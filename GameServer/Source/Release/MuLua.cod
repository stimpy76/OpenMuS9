; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\MuLua.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?sentinel_@@3HB DD 00H					; sentinel_
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	??0MULua@@QAE@XZ				; MULua::MULua
PUBLIC	??1MULua@@QAE@XZ				; MULua::~MULua
PUBLIC	?Create@MULua@@QAE_NXZ				; MULua::Create
PUBLIC	?Release@MULua@@QAEXXZ				; MULua::Release
PUBLIC	?DoFile@MULua@@QAE_NPBD@Z			; MULua::DoFile
PUBLIC	?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z		; MULua::DoFile
PUBLIC	?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; MULua::DoString
PUBLIC	?GetLua@MULua@@QAEPAUlua_State@@XZ		; MULua::GetLua
PUBLIC	?Register@MULua@@QAEXPAX@Z			; MULua::Register
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?MuRequire@@YAHPAUlua_State@@@Z			; MuRequire
PUBLIC	??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_09ENDOEBPC@murequire?$AA@			; `string'
PUBLIC	??_C@_07PINPBNPB@_LOADED?$AA@			; `string'
PUBLIC	??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@ ; `string'
PUBLIC	??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@ ; `string'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_lua_close:PROC
EXTRN	_lua_settop:PROC
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_toboolean:PROC
EXTRN	_lua_tolstring:PROC
EXTRN	_lua_touserdata:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	_lua_pushcclosure:PROC
EXTRN	_lua_pushboolean:PROC
EXTRN	_lua_pushlightuserdata:PROC
EXTRN	_lua_getfield:PROC
EXTRN	_lua_setfield:PROC
EXTRN	_lua_call:PROC
EXTRN	_lua_pcall:PROC
EXTRN	_lua_gc:PROC
EXTRN	_luaL_openlibs:PROC
EXTRN	_luaL_checklstring:PROC
EXTRN	_luaL_error:PROC
EXTRN	_luaL_loadfile:PROC
EXTRN	_luaL_newstate:PROC
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@
CONST	SEGMENT
??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@ DB 'error '
	DB	'loading module ''%s'' from file ''%s'':', 0aH, 09H, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@
CONST	SEGMENT
??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@ DB 'loop or pre'
	DB	'vious error loading module ''%s''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PINPBNPB@_LOADED?$AA@
CONST	SEGMENT
??_C@_07PINPBNPB@_LOADED?$AA@ DB '_LOADED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ENDOEBPC@murequire?$AA@
CONST	SEGMENT
??_C@_09ENDOEBPC@murequire?$AA@ DB 'murequire', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@ DB 'E'
	DB	'rror!!, : %s : State = %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@ DB 'Error!!, : %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ?MuRequire@@YAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?MuRequire@@YAHPAUlua_State@@@Z PROC			; MuRequire, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 117  : 	char *name = NULL;
; 118  : 
; 119  : 	name = gDirPath.GetNewPath( (char*)luaL_checklstring(L, 1, 0) );

  00004	8b 75 08	 mov	 esi, DWORD PTR _L$[ebp]
  00007	57		 push	 edi
  00008	6a 00		 push	 0
  0000a	6a 01		 push	 1
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 _luaL_checklstring
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath

; 120  : 	lua_settop(L, 1);

  00020	6a 01		 push	 1
  00022	56		 push	 esi
  00023	8b f8		 mov	 edi, eax
  00025	e8 00 00 00 00	 call	 _lua_settop

; 121  : 
; 122  : 	lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");

  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_07PINPBNPB@_LOADED?$AA@
  0002f	68 f0 d8 ff ff	 push	 -10000			; ffffd8f0H
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 _lua_getfield

; 123  : 	lua_getfield(L, 2, name);

  0003a	57		 push	 edi
  0003b	6a 02		 push	 2
  0003d	56		 push	 esi
  0003e	e8 00 00 00 00	 call	 _lua_getfield

; 124  : 
; 125  : 	if ( lua_toboolean(L, -1) )

  00043	6a ff		 push	 -1
  00045	56		 push	 esi
  00046	e8 00 00 00 00	 call	 _lua_toboolean
  0004b	83 c4 28	 add	 esp, 40			; 00000028H
  0004e	85 c0		 test	 eax, eax
  00050	74 2e		 je	 SHORT $LN2@MuRequire

; 126  : 	{
; 127  : 		if ( lua_touserdata(L, -1) == sentinel )

  00052	6a ff		 push	 -1
  00054	56		 push	 esi
  00055	e8 00 00 00 00	 call	 _lua_touserdata
  0005a	83 c4 08	 add	 esp, 8
  0005d	3d 00 00 00 00	 cmp	 eax, OFFSET ?sentinel_@@3HB
  00062	0f 85 c8 00 00
	00		 jne	 $LN6@MuRequire

; 128  : 			luaL_error(L, "loop or previous error loading module '%s'", name);

  00068	57		 push	 edi
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DIEJCPFH@loop?5or?5previous?5error?5loading?5m@
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 _luaL_error
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  : 	}
; 156  : 
; 157  : 	return 1;

  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi

; 158  : }

  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN2@MuRequire:

; 129  : 
; 130  : 		return 1;
; 131  : 	}
; 132  : 
; 133  : 
; 134  : 	if ( luaL_loadfile(L, name) )

  00080	57		 push	 edi
  00081	56		 push	 esi
  00082	e8 00 00 00 00	 call	 _luaL_loadfile
  00087	83 c4 08	 add	 esp, 8
  0008a	85 c0		 test	 eax, eax
  0008c	74 2b		 je	 SHORT $LN4@MuRequire

; 135  : 	{
; 136  : 		luaL_error(L, "error loading module '%s' from file '%s':\n\t%s", 

  0008e	6a 00		 push	 0
  00090	6a ff		 push	 -1
  00092	56		 push	 esi
  00093	e8 00 00 00 00	 call	 _lua_tolstring
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	50		 push	 eax
  0009c	57		 push	 edi
  0009d	6a 00		 push	 0
  0009f	6a 01		 push	 1
  000a1	56		 push	 esi
  000a2	e8 00 00 00 00	 call	 _lua_tolstring
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000aa	50		 push	 eax
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KHMIPLKM@error?5loading?5module?5?8?$CFs?8?5from?5f@
  000b0	56		 push	 esi
  000b1	e8 00 00 00 00	 call	 _luaL_error
  000b6	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@MuRequire:

; 137  : 			lua_tolstring(L, 1, 0), name, lua_tolstring(L, -1, 0));
; 138  : 	}
; 139  : 
; 140  : 	lua_pushlightuserdata(L, sentinel);

  000b9	68 00 00 00 00	 push	 OFFSET ?sentinel_@@3HB
  000be	56		 push	 esi
  000bf	e8 00 00 00 00	 call	 _lua_pushlightuserdata

; 141  : 	lua_setfield(L, 2, name);

  000c4	57		 push	 edi
  000c5	6a 02		 push	 2
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 _lua_setfield

; 142  : 	lua_pushstring(L, name);

  000cd	57		 push	 edi
  000ce	56		 push	 esi
  000cf	e8 00 00 00 00	 call	 _lua_pushstring

; 143  : 	lua_call(L, 1, 1);

  000d4	6a 01		 push	 1
  000d6	6a 01		 push	 1
  000d8	56		 push	 esi
  000d9	e8 00 00 00 00	 call	 _lua_call

; 144  : 
; 145  : 	if ( lua_type(L, -1) )

  000de	6a ff		 push	 -1
  000e0	56		 push	 esi
  000e1	e8 00 00 00 00	 call	 _lua_type
  000e6	83 c4 30	 add	 esp, 48			; 00000030H
  000e9	85 c0		 test	 eax, eax
  000eb	74 0c		 je	 SHORT $LN5@MuRequire

; 146  : 		lua_setfield(L, 2, name);

  000ed	57		 push	 edi
  000ee	6a 02		 push	 2
  000f0	56		 push	 esi
  000f1	e8 00 00 00 00	 call	 _lua_setfield
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@MuRequire:

; 147  : 
; 148  : 	lua_getfield(L, 2, name);

  000f9	57		 push	 edi
  000fa	6a 02		 push	 2
  000fc	56		 push	 esi
  000fd	e8 00 00 00 00	 call	 _lua_getfield

; 149  : 
; 150  : 	if ( lua_touserdata(L, -1) == sentinel )

  00102	6a ff		 push	 -1
  00104	56		 push	 esi
  00105	e8 00 00 00 00	 call	 _lua_touserdata
  0010a	83 c4 14	 add	 esp, 20			; 00000014H
  0010d	3d 00 00 00 00	 cmp	 eax, OFFSET ?sentinel_@@3HB
  00112	75 1c		 jne	 SHORT $LN6@MuRequire

; 151  : 	{
; 152  : 		lua_pushboolean(L, 1);

  00114	6a 01		 push	 1
  00116	56		 push	 esi
  00117	e8 00 00 00 00	 call	 _lua_pushboolean

; 153  : 		lua_pushvalue(L, -1);

  0011c	6a ff		 push	 -1
  0011e	56		 push	 esi
  0011f	e8 00 00 00 00	 call	 _lua_pushvalue

; 154  : 		lua_setfield(L, 2, name);

  00124	57		 push	 edi
  00125	6a 02		 push	 2
  00127	56		 push	 esi
  00128	e8 00 00 00 00	 call	 _lua_setfield
  0012d	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN6@MuRequire:

; 155  : 	}
; 156  : 
; 157  : 	return 1;

  00130	5f		 pop	 edi
  00131	b8 01 00 00 00	 mov	 eax, 1
  00136	5e		 pop	 esi

; 158  : }

  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
?MuRequire@@YAHPAUlua_State@@@Z ENDP			; MuRequire
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ?Register@MULua@@QAEXPAX@Z
_TEXT	SEGMENT
_pLua$ = 8						; size = 4
?Register@MULua@@QAEXPAX@Z PROC				; MULua::Register, COMDAT
; _this$ = ecx

; 79   : 	lua_State* pLuaState = (lua_State*)pLua;
; 80   : }

  00000	c2 04 00	 ret	 4
?Register@MULua@@QAEXPAX@Z ENDP				; MULua::Register
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ?GetLua@MULua@@QAEPAUlua_State@@XZ
_TEXT	SEGMENT
?GetLua@MULua@@QAEPAUlua_State@@XZ PROC			; MULua::GetLua, COMDAT
; _this$ = ecx

; 62   : 	return m_luaState;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 63   : }

  00002	c3		 ret	 0
?GetLua@MULua@@QAEPAUlua_State@@XZ ENDP			; MULua::GetLua
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_kString$ = 8						; size = 24
?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; MULua::DoString, COMDAT
; _this$ = ecx

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00003	8b 45 1c	 mov	 eax, DWORD PTR _kString$[ebp+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 0d		 jb	 SHORT $LN121@DoString

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0000b	40		 inc	 eax
  0000c	8d 4d 08	 lea	 ecx, DWORD PTR _kString$[ebp]
  0000f	50		 push	 eax
  00010	ff 75 08	 push	 DWORD PTR _kString$[ebp]
  00013	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN121@DoString:
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp

; 57   : 	return true;

  00018	b0 01		 mov	 al, 1

; 58   : }

  0001a	5d		 pop	 ebp
  0001b	c2 18 00	 ret	 24			; 00000018H
?DoString@MULua@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; MULua::DoString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_szFileName$ = 12					; size = 4
?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z PROC		; MULua::DoFile, COMDAT
; _this$ = ecx

; 52   : 	return true;

  00000	b0 01		 mov	 al, 1

; 53   : }

  00002	c2 08 00	 ret	 8
?DoFile@MULua@@QAE_NPAUlua_State@@PBD@Z ENDP		; MULua::DoFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ?DoFile@MULua@@QAE_NPBD@Z
_TEXT	SEGMENT
_szFileName$ = 8					; size = 4
?DoFile@MULua@@QAE_NPBD@Z PROC				; MULua::DoFile, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 31   : 	int iState = 0;
; 32   : 
; 33   : 	if ( luaL_loadfile(m_luaState, szFileName) )

  00004	ff 75 08	 push	 DWORD PTR _szFileName$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	e8 00 00 00 00	 call	 _luaL_loadfile
  00010	83 c4 08	 add	 esp, 8

; 34   : 	{		
; 35   : 		MsgBox("Error!!, : %s\n", lua_tolstring(m_luaState, -1, 0) );

  00013	6a 00		 push	 0
  00015	6a ff		 push	 -1
  00017	85 c0		 test	 eax, eax
  00019	74 1c		 je	 SHORT $LN2@DoFile
  0001b	ff 36		 push	 DWORD PTR [esi]
  0001d	e8 00 00 00 00	 call	 _lua_tolstring
  00022	50		 push	 eax
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PHJEEFEJ@Error?$CB?$CB?0?5?3?5?$CFs?6?$AA@
  00028	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0002d	83 c4 14	 add	 esp, 20			; 00000014H

; 36   : 		return false;

  00030	32 c0		 xor	 al, al
  00032	5e		 pop	 esi

; 48   : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN2@DoFile:

; 37   : 	}
; 38   : 
; 39   :     iState = lua_pcall(m_luaState, 0, -1, 0);

  00037	6a 00		 push	 0
  00039	ff 36		 push	 DWORD PTR [esi]
  0003b	e8 00 00 00 00	 call	 _lua_pcall
  00040	83 c4 10	 add	 esp, 16			; 00000010H

; 40   : 
; 41   : 	if ( iState )

  00043	85 c0		 test	 eax, eax
  00045	74 24		 je	 SHORT $LN3@DoFile

; 42   : 	{
; 43   : 		MsgBox("Error!!, : %s : State = %d\n", lua_tolstring(m_luaState, -1, 0) , iState);

  00047	50		 push	 eax
  00048	6a 00		 push	 0
  0004a	6a ff		 push	 -1
  0004c	ff 36		 push	 DWORD PTR [esi]
  0004e	e8 00 00 00 00	 call	 _lua_tolstring
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	50		 push	 eax
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LGOJPEJD@Error?$CB?$CB?0?5?3?5?$CFs?5?3?5State?5?$DN?5?$CFd?6?$AA@
  0005c	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 44   : 		return false;

  00064	32 c0		 xor	 al, al
  00066	5e		 pop	 esi

; 48   : }

  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
$LN3@DoFile:

; 45   : 	}
; 46   : 
; 47   : 	return true;	

  0006b	b0 01		 mov	 al, 1
  0006d	5e		 pop	 esi

; 48   : }

  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
?DoFile@MULua@@QAE_NPBD@Z ENDP				; MULua::DoFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ?Release@MULua@@QAEXXZ
_TEXT	SEGMENT
?Release@MULua@@QAEXXZ PROC				; MULua::Release, COMDAT
; _this$ = ecx

; 83   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 84   : 	if(m_luaState)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN2@Release

; 85   : 	{
; 86   : 		lua_close(m_luaState);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _lua_close
  0000f	83 c4 04	 add	 esp, 4

; 87   : 		m_luaState = NULL;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN2@Release:
  00018	5e		 pop	 esi

; 88   : 	}
; 89   : }

  00019	c3		 ret	 0
?Release@MULua@@QAEXXZ ENDP				; MULua::Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ?Create@MULua@@QAE_NXZ
_TEXT	SEGMENT
?Create@MULua@@QAE_NXZ PROC				; MULua::Create, COMDAT
; _this$ = ecx

; 66   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 67   : 	m_luaState = luaL_newstate();

  00003	e8 00 00 00 00	 call	 _luaL_newstate

; 68   : 
; 69   : 	luaL_openlibs(m_luaState);

  00008	50		 push	 eax
  00009	89 06		 mov	 DWORD PTR [esi], eax
  0000b	e8 00 00 00 00	 call	 _luaL_openlibs

; 70   : 	lua_pushcclosure(m_luaState, MuRequire, 0);

  00010	6a 00		 push	 0
  00012	68 00 00 00 00	 push	 OFFSET ?MuRequire@@YAHPAUlua_State@@@Z ; MuRequire
  00017	ff 36		 push	 DWORD PTR [esi]
  00019	e8 00 00 00 00	 call	 _lua_pushcclosure

; 71   : 	lua_setfield(m_luaState, LUA_GLOBALSINDEX, "murequire");

  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_09ENDOEBPC@murequire?$AA@
  00023	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00028	ff 36		 push	 DWORD PTR [esi]
  0002a	e8 00 00 00 00	 call	 _lua_setfield

; 72   : 	lua_gc(m_luaState, LUA_GCCOLLECT, 0);

  0002f	6a 00		 push	 0
  00031	6a 02		 push	 2
  00033	ff 36		 push	 DWORD PTR [esi]
  00035	e8 00 00 00 00	 call	 _lua_gc
  0003a	83 c4 28	 add	 esp, 40			; 00000028H

; 73   : 
; 74   : 	return true;

  0003d	b0 01		 mov	 al, 1
  0003f	5e		 pop	 esi

; 75   : }

  00040	c3		 ret	 0
?Create@MULua@@QAE_NXZ ENDP				; MULua::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ??1MULua@@QAE@XZ
_TEXT	SEGMENT
??1MULua@@QAE@XZ PROC					; MULua::~MULua, COMDAT
; _this$ = ecx

; 26   : 	Release();

  00000	e9 00 00 00 00	 jmp	 ?Release@MULua@@QAEXXZ	; MULua::Release
??1MULua@@QAE@XZ ENDP					; MULua::~MULua
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ??0MULua@@QAE@XZ
_TEXT	SEGMENT
??0MULua@@QAE@XZ PROC					; MULua::MULua, COMDAT
; _this$ = ecx

; 19   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 18   : m_luaState(NULL)

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 20   : 	Create();

  00009	e8 00 00 00 00	 call	 ?Create@MULua@@QAE_NXZ	; MULua::Create

; 21   : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0MULua@@QAE@XZ ENDP					; MULua::MULua
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<char>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2229 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2230 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 26		 je	 SHORT $LN4@Tidy

; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 20		 jb	 SHORT $LN4@Tidy

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN58@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN58@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	8b ce		 mov	 ecx, esi
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00035	5b		 pop	 ebx
$LN4@Tidy:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres
; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}
; 516  : 
; 517  : 	union _Bxty
; 518  : 		{	// storage for small buffer or pointer to larger one
; 519  : 		value_type _Buf[_BUF_SIZE];
; 520  : 		pointer _Ptr;
; 521  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 522  : 		} _Bx;
; 523  : 
; 524  : 	size_type _Mysize;	// current length of string
; 525  : 	size_type _Myres;	// current storage reserved for string
; 526  : 	};
; 527  : 
; 528  : 		// TEMPLATE CLASS _String_alloc
; 529  : template<class _Alloc_types>
; 530  : 	class _String_alloc
; 531  : 	{	// base class for basic_string to hold allocator
; 532  : public:
; 533  : 	typedef _String_alloc<_Alloc_types> _Myt;
; 534  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 535  : 	typedef typename _Alloc_types::_Alty _Alty;
; 536  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 537  : 
; 538  : 	typedef typename _Val_types::value_type value_type;
; 539  : 	typedef typename _Val_types::size_type size_type;
; 540  : 	typedef typename _Val_types::difference_type difference_type;
; 541  : 	typedef typename _Val_types::pointer pointer;
; 542  : 	typedef typename _Val_types::const_pointer const_pointer;
; 543  : 	typedef typename _Val_types::reference reference;
; 544  : 	typedef typename _Val_types::const_reference const_reference;
; 545  : 
; 546  : 	typedef _String_iterator<_String_val<_Val_types> > iterator;
; 547  : 	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;
; 548  : 
; 549  : 	enum
; 550  : 		{	// length of internal buffer, [1, 16]
; 551  : 		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
; 552  : 		};
; 553  : 
; 554  : 	enum
; 555  : 		{	// roundup mask for allocated buffers, [0, 15]
; 556  : 		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
; 557  : 		};
; 558  : 
; 559  : 	value_type *_Myptr()
; 560  : 		{	// determine current pointer to buffer for mutable string
; 561  : 		return (_Get_data()._Myptr());
; 562  : 		}
; 563  : 
; 564  : 	const value_type *_Myptr() const
; 565  : 		{	// determine current pointer to buffer for nonmutable string
; 566  : 		return (_Get_data()._Myptr());
; 567  : 		}
; 568  : 
; 569  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 570  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 571  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 572  : 		{	// construct allocator from _Al
; 573  : 		}
; 574  : 
; 575  : 	_String_alloc(_Alloc&& _Al)
; 576  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 577  : 		{	// construct allocator from _Al
; 578  : 		}
; 579  : 
; 580  : 	void _Copy_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Pocca(_Getal(), _Al);
; 583  : 		}
; 584  : 
; 585  : 	void _Move_alloc(_Alty& _Al)
; 586  : 		{	// replace old allocator
; 587  : 		_Pocma(_Getal(), _Al);
; 588  : 		}
; 589  : 
; 590  : 	void _Swap_alloc(_Myt& _Right)
; 591  : 		{	// swap allocators
; 592  : 		_Pocs(_Getal(), _Right._Getal());
; 593  : 		}
; 594  : 
; 595  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 596  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 597  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 598  : 		{	// construct allocator from _Al
; 599  : 		_Alloc_proxy();
; 600  : 		}
; 601  : 
; 602  : 	_String_alloc(_Alloc&& _Al)
; 603  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 604  : 		{	// construct allocator from _Al
; 605  : 		_Alloc_proxy();
; 606  : 		}
; 607  : 
; 608  : 	~_String_alloc() _NOEXCEPT
; 609  : 		{	// destroy the object
; 610  : 		_Free_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Copy_alloc(const _Alty& _Al)
; 614  : 		{	// replace old allocator
; 615  : 		_Free_proxy();
; 616  : 		_Pocca(_Getal(), _Al);
; 617  : 		_Alloc_proxy();
; 618  : 		}
; 619  : 
; 620  : 	void _Move_alloc(_Alty& _Al)
; 621  : 		{	// replace old allocator
; 622  : 		_Free_proxy();
; 623  : 		_Pocma(_Getal(), _Al);
; 624  : 		_Alloc_proxy();
; 625  : 		}
; 626  : 
; 627  : 	void _Swap_alloc(_Myt& _Right)
; 628  : 		{	// swap allocators
; 629  : 		_Pocs(_Getal(), _Right._Getal());
; 630  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 631  : 		}
; 632  : 
; 633  : 	void _Alloc_proxy()
; 634  : 		{	// construct proxy
; 635  : 		typename _Alty::template rebind<_Container_proxy>::other
; 636  : 			_Alproxy(_Getal());
; 637  : 		_Myproxy() = _Alproxy.allocate(1);
; 638  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 639  : 		_Myproxy()->_Mycont = &_Get_data();
; 640  : 		}
; 641  : 
; 642  : 	void _Free_proxy()
; 643  : 		{	// destroy proxy
; 644  : 		typename _Alty::template rebind<_Container_proxy>::other
; 645  : 			_Alproxy(_Getal());
; 646  : 		_Orphan_all();
; 647  : 		_Alproxy.destroy(_Myproxy());
; 648  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 649  : 		_Myproxy() = 0;
; 650  : 		}
; 651  : 
; 652  : 	_Iterator_base12 **_Getpfirst() const
; 653  : 		{	// get address of iterator chain
; 654  : 		return (_Get_data()._Getpfirst());
; 655  : 		}
; 656  : 
; 657  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 658  : 		{	// return reference to _Myproxy
; 659  : 		return (_Get_data()._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 663  : 		{	// return const reference to _Myproxy
; 664  : 		return (_Get_data()._Myproxy);
; 665  : 		}
; 666  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 667  : 
; 668  : 	void _Orphan_all()
; 669  : 		{	// orphan all iterators
; 670  : 		_Get_data()._Orphan_all();
; 671  : 		}
; 672  : 
; 673  : 	void _Swap_all(_Myt& _Right)
; 674  : 		{	// swap all iterators
; 675  : 		_Get_data()._Swap_all(_Right._Get_data());
; 676  : 		}
; 677  : 
; 678  : 	_Alty& _Getal() _NOEXCEPT
; 679  : 		{	// return reference to allocator
; 680  : 		return (_Mypair._Get_first());
; 681  : 		}
; 682  : 
; 683  : 	const _Alty& _Getal() const _NOEXCEPT
; 684  : 		{	// return const reference to allocator
; 685  : 		return (_Mypair._Get_first());
; 686  : 		}
; 687  : 
; 688  : 	_String_val<_Val_types>& _Get_data() _NOEXCEPT
; 689  : 		{	// return reference to _String_val
; 690  : 		return (_Mypair._Get_second());
; 691  : 		}
; 692  : 
; 693  : 	const _String_val<_Val_types>& _Get_data() const _NOEXCEPT
; 694  : 		{	// return const reference to _String_val
; 695  : 		return (_Mypair._Get_second());
; 696  : 		}
; 697  : 
; 698  : 	typedef typename _String_val<_Val_types>::_Bxty _Bxty;
; 699  : 
; 700  : 	_Bxty& _Bx() _NOEXCEPT
; 701  : 		{	// return reference to _Bx
; 702  : 		return (_Get_data()._Bx);
; 703  : 		}
; 704  : 
; 705  : 	const _Bxty& _Bx() const _NOEXCEPT
; 706  : 		{	// return const reference to _Bx
; 707  : 		return (_Get_data()._Bx);
; 708  : 		}
; 709  : 
; 710  : 	size_type& _Mysize() _NOEXCEPT
; 711  : 		{	// return reference to _Mysize
; 712  : 		return (_Get_data()._Mysize);
; 713  : 		}
; 714  : 
; 715  : 	const size_type& _Mysize() const _NOEXCEPT
; 716  : 		{	// return const reference to _Mysize
; 717  : 		return (_Get_data()._Mysize);
; 718  : 		}
; 719  : 
; 720  : 	size_type& _Myres() _NOEXCEPT
; 721  : 		{	// return reference to _Myres
; 722  : 		return (_Get_data()._Myres);
; 723  : 		}
; 724  : 
; 725  : 	const size_type& _Myres() const _NOEXCEPT
; 726  : 		{	// return const reference to _Myres
; 727  : 		return (_Get_data()._Myres);
; 728  : 		}
; 729  : 
; 730  : private:
; 731  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 732  : 	};
; 733  : 
; 734  : 		// TEMPLATE CLASS basic_string
; 735  : template<class _Elem,
; 736  : 	class _Traits,
; 737  : 	class _Alloc>
; 738  : 	class basic_string
; 739  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 740  : 	{	// null-terminated transparent array of elements
; 741  : public:
; 742  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 743  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 744  : 	typedef _Traits traits_type;
; 745  : 	typedef _Alloc allocator_type;
; 746  : 
; 747  : 	typedef typename _Mybase::_Alty _Alty;
; 748  : 
; 749  : 	typedef typename _Mybase::value_type value_type;
; 750  : 	typedef typename _Mybase::size_type size_type;
; 751  : 	typedef typename _Mybase::difference_type difference_type;
; 752  : 	typedef typename _Mybase::pointer pointer;
; 753  : 	typedef typename _Mybase::const_pointer const_pointer;
; 754  : 	typedef typename _Mybase::reference reference;
; 755  : 	typedef typename _Mybase::const_reference const_reference;
; 756  : 
; 757  : 	typedef typename _Mybase::iterator iterator;
; 758  : 	typedef typename _Mybase::const_iterator const_iterator;
; 759  : 
; 760  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 761  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 762  : 
; 763  : 	basic_string(const _Myt& _Right)
; 764  : 
; 765  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 766  : 
; 767  : 
; 768  : 		{	// construct by copying _Right
; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);
; 771  : 		}
; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0003d	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00040	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00044	72 0c		 jb	 SHORT $LN104@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00046	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00048	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2243 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
$LN104@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00052	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2243 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2199 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00003	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00006	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00009	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0000d	72 0a		 jb	 SHORT $LN22@Eos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2201 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN22@Eos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2201 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1005 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)
; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)
; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow
; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)
; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do
; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 09		 jb	 SHORT $LN6@basic_stri

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00022	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00026	72 07		 jb	 SHORT $LN106@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1007 : 		}

  0002e	c3		 ret	 0
$LN106@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1007 : 		}

  00033	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 722  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 723  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 712  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 713  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 702  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 690  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 691  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 680  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 681  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr

; 561  : 		return (_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 562  : 		}

  00008	c3		 ret	 0
$LN11@Myptr:

; 561  : 		return (_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 562  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00009	8b c1		 mov	 eax, ecx

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]

; 139  : 	}
; 140  : 
; 141  : 		// TEMPLATE FUNCTION _Construct
; 142  : template<class _Ty1,
; 143  : 	class _Ty2> inline
; 144  : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 145  : 	{	// construct object at _Ptr with value _Val
; 146  : 	void *_Vptr = _Ptr;
; 147  : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 148  : 	}
; 149  : 
; 150  : template<class _Ty1> inline
; 151  : 	void _Construct(_Ty1 *_Ptr)
; 152  : 	{	// construct object at _Ptr with default value
; 153  : 	void *_Vptr = _Ptr;
; 154  : 
; 155  : 	::new (_Vptr) _Ty1();
; 156  : 	}
; 157  : 
; 158  : 		// TEMPLATE FUNCTION _Destroy
; 159  : template<class _Ty> inline
; 160  : 	void _Destroy(_Ty *_Ptr)
; 161  : 	{	// destroy object at _Ptr
; 162  : 	_Ptr->~_Ty();
; 163  : 	}
; 164  : 
; 165  : 		// TEMPLATE FUNCTION _Destroy_range
; 166  : template<class _Alloc> inline
; 167  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 168  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 169  : 		_Nonscalar_ptr_iterator_tag)
; 170  : 	{	// destroy [_First, _Last), arbitrary type
; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}
; 174  : 
; 175  : template<class _Alloc> inline
; 176  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 177  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 178  : 		_Scalar_ptr_iterator_tag)
; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 180  : 	}
; 181  : 
; 182  : template<class _Alloc> inline
; 183  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 184  : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 185  : 	{	// destroy [_First, _Last)
; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}
; 188  : 
; 189  : 		// TEMPLATE CLASS _Is_simple_alloc
; 190  : template<class _Alty>
; 191  : 	struct _Is_simple_alloc
; 192  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 193  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 194  : 		&& is_same<typename _Alty::pointer,
; 195  : 			typename _Alty::value_type *>::value
; 196  : 		&& is_same<typename _Alty::const_pointer,
; 197  : 			const typename _Alty::value_type *>::value
; 198  : 		&& is_same<typename _Alty::reference,
; 199  : 			typename _Alty::value_type&>::value
; 200  : 		&& is_same<typename _Alty::const_reference,
; 201  : 			const typename _Alty::value_type&>::value>
; 202  : 	{	// tests if allocator has simple addressing
; 203  : 	};
; 204  : 
; 205  : 		// TEMPLATE CLASS _Simple_types
; 206  : template<class _Value_type>
; 207  : 	struct _Simple_types
; 208  : 	{	// wraps types needed by iterators
; 209  : 	typedef _Value_type value_type;
; 210  : 	typedef size_t size_type;
; 211  : 	typedef ptrdiff_t difference_type;
; 212  : 	typedef value_type *pointer;
; 213  : 	typedef const value_type *const_pointer;
; 214  : 	typedef value_type& reference;
; 215  : 	typedef const value_type& const_reference;
; 216  : 	};
; 217  : 
; 218  : 		// TEMPLATE CLASS _Get_voidptr
; 219  : template<class _Alty,
; 220  : 	class _Pointer>
; 221  : 	struct _Get_voidptr
; 222  : 	{	// get void pointer for allocator
; 223  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 224  : 	typedef typename _Alvoid::pointer type;
; 225  : 	};
; 226  : 
; 227  : template<class _Alty,
; 228  : 	class _Ty>
; 229  : 	struct _Get_voidptr<_Alty, _Ty *>
; 230  : 	{	// get raw void pointer for allocator
; 231  : 	typedef void *type;
; 232  : 	};
; 233  : 
; 234  : 		// TEMPLATE STRUCT _Get_first_parameter
; 235  : template<class _Ty>
; 236  : 	struct _Get_first_parameter;
; 237  : 
; 238  : template<template<class, class...> class _Ty,
; 239  : 	class _First,
; 240  : 	class... _Rest>
; 241  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 242  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 243  : 	typedef _First type;
; 244  : 	};
; 245  : 
; 246  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 247  : template<class _Newfirst,
; 248  : 	class _Ty>
; 249  : 	struct _Replace_first_parameter;
; 250  : 
; 251  : template<class _Newfirst,
; 252  : 	template<class, class...> class _Ty,
; 253  : 	class _First,
; 254  : 	class... _Rest>
; 255  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 256  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 257  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 258  : 	};
; 259  : 
; 260  : 		// TEMPLATE STRUCT _Get_element_type
; 261  : template<class _Ty>
; 262  : 	struct _Get_element_type
; 263  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 264  : 		typename _Get_first_parameter<_Uty>::type);
; 265  : 
; 266  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 267  : template<class _Ty>
; 268  : 	struct _Get_ptr_difference_type
; 269  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 270  : 		ptrdiff_t);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_rebind_type
; 273  : template<class _Ty,
; 274  : 	class _Other>
; 275  : 	struct _Get_rebind_type
; 276  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 277  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 278  : 
; 279  : 		// TEMPLATE CLASS pointer_traits
; 280  : template<class _Ty>
; 281  : 	struct pointer_traits
; 282  : 	{	// defines traits for arbitrary pointers
; 283  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 284  : 	typedef _Ty pointer;
; 285  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 286  : 
; 287  : 	template<class _Other>
; 288  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 289  : 
; 290  : 	typedef typename _If<is_void<element_type>::value,
; 291  : 		char&,
; 292  : 		typename add_lvalue_reference<element_type>::type>::type _Reftype;
; 293  : 
; 294  : 	static pointer pointer_to(_Reftype _Val)
; 295  : 		{	// convert raw reference to pointer
; 296  : 		return (_Ty::pointer_to(_Val));
; 297  : 		}
; 298  : 	};
; 299  : 
; 300  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 301  : template<class _Ty>
; 302  : 	struct pointer_traits<_Ty *>
; 303  : 	{	// defines traits for raw pointers
; 304  : 	typedef _Ty element_type;
; 305  : 	typedef _Ty *pointer;
; 306  : 	typedef ptrdiff_t difference_type;
; 307  : 
; 308  : 	template<class _Other>
; 309  : 		using rebind = _Other *;
; 310  : 
; 311  : 	typedef typename _If<is_void<_Ty>::value,
; 312  : 		char&,
; 313  : 		typename add_lvalue_reference<_Ty>::type>::type _Reftype;
; 314  : 
; 315  : 	static pointer pointer_to(_Reftype _Val)
; 316  : 		{	// convert raw reference to pointer
; 317  : 		return (_STD addressof(_Val));
; 318  : 		}
; 319  : 	};
; 320  : 
; 321  : 		// TEMPLATE STRUCT _Get_pointer_type
; 322  : template<class _Ty>
; 323  : 	struct _Get_pointer_type
; 324  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 325  : 		typename _Ty::value_type *);
; 326  : 
; 327  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 328  : template<class _Ty>
; 329  : 	struct _Get_const_pointer_type
; 330  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 331  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 332  : 			::template rebind<const typename _Ty::value_type>);
; 333  : 
; 334  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 335  : template<class _Ty>
; 336  : 	struct _Get_void_pointer_type
; 337  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 338  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 339  : 			::template rebind<void>);
; 340  : 
; 341  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 342  : template<class _Ty>
; 343  : 	struct _Get_const_void_pointer_type
; 344  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 345  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 346  : 			::template rebind<const void>);
; 347  : 
; 348  : 		// TEMPLATE STRUCT _Get_difference_type
; 349  : template<class _Ty>
; 350  : 	struct _Get_difference_type
; 351  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 352  : 		typename _Get_ptr_difference_type<
; 353  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 354  : 
; 355  : 		// TEMPLATE STRUCT _Get_size_type
; 356  : template<class _Ty>
; 357  : 	struct _Get_size_type
; 358  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 359  : 		typename make_unsigned<
; 360  : 			typename _Get_difference_type<_Ty>::type>::type);
; 361  : 
; 362  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 363  : template<class _Ty>
; 364  : 	struct _Get_propagate_on_container_copy
; 365  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 366  : 		false_type);
; 367  : 
; 368  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 369  : template<class _Ty>
; 370  : 	struct _Get_propagate_on_container_move
; 371  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 372  : 		false_type);
; 373  : 
; 374  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 375  : template<class _Ty>
; 376  : 	struct _Get_propagate_on_container_swap
; 377  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 378  : 		false_type);
; 379  : 
; 380  : 		// TEMPLATE STRUCT _Get_is_always_equal
; 381  : template<class _Ty>
; 382  : 	struct _Get_is_always_equal
; 383  : 	_GET_TYPE_OR_DEFAULT(is_always_equal,
; 384  : 		typename is_empty<_Ty>::type);
; 385  : 
; 386  : 		// STRUCT _Alloc_allocate
; 387  : struct _Alloc_allocate
; 388  : 	{	// determines allocator_traits<_Alloc>
; 389  : 		// ::allocate(size_type, const_void_pointer)
; 390  : 
; 391  : 	template<class _Alloc,
; 392  : 		class _Size_type,
; 393  : 		class _Const_void_pointer>
; 394  : 		static auto _Fn(int, _Alloc& _Al,
; 395  : 			_Size_type _Count,
; 396  : 			_Const_void_pointer _Hint)
; 397  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 398  : 		{	// call allocator supplied version
; 399  : 		return (_Al.allocate(_Count, _Hint));
; 400  : 		}
; 401  : 
; 402  : 	template<class _Alloc,
; 403  : 		class _Size_type,
; 404  : 		class _Const_void_pointer>
; 405  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 406  : 			_Size_type _Count,
; 407  : 			_Const_void_pointer)
; 408  : 			-> decltype(_Al.allocate(_Count))
; 409  : 		{	// call default version
; 410  : 		return (_Al.allocate(_Count));
; 411  : 		}
; 412  : 	};
; 413  : 
; 414  : 		// STRUCT _Alloc_construct
; 415  : struct _Alloc_construct
; 416  : 	{	// determines allocator_traits<_Ty>
; 417  : 		// ::construct(_Ty&, _Objty *, _Types&&...)
; 418  : 
; 419  : 	template<class _Ty,
; 420  : 		class _Objty,
; 421  : 		class... _Types>
; 422  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 423  : 			_Types&&... _Args)
; 424  : 			-> void_t<decltype(
; 425  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))>
; 426  : 		{	// call allocator supplied version
; 427  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 428  : 		}
; 429  : 
; 430  : 	template<class _Ty,
; 431  : 		class _Objty,
; 432  : 		class... _Types>
; 433  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 434  : 			_Types&&... _Args)
; 435  : 		{	// call default version
; 436  : 		::new (static_cast<void *>(_Ptr))
; 437  : 			_Objty(_STD forward<_Types>(_Args)...);
; 438  : 		}
; 439  : 
; 440  : 	};
; 441  : 
; 442  : 		// STRUCT _Alloc_destroy
; 443  : struct _Alloc_destroy
; 444  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 445  : 	template<class _Ty,
; 446  : 		class _Objty>
; 447  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 448  : 			-> void_t<decltype(_Al.destroy(_Ptr))>
; 449  : 		{	// call allocator supplied version
; 450  : 		_Al.destroy(_Ptr);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty,
; 454  : 		class _Objty>
; 455  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 456  : 		{	// call default version
; 457  : 		_Ptr->~_Objty();
; 458  : 		}
; 459  : 	};
; 460  : 
; 461  : 		// STRUCT _Alloc_max_size
; 462  : struct _Alloc_max_size
; 463  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 464  : 	template<class _Ty>
; 465  : 		static auto _Fn(int, const _Ty& _Al) _NOEXCEPT
; 466  : 			-> decltype(_Al.max_size())
; 467  : 		{	// call allocator supplied version
; 468  : 		return (_Al.max_size());
; 469  : 		}
; 470  : 
; 471  : 	template<class _Ty>
; 472  : 		static auto _Fn(_Wrap_int, const _Ty&) _NOEXCEPT
; 473  : 			-> typename _Get_size_type<_Ty>::type
; 474  : 		{	// call default version
; 475  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 476  : 		}
; 477  : 	};
; 478  : 
; 479  : 		// STRUCT _Alloc_select
; 480  : struct _Alloc_select
; 481  : 	{	// determines allocator_traits<_Ty>
; 482  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 483  : 
; 484  : 	template<class _Ty>
; 485  : 		static auto _Fn(int, const _Ty& _Al)
; 486  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 487  : 		{	// call allocator supplied version
; 488  : 		return (_Al.select_on_container_copy_construction());
; 489  : 		}
; 490  : 
; 491  : 	template<class _Ty>
; 492  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 493  : 			-> _Ty
; 494  : 		{	// call default version
; 495  : 		return (_Al);
; 496  : 		}
; 497  : 	};
; 498  : 
; 499  : 		// TEMPLATE CLASS allocator_traits
; 500  : template<class _Alloc>
; 501  : 	struct allocator_traits
; 502  : 	{	// defines traits for allocators
; 503  : 	typedef _Alloc allocator_type;
; 504  : 	typedef typename _Alloc::value_type value_type;
; 505  : 
; 506  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 507  : 		pointer;
; 508  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 509  : 		const_pointer;
; 510  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 511  : 		void_pointer;
; 512  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 513  : 		const_void_pointer;
; 514  : 
; 515  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 516  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 517  : 
; 518  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 519  : 		propagate_on_container_copy_assignment;
; 520  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 521  : 		propagate_on_container_move_assignment;
; 522  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 523  : 		propagate_on_container_swap;
; 524  : 	typedef typename _Get_is_always_equal<_Alloc>::type
; 525  : 		is_always_equal;
; 526  : 
; 527  : 	template<class _Other>
; 528  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 529  : 
; 530  : 	template<class _Other>
; 531  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 532  : 
; 533  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count)
; 534  : 		{	// allocate array of _Count elements
; 535  : 		return (_Al.allocate(_Count));
; 536  : 		}
; 537  : 
; 538  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count,
; 539  : 		const_void_pointer _Hint)
; 540  : 		{	// allocate array of _Count elements, with hint
; 541  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 542  : 		}
; 543  : 
; 544  : 	static void deallocate(_Alloc& _Al,
; 545  : 		pointer _Ptr, size_type _Count)
; 546  : 		{	// deallocate _Count elements at _Ptr
; 547  : 		_Al.deallocate(_Ptr, _Count);
; 548  : 		}
; 549  : 
; 550  : 	template<class _Ty,
; 551  : 		class... _Types>
; 552  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 553  : 			_Types&&... _Args)
; 554  : 		{	// construct _Ty(_Types...) at _Ptr
; 555  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 556  : 			_STD forward<_Types>(_Args)...);
; 557  : 		}
; 558  : 
; 559  : 
; 560  : 	template<class _Ty>
; 561  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 562  : 		{	// destroy object at _Ptr
; 563  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 564  : 		}
; 565  : 
; 566  : 	static size_type max_size(const _Alloc& _Al) _NOEXCEPT
; 567  : 		{	// get maximum size
; 568  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 569  : 		}
; 570  : 
; 571  : 	static _Alloc select_on_container_copy_construction(
; 572  : 		const _Alloc& _Al)
; 573  : 		{	// get allocator to use
; 574  : 		return (_Alloc_select::_Fn(0, _Al));
; 575  : 		}
; 576  : 	};
; 577  : 
; 578  : 		// TEMPLATE CLASS allocator
; 579  : template<class _Ty>
; 580  : 	class allocator
; 581  : 	{	// generic allocator for objects of class _Ty
; 582  : public:
; 583  : 	static_assert(!is_const<_Ty>::value,
; 584  : 		"The C++ Standard forbids containers of const elements "
; 585  : 		"because allocator<const T> is ill-formed.");
; 586  : 
; 587  : 	typedef _Ty value_type;
; 588  : 
; 589  : 	typedef value_type *pointer;
; 590  : 	typedef const value_type *const_pointer;
; 591  : 
; 592  : 	typedef value_type& reference;
; 593  : 	typedef const value_type& const_reference;
; 594  : 
; 595  : 	typedef size_t size_type;
; 596  : 	typedef ptrdiff_t difference_type;
; 597  : 
; 598  : 	typedef true_type propagate_on_container_move_assignment;
; 599  : 	typedef true_type is_always_equal;
; 600  : 
; 601  : 	template<class _Other>
; 602  : 		struct rebind
; 603  : 		{	// convert this type to allocator<_Other>
; 604  : 		typedef allocator<_Other> other;
; 605  : 		};
; 606  : 
; 607  : 	pointer address(reference _Val) const _NOEXCEPT
; 608  : 		{	// return address of mutable _Val
; 609  : 		return (_STD addressof(_Val));
; 610  : 		}
; 611  : 
; 612  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 613  : 		{	// return address of nonmutable _Val
; 614  : 		return (_STD addressof(_Val));
; 615  : 		}
; 616  : 
; 617  : 	allocator() _THROW0()
; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}
; 620  : 
; 621  : 	allocator(const allocator<_Ty>&) _THROW0()
; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}
; 624  : 
; 625  : 	template<class _Other>
; 626  : 		allocator(const allocator<_Other>&) _THROW0()
; 627  : 		{	// construct from a related allocator (do nothing)
; 628  : 		}
; 629  : 
; 630  : 	template<class _Other>
; 631  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 632  : 		{	// assign from a related allocator (do nothing)
; 633  : 		return (*this);
; 634  : 		}
; 635  : 
; 636  : 	void deallocate(pointer _Ptr, size_type _Count)
; 637  : 		{	// deallocate object at _Ptr
; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	83 f9 ff	 cmp	 ecx, -1
  0000c	77 2e		 ja	 SHORT $LN16@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;
; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 19		 jb	 SHORT $LN7@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00016	a8 1f		 test	 al, 31			; 0000001fH
  00018	75 27		 jne	 SHORT $LN18@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001a	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0001d	3b c8		 cmp	 ecx, eax
  0001f	73 25		 jae	 SHORT $LN19@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00021	2b c1		 sub	 eax, ecx
  00023	83 f8 04	 cmp	 eax, 4
  00026	72 23		 jb	 SHORT $LN20@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00028	83 f8 23	 cmp	 eax, 35			; 00000023H
  0002b	77 23		 ja	 SHORT $LN21@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002d	8b c1		 mov	 eax, ecx
$LN7@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4

; 909  : 		_Mybase::deallocate(_Ptr, _Count);
; 910  : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN16@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  0003c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  00055	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	83 f9 ff	 cmp	 ecx, -1
  0000c	77 2e		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;
; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 19		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00016	a8 1f		 test	 al, 31			; 0000001fH
  00018	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001a	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0001d	3b c8		 cmp	 ecx, eax
  0001f	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00021	2b c1		 sub	 eax, ecx
  00023	83 f8 04	 cmp	 eax, 4
  00026	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00028	83 f8 23	 cmp	 eax, 35			; 00000023H
  0002b	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002d	8b c1		 mov	 eax, ecx
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4

; 639  : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  0003c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00055	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 530  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00012	5d		 pop	 ebp

; 530  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mulua.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 159  : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
