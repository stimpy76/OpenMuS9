; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\Event.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?pEventObj@@3PAUOBJECTSTRUCT@@A			; pEventObj
PUBLIC	?g_bRingEventItemTextLoad@@3HA			; g_bRingEventItemTextLoad
PUBLIC	?g_sz2ANV_GIFT_NAME@@3PAY0EA@DA			; g_sz2ANV_GIFT_NAME
_BSS	SEGMENT
?pEventObj@@3PAUOBJECTSTRUCT@@A DD 01H DUP (?)		; pEventObj
?g_bRingEventItemTextLoad@@3HA DD 01H DUP (?)		; g_bRingEventItemTextLoad
?g_sz2ANV_GIFT_NAME@@3PAY0EA@DA DB 0c80H DUP (?)	; g_sz2ANV_GIFT_NAME
_BSS	ENDS
CONST	SEGMENT
?g_szRingEventOfflineGift@@3QAY0CA@$$CBDA DB '100', 0b5H, 0b7H, ' ', 0b9H
	DB	0c2H, 0b9H, 0ddH, 0c1H, 0f6H, 00H		; g_szRingEventOfflineGift
	ORG $+19
	DB	'10', 0b5H, 0b7H, ' ', 0b9H, 0c2H, 0b9H, 0ddH, 0c1H, 0f6H
	DB	00H
	ORG $+20
	DB	'5', 0b5H, 0b7H, ' ', 0b9H, 0c2H, 0b9H, 0ddH, 0c1H, 0f6H, 00H
	ORG $+21
	DB	'2', 0b5H, 0b7H, ' ', 0b9H, 0c2H, 0b9H, 0ddH, 0c1H, 0f6H, 00H
	ORG $+21
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?EventChipEventProtocolCore@@YAXEPAEH@Z		; EventChipEventProtocolCore
PUBLIC	?DataSendEventChip@@YAXPADH@Z			; DataSendEventChip
PUBLIC	?EGRecvEventChipInfo@@YAXPAUPMSG_ANS_VIEW_EC_MN@@@Z ; EGRecvEventChipInfo
PUBLIC	?EGResultRegEventChip@@YAXPAUPMSG_ANS_REGISTER_EVENTCHIP@@@Z ; EGResultRegEventChip
PUBLIC	?EGRecvRegMutoNum@@YAXPAUPMSG_ANS_REGISTER_MUTONUM@@@Z ; EGRecvRegMutoNum
PUBLIC	?EGRecvChangeRena@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ; EGRecvChangeRena
PUBLIC	?EGRecvStoneInfo@@YAXPAUPMSG_ANS_VIEW_STONES@@@Z ; EGRecvStoneInfo
PUBLIC	?EGRecvRegStone@@YAXPAUPMSG_ANS_REGISTER_STONES@@@Z ; EGRecvRegStone
PUBLIC	?EGRecvDeleteStone@@YAXPAUPMSG_ANS_DELETE_STONES@@@Z ; EGRecvDeleteStone
PUBLIC	?EGRecvChangeStones@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ; EGRecvChangeStones
PUBLIC	?EGRecv2AnvRegSerial@@YAXPAUPMSG_ANS_2ANIV_SERIAL@@@Z ; EGRecv2AnvRegSerial
PUBLIC	?EGRecvRegRingGift@@YAXPAUPMSG_ANS_REG_RINGGIFT@@@Z ; EGRecvRegRingGift
PUBLIC	?EGReqDevilSquareEnter@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ; EGReqDevilSquareEnter
PUBLIC	?EGAnsDevilSquareEnter@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTER@@@Z ; EGAnsDevilSquareEnter
PUBLIC	?EGDevilSquareEnter@@YAXH@Z			; EGDevilSquareEnter
PUBLIC	?EGReqBloodCastleEnter@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ; EGReqBloodCastleEnter
PUBLIC	?EGAnsBloodCastleEnter@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTER@@@Z ; EGAnsBloodCastleEnter
PUBLIC	?EGBloodCastleEnter@@YAXH@Z			; EGBloodCastleEnter
PUBLIC	?EGReqBloodCastleEnterCount@@YAXH@Z		; EGReqBloodCastleEnterCount
PUBLIC	?EGAnsBloodCastleEnterCount@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTERCOUNT@@@Z ; EGAnsBloodCastleEnterCount
PUBLIC	?EGReqRegCCOfflineGift@@YAXH@Z			; EGReqRegCCOfflineGift
PUBLIC	?EGAnsRegCCOfflineGift@@YAXPAUPMSG_ANS_REG_CC_OFFLINE_GIFT@@@Z ; EGAnsRegCCOfflineGift
PUBLIC	?EGReqRegDLOfflineGift@@YAXH@Z			; EGReqRegDLOfflineGift
PUBLIC	?EGAnsRegDLOfflineGift@@YAXPAUPMSG_ANS_REG_DL_OFFLINE_GIFT@@@Z ; EGAnsRegDLOfflineGift
PUBLIC	?EGReqRegHTOfflineGift@@YAXH@Z			; EGReqRegHTOfflineGift
PUBLIC	?EGAnsRegHTOfflineGift@@YAXPAUPMSG_ANS_REG_HT_OFFLINE_GIFT@@@Z ; EGAnsRegHTOfflineGift
PUBLIC	??_C@_0CB@JKOKDAGE@Can?5not?5connect?5EventChip?5Server@ ; `string'
PUBLIC	??_C@_0DL@NPJNKEPH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventSer@ ; `string'
PUBLIC	??_C@_0CL@GENGFGNN@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Even@ ; `string'
PUBLIC	??_C@_0CO@PLMPLCLH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5MutoNu@ ; `string'
PUBLIC	??_C@_0CN@HPMMCJJA@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5@ ; `string'
PUBLIC	??_C@_0CF@KMDOMHEE@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5@ ; `string'
PUBLIC	??_C@_0BP@HIMCGJFF@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Stones?$AA@ ; `string'
PUBLIC	??_C@_0DD@JDHGBHBI@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventServer?5@ ; `string'
PUBLIC	??_C@_0CK@KDDNBJOH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Add@ ; `string'
PUBLIC	??_C@_0CC@FLCEMGDH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Fai@ ; `string'
PUBLIC	??_C@_0DD@NFIPOICF@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Index?5is@ ; `string'
PUBLIC	??_C@_0DI@IMNBMFDN@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Gift?5Ind@ ; `string'
PUBLIC	??_C@_0O@HHCDHNEF@Heart?5of?5Love?$AA@		; `string'
PUBLIC	??_C@_0M@NFDLLOLF@500?0000?5Zen?$AA@		; `string'
PUBLIC	??_C@_0L@DILECEGA@50?0000?5Zen?$AA@		; `string'
PUBLIC	??_C@_0L@NAABOOCD@30?0000?5Zen?$AA@		; `string'
PUBLIC	??_C@_0DI@MNCKIFPI@?$FLMu_2Anv_Event?$FN?5Error?5?3?5iGiftNum@ ; `string'
PUBLIC	??_C@_0DD@BPJEDJME@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Result?5V@ ; `string'
PUBLIC	??_C@_0DF@GNHADNCC@?$FLMu_2Anv_Event?$FN?5Register?5Serial?5@ ; `string'
PUBLIC	??_C@_0BP@LPHCCDAB@?$CFs?$LE?T?5?$LC?$LC?$LM?$KN?5?$CFs?$LP?$KB?5?$LE?g?C?$LH?$LF?G?$LM?L?$LN?$MA?$LE?O?$LE?Y?4?$AA@ ; `string'
PUBLIC	??_C@_0DM@EBGDAEID@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5S@ ; `string'
PUBLIC	??_C@_0EN@JKCGIJEK@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5F@ ; `string'
PUBLIC	??_C@_0DC@NJLHLHM@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5F@ ; `string'
PUBLIC	??_C@_0ED@MNBMBKBB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5@ ; `string'
PUBLIC	??_C@_0DL@IPBEOKOL@?$FL?$LE?Y?E?$KJ?$LH?N?$LF?e?5?$LB?b?$LD?d?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC?$LM?$KN@ ; `string'
PUBLIC	??_C@_0EL@NOBBOLBI@?$FLDarkLord?5Heart?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0DN@DCNMDOGL@?$FL?$LM?$PL?$LA?$NM?A?x?5?$LK?$LI?$LJ?$LA?$LL?s?$MA?Z?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC@ ; `string'
PUBLIC	??_C@_0EP@NDKKAONI@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_strcpy_s:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z:PROC ; ChatTargetSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z:PROC ; GCReqmoveDevilSquare
EXTRN	?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z:PROC ; CGRequestEnterBloodCastle
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?gObjFind10EventChip@@YAHH@Z:PROC		; gObjFind10EventChip
EXTRN	?gObjDelete10EventChip@@YAHH@Z:PROC		; gObjDelete10EventChip
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z:PROC ; ItemSerialCreateSend
EXTRN	?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z:PROC ; MyWinsockBase::CreateSocket
EXTRN	?Close@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::Close
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?GMRankingServerConnect@@YAHPADK@Z:PROC		; GMRankingServerConnect
EXTRN	?GMEventChipServerConnect@@YAHPADK@Z:PROC	; GMEventChipServerConnect
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?IsDevilSquareEventConnected@@3HA:DWORD		; IsDevilSquareEventConnected
EXTRN	?IsEventChipServerConnected@@3HA:DWORD		; IsEventChipServerConnected
EXTRN	?RankingServerIP@@3PADA:BYTE			; RankingServerIP
EXTRN	?EventServerIP@@3PADA:BYTE			; EventServerIP
EXTRN	?wsRServerCli@@3VwsJoinServerCli@@A:BYTE	; wsRServerCli
EXTRN	?wsEvenChipServerCli@@3VwsJoinServerCli@@A:BYTE	; wsEvenChipServerCli
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0EP@NDKKAONI@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0EP@NDKKAONI@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Success to Register OffLin'
	DB	'e Gift (GIFT:%s)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@DCNMDOGL@?$FL?$LM?$PL?$LA?$NM?A?x?5?$LK?$LI?$LJ?$LA?$LL?s?$MA?Z?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC@
CONST	SEGMENT
??_C@_0DN@DCNMDOGL@?$FL?$LM?$PL?$LA?$NM?A?x?5?$LK?$LI?$LJ?$LA?$LL?s?$MA?Z?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC@ DB '['
	DB	0bcH, 0fbH, 0b0H, 0dcH, 0c1H, 0f8H, ' ', 0baH, 0b8H, 0b9H, 0b0H
	DB	0bbH, 0f3H, 0c0H, 0daH, ' ', 0c0H, 0ccH, 0baH, 0a5H, 0c6H, 0aeH
	DB	'] %s ', 0b4H, 0d4H, 0b2H, 0b2H, 0bcH, 0adH, ' %s ', 0b0H, 0e6H
	DB	0c7H, 0b0H, 0bfH, 0a1H, ' ', 0b4H, 0e7H, 0c3H, 0b7H, 0b5H, 0c7H
	DB	0bcH, 0ccH, 0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NOBBOLBI@?$FLDarkLord?5Heart?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0EL@NOBBOLBI@?$FLDarkLord?5Heart?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'DarkLord Heart Event] [%s][%s] Success to Register OffLine Gi'
	DB	'ft (GIFT:%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@IPBEOKOL@?$FL?$LE?Y?E?$KJ?$LH?N?$LF?e?5?$LB?b?$LD?d?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC?$LM?$KN@
CONST	SEGMENT
??_C@_0DL@IPBEOKOL@?$FL?$LE?Y?E?$KJ?$LH?N?$LF?e?5?$LB?b?$LD?d?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC?$LM?$KN@ DB '['
	DB	0b4H, 0d9H, 0c5H, 0a9H, 0b7H, 0ceH, 0b5H, 0e5H, ' ', 0b1H, 0e2H
	DB	0b3H, 0e4H, ' ', 0c0H, 0ccH, 0baH, 0a5H, 0c6H, 0aeH, '] %s ', 0b4H
	DB	0d4H, 0b2H, 0b2H, 0bcH, 0adH, ' %s ', 0b0H, 0e6H, 0c7H, 0b0H, 0bfH
	DB	0a1H, ' ', 0b4H, 0e7H, 0c3H, 0b7H, 0b5H, 0c7H, 0bcH, 0ccH, 0bdH
	DB	0c0H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MNBMBKBB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5@
CONST	SEGMENT
??_C@_0ED@MNBMBKBB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5@ DB '['
	DB	'Chaos Castle] [%s][%s] Success to Register OffLine Gift (GIFT'
	DB	':%s)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@NJLHLHM@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5F@
CONST	SEGMENT
??_C@_0DC@NJLHLHM@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5F@ DB '['
	DB	'Ring Event] [%s][%s] Register Failed Result : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@JKCGIJEK@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5F@
CONST	SEGMENT
??_C@_0EN@JKCGIJEK@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5F@ DB '['
	DB	'Ring Event] [%s][%s] Register Failed Result:%d, Gift:%d (out '
	DB	'of bound, 1~4)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EBGDAEID@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5S@
CONST	SEGMENT
??_C@_0DM@EBGDAEID@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5S@ DB '['
	DB	'Ring Event] [%s][%s] Register Succeeded Result:%d, Gift:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LPHCCDAB@?$CFs?$LE?T?5?$LC?$LC?$LM?$KN?5?$CFs?$LP?$KB?5?$LE?g?C?$LH?$LF?G?$LM?L?$LN?$MA?$LE?O?$LE?Y?4?$AA@
CONST	SEGMENT
??_C@_0BP@LPHCCDAB@?$CFs?$LE?T?5?$LC?$LC?$LM?$KN?5?$CFs?$LP?$KB?5?$LE?g?C?$LH?$LF?G?$LM?L?$LN?$MA?$LE?O?$LE?Y?4?$AA@ DB '%'
	DB	's', 0b4H, 0d4H, ' ', 0b2H, 0b2H, 0bcH, 0adH, ' %s', 0bfH, 0a1H
	DB	' ', 0b4H, 0e7H, 0c3H, 0b7H, 0b5H, 0c7H, 0bcH, 0ccH, 0bdH, 0c0H
	DB	0b4H, 0cfH, 0b4H, 0d9H, '.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GNHADNCC@?$FLMu_2Anv_Event?$FN?5Register?5Serial?5@
CONST	SEGMENT
??_C@_0DF@GNHADNCC@?$FLMu_2Anv_Event?$FN?5Register?5Serial?5@ DB '[Mu_2An'
	DB	'v_Event] Register Serial Result : %d [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BPJEDJME@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Result?5V@
CONST	SEGMENT
??_C@_0DD@BPJEDJME@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Result?5V@ DB '[Mu_2'
	DB	'Anv_Event] Error : Result Value is Wrong [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MNCKIFPI@?$FLMu_2Anv_Event?$FN?5Error?5?3?5iGiftNum@
CONST	SEGMENT
??_C@_0DI@MNCKIFPI@?$FLMu_2Anv_Event?$FN?5Error?5?3?5iGiftNum@ DB '[Mu_2A'
	DB	'nv_Event] Error : iGiftNumber is Out of Boud [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NAABOOCD@30?0000?5Zen?$AA@
CONST	SEGMENT
??_C@_0L@NAABOOCD@30?0000?5Zen?$AA@ DB '30,000 Zen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DILECEGA@50?0000?5Zen?$AA@
CONST	SEGMENT
??_C@_0L@DILECEGA@50?0000?5Zen?$AA@ DB '50,000 Zen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFDLLOLF@500?0000?5Zen?$AA@
CONST	SEGMENT
??_C@_0M@NFDLLOLF@500?0000?5Zen?$AA@ DB '500,000 Zen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HHCDHNEF@Heart?5of?5Love?$AA@
CONST	SEGMENT
??_C@_0O@HHCDHNEF@Heart?5of?5Love?$AA@ DB 'Heart of Love', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@IMNBMFDN@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Gift?5Ind@
CONST	SEGMENT
??_C@_0DI@IMNBMFDN@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Gift?5Ind@ DB '[Mu_2'
	DB	'Anv_Event] Error : Gift Index is out of bound [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@NFIPOICF@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Index?5is@
CONST	SEGMENT
??_C@_0DD@NFIPOICF@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Index?5is@ DB '[Mu_2'
	DB	'Anv_Event] Error : Index is out of bound [%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FLCEMGDH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Fai@
CONST	SEGMENT
??_C@_0CC@FLCEMGDH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Fai@ DB '['
	DB	'Stones] [%s][%s] ChangeRena Fail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KDDNBJOH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Add@
CONST	SEGMENT
??_C@_0CK@KDDNBJOH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Add@ DB '['
	DB	'Stones] [%s][%s] ChangeRena AddMoney(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JDHGBHBI@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventServer?5@
CONST	SEGMENT
??_C@_0DD@JDHGBHBI@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventServer?5@ DB '['
	DB	'Stone] [%s][%s] RegEventServer Fail (Stones : %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HIMCGJFF@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Stones?$AA@
CONST	SEGMENT
??_C@_0BP@HIMCGJFF@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Stones?$AA@ DB '['
	DB	'Stone] [%s][%s] Delete Stones', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KMDOMHEE@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5@
CONST	SEGMENT
??_C@_0CF@KMDOMHEE@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5@ DB '['
	DB	'EventChip] [%s][%s] ChangeRena Fail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HPMMCJJA@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5@
CONST	SEGMENT
??_C@_0CN@HPMMCJJA@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5@ DB '['
	DB	'EventChip] [%s][%s] ChangeRena AddMoney(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PLMPLCLH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5MutoNu@
CONST	SEGMENT
??_C@_0CO@PLMPLCLH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5MutoNu@ DB '['
	DB	'EventChip] [%s][%s] Make MutoNumber %d,%d,%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GENGFGNN@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Even@
CONST	SEGMENT
??_C@_0CL@GENGFGNN@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Even@ DB '['
	DB	'EventChip] [%s][%s] Delete EventChip (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NPJNKEPH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventSer@
CONST	SEGMENT
??_C@_0DL@NPJNKEPH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventSer@ DB '['
	DB	'EventChip] [%s][%s] RegEventServer Fail (RegEventchip) %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JKOKDAGE@Can?5not?5connect?5EventChip?5Server@
CONST	SEGMENT
??_C@_0CB@JKOKDAGE@Can?5not?5connect?5EventChip?5Server@ DB 'Can not conn'
	DB	'ect EventChip Server', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGAnsRegHTOfflineGift@@YAXPAUPMSG_ANS_REG_HT_OFFLINE_GIFT@@@Z
_TEXT	SEGMENT
_szText$ = -336						; size = 256
_szGIFT_NAME$ = -80					; size = 50
_szAccountID$ = -28					; size = 11
_szName$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?EGAnsRegHTOfflineGift@@YAXPAUPMSG_ANS_REG_HT_OFFLINE_GIFT@@@Z PROC ; EGAnsRegHTOfflineGift, COMDAT

; 1499 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]

; 1500 : 	if ( !lpMsg)

  00017	85 f6		 test	 esi, esi
  00019	0f 84 05 01 00
	00		 je	 $LN1@EGAnsRegHT

; 1501 : 		return;
; 1502 : 
; 1503 : 	if ( !lpMsg->iResultCode )

  0001f	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00023	75 5c		 jne	 SHORT $LN3@EGAnsRegHT

; 1504 : 	{
; 1505 : 		if ( gObjIsConnected(lpMsg->iINDEX))

  00025	ff 76 04	 push	 DWORD PTR [esi+4]
  00028	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c0		 test	 eax, eax
  00032	0f 84 ec 00 00
	00		 je	 $LN1@EGAnsRegHT

; 1506 : 		{
; 1507 : 			LPOBJ lpObj = &gObj[lpMsg->iINDEX];

  00038	69 4e 04 40 27
	00 00		 imul	 ecx, DWORD PTR [esi+4], 10048
  0003f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1508 : 
; 1509 : 			MapC[lpObj->MapNumber].MoneyItemDrop(1000000, lpObj->X, lpObj->Y);

  00045	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  0004c	50		 push	 eax
  0004d	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  00054	50		 push	 eax
  00055	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  0005c	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  00062	68 40 42 0f 00	 push	 1000000			; 000f4240H
  00067	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0006d	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
  00072	5e		 pop	 esi

; 1532 : 		szAccountID, szName, szGIFT_NAME);
; 1533 : }

  00073	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00076	33 cd		 xor	 ecx, ebp
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
$LN3@EGAnsRegHT:

; 1510 : 		}
; 1511 : 		return;
; 1512 : 	}
; 1513 : 
; 1514 : 	char szAccountID[11] = {0};
; 1515 : 	char szName[11] = {0};
; 1516 : 	char szGIFT_NAME[50] = {0};
; 1517 : 	memset(szAccountID, 0, sizeof(szAccountID));
; 1518 : 	memset(szName, 0, sizeof(szName));
; 1519 : 	memset(szGIFT_NAME, 0, sizeof(szGIFT_NAME));
; 1520 : 	memcpy(szAccountID, lpMsg->szUID, sizeof(szAccountID));

  00081	f3 0f 7e 46 08	 movq	 xmm0, QWORD PTR [esi+8]
  00086	0f b7 46 10	 movzx	 eax, WORD PTR [esi+16]
  0008a	66 0f d6 45 e4	 movq	 QWORD PTR _szAccountID$[ebp], xmm0

; 1521 : 	memcpy(szName, lpMsg->szNAME, sizeof(szName));

  0008f	f3 0f 7e 46 16	 movq	 xmm0, QWORD PTR [esi+22]
  00094	66 0f d6 45 f0	 movq	 QWORD PTR _szName$[ebp], xmm0

; 1522 : 	memcpy(szGIFT_NAME, lpMsg->szGIFT_NAME, sizeof(szGIFT_NAME));

  00099	0f 10 46 28	 movups	 xmm0, XMMWORD PTR [esi+40]
  0009d	66 89 45 ec	 mov	 WORD PTR _szAccountID$[ebp+8], ax
  000a1	0f b7 46 1e	 movzx	 eax, WORD PTR [esi+30]
  000a5	0f 11 45 b0	 movups	 XMMWORD PTR _szGIFT_NAME$[ebp], xmm0
  000a9	66 89 45 f8	 mov	 WORD PTR _szName$[ebp+8], ax
  000ad	0f 10 46 38	 movups	 xmm0, XMMWORD PTR [esi+56]
  000b1	0f b7 46 58	 movzx	 eax, WORD PTR [esi+88]
  000b5	66 89 45 e0	 mov	 WORD PTR _szGIFT_NAME$[ebp+48], ax
  000b9	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  000bf	0f 11 45 c0	 movups	 XMMWORD PTR _szGIFT_NAME$[ebp+16], xmm0
  000c3	68 00 01 00 00	 push	 256			; 00000100H
  000c8	0f 10 46 48	 movups	 xmm0, XMMWORD PTR [esi+72]
  000cc	6a 00		 push	 0
  000ce	50		 push	 eax
  000cf	0f 11 45 d0	 movups	 XMMWORD PTR _szGIFT_NAME$[ebp+32], xmm0

; 1523 : 	szAccountID[10] = 0;

  000d3	c6 45 ee 00	 mov	 BYTE PTR _szAccountID$[ebp+10], 0

; 1524 : 	szName[10] = 0;

  000d7	c6 45 fa 00	 mov	 BYTE PTR _szName$[ebp+10], 0

; 1525 : 	szGIFT_NAME[49] = 0;

  000db	c6 45 e1 00	 mov	 BYTE PTR _szGIFT_NAME$[ebp+49], 0
  000df	e8 00 00 00 00	 call	 _memset

; 1526 : 	char szText[256] = {0};
; 1527 : 
; 1528 : 	wsprintf(szText, "[숨겨진 보물상자 이벤트] %s 님께서 %s 경품에 당첨되셨습니다.", szName, szGIFT_NAME);

  000e4	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  000e7	50		 push	 eax
  000e8	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  000eb	50		 push	 eax
  000ec	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@DCNMDOGL@?$FL?$LM?$PL?$LA?$NM?A?x?5?$LK?$LI?$LJ?$LA?$LL?s?$MA?Z?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC@
  000f7	50		 push	 eax
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1529 : 	AllSendServerMsg(szText);

  000fe	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg

; 1530 : 
; 1531 : 	LogAddTD("[Hidden TreasureBox Event] [%s][%s] Success to Register OffLine Gift (GIFT:%s)",

  0010a	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  0010d	50		 push	 eax
  0010e	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  00111	50		 push	 eax
  00112	8d 45 e4	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  00115	50		 push	 eax
  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@NDKKAONI@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00121	83 c4 30	 add	 esp, 48			; 00000030H
$LN1@EGAnsRegHT:

; 1532 : 		szAccountID, szName, szGIFT_NAME);
; 1533 : }

  00124	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00127	33 cd		 xor	 ecx, ebp
  00129	5e		 pop	 esi
  0012a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
?EGAnsRegHTOfflineGift@@YAXPAUPMSG_ANS_REG_HT_OFFLINE_GIFT@@@Z ENDP ; EGAnsRegHTOfflineGift
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGReqRegHTOfflineGift@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGReqRegHTOfflineGift@@YAXH@Z PROC			; EGReqRegHTOfflineGift, COMDAT

; 1476 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 1477 : 	if ( !gObjIsConnected(iIndex) )

  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 76		 je	 SHORT $LN1@EGReqRegHT

; 1478 : 		return;
; 1479 : 
; 1480 : 	PMSG_REQ_REG_HT_OFFLINE_GIFT pMsg;
; 1481 : 
; 1482 : 	pMsg.h.c = 0xC1;
; 1483 : 	pMsg.h.headcode = 0x17;
; 1484 : 	pMsg.h.size = sizeof(pMsg);
; 1485 : 	memcpy(pMsg.szUID, gObj[iIndex].AccountID, 11);

  00021	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00027	66 c7 45 d8 c1
	24		 mov	 WORD PTR _pMsg$[ebp], 9409 ; 000024c1H
  0002d	c6 45 da 17	 mov	 BYTE PTR _pMsg$[ebp+2], 23 ; 00000017H

; 1486 : 	memcpy(pMsg.szNAME, gObj[iIndex].Name, 11);
; 1487 : 	pMsg.wServerCode = gGameServerCode / 20;
; 1488 : 	pMsg.iINDEX = iIndex;
; 1489 : 	pMsg.szUID[10] = 0;
; 1490 : 	pMsg.szNAME[10] = 0;
; 1491 : 
; 1492 : 	DataSendEventChip((PCHAR)&pMsg, sizeof(pMsg));

  00031	6a 24		 push	 36			; 00000024H
  00033	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  0003e	66 0f d6 45 e0	 movq	 QWORD PTR _pMsg$[ebp+8], xmm0
  00043	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  00047	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+16], ax
  0004b	0f b6 41 5c	 movzx	 eax, BYTE PTR [ecx+92]
  0004f	88 45 ea	 mov	 BYTE PTR _pMsg$[ebp+18], al
  00052	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  00057	66 0f d6 45 ee	 movq	 QWORD PTR _pMsg$[ebp+22], xmm0
  0005c	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]
  00060	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00067	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+30], ax
  0006b	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00070	f7 e9		 imul	 ecx
  00072	89 75 dc	 mov	 DWORD PTR _pMsg$[ebp+4], esi
  00075	c1 fa 03	 sar	 edx, 3
  00078	8b c2		 mov	 eax, edx
  0007a	c6 45 ea 00	 mov	 BYTE PTR _pMsg$[ebp+18], 0
  0007e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00081	03 c2		 add	 eax, edx
  00083	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+32], 0
  00087	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+20], ax
  0008b	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  00094	83 c4 08	 add	 esp, 8
$LN1@EGReqRegHT:

; 1493 : }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	33 cd		 xor	 ecx, ebp
  0009c	5e		 pop	 esi
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
?EGReqRegHTOfflineGift@@YAXH@Z ENDP			; EGReqRegHTOfflineGift
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGAnsRegDLOfflineGift@@YAXPAUPMSG_ANS_REG_DL_OFFLINE_GIFT@@@Z
_TEXT	SEGMENT
_szText$ = -336						; size = 256
_szGIFT_NAME$ = -80					; size = 50
_szAccountID$ = -28					; size = 11
_szName$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?EGAnsRegDLOfflineGift@@YAXPAUPMSG_ANS_REG_DL_OFFLINE_GIFT@@@Z PROC ; EGAnsRegDLOfflineGift, COMDAT

; 1436 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]

; 1437 : 	if ( !lpMsg)

  00016	85 c9		 test	 ecx, ecx
  00018	0f 84 ad 00 00
	00		 je	 $LN1@EGAnsRegDL

; 1438 : 		return;
; 1439 : 
; 1440 : 	if ( !lpMsg->iResultCode )

  0001e	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00022	0f 84 a3 00 00
	00		 je	 $LN1@EGAnsRegDL

; 1441 : 		return;
; 1442 : 
; 1443 : 	char szAccountID[11] = {0};
; 1444 : 	char szName[11] = {0};
; 1445 : 	char szGIFT_NAME[50] = {0};
; 1446 : 	memset(szAccountID, 0, sizeof(szAccountID));
; 1447 : 	memset(szName, 0, sizeof(szName));
; 1448 : 	memset(szGIFT_NAME, 0, sizeof(szGIFT_NAME));
; 1449 : 	memcpy(szAccountID, lpMsg->szUID, sizeof(szAccountID));

  00028	f3 0f 7e 41 08	 movq	 xmm0, QWORD PTR [ecx+8]
  0002d	0f b7 41 10	 movzx	 eax, WORD PTR [ecx+16]
  00031	66 0f d6 45 e4	 movq	 QWORD PTR _szAccountID$[ebp], xmm0

; 1450 : 	memcpy(szName, lpMsg->szNAME, sizeof(szName));

  00036	f3 0f 7e 41 16	 movq	 xmm0, QWORD PTR [ecx+22]
  0003b	66 0f d6 45 f0	 movq	 QWORD PTR _szName$[ebp], xmm0

; 1451 : 	memcpy(szGIFT_NAME, lpMsg->szGIFT_NAME, sizeof(szGIFT_NAME));

  00040	0f 10 41 28	 movups	 xmm0, XMMWORD PTR [ecx+40]
  00044	66 89 45 ec	 mov	 WORD PTR _szAccountID$[ebp+8], ax
  00048	0f b7 41 1e	 movzx	 eax, WORD PTR [ecx+30]
  0004c	0f 11 45 b0	 movups	 XMMWORD PTR _szGIFT_NAME$[ebp], xmm0
  00050	66 89 45 f8	 mov	 WORD PTR _szName$[ebp+8], ax
  00054	0f 10 41 38	 movups	 xmm0, XMMWORD PTR [ecx+56]
  00058	0f b7 41 58	 movzx	 eax, WORD PTR [ecx+88]
  0005c	66 89 45 e0	 mov	 WORD PTR _szGIFT_NAME$[ebp+48], ax
  00060	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  00066	0f 11 45 c0	 movups	 XMMWORD PTR _szGIFT_NAME$[ebp+16], xmm0
  0006a	68 00 01 00 00	 push	 256			; 00000100H
  0006f	0f 10 41 48	 movups	 xmm0, XMMWORD PTR [ecx+72]
  00073	6a 00		 push	 0
  00075	50		 push	 eax
  00076	0f 11 45 d0	 movups	 XMMWORD PTR _szGIFT_NAME$[ebp+32], xmm0

; 1452 : 	szAccountID[10] = 0;

  0007a	c6 45 ee 00	 mov	 BYTE PTR _szAccountID$[ebp+10], 0

; 1453 : 	szName[10] = 0;

  0007e	c6 45 fa 00	 mov	 BYTE PTR _szName$[ebp+10], 0

; 1454 : 	szGIFT_NAME[49] = 0;

  00082	c6 45 e1 00	 mov	 BYTE PTR _szGIFT_NAME$[ebp+49], 0
  00086	e8 00 00 00 00	 call	 _memset

; 1455 : 	char szText[256] = {0};
; 1456 : 
; 1457 : 	wsprintf(szText, "[다크로드 기념 이벤트] %s 님께서 %s 경품에 당첨되셨습니다.", szName, szGIFT_NAME);

  0008b	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  0008e	50		 push	 eax
  0008f	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  00092	50		 push	 eax
  00093	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@IPBEOKOL@?$FL?$LE?Y?E?$KJ?$LH?N?$LF?e?5?$LB?b?$LD?d?5?$MA?L?$LK?$KF?F?$KO?$FN?5?$CFs?5?$LE?T?$LC?$LC?$LM?$KN@
  0009e	50		 push	 eax
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1458 : 	AllSendServerMsg(szText);

  000a5	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg

; 1459 : 
; 1460 : 	LogAddTD("[DarkLord Heart Event] [%s][%s] Success to Register OffLine Gift (GIFT:%s)",

  000b1	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  000b4	50		 push	 eax
  000b5	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  000b8	50		 push	 eax
  000b9	8d 45 e4	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  000bc	50		 push	 eax
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NOBBOLBI@?$FLDarkLord?5Heart?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c8	83 c4 30	 add	 esp, 48			; 00000030H
$LN1@EGAnsRegDL:

; 1461 : 		szAccountID, szName, szGIFT_NAME);
; 1462 : }

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	33 cd		 xor	 ecx, ebp
  000d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?EGAnsRegDLOfflineGift@@YAXPAUPMSG_ANS_REG_DL_OFFLINE_GIFT@@@Z ENDP ; EGAnsRegDLOfflineGift
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGReqRegDLOfflineGift@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGReqRegDLOfflineGift@@YAXH@Z PROC			; EGReqRegDLOfflineGift, COMDAT

; 1413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 1414 : 	if ( !gObjIsConnected(iIndex) )

  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 76		 je	 SHORT $LN1@EGReqRegDL

; 1415 : 		return;
; 1416 : 
; 1417 : 	PMSG_REQ_REG_DL_OFFLINE_GIFT pMsg;
; 1418 : 
; 1419 : 	pMsg.h.c = 0xC1;
; 1420 : 	pMsg.h.headcode = 0x16;
; 1421 : 	pMsg.h.size = sizeof(pMsg);
; 1422 : 	memcpy(pMsg.szUID, gObj[iIndex].AccountID, 11);

  00021	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00027	66 c7 45 d8 c1
	24		 mov	 WORD PTR _pMsg$[ebp], 9409 ; 000024c1H
  0002d	c6 45 da 16	 mov	 BYTE PTR _pMsg$[ebp+2], 22 ; 00000016H

; 1423 : 	memcpy(pMsg.szNAME, gObj[iIndex].Name, 11);
; 1424 : 	pMsg.wServerCode = gGameServerCode / 20;
; 1425 : 	pMsg.iINDEX = iIndex;
; 1426 : 	pMsg.szUID[10] = 0;
; 1427 : 	pMsg.szNAME[10] = 0;
; 1428 : 
; 1429 : 	DataSendEventChip((PCHAR)&pMsg, sizeof(pMsg));

  00031	6a 24		 push	 36			; 00000024H
  00033	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  0003e	66 0f d6 45 e0	 movq	 QWORD PTR _pMsg$[ebp+8], xmm0
  00043	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  00047	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+16], ax
  0004b	0f b6 41 5c	 movzx	 eax, BYTE PTR [ecx+92]
  0004f	88 45 ea	 mov	 BYTE PTR _pMsg$[ebp+18], al
  00052	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  00057	66 0f d6 45 ee	 movq	 QWORD PTR _pMsg$[ebp+22], xmm0
  0005c	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]
  00060	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00067	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+30], ax
  0006b	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00070	f7 e9		 imul	 ecx
  00072	89 75 dc	 mov	 DWORD PTR _pMsg$[ebp+4], esi
  00075	c1 fa 03	 sar	 edx, 3
  00078	8b c2		 mov	 eax, edx
  0007a	c6 45 ea 00	 mov	 BYTE PTR _pMsg$[ebp+18], 0
  0007e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00081	03 c2		 add	 eax, edx
  00083	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+32], 0
  00087	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+20], ax
  0008b	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  00094	83 c4 08	 add	 esp, 8
$LN1@EGReqRegDL:

; 1430 : }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	33 cd		 xor	 ecx, ebp
  0009c	5e		 pop	 esi
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
?EGReqRegDLOfflineGift@@YAXH@Z ENDP			; EGReqRegDLOfflineGift
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGAnsRegCCOfflineGift@@YAXPAUPMSG_ANS_REG_CC_OFFLINE_GIFT@@@Z
_TEXT	SEGMENT
_szText$ = -336						; size = 256
_szGIFT_NAME$ = -80					; size = 50
_szAccountID$ = -28					; size = 11
_szName$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?EGAnsRegCCOfflineGift@@YAXPAUPMSG_ANS_REG_CC_OFFLINE_GIFT@@@Z PROC ; EGAnsRegCCOfflineGift, COMDAT

; 1370 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]

; 1371 : 	if ( !lpMsg)

  00016	85 c9		 test	 ecx, ecx
  00018	0f 84 bb 00 00
	00		 je	 $LN1@EGAnsRegCC

; 1372 : 		return;
; 1373 : 
; 1374 : 	if ( !lpMsg->iResultCode )

  0001e	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00022	0f 84 b1 00 00
	00		 je	 $LN1@EGAnsRegCC

; 1375 : 		return;
; 1376 : 
; 1377 : 	char szAccountID[11] = {0};
; 1378 : 	char szName[11] = {0};
; 1379 : 	char szGIFT_NAME[50] = {0};
; 1380 : 	memset(szAccountID, 0, sizeof(szAccountID));
; 1381 : 	memset(szName, 0, sizeof(szName));
; 1382 : 	memset(szGIFT_NAME, 0, sizeof(szGIFT_NAME));
; 1383 : 	memcpy(szAccountID, lpMsg->szUID, sizeof(szAccountID));

  00028	f3 0f 7e 41 08	 movq	 xmm0, QWORD PTR [ecx+8]
  0002d	0f b7 41 10	 movzx	 eax, WORD PTR [ecx+16]
  00031	66 0f d6 45 e4	 movq	 QWORD PTR _szAccountID$[ebp], xmm0

; 1384 : 	memcpy(szName, lpMsg->szNAME, sizeof(szName));

  00036	f3 0f 7e 41 16	 movq	 xmm0, QWORD PTR [ecx+22]
  0003b	66 0f d6 45 f0	 movq	 QWORD PTR _szName$[ebp], xmm0

; 1385 : 	memcpy(szGIFT_NAME, lpMsg->szGIFT_NAME, sizeof(szGIFT_NAME));

  00040	0f 10 41 28	 movups	 xmm0, XMMWORD PTR [ecx+40]
  00044	66 89 45 ec	 mov	 WORD PTR _szAccountID$[ebp+8], ax
  00048	0f b7 41 1e	 movzx	 eax, WORD PTR [ecx+30]
  0004c	0f 11 45 b0	 movups	 XMMWORD PTR _szGIFT_NAME$[ebp], xmm0
  00050	66 89 45 f8	 mov	 WORD PTR _szName$[ebp+8], ax
  00054	0f 10 41 38	 movups	 xmm0, XMMWORD PTR [ecx+56]
  00058	0f b7 41 58	 movzx	 eax, WORD PTR [ecx+88]
  0005c	66 89 45 e0	 mov	 WORD PTR _szGIFT_NAME$[ebp+48], ax
  00060	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  00066	0f 11 45 c0	 movups	 XMMWORD PTR _szGIFT_NAME$[ebp+16], xmm0
  0006a	68 00 01 00 00	 push	 256			; 00000100H
  0006f	0f 10 41 48	 movups	 xmm0, XMMWORD PTR [ecx+72]
  00073	6a 00		 push	 0
  00075	50		 push	 eax
  00076	0f 11 45 d0	 movups	 XMMWORD PTR _szGIFT_NAME$[ebp+32], xmm0

; 1386 : 	szAccountID[10] = 0;

  0007a	c6 45 ee 00	 mov	 BYTE PTR _szAccountID$[ebp+10], 0

; 1387 : 	szName[10] = 0;

  0007e	c6 45 fa 00	 mov	 BYTE PTR _szName$[ebp+10], 0

; 1388 : 	szGIFT_NAME[49] = 0;

  00082	c6 45 e1 00	 mov	 BYTE PTR _szGIFT_NAME$[ebp+49], 0
  00086	e8 00 00 00 00	 call	 _memset
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1389 : 	char szText[256] = {0};
; 1390 : 
; 1391 : 	wsprintf(szText, lMsg.Get(MSGGET(6,74)), szName, szGIFT_NAME);

  0008e	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00096	50		 push	 eax
  00097	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  0009a	50		 push	 eax
  0009b	68 4a 06 00 00	 push	 1610			; 0000064aH
  000a0	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000a5	50		 push	 eax
  000a6	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  000ac	50		 push	 eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1392 : 	AllSendServerMsg(szText);

  000b3	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _szText$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg

; 1393 : 
; 1394 : 	LogAddTD("[Chaos Castle] [%s][%s] Success to Register OffLine Gift (GIFT:%s)",

  000bf	8d 45 b0	 lea	 eax, DWORD PTR _szGIFT_NAME$[ebp]
  000c2	50		 push	 eax
  000c3	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  000c6	50		 push	 eax
  000c7	8d 45 e4	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  000ca	50		 push	 eax
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@MNBMBKBB@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5@
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000d6	83 c4 24	 add	 esp, 36			; 00000024H
$LN1@EGAnsRegCC:

; 1395 : 		szAccountID, szName, szGIFT_NAME);
; 1396 : }

  000d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dc	33 cd		 xor	 ecx, ebp
  000de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
?EGAnsRegCCOfflineGift@@YAXPAUPMSG_ANS_REG_CC_OFFLINE_GIFT@@@Z ENDP ; EGAnsRegCCOfflineGift
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGReqRegCCOfflineGift@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGReqRegCCOfflineGift@@YAXH@Z PROC			; EGReqRegCCOfflineGift, COMDAT

; 1347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 1348 : 	if ( !gObjIsConnected(iIndex) )

  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 76		 je	 SHORT $LN1@EGReqRegCC

; 1349 : 		return;
; 1350 : 
; 1351 : 	PMSG_REQ_REG_CC_OFFLINE_GIFT pMsg;
; 1352 : 
; 1353 : 	pMsg.h.c = 0xC1;
; 1354 : 	pMsg.h.headcode = 0x15;
; 1355 : 	pMsg.h.size = sizeof(pMsg);
; 1356 : 	memcpy(pMsg.szUID, gObj[iIndex].AccountID, 11);

  00021	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00027	66 c7 45 d8 c1
	24		 mov	 WORD PTR _pMsg$[ebp], 9409 ; 000024c1H
  0002d	c6 45 da 15	 mov	 BYTE PTR _pMsg$[ebp+2], 21 ; 00000015H

; 1357 : 	memcpy(pMsg.szNAME, gObj[iIndex].Name, 11);
; 1358 : 	pMsg.wServerCode = gGameServerCode / 20;
; 1359 : 	pMsg.iINDEX = iIndex;
; 1360 : 	pMsg.szUID[10] = 0;
; 1361 : 	pMsg.szNAME[10] = 0;
; 1362 : 
; 1363 : 	DataSendEventChip((PCHAR)&pMsg, sizeof(pMsg));

  00031	6a 24		 push	 36			; 00000024H
  00033	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  0003e	66 0f d6 45 e0	 movq	 QWORD PTR _pMsg$[ebp+8], xmm0
  00043	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  00047	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+16], ax
  0004b	0f b6 41 5c	 movzx	 eax, BYTE PTR [ecx+92]
  0004f	88 45 ea	 mov	 BYTE PTR _pMsg$[ebp+18], al
  00052	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  00057	66 0f d6 45 ee	 movq	 QWORD PTR _pMsg$[ebp+22], xmm0
  0005c	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]
  00060	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00067	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+30], ax
  0006b	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00070	f7 e9		 imul	 ecx
  00072	89 75 dc	 mov	 DWORD PTR _pMsg$[ebp+4], esi
  00075	c1 fa 03	 sar	 edx, 3
  00078	8b c2		 mov	 eax, edx
  0007a	c6 45 ea 00	 mov	 BYTE PTR _pMsg$[ebp+18], 0
  0007e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00081	03 c2		 add	 eax, edx
  00083	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+32], 0
  00087	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+20], ax
  0008b	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  00094	83 c4 08	 add	 esp, 8
$LN1@EGReqRegCC:

; 1364 : }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	33 cd		 xor	 ecx, ebp
  0009c	5e		 pop	 esi
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
?EGReqRegCCOfflineGift@@YAXH@Z ENDP			; EGReqRegCCOfflineGift
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGAnsBloodCastleEnterCount@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTERCOUNT@@@Z
_TEXT	SEGMENT
_szName$ = -32						; size = 11
_szAccountID$ = -20					; size = 11
_pMsgSend$ = -8						; size = 5
_lpMsg$ = 8						; size = 4
?EGAnsBloodCastleEnterCount@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTERCOUNT@@@Z PROC ; EGAnsBloodCastleEnterCount, COMDAT

; 1306 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 1307 : 	if ( !lpMsg)

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	0f 84 e5 00 00
	00		 je	 $LN5@EGAnsBlood

; 1308 : 		return;
; 1309 : 
; 1310 : 	if ( !gObjIsConnected(lpMsg->iObjIndex))

  00012	ff 76 1c	 push	 DWORD PTR [esi+28]
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 d2 00 00
	00		 je	 $LN5@EGAnsBlood

; 1311 : 		return;
; 1312 : 
; 1313 : 	char szAccountID[11] = {0};
; 1314 : 	char szName[11] = {0};
; 1315 : 	memcpy(szAccountID, lpMsg->AccountID, 10);

  00025	0f b7 46 0b	 movzx	 eax, WORD PTR [esi+11]

; 1316 : 	memcpy(szName, lpMsg->GameID, 10);
; 1317 : 
; 1318 : 	if ( strcmp(gObj[lpMsg->iObjIndex].AccountID, szAccountID) ||

  00029	8d 4d ec	 lea	 ecx, DWORD PTR _szAccountID$[ebp]
  0002c	53		 push	 ebx
  0002d	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	57		 push	 edi
  00034	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  0003a	66 0f d6 45 ed	 movq	 QWORD PTR _szAccountID$[ebp+1], xmm0
  0003f	66 0f d6 45 e1	 movq	 QWORD PTR _szName$[ebp+1], xmm0
  00044	f3 0f 7e 46 03	 movq	 xmm0, QWORD PTR [esi+3]
  00049	66 c7 45 f5 00
	00		 mov	 WORD PTR _szAccountID$[ebp+9], 0
  0004f	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	66 89 45 f4	 mov	 WORD PTR _szAccountID$[ebp+8], ax
  00059	0f b7 46 15	 movzx	 eax, WORD PTR [esi+21]
  0005d	66 0f d6 45 ec	 movq	 QWORD PTR _szAccountID$[ebp], xmm0
  00062	f3 0f 7e 46 0d	 movq	 xmm0, QWORD PTR [esi+13]
  00067	66 c7 45 e9 00
	00		 mov	 WORD PTR _szName$[ebp+9], 0
  0006d	66 89 45 e8	 mov	 WORD PTR _szName$[ebp+8], ax
  00071	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00074	66 0f d6 45 e0	 movq	 QWORD PTR _szName$[ebp], xmm0
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@EGAnsBlood:
  00080	8a 10		 mov	 dl, BYTE PTR [eax]
  00082	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00084	75 1a		 jne	 SHORT $LN8@EGAnsBlood
  00086	84 d2		 test	 dl, dl
  00088	74 12		 je	 SHORT $LN9@EGAnsBlood
  0008a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0008d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00090	75 0e		 jne	 SHORT $LN8@EGAnsBlood
  00092	83 c0 02	 add	 eax, 2
  00095	83 c1 02	 add	 ecx, 2
  00098	84 d2		 test	 dl, dl
  0009a	75 e4		 jne	 SHORT $LL7@EGAnsBlood
$LN9@EGAnsBlood:
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 05		 jmp	 SHORT $LN10@EGAnsBlood
$LN8@EGAnsBlood:
  000a0	1b c0		 sbb	 eax, eax
  000a2	83 c8 01	 or	 eax, 1
$LN10@EGAnsBlood:
  000a5	85 c0		 test	 eax, eax
  000a7	75 4c		 jne	 SHORT $LN15@EGAnsBlood
  000a9	8d 45 e0	 lea	 eax, DWORD PTR _szName$[ebp]
  000ac	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
  000af	90		 npad	 1
$LL11@EGAnsBlood:
  000b0	8a 11		 mov	 dl, BYTE PTR [ecx]
  000b2	3a 10		 cmp	 dl, BYTE PTR [eax]
  000b4	75 1a		 jne	 SHORT $LN12@EGAnsBlood
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN13@EGAnsBlood
  000ba	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  000bd	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  000c0	75 0e		 jne	 SHORT $LN12@EGAnsBlood
  000c2	83 c1 02	 add	 ecx, 2
  000c5	83 c0 02	 add	 eax, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL11@EGAnsBlood
$LN13@EGAnsBlood:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN14@EGAnsBlood
$LN12@EGAnsBlood:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 c8 01	 or	 eax, 1
$LN14@EGAnsBlood:
  000d5	85 c0		 test	 eax, eax
  000d7	75 1c		 jne	 SHORT $LN15@EGAnsBlood

; 1319 : 		 strcmp(gObj[lpMsg->iObjIndex].Name, szName) )
; 1320 : 		 return;
; 1321 : 
; 1322 : 	PMSG_ANS_CL_ENTERCOUNT pMsgSend;
; 1323 : 
; 1324 : 	pMsgSend.h.c = 0xC1;
; 1325 : 	pMsgSend.h.headcode = 0x9F;
; 1326 : 	pMsgSend.h.size = sizeof(pMsgSend);
; 1327 : 	pMsgSend.btEventType = 2;
; 1328 : 	pMsgSend.btLeftEnterCount = lpMsg->iLeftCount;

  000d9	8a 46 20	 mov	 al, BYTE PTR [esi+32]
  000dc	88 45 fc	 mov	 BYTE PTR _pMsgSend$[ebp+4], al

; 1329 : 
; 1330 : 	DataSend(lpMsg->iObjIndex, (LPBYTE)&pMsgSend, sizeof(pMsgSend));

  000df	8d 45 f8	 lea	 eax, DWORD PTR _pMsgSend$[ebp]
  000e2	6a 05		 push	 5
  000e4	50		 push	 eax
  000e5	53		 push	 ebx
  000e6	c7 45 f8 c1 05
	9f 02		 mov	 DWORD PTR _pMsgSend$[ebp], 43976129 ; 029f05c1H
  000ed	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@EGAnsBlood:
  000f5	5f		 pop	 edi
  000f6	5b		 pop	 ebx
$LN5@EGAnsBlood:
  000f7	5e		 pop	 esi

; 1331 : }

  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
?EGAnsBloodCastleEnterCount@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTERCOUNT@@@Z ENDP ; EGAnsBloodCastleEnterCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGReqBloodCastleEnterCount@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGReqBloodCastleEnterCount@@YAXH@Z PROC		; EGReqBloodCastleEnterCount, COMDAT

; 1261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 1262 : 	if ( !gObjIsConnected(iIndex) )

  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 c9 00 00
	00		 je	 $LN5@EGReqBlood

; 1263 : 		return;
; 1264 : 
; 1265 : 	PMSG_REQ_BLOODCASTLE_ENTERCOUNT pMsg;
; 1266 : 
; 1267 : 	pMsg.h.c = 0xC1;
; 1268 : 	pMsg.h.headcode = 0x0B;
; 1269 : 	pMsg.h.size = sizeof(pMsg);
; 1270 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, 10);

  00025	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0002b	66 c7 45 dc c1
	20		 mov	 WORD PTR _pMsg$[ebp], 8385 ; 000020c1H
  00031	c6 45 de 0b	 mov	 BYTE PTR _pMsg$[ebp+2], 11 ; 0000000bH
  00035	53		 push	 ebx
  00036	b3 20		 mov	 bl, 32			; 00000020H
  00038	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003e	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  00043	66 0f d6 45 df	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  00048	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  0004c	66 89 45 e7	 mov	 WORD PTR _pMsg$[ebp+11], ax

; 1271 : 	memcpy(pMsg.GameID, gObj[iIndex].Name, 10);

  00050	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  00055	66 0f d6 45 e9	 movq	 QWORD PTR _pMsg$[ebp+13], xmm0
  0005a	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]

; 1272 : 	pMsg.ServerCode = gGameServerCode / 20;

  0005e	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00065	66 89 45 f1	 mov	 WORD PTR _pMsg$[ebp+21], ax
  00069	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0006e	f7 e9		 imul	 ecx

; 1273 : 	pMsg.iObjIndex = iIndex;

  00070	89 75 f8	 mov	 DWORD PTR _pMsg$[ebp+28], esi
  00073	c1 fa 03	 sar	 edx, 3
  00076	8b c2		 mov	 eax, edx
  00078	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007b	03 c2		 add	 eax, edx

; 1274 : 
; 1275 : 	if ( !IsDevilSquareEventConnected )

  0007d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00084	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  00087	75 52		 jne	 SHORT $LN7@EGReqBlood

; 1276 : 	{
; 1277 : 		wsRServerCli.Close();

  00089	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  0008e	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 1278 : 		wsRServerCli.CreateSocket(ghWnd);

  00093	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00099	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  0009e	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 1279 : 
; 1280 : 		if ( !GMRankingServerConnect(RankingServerIP, WM_GM_RANKING_CLIENT_MSG_PROC) )

  000a3	68 0c 04 00 00	 push	 1036			; 0000040cH
  000a8	68 00 00 00 00	 push	 OFFSET ?RankingServerIP@@3PADA ; RankingServerIP
  000ad	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  000b2	83 c4 08	 add	 esp, 8
  000b5	85 c0		 test	 eax, eax
  000b7	75 15		 jne	 SHORT $LN4@EGReqBlood

; 1281 : 		{
; 1282 : 			IsDevilSquareEventConnected = 0;

  000b9	5b		 pop	 ebx
  000ba	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
  000bf	5e		 pop	 esi

; 1293 : 	}
; 1294 : }

  000c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	33 cd		 xor	 ecx, ebp
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
$LN4@EGReqBlood:

; 1283 : //			LogAddTD("Can not connect Ranking Server");
; 1284 : 			return;
; 1285 : 		}
; 1286 : 
; 1287 : 		IsDevilSquareEventConnected = TRUE;

  000ce	8a 5d dd	 mov	 bl, BYTE PTR _pMsg$[ebp+1]
  000d1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN7@EGReqBlood:

; 1288 : 	}
; 1289 : 
; 1290 : 	if ( IsDevilSquareEventConnected )
; 1291 : 	{
; 1292 : 		wsRServerCli.DataSend((PCHAR)&pMsg, pMsg.h.size);

  000db	0f b6 c3	 movzx	 eax, bl
  000de	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  000e3	50		 push	 eax
  000e4	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
  000ed	5b		 pop	 ebx
$LN5@EGReqBlood:

; 1293 : 	}
; 1294 : }

  000ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f1	33 cd		 xor	 ecx, ebp
  000f3	5e		 pop	 esi
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
?EGReqBloodCastleEnterCount@@YAXH@Z ENDP		; EGReqBloodCastleEnterCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGBloodCastleEnter@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGBloodCastleEnter@@YAXH@Z PROC			; EGBloodCastleEnter, COMDAT

; 1225 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 1226 : 	if ( !gObjIsConnected(iIndex) )

  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 c9 00 00
	00		 je	 $LN5@EGBloodCas

; 1227 : 		return;
; 1228 : 
; 1229 : 	PMSG_REQ_BLOODCASTLE_ENTERCOUNT pMsg;
; 1230 : 
; 1231 : 	pMsg.h.c = 0xC1;
; 1232 : 	pMsg.h.headcode = 0x09;
; 1233 : 	pMsg.h.size = sizeof(pMsg);
; 1234 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, 10);

  00025	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0002b	66 c7 45 dc c1
	20		 mov	 WORD PTR _pMsg$[ebp], 8385 ; 000020c1H
  00031	c6 45 de 09	 mov	 BYTE PTR _pMsg$[ebp+2], 9
  00035	53		 push	 ebx
  00036	b3 20		 mov	 bl, 32			; 00000020H
  00038	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003e	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  00043	66 0f d6 45 df	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  00048	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  0004c	66 89 45 e7	 mov	 WORD PTR _pMsg$[ebp+11], ax

; 1235 : 	memcpy(pMsg.GameID, gObj[iIndex].Name, 10);

  00050	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  00055	66 0f d6 45 e9	 movq	 QWORD PTR _pMsg$[ebp+13], xmm0
  0005a	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]

; 1236 : 	pMsg.ServerCode = gGameServerCode / 20;

  0005e	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00065	66 89 45 f1	 mov	 WORD PTR _pMsg$[ebp+21], ax
  00069	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0006e	f7 e9		 imul	 ecx

; 1237 : 	pMsg.iObjIndex = iIndex;

  00070	89 75 f8	 mov	 DWORD PTR _pMsg$[ebp+28], esi
  00073	c1 fa 03	 sar	 edx, 3
  00076	8b c2		 mov	 eax, edx
  00078	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007b	03 c2		 add	 eax, edx

; 1238 : 
; 1239 : 	if ( !IsDevilSquareEventConnected )

  0007d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00084	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  00087	75 52		 jne	 SHORT $LN7@EGBloodCas

; 1240 : 	{
; 1241 : 		wsRServerCli.Close();

  00089	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  0008e	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 1242 : 		wsRServerCli.CreateSocket(ghWnd);

  00093	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00099	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  0009e	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 1243 : 
; 1244 : 		if ( !GMRankingServerConnect(RankingServerIP, WM_GM_RANKING_CLIENT_MSG_PROC) )

  000a3	68 0c 04 00 00	 push	 1036			; 0000040cH
  000a8	68 00 00 00 00	 push	 OFFSET ?RankingServerIP@@3PADA ; RankingServerIP
  000ad	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  000b2	83 c4 08	 add	 esp, 8
  000b5	85 c0		 test	 eax, eax
  000b7	75 15		 jne	 SHORT $LN4@EGBloodCas

; 1245 : 		{
; 1246 : 			IsDevilSquareEventConnected = 0;

  000b9	5b		 pop	 ebx
  000ba	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
  000bf	5e		 pop	 esi

; 1257 : 	}
; 1258 : }

  000c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	33 cd		 xor	 ecx, ebp
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
$LN4@EGBloodCas:

; 1247 : //			LogAddTD("Can not connect Ranking Server");
; 1248 : 			return;
; 1249 : 		}
; 1250 : 
; 1251 : 		IsDevilSquareEventConnected = TRUE;

  000ce	8a 5d dd	 mov	 bl, BYTE PTR _pMsg$[ebp+1]
  000d1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN7@EGBloodCas:

; 1252 : 	}
; 1253 : 
; 1254 : 	if ( IsDevilSquareEventConnected )
; 1255 : 	{
; 1256 : 		wsRServerCli.DataSend((PCHAR)&pMsg, pMsg.h.size);

  000db	0f b6 c3	 movzx	 eax, bl
  000de	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  000e3	50		 push	 eax
  000e4	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
  000ed	5b		 pop	 ebx
$LN5@EGBloodCas:

; 1257 : 	}
; 1258 : }

  000ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f1	33 cd		 xor	 ecx, ebp
  000f3	5e		 pop	 esi
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
?EGBloodCastleEnter@@YAXH@Z ENDP			; EGBloodCastleEnter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGAnsBloodCastleEnter@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTER@@@Z
_TEXT	SEGMENT
_szName$ = -32						; size = 11
_szAccountID$ = -20					; size = 11
_pMsg$1 = -8						; size = 5
_pResult$2 = 8						; size = 4
_lpMsg$ = 8						; size = 4
?EGAnsBloodCastleEnter@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTER@@@Z PROC ; EGAnsBloodCastleEnter, COMDAT

; 1190 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 1191 : 	if ( !lpMsg)

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	0f 84 1c 01 00
	00		 je	 $LN5@EGAnsBlood

; 1192 : 		return;
; 1193 : 
; 1194 : 	if ( !gObjIsConnected(lpMsg->iObjIndex))

  00012	ff 76 1c	 push	 DWORD PTR [esi+28]
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 09 01 00
	00		 je	 $LN5@EGAnsBlood

; 1195 : 		return;
; 1196 : 
; 1197 : 	char szAccountID[11] = {0};
; 1198 : 	char szName[11] = {0};
; 1199 : 	memcpy(szAccountID, lpMsg->AccountID, 10);

  00025	0f b7 46 0b	 movzx	 eax, WORD PTR [esi+11]

; 1200 : 	memcpy(szName, lpMsg->GameID, 10);
; 1201 : 
; 1202 : 	if ( strcmp(gObj[lpMsg->iObjIndex].AccountID, szAccountID) ||

  00029	8d 4d ec	 lea	 ecx, DWORD PTR _szAccountID$[ebp]
  0002c	53		 push	 ebx
  0002d	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	57		 push	 edi
  00034	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  0003a	66 0f d6 45 ed	 movq	 QWORD PTR _szAccountID$[ebp+1], xmm0
  0003f	66 0f d6 45 e1	 movq	 QWORD PTR _szName$[ebp+1], xmm0
  00044	f3 0f 7e 46 03	 movq	 xmm0, QWORD PTR [esi+3]
  00049	66 c7 45 f5 00
	00		 mov	 WORD PTR _szAccountID$[ebp+9], 0
  0004f	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	66 89 45 f4	 mov	 WORD PTR _szAccountID$[ebp+8], ax
  00059	0f b7 46 15	 movzx	 eax, WORD PTR [esi+21]
  0005d	66 0f d6 45 ec	 movq	 QWORD PTR _szAccountID$[ebp], xmm0
  00062	f3 0f 7e 46 0d	 movq	 xmm0, QWORD PTR [esi+13]
  00067	66 c7 45 e9 00
	00		 mov	 WORD PTR _szName$[ebp+9], 0
  0006d	66 89 45 e8	 mov	 WORD PTR _szName$[ebp+8], ax
  00071	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00074	66 0f d6 45 e0	 movq	 QWORD PTR _szName$[ebp], xmm0
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@EGAnsBlood:
  00080	8a 10		 mov	 dl, BYTE PTR [eax]
  00082	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00084	75 1a		 jne	 SHORT $LN10@EGAnsBlood
  00086	84 d2		 test	 dl, dl
  00088	74 12		 je	 SHORT $LN11@EGAnsBlood
  0008a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0008d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00090	75 0e		 jne	 SHORT $LN10@EGAnsBlood
  00092	83 c0 02	 add	 eax, 2
  00095	83 c1 02	 add	 ecx, 2
  00098	84 d2		 test	 dl, dl
  0009a	75 e4		 jne	 SHORT $LL9@EGAnsBlood
$LN11@EGAnsBlood:
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 05		 jmp	 SHORT $LN12@EGAnsBlood
$LN10@EGAnsBlood:
  000a0	1b c0		 sbb	 eax, eax
  000a2	83 c8 01	 or	 eax, 1
$LN12@EGAnsBlood:
  000a5	85 c0		 test	 eax, eax
  000a7	0f 85 7f 00 00
	00		 jne	 $LN17@EGAnsBlood
  000ad	8d 45 e0	 lea	 eax, DWORD PTR _szName$[ebp]
  000b0	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
$LL13@EGAnsBlood:
  000b3	8a 11		 mov	 dl, BYTE PTR [ecx]
  000b5	3a 10		 cmp	 dl, BYTE PTR [eax]
  000b7	75 1a		 jne	 SHORT $LN14@EGAnsBlood
  000b9	84 d2		 test	 dl, dl
  000bb	74 12		 je	 SHORT $LN15@EGAnsBlood
  000bd	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  000c0	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  000c3	75 0e		 jne	 SHORT $LN14@EGAnsBlood
  000c5	83 c1 02	 add	 ecx, 2
  000c8	83 c0 02	 add	 eax, 2
  000cb	84 d2		 test	 dl, dl
  000cd	75 e4		 jne	 SHORT $LL13@EGAnsBlood
$LN15@EGAnsBlood:
  000cf	33 c0		 xor	 eax, eax
  000d1	eb 05		 jmp	 SHORT $LN16@EGAnsBlood
$LN14@EGAnsBlood:
  000d3	1b c0		 sbb	 eax, eax
  000d5	83 c8 01	 or	 eax, 1
$LN16@EGAnsBlood:
  000d8	85 c0		 test	 eax, eax
  000da	75 50		 jne	 SHORT $LN17@EGAnsBlood

; 1203 : 		 strcmp(gObj[lpMsg->iObjIndex].Name, szName) )
; 1204 : 		 return;
; 1205 : 
; 1206 : 	if( lpMsg->iResult == 1 )

  000dc	83 7e 20 01	 cmp	 DWORD PTR [esi+32], 1
  000e0	75 22		 jne	 SHORT $LN6@EGAnsBlood

; 1207 : 	{
; 1208 : 		PMSG_REQ_MOVEBLOODCASTLE pMsg;
; 1209 : 		pMsg.iBridgeNumber = lpMsg->iBloodCastle;

  000e2	0f b6 46 24	 movzx	 eax, BYTE PTR [esi+36]
  000e6	88 45 fb	 mov	 BYTE PTR _pMsg$1[ebp+3], al

; 1210 : 		pMsg.iItemPos = lpMsg->iBloodCastleItemPos;

  000e9	0f b6 46 28	 movzx	 eax, BYTE PTR [esi+40]
  000ed	88 45 fc	 mov	 BYTE PTR _pMsg$1[ebp+4], al

; 1211 : 
; 1212 : 		CGRequestEnterBloodCastle(&pMsg,lpMsg->iObjIndex);

  000f0	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  000f3	53		 push	 ebx
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ; CGRequestEnterBloodCastle
  000fa	83 c4 08	 add	 esp, 8
  000fd	5f		 pop	 edi
  000fe	5b		 pop	 ebx
  000ff	5e		 pop	 esi

; 1221 : 	}
; 1222 : }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
$LN6@EGAnsBlood:

; 1213 : 	}
; 1214 : 	else
; 1215 : 	{
; 1216 : 		PMSG_RESULT_MOVEBLOODCASTLE pResult;
; 1217 : 		PHeadSetB((LPBYTE)&pResult,0x9A,sizeof(pResult));

  00104	6a 04		 push	 4
  00106	8d 45 08	 lea	 eax, DWORD PTR _pResult$2[ebp]
  00109	68 9a 00 00 00	 push	 154			; 0000009aH
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1218 : 		pResult.Result = 6;
; 1219 : 
; 1220 : 		DataSend(lpMsg->iObjIndex,(LPBYTE)&pResult,pResult.h.size);

  00114	0f b6 45 09	 movzx	 eax, BYTE PTR _pResult$2[ebp+1]
  00118	50		 push	 eax
  00119	8d 45 08	 lea	 eax, DWORD PTR _pResult$2[ebp]
  0011c	c6 45 0b 06	 mov	 BYTE PTR _pResult$2[ebp+3], 6
  00120	50		 push	 eax
  00121	ff 76 1c	 push	 DWORD PTR [esi+28]
  00124	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00129	83 c4 18	 add	 esp, 24			; 00000018H
$LN17@EGAnsBlood:
  0012c	5f		 pop	 edi
  0012d	5b		 pop	 ebx
$LN5@EGAnsBlood:
  0012e	5e		 pop	 esi

; 1221 : 	}
; 1222 : }

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
?EGAnsBloodCastleEnter@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTER@@@Z ENDP ; EGAnsBloodCastleEnter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGReqBloodCastleEnter@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z
_TEXT	SEGMENT
_pMsg$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?EGReqBloodCastleEnter@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z PROC ; EGReqBloodCastleEnter, COMDAT

; 1152 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 1153 : 	if ( !gObjIsConnected(iIndex) )

  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	0f 84 d8 00 00
	00		 je	 $LN5@EGReqBlood

; 1154 : 		return;
; 1155 : 
; 1156 : 	PMSG_REQ_BLOODCASTLE_ENTER pMsg;
; 1157 : 
; 1158 : 	pMsg.h.c = 0xC1;
; 1159 : 	pMsg.h.headcode = 0x08;
; 1160 : 	pMsg.h.size = sizeof(pMsg);
; 1161 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, 10);

  00029	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0002f	66 c7 45 d4 c1
	28		 mov	 WORD PTR _pMsg$[ebp], 10433 ; 000028c1H
  00035	c6 45 d6 08	 mov	 BYTE PTR _pMsg$[ebp+2], 8
  00039	53		 push	 ebx
  0003a	b3 28		 mov	 bl, 40			; 00000028H
  0003c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00042	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  00047	66 0f d6 45 d7	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  0004c	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  00050	66 89 45 df	 mov	 WORD PTR _pMsg$[ebp+11], ax

; 1162 : 	memcpy(pMsg.GameID, gObj[iIndex].Name, 10);

  00054	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  00059	66 0f d6 45 e1	 movq	 QWORD PTR _pMsg$[ebp+13], xmm0
  0005e	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]

; 1163 : 	pMsg.ServerCode = gGameServerCode / 20;

  00062	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00069	66 89 45 e9	 mov	 WORD PTR _pMsg$[ebp+21], ax
  0006d	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00072	f7 e9		 imul	 ecx

; 1164 : 	pMsg.iObjIndex = iIndex;

  00074	89 75 f0	 mov	 DWORD PTR _pMsg$[ebp+28], esi
  00077	c1 fa 03	 sar	 edx, 3
  0007a	8b c2		 mov	 eax, edx
  0007c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007f	03 c2		 add	 eax, edx

; 1165 : 	pMsg.iBloodCastle = lpMsg->iBridgeNumber;
; 1166 : 	pMsg.iBloodCastleItemPos = lpMsg->iItemPos;
; 1167 : 
; 1168 : 	if ( !IsDevilSquareEventConnected )

  00081	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00088	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  0008b	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0008f	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+32], eax
  00092	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00096	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+36], eax
  00099	75 53		 jne	 SHORT $LN7@EGReqBlood

; 1169 : 	{
; 1170 : 		wsRServerCli.Close();

  0009b	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000a0	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 1171 : 		wsRServerCli.CreateSocket(ghWnd);

  000a5	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000ab	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000b0	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 1172 : 
; 1173 : 		if ( !GMRankingServerConnect(RankingServerIP, WM_GM_RANKING_CLIENT_MSG_PROC) )

  000b5	68 0c 04 00 00	 push	 1036			; 0000040cH
  000ba	68 00 00 00 00	 push	 OFFSET ?RankingServerIP@@3PADA ; RankingServerIP
  000bf	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  000c4	83 c4 08	 add	 esp, 8
  000c7	85 c0		 test	 eax, eax
  000c9	75 16		 jne	 SHORT $LN4@EGReqBlood

; 1174 : 		{
; 1175 : 			IsDevilSquareEventConnected = 0;

  000cb	5b		 pop	 ebx
  000cc	5f		 pop	 edi
  000cd	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
  000d2	5e		 pop	 esi

; 1186 : 	}
; 1187 : }

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 cd		 xor	 ecx, ebp
  000d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
$LN4@EGReqBlood:

; 1176 : //			LogAddTD("Can not connect Ranking Server");
; 1177 : 			return;
; 1178 : 		}
; 1179 : 
; 1180 : 		IsDevilSquareEventConnected = TRUE;

  000e1	8a 5d d5	 mov	 bl, BYTE PTR _pMsg$[ebp+1]
  000e4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN7@EGReqBlood:

; 1181 : 	}
; 1182 : 
; 1183 : 	if ( IsDevilSquareEventConnected )
; 1184 : 	{
; 1185 : 		wsRServerCli.DataSend((PCHAR)&pMsg, pMsg.h.size);

  000ee	0f b6 c3	 movzx	 eax, bl
  000f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  000f6	50		 push	 eax
  000f7	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
  00100	5b		 pop	 ebx
$LN5@EGReqBlood:

; 1186 : 	}
; 1187 : }

  00101	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00104	5f		 pop	 edi
  00105	33 cd		 xor	 ecx, ebp
  00107	5e		 pop	 esi
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
?EGReqBloodCastleEnter@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ENDP ; EGReqBloodCastleEnter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGDevilSquareEnter@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EGDevilSquareEnter@@YAXH@Z PROC			; EGDevilSquareEnter, COMDAT

; 1116 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 1117 : 	if ( !gObjIsConnected(iIndex) )

  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 c9 00 00
	00		 je	 $LN5@EGDevilSqu

; 1118 : 		return;
; 1119 : 
; 1120 : 	PMSG_REQ_BLOODCASTLE_ENTERCOUNT pMsg;
; 1121 : 
; 1122 : 	pMsg.h.c = 0xC1;
; 1123 : 	pMsg.h.headcode = 0x07;
; 1124 : 	pMsg.h.size = sizeof(pMsg);
; 1125 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, 10);

  00025	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0002b	66 c7 45 dc c1
	20		 mov	 WORD PTR _pMsg$[ebp], 8385 ; 000020c1H
  00031	c6 45 de 07	 mov	 BYTE PTR _pMsg$[ebp+2], 7
  00035	53		 push	 ebx
  00036	b3 20		 mov	 bl, 32			; 00000020H
  00038	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003e	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  00043	66 0f d6 45 df	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  00048	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  0004c	66 89 45 e7	 mov	 WORD PTR _pMsg$[ebp+11], ax

; 1126 : 	memcpy(pMsg.GameID, gObj[iIndex].Name, 10);

  00050	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  00055	66 0f d6 45 e9	 movq	 QWORD PTR _pMsg$[ebp+13], xmm0
  0005a	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]

; 1127 : 	pMsg.ServerCode = gGameServerCode / 20;

  0005e	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00065	66 89 45 f1	 mov	 WORD PTR _pMsg$[ebp+21], ax
  00069	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0006e	f7 e9		 imul	 ecx

; 1128 : 	pMsg.iObjIndex = iIndex;

  00070	89 75 f8	 mov	 DWORD PTR _pMsg$[ebp+28], esi
  00073	c1 fa 03	 sar	 edx, 3
  00076	8b c2		 mov	 eax, edx
  00078	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007b	03 c2		 add	 eax, edx

; 1129 : 
; 1130 : 	if ( !IsDevilSquareEventConnected )

  0007d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00084	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  00087	75 52		 jne	 SHORT $LN7@EGDevilSqu

; 1131 : 	{
; 1132 : 		wsRServerCli.Close();

  00089	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  0008e	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 1133 : 		wsRServerCli.CreateSocket(ghWnd);

  00093	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00099	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  0009e	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 1134 : 
; 1135 : 		if ( !GMRankingServerConnect(RankingServerIP, WM_GM_RANKING_CLIENT_MSG_PROC) )

  000a3	68 0c 04 00 00	 push	 1036			; 0000040cH
  000a8	68 00 00 00 00	 push	 OFFSET ?RankingServerIP@@3PADA ; RankingServerIP
  000ad	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  000b2	83 c4 08	 add	 esp, 8
  000b5	85 c0		 test	 eax, eax
  000b7	75 15		 jne	 SHORT $LN4@EGDevilSqu

; 1136 : 		{
; 1137 : 			IsDevilSquareEventConnected = 0;

  000b9	5b		 pop	 ebx
  000ba	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
  000bf	5e		 pop	 esi

; 1148 : 	}
; 1149 : }

  000c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	33 cd		 xor	 ecx, ebp
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
$LN4@EGDevilSqu:

; 1138 : //			LogAddTD("Can not connect Ranking Server");
; 1139 : 			return;
; 1140 : 		}
; 1141 : 
; 1142 : 		IsDevilSquareEventConnected = TRUE;

  000ce	8a 5d dd	 mov	 bl, BYTE PTR _pMsg$[ebp+1]
  000d1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN7@EGDevilSqu:

; 1143 : 	}
; 1144 : 
; 1145 : 	if ( IsDevilSquareEventConnected )
; 1146 : 	{
; 1147 : 		wsRServerCli.DataSend((PCHAR)&pMsg, pMsg.h.size);

  000db	0f b6 c3	 movzx	 eax, bl
  000de	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  000e3	50		 push	 eax
  000e4	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
  000ed	5b		 pop	 ebx
$LN5@EGDevilSqu:

; 1148 : 	}
; 1149 : }

  000ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f1	33 cd		 xor	 ecx, ebp
  000f3	5e		 pop	 esi
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
?EGDevilSquareEnter@@YAXH@Z ENDP			; EGDevilSquareEnter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGAnsDevilSquareEnter@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTER@@@Z
_TEXT	SEGMENT
_szName$ = -32						; size = 11
_szAccountID$ = -20					; size = 11
_pMsg$1 = -8						; size = 5
_pResult$2 = 8						; size = 4
_lpMsg$ = 8						; size = 4
?EGAnsDevilSquareEnter@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTER@@@Z PROC ; EGAnsDevilSquareEnter, COMDAT

; 1081 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi

; 1082 : 	if ( !lpMsg)

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	0f 84 1c 01 00
	00		 je	 $LN5@EGAnsDevil

; 1083 : 		return;
; 1084 : 
; 1085 : 	if ( !gObjIsConnected(lpMsg->iObjIndex))

  00012	ff 76 1c	 push	 DWORD PTR [esi+28]
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 09 01 00
	00		 je	 $LN5@EGAnsDevil

; 1086 : 		return;
; 1087 : 
; 1088 : 	char szAccountID[11] = {0};
; 1089 : 	char szName[11] = {0};
; 1090 : 	memcpy(szAccountID, lpMsg->AccountID, 10);

  00025	0f b7 46 0b	 movzx	 eax, WORD PTR [esi+11]

; 1091 : 	memcpy(szName, lpMsg->GameID, 10);
; 1092 : 
; 1093 : 	if ( strcmp(gObj[lpMsg->iObjIndex].AccountID, szAccountID) ||

  00029	8d 4d ec	 lea	 ecx, DWORD PTR _szAccountID$[ebp]
  0002c	53		 push	 ebx
  0002d	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	57		 push	 edi
  00034	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  0003a	66 0f d6 45 ed	 movq	 QWORD PTR _szAccountID$[ebp+1], xmm0
  0003f	66 0f d6 45 e1	 movq	 QWORD PTR _szName$[ebp+1], xmm0
  00044	f3 0f 7e 46 03	 movq	 xmm0, QWORD PTR [esi+3]
  00049	66 c7 45 f5 00
	00		 mov	 WORD PTR _szAccountID$[ebp+9], 0
  0004f	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	66 89 45 f4	 mov	 WORD PTR _szAccountID$[ebp+8], ax
  00059	0f b7 46 15	 movzx	 eax, WORD PTR [esi+21]
  0005d	66 0f d6 45 ec	 movq	 QWORD PTR _szAccountID$[ebp], xmm0
  00062	f3 0f 7e 46 0d	 movq	 xmm0, QWORD PTR [esi+13]
  00067	66 c7 45 e9 00
	00		 mov	 WORD PTR _szName$[ebp+9], 0
  0006d	66 89 45 e8	 mov	 WORD PTR _szName$[ebp+8], ax
  00071	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00074	66 0f d6 45 e0	 movq	 QWORD PTR _szName$[ebp], xmm0
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@EGAnsDevil:
  00080	8a 10		 mov	 dl, BYTE PTR [eax]
  00082	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00084	75 1a		 jne	 SHORT $LN10@EGAnsDevil
  00086	84 d2		 test	 dl, dl
  00088	74 12		 je	 SHORT $LN11@EGAnsDevil
  0008a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0008d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00090	75 0e		 jne	 SHORT $LN10@EGAnsDevil
  00092	83 c0 02	 add	 eax, 2
  00095	83 c1 02	 add	 ecx, 2
  00098	84 d2		 test	 dl, dl
  0009a	75 e4		 jne	 SHORT $LL9@EGAnsDevil
$LN11@EGAnsDevil:
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 05		 jmp	 SHORT $LN12@EGAnsDevil
$LN10@EGAnsDevil:
  000a0	1b c0		 sbb	 eax, eax
  000a2	83 c8 01	 or	 eax, 1
$LN12@EGAnsDevil:
  000a5	85 c0		 test	 eax, eax
  000a7	0f 85 7f 00 00
	00		 jne	 $LN17@EGAnsDevil
  000ad	8d 45 e0	 lea	 eax, DWORD PTR _szName$[ebp]
  000b0	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
$LL13@EGAnsDevil:
  000b3	8a 11		 mov	 dl, BYTE PTR [ecx]
  000b5	3a 10		 cmp	 dl, BYTE PTR [eax]
  000b7	75 1a		 jne	 SHORT $LN14@EGAnsDevil
  000b9	84 d2		 test	 dl, dl
  000bb	74 12		 je	 SHORT $LN15@EGAnsDevil
  000bd	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  000c0	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  000c3	75 0e		 jne	 SHORT $LN14@EGAnsDevil
  000c5	83 c1 02	 add	 ecx, 2
  000c8	83 c0 02	 add	 eax, 2
  000cb	84 d2		 test	 dl, dl
  000cd	75 e4		 jne	 SHORT $LL13@EGAnsDevil
$LN15@EGAnsDevil:
  000cf	33 c0		 xor	 eax, eax
  000d1	eb 05		 jmp	 SHORT $LN16@EGAnsDevil
$LN14@EGAnsDevil:
  000d3	1b c0		 sbb	 eax, eax
  000d5	83 c8 01	 or	 eax, 1
$LN16@EGAnsDevil:
  000d8	85 c0		 test	 eax, eax
  000da	75 50		 jne	 SHORT $LN17@EGAnsDevil

; 1094 : 		 strcmp(gObj[lpMsg->iObjIndex].Name, szName) )
; 1095 : 		 return;
; 1096 : 
; 1097 : 	if( lpMsg->iResult == 1 )

  000dc	83 7e 20 01	 cmp	 DWORD PTR [esi+32], 1
  000e0	75 22		 jne	 SHORT $LN6@EGAnsDevil

; 1098 : 	{
; 1099 : 		PMSG_REQ_MOVEDEVILSQUARE pMsg;
; 1100 : 		pMsg.SquareNumber = lpMsg->iBloodCastle;

  000e2	0f b6 46 24	 movzx	 eax, BYTE PTR [esi+36]
  000e6	88 45 fb	 mov	 BYTE PTR _pMsg$1[ebp+3], al

; 1101 : 		pMsg.InvitationItemPos = lpMsg->iBloodCastleItemPos;

  000e9	0f b6 46 28	 movzx	 eax, BYTE PTR [esi+40]
  000ed	88 45 fc	 mov	 BYTE PTR _pMsg$1[ebp+4], al

; 1102 : 
; 1103 : 		GCReqmoveDevilSquare(&pMsg,lpMsg->iObjIndex);

  000f0	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  000f3	53		 push	 ebx
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ; GCReqmoveDevilSquare
  000fa	83 c4 08	 add	 esp, 8
  000fd	5f		 pop	 edi
  000fe	5b		 pop	 ebx
  000ff	5e		 pop	 esi

; 1112 : 	}
; 1113 : }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
$LN6@EGAnsDevil:

; 1104 : 	}
; 1105 : 	else
; 1106 : 	{
; 1107 : 		PMSG_RESULT_MOVEBLOODCASTLE pResult;
; 1108 : 		PHeadSetB((LPBYTE)&pResult,0x9A,sizeof(pResult));

  00104	6a 04		 push	 4
  00106	8d 45 08	 lea	 eax, DWORD PTR _pResult$2[ebp]
  00109	68 9a 00 00 00	 push	 154			; 0000009aH
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1109 : 		pResult.Result = 6;
; 1110 : 
; 1111 : 		DataSend(lpMsg->iObjIndex,(LPBYTE)&pResult,pResult.h.size);

  00114	0f b6 45 09	 movzx	 eax, BYTE PTR _pResult$2[ebp+1]
  00118	50		 push	 eax
  00119	8d 45 08	 lea	 eax, DWORD PTR _pResult$2[ebp]
  0011c	c6 45 0b 06	 mov	 BYTE PTR _pResult$2[ebp+3], 6
  00120	50		 push	 eax
  00121	ff 76 1c	 push	 DWORD PTR [esi+28]
  00124	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00129	83 c4 18	 add	 esp, 24			; 00000018H
$LN17@EGAnsDevil:
  0012c	5f		 pop	 edi
  0012d	5b		 pop	 ebx
$LN5@EGAnsDevil:
  0012e	5e		 pop	 esi

; 1112 : 	}
; 1113 : }

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
?EGAnsDevilSquareEnter@@YAXPAUPMSG_ANS_BLOODCASTLE_ENTER@@@Z ENDP ; EGAnsDevilSquareEnter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGReqDevilSquareEnter@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z
_TEXT	SEGMENT
_pMsg$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?EGReqDevilSquareEnter@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z PROC ; EGReqDevilSquareEnter, COMDAT

; 1043 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 1044 : 	if ( !gObjIsConnected(iIndex) )

  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	0f 84 d8 00 00
	00		 je	 $LN5@EGReqDevil

; 1045 : 		return;
; 1046 : 
; 1047 : 	PMSG_REQ_BLOODCASTLE_ENTER pMsg;
; 1048 : 
; 1049 : 	pMsg.h.c = 0xC1;
; 1050 : 	pMsg.h.headcode = 0x06;
; 1051 : 	pMsg.h.size = sizeof(pMsg);
; 1052 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, 10);

  00029	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0002f	66 c7 45 d4 c1
	28		 mov	 WORD PTR _pMsg$[ebp], 10433 ; 000028c1H
  00035	c6 45 d6 06	 mov	 BYTE PTR _pMsg$[ebp+2], 6
  00039	53		 push	 ebx
  0003a	b3 28		 mov	 bl, 40			; 00000028H
  0003c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00042	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  00047	66 0f d6 45 d7	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  0004c	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  00050	66 89 45 df	 mov	 WORD PTR _pMsg$[ebp+11], ax

; 1053 : 	memcpy(pMsg.GameID, gObj[iIndex].Name, 10);

  00054	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  00059	66 0f d6 45 e1	 movq	 QWORD PTR _pMsg$[ebp+13], xmm0
  0005e	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]

; 1054 : 	pMsg.ServerCode = gGameServerCode / 20;

  00062	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00069	66 89 45 e9	 mov	 WORD PTR _pMsg$[ebp+21], ax
  0006d	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00072	f7 e9		 imul	 ecx

; 1055 : 	pMsg.iObjIndex = iIndex;

  00074	89 75 f0	 mov	 DWORD PTR _pMsg$[ebp+28], esi
  00077	c1 fa 03	 sar	 edx, 3
  0007a	8b c2		 mov	 eax, edx
  0007c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007f	03 c2		 add	 eax, edx

; 1056 : 	pMsg.iBloodCastle = lpMsg->SquareNumber;
; 1057 : 	pMsg.iBloodCastleItemPos = lpMsg->InvitationItemPos;
; 1058 : 
; 1059 : 	if ( !IsDevilSquareEventConnected )

  00081	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00088	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  0008b	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0008f	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+32], eax
  00092	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00096	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+36], eax
  00099	75 53		 jne	 SHORT $LN7@EGReqDevil

; 1060 : 	{
; 1061 : 		wsRServerCli.Close();

  0009b	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000a0	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 1062 : 		wsRServerCli.CreateSocket(ghWnd);

  000a5	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000ab	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000b0	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 1063 : 
; 1064 : 		if ( !GMRankingServerConnect(RankingServerIP, WM_GM_RANKING_CLIENT_MSG_PROC) )

  000b5	68 0c 04 00 00	 push	 1036			; 0000040cH
  000ba	68 00 00 00 00	 push	 OFFSET ?RankingServerIP@@3PADA ; RankingServerIP
  000bf	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  000c4	83 c4 08	 add	 esp, 8
  000c7	85 c0		 test	 eax, eax
  000c9	75 16		 jne	 SHORT $LN4@EGReqDevil

; 1065 : 		{
; 1066 : 			IsDevilSquareEventConnected = 0;

  000cb	5b		 pop	 ebx
  000cc	5f		 pop	 edi
  000cd	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected
  000d2	5e		 pop	 esi

; 1077 : 	}
; 1078 : }

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 cd		 xor	 ecx, ebp
  000d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
$LN4@EGReqDevil:

; 1067 : //			LogAddTD("Can not connect Ranking Server");
; 1068 : 			return;
; 1069 : 		}
; 1070 : 
; 1071 : 		IsDevilSquareEventConnected = TRUE;

  000e1	8a 5d d5	 mov	 bl, BYTE PTR _pMsg$[ebp+1]
  000e4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN7@EGReqDevil:

; 1072 : 	}
; 1073 : 
; 1074 : 	if ( IsDevilSquareEventConnected )
; 1075 : 	{
; 1076 : 		wsRServerCli.DataSend((PCHAR)&pMsg, pMsg.h.size);

  000ee	0f b6 c3	 movzx	 eax, bl
  000f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  000f6	50		 push	 eax
  000f7	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
  00100	5b		 pop	 ebx
$LN5@EGReqDevil:

; 1077 : 	}
; 1078 : }

  00101	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00104	5f		 pop	 edi
  00105	33 cd		 xor	 ecx, ebp
  00107	5e		 pop	 esi
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
?EGReqDevilSquareEnter@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ENDP ; EGReqDevilSquareEnter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGRecvRegRingGift@@YAXPAUPMSG_ANS_REG_RINGGIFT@@@Z
_TEXT	SEGMENT
_szTemp$1 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?EGRecvRegRingGift@@YAXPAUPMSG_ANS_REG_RINGGIFT@@@Z PROC ; EGRecvRegRingGift, COMDAT

; 998  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 999  : 	gObj[aRecv->iINDEX].UseEventServer = FALSE;

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  0001c	69 4e 04 40 27
	00 00		 imul	 ecx, DWORD PTR [esi+4], 10048
  00023	c7 84 01 e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+5096], 0

; 1000 : 
; 1001 : 	if ( gObjIsConnected(aRecv->iINDEX) == FALSE )

  0002e	ff 76 04	 push	 DWORD PTR [esi+4]
  00031	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00036	83 c4 04	 add	 esp, 4
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 57 01 00
	00		 je	 $LN7@EGRecvRegR

; 1002 : 		return;
; 1003 : 
; 1004 : 	if ( strcmp(aRecv->szUID, gObj[aRecv->iINDEX].AccountID))

  00041	53		 push	 ebx
  00042	57		 push	 edi
  00043	69 7e 04 40 27
	00 00		 imul	 edi, DWORD PTR [esi+4], 10048
  0004a	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0004d	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00053	8d 5f 52	 lea	 ebx, DWORD PTR [edi+82]
  00056	8b cb		 mov	 ecx, ebx
$LL11@EGRecvRegR:
  00058	8a 10		 mov	 dl, BYTE PTR [eax]
  0005a	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0005c	75 1a		 jne	 SHORT $LN12@EGRecvRegR
  0005e	84 d2		 test	 dl, dl
  00060	74 12		 je	 SHORT $LN13@EGRecvRegR
  00062	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00065	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00068	75 0e		 jne	 SHORT $LN12@EGRecvRegR
  0006a	83 c0 02	 add	 eax, 2
  0006d	83 c1 02	 add	 ecx, 2
  00070	84 d2		 test	 dl, dl
  00072	75 e4		 jne	 SHORT $LL11@EGRecvRegR
$LN13@EGRecvRegR:
  00074	33 c0		 xor	 eax, eax
  00076	eb 05		 jmp	 SHORT $LN14@EGRecvRegR
$LN12@EGRecvRegR:
  00078	1b c0		 sbb	 eax, eax
  0007a	83 c8 01	 or	 eax, 1
$LN14@EGRecvRegR:
  0007d	85 c0		 test	 eax, eax
  0007f	0f 85 11 01 00
	00		 jne	 $LN15@EGRecvRegR

; 1005 : 		return;
; 1006 : 
; 1007 : 	if ( aRecv->btIsRegistered == 1 )

  00085	8a 46 13	 mov	 al, BYTE PTR [esi+19]
  00088	3c 01		 cmp	 al, 1
  0008a	0f 85 a8 00 00
	00		 jne	 $LN4@EGRecvRegR

; 1008 : 	{
; 1009 : 		if ( CHECK_LIMIT(aRecv->btGiftKind-1, 4) )

  00090	0f b6 4e 15	 movzx	 ecx, BYTE PTR [esi+21]
  00094	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  00097	85 d2		 test	 edx, edx
  00099	78 76		 js	 SHORT $LN5@EGRecvRegR
  0009b	33 c0		 xor	 eax, eax
  0009d	83 fa 03	 cmp	 edx, 3
  000a0	0f 9e c0	 setle	 al
  000a3	85 c0		 test	 eax, eax
  000a5	74 6a		 je	 SHORT $LN5@EGRecvRegR

; 1010 : 		{
; 1011 : 			char szTemp[256];
; 1012 : 			wsprintf(szTemp, "%s님 께서 %s에 당첨되셨습니다.",

  000a7	c1 e1 05	 shl	 ecx, 5
  000aa	8d 81 e0 ff ff
	ff		 lea	 eax, DWORD PTR ?g_szRingEventOfflineGift@@3QAY0CA@$$CBDA[ecx-32]
  000b0	50		 push	 eax
  000b1	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  000b4	50		 push	 eax
  000b5	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$1[ebp]
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LPHCCDAB@?$CFs?$LE?T?5?$LC?$LC?$LM?$KN?5?$CFs?$LP?$KB?5?$LE?g?C?$LH?$LF?G?$LM?L?$LN?$MA?$LE?O?$LE?Y?4?$AA@
  000c0	50		 push	 eax
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 1013 : 				gObj[aRecv->iINDEX].Name, g_szRingEventOfflineGift[aRecv->btGiftKind-1]);
; 1014 : 
; 1015 : 			AllSendServerMsg(szTemp);

  000c7	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$1[ebp]
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg

; 1016 : 
; 1017 : 			LogAddTD("[Ring Event] [%s][%s] Register Succeeded Result:%d, Gift:%d",

  000d3	69 4e 04 40 27
	00 00		 imul	 ecx, DWORD PTR [esi+4], 10048
  000da	0f b6 46 15	 movzx	 eax, BYTE PTR [esi+21]
  000de	50		 push	 eax
  000df	0f b6 46 13	 movzx	 eax, BYTE PTR [esi+19]
  000e3	50		 push	 eax
  000e4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ea	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000ed	50		 push	 eax
  000ee	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000f1	50		 push	 eax
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@EBGDAEID@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5S@
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000fd	83 c4 28	 add	 esp, 40			; 00000028H
  00100	5f		 pop	 edi
  00101	5b		 pop	 ebx
  00102	5e		 pop	 esi

; 1038 : 	}
; 1039 : }

  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
$LN5@EGRecvRegR:

; 1018 : 				gObj[aRecv->iINDEX].AccountID, gObj[aRecv->iINDEX].Name,
; 1019 : 				aRecv->btIsRegistered, aRecv->btGiftKind);
; 1020 : 		}
; 1021 : 		else
; 1022 : 		{
; 1023 : 			LogAddTD("[Ring Event] [%s][%s] Register Failed Result:%d, Gift:%d (out of bound, 1~4)",

  00111	51		 push	 ecx
  00112	6a 01		 push	 1
  00114	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00117	50		 push	 eax
  00118	53		 push	 ebx
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@JKCGIJEK@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5F@
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00124	83 c4 14	 add	 esp, 20			; 00000014H
  00127	5f		 pop	 edi
  00128	5b		 pop	 ebx
  00129	5e		 pop	 esi

; 1038 : 	}
; 1039 : }

  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
$LN4@EGRecvRegR:

; 1024 : 				gObj[aRecv->iINDEX].AccountID, gObj[aRecv->iINDEX].Name,
; 1025 : 				aRecv->btIsRegistered, aRecv->btGiftKind);
; 1026 : 		}
; 1027 : 
; 1028 : 		return;
; 1029 : 	}
; 1030 : 
; 1031 : 	LogAddTD("[Ring Event] [%s][%s] Register Failed Result : %d",

  00138	0f b6 c0	 movzx	 eax, al
  0013b	50		 push	 eax
  0013c	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0013f	50		 push	 eax
  00140	53		 push	 ebx
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@NJLHLHM@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Register?5F@
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1032 : 		gObj[aRecv->iINDEX].AccountID, gObj[aRecv->iINDEX].Name,
; 1033 : 		aRecv->btIsRegistered);
; 1034 : 
; 1035 : 	if ( gObjIsConnected(aRecv->iINDEX) == TRUE )

  0014c	ff 76 04	 push	 DWORD PTR [esi+4]
  0014f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00154	83 c4 14	 add	 esp, 20			; 00000014H
  00157	83 f8 01	 cmp	 eax, 1
  0015a	75 3a		 jne	 SHORT $LN15@EGRecvRegR

; 1036 : 	{
; 1037 : 		MapC[gObj[aRecv->iINDEX].MapNumber].MoneyItemDrop(100000, (BYTE)gObj[aRecv->iINDEX].X, (BYTE)gObj[aRecv->iINDEX].Y);

  0015c	69 4e 04 40 27
	00 00		 imul	 ecx, DWORD PTR [esi+4], 10048
  00163	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00169	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  00170	50		 push	 eax
  00171	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  00178	50		 push	 eax
  00179	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  00180	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  00186	68 a0 86 01 00	 push	 100000			; 000186a0H
  0018b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00191	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN15@EGRecvRegR:
  00196	5f		 pop	 edi
  00197	5b		 pop	 ebx
$LN7@EGRecvRegR:

; 1038 : 	}
; 1039 : }

  00198	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019b	33 cd		 xor	 ecx, ebp
  0019d	5e		 pop	 esi
  0019e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c3		 ret	 0
?EGRecvRegRingGift@@YAXPAUPMSG_ANS_REG_RINGGIFT@@@Z ENDP ; EGRecvRegRingGift
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGRecv2AnvRegSerial@@YAXPAUPMSG_ANS_2ANIV_SERIAL@@@Z
_TEXT	SEGMENT
_ServerCmd$1 = -80					; size = 7
_Result$ = -72						; size = 68
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?EGRecv2AnvRegSerial@@YAXPAUPMSG_ANS_2ANIV_SERIAL@@@Z PROC ; EGRecv2AnvRegSerial, COMDAT

; 404  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 405  : 	PMSG_ANS_2ANV_LOTTO_EVENT Result;
; 406  : 
; 407  : 	PHeadSetB((LPBYTE)&Result, 0x9D, sizeof(Result));

  00014	8d 45 b8	 lea	 eax, DWORD PTR _Result$[ebp]
  00017	6a 44		 push	 68			; 00000044H
  00019	68 9d 00 00 00	 push	 157			; 0000009dH
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 408  : 
; 409  : 	if ( !OBJMAX_RANGE(aRecv->iINDEX))

  00024	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	85 d2		 test	 edx, edx
  0002c	0f 88 6d 13 00
	00		 js	 $LN100@EGRecv2Anv
  00032	33 c0		 xor	 eax, eax
  00034	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  0003a	0f 9e c0	 setle	 al
  0003d	85 c0		 test	 eax, eax
  0003f	0f 84 5a 13 00
	00		 je	 $LN100@EGRecv2Anv

; 412  : 		return;
; 413  : 	}
; 414  : 
; 415  : 	if ( gObj[aRecv->iINDEX].Connected <= PLAYER_LOGGED )

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004a	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00050	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00055	0f 8e 44 13 00
	00		 jle	 $LN100@EGRecv2Anv

; 416  : 	{
; 417  : 		LogAddTD("[Mu_2Anv_Event] Error : Index is out of bound [%d]", aRecv->iINDEX);
; 418  : 		return;
; 419  : 	}
; 420  : 
; 421  : 	Result.szGIFT_NAME[0] = 0;
; 422  : 
; 423  : 	if ( aRecv->btIsRegistered == FALSE )

  0005b	8a 47 13	 mov	 al, BYTE PTR [edi+19]
  0005e	c6 45 bc 00	 mov	 BYTE PTR _Result$[ebp+4], 0
  00062	56		 push	 esi
  00063	84 c0		 test	 al, al
  00065	0f 85 a5 12 00
	00		 jne	 $LN6@EGRecv2Anv

; 424  : 	{
; 425  : 		Result.btIsRegistered = FALSE;
; 426  : 		
; 427  : 		if ( !GIFT_2ANV_RANGE(aRecv->iGiftNumber-1) )

  0006b	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0006e	88 45 bb	 mov	 BYTE PTR _Result$[ebp+3], al
  00071	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  00074	85 d2		 test	 edx, edx
  00076	78 0c		 js	 SHORT $LN101@EGRecv2Anv
  00078	33 c0		 xor	 eax, eax
  0007a	83 fa 31	 cmp	 edx, 49			; 00000031H
  0007d	0f 9e c0	 setle	 al
  00080	85 c0		 test	 eax, eax
  00082	75 13		 jne	 SHORT $LN8@EGRecv2Anv
$LN101@EGRecv2Anv:

; 428  : 		{
; 429  : 			LogAddTD("[Mu_2Anv_Event] Error : Gift Index is out of bound [%d]", aRecv->iGiftNumber);

  00084	51		 push	 ecx
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@IMNBMFDN@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Gift?5Ind@
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00090	83 c4 08	 add	 esp, 8

; 430  : 			Result.btIsRegistered = 2;

  00093	c6 45 bb 02	 mov	 BYTE PTR _Result$[ebp+3], 2
$LN8@EGRecv2Anv:

; 431  : 		}
; 432  : 
; 433  : 		if ( gObj[aRecv->iINDEX].Connected > PLAYER_LOGGED )

  00097	69 4f 04 40 27
	00 00		 imul	 ecx, DWORD PTR [edi+4], 10048
  0009e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a3	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  000a8	7e 54		 jle	 SHORT $LN9@EGRecv2Anv

; 434  : 		{
; 435  : 			PMSG_SERVERCMD ServerCmd;
; 436  : 
; 437  : 			PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  000aa	6a 07		 push	 7
  000ac	6a 40		 push	 64			; 00000040H
  000ae	8d 45 b0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  000b1	68 f3 00 00 00	 push	 243			; 000000f3H
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 438  : 			ServerCmd.CmdType = 0;
; 439  : 			ServerCmd.X = gObj[aRecv->iINDEX].X;

  000bc	69 4f 04 40 27
	00 00		 imul	 ecx, DWORD PTR [edi+4], 10048
  000c3	c6 45 b4 00	 mov	 BYTE PTR _ServerCmd$1[ebp+4], 0

; 440  : 			ServerCmd.Y = gObj[aRecv->iINDEX].Y;
; 441  : 
; 442  : 			MsgSendV2(&gObj[aRecv->iINDEX], (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  000c7	6a 07		 push	 7
  000c9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cf	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  000d6	88 45 b5	 mov	 BYTE PTR _ServerCmd$1[ebp+5], al
  000d9	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  000e0	88 45 b6	 mov	 BYTE PTR _ServerCmd$1[ebp+6], al
  000e3	8d 45 b0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  000e6	50		 push	 eax
  000e7	51		 push	 ecx
  000e8	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 443  : 			DataSend(aRecv->iINDEX, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  000ed	6a 07		 push	 7
  000ef	8d 45 b0	 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  000f2	50		 push	 eax
  000f3	ff 77 04	 push	 DWORD PTR [edi+4]
  000f6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000fb	83 c4 28	 add	 esp, 40			; 00000028H
$LN9@EGRecv2Anv:

; 444  : 		}
; 445  : 
; 446  : 		if ( g_bRingEventItemTextLoad )

  000fe	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00105	74 1b		 je	 SHORT $LN10@EGRecv2Anv

; 447  : 		{
; 448  : 			strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), g_sz2ANV_GIFT_NAME[aRecv->iGiftNumber-1]);

  00107	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0010a	c1 e0 06	 shl	 eax, 6
  0010d	8d 80 c0 ff ff
	ff		 lea	 eax, DWORD PTR ?g_sz2ANV_GIFT_NAME@@3PAY0EA@DA[eax-64]
  00113	50		 push	 eax
  00114	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00117	6a 40		 push	 64			; 00000040H
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 _strcpy_s
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@EGRecv2Anv:

; 449  : 		}
; 450  : 
; 451  : 		switch ( aRecv->iGiftNumber )

  00122	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00125	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00128	83 f9 31	 cmp	 ecx, 49			; 00000031H
  0012b	0f 87 ce 11 00
	00		 ja	 $LN91@EGRecv2Anv
  00131	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN104@EGRecv2Anv[ecx*4]
$LN11@EGRecv2Anv:

; 452  : 		{
; 453  : 			case 1:
; 454  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00138	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  0013f	6a 00		 push	 0
  00141	6a 00		 push	 0
  00143	6a 00		 push	 0
  00145	6a 00		 push	 0
  00147	ff 77 04	 push	 DWORD PTR [edi+4]
  0014a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00150	6a 00		 push	 0
  00152	6a 00		 push	 0
  00154	6a 00		 push	 0
  00156	6a 00		 push	 0
  00158	6a 00		 push	 0
  0015a	6a 0d		 push	 13			; 0000000dH
  0015c	6a 0e		 push	 14			; 0000000eH
  0015e	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00163	83 c4 08	 add	 esp, 8
  00166	50		 push	 eax
  00167	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0016e	50		 push	 eax
  0016f	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00176	50		 push	 eax
  00177	68 eb 00 00 00	 push	 235			; 000000ebH
  0017c	ff 36		 push	 DWORD PTR [esi]
  0017e	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00183	83 c4 3c	 add	 esp, 60			; 0000003cH

; 455  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 456  : 					ItemGetNumberMake(14, 13),
; 457  : 					0, 0, 0, 0, 0,
; 458  : 					aRecv->iINDEX,
; 459  : 					0, 0);
; 460  : 
; 461  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00186	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  0018d	0f 85 ac 11 00
	00		 jne	 $LN93@EGRecv2Anv

; 462  : 				{
; 463  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 13)].Name);

  00193	68 b0 45 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804272
  00198	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  0019b	6a 40		 push	 64			; 00000040H
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 _strcpy_s
  001a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 464  : 				}
; 465  : 				break;

  001a6	e9 94 11 00 00	 jmp	 $LN93@EGRecv2Anv
$LN13@EGRecv2Anv:

; 466  : 			case 2:
; 467  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  001ab	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  001b2	6a 00		 push	 0
  001b4	6a 00		 push	 0
  001b6	6a 00		 push	 0
  001b8	6a 00		 push	 0
  001ba	ff 77 04	 push	 DWORD PTR [edi+4]
  001bd	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c3	6a 00		 push	 0
  001c5	6a 00		 push	 0
  001c7	6a 00		 push	 0
  001c9	6a 00		 push	 0
  001cb	6a 00		 push	 0
  001cd	6a 0e		 push	 14			; 0000000eH
  001cf	6a 0e		 push	 14			; 0000000eH
  001d1	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  001d6	83 c4 08	 add	 esp, 8
  001d9	50		 push	 eax
  001da	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  001e1	50		 push	 eax
  001e2	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  001e9	50		 push	 eax
  001ea	68 eb 00 00 00	 push	 235			; 000000ebH
  001ef	ff 36		 push	 DWORD PTR [esi]
  001f1	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  001f6	83 c4 3c	 add	 esp, 60			; 0000003cH

; 468  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 469  : 					ItemGetNumberMake(14, 14),
; 470  : 					0, 0, 0, 0, 0,
; 471  : 					aRecv->iINDEX,
; 472  : 					0, 0);
; 473  : 
; 474  : 				if ( g_bRingEventItemTextLoad == FALSE )

  001f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00200	0f 85 39 11 00
	00		 jne	 $LN93@EGRecv2Anv

; 475  : 				{
; 476  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 14)].Name);

  00206	68 20 46 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804384
  0020b	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  0020e	6a 40		 push	 64			; 00000040H
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 _strcpy_s
  00216	83 c4 0c	 add	 esp, 12			; 0000000cH

; 477  : 				}
; 478  : 				break;

  00219	e9 21 11 00 00	 jmp	 $LN93@EGRecv2Anv
$LN15@EGRecv2Anv:

; 479  : 			case 3:
; 480  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  0021e	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00225	6a 00		 push	 0
  00227	6a 00		 push	 0
  00229	6a 00		 push	 0
  0022b	6a 00		 push	 0
  0022d	ff 77 04	 push	 DWORD PTR [edi+4]
  00230	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00236	6a 00		 push	 0
  00238	6a 00		 push	 0
  0023a	6a 00		 push	 0
  0023c	6a 00		 push	 0
  0023e	6a 00		 push	 0
  00240	6a 0f		 push	 15			; 0000000fH
  00242	6a 0c		 push	 12			; 0000000cH
  00244	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00249	83 c4 08	 add	 esp, 8
  0024c	50		 push	 eax
  0024d	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00254	50		 push	 eax
  00255	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0025c	50		 push	 eax
  0025d	68 eb 00 00 00	 push	 235			; 000000ebH
  00262	ff 36		 push	 DWORD PTR [esi]
  00264	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00269	83 c4 3c	 add	 esp, 60			; 0000003cH

; 481  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 482  : 					ItemGetNumberMake(12, 15),
; 483  : 					0, 0, 0, 0, 0,
; 484  : 					aRecv->iINDEX,
; 485  : 					0, 0);
; 486  : 
; 487  : 				if ( g_bRingEventItemTextLoad == FALSE )

  0026c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00273	0f 85 c6 10 00
	00		 jne	 $LN93@EGRecv2Anv

; 488  : 				{
; 489  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(12, 15)].Name);

  00279	68 90 86 0a 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+689808
  0027e	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00281	6a 40		 push	 64			; 00000040H
  00283	50		 push	 eax
  00284	e8 00 00 00 00	 call	 _strcpy_s
  00289	83 c4 0c	 add	 esp, 12			; 0000000cH

; 490  : 				}
; 491  : 				break;

  0028c	e9 ae 10 00 00	 jmp	 $LN93@EGRecv2Anv
$LN17@EGRecv2Anv:

; 492  : 			case 4:
; 493  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00291	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00298	6a 00		 push	 0
  0029a	6a 00		 push	 0
  0029c	6a 00		 push	 0
  0029e	6a 00		 push	 0
  002a0	ff 77 04	 push	 DWORD PTR [edi+4]
  002a3	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a9	6a 00		 push	 0
  002ab	6a 00		 push	 0
  002ad	6a 00		 push	 0
  002af	6a 00		 push	 0
  002b1	6a 00		 push	 0
  002b3	6a 0b		 push	 11			; 0000000bH
  002b5	6a 0e		 push	 14			; 0000000eH
  002b7	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  002bc	83 c4 08	 add	 esp, 8
  002bf	50		 push	 eax
  002c0	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  002c7	50		 push	 eax
  002c8	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  002cf	50		 push	 eax
  002d0	68 eb 00 00 00	 push	 235			; 000000ebH
  002d5	ff 36		 push	 DWORD PTR [esi]
  002d7	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  002dc	83 c4 3c	 add	 esp, 60			; 0000003cH

; 494  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 495  : 					ItemGetNumberMake(14, 11),
; 496  : 					0, 0, 0, 0, 0,
; 497  : 					aRecv->iINDEX,
; 498  : 					0, 0);
; 499  : 
; 500  : 				if ( g_bRingEventItemTextLoad == FALSE )

  002df	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  002e6	0f 85 53 10 00
	00		 jne	 $LN93@EGRecv2Anv

; 501  : 				{
; 502  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 11)].Name);

  002ec	68 d0 44 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804048
  002f1	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  002f4	6a 40		 push	 64			; 00000040H
  002f6	50		 push	 eax
  002f7	e8 00 00 00 00	 call	 _strcpy_s
  002fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 503  : 				}
; 504  : 				break;

  002ff	e9 3b 10 00 00	 jmp	 $LN93@EGRecv2Anv
$LN19@EGRecv2Anv:

; 505  : 			case 5:
; 506  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00304	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  0030b	6a 00		 push	 0
  0030d	6a 00		 push	 0
  0030f	6a 00		 push	 0
  00311	6a 00		 push	 0
  00313	ff 77 04	 push	 DWORD PTR [edi+4]
  00316	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0031c	6a 00		 push	 0
  0031e	6a 00		 push	 0
  00320	6a 00		 push	 0
  00322	6a 00		 push	 0
  00324	6a 03		 push	 3
  00326	6a 0b		 push	 11			; 0000000bH
  00328	6a 0e		 push	 14			; 0000000eH
  0032a	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0032f	83 c4 08	 add	 esp, 8
  00332	50		 push	 eax
  00333	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0033a	50		 push	 eax
  0033b	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00342	50		 push	 eax
  00343	68 eb 00 00 00	 push	 235			; 000000ebH
  00348	ff 36		 push	 DWORD PTR [esi]
  0034a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  0034f	83 c4 3c	 add	 esp, 60			; 0000003cH

; 507  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 508  : 					ItemGetNumberMake(14, 11),
; 509  : 					3, 0, 0, 0, 0,
; 510  : 					aRecv->iINDEX,
; 511  : 					0, 0);
; 512  : 
; 513  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00352	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00359	0f 85 e0 0f 00
	00		 jne	 $LN93@EGRecv2Anv

; 514  : 				{
; 515  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), "Heart of Love");

  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HHCDHNEF@Heart?5of?5Love?$AA@
  00364	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00367	6a 40		 push	 64			; 00000040H
  00369	50		 push	 eax
  0036a	e8 00 00 00 00	 call	 _strcpy_s
  0036f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 516  : 				}
; 517  : 				break;

  00372	e9 c8 0f 00 00	 jmp	 $LN93@EGRecv2Anv
$LN21@EGRecv2Anv:

; 518  : 			case 6:
; 519  : 				gObj[aRecv->iINDEX].Money += 500000;

  00377	69 4f 04 40 27
	00 00		 imul	 ecx, DWORD PTR [edi+4], 10048
  0037e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00383	81 84 01 cc 00
	00 00 20 a1 07
	00		 add	 DWORD PTR [ecx+eax+204], 500000 ; 0007a120H

; 520  : 				GCMoneySend(aRecv->iINDEX, gObj[aRecv->iINDEX].Money);

  0038e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00391	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00396	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  0039c	ff b4 01 cc 00
	00 00		 push	 DWORD PTR [ecx+eax+204]
  003a3	52		 push	 edx
  003a4	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  003a9	83 c4 08	 add	 esp, 8

; 521  : 
; 522  : 				if ( g_bRingEventItemTextLoad == FALSE )

  003ac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  003b3	0f 85 86 0f 00
	00		 jne	 $LN93@EGRecv2Anv

; 523  : 				{
; 524  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), "500,000 Zen");

  003b9	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NFDLLOLF@500?0000?5Zen?$AA@
  003be	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  003c1	6a 40		 push	 64			; 00000040H
  003c3	50		 push	 eax
  003c4	e8 00 00 00 00	 call	 _strcpy_s
  003c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 525  : 				}
; 526  : 				break;

  003cc	e9 6e 0f 00 00	 jmp	 $LN93@EGRecv2Anv
$LN23@EGRecv2Anv:

; 527  : 			case 7:
; 528  : 				gObj[aRecv->iINDEX].Money += 50000;

  003d1	69 4f 04 40 27
	00 00		 imul	 ecx, DWORD PTR [edi+4], 10048
  003d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003dd	81 84 01 cc 00
	00 00 50 c3 00
	00		 add	 DWORD PTR [ecx+eax+204], 50000 ; 0000c350H

; 529  : 				GCMoneySend(aRecv->iINDEX, gObj[aRecv->iINDEX].Money);

  003e8	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  003eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003f0	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  003f6	ff b4 01 cc 00
	00 00		 push	 DWORD PTR [ecx+eax+204]
  003fd	52		 push	 edx
  003fe	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00403	83 c4 08	 add	 esp, 8

; 530  : 
; 531  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00406	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  0040d	0f 85 2c 0f 00
	00		 jne	 $LN93@EGRecv2Anv

; 532  : 				{
; 533  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), "50,000 Zen");

  00413	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DILECEGA@50?0000?5Zen?$AA@
  00418	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  0041b	6a 40		 push	 64			; 00000040H
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 _strcpy_s
  00423	83 c4 0c	 add	 esp, 12			; 0000000cH

; 534  : 				}
; 535  : 				break;

  00426	e9 14 0f 00 00	 jmp	 $LN93@EGRecv2Anv
$LN25@EGRecv2Anv:

; 536  : 			case 8:	case 9:	case 10:
; 537  : 				gObj[aRecv->iINDEX].Money += 30000;

  0042b	69 4f 04 40 27
	00 00		 imul	 ecx, DWORD PTR [edi+4], 10048
  00432	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00437	81 84 01 cc 00
	00 00 30 75 00
	00		 add	 DWORD PTR [ecx+eax+204], 30000 ; 00007530H

; 538  : 				GCMoneySend(aRecv->iINDEX, gObj[aRecv->iINDEX].Money);

  00442	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00445	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0044a	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00450	ff b4 01 cc 00
	00 00		 push	 DWORD PTR [ecx+eax+204]
  00457	52		 push	 edx
  00458	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0045d	83 c4 08	 add	 esp, 8

; 539  : 
; 540  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00460	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00467	0f 85 d2 0e 00
	00		 jne	 $LN93@EGRecv2Anv

; 541  : 				{
; 542  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), "30,000 Zen");

  0046d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NAABOOCD@30?0000?5Zen?$AA@
  00472	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00475	6a 40		 push	 64			; 00000040H
  00477	50		 push	 eax
  00478	e8 00 00 00 00	 call	 _strcpy_s
  0047d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 543  : 				}
; 544  : 				break;

  00480	e9 ba 0e 00 00	 jmp	 $LN93@EGRecv2Anv
$LN27@EGRecv2Anv:

; 545  : 			case 11:
; 546  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00485	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  0048c	6a 00		 push	 0
  0048e	6a 00		 push	 0
  00490	6a 00		 push	 0
  00492	6a 00		 push	 0
  00494	ff 77 04	 push	 DWORD PTR [edi+4]
  00497	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0049d	6a 00		 push	 0
  0049f	6a 00		 push	 0
  004a1	6a 00		 push	 0
  004a3	6a 00		 push	 0
  004a5	6a 00		 push	 0
  004a7	6a 13		 push	 19			; 00000013H
  004a9	6a 0c		 push	 12			; 0000000cH
  004ab	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  004b0	83 c4 08	 add	 esp, 8
  004b3	50		 push	 eax
  004b4	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  004bb	50		 push	 eax
  004bc	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  004c3	50		 push	 eax
  004c4	68 eb 00 00 00	 push	 235			; 000000ebH
  004c9	ff 36		 push	 DWORD PTR [esi]
  004cb	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  004d0	83 c4 3c	 add	 esp, 60			; 0000003cH

; 547  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 548  : 					ItemGetNumberMake(12, 19),
; 549  : 					0, 0, 0, 0, 0,
; 550  : 					aRecv->iINDEX,
; 551  : 					0, 0);
; 552  : 
; 553  : 				if ( g_bRingEventItemTextLoad == FALSE )

  004d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  004da	0f 85 5f 0e 00
	00		 jne	 $LN93@EGRecv2Anv

; 554  : 				{
; 555  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(12, 19)].Name);

  004e0	68 50 88 0a 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+690256
  004e5	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  004e8	6a 40		 push	 64			; 00000040H
  004ea	50		 push	 eax
  004eb	e8 00 00 00 00	 call	 _strcpy_s
  004f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 556  : 				}
; 557  : 				break;

  004f3	e9 47 0e 00 00	 jmp	 $LN93@EGRecv2Anv
$LN29@EGRecv2Anv:

; 558  : 			case 12:
; 559  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  004f8	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  004ff	6a 00		 push	 0
  00501	6a 00		 push	 0
  00503	6a 00		 push	 0
  00505	6a 00		 push	 0
  00507	ff 77 04	 push	 DWORD PTR [edi+4]
  0050a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00510	6a 00		 push	 0
  00512	6a 00		 push	 0
  00514	6a 00		 push	 0
  00516	6a 00		 push	 0
  00518	6a 00		 push	 0
  0051a	6a 12		 push	 18			; 00000012H
  0051c	6a 0c		 push	 12			; 0000000cH
  0051e	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00523	83 c4 08	 add	 esp, 8
  00526	50		 push	 eax
  00527	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0052e	50		 push	 eax
  0052f	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00536	50		 push	 eax
  00537	68 eb 00 00 00	 push	 235			; 000000ebH
  0053c	ff 36		 push	 DWORD PTR [esi]
  0053e	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00543	83 c4 3c	 add	 esp, 60			; 0000003cH

; 560  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 561  : 					ItemGetNumberMake(12, 18),
; 562  : 					0, 0, 0, 0, 0,
; 563  : 					aRecv->iINDEX,
; 564  : 					0, 0);
; 565  : 
; 566  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00546	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  0054d	0f 85 ec 0d 00
	00		 jne	 $LN93@EGRecv2Anv

; 567  : 				{
; 568  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(12, 18)].Name);

  00553	68 e0 87 0a 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+690144
  00558	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  0055b	6a 40		 push	 64			; 00000040H
  0055d	50		 push	 eax
  0055e	e8 00 00 00 00	 call	 _strcpy_s
  00563	83 c4 0c	 add	 esp, 12			; 0000000cH

; 569  : 				}
; 570  : 				break;

  00566	e9 d4 0d 00 00	 jmp	 $LN93@EGRecv2Anv
$LN31@EGRecv2Anv:

; 571  : 			case 13:
; 572  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  0056b	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00572	6a 00		 push	 0
  00574	6a 00		 push	 0
  00576	6a 00		 push	 0
  00578	6a 00		 push	 0
  0057a	ff 77 04	 push	 DWORD PTR [edi+4]
  0057d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00583	6a 00		 push	 0
  00585	6a 00		 push	 0
  00587	6a 00		 push	 0
  00589	6a 00		 push	 0
  0058b	6a 00		 push	 0
  0058d	6a 11		 push	 17			; 00000011H
  0058f	6a 0c		 push	 12			; 0000000cH
  00591	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00596	83 c4 08	 add	 esp, 8
  00599	50		 push	 eax
  0059a	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  005a1	50		 push	 eax
  005a2	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  005a9	50		 push	 eax
  005aa	68 eb 00 00 00	 push	 235			; 000000ebH
  005af	ff 36		 push	 DWORD PTR [esi]
  005b1	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  005b6	83 c4 3c	 add	 esp, 60			; 0000003cH

; 573  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 574  : 					ItemGetNumberMake(12, 17),
; 575  : 					0, 0, 0, 0, 0,
; 576  : 					aRecv->iINDEX,
; 577  : 					0, 0);
; 578  : 
; 579  : 				if ( g_bRingEventItemTextLoad == FALSE )

  005b9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  005c0	0f 85 79 0d 00
	00		 jne	 $LN93@EGRecv2Anv

; 580  : 				{
; 581  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(12, 17)].Name);

  005c6	68 70 87 0a 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+690032
  005cb	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  005ce	6a 40		 push	 64			; 00000040H
  005d0	50		 push	 eax
  005d1	e8 00 00 00 00	 call	 _strcpy_s
  005d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 582  : 				}
; 583  : 				break;

  005d9	e9 61 0d 00 00	 jmp	 $LN93@EGRecv2Anv
$LN33@EGRecv2Anv:

; 584  : 			case 14:
; 585  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  005de	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  005e5	6a 00		 push	 0
  005e7	6a 00		 push	 0
  005e9	6a 00		 push	 0
  005eb	6a 00		 push	 0
  005ed	ff 77 04	 push	 DWORD PTR [edi+4]
  005f0	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005f6	6a 00		 push	 0
  005f8	6a 00		 push	 0
  005fa	6a 00		 push	 0
  005fc	6a 00		 push	 0
  005fe	6a 00		 push	 0
  00600	6a 10		 push	 16			; 00000010H
  00602	6a 0c		 push	 12			; 0000000cH
  00604	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00609	83 c4 08	 add	 esp, 8
  0060c	50		 push	 eax
  0060d	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00614	50		 push	 eax
  00615	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0061c	50		 push	 eax
  0061d	68 eb 00 00 00	 push	 235			; 000000ebH
  00622	ff 36		 push	 DWORD PTR [esi]
  00624	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00629	83 c4 3c	 add	 esp, 60			; 0000003cH

; 586  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 587  : 					ItemGetNumberMake(12, 16),
; 588  : 					0, 0, 0, 0, 0,
; 589  : 					aRecv->iINDEX,
; 590  : 					0, 0);
; 591  : 
; 592  : 				if ( g_bRingEventItemTextLoad == FALSE )

  0062c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00633	0f 85 06 0d 00
	00		 jne	 $LN93@EGRecv2Anv

; 593  : 				{
; 594  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(12, 16)].Name);

  00639	68 00 87 0a 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+689920
  0063e	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00641	6a 40		 push	 64			; 00000040H
  00643	50		 push	 eax
  00644	e8 00 00 00 00	 call	 _strcpy_s
  00649	83 c4 0c	 add	 esp, 12			; 0000000cH

; 595  : 				}
; 596  : 				break;

  0064c	e9 ee 0c 00 00	 jmp	 $LN93@EGRecv2Anv
$LN35@EGRecv2Anv:

; 597  : 			case 15:
; 598  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00651	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00658	6a 00		 push	 0
  0065a	6a 00		 push	 0
  0065c	6a 00		 push	 0
  0065e	6a 00		 push	 0
  00660	ff 77 04	 push	 DWORD PTR [edi+4]
  00663	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00669	6a 00		 push	 0
  0066b	6a 00		 push	 0
  0066d	6a 00		 push	 0
  0066f	6a 00		 push	 0
  00671	6a 00		 push	 0
  00673	6a 0e		 push	 14			; 0000000eH
  00675	6a 0c		 push	 12			; 0000000cH
  00677	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0067c	83 c4 08	 add	 esp, 8
  0067f	50		 push	 eax
  00680	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00687	50		 push	 eax
  00688	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0068f	50		 push	 eax
  00690	68 eb 00 00 00	 push	 235			; 000000ebH
  00695	ff 36		 push	 DWORD PTR [esi]
  00697	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  0069c	83 c4 3c	 add	 esp, 60			; 0000003cH

; 599  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 600  : 					ItemGetNumberMake(12, 14),
; 601  : 					0, 0, 0, 0, 0,
; 602  : 					aRecv->iINDEX,
; 603  : 					0, 0);
; 604  : 
; 605  : 				if ( g_bRingEventItemTextLoad == FALSE )

  0069f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  006a6	0f 85 93 0c 00
	00		 jne	 $LN93@EGRecv2Anv

; 606  : 				{
; 607  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(12, 14)].Name);

  006ac	68 20 86 0a 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+689696
  006b1	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  006b4	6a 40		 push	 64			; 00000040H
  006b6	50		 push	 eax
  006b7	e8 00 00 00 00	 call	 _strcpy_s
  006bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 608  : 				}
; 609  : 				break;

  006bf	e9 7b 0c 00 00	 jmp	 $LN93@EGRecv2Anv
$LN37@EGRecv2Anv:

; 610  : 			case 16:
; 611  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  006c4	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  006cb	6a 00		 push	 0
  006cd	6a 00		 push	 0
  006cf	6a 00		 push	 0
  006d1	6a 00		 push	 0
  006d3	ff 77 04	 push	 DWORD PTR [edi+4]
  006d6	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006dc	6a 00		 push	 0
  006de	6a 00		 push	 0
  006e0	6a 00		 push	 0
  006e2	6a 00		 push	 0
  006e4	6a 00		 push	 0
  006e6	6a 0d		 push	 13			; 0000000dH
  006e8	6a 0c		 push	 12			; 0000000cH
  006ea	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  006ef	83 c4 08	 add	 esp, 8
  006f2	50		 push	 eax
  006f3	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  006fa	50		 push	 eax
  006fb	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00702	50		 push	 eax
  00703	68 eb 00 00 00	 push	 235			; 000000ebH
  00708	ff 36		 push	 DWORD PTR [esi]
  0070a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  0070f	83 c4 3c	 add	 esp, 60			; 0000003cH

; 612  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 613  : 					ItemGetNumberMake(12, 13),
; 614  : 					0, 0, 0, 0, 0,
; 615  : 					aRecv->iINDEX,
; 616  : 					0, 0);
; 617  : 
; 618  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00712	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00719	0f 85 20 0c 00
	00		 jne	 $LN93@EGRecv2Anv

; 619  : 				{
; 620  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(12, 13)].Name);

  0071f	68 b0 85 0a 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+689584
  00724	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00727	6a 40		 push	 64			; 00000040H
  00729	50		 push	 eax
  0072a	e8 00 00 00 00	 call	 _strcpy_s
  0072f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 621  : 				}
; 622  : 				break;

  00732	e9 08 0c 00 00	 jmp	 $LN93@EGRecv2Anv
$LN39@EGRecv2Anv:

; 623  : 			case 17:
; 624  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00737	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  0073e	6a 00		 push	 0
  00740	6a 00		 push	 0
  00742	6a 00		 push	 0
  00744	6a 00		 push	 0
  00746	ff 77 04	 push	 DWORD PTR [edi+4]
  00749	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0074f	6a 00		 push	 0
  00751	6a 00		 push	 0
  00753	6a 00		 push	 0
  00755	6a 00		 push	 0
  00757	6a 00		 push	 0
  00759	6a 0c		 push	 12			; 0000000cH
  0075b	6a 0c		 push	 12			; 0000000cH
  0075d	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00762	83 c4 08	 add	 esp, 8
  00765	50		 push	 eax
  00766	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0076d	50		 push	 eax
  0076e	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00775	50		 push	 eax
  00776	68 eb 00 00 00	 push	 235			; 000000ebH
  0077b	ff 36		 push	 DWORD PTR [esi]
  0077d	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00782	83 c4 3c	 add	 esp, 60			; 0000003cH

; 625  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 626  : 					ItemGetNumberMake(12, 12),
; 627  : 					0, 0, 0, 0, 0,
; 628  : 					aRecv->iINDEX,
; 629  : 					0, 0);
; 630  : 
; 631  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00785	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  0078c	0f 85 ad 0b 00
	00		 jne	 $LN93@EGRecv2Anv

; 632  : 				{
; 633  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(12, 12)].Name);

  00792	68 40 85 0a 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+689472
  00797	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  0079a	6a 40		 push	 64			; 00000040H
  0079c	50		 push	 eax
  0079d	e8 00 00 00 00	 call	 _strcpy_s
  007a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 634  : 				}
; 635  : 				break;

  007a5	e9 95 0b 00 00	 jmp	 $LN93@EGRecv2Anv
$LN41@EGRecv2Anv:

; 636  : 			case 18:
; 637  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  007aa	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  007b1	6a 00		 push	 0
  007b3	6a 00		 push	 0
  007b5	6a 00		 push	 0
  007b7	6a 00		 push	 0
  007b9	ff 77 04	 push	 DWORD PTR [edi+4]
  007bc	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007c2	6a 00		 push	 0
  007c4	6a 00		 push	 0
  007c6	6a 00		 push	 0
  007c8	68 ff 00 00 00	 push	 255			; 000000ffH
  007cd	6a 00		 push	 0
  007cf	6a 02		 push	 2
  007d1	6a 0d		 push	 13			; 0000000dH
  007d3	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  007d8	83 c4 08	 add	 esp, 8
  007db	50		 push	 eax
  007dc	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  007e3	50		 push	 eax
  007e4	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  007eb	50		 push	 eax
  007ec	68 eb 00 00 00	 push	 235			; 000000ebH
  007f1	ff 36		 push	 DWORD PTR [esi]
  007f3	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  007f8	83 c4 3c	 add	 esp, 60			; 0000003cH

; 638  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 639  : 					ItemGetNumberMake(13, 2),
; 640  : 					0, 255, 0, 0, 0,
; 641  : 					aRecv->iINDEX,
; 642  : 					0, 0);
; 643  : 
; 644  : 				if ( g_bRingEventItemTextLoad == FALSE )

  007fb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00802	0f 85 37 0b 00
	00		 jne	 $LN93@EGRecv2Anv

; 645  : 				{
; 646  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(13, 2)].Name);

  00808	68 e0 60 0b 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+745696
  0080d	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00810	6a 40		 push	 64			; 00000040H
  00812	50		 push	 eax
  00813	e8 00 00 00 00	 call	 _strcpy_s
  00818	83 c4 0c	 add	 esp, 12			; 0000000cH

; 647  : 				}
; 648  : 				break;

  0081b	e9 1f 0b 00 00	 jmp	 $LN93@EGRecv2Anv
$LN43@EGRecv2Anv:

; 649  : 			case 19:
; 650  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00820	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00827	6a 00		 push	 0
  00829	6a 00		 push	 0
  0082b	6a 00		 push	 0
  0082d	6a 00		 push	 0
  0082f	ff 77 04	 push	 DWORD PTR [edi+4]
  00832	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00838	6a 00		 push	 0
  0083a	6a 00		 push	 0
  0083c	6a 00		 push	 0
  0083e	68 ff 00 00 00	 push	 255			; 000000ffH
  00843	6a 00		 push	 0
  00845	6a 03		 push	 3
  00847	6a 0d		 push	 13			; 0000000dH
  00849	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0084e	83 c4 08	 add	 esp, 8
  00851	50		 push	 eax
  00852	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00859	50		 push	 eax
  0085a	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00861	50		 push	 eax
  00862	68 eb 00 00 00	 push	 235			; 000000ebH
  00867	ff 36		 push	 DWORD PTR [esi]
  00869	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  0086e	83 c4 3c	 add	 esp, 60			; 0000003cH

; 651  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 652  : 					ItemGetNumberMake(13, 3),
; 653  : 					0, 255, 0, 0, 0,
; 654  : 					aRecv->iINDEX,
; 655  : 					0, 0);
; 656  : 
; 657  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00871	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00878	0f 85 c1 0a 00
	00		 jne	 $LN93@EGRecv2Anv

; 658  : 				{
; 659  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(13, 3)].Name);

  0087e	68 50 61 0b 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+745808
  00883	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00886	6a 40		 push	 64			; 00000040H
  00888	50		 push	 eax
  00889	e8 00 00 00 00	 call	 _strcpy_s
  0088e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 660  : 				}
; 661  : 				break;

  00891	e9 a9 0a 00 00	 jmp	 $LN93@EGRecv2Anv
$LN45@EGRecv2Anv:

; 662  : 			case 20:
; 663  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00896	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  0089d	6a 00		 push	 0
  0089f	6a 00		 push	 0
  008a1	6a 00		 push	 0
  008a3	6a 00		 push	 0
  008a5	ff 77 04	 push	 DWORD PTR [edi+4]
  008a8	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008ae	6a 00		 push	 0
  008b0	6a 00		 push	 0
  008b2	6a 00		 push	 0
  008b4	6a 00		 push	 0
  008b6	6a 00		 push	 0
  008b8	6a 10		 push	 16			; 00000010H
  008ba	6a 0e		 push	 14			; 0000000eH
  008bc	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  008c1	83 c4 08	 add	 esp, 8
  008c4	50		 push	 eax
  008c5	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  008cc	50		 push	 eax
  008cd	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  008d4	50		 push	 eax
  008d5	68 eb 00 00 00	 push	 235			; 000000ebH
  008da	ff 36		 push	 DWORD PTR [esi]
  008dc	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  008e1	83 c4 3c	 add	 esp, 60			; 0000003cH

; 664  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 665  : 					ItemGetNumberMake(14, 16),
; 666  : 					0, 0, 0, 0, 0,
; 667  : 					aRecv->iINDEX,
; 668  : 					0, 0);
; 669  : 
; 670  : 				if ( g_bRingEventItemTextLoad == FALSE )

  008e4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  008eb	0f 85 4e 0a 00
	00		 jne	 $LN93@EGRecv2Anv

; 671  : 				{
; 672  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 16)].Name);

  008f1	68 00 47 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804608
  008f6	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  008f9	6a 40		 push	 64			; 00000040H
  008fb	50		 push	 eax
  008fc	e8 00 00 00 00	 call	 _strcpy_s
  00901	83 c4 0c	 add	 esp, 12			; 0000000cH

; 673  : 				}
; 674  : 				break;

  00904	e9 36 0a 00 00	 jmp	 $LN93@EGRecv2Anv
$LN47@EGRecv2Anv:

; 675  : 			case 21:
; 676  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00909	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00910	6a 00		 push	 0
  00912	6a 00		 push	 0
  00914	6a 00		 push	 0
  00916	6a 00		 push	 0
  00918	ff 77 04	 push	 DWORD PTR [edi+4]
  0091b	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00921	6a 00		 push	 0
  00923	6a 00		 push	 0
  00925	6a 00		 push	 0
  00927	68 ff 00 00 00	 push	 255			; 000000ffH
  0092c	6a 00		 push	 0
  0092e	6a 00		 push	 0
  00930	6a 0d		 push	 13			; 0000000dH
  00932	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00937	83 c4 08	 add	 esp, 8
  0093a	50		 push	 eax
  0093b	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00942	50		 push	 eax
  00943	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0094a	50		 push	 eax
  0094b	68 eb 00 00 00	 push	 235			; 000000ebH
  00950	ff 36		 push	 DWORD PTR [esi]
  00952	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00957	83 c4 3c	 add	 esp, 60			; 0000003cH

; 677  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 678  : 					ItemGetNumberMake(13, 0),
; 679  : 					0, 255, 0, 0, 0,
; 680  : 					aRecv->iINDEX,
; 681  : 					0, 0);
; 682  : 
; 683  : 				if ( g_bRingEventItemTextLoad == FALSE )

  0095a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00961	0f 85 d8 09 00
	00		 jne	 $LN93@EGRecv2Anv

; 684  : 				{
; 685  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(13, 0)].Name);

  00967	68 00 60 0b 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+745472
  0096c	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  0096f	6a 40		 push	 64			; 00000040H
  00971	50		 push	 eax
  00972	e8 00 00 00 00	 call	 _strcpy_s
  00977	83 c4 0c	 add	 esp, 12			; 0000000cH

; 686  : 				}
; 687  : 				break;

  0097a	e9 c0 09 00 00	 jmp	 $LN93@EGRecv2Anv
$LN49@EGRecv2Anv:

; 688  : 			case 22:
; 689  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  0097f	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00986	6a 00		 push	 0
  00988	6a 00		 push	 0
  0098a	6a 00		 push	 0
  0098c	6a 00		 push	 0
  0098e	ff 77 04	 push	 DWORD PTR [edi+4]
  00991	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00997	6a 00		 push	 0
  00999	6a 00		 push	 0
  0099b	6a 00		 push	 0
  0099d	68 ff 00 00 00	 push	 255			; 000000ffH
  009a2	6a 00		 push	 0
  009a4	6a 01		 push	 1
  009a6	6a 0d		 push	 13			; 0000000dH
  009a8	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  009ad	83 c4 08	 add	 esp, 8
  009b0	50		 push	 eax
  009b1	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  009b8	50		 push	 eax
  009b9	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  009c0	50		 push	 eax
  009c1	68 eb 00 00 00	 push	 235			; 000000ebH
  009c6	ff 36		 push	 DWORD PTR [esi]
  009c8	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  009cd	83 c4 3c	 add	 esp, 60			; 0000003cH

; 690  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 691  : 					ItemGetNumberMake(13, 1),
; 692  : 					0, 255, 0, 0, 0,
; 693  : 					aRecv->iINDEX,
; 694  : 					0, 0);
; 695  : 
; 696  : 				if ( g_bRingEventItemTextLoad == FALSE )

  009d0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  009d7	0f 85 62 09 00
	00		 jne	 $LN93@EGRecv2Anv

; 697  : 				{
; 698  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(13, 1)].Name);

  009dd	68 70 60 0b 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+745584
  009e2	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  009e5	6a 40		 push	 64			; 00000040H
  009e7	50		 push	 eax
  009e8	e8 00 00 00 00	 call	 _strcpy_s
  009ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 699  : 				}
; 700  : 				break;

  009f0	e9 4a 09 00 00	 jmp	 $LN93@EGRecv2Anv
$LN51@EGRecv2Anv:

; 701  : 			case 23:
; 702  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  009f5	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  009fc	6a 00		 push	 0
  009fe	6a 00		 push	 0
  00a00	6a 00		 push	 0
  00a02	6a 00		 push	 0
  00a04	ff 77 04	 push	 DWORD PTR [edi+4]
  00a07	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a0d	6a 00		 push	 0
  00a0f	6a 00		 push	 0
  00a11	6a 00		 push	 0
  00a13	6a 00		 push	 0
  00a15	6a 01		 push	 1
  00a17	6a 0b		 push	 11			; 0000000bH
  00a19	6a 0e		 push	 14			; 0000000eH
  00a1b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00a20	83 c4 08	 add	 esp, 8
  00a23	50		 push	 eax
  00a24	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00a2b	50		 push	 eax
  00a2c	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00a33	50		 push	 eax
  00a34	68 eb 00 00 00	 push	 235			; 000000ebH
  00a39	ff 36		 push	 DWORD PTR [esi]
  00a3b	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00a40	83 c4 3c	 add	 esp, 60			; 0000003cH

; 703  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 704  : 					ItemGetNumberMake(14, 11),
; 705  : 					1, 0, 0, 0, 0,
; 706  : 					aRecv->iINDEX,
; 707  : 					0, 0);
; 708  : 
; 709  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00a43	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00a4a	0f 85 ef 08 00
	00		 jne	 $LN93@EGRecv2Anv

; 710  : 				{
; 711  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 11)].Name);

  00a50	68 d0 44 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804048
  00a55	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00a58	6a 40		 push	 64			; 00000040H
  00a5a	50		 push	 eax
  00a5b	e8 00 00 00 00	 call	 _strcpy_s
  00a60	83 c4 0c	 add	 esp, 12			; 0000000cH

; 712  : 				}
; 713  : 				break;

  00a63	e9 d7 08 00 00	 jmp	 $LN93@EGRecv2Anv
$LN53@EGRecv2Anv:

; 714  : 			case 24:
; 715  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00a68	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00a6f	6a 00		 push	 0
  00a71	6a 00		 push	 0
  00a73	6a 00		 push	 0
  00a75	6a 00		 push	 0
  00a77	ff 77 04	 push	 DWORD PTR [edi+4]
  00a7a	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a80	6a 00		 push	 0
  00a82	6a 00		 push	 0
  00a84	6a 00		 push	 0
  00a86	6a 00		 push	 0
  00a88	6a 09		 push	 9
  00a8a	6a 0b		 push	 11			; 0000000bH
  00a8c	6a 0e		 push	 14			; 0000000eH
  00a8e	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00a93	83 c4 08	 add	 esp, 8
  00a96	50		 push	 eax
  00a97	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00a9e	50		 push	 eax
  00a9f	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00aa6	50		 push	 eax
  00aa7	68 eb 00 00 00	 push	 235			; 000000ebH
  00aac	ff 36		 push	 DWORD PTR [esi]
  00aae	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00ab3	83 c4 3c	 add	 esp, 60			; 0000003cH

; 716  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 717  : 					ItemGetNumberMake(14, 11),
; 718  : 					9, 0, 0, 0, 0,
; 719  : 					aRecv->iINDEX,
; 720  : 					0, 0);
; 721  : 
; 722  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00ab6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00abd	0f 85 7c 08 00
	00		 jne	 $LN93@EGRecv2Anv

; 723  : 				{
; 724  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 11)].Name);

  00ac3	68 d0 44 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804048
  00ac8	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00acb	6a 40		 push	 64			; 00000040H
  00acd	50		 push	 eax
  00ace	e8 00 00 00 00	 call	 _strcpy_s
  00ad3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 725  : 				}
; 726  : 				break;

  00ad6	e9 64 08 00 00	 jmp	 $LN93@EGRecv2Anv
$LN55@EGRecv2Anv:

; 727  : 			case 25:
; 728  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00adb	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00ae2	6a 00		 push	 0
  00ae4	6a 00		 push	 0
  00ae6	6a 00		 push	 0
  00ae8	6a 00		 push	 0
  00aea	ff 77 04	 push	 DWORD PTR [edi+4]
  00aed	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00af3	6a 00		 push	 0
  00af5	6a 00		 push	 0
  00af7	6a 00		 push	 0
  00af9	6a 00		 push	 0
  00afb	6a 0a		 push	 10			; 0000000aH
  00afd	6a 0b		 push	 11			; 0000000bH
  00aff	6a 0e		 push	 14			; 0000000eH
  00b01	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00b06	83 c4 08	 add	 esp, 8
  00b09	50		 push	 eax
  00b0a	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00b11	50		 push	 eax
  00b12	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00b19	50		 push	 eax
  00b1a	68 eb 00 00 00	 push	 235			; 000000ebH
  00b1f	ff 36		 push	 DWORD PTR [esi]
  00b21	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00b26	83 c4 3c	 add	 esp, 60			; 0000003cH

; 729  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 730  : 					ItemGetNumberMake(14, 11),
; 731  : 					10, 0, 0, 0, 0,
; 732  : 					aRecv->iINDEX,
; 733  : 					0, 0);
; 734  : 
; 735  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00b29	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00b30	0f 85 09 08 00
	00		 jne	 $LN93@EGRecv2Anv

; 736  : 				{
; 737  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 11)].Name);

  00b36	68 d0 44 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804048
  00b3b	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00b3e	6a 40		 push	 64			; 00000040H
  00b40	50		 push	 eax
  00b41	e8 00 00 00 00	 call	 _strcpy_s
  00b46	83 c4 0c	 add	 esp, 12			; 0000000cH

; 738  : 				}
; 739  : 				break;

  00b49	e9 f1 07 00 00	 jmp	 $LN93@EGRecv2Anv
$LN57@EGRecv2Anv:

; 740  : 			case 26:
; 741  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00b4e	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00b55	6a 00		 push	 0
  00b57	6a 00		 push	 0
  00b59	6a 00		 push	 0
  00b5b	6a 00		 push	 0
  00b5d	ff 77 04	 push	 DWORD PTR [edi+4]
  00b60	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b66	6a 00		 push	 0
  00b68	6a 00		 push	 0
  00b6a	6a 00		 push	 0
  00b6c	6a 00		 push	 0
  00b6e	6a 00		 push	 0
  00b70	6a 13		 push	 19			; 00000013H
  00b72	6a 0e		 push	 14			; 0000000eH
  00b74	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00b79	83 c4 08	 add	 esp, 8
  00b7c	50		 push	 eax
  00b7d	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00b84	50		 push	 eax
  00b85	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00b8c	50		 push	 eax
  00b8d	68 eb 00 00 00	 push	 235			; 000000ebH
  00b92	ff 36		 push	 DWORD PTR [esi]
  00b94	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00b99	83 c4 3c	 add	 esp, 60			; 0000003cH

; 742  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 743  : 					ItemGetNumberMake(14, 19),
; 744  : 					0, 0, 0, 0, 0,
; 745  : 					aRecv->iINDEX,
; 746  : 					0, 0);
; 747  : 
; 748  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00b9c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00ba3	0f 85 96 07 00
	00		 jne	 $LN93@EGRecv2Anv

; 749  : 				{
; 750  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 19)].Name);

  00ba9	68 50 48 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804944
  00bae	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00bb1	6a 40		 push	 64			; 00000040H
  00bb3	50		 push	 eax
  00bb4	e8 00 00 00 00	 call	 _strcpy_s
  00bb9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 751  : 				}
; 752  : 				break;

  00bbc	e9 7e 07 00 00	 jmp	 $LN93@EGRecv2Anv
$LN59@EGRecv2Anv:

; 753  : 			case 27:
; 754  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00bc1	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00bc8	6a 00		 push	 0
  00bca	6a 00		 push	 0
  00bcc	6a 00		 push	 0
  00bce	6a 00		 push	 0
  00bd0	ff 77 04	 push	 DWORD PTR [edi+4]
  00bd3	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bd9	6a 00		 push	 0
  00bdb	6a 00		 push	 0
  00bdd	6a 00		 push	 0
  00bdf	6a 00		 push	 0
  00be1	6a 01		 push	 1
  00be3	6a 13		 push	 19			; 00000013H
  00be5	6a 0e		 push	 14			; 0000000eH
  00be7	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00bec	83 c4 08	 add	 esp, 8
  00bef	50		 push	 eax
  00bf0	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00bf7	50		 push	 eax
  00bf8	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00bff	50		 push	 eax
  00c00	68 eb 00 00 00	 push	 235			; 000000ebH
  00c05	ff 36		 push	 DWORD PTR [esi]
  00c07	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00c0c	83 c4 3c	 add	 esp, 60			; 0000003cH

; 755  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 756  : 					ItemGetNumberMake(14, 19),
; 757  : 					1, 0, 0, 0, 0,
; 758  : 					aRecv->iINDEX,
; 759  : 					0, 0);
; 760  : 
; 761  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00c0f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00c16	0f 85 23 07 00
	00		 jne	 $LN93@EGRecv2Anv

; 762  : 				{
; 763  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 19)].Name);

  00c1c	68 50 48 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804944
  00c21	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00c24	6a 40		 push	 64			; 00000040H
  00c26	50		 push	 eax
  00c27	e8 00 00 00 00	 call	 _strcpy_s
  00c2c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 764  : 				}
; 765  : 				break;

  00c2f	e9 0b 07 00 00	 jmp	 $LN93@EGRecv2Anv
$LN61@EGRecv2Anv:

; 766  : 			case 28:
; 767  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00c34	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00c3b	6a 00		 push	 0
  00c3d	6a 00		 push	 0
  00c3f	6a 00		 push	 0
  00c41	6a 00		 push	 0
  00c43	ff 77 04	 push	 DWORD PTR [edi+4]
  00c46	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c4c	6a 00		 push	 0
  00c4e	6a 00		 push	 0
  00c50	6a 00		 push	 0
  00c52	6a 00		 push	 0
  00c54	6a 02		 push	 2
  00c56	6a 13		 push	 19			; 00000013H
  00c58	6a 0e		 push	 14			; 0000000eH
  00c5a	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00c5f	83 c4 08	 add	 esp, 8
  00c62	50		 push	 eax
  00c63	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00c6a	50		 push	 eax
  00c6b	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00c72	50		 push	 eax
  00c73	68 eb 00 00 00	 push	 235			; 000000ebH
  00c78	ff 36		 push	 DWORD PTR [esi]
  00c7a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00c7f	83 c4 3c	 add	 esp, 60			; 0000003cH

; 768  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 769  : 					ItemGetNumberMake(14, 19),
; 770  : 					2, 0, 0, 0, 0,
; 771  : 					aRecv->iINDEX,
; 772  : 					0, 0);
; 773  : 
; 774  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00c82	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00c89	0f 85 b0 06 00
	00		 jne	 $LN93@EGRecv2Anv

; 775  : 				{
; 776  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 19)].Name);

  00c8f	68 50 48 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804944
  00c94	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00c97	6a 40		 push	 64			; 00000040H
  00c99	50		 push	 eax
  00c9a	e8 00 00 00 00	 call	 _strcpy_s
  00c9f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 777  : 				}
; 778  : 				break;

  00ca2	e9 98 06 00 00	 jmp	 $LN93@EGRecv2Anv
$LN63@EGRecv2Anv:

; 779  : 			case 29:
; 780  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00ca7	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00cae	6a 00		 push	 0
  00cb0	6a 00		 push	 0
  00cb2	6a 00		 push	 0
  00cb4	6a 00		 push	 0
  00cb6	ff 77 04	 push	 DWORD PTR [edi+4]
  00cb9	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cbf	6a 00		 push	 0
  00cc1	6a 00		 push	 0
  00cc3	6a 00		 push	 0
  00cc5	6a 00		 push	 0
  00cc7	6a 03		 push	 3
  00cc9	6a 13		 push	 19			; 00000013H
  00ccb	6a 0e		 push	 14			; 0000000eH
  00ccd	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00cd2	83 c4 08	 add	 esp, 8
  00cd5	50		 push	 eax
  00cd6	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00cdd	50		 push	 eax
  00cde	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00ce5	50		 push	 eax
  00ce6	68 eb 00 00 00	 push	 235			; 000000ebH
  00ceb	ff 36		 push	 DWORD PTR [esi]
  00ced	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00cf2	83 c4 3c	 add	 esp, 60			; 0000003cH

; 781  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 782  : 					ItemGetNumberMake(14, 19),
; 783  : 					3, 0, 0, 0, 0,
; 784  : 					aRecv->iINDEX,
; 785  : 					0, 0);
; 786  : 
; 787  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00cf5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00cfc	0f 85 3d 06 00
	00		 jne	 $LN93@EGRecv2Anv

; 788  : 				{
; 789  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 19)].Name);

  00d02	68 50 48 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804944
  00d07	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00d0a	6a 40		 push	 64			; 00000040H
  00d0c	50		 push	 eax
  00d0d	e8 00 00 00 00	 call	 _strcpy_s
  00d12	83 c4 0c	 add	 esp, 12			; 0000000cH

; 790  : 				}
; 791  : 				break;

  00d15	e9 25 06 00 00	 jmp	 $LN93@EGRecv2Anv
$LN65@EGRecv2Anv:

; 792  : 			case 30:
; 793  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00d1a	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00d21	6a 00		 push	 0
  00d23	6a 00		 push	 0
  00d25	6a 00		 push	 0
  00d27	6a 00		 push	 0
  00d29	ff 77 04	 push	 DWORD PTR [edi+4]
  00d2c	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d32	6a 00		 push	 0
  00d34	6a 00		 push	 0
  00d36	6a 00		 push	 0
  00d38	6a 00		 push	 0
  00d3a	6a 04		 push	 4
  00d3c	6a 13		 push	 19			; 00000013H
  00d3e	6a 0e		 push	 14			; 0000000eH
  00d40	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00d45	83 c4 08	 add	 esp, 8
  00d48	50		 push	 eax
  00d49	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00d50	50		 push	 eax
  00d51	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00d58	50		 push	 eax
  00d59	68 eb 00 00 00	 push	 235			; 000000ebH
  00d5e	ff 36		 push	 DWORD PTR [esi]
  00d60	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00d65	83 c4 3c	 add	 esp, 60			; 0000003cH

; 794  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 795  : 					ItemGetNumberMake(14, 19),
; 796  : 					4, 0, 0, 0, 0,
; 797  : 					aRecv->iINDEX,
; 798  : 					0, 0);
; 799  : 
; 800  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00d68	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00d6f	0f 85 ca 05 00
	00		 jne	 $LN93@EGRecv2Anv

; 801  : 				{
; 802  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 19)].Name);

  00d75	68 50 48 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804944
  00d7a	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00d7d	6a 40		 push	 64			; 00000040H
  00d7f	50		 push	 eax
  00d80	e8 00 00 00 00	 call	 _strcpy_s
  00d85	83 c4 0c	 add	 esp, 12			; 0000000cH

; 803  : 				}
; 804  : 				break;

  00d88	e9 b2 05 00 00	 jmp	 $LN93@EGRecv2Anv
$LN67@EGRecv2Anv:

; 805  : 			case 31:
; 806  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00d8d	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00d94	6a 00		 push	 0
  00d96	6a 00		 push	 0
  00d98	6a 00		 push	 0
  00d9a	6a 00		 push	 0
  00d9c	ff 77 04	 push	 DWORD PTR [edi+4]
  00d9f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00da5	6a 00		 push	 0
  00da7	6a 00		 push	 0
  00da9	6a 00		 push	 0
  00dab	6a 00		 push	 0
  00dad	6a 02		 push	 2
  00daf	6a 0b		 push	 11			; 0000000bH
  00db1	6a 0e		 push	 14			; 0000000eH
  00db3	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00db8	83 c4 08	 add	 esp, 8
  00dbb	50		 push	 eax
  00dbc	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00dc3	50		 push	 eax
  00dc4	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00dcb	50		 push	 eax
  00dcc	68 eb 00 00 00	 push	 235			; 000000ebH
  00dd1	ff 36		 push	 DWORD PTR [esi]
  00dd3	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00dd8	83 c4 3c	 add	 esp, 60			; 0000003cH

; 807  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 808  : 					ItemGetNumberMake(14, 11),
; 809  : 					2, 0, 0, 0, 0,
; 810  : 					aRecv->iINDEX,
; 811  : 					0, 0);
; 812  : 
; 813  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00ddb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00de2	0f 85 57 05 00
	00		 jne	 $LN93@EGRecv2Anv

; 814  : 				{
; 815  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 11)].Name);

  00de8	68 d0 44 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804048
  00ded	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00df0	6a 40		 push	 64			; 00000040H
  00df2	50		 push	 eax
  00df3	e8 00 00 00 00	 call	 _strcpy_s
  00df8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 816  : 				}
; 817  : 				break;

  00dfb	e9 3f 05 00 00	 jmp	 $LN93@EGRecv2Anv
$LN69@EGRecv2Anv:

; 818  : 			case 32:
; 819  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00e00	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00e07	6a 00		 push	 0
  00e09	6a 00		 push	 0
  00e0b	6a 00		 push	 0
  00e0d	6a 00		 push	 0
  00e0f	ff 77 04	 push	 DWORD PTR [edi+4]
  00e12	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e18	6a 00		 push	 0
  00e1a	6a 00		 push	 0
  00e1c	6a 00		 push	 0
  00e1e	6a 00		 push	 0
  00e20	6a 00		 push	 0
  00e22	6a 14		 push	 20			; 00000014H
  00e24	6a 0e		 push	 14			; 0000000eH
  00e26	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00e2b	83 c4 08	 add	 esp, 8
  00e2e	50		 push	 eax
  00e2f	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00e36	50		 push	 eax
  00e37	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00e3e	50		 push	 eax
  00e3f	68 eb 00 00 00	 push	 235			; 000000ebH
  00e44	ff 36		 push	 DWORD PTR [esi]
  00e46	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00e4b	83 c4 3c	 add	 esp, 60			; 0000003cH

; 820  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 821  : 					ItemGetNumberMake(14, 20),
; 822  : 					0, 0, 0, 0, 0,
; 823  : 					aRecv->iINDEX,
; 824  : 					0, 0);
; 825  : 
; 826  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00e4e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00e55	0f 85 e4 04 00
	00		 jne	 $LN93@EGRecv2Anv

; 827  : 				{
; 828  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 20)].Name);

  00e5b	68 c0 48 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+805056
  00e60	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00e63	6a 40		 push	 64			; 00000040H
  00e65	50		 push	 eax
  00e66	e8 00 00 00 00	 call	 _strcpy_s
  00e6b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 829  : 				}
; 830  : 				break;

  00e6e	e9 cc 04 00 00	 jmp	 $LN93@EGRecv2Anv
$LN71@EGRecv2Anv:

; 831  : 			case 33:
; 832  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00e73	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00e7a	6a 00		 push	 0
  00e7c	6a 00		 push	 0
  00e7e	6a 00		 push	 0
  00e80	6a 00		 push	 0
  00e82	ff 77 04	 push	 DWORD PTR [edi+4]
  00e85	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e8b	6a 00		 push	 0
  00e8d	6a 00		 push	 0
  00e8f	6a 00		 push	 0
  00e91	6a 00		 push	 0
  00e93	6a 00		 push	 0
  00e95	6a 16		 push	 22			; 00000016H
  00e97	6a 0e		 push	 14			; 0000000eH
  00e99	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00e9e	83 c4 08	 add	 esp, 8
  00ea1	50		 push	 eax
  00ea2	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00ea9	50		 push	 eax
  00eaa	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00eb1	50		 push	 eax
  00eb2	68 eb 00 00 00	 push	 235			; 000000ebH
  00eb7	ff 36		 push	 DWORD PTR [esi]
  00eb9	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00ebe	83 c4 3c	 add	 esp, 60			; 0000003cH

; 833  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 834  : 					ItemGetNumberMake(14, 22),
; 835  : 					0, 0, 0, 0, 0,
; 836  : 					aRecv->iINDEX,
; 837  : 					0, 0);
; 838  : 
; 839  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00ec1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00ec8	0f 85 71 04 00
	00		 jne	 $LN93@EGRecv2Anv

; 840  : 				{
; 841  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 22)].Name);

  00ece	68 a0 49 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+805280
  00ed3	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00ed6	6a 40		 push	 64			; 00000040H
  00ed8	50		 push	 eax
  00ed9	e8 00 00 00 00	 call	 _strcpy_s
  00ede	83 c4 0c	 add	 esp, 12			; 0000000cH

; 842  : 				}
; 843  : 				break;

  00ee1	e9 59 04 00 00	 jmp	 $LN93@EGRecv2Anv
$LN73@EGRecv2Anv:

; 844  : 			case 34:	case 35:	case 36:	case 37:
; 845  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00ee6	8a 47 14	 mov	 al, BYTE PTR [edi+20]
  00ee9	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00ef0	2c 22		 sub	 al, 34			; 00000022H
  00ef2	6a 00		 push	 0
  00ef4	6a 00		 push	 0
  00ef6	6a 00		 push	 0
  00ef8	6a 00		 push	 0
  00efa	ff 77 04	 push	 DWORD PTR [edi+4]
  00efd	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f03	6a 00		 push	 0
  00f05	6a 00		 push	 0
  00f07	6a 00		 push	 0
  00f09	6a 00		 push	 0
  00f0b	0f b6 c0	 movzx	 eax, al
  00f0e	50		 push	 eax
  00f0f	6a 0f		 push	 15			; 0000000fH
  00f11	6a 0d		 push	 13			; 0000000dH
  00f13	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00f18	83 c4 08	 add	 esp, 8
  00f1b	50		 push	 eax
  00f1c	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00f23	50		 push	 eax
  00f24	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00f2b	50		 push	 eax
  00f2c	68 eb 00 00 00	 push	 235			; 000000ebH
  00f31	ff 36		 push	 DWORD PTR [esi]
  00f33	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00f38	83 c4 3c	 add	 esp, 60			; 0000003cH

; 846  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 847  : 					ItemGetNumberMake(13, 15),
; 848  : 					aRecv->iGiftNumber - 34, 0, 0, 0, 0,
; 849  : 					aRecv->iINDEX,
; 850  : 					0, 0);
; 851  : 
; 852  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00f3b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00f42	0f 85 f7 03 00
	00		 jne	 $LN93@EGRecv2Anv

; 853  : 				{
; 854  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(13, 15)].Name);

  00f48	68 90 66 0b 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+747152
  00f4d	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00f50	6a 40		 push	 64			; 00000040H
  00f52	50		 push	 eax
  00f53	e8 00 00 00 00	 call	 _strcpy_s
  00f58	83 c4 0c	 add	 esp, 12			; 0000000cH

; 855  : 				}
; 856  : 				break;

  00f5b	e9 df 03 00 00	 jmp	 $LN93@EGRecv2Anv
$LN75@EGRecv2Anv:

; 857  : 			case 38:	case 39:
; 858  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00f60	8a 47 14	 mov	 al, BYTE PTR [edi+20]
  00f63	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00f6a	2c 1b		 sub	 al, 27			; 0000001bH
  00f6c	6a 00		 push	 0
  00f6e	6a 00		 push	 0
  00f70	6a 00		 push	 0
  00f72	6a 00		 push	 0
  00f74	ff 77 04	 push	 DWORD PTR [edi+4]
  00f77	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f7d	6a 00		 push	 0
  00f7f	6a 00		 push	 0
  00f81	6a 00		 push	 0
  00f83	6a 00		 push	 0
  00f85	0f b6 c0	 movzx	 eax, al
  00f88	50		 push	 eax
  00f89	6a 0b		 push	 11			; 0000000bH
  00f8b	6a 0e		 push	 14			; 0000000eH
  00f8d	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00f92	83 c4 08	 add	 esp, 8
  00f95	50		 push	 eax
  00f96	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00f9d	50		 push	 eax
  00f9e	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00fa5	50		 push	 eax
  00fa6	68 eb 00 00 00	 push	 235			; 000000ebH
  00fab	ff 36		 push	 DWORD PTR [esi]
  00fad	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00fb2	83 c4 3c	 add	 esp, 60			; 0000003cH

; 859  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 860  : 					ItemGetNumberMake(14, 11),
; 861  : 					aRecv->iGiftNumber - 27, 0, 0, 0, 0,
; 862  : 					aRecv->iINDEX,
; 863  : 					0, 0);
; 864  : 
; 865  : 				if ( g_bRingEventItemTextLoad == FALSE )

  00fb5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  00fbc	0f 85 7d 03 00
	00		 jne	 $LN93@EGRecv2Anv

; 866  : 				{
; 867  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 11)].Name);

  00fc2	68 d0 44 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804048
  00fc7	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  00fca	6a 40		 push	 64			; 00000040H
  00fcc	50		 push	 eax
  00fcd	e8 00 00 00 00	 call	 _strcpy_s
  00fd2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 868  : 				}
; 869  : 				break;

  00fd5	e9 65 03 00 00	 jmp	 $LN93@EGRecv2Anv
$LN77@EGRecv2Anv:

; 870  : 			case 40:	case 41:	case 42:	case 43:	case 44:
; 871  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  00fda	8a 47 14	 mov	 al, BYTE PTR [edi+20]
  00fdd	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  00fe4	2c 27		 sub	 al, 39			; 00000027H
  00fe6	6a 00		 push	 0
  00fe8	6a 00		 push	 0
  00fea	6a 00		 push	 0
  00fec	6a 00		 push	 0
  00fee	ff 77 04	 push	 DWORD PTR [edi+4]
  00ff1	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ff7	6a 00		 push	 0
  00ff9	6a 00		 push	 0
  00ffb	6a 00		 push	 0
  00ffd	6a 00		 push	 0
  00fff	0f b6 c0	 movzx	 eax, al
  01002	50		 push	 eax
  01003	6a 14		 push	 20			; 00000014H
  01005	6a 0e		 push	 14			; 0000000eH
  01007	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0100c	83 c4 08	 add	 esp, 8
  0100f	50		 push	 eax
  01010	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  01017	50		 push	 eax
  01018	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0101f	50		 push	 eax
  01020	68 eb 00 00 00	 push	 235			; 000000ebH
  01025	ff 36		 push	 DWORD PTR [esi]
  01027	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  0102c	83 c4 3c	 add	 esp, 60			; 0000003cH

; 872  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 873  : 					ItemGetNumberMake(14, 20),
; 874  : 					aRecv->iGiftNumber - 39, 0, 0, 0, 0,
; 875  : 					aRecv->iINDEX,
; 876  : 					0, 0);
; 877  : 
; 878  : 				if ( g_bRingEventItemTextLoad == FALSE )

  0102f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01036	0f 85 03 03 00
	00		 jne	 $LN93@EGRecv2Anv

; 879  : 				{
; 880  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 20)].Name);

  0103c	68 c0 48 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+805056
  01041	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  01044	6a 40		 push	 64			; 00000040H
  01046	50		 push	 eax
  01047	e8 00 00 00 00	 call	 _strcpy_s
  0104c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 881  : 				}
; 882  : 				break;

  0104f	e9 eb 02 00 00	 jmp	 $LN93@EGRecv2Anv
$LN79@EGRecv2Anv:

; 883  : 			case 45:
; 884  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  01054	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  0105b	6a 00		 push	 0
  0105d	6a 00		 push	 0
  0105f	6a 00		 push	 0
  01061	6a 00		 push	 0
  01063	ff 77 04	 push	 DWORD PTR [edi+4]
  01066	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0106c	6a 00		 push	 0
  0106e	6a 00		 push	 0
  01070	6a 00		 push	 0
  01072	6a 00		 push	 0
  01074	6a 08		 push	 8
  01076	6a 0b		 push	 11			; 0000000bH
  01078	6a 0e		 push	 14			; 0000000eH
  0107a	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0107f	83 c4 08	 add	 esp, 8
  01082	50		 push	 eax
  01083	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0108a	50		 push	 eax
  0108b	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  01092	50		 push	 eax
  01093	68 eb 00 00 00	 push	 235			; 000000ebH
  01098	ff 36		 push	 DWORD PTR [esi]
  0109a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  0109f	83 c4 3c	 add	 esp, 60			; 0000003cH

; 885  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 886  : 					ItemGetNumberMake(14, 11),
; 887  : 					8, 0, 0, 0, 0,
; 888  : 					aRecv->iINDEX,
; 889  : 					0, 0);
; 890  : 
; 891  : 				if ( g_bRingEventItemTextLoad == FALSE )

  010a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  010a9	0f 85 90 02 00
	00		 jne	 $LN93@EGRecv2Anv

; 892  : 				{
; 893  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 11)].Name);

  010af	68 d0 44 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+804048
  010b4	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  010b7	6a 40		 push	 64			; 00000040H
  010b9	50		 push	 eax
  010ba	e8 00 00 00 00	 call	 _strcpy_s
  010bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 894  : 				}
; 895  : 				break;

  010c2	e9 78 02 00 00	 jmp	 $LN93@EGRecv2Anv
$LN81@EGRecv2Anv:

; 896  : 			case 46:
; 897  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  010c7	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  010ce	6a 00		 push	 0
  010d0	6a 00		 push	 0
  010d2	6a 00		 push	 0
  010d4	6a 00		 push	 0
  010d6	ff 77 04	 push	 DWORD PTR [edi+4]
  010d9	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010df	6a 00		 push	 0
  010e1	6a 00		 push	 0
  010e3	6a 00		 push	 0
  010e5	6a 00		 push	 0
  010e7	6a 00		 push	 0
  010e9	6a 29		 push	 41			; 00000029H
  010eb	6a 0e		 push	 14			; 0000000eH
  010ed	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  010f2	83 c4 08	 add	 esp, 8
  010f5	50		 push	 eax
  010f6	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  010fd	50		 push	 eax
  010fe	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  01105	50		 push	 eax
  01106	68 eb 00 00 00	 push	 235			; 000000ebH
  0110b	ff 36		 push	 DWORD PTR [esi]
  0110d	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  01112	83 c4 3c	 add	 esp, 60			; 0000003cH

; 898  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 899  : 					ItemGetNumberMake(14, 41),
; 900  : 					0, 0, 0, 0, 0,
; 901  : 					aRecv->iINDEX,
; 902  : 					0, 0);
; 903  : 
; 904  : 				if ( g_bRingEventItemTextLoad == FALSE )

  01115	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  0111c	0f 85 1d 02 00
	00		 jne	 $LN93@EGRecv2Anv

; 905  : 				{
; 906  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 41)].Name);

  01122	68 f0 51 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+807408
  01127	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  0112a	6a 40		 push	 64			; 00000040H
  0112c	50		 push	 eax
  0112d	e8 00 00 00 00	 call	 _strcpy_s
  01132	83 c4 0c	 add	 esp, 12			; 0000000cH

; 907  : 				}
; 908  : 				break;

  01135	e9 05 02 00 00	 jmp	 $LN93@EGRecv2Anv
$LN83@EGRecv2Anv:

; 909  : 			case 47:
; 910  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  0113a	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  01141	6a 00		 push	 0
  01143	6a 00		 push	 0
  01145	6a 00		 push	 0
  01147	6a 00		 push	 0
  01149	ff 77 04	 push	 DWORD PTR [edi+4]
  0114c	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01152	6a 00		 push	 0
  01154	6a 00		 push	 0
  01156	6a 00		 push	 0
  01158	6a 00		 push	 0
  0115a	6a 00		 push	 0
  0115c	6a 2a		 push	 42			; 0000002aH
  0115e	6a 0e		 push	 14			; 0000000eH
  01160	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01165	83 c4 08	 add	 esp, 8
  01168	50		 push	 eax
  01169	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  01170	50		 push	 eax
  01171	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  01178	50		 push	 eax
  01179	68 eb 00 00 00	 push	 235			; 000000ebH
  0117e	ff 36		 push	 DWORD PTR [esi]
  01180	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  01185	83 c4 3c	 add	 esp, 60			; 0000003cH

; 911  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 912  : 					ItemGetNumberMake(14, 42),
; 913  : 					0, 0, 0, 0, 0,
; 914  : 					aRecv->iINDEX,
; 915  : 					0, 0);
; 916  : 
; 917  : 				if ( g_bRingEventItemTextLoad == FALSE )

  01188	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  0118f	0f 85 aa 01 00
	00		 jne	 $LN93@EGRecv2Anv

; 918  : 				{
; 919  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 42)].Name);

  01195	68 60 52 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+807520
  0119a	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  0119d	6a 40		 push	 64			; 00000040H
  0119f	50		 push	 eax
  011a0	e8 00 00 00 00	 call	 _strcpy_s
  011a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 920  : 				}
; 921  : 				break;

  011a8	e9 92 01 00 00	 jmp	 $LN93@EGRecv2Anv
$LN85@EGRecv2Anv:

; 922  : 			case 48:
; 923  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  011ad	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  011b4	6a 00		 push	 0
  011b6	6a 00		 push	 0
  011b8	6a 00		 push	 0
  011ba	6a 00		 push	 0
  011bc	ff 77 04	 push	 DWORD PTR [edi+4]
  011bf	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  011c5	6a 00		 push	 0
  011c7	6a 00		 push	 0
  011c9	6a 00		 push	 0
  011cb	6a 00		 push	 0
  011cd	6a 00		 push	 0
  011cf	6a 2c		 push	 44			; 0000002cH
  011d1	6a 0e		 push	 14			; 0000000eH
  011d3	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  011d8	83 c4 08	 add	 esp, 8
  011db	50		 push	 eax
  011dc	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  011e3	50		 push	 eax
  011e4	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  011eb	50		 push	 eax
  011ec	68 eb 00 00 00	 push	 235			; 000000ebH
  011f1	ff 36		 push	 DWORD PTR [esi]
  011f3	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  011f8	83 c4 3c	 add	 esp, 60			; 0000003cH

; 924  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 925  : 					ItemGetNumberMake(14, 44),
; 926  : 					0, 0, 0, 0, 0,
; 927  : 					aRecv->iINDEX,
; 928  : 					0, 0);
; 929  : 
; 930  : 				if ( g_bRingEventItemTextLoad == FALSE )

  011fb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01202	0f 85 37 01 00
	00		 jne	 $LN93@EGRecv2Anv

; 931  : 				{
; 932  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 44)].Name);

  01208	68 40 53 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+807744
  0120d	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  01210	6a 40		 push	 64			; 00000040H
  01212	50		 push	 eax
  01213	e8 00 00 00 00	 call	 _strcpy_s
  01218	83 c4 0c	 add	 esp, 12			; 0000000cH

; 933  : 				}
; 934  : 				break;

  0121b	e9 1f 01 00 00	 jmp	 $LN93@EGRecv2Anv
$LN87@EGRecv2Anv:

; 935  : 			case 49:
; 936  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  01220	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  01227	6a 00		 push	 0
  01229	6a 00		 push	 0
  0122b	6a 00		 push	 0
  0122d	6a 00		 push	 0
  0122f	ff 77 04	 push	 DWORD PTR [edi+4]
  01232	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01238	6a 00		 push	 0
  0123a	6a 00		 push	 0
  0123c	6a 00		 push	 0
  0123e	6a 00		 push	 0
  01240	6a 00		 push	 0
  01242	6a 2b		 push	 43			; 0000002bH
  01244	6a 0e		 push	 14			; 0000000eH
  01246	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0124b	83 c4 08	 add	 esp, 8
  0124e	50		 push	 eax
  0124f	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  01256	50		 push	 eax
  01257	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0125e	50		 push	 eax
  0125f	68 eb 00 00 00	 push	 235			; 000000ebH
  01264	ff 36		 push	 DWORD PTR [esi]
  01266	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  0126b	83 c4 3c	 add	 esp, 60			; 0000003cH

; 937  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 938  : 					ItemGetNumberMake(14, 43),
; 939  : 					0, 0, 0, 0, 0,
; 940  : 					aRecv->iINDEX,
; 941  : 					0, 0);
; 942  : 
; 943  : 				if ( g_bRingEventItemTextLoad == FALSE )

  0126e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  01275	0f 85 c4 00 00
	00		 jne	 $LN93@EGRecv2Anv

; 944  : 				{
; 945  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 43)].Name);

  0127b	68 d0 52 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+807632
  01280	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  01283	6a 40		 push	 64			; 00000040H
  01285	50		 push	 eax
  01286	e8 00 00 00 00	 call	 _strcpy_s
  0128b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 946  : 				}
; 947  : 				break;

  0128e	e9 ac 00 00 00	 jmp	 $LN93@EGRecv2Anv
$LN89@EGRecv2Anv:

; 948  : 			case 50:
; 949  : 				ItemSerialCreateSend(gObj[aRecv->iINDEX].m_Index, GIFT_2ANV_MAP, 

  01293	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  0129a	6a 00		 push	 0
  0129c	6a 00		 push	 0
  0129e	6a 00		 push	 0
  012a0	6a 00		 push	 0
  012a2	ff 77 04	 push	 DWORD PTR [edi+4]
  012a5	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  012ab	6a 00		 push	 0
  012ad	6a 00		 push	 0
  012af	6a 00		 push	 0
  012b1	6a 00		 push	 0
  012b3	6a 00		 push	 0
  012b5	6a 1f		 push	 31			; 0000001fH
  012b7	6a 0e		 push	 14			; 0000000eH
  012b9	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  012be	83 c4 08	 add	 esp, 8
  012c1	50		 push	 eax
  012c2	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  012c9	50		 push	 eax
  012ca	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  012d1	50		 push	 eax
  012d2	68 eb 00 00 00	 push	 235			; 000000ebH
  012d7	ff 36		 push	 DWORD PTR [esi]
  012d9	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  012de	83 c4 3c	 add	 esp, 60			; 0000003cH

; 950  : 					gObj[aRecv->iINDEX].X, gObj[aRecv->iINDEX].Y,
; 951  : 					ItemGetNumberMake(14, 31),
; 952  : 					0, 0, 0, 0, 0,
; 953  : 					aRecv->iINDEX,
; 954  : 					0, 0);
; 955  : 
; 956  : 				if ( g_bRingEventItemTextLoad == FALSE )

  012e1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bRingEventItemTextLoad@@3HA, 0 ; g_bRingEventItemTextLoad
  012e8	75 55		 jne	 SHORT $LN93@EGRecv2Anv

; 957  : 				{
; 958  : 					strcpy_s(Result.szGIFT_NAME, sizeof(Result.szGIFT_NAME), ItemAttribute[ITEMGET(14, 31)].Name);

  012ea	68 90 4d 0c 00	 push	 OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A+806288
  012ef	8d 45 bc	 lea	 eax, DWORD PTR _Result$[ebp+4]
  012f2	6a 40		 push	 64			; 00000040H
  012f4	50		 push	 eax
  012f5	e8 00 00 00 00	 call	 _strcpy_s
  012fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 959  : 				}
; 960  : 				break;

  012fd	eb 40		 jmp	 SHORT $LN93@EGRecv2Anv
$LN91@EGRecv2Anv:

; 961  : 			default:
; 962  : 				LogAddTD("[Mu_2Anv_Event] Error : iGiftNumber is Out of Boud [%d]", aRecv->iGiftNumber);

  012ff	50		 push	 eax
  01300	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@MNCKIFPI@?$FLMu_2Anv_Event?$FN?5Error?5?3?5iGiftNum@
  01305	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0130b	83 c4 08	 add	 esp, 8

; 963  : 				break;
; 964  : 		}
; 965  : 	}
; 966  : 	else if ( aRecv->btIsRegistered == 1 ||

  0130e	eb 2f		 jmp	 SHORT $LN93@EGRecv2Anv
$LN6@EGRecv2Anv:

; 967  : 			  aRecv->btIsRegistered == 2 ||
; 968  : 			  aRecv->btIsRegistered == 3 ||
; 969  : 			  aRecv->btIsRegistered == 4 ||

  01310	3c 01		 cmp	 al, 1
  01312	74 28		 je	 SHORT $LN94@EGRecv2Anv
  01314	3c 02		 cmp	 al, 2
  01316	74 24		 je	 SHORT $LN94@EGRecv2Anv
  01318	3c 03		 cmp	 al, 3
  0131a	74 20		 je	 SHORT $LN94@EGRecv2Anv
  0131c	3c 04		 cmp	 al, 4
  0131e	74 1c		 je	 SHORT $LN94@EGRecv2Anv
  01320	3c 05		 cmp	 al, 5
  01322	74 18		 je	 SHORT $LN94@EGRecv2Anv

; 973  : 	}
; 974  : 	else
; 975  : 	{
; 976  : 		Result.btIsRegistered = 4;
; 977  : 		LogAddTD("[Mu_2Anv_Event] Error : Result Value is Wrong [%d]", aRecv->btIsRegistered);

  01324	0f b6 c0	 movzx	 eax, al
  01327	50		 push	 eax
  01328	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@BPJEDJME@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Result?5V@
  0132d	c6 45 bb 04	 mov	 BYTE PTR _Result$[ebp+3], 4
  01331	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01337	83 c4 08	 add	 esp, 8
  0133a	eb 03		 jmp	 SHORT $LN93@EGRecv2Anv
$LN94@EGRecv2Anv:

; 970  : 			  aRecv->btIsRegistered == 5 )
; 971  : 	{
; 972  : 		Result.btIsRegistered = aRecv->btIsRegistered;

  0133c	88 45 bb	 mov	 BYTE PTR _Result$[ebp+3], al
$LN93@EGRecv2Anv:

; 978  : 	}
; 979  : 
; 980  : 	LogAddTD("[Mu_2Anv_Event] Register Serial Result : %d [%s][%s]",

  0133f	69 4f 04 40 27
	00 00		 imul	 ecx, DWORD PTR [edi+4], 10048
  01346	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0134c	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0134f	50		 push	 eax
  01350	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  01353	50		 push	 eax
  01354	0f b6 47 13	 movzx	 eax, BYTE PTR [edi+19]
  01358	50		 push	 eax
  01359	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GNHADNCC@?$FLMu_2Anv_Event?$FN?5Register?5Serial?5@
  0135e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 981  : 		aRecv->btIsRegistered, gObj[aRecv->iINDEX].AccountID, gObj[aRecv->iINDEX].Name);
; 982  : 
; 983  : 	DataSend(aRecv->iINDEX, (LPBYTE)&Result, Result.h.size);

  01364	0f b6 45 b9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  01368	50		 push	 eax
  01369	8d 45 b8	 lea	 eax, DWORD PTR _Result$[ebp]
  0136c	50		 push	 eax
  0136d	ff 77 04	 push	 DWORD PTR [edi+4]
  01370	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 984  : 
; 985  : 	gObj[aRecv->iINDEX].UseEventServer = FALSE;

  01375	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0137a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0137d	69 4f 04 40 27
	00 00		 imul	 ecx, DWORD PTR [edi+4], 10048
  01384	5e		 pop	 esi
  01385	5f		 pop	 edi
  01386	c7 84 01 e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+5096], 0

; 986  : }

  01391	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01394	33 cd		 xor	 ecx, ebp
  01396	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0139b	8b e5		 mov	 esp, ebp
  0139d	5d		 pop	 ebp
  0139e	c3		 ret	 0
$LN100@EGRecv2Anv:

; 410  : 	{
; 411  : 		LogAddTD("[Mu_2Anv_Event] Error : Index is out of bound [%d]", aRecv->iINDEX);

  0139f	52		 push	 edx
  013a0	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@NFIPOICF@?$FLMu_2Anv_Event?$FN?5Error?5?3?5Index?5is@
  013a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 986  : }

  013ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  013ae	83 c4 08	 add	 esp, 8
  013b1	33 cd		 xor	 ecx, ebp
  013b3	5f		 pop	 edi
  013b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  013b9	8b e5		 mov	 esp, ebp
  013bb	5d		 pop	 ebp
  013bc	c3		 ret	 0
  013bd	0f 1f 00	 npad	 3
$LN104@EGRecv2Anv:
  013c0	00 00 00 00	 DD	 $LN11@EGRecv2Anv
  013c4	00 00 00 00	 DD	 $LN13@EGRecv2Anv
  013c8	00 00 00 00	 DD	 $LN15@EGRecv2Anv
  013cc	00 00 00 00	 DD	 $LN17@EGRecv2Anv
  013d0	00 00 00 00	 DD	 $LN19@EGRecv2Anv
  013d4	00 00 00 00	 DD	 $LN21@EGRecv2Anv
  013d8	00 00 00 00	 DD	 $LN23@EGRecv2Anv
  013dc	00 00 00 00	 DD	 $LN25@EGRecv2Anv
  013e0	00 00 00 00	 DD	 $LN25@EGRecv2Anv
  013e4	00 00 00 00	 DD	 $LN25@EGRecv2Anv
  013e8	00 00 00 00	 DD	 $LN27@EGRecv2Anv
  013ec	00 00 00 00	 DD	 $LN29@EGRecv2Anv
  013f0	00 00 00 00	 DD	 $LN31@EGRecv2Anv
  013f4	00 00 00 00	 DD	 $LN33@EGRecv2Anv
  013f8	00 00 00 00	 DD	 $LN35@EGRecv2Anv
  013fc	00 00 00 00	 DD	 $LN37@EGRecv2Anv
  01400	00 00 00 00	 DD	 $LN39@EGRecv2Anv
  01404	00 00 00 00	 DD	 $LN41@EGRecv2Anv
  01408	00 00 00 00	 DD	 $LN43@EGRecv2Anv
  0140c	00 00 00 00	 DD	 $LN45@EGRecv2Anv
  01410	00 00 00 00	 DD	 $LN47@EGRecv2Anv
  01414	00 00 00 00	 DD	 $LN49@EGRecv2Anv
  01418	00 00 00 00	 DD	 $LN51@EGRecv2Anv
  0141c	00 00 00 00	 DD	 $LN53@EGRecv2Anv
  01420	00 00 00 00	 DD	 $LN55@EGRecv2Anv
  01424	00 00 00 00	 DD	 $LN57@EGRecv2Anv
  01428	00 00 00 00	 DD	 $LN59@EGRecv2Anv
  0142c	00 00 00 00	 DD	 $LN61@EGRecv2Anv
  01430	00 00 00 00	 DD	 $LN63@EGRecv2Anv
  01434	00 00 00 00	 DD	 $LN65@EGRecv2Anv
  01438	00 00 00 00	 DD	 $LN67@EGRecv2Anv
  0143c	00 00 00 00	 DD	 $LN69@EGRecv2Anv
  01440	00 00 00 00	 DD	 $LN71@EGRecv2Anv
  01444	00 00 00 00	 DD	 $LN73@EGRecv2Anv
  01448	00 00 00 00	 DD	 $LN73@EGRecv2Anv
  0144c	00 00 00 00	 DD	 $LN73@EGRecv2Anv
  01450	00 00 00 00	 DD	 $LN73@EGRecv2Anv
  01454	00 00 00 00	 DD	 $LN75@EGRecv2Anv
  01458	00 00 00 00	 DD	 $LN75@EGRecv2Anv
  0145c	00 00 00 00	 DD	 $LN77@EGRecv2Anv
  01460	00 00 00 00	 DD	 $LN77@EGRecv2Anv
  01464	00 00 00 00	 DD	 $LN77@EGRecv2Anv
  01468	00 00 00 00	 DD	 $LN77@EGRecv2Anv
  0146c	00 00 00 00	 DD	 $LN77@EGRecv2Anv
  01470	00 00 00 00	 DD	 $LN79@EGRecv2Anv
  01474	00 00 00 00	 DD	 $LN81@EGRecv2Anv
  01478	00 00 00 00	 DD	 $LN83@EGRecv2Anv
  0147c	00 00 00 00	 DD	 $LN85@EGRecv2Anv
  01480	00 00 00 00	 DD	 $LN87@EGRecv2Anv
  01484	00 00 00 00	 DD	 $LN89@EGRecv2Anv
?EGRecv2AnvRegSerial@@YAXPAUPMSG_ANS_2ANIV_SERIAL@@@Z ENDP ; EGRecv2AnvRegSerial
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGRecvChangeStones@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z
_TEXT	SEGMENT
_Result$ = -8						; size = 6
_aRecv$ = 8						; size = 4
?EGRecvChangeStones@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z PROC ; EGRecvChangeStones, COMDAT

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 354  : 	PMSG_REGEVENTCHIP_RESULT Result;
; 355  : 	LPOBJ lpObj;
; 356  : 	int aIndex;
; 357  : 	
; 358  : 
; 359  : 	PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00006	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	6a 06		 push	 6
  0000d	68 95 00 00 00	 push	 149			; 00000095H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 360  : 	lpObj = &gObj[aRecv->iINDEX];

  00018	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00021	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00027	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 361  : 	aIndex = aRecv->iINDEX;
; 362  : 
; 363  : 	if ( aRecv->bSUCCESS != FALSE )

  0002d	80 78 13 00	 cmp	 BYTE PTR [eax+19], 0
  00031	74 3f		 je	 SHORT $LN2@EGRecvChan

; 364  : 	{
; 365  : 		lpObj->Money += lpObj->iStoneCount * 3000;

  00033	69 86 f0 13 00
	00 b8 0b 00 00	 imul	 eax, DWORD PTR [esi+5104], 3000
  0003d	01 86 cc 00 00
	00		 add	 DWORD PTR [esi+204], eax

; 366  : 		GCMoneySend(aIndex, lpObj->Money);

  00043	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  00049	57		 push	 edi
  0004a	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 367  : 
; 368  : 		LogAddTD("[Stones] [%s][%s] ChangeRena AddMoney(%d)",

  0004f	69 86 f0 13 00
	00 b8 0b 00 00	 imul	 eax, DWORD PTR [esi+5104], 3000
  00059	50		 push	 eax
  0005a	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0005d	50		 push	 eax
  0005e	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00061	50		 push	 eax
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KDDNBJOH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Add@
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0006d	83 c4 18	 add	 esp, 24			; 00000018H

; 369  : 			lpObj->AccountID, lpObj->Name, lpObj->iStoneCount*3000);
; 370  : 	}
; 371  : 	else

  00070	eb 16		 jmp	 SHORT $LN3@EGRecvChan
$LN2@EGRecvChan:

; 372  : 	{
; 373  : 		LogAddTD("[Stones] [%s][%s] ChangeRena Fail",

  00072	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00075	50		 push	 eax
  00076	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FLCEMGDH@?$FLStones?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5Fai@
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@EGRecvChan:

; 374  : 			lpObj->AccountID, lpObj->Name);
; 375  : 	}
; 376  : 
; 377  : 	Result.ChipCount = 0;

  00088	33 c0		 xor	 eax, eax
  0008a	66 89 45 fc	 mov	 WORD PTR _Result$[ebp+4], ax

; 378  : 	lpObj->iStoneCount = 0;

  0008e	89 86 f0 13 00
	00		 mov	 DWORD PTR [esi+5104], eax

; 379  : 
; 380  : 	DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  00094	0f b6 45 f9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  00098	50		 push	 eax
  00099	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  0009c	50		 push	 eax
  0009d	57		 push	 edi
  0009e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 381  : 
; 382  : 	lpObj->UseEventServer = FALSE;

  000a6	c7 86 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5096], 0
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi

; 383  : }

  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
?EGRecvChangeStones@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ENDP ; EGRecvChangeStones
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGRecvDeleteStone@@YAXPAUPMSG_ANS_DELETE_STONES@@@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
?EGRecvDeleteStone@@YAXPAUPMSG_ANS_DELETE_STONES@@@Z PROC ; EGRecvDeleteStone, COMDAT

; 347  : 	return;
; 348  : }

  00000	c3		 ret	 0
?EGRecvDeleteStone@@YAXPAUPMSG_ANS_DELETE_STONES@@@Z ENDP ; EGRecvDeleteStone
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGRecvRegStone@@YAXPAUPMSG_ANS_REGISTER_STONES@@@Z
_TEXT	SEGMENT
_Result$ = -8						; size = 6
_aRecv$ = 8						; size = 4
?EGRecvRegStone@@YAXPAUPMSG_ANS_REGISTER_STONES@@@Z PROC ; EGRecvRegStone, COMDAT

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 312  : 	PMSG_REGEVENTCHIP_RESULT Result;
; 313  : 	LPOBJ lpObj;
; 314  : 	int aIndex;
; 315  : 	
; 316  : 
; 317  : 	PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00006	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	6a 06		 push	 6
  0000e	68 95 00 00 00	 push	 149			; 00000095H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 318  : 	lpObj = &gObj[aRecv->iINDEX];

  00019	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00022	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00028	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 319  : 	aIndex = aRecv->iINDEX;
; 320  : 
; 321  : 	if ( aRecv->bSUCCESS != FALSE )

  0002e	80 7f 14 00	 cmp	 BYTE PTR [edi+20], 0
  00032	74 38		 je	 SHORT $LN2@EGRecvRegS

; 322  : 	{
; 323  : 		Result.ChipCount = aRecv->iStoneCount;

  00034	66 8b 47 18	 mov	 ax, WORD PTR [edi+24]
  00038	66 89 45 fc	 mov	 WORD PTR _Result$[ebp+4], ax

; 324  : 		gObjInventoryDeleteItem(aIndex, aRecv->iPosition);

  0003c	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  00040	50		 push	 eax
  00041	53		 push	 ebx
  00042	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 325  : 		GCInventoryItemDeleteSend(aIndex, aRecv->iPosition, 1);

  00047	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  0004b	6a 01		 push	 1
  0004d	50		 push	 eax
  0004e	53		 push	 ebx
  0004f	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 326  : 
; 327  : 		LogAddTD("[Stone] [%s][%s] Delete Stones",

  00054	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00057	50		 push	 eax
  00058	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0005b	50		 push	 eax
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@HIMCGJFF@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Stones?$AA@
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00067	83 c4 20	 add	 esp, 32			; 00000020H

; 328  : 			lpObj->AccountID, lpObj->Name);
; 329  : 	}
; 330  : 	else

  0006a	eb 20		 jmp	 SHORT $LN3@EGRecvRegS
$LN2@EGRecvRegS:

; 331  : 	{
; 332  : 		Result.ChipCount = -1;
; 333  : 		
; 334  : 		LogAddTD("[Stone] [%s][%s] RegEventServer Fail (Stones : %d)",

  0006c	ff 77 18	 push	 DWORD PTR [edi+24]
  0006f	83 c8 ff	 or	 eax, -1
  00072	66 89 45 fc	 mov	 WORD PTR _Result$[ebp+4], ax
  00076	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00079	50		 push	 eax
  0007a	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0007d	50		 push	 eax
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@JDHGBHBI@?$FLStone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventServer?5@
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00089	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@EGRecvRegS:

; 335  : 			lpObj->AccountID, lpObj->Name, aRecv->iStoneCount);
; 336  : 	}
; 337  : 
; 338  : 	DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  0008c	0f b6 45 f9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  00090	50		 push	 eax
  00091	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  00094	50		 push	 eax
  00095	53		 push	 ebx
  00096	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 339  : 
; 340  : 	lpObj->UseEventServer = FALSE;

  0009e	c7 86 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5096], 0
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx

; 341  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?EGRecvRegStone@@YAXPAUPMSG_ANS_REGISTER_STONES@@@Z ENDP ; EGRecvRegStone
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGRecvStoneInfo@@YAXPAUPMSG_ANS_VIEW_STONES@@@Z
_TEXT	SEGMENT
_Result$ = -148						; size = 16
_msg$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?EGRecvStoneInfo@@YAXPAUPMSG_ANS_VIEW_STONES@@@Z PROC	; EGRecvStoneInfo, COMDAT

; 285  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 286  : 	LPOBJ lpObj = &gObj[aRecv->iINDEX];
; 287  : 
; 288  : 	PMSG_EVENTCHIPINFO Result;
; 289  : 	
; 290  : 	PHeadSetB((LPBYTE)&Result, 0x94, sizeof(Result));

  00018	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _Result$[ebp]
  0001e	6a 10		 push	 16			; 00000010H
  00020	68 94 00 00 00	 push	 148			; 00000094H
  00025	50		 push	 eax
  00026	69 77 04 40 27
	00 00		 imul	 esi, DWORD PTR [edi+4], 10048
  0002d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 291  : 
; 292  : 	if ( aRecv->bSUCCESS )

  0003b	80 7f 13 00	 cmp	 BYTE PTR [edi+19], 0
  0003f	74 0b		 je	 SHORT $LN2@EGRecvSton

; 293  : 		lpObj->iStoneCount = aRecv->iStoneCount;

  00041	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00044	89 86 f0 13 00
	00		 mov	 DWORD PTR [esi+5104], eax

; 294  : 	else

  0004a	eb 0a		 jmp	 SHORT $LN3@EGRecvSton
$LN2@EGRecvSton:

; 295  : 		lpObj->iStoneCount = 0;

  0004c	c7 86 f0 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5104], 0
$LN3@EGRecvSton:

; 296  : 
; 297  : 	lpObj->MutoNumber = 0;

  00056	c7 86 e4 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5092], 0

; 298  : 	Result.Type = 3;
; 299  : 	Result.ChipCount = aRecv->iStoneCount;

  00060	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00063	89 85 70 ff ff
	ff		 mov	 DWORD PTR _Result$[ebp+4], eax

; 300  : 
; 301  : 	DataSend(lpObj->m_Index, (LPBYTE)&Result, Result.h.size);

  00069	0f b6 85 6d ff
	ff ff		 movzx	 eax, BYTE PTR _Result$[ebp+1]
  00070	50		 push	 eax
  00071	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _Result$[ebp]
  00077	c6 85 6f ff ff
	ff 03		 mov	 BYTE PTR _Result$[ebp+3], 3
  0007e	50		 push	 eax
  0007f	ff 36		 push	 DWORD PTR [esi]
  00081	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  : 
; 303  : 	char msg[128];
; 304  : 	wsprintf(msg, lMsg.Get(MSGGET(4, 153)), Result.ChipCount);

  00089	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0008e	ff b5 70 ff ff
	ff		 push	 DWORD PTR _Result$[ebp+4]
  00094	68 99 04 00 00	 push	 1177			; 00000499H
  00099	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0009e	50		 push	 eax
  0009f	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  000a5	50		 push	 eax
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 305  : 	ChatTargetSend(pEventObj, msg, lpObj->m_Index);

  000ac	ff 36		 push	 DWORD PTR [esi]
  000ae	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  000b4	50		 push	 eax
  000b5	ff 35 00 00 00
	00		 push	 DWORD PTR ?pEventObj@@3PAUOBJECTSTRUCT@@A ; pEventObj
  000bb	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend

; 306  : }

  000c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	83 c4 18	 add	 esp, 24			; 00000018H
  000c6	33 cd		 xor	 ecx, ebp
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
?EGRecvStoneInfo@@YAXPAUPMSG_ANS_VIEW_STONES@@@Z ENDP	; EGRecvStoneInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGRecvChangeRena@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z
_TEXT	SEGMENT
_Result$ = -8						; size = 6
_aRecv$ = 8						; size = 4
?EGRecvChangeRena@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z PROC ; EGRecvChangeRena, COMDAT

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 250  : 	PMSG_REGEVENTCHIP_RESULT Result;
; 251  : 	LPOBJ lpObj;
; 252  : 	int aIndex;
; 253  : 
; 254  : 	PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00006	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	6a 06		 push	 6
  0000d	68 95 00 00 00	 push	 149			; 00000095H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 255  : 	lpObj = &gObj[aRecv->iINDEX];

  00018	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00021	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00027	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 256  : 	aIndex = aRecv->iINDEX;
; 257  : 
; 258  : 	if ( aRecv->bSUCCESS != FALSE )

  0002d	80 78 13 00	 cmp	 BYTE PTR [eax+19], 0
  00031	74 45		 je	 SHORT $LN2@EGRecvChan

; 259  : 	{
; 260  : 		lpObj->Money += lpObj->EventChipCount * 3000;

  00033	0f bf 86 e0 13
	00 00		 movsx	 eax, WORD PTR [esi+5088]
  0003a	69 c0 b8 0b 00
	00		 imul	 eax, eax, 3000
  00040	01 86 cc 00 00
	00		 add	 DWORD PTR [esi+204], eax

; 261  : 		GCMoneySend(aIndex, lpObj->Money);

  00046	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 262  : 
; 263  : 		LogAddTD("[EventChip] [%s][%s] ChangeRena AddMoney(%d)",

  00052	0f bf 86 e0 13
	00 00		 movsx	 eax, WORD PTR [esi+5088]
  00059	69 c0 b8 0b 00
	00		 imul	 eax, eax, 3000
  0005f	50		 push	 eax
  00060	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00063	50		 push	 eax
  00064	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HPMMCJJA@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5@
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00073	83 c4 18	 add	 esp, 24			; 00000018H

; 264  : 			lpObj->AccountID, lpObj->Name, lpObj->EventChipCount * 3000);
; 265  : 	}
; 266  : 	else

  00076	eb 16		 jmp	 SHORT $LN3@EGRecvChan
$LN2@EGRecvChan:

; 267  : 	{
; 268  : 		LogAddTD("[EventChip] [%s][%s] ChangeRena Fail",

  00078	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0007b	50		 push	 eax
  0007c	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KMDOMHEE@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ChangeRena?5@
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@EGRecvChan:

; 269  : 			lpObj->AccountID, lpObj->Name);
; 270  : 	}
; 271  : 
; 272  : 	Result.ChipCount = 0;

  0008e	33 c0		 xor	 eax, eax
  00090	66 89 45 fc	 mov	 WORD PTR _Result$[ebp+4], ax

; 273  : 	lpObj->EventChipCount = 0;

  00094	66 89 86 e0 13
	00 00		 mov	 WORD PTR [esi+5088], ax

; 274  : 
; 275  : 	DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  0009b	0f b6 45 f9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  0009f	50		 push	 eax
  000a0	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  000a3	50		 push	 eax
  000a4	57		 push	 edi
  000a5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 276  : 
; 277  : 	lpObj->UseEventServer = FALSE;

  000ad	c7 86 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5096], 0
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi

; 278  : }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?EGRecvChangeRena@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ENDP ; EGRecvChangeRena
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGRecvRegMutoNum@@YAXPAUPMSG_ANS_REGISTER_MUTONUM@@@Z
_TEXT	SEGMENT
tv74 = -20						; size = 4
_Result$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?EGRecvRegMutoNum@@YAXPAUPMSG_ANS_REGISTER_MUTONUM@@@Z PROC ; EGRecvRegMutoNum, COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]

; 208  : 	LPOBJ lpObj;
; 209  : 	int aIndex;
; 210  : 	
; 211  : 
; 212  : 	lpObj = &gObj[aRecv->iINDEX];
; 213  : 	aIndex = aRecv->iINDEX;
; 214  : 
; 215  : 	PMSG_GETMUTONUMBER_RESULT Result;
; 216  : 
; 217  : 	PHeadSetB((LPBYTE)&Result, 0x96, sizeof(Result));

  00015	8d 45 f0	 lea	 eax, DWORD PTR _Result$[ebp]
  00018	57		 push	 edi
  00019	6a 0a		 push	 10			; 0000000aH
  0001b	68 96 00 00 00	 push	 150			; 00000096H
  00020	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00023	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  00029	50		 push	 eax
  0002a	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 218  : 	
; 219  : 	if ( gObjFind10EventChip(aIndex) == FALSE )

  00035	53		 push	 ebx
  00036	e8 00 00 00 00	 call	 ?gObjFind10EventChip@@YAHH@Z ; gObjFind10EventChip
  0003b	83 c4 10	 add	 esp, 16			; 00000010H
  0003e	85 c0		 test	 eax, eax
  00040	75 20		 jne	 SHORT $LN2@EGRecvRegM

; 220  : 	{
; 221  : 		Result.MutoNum[0] = -1;

  00042	83 c8 ff	 or	 eax, -1
  00045	66 89 45 f4	 mov	 WORD PTR _Result$[ebp+4], ax

; 222  : 		Result.MutoNum[1] = 0;

  00049	33 c0		 xor	 eax, eax
  0004b	89 45 f6	 mov	 DWORD PTR _Result$[ebp+6], eax

; 223  : 		Result.MutoNum[2] = 0;
; 224  : 
; 225  : 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  0004e	0f b6 45 f1	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  00052	50		 push	 eax
  00053	8d 45 f0	 lea	 eax, DWORD PTR _Result$[ebp]
  00056	50		 push	 eax
  00057	53		 push	 ebx
  00058	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 226  : 
; 227  : 		lpObj->UseEventServer = FALSE;
; 228  : 
; 229  : 		return;

  00060	eb 75		 jmp	 SHORT $LN4@EGRecvRegM
$LN2@EGRecvRegM:

; 230  : 	}
; 231  : 
; 232  : 	gObjDelete10EventChip(aIndex);

  00062	53		 push	 ebx
  00063	e8 00 00 00 00	 call	 ?gObjDelete10EventChip@@YAHH@Z ; gObjDelete10EventChip

; 233  : 	Result.MutoNum[0] = aRecv->iMUTO_NUM / 1000000;

  00068	8b 76 14	 mov	 esi, DWORD PTR [esi+20]
  0006b	b8 83 de 1b 43	 mov	 eax, 1125899907		; 431bde83H
  00070	f7 ee		 imul	 esi

; 234  : 	Result.MutoNum[1] = aRecv->iMUTO_NUM / 1000 - aRecv->iMUTO_NUM / 1000000 * 1000;

  00072	8b c6		 mov	 eax, esi
  00074	c7 45 ec e8 03
	00 00		 mov	 DWORD PTR tv74[ebp], 1000 ; 000003e8H
  0007b	c1 fa 12	 sar	 edx, 18			; 00000012H
  0007e	8b ca		 mov	 ecx, edx
  00080	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00083	03 ca		 add	 ecx, edx
  00085	99		 cdq
  00086	f7 7d ec	 idiv	 DWORD PTR tv74[ebp]
  00089	66 89 4d f4	 mov	 WORD PTR _Result$[ebp+4], cx
  0008d	69 c9 e8 03 00
	00		 imul	 ecx, ecx, 1000

; 235  : 	Result.MutoNum[2] = aRecv->iMUTO_NUM % 1000;

  00093	66 89 55 f8	 mov	 WORD PTR _Result$[ebp+8], dx
  00097	2b c1		 sub	 eax, ecx
  00099	66 89 45 f6	 mov	 WORD PTR _Result$[ebp+6], ax

; 236  : 	lpObj->MutoNumber = aRecv->iMUTO_NUM;

  0009d	89 b7 e4 13 00
	00		 mov	 DWORD PTR [edi+5092], esi

; 237  : 	
; 238  : 	LogAddTD("[EventChip] [%s][%s] Make MutoNumber %d,%d,%d",

  000a3	0f bf 45 f8	 movsx	 eax, WORD PTR _Result$[ebp+8]
  000a7	50		 push	 eax
  000a8	0f bf 45 f6	 movsx	 eax, WORD PTR _Result$[ebp+6]
  000ac	50		 push	 eax
  000ad	0f bf 45 f4	 movsx	 eax, WORD PTR _Result$[ebp+4]
  000b1	50		 push	 eax
  000b2	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  000b5	50		 push	 eax
  000b6	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@PLMPLCLH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5MutoNu@
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 239  : 		lpObj->AccountID, lpObj->Name, 
; 240  : 		Result.MutoNum[0], Result.MutoNum[1], Result.MutoNum[2]);
; 241  : 
; 242  : 	DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000c5	0f b6 45 f1	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  000c9	50		 push	 eax
  000ca	8d 45 f0	 lea	 eax, DWORD PTR _Result$[ebp]
  000cd	50		 push	 eax
  000ce	53		 push	 ebx
  000cf	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d4	83 c4 28	 add	 esp, 40			; 00000028H
$LN4@EGRecvRegM:

; 243  : 	lpObj->UseEventServer = FALSE;
; 244  : }

  000d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000da	c7 87 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+5096], 0
  000e4	33 cd		 xor	 ecx, ebp
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
?EGRecvRegMutoNum@@YAXPAUPMSG_ANS_REGISTER_MUTONUM@@@Z ENDP ; EGRecvRegMutoNum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGResultRegEventChip@@YAXPAUPMSG_ANS_REGISTER_EVENTCHIP@@@Z
_TEXT	SEGMENT
_Result$ = -8						; size = 6
_aRecv$ = 8						; size = 4
?EGResultRegEventChip@@YAXPAUPMSG_ANS_REGISTER_EVENTCHIP@@@Z PROC ; EGResultRegEventChip, COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 171  : 	PMSG_REGEVENTCHIP_RESULT Result;
; 172  : 	LPOBJ lpObj;
; 173  : 	int aIndex;
; 174  : 
; 175  : 	PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00006	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	6a 06		 push	 6
  0000e	68 95 00 00 00	 push	 149			; 00000095H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 176  : 	lpObj = &gObj[aRecv->iINDEX];

  00019	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00022	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00028	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 177  : 	aIndex = aRecv->iINDEX;
; 178  : 
; 179  : 	if ( aRecv->bSUCCESS == FALSE )

  0002e	80 7f 14 00	 cmp	 BYTE PTR [edi+20], 0
  00032	75 24		 jne	 SHORT $LN2@EGResultRe

; 180  : 	{
; 181  : 		Result.ChipCount = -1;

  00034	83 c8 ff	 or	 eax, -1
  00037	66 89 45 fc	 mov	 WORD PTR _Result$[ebp+4], ax

; 182  : 		LogAddTD("[EventChip] [%s][%s] RegEventServer Fail (RegEventchip) %d",

  0003b	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  0003f	50		 push	 eax
  00040	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00043	50		 push	 eax
  00044	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00047	50		 push	 eax
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@NPJNKEPH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RegEventSer@
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00053	83 c4 10	 add	 esp, 16			; 00000010H

; 183  : 			lpObj->AccountID, lpObj->Name, aRecv->Pos);
; 184  : 
; 185  : 	}
; 186  : 	else

  00056	eb 3b		 jmp	 SHORT $LN3@EGResultRe
$LN2@EGResultRe:

; 187  : 	{
; 188  : 		Result.ChipCount = aRecv->nEVENT_CHIPS;

  00058	66 8b 47 16	 mov	 ax, WORD PTR [edi+22]
  0005c	66 89 45 fc	 mov	 WORD PTR _Result$[ebp+4], ax

; 189  : 		gObjInventoryDeleteItem(aIndex, aRecv->Pos);

  00060	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  00064	50		 push	 eax
  00065	53		 push	 ebx
  00066	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 190  : 		GCInventoryItemDeleteSend(aIndex, aRecv->Pos, 1);

  0006b	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  0006f	6a 01		 push	 1
  00071	50		 push	 eax
  00072	53		 push	 ebx
  00073	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 191  : 
; 192  : 		LogAddTD("[EventChip] [%s][%s] Delete EventChip (%d)",

  00078	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  0007c	50		 push	 eax
  0007d	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00080	50		 push	 eax
  00081	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00084	50		 push	 eax
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@GENGFGNN@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Even@
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00090	83 c4 24	 add	 esp, 36			; 00000024H
$LN3@EGResultRe:

; 193  : 			lpObj->AccountID, lpObj->Name, aRecv->Pos);
; 194  : 	}
; 195  : 
; 196  : 	Result.Type = 0;
; 197  : 
; 198  : 	DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  00093	0f b6 45 f9	 movzx	 eax, BYTE PTR _Result$[ebp+1]
  00097	50		 push	 eax
  00098	8d 45 f8	 lea	 eax, DWORD PTR _Result$[ebp]
  0009b	c6 45 fb 00	 mov	 BYTE PTR _Result$[ebp+3], 0
  0009f	50		 push	 eax
  000a0	53		 push	 ebx
  000a1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 199  : 
; 200  : 	lpObj->UseEventServer = FALSE;

  000a9	c7 86 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5096], 0
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx

; 201  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?EGResultRegEventChip@@YAXPAUPMSG_ANS_REGISTER_EVENTCHIP@@@Z ENDP ; EGResultRegEventChip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EGRecvEventChipInfo@@YAXPAUPMSG_ANS_VIEW_EC_MN@@@Z
_TEXT	SEGMENT
_eventchipeventinfo$ = -20				; size = 16
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?EGRecvEventChipInfo@@YAXPAUPMSG_ANS_VIEW_EC_MN@@@Z PROC ; EGRecvEventChipInfo, COMDAT

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]

; 150  : 	LPOBJ lpObj = &gObj[aRecv->iINDEX];
; 151  : 
; 152  : 	PMSG_EVENTCHIPINFO eventchipeventinfo;
; 153  : 	char msg[255];
; 154  : 
; 155  : 	PHeadSetB((LPBYTE)&eventchipeventinfo, 0x94, sizeof(eventchipeventinfo));

  00014	8d 45 ec	 lea	 eax, DWORD PTR _eventchipeventinfo$[ebp]
  00017	57		 push	 edi
  00018	6a 10		 push	 16			; 00000010H
  0001a	68 94 00 00 00	 push	 148			; 00000094H
  0001f	69 7e 04 40 27
	00 00		 imul	 edi, DWORD PTR [esi+4], 10048
  00026	50		 push	 eax
  00027	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 156  : 	eventchipeventinfo.Type = 0;
; 157  : 	eventchipeventinfo.ChipCount = aRecv->nEVENT_CHIPS;

  00032	0f b7 4e 14	 movzx	 ecx, WORD PTR [esi+20]
  00036	0f bf c1	 movsx	 eax, cx
  00039	89 45 f0	 mov	 DWORD PTR _eventchipeventinfo$[ebp+4], eax
  0003c	c6 45 ef 00	 mov	 BYTE PTR _eventchipeventinfo$[ebp+3], 0

; 158  : 	lpObj->EventChipCount = aRecv->nEVENT_CHIPS;

  00040	66 89 8f e0 13
	00 00		 mov	 WORD PTR [edi+5088], cx

; 159  : 	lpObj->MutoNumber = aRecv->iMUTO_NUM;

  00047	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0004a	89 87 e4 13 00
	00		 mov	 DWORD PTR [edi+5092], eax

; 160  : 
; 161  : 	DataSend(lpObj->m_Index, (LPBYTE)&eventchipeventinfo, eventchipeventinfo.h.size);

  00050	0f b6 45 ed	 movzx	 eax, BYTE PTR _eventchipeventinfo$[ebp+1]
  00054	50		 push	 eax
  00055	8d 45 ec	 lea	 eax, DWORD PTR _eventchipeventinfo$[ebp]
  00058	50		 push	 eax
  00059	ff 37		 push	 DWORD PTR [edi]
  0005b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 162  : 
; 163  : 	lpObj->UseEventServer = FALSE;
; 164  : }

  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	83 c4 18	 add	 esp, 24			; 00000018H
  00066	c7 87 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+5096], 0
  00070	33 cd		 xor	 ecx, ebp
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?EGRecvEventChipInfo@@YAXPAUPMSG_ANS_VIEW_EC_MN@@@Z ENDP ; EGRecvEventChipInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?DataSendEventChip@@YAXPADH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
_size$ = 12						; size = 4
?DataSendEventChip@@YAXPADH@Z PROC			; DataSendEventChip, COMDAT

; 124  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 	if ( IsEventChipServerConnected == FALSE )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsEventChipServerConnected@@3HA, 0 ; IsEventChipServerConnected
  0000a	75 4f		 jne	 SHORT $LN6@DataSendEv

; 126  : 	{
; 127  : 		wsEvenChipServerCli.Close();

  0000c	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsEvenChipServerCli@@3VwsJoinServerCli@@A+4
  00011	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 128  : 		wsEvenChipServerCli.CreateSocket(ghWnd);

  00016	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0001c	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsEvenChipServerCli@@3VwsJoinServerCli@@A+4
  00021	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 129  : 		if ( GMEventChipServerConnect(EventServerIP, WM_GM_EVENTCHIP_CLIENT_MSG_PROC) == FALSE )

  00026	68 0d 04 00 00	 push	 1037			; 0000040dH
  0002b	68 00 00 00 00	 push	 OFFSET ?EventServerIP@@3PADA ; EventServerIP
  00030	e8 00 00 00 00	 call	 ?GMEventChipServerConnect@@YAHPADK@Z ; GMEventChipServerConnect
  00035	83 c4 08	 add	 esp, 8
  00038	85 c0		 test	 eax, eax
  0003a	75 15		 jne	 SHORT $LN3@DataSendEv

; 130  : 		{
; 131  : 			IsEventChipServerConnected = FALSE;
; 132  : 			LogAddTD("Can not connect EventChip Server");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JKOKDAGE@Can?5not?5connect?5EventChip?5Server@
  00041	a3 00 00 00 00	 mov	 DWORD PTR ?IsEventChipServerConnected@@3HA, eax ; IsEventChipServerConnected
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0004c	83 c4 04	 add	 esp, 4

; 144  : 	}
; 145  : }

  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN3@DataSendEv:

; 133  : 
; 134  : 			return;
; 135  : 		}
; 136  : 
; 137  : 		::IsEventChipServerConnected = TRUE;

  00051	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsEventChipServerConnected@@3HA, 1 ; IsEventChipServerConnected
$LN6@DataSendEv:

; 138  : 
; 139  : 	}
; 140  : 
; 141  : 	if ( ::IsEventChipServerConnected != FALSE )
; 142  : 	{
; 143  : 		::wsEvenChipServerCli.DataSend((char *)pMsg, size);

  0005b	ff 75 0c	 push	 DWORD PTR _size$[ebp]
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsEvenChipServerCli@@3VwsJoinServerCli@@A ; wsEvenChipServerCli
  00063	ff 75 08	 push	 DWORD PTR _pMsg$[ebp]
  00066	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 144  : 	}
; 145  : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?DataSendEventChip@@YAXPADH@Z ENDP			; DataSendEventChip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?EventChipEventProtocolCore@@YAXEPAEH@Z
_TEXT	SEGMENT
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
?EventChipEventProtocolCore@@YAXEPAEH@Z PROC		; EventChipEventProtocolCore, COMDAT

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19   : #if (TRACE_PROTOCOL==1)
; 20   : 	LogAddHeadHex("EVENT_SERVER", aRecv, aLen);
; 21   : #endif
; 22   : 
; 23   : 	switch ( protoNum )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  00007	48		 dec	 eax
  00008	83 f8 16	 cmp	 eax, 22			; 00000016H
  0000b	0f 87 a8 00 00
	00		 ja	 $LN2@EventChipE
  00011	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN18@EventChipE[eax]
  00018	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN21@EventChipE[eax*4]
$LN4@EventChipE:

; 24   : 	{
; 25   : 		case 0x01:
; 26   : 			EGRecvEventChipInfo((PMSG_ANS_VIEW_EC_MN *)aRecv);

  0001f	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00022	e8 00 00 00 00	 call	 ?EGRecvEventChipInfo@@YAXPAUPMSG_ANS_VIEW_EC_MN@@@Z ; EGRecvEventChipInfo

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  00027	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN5@EventChipE:

; 27   : 			break;
; 28   : 		case 0x02:
; 29   : 			EGResultRegEventChip((PMSG_ANS_REGISTER_EVENTCHIP *)aRecv);

  0002c	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0002f	e8 00 00 00 00	 call	 ?EGResultRegEventChip@@YAXPAUPMSG_ANS_REGISTER_EVENTCHIP@@@Z ; EGResultRegEventChip

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  00034	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN6@EventChipE:

; 30   : 			break;
; 31   : 		case 0x03:
; 32   : 			EGRecvRegMutoNum((PMSG_ANS_REGISTER_MUTONUM *)aRecv);

  00039	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0003c	e8 00 00 00 00	 call	 ?EGRecvRegMutoNum@@YAXPAUPMSG_ANS_REGISTER_MUTONUM@@@Z ; EGRecvRegMutoNum

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  00041	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN7@EventChipE:

; 33   : 			break;
; 34   : 		case 0x04:
; 35   : 			EGRecvChangeRena((PMSG_ANS_RESET_EVENTCHIP *)aRecv);

  00046	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00049	e8 00 00 00 00	 call	 ?EGRecvChangeRena@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ; EGRecvChangeRena

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  0004e	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
$LN8@EventChipE:

; 36   : 			break;
; 37   : 		case 0x05:
; 38   : 			EGRecvStoneInfo((PMSG_ANS_VIEW_STONES *)aRecv);

  00053	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00056	e8 00 00 00 00	 call	 ?EGRecvStoneInfo@@YAXPAUPMSG_ANS_VIEW_STONES@@@Z ; EGRecvStoneInfo

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  0005b	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
$LN9@EventChipE:

; 39   : 			break;
; 40   : 		case 0x06:
; 41   : 			EGRecvRegStone((PMSG_ANS_REGISTER_STONES *)aRecv);

  00060	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00063	e8 00 00 00 00	 call	 ?EGRecvRegStone@@YAXPAUPMSG_ANS_REGISTER_STONES@@@Z ; EGRecvRegStone

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  00068	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN11@EventChipE:

; 42   : 			break;
; 43   : 		case 0x07:
; 44   : 			EGRecvDeleteStone((PMSG_ANS_DELETE_STONES *)aRecv);
; 45   : 			break;
; 46   : 		case 0x09:
; 47   : 			EGRecvChangeStones((PMSG_ANS_RESET_EVENTCHIP *)aRecv);

  0006d	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00070	e8 00 00 00 00	 call	 ?EGRecvChangeStones@@YAXPAUPMSG_ANS_RESET_EVENTCHIP@@@Z ; EGRecvChangeStones

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  00075	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
$LN12@EventChipE:

; 48   : 			break;
; 49   : 		case 0x08:
; 50   : 			EGRecv2AnvRegSerial((PMSG_ANS_2ANIV_SERIAL *)aRecv);

  0007a	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0007d	e8 00 00 00 00	 call	 ?EGRecv2AnvRegSerial@@YAXPAUPMSG_ANS_2ANIV_SERIAL@@@Z ; EGRecv2AnvRegSerial

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  00082	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
$LN13@EventChipE:

; 51   : 			break;
; 52   : 		case 0x10:
; 53   : 			EGRecvRegRingGift((PMSG_ANS_REG_RINGGIFT *)aRecv);

  00087	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0008a	e8 00 00 00 00	 call	 ?EGRecvRegRingGift@@YAXPAUPMSG_ANS_REG_RINGGIFT@@@Z ; EGRecvRegRingGift

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  0008f	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN14@EventChipE:

; 54   : 			break;
; 55   : 		case 0x15:
; 56   : 			EGAnsRegCCOfflineGift((PMSG_ANS_REG_CC_OFFLINE_GIFT *)aRecv);

  00094	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00097	e8 00 00 00 00	 call	 ?EGAnsRegCCOfflineGift@@YAXPAUPMSG_ANS_REG_CC_OFFLINE_GIFT@@@Z ; EGAnsRegCCOfflineGift

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  0009c	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
$LN15@EventChipE:

; 57   : 			break;
; 58   : 		case 0x16:
; 59   : 			EGAnsRegDLOfflineGift((PMSG_ANS_REG_DL_OFFLINE_GIFT *)aRecv);

  000a1	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  000a4	e8 00 00 00 00	 call	 ?EGAnsRegDLOfflineGift@@YAXPAUPMSG_ANS_REG_DL_OFFLINE_GIFT@@@Z ; EGAnsRegDLOfflineGift

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  000a9	83 c4 04	 add	 esp, 4

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
$LN16@EventChipE:

; 60   : 			break;
; 61   : 		case 0x17:
; 62   : 			EGAnsRegHTOfflineGift((PMSG_ANS_REG_HT_OFFLINE_GIFT *)aRecv);

  000ae	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  000b1	e8 00 00 00 00	 call	 ?EGAnsRegHTOfflineGift@@YAXPAUPMSG_ANS_REG_HT_OFFLINE_GIFT@@@Z ; EGAnsRegHTOfflineGift
  000b6	83 c4 04	 add	 esp, 4
$LN2@EventChipE:

; 63   : 			break;
; 64   : #if (__CUSTOM_QUEST__ == 1)
; 65   : 		case 0x65:
; 66   : 			{
; 67   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 68   : 
; 69   : 				switch(lpRecv->subcode)
; 70   : 				{
; 71   : 				case 0x01:
; 72   : 					g_MyQuest.AnsUserInfo(aRecv);
; 73   : 					break;
; 74   : 				}
; 75   : 			}
; 76   : 			break;
; 77   : #endif
; 78   : #if (CUSTOM_PETS == 1)
; 79   : 		case 0x66:
; 80   : 			{
; 81   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 82   : 
; 83   : 				switch(lpRecv->subcode)
; 84   : 				{
; 85   : 
; 86   : 				case 0x00:
; 87   : 					gCustomPets.SummoInfoAnswer((LPBMSG_ANSSUMMONINFO)aRecv);
; 88   : 					break;
; 89   : 				}
; 90   : 			}
; 91   : 			break;
; 92   : #endif
; 93   : #if (CUSTOM_OLYMP==1)
; 94   : 		case 0x68:
; 95   : 			{
; 96   : 				PBMSG_HEAD2 * lpRecv = (PBMSG_HEAD2*)aRecv;
; 97   : 
; 98   : 				switch(lpRecv->subcode)
; 99   : 				{
; 100  : 				case 0x00:
; 101  : 					g_CustomOlymp.GS_DGAnsOlympInitData(aRecv);
; 102  : 					break;
; 103  : 				case 0x01:
; 104  : 					g_CustomOlymp.GS_DGAnsOlympDateChange(aRecv);
; 105  : 					break;
; 106  : 				case 0x02:
; 107  : 					g_CustomOlymp.GS_DGAnsOlympReg(aRecv);
; 108  : 					break;
; 109  : 				case 0x05:
; 110  : 					g_CustomOlymp.GS_DGAnsOlympReward(aRecv);
; 111  : 					break;
; 112  : 				case 0x06:
; 113  : 					g_CustomOlymp.GS_DGAnsOlympStats(aRecv);
; 114  : 					break;
; 115  : 				}
; 116  : 			}
; 117  : 			break;
; 118  : #endif
; 119  : 	}
; 120  : }

  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
  000bb	90		 npad	 1
$LN21@EventChipE:
  000bc	00 00 00 00	 DD	 $LN4@EventChipE
  000c0	00 00 00 00	 DD	 $LN5@EventChipE
  000c4	00 00 00 00	 DD	 $LN6@EventChipE
  000c8	00 00 00 00	 DD	 $LN7@EventChipE
  000cc	00 00 00 00	 DD	 $LN8@EventChipE
  000d0	00 00 00 00	 DD	 $LN9@EventChipE
  000d4	00 00 00 00	 DD	 $LN2@EventChipE
  000d8	00 00 00 00	 DD	 $LN12@EventChipE
  000dc	00 00 00 00	 DD	 $LN11@EventChipE
  000e0	00 00 00 00	 DD	 $LN13@EventChipE
  000e4	00 00 00 00	 DD	 $LN14@EventChipE
  000e8	00 00 00 00	 DD	 $LN15@EventChipE
  000ec	00 00 00 00	 DD	 $LN16@EventChipE
  000f0	00 00 00 00	 DD	 $LN2@EventChipE
$LN18@EventChipE:
  000f4	00		 DB	 0
  000f5	01		 DB	 1
  000f6	02		 DB	 2
  000f7	03		 DB	 3
  000f8	04		 DB	 4
  000f9	05		 DB	 5
  000fa	06		 DB	 6
  000fb	07		 DB	 7
  000fc	08		 DB	 8
  000fd	0d		 DB	 13			; 0000000dH
  000fe	0d		 DB	 13			; 0000000dH
  000ff	0d		 DB	 13			; 0000000dH
  00100	0d		 DB	 13			; 0000000dH
  00101	0d		 DB	 13			; 0000000dH
  00102	0d		 DB	 13			; 0000000dH
  00103	09		 DB	 9
  00104	0d		 DB	 13			; 0000000dH
  00105	0d		 DB	 13			; 0000000dH
  00106	0d		 DB	 13			; 0000000dH
  00107	0d		 DB	 13			; 0000000dH
  00108	0a		 DB	 10			; 0000000aH
  00109	0b		 DB	 11			; 0000000bH
  0010a	0c		 DB	 12			; 0000000cH
?EventChipEventProtocolCore@@YAXEPAEH@Z ENDP		; EventChipEventProtocolCore
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\event.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
