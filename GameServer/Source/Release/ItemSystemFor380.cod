; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\ItemSystemFor380.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??0CItemSystemFor380@@QAE@XZ			; CItemSystemFor380::CItemSystemFor380
PUBLIC	??1CItemSystemFor380@@UAE@XZ			; CItemSystemFor380::~CItemSystemFor380
PUBLIC	?Load380ItemOptionInfo@CItemSystemFor380@@QAEHPAD@Z ; CItemSystemFor380::Load380ItemOptionInfo
PUBLIC	?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z	; CItemSystemFor380::Is380Item
PUBLIC	?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380OptionItem
PUBLIC	?InitEffectValue@CItemSystemFor380@@QAEXPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z ; CItemSystemFor380::InitEffectValue
PUBLIC	?ApplyFor380Option@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z ; CItemSystemFor380::ApplyFor380Option
PUBLIC	?SetOptionItemByMacro@CItemSystemFor380@@QAEXPAUOBJECTSTRUCT@@EH@Z ; CItemSystemFor380::SetOptionItemByMacro
PUBLIC	?ChaosMix380ItemOption@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z ; CItemSystemFor380::ChaosMix380ItemOption
PUBLIC	?_InitOption@CItemSystemFor380@@AAEXXZ		; CItemSystemFor380::_InitOption
PUBLIC	?_CalcItemEffectValue@CItemSystemFor380@@AAEHHHPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z ; CItemSystemFor380::_CalcItemEffectValue
PUBLIC	?_SetOption@CItemSystemFor380@@AAEHPAVCItem@@H@Z ; CItemSystemFor380::_SetOption
PUBLIC	??_GCItemSystemFor380@@UAEPAXI@Z		; CItemSystemFor380::`scalar deleting destructor'
PUBLIC	?DebugLog@@YAXPADZZ				; DebugLog
PUBLIC	??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char *>
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7CItemSystemFor380@@6B@			; CItemSystemFor380::`vftable'
PUBLIC	?g_kItemSystemFor380@@3VCItemSystemFor380@@A	; g_kItemSystemFor380
PUBLIC	??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@	; `string'
PUBLIC	??_C@_0BE@IOGDNNHO@System380ItemSystem?$AA@	; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BM@LEJPEKJC@CountOfJewelOfHarmonyForMix?$AA@ ; `string'
PUBLIC	??_C@_0BL@NIODIINL@CountOfSuhoOfHarmonyForMix?$AA@ ; `string'
PUBLIC	??_C@_0O@OBABOJH@NeedZenForMix?$AA@		; `string'
PUBLIC	??_C@_0BB@OGNCKJFO@MixRateForGrade1?$AA@	; `string'
PUBLIC	??_C@_0BB@MNPPPKJN@MixRateForGrade2?$AA@	; `string'
PUBLIC	??_C@_0BB@NEOEMLNM@MixRateForGrade3?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0DA@DNNIILED@?$FL380Item?$FN?5OptionItem?5Check?5error@ ; `string'
PUBLIC	??_C@_0BN@HDJNGNAL@380?H?$LP?$LA?z?5?3?5?$LA?x?$LA?$NN?$LM?$LK?$LA?x?$MA?$LC?$LL?s?$LN?B?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@IJPMOAAH@380?H?$LP?$LA?z?5?3?5?$LF?$KF?$LJ?L?A?v?5?$LL?s?$LN?B?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@DKELHMA@380?H?$LP?$LA?z?5?3?5?$LJ?f?$LO?n?$LM?$LK?$LA?x?$MA?$LC?$LL?s?$LN?B?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@BAHDGKDP@380?H?$LP?$LA?z?5?3?5?$LJ?f?$LO?n?$LH?B?5?$LL?s?$LN?B?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@JNMCOPBP@380?H?$LP?$LA?z?5?3?5?C?V?$LE?k?5HP?5?$LL?s?$LN?B?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@POGHBBKE@380?H?$LP?$LA?z?5?3?5?C?V?$LE?k?5SD?5?$LL?s?$LN?B?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@FIBFGHCI@380?H?$LP?$LA?z?5?3?5SD?5?$MA?Z?$LF?$LP?5?H?$LI?$LK?$LJ?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@CPFKOFBB@380?H?$LP?$LA?z?5?3?5SD?$MA?Z?$LF?$LP?H?$LI?$LK?$LJ?$LH?$KO?5?A?u?$LA?$KB?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@IFIOIDM@380Item?$FN?$FLItem?5Mix?$AA@	; `string'
PUBLIC	??_C@_0CA@CBDBEMLE@?$FL380Item?$FN?$FLItem?5Mix?$FN?5?9?5Mix?5Start?$AA@ ; `string'
PUBLIC	??_C@_0GD@FNEHGIAM@?$FL380Item?$FN?$FLItemMix?$FN?5Mix?5Success?5?$FL@ ; `string'
PUBLIC	??_C@_0DP@LHPKHLIF@?$FL380Item?$FN?$FLItemMix?$FN?5Mix?5Fail?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_R4CItemSystemFor380@@6B@			; CItemSystemFor380::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCItemSystemFor380@@@8			; CItemSystemFor380 `RTTI Type Descriptor'
PUBLIC	??_R3CItemSystemFor380@@8			; CItemSystemFor380::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CItemSystemFor380@@8			; CItemSystemFor380::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CItemSystemFor380@@8		; CItemSystemFor380::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	??_ECItemSystemFor380@@UAEPAXI@Z:PROC		; CItemSystemFor380::`vector deleting destructor'
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z:PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CChaosBox::LogChaosItem
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A:BYTE ; g_kJewelOfHarmonySystem
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?g_ChaosBox@@3VCChaosBox@@A:BYTE		; g_ChaosBox
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?g_kItemSystemFor380@@3VCItemSystemFor380@@A DB 020020H DUP (?) ; g_kItemSystemFor380
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
_BSS	ENDS
CRT$XCU	SEGMENT
?g_kItemSystemFor380$initializer$@@3P6AXXZA DD FLAT:??__Eg_kItemSystemFor380@@YAXXZ ; g_kItemSystemFor380$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CItemSystemFor380@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CItemSystemFor380@@8 DD FLAT:??_R0?AVCItemSystemFor380@@@8 ; CItemSystemFor380::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CItemSystemFor380@@8
rdata$r	ENDS
;	COMDAT ??_R2CItemSystemFor380@@8
rdata$r	SEGMENT
??_R2CItemSystemFor380@@8 DD FLAT:??_R1A@?0A@EA@CItemSystemFor380@@8 ; CItemSystemFor380::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CItemSystemFor380@@8
rdata$r	SEGMENT
??_R3CItemSystemFor380@@8 DD 00H			; CItemSystemFor380::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CItemSystemFor380@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCItemSystemFor380@@@8
data$r	SEGMENT
??_R0?AVCItemSystemFor380@@@8 DD FLAT:??_7type_info@@6B@ ; CItemSystemFor380 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCItemSystemFor380@@', 00H
data$r	ENDS
;	COMDAT ??_R4CItemSystemFor380@@6B@
rdata$r	SEGMENT
??_R4CItemSystemFor380@@6B@ DD 00H			; CItemSystemFor380::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCItemSystemFor380@@@8
	DD	FLAT:??_R3CItemSystemFor380@@8
rdata$r	ENDS
;	COMDAT ??_C@_0DP@LHPKHLIF@?$FL380Item?$FN?$FLItemMix?$FN?5Mix?5Fail?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0DP@LHPKHLIF@?$FL380Item?$FN?$FLItemMix?$FN?5Mix?5Fail?5?$FL?$CFs?$FN@ DB '['
	DB	'380Item][ItemMix] Mix Fail [%s][%s], Money(%d-%d) Rate(%d/%d)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@FNEHGIAM@?$FL380Item?$FN?$FLItemMix?$FN?5Mix?5Success?5?$FL@
CONST	SEGMENT
??_C@_0GD@FNEHGIAM@?$FL380Item?$FN?$FLItemMix?$FN?5Mix?5Success?5?$FL@ DB '['
	DB	'380Item][ItemMix] Mix Success [%s][%s], Money(%d-%d) Rate(%d/'
	DB	'%d) Option(%d,%d) OptionValue(%d,%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CBDBEMLE@?$FL380Item?$FN?$FLItem?5Mix?$FN?5?9?5Mix?5Start?$AA@
CONST	SEGMENT
??_C@_0CA@CBDBEMLE@?$FL380Item?$FN?$FLItem?5Mix?$FN?5?9?5Mix?5Start?$AA@ DB '['
	DB	'380Item][Item Mix] - Mix Start', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IFIOIDM@380Item?$FN?$FLItem?5Mix?$AA@
CONST	SEGMENT
??_C@_0BC@IFIOIDM@380Item?$FN?$FLItem?5Mix?$AA@ DB '380Item][Item Mix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CPFKOFBB@380?H?$LP?$LA?z?5?3?5SD?$MA?Z?$LF?$LP?H?$LI?$LK?$LJ?$LH?$KO?5?A?u?$LA?$KB?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@CPFKOFBB@380?H?$LP?$LA?z?5?3?5SD?$MA?Z?$LF?$LP?H?$LI?$LK?$LJ?$LH?$KO?5?A?u?$LA?$KB?5?$CFd?6?$AA@ DB '3'
	DB	'80', 0c8H, 0bfH, 0b0H, 0faH, ' : SD', 0c0H, 0daH, 0b5H, 0bfH, 0c8H
	DB	0b8H, 0baH, 0b9H, 0b7H, 0aeH, ' ', 0c1H, 0f5H, 0b0H, 0a1H, ' %'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FIBFGHCI@380?H?$LP?$LA?z?5?3?5SD?5?$MA?Z?$LF?$LP?5?H?$LI?$LK?$LJ?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@FIBFGHCI@380?H?$LP?$LA?z?5?3?5SD?5?$MA?Z?$LF?$LP?5?H?$LI?$LK?$LJ?5?$CFd?6?$AA@ DB '3'
	DB	'80', 0c8H, 0bfH, 0b0H, 0faH, ' : SD ', 0c0H, 0daH, 0b5H, 0bfH
	DB	' ', 0c8H, 0b8H, 0baH, 0b9H, ' %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@POGHBBKE@380?H?$LP?$LA?z?5?3?5?C?V?$LE?k?5SD?5?$LL?s?$LN?B?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@POGHBBKE@380?H?$LP?$LA?z?5?3?5?C?V?$LE?k?5SD?5?$LL?s?$LN?B?5?$CFd?6?$AA@ DB '3'
	DB	'80', 0c8H, 0bfH, 0b0H, 0faH, ' : ', 0c3H, 0d6H, 0b4H, 0ebH, ' '
	DB	'SD ', 0bbH, 0f3H, 0bdH, 0c2H, ' %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JNMCOPBP@380?H?$LP?$LA?z?5?3?5?C?V?$LE?k?5HP?5?$LL?s?$LN?B?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@JNMCOPBP@380?H?$LP?$LA?z?5?3?5?C?V?$LE?k?5HP?5?$LL?s?$LN?B?5?$CFd?6?$AA@ DB '3'
	DB	'80', 0c8H, 0bfH, 0b0H, 0faH, ' : ', 0c3H, 0d6H, 0b4H, 0ebH, ' '
	DB	'HP ', 0bbH, 0f3H, 0bdH, 0c2H, ' %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BAHDGKDP@380?H?$LP?$LA?z?5?3?5?$LJ?f?$LO?n?$LH?B?5?$LL?s?$LN?B?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@BAHDGKDP@380?H?$LP?$LA?z?5?3?5?$LJ?f?$LO?n?$LH?B?5?$LL?s?$LN?B?5?$CFd?6?$AA@ DB '3'
	DB	'80', 0c8H, 0bfH, 0b0H, 0faH, ' : ', 0b9H, 0e6H, 0beH, 0eeH, 0b7H
	DB	0c2H, ' ', 0bbH, 0f3H, 0bdH, 0c2H, ' %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DKELHMA@380?H?$LP?$LA?z?5?3?5?$LJ?f?$LO?n?$LM?$LK?$LA?x?$MA?$LC?$LL?s?$LN?B?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@DKELHMA@380?H?$LP?$LA?z?5?3?5?$LJ?f?$LO?n?$LM?$LK?$LA?x?$MA?$LC?$LL?s?$LN?B?5?$CFd?6?$AA@ DB '3'
	DB	'80', 0c8H, 0bfH, 0b0H, 0faH, ' : ', 0b9H, 0e6H, 0beH, 0eeH, 0bcH
	DB	0baH, 0b0H, 0f8H, 0c0H, 0b2H, 0bbH, 0f3H, 0bdH, 0c2H, ' %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IJPMOAAH@380?H?$LP?$LA?z?5?3?5?$LF?$KF?$LJ?L?A?v?5?$LL?s?$LN?B?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@IJPMOAAH@380?H?$LP?$LA?z?5?3?5?$LF?$KF?$LJ?L?A?v?5?$LL?s?$LN?B?5?$CFd?6?$AA@ DB '3'
	DB	'80', 0c8H, 0bfH, 0b0H, 0faH, ' : ', 0b5H, 0a5H, 0b9H, 0ccH, 0c1H
	DB	0f6H, ' ', 0bbH, 0f3H, 0bdH, 0c2H, ' %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HDJNGNAL@380?H?$LP?$LA?z?5?3?5?$LA?x?$LA?$NN?$LM?$LK?$LA?x?$MA?$LC?$LL?s?$LN?B?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@HDJNGNAL@380?H?$LP?$LA?z?5?3?5?$LA?x?$LA?$NN?$LM?$LK?$LA?x?$MA?$LC?$LL?s?$LN?B?5?$CFd?6?$AA@ DB '3'
	DB	'80', 0c8H, 0bfH, 0b0H, 0faH, ' : ', 0b0H, 0f8H, 0b0H, 0ddH, 0bcH
	DB	0baH, 0b0H, 0f8H, 0c0H, 0b2H, 0bbH, 0f3H, 0bdH, 0c2H, ' %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DNNIILED@?$FL380Item?$FN?5OptionItem?5Check?5error@
CONST	SEGMENT
??_C@_0DA@DNNIILED@?$FL380Item?$FN?5OptionItem?5Check?5error@ DB '[380Ite'
	DB	'm] OptionItem Check error: (iItemNum:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NEOEMLNM@MixRateForGrade3?$AA@
CONST	SEGMENT
??_C@_0BB@NEOEMLNM@MixRateForGrade3?$AA@ DB 'MixRateForGrade3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MNPPPKJN@MixRateForGrade2?$AA@
CONST	SEGMENT
??_C@_0BB@MNPPPKJN@MixRateForGrade2?$AA@ DB 'MixRateForGrade2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OGNCKJFO@MixRateForGrade1?$AA@
CONST	SEGMENT
??_C@_0BB@OGNCKJFO@MixRateForGrade1?$AA@ DB 'MixRateForGrade1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OBABOJH@NeedZenForMix?$AA@
CONST	SEGMENT
??_C@_0O@OBABOJH@NeedZenForMix?$AA@ DB 'NeedZenForMix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NIODIINL@CountOfSuhoOfHarmonyForMix?$AA@
CONST	SEGMENT
??_C@_0BL@NIODIINL@CountOfSuhoOfHarmonyForMix?$AA@ DB 'CountOfSuhoOfHarmo'
	DB	'nyForMix', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LEJPEKJC@CountOfJewelOfHarmonyForMix?$AA@
CONST	SEGMENT
??_C@_0BM@LEJPEKJC@CountOfJewelOfHarmonyForMix?$AA@ DB 'CountOfJewelOfHar'
	DB	'monyForMix', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IOGDNNHO@System380ItemSystem?$AA@
CONST	SEGMENT
??_C@_0BE@IOGDNNHO@System380ItemSystem?$AA@ DB 'System380ItemSystem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@ DB 'CommonServer.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CItemSystemFor380@@6B@
CONST	SEGMENT
??_7CItemSystemFor380@@6B@ DD FLAT:??_R4CItemSystemFor380@@6B@ ; CItemSystemFor380::`vftable'
	DD	FLAT:??_ECItemSystemFor380@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_kItemSystemFor380@@YAXXZ
text$yd	SEGMENT
??__Fg_kItemSystemFor380@@YAXXZ PROC			; `dynamic atexit destructor for 'g_kItemSystemFor380'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  00005	e9 00 00 00 00	 jmp	 ??1CItemSystemFor380@@UAE@XZ ; CItemSystemFor380::~CItemSystemFor380
??__Fg_kItemSystemFor380@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_kItemSystemFor380''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ??__Eg_kItemSystemFor380@@YAXXZ
text$di	SEGMENT
??__Eg_kItemSystemFor380@@YAXXZ PROC			; `dynamic initializer for 'g_kItemSystemFor380'', COMDAT

; 14   : CItemSystemFor380 g_kItemSystemFor380;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  00005	e8 00 00 00 00	 call	 ??0CItemSystemFor380@@QAE@XZ ; CItemSystemFor380::CItemSystemFor380
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_kItemSystemFor380@@YAXXZ ; `dynamic atexit destructor for 'g_kItemSystemFor380''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_kItemSystemFor380@@YAXXZ ENDP			; `dynamic initializer for 'g_kItemSystemFor380''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	int ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA, 0
  00017	53		 push	 ebx
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8b d8		 mov	 ebx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	83 fb ff	 cmp	 ebx, -1
  00033	74 5d		 je	 SHORT $LN43@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)
; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  00038	75 30		 jne	 SHORT $LN2@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00040	e8 00 00 00 00	 call	 _fgetc
  00045	8b d8		 mov	 ebx, eax
  00047	83 c4 04	 add	 esp, 4
  0004a	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  0004d	75 1b		 jne	 SHORT $LN2@GetToken
  0004f	90		 npad	 1
$LL5@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	83 fb ff	 cmp	 ebx, -1
  00053	74 3d		 je	 SHORT $LN43@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0005b	e8 00 00 00 00	 call	 _fgetc
  00060	8b d8		 mov	 ebx, eax
  00062	83 c4 04	 add	 esp, 4
  00065	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00068	75 e6		 jne	 SHORT $LL5@GetToken
$LN2@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _isspace
  00070	83 c4 04	 add	 esp, 4
  00073	85 c0		 test	 eax, eax
  00075	75 a9		 jne	 SHORT $LL4@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00077	8d 43 de	 lea	 eax, DWORD PTR [ebx-34]
  0007a	56		 push	 esi
  0007b	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  0007e	0f 87 89 01 00
	00		 ja	 $LN29@GetToken
  00084	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN58@GetToken[eax]
  0008b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN64@GetToken[eax*4]
$LN43@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE

  00092	b8 02 00 00 00	 mov	 eax, 2
  00097	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	33 cd		 xor	 ecx, ebp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN20@GetToken:
  000a6	5e		 pop	 esi

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000a7	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  000b1	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b6	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
$LN21@GetToken:
  000c5	5e		 pop	 esi

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000c6	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  000d0	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000d5	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN22@GetToken:
  000e4	5e		 pop	 esi

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000e5	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  000ef	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000f4	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f8	33 cd		 xor	 ecx, ebp
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN23@GetToken:
  00103	5e		 pop	 esi

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00104	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0010e	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  00113	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00114	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	33 cd		 xor	 ecx, ebp
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN24@GetToken:
  00122	5e		 pop	 esi

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00123	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  0012d	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  00132	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
$LN25@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00141	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00147	53		 push	 ebx
  00148	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  0014d	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00153	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  00156	e8 00 00 00 00	 call	 _getc
  0015b	8b d8		 mov	 ebx, eax
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	83 fb ff	 cmp	 ebx, -1
  00163	74 2f		 je	 SHORT $LN59@GetToken
$LL9@GetToken:
  00165	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00168	74 12		 je	 SHORT $LN26@GetToken
  0016a	53		 push	 ebx
  0016b	e8 00 00 00 00	 call	 _isdigit
  00170	83 c4 04	 add	 esp, 4
  00173	85 c0		 test	 eax, eax
  00175	75 05		 jne	 SHORT $LN26@GetToken
  00177	83 fb 2d	 cmp	 ebx, 45			; 0000002dH
  0017a	75 18		 jne	 SHORT $LN59@GetToken
$LN26@GetToken:
  0017c	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00182	88 1e		 mov	 BYTE PTR [esi], bl

; 102  : 			p++;

  00184	46		 inc	 esi
  00185	e8 00 00 00 00	 call	 _getc
  0018a	8b d8		 mov	 ebx, eax
  0018c	83 c4 04	 add	 esp, 4
  0018f	83 fb ff	 cmp	 ebx, -1
  00192	75 d1		 jne	 SHORT $LL9@GetToken
$LN59@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = (float)atof( TempString);	// Select the first Byte as Main ID

  00194	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  00197	c6 06 00	 mov	 BYTE PTR [esi], 0
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _atof
  001a0	83 c4 04	 add	 esp, 4

; 106  : 		return CurrentToken  = NUMBER ;

  001a3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  001ad	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA
  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  001ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bd	33 cd		 xor	 ecx, ebp
  001bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$LN27@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  001c8	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  001ce	be 00 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA
  001d3	e8 00 00 00 00	 call	 _getc
  001d8	83 c4 04	 add	 esp, 4
  001db	83 f8 ff	 cmp	 eax, -1
  001de	74 1f		 je	 SHORT $LN12@GetToken
$LL11@GetToken:
  001e0	83 f8 22	 cmp	 eax, 34			; 00000022H
  001e3	0f 84 95 00 00
	00		 je	 $LN28@GetToken
  001e9	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 113  : 		{
; 114  : 			*p = ch;

  001ef	88 06		 mov	 BYTE PTR [esi], al

; 115  : 			p++;

  001f1	46		 inc	 esi
  001f2	e8 00 00 00 00	 call	 _getc
  001f7	83 c4 04	 add	 esp, 4
  001fa	83 f8 ff	 cmp	 eax, -1
  001fd	75 e1		 jne	 SHORT $LL11@GetToken
$LN12@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001ff	83 f8 22	 cmp	 eax, 34			; 00000022H
  00202	74 7a		 je	 SHORT $LN28@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00204	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0020a	50		 push	 eax

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  0020b	eb 69		 jmp	 SHORT $LN62@GetToken
$LN29@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0020d	53		 push	 ebx
  0020e	e8 00 00 00 00	 call	 _isalpha
  00213	83 c4 04	 add	 esp, 4
  00216	85 c0		 test	 eax, eax
  00218	0f 84 7f 00 00
	00		 je	 $LN30@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  0021e	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00224	88 1d 00 00 00
	00		 mov	 BYTE PTR ?TokenString@@3PADA, bl
  0022a	be 01 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA+1
  0022f	e8 00 00 00 00	 call	 _getc
  00234	8b d8		 mov	 ebx, eax
  00236	83 c4 04	 add	 esp, 4
  00239	83 fb ff	 cmp	 ebx, -1
  0023c	74 31		 je	 SHORT $LN60@GetToken
  0023e	66 90		 npad	 2
$LL13@GetToken:
  00240	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00243	74 12		 je	 SHORT $LN32@GetToken
  00245	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00248	74 0d		 je	 SHORT $LN32@GetToken
  0024a	53		 push	 ebx
  0024b	e8 00 00 00 00	 call	 _isalnum
  00250	83 c4 04	 add	 esp, 4
  00253	85 c0		 test	 eax, eax
  00255	74 18		 je	 SHORT $LN60@GetToken
$LN32@GetToken:
  00257	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 133  : 			{
; 134  : 				*p=ch;

  0025d	88 1e		 mov	 BYTE PTR [esi], bl

; 135  : 				p++;

  0025f	46		 inc	 esi
  00260	e8 00 00 00 00	 call	 _getc
  00265	8b d8		 mov	 ebx, eax
  00267	83 c4 04	 add	 esp, 4
  0026a	83 fb ff	 cmp	 ebx, -1
  0026d	75 d1		 jne	 SHORT $LL13@GetToken
$LN60@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0026f	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00275	53		 push	 ebx
$LN62@GetToken:
  00276	e8 00 00 00 00	 call	 _ungetc
  0027b	83 c4 08	 add	 esp, 8
$LN28@GetToken:

; 140  : 			*p=0;

  0027e	c6 06 00	 mov	 BYTE PTR [esi], 0

; 141  : 			CurrentToken=NAME;
; 142  : 			return CurrentToken;

  00281	33 c0		 xor	 eax, eax
  00283	5e		 pop	 esi
  00284	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0028e	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0028f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00292	33 cd		 xor	 ecx, ebp
  00294	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00299	8b e5		 mov	 esp, ebp
  0029b	5d		 pop	 ebp
  0029c	c3		 ret	 0
$LN30@GetToken:
  0029d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a0	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  002a5	5e		 pop	 esi
  002a6	33 cd		 xor	 ecx, ebp
  002a8	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  002b2	5b		 pop	 ebx
  002b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
$LN64@GetToken:
  002bc	00 00 00 00	 DD	 $LN27@GetToken
  002c0	00 00 00 00	 DD	 $LN20@GetToken
  002c4	00 00 00 00	 DD	 $LN22@GetToken
  002c8	00 00 00 00	 DD	 $LN25@GetToken
  002cc	00 00 00 00	 DD	 $LN21@GetToken
  002d0	00 00 00 00	 DD	 $LN23@GetToken
  002d4	00 00 00 00	 DD	 $LN24@GetToken
  002d8	00 00 00 00	 DD	 $LN29@GetToken
$LN58@GetToken:
  002dc	00		 DB	 0
  002dd	01		 DB	 1
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	07		 DB	 7
  002e2	07		 DB	 7
  002e3	07		 DB	 7
  002e4	07		 DB	 7
  002e5	07		 DB	 7
  002e6	02		 DB	 2
  002e7	03		 DB	 3
  002e8	03		 DB	 3
  002e9	07		 DB	 7
  002ea	03		 DB	 3
  002eb	03		 DB	 3
  002ec	03		 DB	 3
  002ed	03		 DB	 3
  002ee	03		 DB	 3
  002ef	03		 DB	 3
  002f0	03		 DB	 3
  002f1	03		 DB	 3
  002f2	03		 DB	 3
  002f3	03		 DB	 3
  002f4	07		 DB	 7
  002f5	04		 DB	 4
  002f6	07		 DB	 7
  002f7	07		 DB	 7
  002f8	07		 DB	 7
  002f9	07		 DB	 7
  002fa	07		 DB	 7
  002fb	07		 DB	 7
  002fc	07		 DB	 7
  002fd	07		 DB	 7
  002fe	07		 DB	 7
  002ff	07		 DB	 7
  00300	07		 DB	 7
  00301	07		 DB	 7
  00302	07		 DB	 7
  00303	07		 DB	 7
  00304	07		 DB	 7
  00305	07		 DB	 7
  00306	07		 DB	 7
  00307	07		 DB	 7
  00308	07		 DB	 7
  00309	07		 DB	 7
  0030a	07		 DB	 7
  0030b	07		 DB	 7
  0030c	07		 DB	 7
  0030d	07		 DB	 7
  0030e	07		 DB	 7
  0030f	07		 DB	 7
  00310	07		 DB	 7
  00311	07		 DB	 7
  00312	07		 DB	 7
  00313	07		 DB	 7
  00314	07		 DB	 7
  00315	07		 DB	 7
  00316	07		 DB	 7
  00317	07		 DB	 7
  00318	07		 DB	 7
  00319	07		 DB	 7
  0031a	07		 DB	 7
  0031b	07		 DB	 7
  0031c	07		 DB	 7
  0031d	07		 DB	 7
  0031e	07		 DB	 7
  0031f	07		 DB	 7
  00320	07		 DB	 7
  00321	07		 DB	 7
  00322	07		 DB	 7
  00323	07		 DB	 7
  00324	07		 DB	 7
  00325	07		 DB	 7
  00326	07		 DB	 7
  00327	07		 DB	 7
  00328	07		 DB	 7
  00329	07		 DB	 7
  0032a	07		 DB	 7
  0032b	07		 DB	 7
  0032c	07		 DB	 7
  0032d	07		 DB	 7
  0032e	07		 DB	 7
  0032f	07		 DB	 7
  00330	07		 DB	 7
  00331	07		 DB	 7
  00332	07		 DB	 7
  00333	07		 DB	 7
  00334	07		 DB	 7
  00335	05		 DB	 5
  00336	07		 DB	 7
  00337	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.h
;	COMDAT ?DebugLog@@YAXPADZZ
_TEXT	SEGMENT
_szBuffer$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_szLog$ = 8						; size = 4
?DebugLog@@YAXPADZZ PROC				; DebugLog, COMDAT

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	68 00 02 00 00	 push	 512			; 00000200H
  00018	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0001e	6a 00		 push	 0
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _memset
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00029	8d 45 0c	 lea	 eax, DWORD PTR _szLog$[ebp+4]
  0002c	50		 push	 eax
  0002d	6a 00		 push	 0
  0002f	ff 75 08	 push	 DWORD PTR _szLog$[ebp]
  00032	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  00038	6a ff		 push	 -1
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	ff 70 04	 push	 DWORD PTR [eax+4]
  00045	83 c9 01	 or	 ecx, 1
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.h

; 101  : }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00051	83 c4 1c	 add	 esp, 28			; 0000001cH
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.h

; 101  : }

  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?DebugLog@@YAXPADZZ ENDP				; DebugLog
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCItemSystemFor380@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCItemSystemFor380@@UAEPAXI@Z PROC			; CItemSystemFor380::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CItemSystemFor380@@UAE@XZ ; CItemSystemFor380::~CItemSystemFor380
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 20 00 02 00	 push	 131104			; 00020020H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCItemSystemFor380@@UAEPAXI@Z ENDP			; CItemSystemFor380::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?_SetOption@CItemSystemFor380@@AAEHPAVCItem@@H@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
_bOption$ = 12						; size = 4
?_SetOption@CItemSystemFor380@@AAEHPAVCItem@@H@Z PROC	; CItemSystemFor380::_SetOption, COMDAT
; _this$ = ecx

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 264  : 	if ( !this->Is380Item(pItem) )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pItem$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380Item
  0000d	85 c0		 test	 eax, eax
  0000f	75 05		 jne	 SHORT $LN2@SetOption
  00011	5e		 pop	 esi

; 273  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
$LN2@SetOption:

; 265  : 		return FALSE;
; 266  : 
; 267  : 	if ( bOption  == TRUE )

  00016	83 7d 0c 01	 cmp	 DWORD PTR _bOption$[ebp], 1
  0001a	75 11		 jne	 SHORT $LN3@SetOption

; 268  : 		pItem->m_ItemOptionEx |= 0x80;

  0001c	80 8e c6 00 00
	00 80		 or	 BYTE PTR [esi+198], 128	; 00000080H

; 271  : 
; 272  : 	return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	5e		 pop	 esi

; 273  : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN3@SetOption:

; 269  : 	else
; 270  : 		pItem->m_ItemOptionEx &= ~0x80;

  0002d	80 a6 c6 00 00
	00 7f		 and	 BYTE PTR [esi+198], 127	; 0000007fH

; 271  : 
; 272  : 	return TRUE;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	5e		 pop	 esi

; 273  : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
?_SetOption@CItemSystemFor380@@AAEHPAVCItem@@H@Z ENDP	; CItemSystemFor380::_SetOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?_CalcItemEffectValue@CItemSystemFor380@@AAEHHHPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z
_TEXT	SEGMENT
_iItemOptionType$ = 8					; size = 4
_iItemEffectValue$ = 12					; size = 4
_pItemEffect$ = 16					; size = 4
?_CalcItemEffectValue@CItemSystemFor380@@AAEHHHPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z PROC ; CItemSystemFor380::_CalcItemEffectValue, COMDAT
; _this$ = ecx

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 203  : 	if ( iItemOptionType == 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iItemOptionType$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@CalcItemEf

; 249  : }

  0000a	5d		 pop	 ebp
  0000b	c2 0c 00	 ret	 12			; 0000000cH
$LN4@CalcItemEf:

; 204  : 		return FALSE;
; 205  : 
; 206  : 	BOOL bResult = TRUE;
; 207  : 
; 208  : 	switch ( iItemOptionType )

  0000e	48		 dec	 eax
  0000f	56		 push	 esi
  00010	be 01 00 00 00	 mov	 esi, 1
  00015	83 f8 07	 cmp	 eax, 7
  00018	0f 87 fd 00 00
	00		 ja	 $LN13@CalcItemEf
  0001e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN16@CalcItemEf[eax*4]
$LN5@CalcItemEf:

; 209  : 	{
; 210  : 		//case ITEMOPTION_FOR380ITEM_EFFECT_NONE:
; 211  : 		case ITEMOPTION_FOR380ITEM_EFFECT_OPADDATTACKSUCCESSRATEPVP:
; 212  : 			pItemEffect->OpAddAttackSuccessRatePVP += iItemEffectValue;

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _iItemEffectValue$[ebp]
  00028	8b 45 10	 mov	 eax, DWORD PTR _pItemEffect$[ebp]

; 213  : 			DebugLog("380효과 : 공격성공율상승 %d\n", iItemEffectValue);

  0002b	51		 push	 ecx
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HDJNGNAL@380?H?$LP?$LA?z?5?3?5?$LA?x?$LA?$NN?$LM?$LK?$LA?x?$MA?$LC?$LL?s?$LN?B?5?$CFd?6?$AA@
  00031	66 01 08	 add	 WORD PTR [eax], cx
  00034	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  00039	83 c4 08	 add	 esp, 8

; 245  : 			break;
; 246  : 	}
; 247  : 
; 248  : 	return bResult;

  0003c	8b c6		 mov	 eax, esi
  0003e	5e		 pop	 esi

; 249  : }

  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH
$LN6@CalcItemEf:

; 214  : 			break;
; 215  : 		case ITEMOPTION_FOR380ITEM_EFFECT_OPADDDAMAGE:
; 216  : 			pItemEffect->OpAddDamage += iItemEffectValue;

  00043	8b 4d 10	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  00046	8b 45 0c	 mov	 eax, DWORD PTR _iItemEffectValue$[ebp]

; 217  : 			DebugLog("380효과 : 데미지 상승 %d\n", iItemEffectValue);

  00049	50		 push	 eax
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@IJPMOAAH@380?H?$LP?$LA?z?5?3?5?$LF?$KF?$LJ?L?A?v?5?$LL?s?$LN?B?5?$CFd?6?$AA@
  0004f	66 01 41 02	 add	 WORD PTR [ecx+2], ax
  00053	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  00058	83 c4 08	 add	 esp, 8

; 245  : 			break;
; 246  : 	}
; 247  : 
; 248  : 	return bResult;

  0005b	8b c6		 mov	 eax, esi
  0005d	5e		 pop	 esi

; 249  : }

  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
$LN7@CalcItemEf:

; 218  : 			break;
; 219  : 		case ITEMOPTION_FOR380ITEM_EFFECT_OPADDDEFENSESUCCESSRATEPVP:
; 220  : 			pItemEffect->OpAddDefenseSuccessRatePvP += iItemEffectValue;

  00062	8b 4d 10	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  00065	8b 45 0c	 mov	 eax, DWORD PTR _iItemEffectValue$[ebp]

; 221  : 			DebugLog("380효과 : 방어성공율상승 %d\n", iItemEffectValue);

  00068	50		 push	 eax
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DKELHMA@380?H?$LP?$LA?z?5?3?5?$LJ?f?$LO?n?$LM?$LK?$LA?x?$MA?$LC?$LL?s?$LN?B?5?$CFd?6?$AA@
  0006e	66 01 41 04	 add	 WORD PTR [ecx+4], ax
  00072	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  00077	83 c4 08	 add	 esp, 8

; 245  : 			break;
; 246  : 	}
; 247  : 
; 248  : 	return bResult;

  0007a	8b c6		 mov	 eax, esi
  0007c	5e		 pop	 esi

; 249  : }

  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
$LN8@CalcItemEf:

; 222  : 			break;
; 223  : 		case ITEMOPTION_FOR380ITEM_EFFECT_OPADDDEFENSE:
; 224  : 			pItemEffect->OpAddDefense += iItemEffectValue;

  00081	8b 4d 10	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  00084	8b 45 0c	 mov	 eax, DWORD PTR _iItemEffectValue$[ebp]

; 225  : 			DebugLog("380효과 : 방어력 상승 %d\n", iItemEffectValue);

  00087	50		 push	 eax
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@BAHDGKDP@380?H?$LP?$LA?z?5?3?5?$LJ?f?$LO?n?$LH?B?5?$LL?s?$LN?B?5?$CFd?6?$AA@
  0008d	66 01 41 06	 add	 WORD PTR [ecx+6], ax
  00091	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  00096	83 c4 08	 add	 esp, 8

; 245  : 			break;
; 246  : 	}
; 247  : 
; 248  : 	return bResult;

  00099	8b c6		 mov	 eax, esi
  0009b	5e		 pop	 esi

; 249  : }

  0009c	5d		 pop	 ebp
  0009d	c2 0c 00	 ret	 12			; 0000000cH
$LN9@CalcItemEf:

; 226  : 			break;
; 227  : 		case ITEMOPTION_FOR380ITEM_EFFECT_OPADDMAXHP:
; 228  : 			pItemEffect->OpAddMaxHP += iItemEffectValue;

  000a0	8b 4d 10	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  000a3	8b 45 0c	 mov	 eax, DWORD PTR _iItemEffectValue$[ebp]

; 229  : 			DebugLog("380효과 : 최대 HP 상승 %d\n", iItemEffectValue);

  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@JNMCOPBP@380?H?$LP?$LA?z?5?3?5?C?V?$LE?k?5HP?5?$LL?s?$LN?B?5?$CFd?6?$AA@
  000ac	66 01 41 08	 add	 WORD PTR [ecx+8], ax
  000b0	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  000b5	83 c4 08	 add	 esp, 8

; 245  : 			break;
; 246  : 	}
; 247  : 
; 248  : 	return bResult;

  000b8	8b c6		 mov	 eax, esi
  000ba	5e		 pop	 esi

; 249  : }

  000bb	5d		 pop	 ebp
  000bc	c2 0c 00	 ret	 12			; 0000000cH
$LN10@CalcItemEf:

; 230  : 			break;
; 231  : 		case ITEMOPTION_FOR380ITEM_EFFECT_OPADDMAXSD:
; 232  : 			pItemEffect->OpAddMaxSD += iItemEffectValue;

  000bf	8b 4d 10	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _iItemEffectValue$[ebp]

; 233  : 			DebugLog("380효과 : 최대 SD 상승 %d\n", iItemEffectValue);

  000c5	50		 push	 eax
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@POGHBBKE@380?H?$LP?$LA?z?5?3?5?C?V?$LE?k?5SD?5?$LL?s?$LN?B?5?$CFd?6?$AA@
  000cb	66 01 41 0a	 add	 WORD PTR [ecx+10], ax
  000cf	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  000d4	83 c4 08	 add	 esp, 8

; 245  : 			break;
; 246  : 	}
; 247  : 
; 248  : 	return bResult;

  000d7	8b c6		 mov	 eax, esi
  000d9	5e		 pop	 esi

; 249  : }

  000da	5d		 pop	 ebp
  000db	c2 0c 00	 ret	 12			; 0000000cH
$LN11@CalcItemEf:

; 234  : 			break;
; 235  : 		case ITEMOPTION_FOR380ITEM_EFFECT_OPREFILLON:
; 236  : 			pItemEffect->OpRefillOn += 1;

  000de	8b 45 10	 mov	 eax, DWORD PTR _pItemEffect$[ebp]

; 237  : 			DebugLog("380효과 : SD 자동 회복 %d\n", iItemEffectValue);

  000e1	ff 75 0c	 push	 DWORD PTR _iItemEffectValue$[ebp]
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FIBFGHCI@380?H?$LP?$LA?z?5?3?5SD?5?$MA?Z?$LF?$LP?5?H?$LI?$LK?$LJ?5?$CFd?6?$AA@
  000e9	66 ff 40 0c	 inc	 WORD PTR [eax+12]
  000ed	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  000f2	83 c4 08	 add	 esp, 8

; 245  : 			break;
; 246  : 	}
; 247  : 
; 248  : 	return bResult;

  000f5	8b c6		 mov	 eax, esi
  000f7	5e		 pop	 esi

; 249  : }

  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
$LN12@CalcItemEf:

; 238  : 			break;
; 239  : 		case ITEMOPTION_FOR380ITEM_EFFECT_OPADDREFILLSD:
; 240  : 			pItemEffect->OpAddRefillSD += iItemEffectValue;

  000fc	8b 4d 10	 mov	 ecx, DWORD PTR _pItemEffect$[ebp]
  000ff	8b 45 0c	 mov	 eax, DWORD PTR _iItemEffectValue$[ebp]

; 241  : 			DebugLog("380효과 : SD자동회복량 증가 %d\n", iItemEffectValue);

  00102	50		 push	 eax
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@CPFKOFBB@380?H?$LP?$LA?z?5?3?5SD?$MA?Z?$LF?$LP?H?$LI?$LK?$LJ?$LH?$KO?5?A?u?$LA?$KB?5?$CFd?6?$AA@
  00108	66 01 41 0e	 add	 WORD PTR [ecx+14], ax
  0010c	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  00111	83 c4 08	 add	 esp, 8

; 245  : 			break;
; 246  : 	}
; 247  : 
; 248  : 	return bResult;

  00114	8b c6		 mov	 eax, esi
  00116	5e		 pop	 esi

; 249  : }

  00117	5d		 pop	 ebp
  00118	c2 0c 00	 ret	 12			; 0000000cH
$LN13@CalcItemEf:

; 242  : 			break;
; 243  : 		default:
; 244  : 			bResult = FALSE;

  0011b	33 f6		 xor	 esi, esi

; 245  : 			break;
; 246  : 	}
; 247  : 
; 248  : 	return bResult;

  0011d	8b c6		 mov	 eax, esi
  0011f	5e		 pop	 esi

; 249  : }

  00120	5d		 pop	 ebp
  00121	c2 0c 00	 ret	 12			; 0000000cH
$LN16@CalcItemEf:
  00124	00 00 00 00	 DD	 $LN5@CalcItemEf
  00128	00 00 00 00	 DD	 $LN6@CalcItemEf
  0012c	00 00 00 00	 DD	 $LN7@CalcItemEf
  00130	00 00 00 00	 DD	 $LN8@CalcItemEf
  00134	00 00 00 00	 DD	 $LN9@CalcItemEf
  00138	00 00 00 00	 DD	 $LN10@CalcItemEf
  0013c	00 00 00 00	 DD	 $LN11@CalcItemEf
  00140	00 00 00 00	 DD	 $LN12@CalcItemEf
?_CalcItemEffectValue@CItemSystemFor380@@AAEHHHPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z ENDP ; CItemSystemFor380::_CalcItemEffectValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?_InitOption@CItemSystemFor380@@AAEXXZ
_TEXT	SEGMENT
?_InitOption@CItemSystemFor380@@AAEXXZ PROC		; CItemSystemFor380::_InitOption, COMDAT
; _this$ = ecx

; 31   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 32   : 	memset(this->m_itemOption, 0, sizeof(this->m_itemOption));

  00004	68 00 00 02 00	 push	 131072			; 00020000H
  00009	6a 00		 push	 0
  0000b	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33   : 
; 34   : 	this->m_iNeedJewelOfHarmonyCount = 1;

  00017	c7 87 08 00 02
	00 01 00 00 00	 mov	 DWORD PTR [edi+131080], 1

; 35   : 	this->m_iNeedJewelOfSuhoCount = 1;
; 36   : 	this->m_iNeedZenFor380Option = 10000000;
; 37   : 	this->m_iRateSuccessRateForMix1 = 50;
; 38   : 	this->m_iRateSuccessRateForMix2 = 60;
; 39   : 	this->m_iRateSuccessRateForMix3 = 100;
; 40   : 
; 41   : 	this->m_bSystemFor380ItemOption = GetPrivateProfileInt("GameServerInfo", "System380ItemSystem", 0, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00021	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00026	c7 87 0c 00 02
	00 01 00 00 00	 mov	 DWORD PTR [edi+131084], 1
  00030	c7 87 10 00 02
	00 80 96 98 00	 mov	 DWORD PTR [edi+131088], 10000000 ; 00989680H
  0003a	c7 87 14 00 02
	00 32 00 00 00	 mov	 DWORD PTR [edi+131092], 50 ; 00000032H
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00049	c7 87 18 00 02
	00 3c 00 00 00	 mov	 DWORD PTR [edi+131096], 60 ; 0000003cH
  00053	c7 87 1c 00 02
	00 64 00 00 00	 mov	 DWORD PTR [edi+131100], 100 ; 00000064H
  0005d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00062	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetPrivateProfileIntA@16
  00068	50		 push	 eax
  00069	6a 00		 push	 0
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IOGDNNHO@System380ItemSystem?$AA@
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00075	ff d6		 call	 esi

; 42   : 	this->m_iNeedJewelOfHarmonyCount = GetPrivateProfileInt("GameServerInfo", "CountOfJewelOfHarmonyForMix", 1, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00081	89 87 04 00 02
	00		 mov	 DWORD PTR [edi+131076], eax
  00087	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0008c	50		 push	 eax
  0008d	6a 01		 push	 1
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LEJPEKJC@CountOfJewelOfHarmonyForMix?$AA@
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00099	ff d6		 call	 esi

; 43   : 	this->m_iNeedJewelOfSuhoCount = GetPrivateProfileInt("GameServerInfo", "CountOfSuhoOfHarmonyForMix", 1, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  000a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000a5	89 87 08 00 02
	00		 mov	 DWORD PTR [edi+131080], eax
  000ab	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000b0	50		 push	 eax
  000b1	6a 01		 push	 1
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NIODIINL@CountOfSuhoOfHarmonyForMix?$AA@
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000bd	ff d6		 call	 esi

; 44   : 	this->m_iNeedZenFor380Option = GetPrivateProfileInt("GameServerInfo", "NeedZenForMix", 10000000, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  000c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000c9	89 87 0c 00 02
	00		 mov	 DWORD PTR [edi+131084], eax
  000cf	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000d4	50		 push	 eax
  000d5	68 80 96 98 00	 push	 10000000		; 00989680H
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OBABOJH@NeedZenForMix?$AA@
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000e4	ff d6		 call	 esi

; 45   : 	this->m_iRateSuccessRateForMix1 = GetPrivateProfileInt("GameServerInfo", "MixRateForGrade1", 50, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  000f0	89 87 10 00 02
	00		 mov	 DWORD PTR [edi+131088], eax
  000f6	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000fb	50		 push	 eax
  000fc	6a 32		 push	 50			; 00000032H
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OGNCKJFO@MixRateForGrade1?$AA@
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00108	ff d6		 call	 esi

; 46   : 	this->m_iRateSuccessRateForMix2 = GetPrivateProfileInt("GameServerInfo", "MixRateForGrade2", 60, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  0010f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00114	89 87 14 00 02
	00		 mov	 DWORD PTR [edi+131092], eax
  0011a	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0011f	50		 push	 eax
  00120	6a 3c		 push	 60			; 0000003cH
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MNPPPKJN@MixRateForGrade2?$AA@
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0012c	ff d6		 call	 esi

; 47   : 	this->m_iRateSuccessRateForMix3 = GetPrivateProfileInt("GameServerInfo", "MixRateForGrade3", 60, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00133	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00138	89 87 18 00 02
	00		 mov	 DWORD PTR [edi+131096], eax
  0013e	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00143	50		 push	 eax
  00144	6a 3c		 push	 60			; 0000003cH
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NEOEMLNM@MixRateForGrade3?$AA@
  0014b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00150	ff d6		 call	 esi
  00152	89 87 1c 00 02
	00		 mov	 DWORD PTR [edi+131100], eax
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi

; 48   : }

  0015a	c3		 ret	 0
?_InitOption@CItemSystemFor380@@AAEXXZ ENDP		; CItemSystemFor380::_InitOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?ChaosMix380ItemOption@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iPosOfJewelOfSuho$1$ = -56				; size = 4
_iPosOfJewelOfHarmony$1$ = -52				; size = 4
_iCharmOfLuckCount$1$ = -48				; size = 4
_pTargetItem$1$ = -44					; size = 4
_iMixPrice$2$ = -40					; size = 4
_iValidItemCount$1$ = -40				; size = 4
_this$GSCopy$1$ = -36					; size = 4
_iRate$1$ = -36						; size = 4
_iJewelOfSuho$1$ = -32					; size = 4
_iJewelOfHarmony$1$ = -28				; size = 4
_iInvalidItemCount$1$ = -24				; size = 4
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?ChaosMix380ItemOption@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CItemSystemFor380::ChaosMix380ItemOption, COMDAT
; _this$ = ecx

; 285  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b c1		 mov	 eax, ecx
  00012	56		 push	 esi
  00013	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00016	89 45 dc	 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax

; 286  : 	if ( this->m_bSystemFor380ItemOption != TRUE )

  00019	83 b8 04 00 02
	00 01		 cmp	 DWORD PTR [eax+131076], 1
  00020	74 36		 je	 SHORT $LN5@ChaosMix38

; 287  : 	{
; 288  : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13,55)), lpObj->m_Index, 1);

  00022	6a 01		 push	 1
  00024	ff 36		 push	 DWORD PTR [esi]
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0002b	68 37 0d 00 00	 push	 3383			; 00000d37H
  00030	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 289  : 		lpObj->bIsChaosMixCompleted = false;

  0003e	c6 86 09 16 00
	00 00		 mov	 BYTE PTR [esi+5641], 0

; 290  : 
; 291  : 		return FALSE;

  00045	33 c0		 xor	 eax, eax
  00047	5e		 pop	 esi

; 429  : }

  00048	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004b	33 cd		 xor	 ecx, ebp
  0004d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN5@ChaosMix38:
  00058	53		 push	 ebx

; 292  : 	}
; 293  : 
; 294  : 	lpObj->ChaosLock = TRUE;
; 295  : 
; 296  : 	int iValidItemCount = 0;

  00059	33 c0		 xor	 eax, eax
  0005b	c7 86 20 12 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4640], 1
  00065	57		 push	 edi

; 297  : 	int iJewelOfHarmony = 0;
; 298  : 	int iJewelOfSuho = 0;
; 299  : 	int iInvalidItemCount = 0;
; 300  : 	int iMixPrice = 0;
; 301  : 	int iCharmOfLuckCount = 0;
; 302  : 
; 303  : 	PMSG_CHAOSMIXRESULT pMsg;
; 304  : 
; 305  : 	PHeadSetB((LPBYTE)&pMsg, 0x86, sizeof(pMsg));

  00066	6a 10		 push	 16			; 00000010H
  00068	89 45 d8	 mov	 DWORD PTR _iValidItemCount$1$[ebp], eax
  0006b	89 45 e4	 mov	 DWORD PTR _iJewelOfHarmony$1$[ebp], eax
  0006e	89 45 e0	 mov	 DWORD PTR _iJewelOfSuho$1$[ebp], eax
  00071	89 45 e8	 mov	 DWORD PTR _iInvalidItemCount$1$[ebp], eax
  00074	89 45 d0	 mov	 DWORD PTR _iCharmOfLuckCount$1$[ebp], eax
  00077	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0007a	68 86 00 00 00	 push	 134			; 00000086H
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH

; 306  : 	pMsg.Result = 0;

  00088	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 307  : 	CItem * pTargetItem = NULL;
; 308  : 	int iPosOfJewelOfHarmony= -1;
; 309  : 	int iPosOfJewelOfSuho= -1;
; 310  : 
; 311  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  0008c	33 db		 xor	 ebx, ebx
  0008e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _pTargetItem$1$[ebp], 0
  00095	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _iPosOfJewelOfHarmony$1$[ebp], -1
  0009c	33 ff		 xor	 edi, edi
  0009e	c7 45 c8 ff ff
	ff ff		 mov	 DWORD PTR _iPosOfJewelOfSuho$1$[ebp], -1
  000a5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@ChaosMix38:

; 312  : 	{
; 313  : 	if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  000b0	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  000b6	03 cf		 add	 ecx, edi
  000b8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000bd	83 f8 01	 cmp	 eax, 1
  000c0	75 5f		 jne	 SHORT $LN32@ChaosMix38

; 314  : 	{
; 315  : 		if ( this->Is380Item(&lpObj->pChaosBox[n]) == TRUE &&
; 316  : 			this->Is380OptionItem(&lpObj->pChaosBox[n]) == FALSE &&
; 317  : 			 lpObj->pChaosBox[n].m_Level > 3 &&

  000c2	8b 86 10 12 00
	00		 mov	 eax, DWORD PTR [esi+4624]
  000c8	8b 4d dc	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000cb	03 c7		 add	 eax, edi
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380Item
  000d3	83 f8 01	 cmp	 eax, 1
  000d6	0f 85 0a 01 00
	00		 jne	 $LN7@ChaosMix38
  000dc	8b 86 10 12 00
	00		 mov	 eax, DWORD PTR [esi+4624]
  000e2	8b 4d dc	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000e5	03 c7		 add	 eax, edi
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380OptionItem
  000ed	85 c0		 test	 eax, eax
  000ef	0f 85 f1 00 00
	00		 jne	 $LN7@ChaosMix38
  000f5	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  000fb	03 cf		 add	 ecx, edi
  000fd	66 83 79 08 03	 cmp	 WORD PTR [ecx+8], 3
  00102	0f 8e de 00 00
	00		 jle	 $LN7@ChaosMix38
  00108	0f b6 81 92 00
	00 00		 movzx	 eax, BYTE PTR [ecx+146]
  0010f	c1 e0 02	 shl	 eax, 2
  00112	83 f8 03	 cmp	 eax, 3
  00115	0f 8e cb 00 00
	00		 jle	 $LN7@ChaosMix38

; 318  : 			 (lpObj->pChaosBox[n].m_Option3<<2) > 3)
; 319  : 		{
; 320  : 			iValidItemCount++;

  0011b	ff 45 d8	 inc	 DWORD PTR _iValidItemCount$1$[ebp]

; 321  : 			pTargetItem = &lpObj->pChaosBox[n];

  0011e	89 4d d4	 mov	 DWORD PTR _pTargetItem$1$[ebp], ecx
$LN32@ChaosMix38:
  00121	8b 4d e4	 mov	 ecx, DWORD PTR _iJewelOfHarmony$1$[ebp]
$LN35@ChaosMix38:
  00124	8b 55 e0	 mov	 edx, DWORD PTR _iJewelOfSuho$1$[ebp]
$LN36@ChaosMix38:
  00127	8b 45 e8	 mov	 eax, DWORD PTR _iInvalidItemCount$1$[ebp]
$LN2@ChaosMix38:

; 307  : 	CItem * pTargetItem = NULL;
; 308  : 	int iPosOfJewelOfHarmony= -1;
; 309  : 	int iPosOfJewelOfSuho= -1;
; 310  : 
; 311  : 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  0012a	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00130	43		 inc	 ebx
  00131	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  00137	0f 8c 73 ff ff
	ff		 jl	 $LL4@ChaosMix38

; 340  : 		}
; 341  : 	}
; 342  : 	}
; 343  : 
; 344  : 	if ( iInvalidItemCount ||
; 345  : 		 iValidItemCount != 1 ||
; 346  : 		 iJewelOfHarmony != 1 ||
; 347  : 		 iJewelOfSuho != 1 ||
; 348  : 		 pTargetItem == NULL ||		
; 349  : 		 iPosOfJewelOfHarmony == -1 ||
; 350  : 		 iPosOfJewelOfSuho == -1 ||

  0013d	85 c0		 test	 eax, eax
  0013f	75 73		 jne	 SHORT $LN16@ChaosMix38
  00141	83 7d d8 01	 cmp	 DWORD PTR _iValidItemCount$1$[ebp], 1
  00145	75 6d		 jne	 SHORT $LN16@ChaosMix38
  00147	83 f9 01	 cmp	 ecx, 1
  0014a	75 68		 jne	 SHORT $LN16@ChaosMix38
  0014c	3b d1		 cmp	 edx, ecx
  0014e	75 64		 jne	 SHORT $LN16@ChaosMix38
  00150	39 45 d4	 cmp	 DWORD PTR _pTargetItem$1$[ebp], eax
  00153	74 5f		 je	 SHORT $LN16@ChaosMix38
  00155	83 7d cc ff	 cmp	 DWORD PTR _iPosOfJewelOfHarmony$1$[ebp], -1
  00159	74 59		 je	 SHORT $LN16@ChaosMix38
  0015b	83 7d c8 ff	 cmp	 DWORD PTR _iPosOfJewelOfSuho$1$[ebp], -1
  0015f	74 53		 je	 SHORT $LN16@ChaosMix38
  00161	83 7d d0 0a	 cmp	 DWORD PTR _iCharmOfLuckCount$1$[ebp], 10 ; 0000000aH
  00165	7f 4d		 jg	 SHORT $LN16@ChaosMix38

; 357  : 	}
; 358  : 
; 359  : 	iMixPrice = this->m_iNeedZenFor380Option;

  00167	8b 5d dc	 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]

; 360  : 	int iChaosTaxMoney =  iMixPrice * g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index) / 100;

  0016a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0016f	ff 36		 push	 DWORD PTR [esi]
  00171	8b bb 10 00 02
	00		 mov	 edi, DWORD PTR [ebx+131088]
  00177	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  0017c	8b c8		 mov	 ecx, eax
  0017e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00183	0f af cf	 imul	 ecx, edi
  00186	f7 e9		 imul	 ecx

; 361  : 
; 362  : 	if ( iChaosTaxMoney < 0 )

  00188	b9 00 00 00 00	 mov	 ecx, 0
  0018d	c1 fa 05	 sar	 edx, 5
  00190	8b c2		 mov	 eax, edx
  00192	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00195	03 c2		 add	 eax, edx
  00197	0f 48 c1	 cmovs	 eax, ecx

; 363  : 		iChaosTaxMoney = 0;
; 364  : 
; 365  : 	iMixPrice += iChaosTaxMoney;

  0019a	03 f8		 add	 edi, eax

; 366  : 
; 367  : 	if ( iMixPrice < 0 )

  0019c	0f 48 f9	 cmovs	 edi, ecx

; 368  : 		iMixPrice = 0;
; 369  : 
; 370  : 	if ( lpObj->Money < iMixPrice )

  0019f	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  001a5	89 7d d8	 mov	 DWORD PTR _iMixPrice$2$[ebp], edi
  001a8	3b cf		 cmp	 ecx, edi
  001aa	0f 8d b4 00 00
	00		 jge	 $LN19@ChaosMix38

; 371  : 	{
; 372  : 		pMsg.Result = 2;

  001b0	c6 45 ef 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
$LN16@ChaosMix38:

; 351  : 		 iCharmOfLuckCount > 10 )
; 352  : 	{
; 353  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  001b4	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001b8	50		 push	 eax
  001b9	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001bc	50		 push	 eax
  001bd	ff 36		 push	 DWORD PTR [esi]
  001bf	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 354  : 		lpObj->ChaosLock = FALSE;
; 355  : 
; 356  : 		return FALSE;

  001c7	33 c0		 xor	 eax, eax
$LN37@ChaosMix38:

; 429  : }

  001c9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cc	5f		 pop	 edi
  001cd	5b		 pop	 ebx
  001ce	c7 86 20 12 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4640], 0
  001d8	33 cd		 xor	 ecx, ebp
  001da	5e		 pop	 esi
  001db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e0	8b e5		 mov	 esp, ebp
  001e2	5d		 pop	 ebp
  001e3	c2 04 00	 ret	 4
$LN7@ChaosMix38:

; 322  : 		}
; 323  : 		else if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyPurity(lpObj->pChaosBox[n].m_Type) == TRUE )

  001e6	8b 86 10 12 00
	00		 mov	 eax, DWORD PTR [esi+4624]
  001ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  001f1	0f b7 44 38 06	 movzx	 eax, WORD PTR [eax+edi+6]
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 ?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
  001fc	83 f8 01	 cmp	 eax, 1
  001ff	75 0f		 jne	 SHORT $LN9@ChaosMix38

; 324  : 		{
; 325  : 			iJewelOfHarmony++;

  00201	8b 4d e4	 mov	 ecx, DWORD PTR _iJewelOfHarmony$1$[ebp]
  00204	41		 inc	 ecx

; 326  : 			iPosOfJewelOfHarmony = n;

  00205	89 5d cc	 mov	 DWORD PTR _iPosOfJewelOfHarmony$1$[ebp], ebx
  00208	89 4d e4	 mov	 DWORD PTR _iJewelOfHarmony$1$[ebp], ecx
  0020b	e9 14 ff ff ff	 jmp	 $LN35@ChaosMix38
$LN9@ChaosMix38:

; 327  : 		}
; 328  : 		else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14, 31) )

  00210	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  00216	ba 1f 1c 00 00	 mov	 edx, 7199		; 00001c1fH
  0021b	0f b7 44 39 06	 movzx	 eax, WORD PTR [ecx+edi+6]
  00220	66 3b c2	 cmp	 ax, dx
  00223	75 12		 jne	 SHORT $LN11@ChaosMix38

; 329  : 		{
; 330  : 			iJewelOfSuho++;

  00225	8b 55 e0	 mov	 edx, DWORD PTR _iJewelOfSuho$1$[ebp]

; 331  : 			iPosOfJewelOfSuho = n;

  00228	8b 4d e4	 mov	 ecx, DWORD PTR _iJewelOfHarmony$1$[ebp]
  0022b	42		 inc	 edx
  0022c	89 55 e0	 mov	 DWORD PTR _iJewelOfSuho$1$[ebp], edx
  0022f	89 5d c8	 mov	 DWORD PTR _iPosOfJewelOfSuho$1$[ebp], ebx
  00232	e9 f0 fe ff ff	 jmp	 $LN36@ChaosMix38
$LN11@ChaosMix38:

; 332  : 		}
; 333  : 		else if ( lpObj->pChaosBox[n].m_Type == ITEMGET(14,53) )

  00237	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  0023c	66 3b c2	 cmp	 ax, dx

; 334  : 		{
; 335  : 			iCharmOfLuckCount += (int)lpObj->pChaosBox[n].m_Durability;
; 336  : 		}
; 337  : 		else

  0023f	8b 55 e0	 mov	 edx, DWORD PTR _iJewelOfSuho$1$[ebp]
  00242	75 11		 jne	 SHORT $LN13@ChaosMix38
  00244	f3 0f 2c 44 39
	24		 cvttss2si eax, DWORD PTR [ecx+edi+36]
  0024a	8b 4d e4	 mov	 ecx, DWORD PTR _iJewelOfHarmony$1$[ebp]
  0024d	01 45 d0	 add	 DWORD PTR _iCharmOfLuckCount$1$[ebp], eax
  00250	e9 d2 fe ff ff	 jmp	 $LN36@ChaosMix38
$LN13@ChaosMix38:

; 338  : 		{
; 339  : 			iInvalidItemCount++;

  00255	8b 45 e8	 mov	 eax, DWORD PTR _iInvalidItemCount$1$[ebp]
  00258	8b 4d e4	 mov	 ecx, DWORD PTR _iJewelOfHarmony$1$[ebp]
  0025b	40		 inc	 eax
  0025c	89 45 e8	 mov	 DWORD PTR _iInvalidItemCount$1$[ebp], eax
  0025f	e9 c6 fe ff ff	 jmp	 $LN2@ChaosMix38
$LN19@ChaosMix38:

; 373  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);
; 374  : 		lpObj->ChaosLock = FALSE;
; 375  : 
; 376  : 		return FALSE;
; 377  : 	}
; 378  : 
; 379  : 	lpObj->Money -= iMixPrice;

  00264	2b cf		 sub	 ecx, edi
  00266	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx

; 380  : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  0026c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00271	50		 push	 eax
  00272	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 381  : 	
; 382  : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  00277	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  0027d	ff 36		 push	 DWORD PTR [esi]
  0027f	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00284	83 c4 08	 add	 esp, 8

; 383  : 	g_ChaosBox.LogChaosItem(lpObj, "380Item][Item Mix");

  00287	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0028c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@IFIOIDM@380Item?$FN?$FLItem?5Mix?$AA@
  00291	56		 push	 esi
  00292	e8 00 00 00 00	 call	 ?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CChaosBox::LogChaosItem

; 384  : 	LogAddTD("[380Item][Item Mix] - Mix Start");

  00297	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@CBDBEMLE@?$FL380Item?$FN?$FLItem?5Mix?$FN?5?9?5Mix?5Start?$AA@
  0029c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002a2	83 c4 04	 add	 esp, 4

; 385  : 
; 386  : 	int iRate =	rand() % 100;

  002a5	e8 00 00 00 00	 call	 _rand
  002aa	99		 cdq
  002ab	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  002b0	f7 f9		 idiv	 ecx

; 387  : 	int iRateSuccess = this->m_iRateSuccessRateForMix1;
; 388  : 
; 389  : 	if ( pTargetItem->m_Level < 7 )

  002b2	8b 45 d4	 mov	 eax, DWORD PTR _pTargetItem$1$[ebp]
  002b5	8b bb 14 00 02
	00		 mov	 edi, DWORD PTR [ebx+131092]
  002bb	89 55 dc	 mov	 DWORD PTR _iRate$1$[ebp], edx
  002be	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  002c2	66 83 f8 07	 cmp	 ax, 7
  002c6	7c 1a		 jl	 SHORT $LN24@ChaosMix38

; 390  : 		iRateSuccess = this->m_iRateSuccessRateForMix1;
; 391  : 	else if ( pTargetItem->m_Level < 10 )

  002c8	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  002cc	7d 08		 jge	 SHORT $LN22@ChaosMix38

; 392  : 		iRateSuccess = this->m_iRateSuccessRateForMix2;

  002ce	8b bb 18 00 02
	00		 mov	 edi, DWORD PTR [ebx+131096]
  002d4	eb 0c		 jmp	 SHORT $LN24@ChaosMix38
$LN22@ChaosMix38:

; 393  : 	else if ( pTargetItem->m_Level < 14 )

  002d6	66 83 f8 0e	 cmp	 ax, 14			; 0000000eH
  002da	7d 06		 jge	 SHORT $LN24@ChaosMix38

; 394  : 		iRateSuccess = this->m_iRateSuccessRateForMix3;

  002dc	8b bb 1c 00 02
	00		 mov	 edi, DWORD PTR [ebx+131100]
$LN24@ChaosMix38:

; 395  : 
; 396  : 	iRateSuccess += iCharmOfLuckCount;
; 397  : 
; 398  : 	lpObj->pChaosBox[iPosOfJewelOfHarmony].Clear();

  002e2	69 4d cc d4 00
	00 00		 imul	 ecx, DWORD PTR _iPosOfJewelOfHarmony$1$[ebp], 212
  002e9	03 7d d0	 add	 edi, DWORD PTR _iCharmOfLuckCount$1$[ebp]
  002ec	03 8e 10 12 00
	00		 add	 ecx, DWORD PTR [esi+4624]
  002f2	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 399  : 	lpObj->pChaosBoxMap[iPosOfJewelOfHarmony] = -1;

  002f7	8b 86 14 12 00
	00		 mov	 eax, DWORD PTR [esi+4628]
  002fd	8b 4d cc	 mov	 ecx, DWORD PTR _iPosOfJewelOfHarmony$1$[ebp]
  00300	c6 04 01 ff	 mov	 BYTE PTR [ecx+eax], 255	; 000000ffH

; 400  : 	lpObj->pChaosBox[iPosOfJewelOfSuho].Clear();

  00304	69 4d c8 d4 00
	00 00		 imul	 ecx, DWORD PTR _iPosOfJewelOfSuho$1$[ebp], 212
  0030b	03 8e 10 12 00
	00		 add	 ecx, DWORD PTR [esi+4624]
  00311	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 401  : 	lpObj->pChaosBoxMap[iPosOfJewelOfSuho] = -1;

  00316	8b 86 14 12 00
	00		 mov	 eax, DWORD PTR [esi+4628]
  0031c	8b 4d c8	 mov	 ecx, DWORD PTR _iPosOfJewelOfSuho$1$[ebp]
  0031f	c6 04 01 ff	 mov	 BYTE PTR [ecx+eax], 255	; 000000ffH

; 402  : 
; 403  : 	if ( iRate < iRateSuccess )

  00323	39 7d dc	 cmp	 DWORD PTR _iRate$1$[ebp], edi
  00326	7d 62		 jge	 SHORT $LN25@ChaosMix38

; 404  : 	{
; 405  : 		this->_SetOption(pTargetItem, TRUE);

  00328	6a 01		 push	 1
  0032a	ff 75 d4	 push	 DWORD PTR _pTargetItem$1$[ebp]
  0032d	8b cb		 mov	 ecx, ebx
  0032f	e8 00 00 00 00	 call	 ?_SetOption@CItemSystemFor380@@AAEHPAVCItem@@H@Z ; CItemSystemFor380::_SetOption

; 406  : 		GCUserChaosBoxSend(lpObj, 0);

  00334	6a 00		 push	 0
  00336	56		 push	 esi
  00337	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 407  : 
; 408  : 		LogAddTD("[380Item][ItemMix] Mix Success [%s][%s], Money(%d-%d) Rate(%d/%d) Option(%d,%d) OptionValue(%d,%d)",

  0033c	8b 45 d4	 mov	 eax, DWORD PTR _pTargetItem$1$[ebp]
  0033f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00343	03 c9		 add	 ecx, ecx
  00345	0f b7 44 cb 10	 movzx	 eax, WORD PTR [ebx+ecx*8+16]
  0034a	50		 push	 eax
  0034b	0f b7 44 cb 0c	 movzx	 eax, WORD PTR [ebx+ecx*8+12]
  00350	50		 push	 eax
  00351	0f b6 44 cb 0e	 movzx	 eax, BYTE PTR [ebx+ecx*8+14]
  00356	50		 push	 eax
  00357	0f b6 44 cb 0a	 movzx	 eax, BYTE PTR [ebx+ecx*8+10]
  0035c	50		 push	 eax
  0035d	57		 push	 edi
  0035e	ff 75 dc	 push	 DWORD PTR _iRate$1$[ebp]
  00361	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00364	ff 75 d8	 push	 DWORD PTR _iMixPrice$2$[ebp]
  00367	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  0036d	50		 push	 eax
  0036e	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00371	50		 push	 eax
  00372	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@FNEHGIAM@?$FL380Item?$FN?$FLItemMix?$FN?5Mix?5Success?5?$FL@
  00377	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0037d	83 c4 34	 add	 esp, 52			; 00000034H

; 422  : 			lpObj->AccountID, lpObj->Name, lpObj->Money,
; 423  : 			iMixPrice, iRate, iRateSuccess);
; 424  : 
; 425  : 	}
; 426  : 
; 427  : 	lpObj->ChaosLock = FALSE;
; 428  : 	return TRUE;

  00380	b8 01 00 00 00	 mov	 eax, 1
  00385	e9 3f fe ff ff	 jmp	 $LN37@ChaosMix38
$LN25@ChaosMix38:

; 409  : 			lpObj->AccountID, lpObj->Name, lpObj->Money,
; 410  : 			iMixPrice, iRate, iRateSuccess,
; 411  : 			this->m_itemOption[(pTargetItem->m_Type )].m_Option1,
; 412  : 			this->m_itemOption[(pTargetItem->m_Type )].m_Option2,
; 413  : 			this->m_itemOption[(pTargetItem->m_Type )].m_Value1,
; 414  : 			this->m_itemOption[(pTargetItem->m_Type )].m_Value2);
; 415  : 	}
; 416  : 	else
; 417  : 	{
; 418  : 		GCUserChaosBoxSend(lpObj, 0);

  0038a	6a 00		 push	 0
  0038c	56		 push	 esi
  0038d	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 419  : 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00392	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00396	50		 push	 eax
  00397	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0039a	50		 push	 eax
  0039b	ff 36		 push	 DWORD PTR [esi]
  0039d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 420  : 
; 421  : 		LogAddTD("[380Item][ItemMix] Mix Fail [%s][%s], Money(%d-%d) Rate(%d/%d)",

  003a2	57		 push	 edi
  003a3	ff 75 dc	 push	 DWORD PTR _iRate$1$[ebp]
  003a6	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  003a9	ff 75 d8	 push	 DWORD PTR _iMixPrice$2$[ebp]
  003ac	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  003b2	50		 push	 eax
  003b3	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  003b6	50		 push	 eax
  003b7	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@LHPKHLIF@?$FL380Item?$FN?$FLItemMix?$FN?5Mix?5Fail?5?$FL?$CFs?$FN@
  003bc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003c2	83 c4 30	 add	 esp, 48			; 00000030H

; 422  : 			lpObj->AccountID, lpObj->Name, lpObj->Money,
; 423  : 			iMixPrice, iRate, iRateSuccess);
; 424  : 
; 425  : 	}
; 426  : 
; 427  : 	lpObj->ChaosLock = FALSE;
; 428  : 	return TRUE;

  003c5	b8 01 00 00 00	 mov	 eax, 1
  003ca	e9 fa fd ff ff	 jmp	 $LN37@ChaosMix38
?ChaosMix380ItemOption@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CItemSystemFor380::ChaosMix380ItemOption
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?SetOptionItemByMacro@CItemSystemFor380@@QAEXPAUOBJECTSTRUCT@@EH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_invenrotyTargetPos$ = 12				; size = 1
_bOption$ = 16						; size = 4
?SetOptionItemByMacro@CItemSystemFor380@@QAEXPAUOBJECTSTRUCT@@EH@Z PROC ; CItemSystemFor380::SetOptionItemByMacro, COMDAT
; _this$ = ecx

; 279  : 	// HERE GOES A MACRO
; 280  : 	return;
; 281  : 	CItem * pItem=NULL;
; 282  : }

  00000	c2 0c 00	 ret	 12			; 0000000cH
?SetOptionItemByMacro@CItemSystemFor380@@QAEXPAUOBJECTSTRUCT@@EH@Z ENDP ; CItemSystemFor380::SetOptionItemByMacro
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?ApplyFor380Option@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_pItemEffect$1$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?ApplyFor380Option@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CItemSystemFor380::ApplyFor380Option, COMDAT
; _this$ = ecx

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 169  : 	ITEMOPTION_FOR380ITEM_EFFECT * pItemEffect = &lpObj->m_ItemOptionExFor380;

  00008	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	57		 push	 edi
  0000e	89 5d f8	 mov	 DWORD PTR _this$1$[ebp], ebx
  00011	8d 86 52 24 00
	00		 lea	 eax, DWORD PTR [esi+9298]

; 170  : 	this->InitEffectValue(pItemEffect);

  00017	50		 push	 eax
  00018	89 45 fc	 mov	 DWORD PTR _pItemEffect$1$[ebp], eax
  0001b	e8 00 00 00 00	 call	 ?InitEffectValue@CItemSystemFor380@@QAEXPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z ; CItemSystemFor380::InitEffectValue
  00020	33 ff		 xor	 edi, edi
$LL4@ApplyFor38:

; 174  : 	{
; 175  : 		CItem * pItem = &lpObj->pInventory[iItemIndex];

  00022	8b b6 c0 11 00
	00		 mov	 esi, DWORD PTR [esi+4544]
  00028	03 f7		 add	 esi, edi

; 176  : 
; 177  : 		if ( pItem->IsItem() &&
; 178  : 			 pItem->m_IsValidItem &&

  0002a	8b ce		 mov	 ecx, esi
  0002c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00031	85 c0		 test	 eax, eax
  00033	74 4d		 je	 SHORT $LN2@ApplyFor38
  00035	80 be ac 00 00
	00 00		 cmp	 BYTE PTR [esi+172], 0
  0003c	74 44		 je	 SHORT $LN2@ApplyFor38
  0003e	56		 push	 esi
  0003f	8b cb		 mov	 ecx, ebx
  00041	e8 00 00 00 00	 call	 ?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380OptionItem
  00046	83 f8 01	 cmp	 eax, 1
  00049	75 37		 jne	 SHORT $LN2@ApplyFor38

; 179  : 			 this->Is380OptionItem(pItem) == TRUE )
; 180  : 		{
; 181  : 			BYTE iOption1, iOption2;
; 182  : 			WORD iValue1, iValue2;
; 183  : 
; 184  : 			iOption1 = this->m_itemOption[pItem->m_Type ].m_Option1;
; 185  : 			iValue1 = this->m_itemOption[pItem->m_Type ].m_Value1;
; 186  : 			iOption2 = this->m_itemOption[pItem->m_Type ].m_Option2;

  0004b	0f bf 4e 06	 movsx	 ecx, WORD PTR [esi+6]

; 187  : 			iValue2 = this->m_itemOption[pItem->m_Type ].m_Value2;
; 188  : 			BOOL bResult = FALSE;
; 189  : 			bResult = this->_CalcItemEffectValue(iOption1, iValue1, pItemEffect);

  0004f	ff 75 fc	 push	 DWORD PTR _pItemEffect$1$[ebp]
  00052	c1 e1 04	 shl	 ecx, 4
  00055	03 cb		 add	 ecx, ebx
  00057	0f b7 41 0c	 movzx	 eax, WORD PTR [ecx+12]
  0005b	8a 59 0e	 mov	 bl, BYTE PTR [ecx+14]
  0005e	0f b7 71 10	 movzx	 esi, WORD PTR [ecx+16]
  00062	50		 push	 eax
  00063	0f b6 41 0a	 movzx	 eax, BYTE PTR [ecx+10]
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?_CalcItemEffectValue@CItemSystemFor380@@AAEHHHPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z ; CItemSystemFor380::_CalcItemEffectValue

; 190  : 			bResult |= this->_CalcItemEffectValue(iOption2, iValue2, pItemEffect);

  00070	ff 75 fc	 push	 DWORD PTR _pItemEffect$1$[ebp]
  00073	0f b6 c3	 movzx	 eax, bl
  00076	8b 5d f8	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00079	8b cb		 mov	 ecx, ebx
  0007b	56		 push	 esi
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ?_CalcItemEffectValue@CItemSystemFor380@@AAEHHHPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z ; CItemSystemFor380::_CalcItemEffectValue
$LN2@ApplyFor38:

; 171  : 	int iItemIndex = 0;
; 172  : 
; 173  : 	for ( iItemIndex = 0; iItemIndex < INVETORY_WEAR_SIZE ; iItemIndex++)

  00082	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00085	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  0008b	81 ff f0 09 00
	00		 cmp	 edi, 2544		; 000009f0H
  00091	7c 8f		 jl	 SHORT $LL4@ApplyFor38

; 191  : 		}
; 192  : 	}
; 193  : 
; 194  : 	lpObj->AddLife += pItemEffect->OpAddMaxHP;

  00093	8b 55 fc	 mov	 edx, DWORD PTR _pItemEffect$1$[ebp]
  00096	8b ce		 mov	 ecx, esi
  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  0009f	01 81 24 01 00
	00		 add	 DWORD PTR [ecx+292], eax

; 195  : 	lpObj->iAddShield += pItemEffect->OpAddMaxSD;

  000a5	0f bf 42 0a	 movsx	 eax, WORD PTR [edx+10]
  000a9	01 81 34 01 00
	00		 add	 DWORD PTR [ecx+308], eax

; 196  : 
; 197  : 	return TRUE;

  000af	b8 01 00 00 00	 mov	 eax, 1

; 198  : }

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 04 00	 ret	 4
?ApplyFor380Option@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CItemSystemFor380::ApplyFor380Option
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?InitEffectValue@CItemSystemFor380@@QAEXPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z
_TEXT	SEGMENT
_pItemEffect$ = 8					; size = 4
?InitEffectValue@CItemSystemFor380@@QAEXPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z PROC ; CItemSystemFor380::InitEffectValue, COMDAT
; _this$ = ecx

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 155  : 	pItemEffect->OpAddAttackSuccessRatePVP = 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pItemEffect$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 156  : 	pItemEffect->OpAddDamage = 0;
; 157  : 	pItemEffect->OpAddDefenseSuccessRatePvP = 0;

  0000a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 158  : 	pItemEffect->OpAddDefense = 0;
; 159  : 	pItemEffect->OpAddMaxHP = 0;

  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 160  : 	pItemEffect->OpAddMaxSD = 0;
; 161  : 	pItemEffect->OpRefillOn  = 0;

  00010	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 162  : 	pItemEffect->OpAddRefillSD = 0;
; 163  : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?InitEffectValue@CItemSystemFor380@@QAEXPAUITEMOPTION_FOR380ITEM_EFFECT@@@Z ENDP ; CItemSystemFor380::InitEffectValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z PROC ; CItemSystemFor380::Is380OptionItem, COMDAT
; _this$ = ecx

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 141  : 	if ( this->Is380Item(pItem) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pItem$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380Item
  0000d	85 c0		 test	 eax, eax
  0000f	75 05		 jne	 SHORT $LN2@Is380Optio
  00011	5e		 pop	 esi

; 147  : 		return FALSE;
; 148  : 
; 149  : 	return TRUE;
; 150  : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@Is380Optio:

; 142  : 		return FALSE;
; 143  : 
; 144  : 	BYTE bResult = (pItem->m_ItemOptionEx & 0x80) >> 7;
; 145  : 
; 146  : 	if ( bResult != 1 )

  00016	0f b6 86 c6 00
	00 00		 movzx	 eax, BYTE PTR [esi+198]
  0001d	c1 e8 07	 shr	 eax, 7
  00020	5e		 pop	 esi

; 147  : 		return FALSE;
; 148  : 
; 149  : 	return TRUE;
; 150  : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z ENDP ; CItemSystemFor380::Is380OptionItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z PROC	; CItemSystemFor380::Is380Item, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 126  : 	if ( pItem->m_Type < 0 || pItem->m_Type > MAX_ITEMS-1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00006	8b d1		 mov	 edx, ecx
  00008	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]
  0000c	66 85 c0	 test	 ax, ax
  0000f	78 1c		 js	 SHORT $LN3@Is380Item
  00011	b9 ff 1f 00 00	 mov	 ecx, 8191		; 00001fffH
  00016	66 3b c1	 cmp	 ax, cx
  00019	7f 12		 jg	 SHORT $LN3@Is380Item

; 130  : 	}
; 131  : 
; 132  : 	if ( this->m_itemOption[pItem->m_Type ].IsLoad == FALSE )

  0001b	0f bf c8	 movsx	 ecx, ax
  0001e	33 c0		 xor	 eax, eax
  00020	03 c9		 add	 ecx, ecx
  00022	39 44 ca 04	 cmp	 DWORD PTR [edx+ecx*8+4], eax
  00026	0f 95 c0	 setne	 al

; 133  : 		return FALSE;
; 134  : 
; 135  : 	return TRUE;
; 136  : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN3@Is380Item:

; 127  : 	{
; 128  : 		LogAdd("[380Item] OptionItem Check error: (iItemNum:%d)", pItem->m_Type);

  0002d	98		 cwde
  0002e	50		 push	 eax
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@DNNIILED@?$FL380Item?$FN?5OptionItem?5Check?5error@
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003a	83 c4 08	 add	 esp, 8

; 129  : 		return FALSE;

  0003d	33 c0		 xor	 eax, eax

; 133  : 		return FALSE;
; 134  : 
; 135  : 	return TRUE;
; 136  : }

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z ENDP	; CItemSystemFor380::Is380Item
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?Load380ItemOptionInfo@CItemSystemFor380@@QAEHPAD@Z
_TEXT	SEGMENT
_Index$1$ = 8						; size = 4
_filename$ = 8						; size = 4
?Load380ItemOptionInfo@CItemSystemFor380@@QAEHPAD@Z PROC ; CItemSystemFor380::Load380ItemOptionInfo, COMDAT
; _this$ = ecx

; 54   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 55   : 	enum SMDToken Token;
; 56   : 	SMDFile = fopen(filename, "r");

  00004	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00009	ff 75 08	 push	 DWORD PTR _filename$[ebp]
  0000c	8b f9		 mov	 edi, ecx
  0000e	e8 00 00 00 00	 call	 _fopen
  00013	83 c4 08	 add	 esp, 8
  00016	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax

; 57   : 
; 58   : 	if ( SMDFile == NULL )

  0001b	85 c0		 test	 eax, eax
  0001d	75 05		 jne	 SHORT $LN6@Load380Ite
  0001f	5f		 pop	 edi

; 117  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN6@Load380Ite:

; 59   : 		return FALSE;
; 60   : 
; 61   : 	this->_InitOption();

  00024	8b cf		 mov	 ecx, edi
  00026	e8 00 00 00 00	 call	 ?_InitOption@CItemSystemFor380@@AAEXXZ ; CItemSystemFor380::_InitOption

; 62   : 
; 63   : 
; 64   : 	while ( true )
; 65   : 	{
; 66   : 		Token = (SMDToken)GetToken();

  0002b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 67   : 
; 68   : 		if ( Token == END )

  00030	83 f8 02	 cmp	 eax, 2
  00033	74 0f		 je	 SHORT $LN16@Load380Ite
$LL2@Load380Ite:

; 69   : 			break;
; 70   : 
; 71   : 		if ( Token == NUMBER )

  00035	83 f8 01	 cmp	 eax, 1
  00038	74 22		 je	 SHORT $LN17@Load380Ite

; 67   : 
; 68   : 		if ( Token == END )

  0003a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0003f	83 f8 02	 cmp	 eax, 2
  00042	75 f1		 jne	 SHORT $LL2@Load380Ite
$LN16@Load380Ite:

; 113  : 		}
; 114  : 	}
; 115  : 	fclose(SMDFile);

  00044	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0004a	e8 00 00 00 00	 call	 _fclose
  0004f	83 c4 04	 add	 esp, 4

; 116  : 	return TRUE;

  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	5f		 pop	 edi

; 117  : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN17@Load380Ite:

; 72   : 		{
; 73   : 			int Index = (int)TokenNumber;

  0005c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00064	53		 push	 ebx
  00065	56		 push	 esi
  00066	89 45 08	 mov	 DWORD PTR _Index$1$[ebp], eax
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@Load380Ite:

; 74   : 
; 75   : 			while ( true )
; 76   : 			{
; 77   : 				if ( Index == 0 )

  00070	85 c0		 test	 eax, eax
  00072	75 fc		 jne	 SHORT $LL4@Load380Ite

; 78   : 				{
; 79   : 					Token = (SMDToken)GetToken();

  00074	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 80   : 					int _type = (int)TokenNumber;

  00079	f3 0f 2c 1d 00
	00 00 00	 cvttss2si ebx, DWORD PTR ?TokenNumber@@3MA

; 81   : 
; 82   : 					if ( Token == NAME )

  00081	85 c0		 test	 eax, eax
  00083	75 34		 jne	 SHORT $LN11@Load380Ite

; 83   : 					{
; 84   : 						if ( !strcmp("end", TokenString))

  00085	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  0008a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0008f	90		 npad	 1
$LL23@Load380Ite:
  00090	8a 10		 mov	 dl, BYTE PTR [eax]
  00092	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00094	75 1a		 jne	 SHORT $LN24@Load380Ite
  00096	84 d2		 test	 dl, dl
  00098	74 12		 je	 SHORT $LN25@Load380Ite
  0009a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0009d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000a0	75 0e		 jne	 SHORT $LN24@Load380Ite
  000a2	83 c0 02	 add	 eax, 2
  000a5	83 c1 02	 add	 ecx, 2
  000a8	84 d2		 test	 dl, dl
  000aa	75 e4		 jne	 SHORT $LL23@Load380Ite
$LN25@Load380Ite:
  000ac	33 c0		 xor	 eax, eax
  000ae	eb 05		 jmp	 SHORT $LN26@Load380Ite
$LN24@Load380Ite:
  000b0	1b c0		 sbb	 eax, eax
  000b2	83 c8 01	 or	 eax, 1
$LN26@Load380Ite:
  000b5	85 c0		 test	 eax, eax
  000b7	74 79		 je	 SHORT $LN18@Load380Ite
$LN11@Load380Ite:

; 85   : 						{
; 86   : 							return TRUE;
; 87   : 						}
; 88   : 					}
; 89   : 
; 90   : 					Token = (SMDToken)GetToken();

  000b9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 91   : 					int _index = (int)TokenNumber;

  000be	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA

; 92   : 
; 93   : 					ITEMOPTION_FOR380ITEM * p = &this->m_itemOption[ITEMGET(_type, _index)];

  000c6	8b f3		 mov	 esi, ebx
  000c8	c1 e6 09	 shl	 esi, 9
  000cb	03 f0		 add	 esi, eax
  000cd	03 f6		 add	 esi, esi

; 94   : 					p->IsLoad = TRUE;

  000cf	c7 44 f7 04 01
	00 00 00	 mov	 DWORD PTR [edi+esi*8+4], 1

; 95   : 					p->m_Type = _type;

  000d7	88 5c f7 08	 mov	 BYTE PTR [edi+esi*8+8], bl

; 96   : 					p->m_Index = _index;

  000db	88 44 f7 09	 mov	 BYTE PTR [edi+esi*8+9], al

; 97   : 
; 98   : 					Token = (SMDToken)GetToken();

  000df	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 99   : 					p->m_Option1 = (BYTE)TokenNumber;

  000e4	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000ec	88 44 f7 0a	 mov	 BYTE PTR [edi+esi*8+10], al

; 100  : 
; 101  : 					Token = (SMDToken)GetToken();

  000f0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 102  : 					p->m_Value1 = (WORD)TokenNumber;

  000f5	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000fd	66 89 44 f7 0c	 mov	 WORD PTR [edi+esi*8+12], ax

; 103  : 
; 104  : 					Token = (SMDToken)GetToken();

  00102	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 105  : 					p->m_Option2 = (BYTE)TokenNumber;

  00107	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0010f	88 44 f7 0e	 mov	 BYTE PTR [edi+esi*8+14], al

; 106  : 
; 107  : 					Token = (SMDToken)GetToken();

  00113	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 108  : 					p->m_Value2 = (WORD)TokenNumber;

  00118	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00120	66 89 44 f7 10	 mov	 WORD PTR [edi+esi*8+16], ax

; 109  : 
; 110  : 					Token = (SMDToken)GetToken();

  00125	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 111  : 				}
; 112  : 			}

  0012a	8b 45 08	 mov	 eax, DWORD PTR _Index$1$[ebp]
  0012d	e9 3e ff ff ff	 jmp	 $LL4@Load380Ite
$LN18@Load380Ite:
  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx

; 116  : 	return TRUE;

  00134	b8 01 00 00 00	 mov	 eax, 1
  00139	5f		 pop	 edi

; 117  : }

  0013a	5d		 pop	 ebp
  0013b	c2 04 00	 ret	 4
?Load380ItemOptionInfo@CItemSystemFor380@@QAEHPAD@Z ENDP ; CItemSystemFor380::Load380ItemOptionInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ??1CItemSystemFor380@@UAE@XZ
_TEXT	SEGMENT
??1CItemSystemFor380@@UAE@XZ PROC			; CItemSystemFor380::~CItemSystemFor380, COMDAT
; _this$ = ecx

; 25   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CItemSystemFor380@@6B@

; 26   : 	return;
; 27   : }

  00006	c3		 ret	 0
??1CItemSystemFor380@@UAE@XZ ENDP			; CItemSystemFor380::~CItemSystemFor380
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ??0CItemSystemFor380@@QAE@XZ
_TEXT	SEGMENT
??0CItemSystemFor380@@QAE@XZ PROC			; CItemSystemFor380::CItemSystemFor380, COMDAT
; _this$ = ecx

; 20   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 21   : 	memset(this->m_itemOption, 0, sizeof(this->m_itemOption));

  00003	68 00 00 02 00	 push	 131072			; 00020000H
  00008	6a 00		 push	 0
  0000a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CItemSystemFor380@@6B@
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _memset
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22   : }

  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c3		 ret	 0
??0CItemSystemFor380@@QAE@XZ ENDP			; CItemSystemFor380::CItemSystemFor380
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1473 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 10	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000b	6a ff		 push	 -1
  0000d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00010	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	83 c9 01	 or	 ecx, 1
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1474 :     #pragma warning(push)
; 1475 :     #pragma warning(disable: 4996) // Deprecation
; 1476 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);
; 1477 :     #pragma warning(pop)
; 1478 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\itemsystemfor380.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
