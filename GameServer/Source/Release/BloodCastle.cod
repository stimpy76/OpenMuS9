; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\BloodCastle.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_iBC_ChoasMixSuccessRate@@3PAHA		; g_iBC_ChoasMixSuccessRate
PUBLIC	?g_iBC_ChoasMixMoney@@3PAHA			; g_iBC_ChoasMixMoney
CONST	SEGMENT
?g_iBC_EventScore@@3QBUST_BC_EVENT_SCORE@@B DD 0258H	; g_iBC_EventScore
	DD	012cH
	DD	03e8H
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03e8H
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	DD	0258H
	DD	012cH
	DD	03edH
	DD	0320H
	DD	0190H
	ORG $+20
?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B DD 04e20H		; g_iBC_Add_Exp
	DD	04e20H
	DD	01388H
	DD	0a0H
	DD	0c350H
	DD	0c350H
	DD	02710H
	DD	0b4H
	DD	013880H
	DD	013880H
	DD	03a98H
	DD	0c8H
	DD	015f90H
	DD	015f90H
	DD	04e20H
	DD	0dcH
	DD	0186a0H
	DD	0186a0H
	DD	061a8H
	DD	0f0H
	DD	01adb0H
	DD	01adb0H
	DD	07530H
	DD	0104H
	DD	01d4c0H
	DD	01d4c0H
	DD	088b8H
	DD	0118H
	ORG $+16
?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B DB 0dH	; g_btCastleEntranceMapXY
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
	DB	0dH
	DB	0fH
	DB	0fH
	DB	017H
?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B DB 0dH	; g_btCastleBridgeMapXY
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
	DB	0dH
	DB	046H
	DB	0fH
	DB	04bH
?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A DB 0dH	; g_btCastleDoorMapXY
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
	DB	0dH
	DB	04cH
	DB	0fH
	DB	04fH
	DB	0bH
	DB	050H
	DB	019H
	DB	059H
	DB	08H
	DB	050H
	DB	0aH
	DB	053H
?g_iQuestWinExpendZEN@@3QBUST_REWARD_ZEN@@B DD 04e20H	; g_iQuestWinExpendZEN
	DD	02710H
	DD	0c350H
	DD	061a8H
	DD	0186a0H
	DD	0c350H
	DD	0249f0H
	DD	013880H
	DD	030d40H
	DD	0186a0H
	DD	03d090H
	DD	01d4c0H
	DD	03d090H
	DD	01d4c0H
	DD	03d090H
	DD	01d4c0H
CONST	ENDS
_DATA	SEGMENT
?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A DD 0fH ; g_sttBLOODCASTLE_LEVEL
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
?g_iBC_ChoasMixSuccessRate@@3PAHA DD 050H		; g_iBC_ChoasMixSuccessRate
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
	DD	050H
?g_iBC_ChoasMixMoney@@3PAHA DD 0c350H			; g_iBC_ChoasMixMoney
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	0927c0H
	DD	0cf850H
	DD	0f4240H
_DATA	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	??0OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::OBJECTSTRUCT
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	??0CObjectStruct@@QAE@XZ			; CObjectStruct::CObjectStruct
PUBLIC	??1CObjectStruct@@UAE@XZ			; CObjectStruct::~CObjectStruct
PUBLIC	??_GCObjectStruct@@UAEPAXI@Z			; CObjectStruct::`scalar deleting destructor'
PUBLIC	?CheckChoasMixItem@CBloodCastle@@QAEHH@Z	; CBloodCastle::CheckChoasMixItem
PUBLIC	?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::BloodCastleChaosMix
PUBLIC	?AddExperience@CBloodCastle@@QAE_NHH@Z		; CBloodCastle::AddExperience
PUBLIC	?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z	; CBloodCastle::CalcSendRewardEXP
PUBLIC	?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z	; CBloodCastle::CalcSendRewardZEN
PUBLIC	?DropReward@CBloodCastle@@QAEXH@Z		; CBloodCastle::DropReward
PUBLIC	?SendRewardScore@CBloodCastle@@QAEXHHHH@Z	; CBloodCastle::SendRewardScore
PUBLIC	?GiveReward_Win@CBloodCastle@@QAEXHH@Z		; CBloodCastle::GiveReward_Win
PUBLIC	?GiveReward_Fail@CBloodCastle@@QAEXH@Z		; CBloodCastle::GiveReward_Fail
PUBLIC	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
PUBLIC	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z	; CBloodCastle::SearchUserDropQuestItem
PUBLIC	?SetUserState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SetUserState
PUBLIC	?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleEntranceBlockInfo
PUBLIC	?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleBridgeBlockInfo
PUBLIC	?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleDoorBlockInfo
PUBLIC	?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z	; CBloodCastle::SendAllUserAnyMsg
PUBLIC	?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z	; CBloodCastle::SendBridgeAnyMsg
PUBLIC	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z	; CBloodCastle::SendNoticeMessage
PUBLIC	?SendNoticeScore@CBloodCastle@@QAEXH@Z		; CBloodCastle::SendNoticeScore
PUBLIC	?SendNoticeState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SendNoticeState
PUBLIC	?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::CheckUserBridgeMember
PUBLIC	?BlockCastleEntrance@CBloodCastle@@QAEXH@Z	; CBloodCastle::BlockCastleEntrance
PUBLIC	?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleEntrance
PUBLIC	?BlockCastleBridge@CBloodCastle@@QAEXH@Z	; CBloodCastle::BlockCastleBridge
PUBLIC	?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleBridge
PUBLIC	?BlockCastleDoor@CBloodCastle@@QAEXH@Z		; CBloodCastle::BlockCastleDoor
PUBLIC	?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z	; CBloodCastle::ReleaseCastleDoor
PUBLIC	?SetMonsterKillCount@CBloodCastle@@QAEXH@Z	; CBloodCastle::SetMonsterKillCount
PUBLIC	?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckMonsterKillCount
PUBLIC	?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckMonsterKillSuccess
PUBLIC	?CheckBossKillCount@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckBossKillCount
PUBLIC	?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckBossKillSuccess
PUBLIC	?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckEveryUserDie
PUBLIC	?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckAngelKingExist
PUBLIC	?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetWhoGotUltimateWeapon
PUBLIC	?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCurrentLiveUserCount
PUBLIC	?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z	; CBloodCastle::DropItemDirectly
PUBLIC	?ClearMonster@CBloodCastle@@QAEXH_N@Z		; CBloodCastle::ClearMonster
PUBLIC	?SetMonster@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetMonster
PUBLIC	?SetBossMonster@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetBossMonster
PUBLIC	?SetSaintStatue@CBloodCastle@@QAEXH@Z		; CBloodCastle::SetSaintStatue
PUBLIC	?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z	; CBloodCastle::LeaveUserBridge
PUBLIC	?EnterUserBridge@CBloodCastle@@QAEHHH@Z		; CBloodCastle::EnterUserBridge
PUBLIC	?LevelUp@CBloodCastle@@QAEHHHH@Z		; CBloodCastle::LevelUp
PUBLIC	?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z	; CBloodCastle::CheckUsersOnConnect
PUBLIC	?GetCurrentState@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetCurrentState
PUBLIC	?GetRemainTime@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetRemainTime
PUBLIC	?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCurrentRemainSec
PUBLIC	?CheckEnterLevel@CBloodCastle@@QAEHHH@Z		; CBloodCastle::CheckEnterLevel
PUBLIC	?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckEnterFreeTicket
PUBLIC	?CheckEnterItem@CBloodCastle@@QAEHH@Z		; CBloodCastle::CheckEnterItem
PUBLIC	?CheckQuestItem@CBloodCastle@@QAEHH@Z		; CBloodCastle::CheckQuestItem
PUBLIC	?CheckWalk@CBloodCastle@@QAE_NHHH@Z		; CBloodCastle::CheckWalk
PUBLIC	?CheckCanEnter@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckCanEnter
PUBLIC	?CheckCanParty@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckCanParty
PUBLIC	?CheckPlayStart@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckPlayStart
PUBLIC	?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ; CBloodCastle::CheckQuestItemSerial
PUBLIC	?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckUserHaveUlimateWeapon
PUBLIC	?CheckWinnerExist@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckWinnerExist
PUBLIC	?CheckWinnerValid@CBloodCastle@@QAE_NH@Z	; CBloodCastle::CheckWinnerValid
PUBLIC	?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::CheckUserWinnerParty
PUBLIC	?CheckPartyExist@CBloodCastle@@QAE_NH@Z		; CBloodCastle::CheckPartyExist
PUBLIC	?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerPartyComplete
PUBLIC	?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z	; CBloodCastle::SetBridgeWinner
PUBLIC	?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount
PUBLIC	?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompletePoint
PUBLIC	?ChangeMonsterState@CBloodCastle@@QAEXHH@Z	; CBloodCastle::ChangeMonsterState
PUBLIC	?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z	; CBloodCastle::FixUsersPlayStateWin
PUBLIC	?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z	; CBloodCastle::FixUsersPlayStateFail
PUBLIC	?Run@CBloodCastle@@QAEXXZ			; CBloodCastle::Run
PUBLIC	?Init@CBloodCastle@@QAEX_N@Z			; CBloodCastle::Init
PUBLIC	?Load@CBloodCastle@@QAEXPAD@Z			; CBloodCastle::Load
PUBLIC	?LoadItemDropRate@CBloodCastle@@QAEXXZ		; CBloodCastle::LoadItemDropRate
PUBLIC	?SetState@CBloodCastle@@QAEXHH@Z		; CBloodCastle::SetState
PUBLIC	?GetEventMap@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetEventMap
PUBLIC	?GetBridgeLevel@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetBridgeLevel
PUBLIC	?GetItemMap@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetItemMap
PUBLIC	?GetRewardMap@CBloodCastle@@QAEHH@Z		; CBloodCastle::GetRewardMap
PUBLIC	?ChangeUserIndex@CBloodCastle@@QAEHHHH@Z	; CBloodCastle::ChangeUserIndex
PUBLIC	?SendNoticeMessageToSpecificUser@CBloodCastle@@QAEXHHH@Z ; CBloodCastle::SendNoticeMessageToSpecificUser
PUBLIC	?SetCastleBlockInfo@CBloodCastle@@QAEHHH@Z	; CBloodCastle::SetCastleBlockInfo
PUBLIC	?GetCastleBlockInfo@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetCastleBlockInfo
PUBLIC	?GetPlayUserCountRightNow@CBloodCastle@@QAEHH@Z	; CBloodCastle::GetPlayUserCountRightNow
PUBLIC	??0CBloodCastle@@QAE@XZ				; CBloodCastle::CBloodCastle
PUBLIC	??1CBloodCastle@@UAE@XZ				; CBloodCastle::~CBloodCastle
PUBLIC	?CheckSync@CBloodCastle@@IAEXH@Z		; CBloodCastle::CheckSync
PUBLIC	?ClearBridgeData@CBloodCastle@@IAEXH@Z		; CBloodCastle::ClearBridgeData
PUBLIC	?ProcState_None@CBloodCastle@@IAEXH@Z		; CBloodCastle::ProcState_None
PUBLIC	?ProcState_Closed@CBloodCastle@@IAEXH@Z		; CBloodCastle::ProcState_Closed
PUBLIC	?ProcState_Playing@CBloodCastle@@IAEXH@Z	; CBloodCastle::ProcState_Playing
PUBLIC	?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z	; CBloodCastle::ProcState_PlayEnd
PUBLIC	?SetState_None@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_None
PUBLIC	?SetState_Closed@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_Closed
PUBLIC	?SetState_Playing@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_Playing
PUBLIC	?SetState_PlayEnd@CBloodCastle@@IAEXH@Z		; CBloodCastle::SetState_PlayEnd
PUBLIC	?BlockSector@CBloodCastle@@IAEXHHHHH@Z		; CBloodCastle::BlockSector
PUBLIC	?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z	; CBloodCastle::ReleaseSector
PUBLIC	?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z	; CBloodCastle::GetAliveUserTotalEXP
PUBLIC	?_Buynode0@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buynode0
PUBLIC	??_GCBloodCastle@@UAEPAXI@Z			; CBloodCastle::`scalar deleting destructor'
PUBLIC	??$_Buynode@ABU_EVENT_TIME@CBloodCastle@@@?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PAU21@0ABU_EVENT_TIME@CBloodCastle@@@Z ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Buynode<CBloodCastle::_EVENT_TIME const &>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7CObjectStruct@@6B@				; CObjectStruct::`vftable'
PUBLIC	??_7CBloodCastle@@6B@				; CBloodCastle::`vftable'
PUBLIC	?g_BloodCastle@@3VCBloodCastle@@A		; g_BloodCastle
PUBLIC	?ObjectStruct@@3VCObjectStruct@@A		; ObjectStruct
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@	; `string'
PUBLIC	??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@	; `string'
PUBLIC	??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@	; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@	; `string'
PUBLIC	??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@	; `string'
PUBLIC	??_C@_0O@PBCFFJJH@StoneDropRate?$AA@		; `string'
PUBLIC	??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@		; `string'
PUBLIC	??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@ ; `string'
PUBLIC	??_C@_0DD@ILIPMAJB@?$FLBloodCastle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Tim@ ; `string'
PUBLIC	??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@ ; `string'
PUBLIC	??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@ ; `string'
PUBLIC	??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@ ; `string'
PUBLIC	??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@ ; `string'
PUBLIC	??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@ ; `string'
PUBLIC	??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ ; `string'
PUBLIC	??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ ; `string'
PUBLIC	??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ ; `string'
PUBLIC	??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0BD@KGJMEGIB@BloodCastle?5Mix?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ ; `string'
PUBLIC	??_C@_0DG@MNKNGIBB@?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@ ; `string'
PUBLIC	??_C@_0DD@NPKINPCN@?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fai@ ; `string'
PUBLIC	??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ ; `string'
PUBLIC	??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ ; `string'
PUBLIC	??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@ ; `string'
PUBLIC	??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@ ; `string'
PUBLIC	??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@ ; `string'
PUBLIC	??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@ ; `string'
PUBLIC	??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@ ; `string'
PUBLIC	??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@ ; `string'
PUBLIC	??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@ ; `string'
PUBLIC	??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ ; `string'
PUBLIC	??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@ ; `string'
PUBLIC	??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ ; `string'
PUBLIC	??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ ; `string'
PUBLIC	??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@ ; `string'
PUBLIC	??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@ ; `string'
PUBLIC	??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@ ; `string'
PUBLIC	??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@ ; `string'
PUBLIC	??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@ ; `string'
PUBLIC	??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@ ; `string'
PUBLIC	??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@ ; `string'
PUBLIC	??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@ ; `string'
PUBLIC	??_C@_04BGCMBJDA@Item?$AA@			; `string'
PUBLIC	??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ ; `string'
PUBLIC	??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ ; `string'
PUBLIC	??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ ; `string'
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4CObjectStruct@@6B@				; CObjectStruct::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCObjectStruct@@@8			; CObjectStruct `RTTI Type Descriptor'
PUBLIC	??_R3CObjectStruct@@8				; CObjectStruct::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObjectStruct@@8				; CObjectStruct::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObjectStruct@@8			; CObjectStruct::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CBloodCastle@@6B@				; CBloodCastle::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBloodCastle@@@8			; CBloodCastle `RTTI Type Descriptor'
PUBLIC	??_R3CBloodCastle@@8				; CBloodCastle::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBloodCastle@@8				; CBloodCastle::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBloodCastle@@8			; CBloodCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	__localtime64:PROC
EXTRN	__time64:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	??0CSkillDelay@@QAE@XZ:PROC			; CSkillDelay::CSkillDelay
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	??0TMonsterAIAgro@@QAE@XZ:PROC			; TMonsterAIAgro::TMonsterAIAgro
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?Reset@TMonsterSkillElementInfo@@QAEXXZ:PROC	; TMonsterSkillElementInfo::Reset
EXTRN	?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemStrengthenOption
EXTRN	?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemOptionLevel
EXTRN	?GetItemOptions@CSocketItems@@QAEXPAVCItem@@PAE1@Z:PROC ; CSocketItems::GetItemOptions
EXTRN	??_ECObjectStruct@@UAEPAXI@Z:PROC		; CObjectStruct::`vector deleting destructor'
EXTRN	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEPAEE@Z:PROC ; MapClass::ItemDrop
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCLevelUpMsgSend@@YAXHH@Z:PROC			; GCLevelUpMsgSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GCUserChaosBoxSend
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?GCSendExp@@YAXHH_JHH@Z:PROC			; GCSendExp
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?gObjSetPosMonster@@YAHHH@Z:PROC		; gObjSetPosMonster
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjNextExpCal
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?LevelSmallConvert@@YAEHH@Z:PROC		; LevelSmallConvert
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
EXTRN	?gObjSetExpPetItem@@YAXHH@Z:PROC		; gObjSetExpPetItem
EXTRN	??_ECBloodCastle@@UAEPAXI@Z:PROC		; CBloodCastle::`vector deleting destructor'
EXTRN	?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z:PROC ; MyWinsockBase::CreateSocket
EXTRN	?Close@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::Close
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?GMRankingServerConnect@@YAHPADK@Z:PROC		; GMRankingServerConnect
EXTRN	?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z:PROC ; GJSetCharacterInfo
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z:PROC ; ItemSerialCreateSend
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z:PROC	; TNotice::SetNoticeProperty
EXTRN	?SendNoticeToUser@TNotice@@SAXHPAX@Z:PROC	; TNotice::SendNoticeToUser
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ChaosBoxInit
EXTRN	?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CChaosBox::LogChaosItem
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?GetPlusChaosRate@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetPlusChaosRate
EXTRN	?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ:PROC ; CCrywolfSync::GetGettingExpPenaltyRate
EXTRN	?CheckItemOptForGetExpEx@@YAXPAUOBJECTSTRUCT@@AA_JH@Z:PROC ; CheckItemOptForGetExpEx
EXTRN	?LevelUp@CMasterExperience@@QAEHPAUOBJECTSTRUCT@@_J@Z:PROC ; CMasterExperience::LevelUp
EXTRN	?IsEnabled@CMasterExperience@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMasterExperience::IsEnabled
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?GetLevelPoint@ClassCalc@@QAEGPAUOBJECTSTRUCT@@EE@Z:PROC ; ClassCalc::GetLevelPoint
EXTRN	?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z:PROC ; EventItemBagManager::OpenSpecial
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__ftol3:PROC
EXTRN	__ltod3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A:BYTE ; g_kJewelOfHarmonySystem
EXTRN	?g_SocketItem@@3VCSocketItems@@A:BYTE		; g_SocketItem
EXTRN	?MainObj@@3PAUOBJECTSTRUCT@@A:DWORD		; MainObj
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?IsDevilSquareEventConnected@@3HA:DWORD		; IsDevilSquareEventConnected
EXTRN	?g_bStoneItemDrop@@3HA:DWORD			; g_bStoneItemDrop
EXTRN	?RankingServerIP@@3PADA:BYTE			; RankingServerIP
EXTRN	?wsRServerCli@@3VwsJoinServerCli@@A:BYTE	; wsRServerCli
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?g_iCrywolfApplyMvpBenefit@@3HA:DWORD		; g_iCrywolfApplyMvpBenefit
EXTRN	?g_iCrywolfApplyMvpPenalty@@3HA:DWORD		; g_iCrywolfApplyMvpPenalty
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?g_bBloodCastle@@3HA:DWORD			; g_bBloodCastle
EXTRN	?g_iStoneDropRate@@3HA:DWORD			; g_iStoneDropRate
EXTRN	?g_iAngelKingsPaperDropRate@@3HA:DWORD		; g_iAngelKingsPaperDropRate
EXTRN	?g_iBloodBoneDropRate@@3HA:DWORD		; g_iBloodBoneDropRate
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?g_ChaosBox@@3VCChaosBox@@A:BYTE		; g_ChaosBox
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
EXTRN	?g_MasterExp@@3VCMasterExperience@@A:BYTE	; g_MasterExp
EXTRN	?g_ClassCalc@@3VClassCalc@@A:BYTE		; g_ClassCalc
EXTRN	?g_EventItemBagManager@@3VEventItemBagManager@@A:BYTE ; g_EventItemBagManager
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?g_BloodCastle@@3VCBloodCastle@@A DB 01088H DUP (?)	; g_BloodCastle
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
?ObjectStruct@@3VCObjectStruct@@A DD 01H DUP (?)	; ObjectStruct
_BSS	ENDS
CRT$XCU	SEGMENT
?ObjectStruct$initializer$@@3P6AXXZA DD FLAT:??__EObjectStruct@@YAXXZ ; ObjectStruct$initializer$
CRT$XCU	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CBloodCastle@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBloodCastle@@8 DD FLAT:??_R0?AVCBloodCastle@@@8 ; CBloodCastle::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R2CBloodCastle@@8
rdata$r	SEGMENT
??_R2CBloodCastle@@8 DD FLAT:??_R1A@?0A@EA@CBloodCastle@@8 ; CBloodCastle::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CBloodCastle@@8
rdata$r	SEGMENT
??_R3CBloodCastle@@8 DD 00H				; CBloodCastle::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBloodCastle@@@8
data$r	SEGMENT
??_R0?AVCBloodCastle@@@8 DD FLAT:??_7type_info@@6B@	; CBloodCastle `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBloodCastle@@', 00H
data$r	ENDS
;	COMDAT ??_R4CBloodCastle@@6B@
rdata$r	SEGMENT
??_R4CBloodCastle@@6B@ DD 00H				; CBloodCastle::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBloodCastle@@@8
	DD	FLAT:??_R3CBloodCastle@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CObjectStruct@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObjectStruct@@8 DD FLAT:??_R0?AVCObjectStruct@@@8 ; CObjectStruct::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObjectStruct@@8
rdata$r	ENDS
;	COMDAT ??_R2CObjectStruct@@8
rdata$r	SEGMENT
??_R2CObjectStruct@@8 DD FLAT:??_R1A@?0A@EA@CObjectStruct@@8 ; CObjectStruct::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObjectStruct@@8
rdata$r	SEGMENT
??_R3CObjectStruct@@8 DD 00H				; CObjectStruct::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObjectStruct@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObjectStruct@@@8
data$r	SEGMENT
??_R0?AVCObjectStruct@@@8 DD FLAT:??_7type_info@@6B@	; CObjectStruct `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObjectStruct@@', 00H
data$r	ENDS
;	COMDAT ??_R4CObjectStruct@@6B@
rdata$r	SEGMENT
??_R4CObjectStruct@@6B@ DD 00H				; CObjectStruct::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCObjectStruct@@@8
	DD	FLAT:??_R3CObjectStruct@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
CONST	SEGMENT
??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ DB '['
	DB	'Blood Castle] (%d) [%s][%s] FixUsersPlayStateFail() - State :'
	DB	' %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
CONST	SEGMENT
??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@ DB '['
	DB	'Blood Castle] (%d) [%s][%s] FixUsersPlayStateWin() - State : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_'
	DB	'BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_US'
	DB	'ER_INDEX].MapNumber)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m'
	DB	'_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBlood'
	DB	'CastleIndex == -1) ...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !gObjIs'
	DB	'Connected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDE'
	DB	'X)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - m_Bridg'
	DB	'eData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
CONST	SEGMENT
??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@ DB '['
	DB	'Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_'
	DB	'LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGCMBJDA@Item?$AA@
CONST	SEGMENT
??_C@_04BGCMBJDA@Item?$AA@ DB 'Item', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@
CONST	SEGMENT
??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@ DB '['
	DB	'Blood Castle] [%s][%s] DropItemDirectly() failed (iBridgeInde'
	DB	'x wrong - %d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@
CONST	SEGMENT
??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@ DB '['
	DB	'Blood Castle] (%d) Angel King - gObjAdd() failed (no space to'
	DB	' add monster, result:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@
CONST	SEGMENT
??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@ DB '['
	DB	'Blood Castle] (%d) Angel King''s Monster Position Doesn''t Ex'
	DB	'ist', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@
CONST	SEGMENT
??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@ DB 'e'
	DB	'rror-L3 : [Blood Castle] (%d) Connection Closed UserIndex:%d,'
	DB	' SubIndex:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@
CONST	SEGMENT
??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@ DB 'e'
	DB	'rror-L3 : [Blood Castle] (%d) User Out of Bound UserIndex:%d,'
	DB	' SubIndex:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) All Boss Monster Kill Success('
	DB	'Max Boss Kill Count:%d / Boss Kill Count:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) All Monster Kill Success(Max K'
	DB	'ill Count:%d / Kill Count:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@
CONST	SEGMENT
??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@ DB '['
	DB	'Blood Castle] (%d) Monster Kill Count Set - Monster:%d, Curre'
	DB	'nt Monster:%d, USER TOT:%d, LIVE:%d, DEAD:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@
CONST	SEGMENT
??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@ DB '['
	DB	'Blood Castle] (%d) Send User Quest Fail Message (Account:%s, '
	DB	'Name:%s [State:%d], MapNumber:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@
CONST	SEGMENT
??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@ DB '['
	DB	'Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, '
	DB	'Score:%d, ExtEXP:%d, LeftTime:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) got Ultimate Weapon '
	DB	'(%d) but Failed - Time Out', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
CONST	SEGMENT
??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ DB '['
	DB	'Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:'
	DB	'%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:'
	DB	'%d, MapNumber:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
CONST	SEGMENT
??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@ DB '['
	DB	'Blood Castle] (%d) Quest Complete - All Alive User''s Total E'
	DB	'XP:%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@
CONST	SEGMENT
??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@ DB '['
	DB	'Blood Castle] (%d) Winner Party Point - Alive Party Member : '
	DB	'%d, Alive Party Point : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King'''
	DB	's Weapon (%d) [Serial:%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King'''
	DB	's Weapon (%d) [Serial:%d-%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
CONST	SEGMENT
??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@ DB '['
	DB	'Blood Castle] Force (Account:%s, Name:%s) to Delete Angel Kin'
	DB	'g''s Weapon (%d) [Serial:%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@
CONST	SEGMENT
??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@ DB '['
	DB	'Blood Castle][Bug Tracer] SendCastleBridgeBlockInfo-> Bridge:'
	DB	'%d/Live:%d, (%d,%d,%d,%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@
CONST	SEGMENT
??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@ DB '['
	DB	'Blood Castle][Bug Tracer] ReleaseCastleBridge-> %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@
CONST	SEGMENT
??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@ DB '['
	DB	'Blood Castle] (%d) Castle Door Subsist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@
CONST	SEGMENT
??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@ DB ',(%s)(%s) ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@
CONST	SEGMENT
??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@ DB '4'
	DB	'00 LevelUp (%s)(%s) Party ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@ DB 'E'
	DB	'xperience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex :'
	DB	' %d, EventType : %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@ DB '['
	DB	'Blood Castle][Bug Tracer] (%d) It''s not Saint Statue( Map:%d'
	DB	', BloodCastleIndex:%d, Type:%d )', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@
CONST	SEGMENT
??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@ DB '['
	DB	'Blood Castle] (%d) Saint Status be created.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@
CONST	SEGMENT
??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@ DB '['
	DB	'Blood Castle] (%d) Door monster type Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@
CONST	SEGMENT
??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ DB '['
	DB	'Blood Castle] (%d) Create Door Fail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@
CONST	SEGMENT
??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@ DB '['
	DB	'Blood Castle] (%d) Create Door Successfuly : Index(%d)', 00H ; `string'
CONST	ENDS
CONST	SEGMENT
?g_iBC_EventScore_Fail@@3QBHB DD 0fffffed4H		; g_iBC_EventScore_Fail
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	DD	0fffffed4H
	ORG $+4
?g_iBC_Party_EventPoint@@3QBHB DD 05H			; g_iBC_Party_EventPoint
	DD	0aH
	DD	0fH
	DD	014H
	DD	01eH
CONST	ENDS
;	COMDAT ??_C@_0DD@NPKINPCN@?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fai@
CONST	SEGMENT
??_C@_0DD@NPKINPCN@?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fai@ DB '['
	DB	'BloodCastle] [%s][%s] CBMix Fail %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MNKNGIBB@?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@
CONST	SEGMENT
??_C@_0DG@MNKNGIBB@?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@ DB '['
	DB	'BloodCastle] [%s][%s] CBMix Success %d Money : %d-%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s'
	DB	', Level:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Le'
	DB	'vel:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Failed - MixRate Out of Bound (Account:%s, Nam'
	DB	'e:%s, Level:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KGJMEGIB@BloodCastle?5Mix?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@KGJMEGIB@BloodCastle?5Mix?5?$CFd?$AA@ DB 'BloodCastle Mix %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
CONST	SEGMENT
??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@ DB '['
	DB	'Blood Castle] ', 0c5H, 0f5H, 0b8H, 0edH, 0b8H, 0c1H, 0c5H, 0e4H
	DB	' Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Blood Castle] (%d) SetState PLAYEND', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
CONST	SEGMENT
??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@ DB '['
	DB	'Blood Castle] (%d) SetState PLAYING', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
CONST	SEGMENT
??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@ DB '['
	DB	'Blood Castle] (%d) SetState CLOSED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Failed -> Time Out', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@
CONST	SEGMENT
??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@ DB '['
	DB	'Blood Castle] (%d) CheckWinnerValid(iBridgeIndex) == false', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@
CONST	SEGMENT
??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@ DB '['
	DB	'Blood Castle] (%d) CheckWinnerPartyComplete(iBridgeIndex) == '
	DB	'true', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Failed -> Every User Ou'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy '
	DB	'Saint Status [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy '
	DB	'Castle Door [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
CONST	SEGMENT
??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@ DB '['
	DB	'Blood Castle] (%d) Blood Castle Quest Start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@
CONST	SEGMENT
??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@ DB '['
	DB	'Blood Castle] (%d) Door Subsist (%d)(Name: %s)(Dieregen:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@
CONST	SEGMENT
??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@ DB '['
	DB	'Blood Castle] (%d) Door Not Subsist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@
CONST	SEGMENT
??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@ DB '['
	DB	'Blood Castle] (%d) Bridge Change Bridge Attribute -> Open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@ILIPMAJB@?$FLBloodCastle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Tim@
CONST	SEGMENT
??_C@_0DD@ILIPMAJB@?$FLBloodCastle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Tim@ DB '['
	DB	'BloodCastle] (%d) Sync Open Time. [%d] min remain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@
CONST	SEGMENT
??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@ DB 'Error : Bl'
	DB	'ood Castle StartTime size is 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@
CONST	SEGMENT
??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@ DB 'StoneItemDrop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBCFFJJH@StoneDropRate?$AA@
CONST	SEGMENT
??_C@_0O@PBCFFJJH@StoneDropRate?$AA@ DB 'StoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@
CONST	SEGMENT
??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@ DB 'BloodBoneDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@
CONST	SEGMENT
??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@ DB 'AngelKingsPaperDropRa'
	DB	'te', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@
CONST	SEGMENT
??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@ DB 'BloodCastleEvent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@ DB 'CommonServer.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@
CONST	SEGMENT
??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@ DB '[Bloo'
	DB	'd Castle] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CBloodCastle@@6B@
CONST	SEGMENT
??_7CBloodCastle@@6B@ DD FLAT:??_R4CBloodCastle@@6B@	; CBloodCastle::`vftable'
	DD	FLAT:??_ECBloodCastle@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CObjectStruct@@6B@
CONST	SEGMENT
??_7CObjectStruct@@6B@ DD FLAT:??_R4CObjectStruct@@6B@	; CObjectStruct::`vftable'
	DD	FLAT:??_ECObjectStruct@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CObjectStruct@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CObjectStruct@@QAE@XZ$0
__ehfuncinfo$??0CObjectStruct@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CObjectStruct@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0OBJECTSTRUCT@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0OBJECTSTRUCT@@QAE@XZ$0
__ehfuncinfo$??0OBJECTSTRUCT@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0OBJECTSTRUCT@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_BloodCastle$initializer$@@3P6AXXZA DD FLAT:??__Eg_BloodCastle@@YAXXZ ; g_BloodCastle$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_EVENT_TIME@CBloodCastle@@ABU12@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@ABU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_EVENT_TIME@CBloodCastle@@ABU12@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@ABU23@@Z PROC ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::construct<CBloodCastle::_EVENT_TIME,CBloodCastle::_EVENT_TIME const &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN3@construct:

; 656  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U_EVENT_TIME@CBloodCastle@@ABU12@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@ABU23@@Z ENDP ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::construct<CBloodCastle::_EVENT_TIME,CBloodCastle::_EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_EVENT_TIME@CBloodCastle@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAU_EVENT_TIME@CBloodCastle@@ABU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_EVENT_TIME@CBloodCastle@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAU_EVENT_TIME@CBloodCastle@@ABU34@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::construct<CBloodCastle::_EVENT_TIME,CBloodCastle::_EVENT_TIME const &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN8@construct
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$construct@U_EVENT_TIME@CBloodCastle@@ABU12@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAU_EVENT_TIME@CBloodCastle@@ABU34@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::construct<CBloodCastle::_EVENT_TIME,CBloodCastle::_EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::construct<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *,std::_List_node<CBloodCastle::_EVENT_TIME,void *> * &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 656  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::construct<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *,std::_List_node<CBloodCastle::_EVENT_TIME,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_EVENT_TIME@CBloodCastle@@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_EVENT_TIME@CBloodCastle@@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@@Z PROC ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::destroy<CBloodCastle::_EVENT_TIME>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U_EVENT_TIME@CBloodCastle@@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@@Z ENDP ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::destroy<CBloodCastle::_EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@@Z PROC ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::destroy<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@@Z ENDP ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::destroy<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_EVENT_TIME@CBloodCastle@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@ABU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_EVENT_TIME@CBloodCastle@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@ABU23@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::construct<CBloodCastle::_EVENT_TIME,CBloodCastle::_EVENT_TIME const &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 0d		 je	 SHORT $LN13@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	89 02		 mov	 DWORD PTR [edx], eax
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U_EVENT_TIME@CBloodCastle@@ABU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@ABU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::construct<CBloodCastle::_EVENT_TIME,CBloodCastle::_EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::construct<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *,std::_List_node<CBloodCastle::_EVENT_TIME,void *> * &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::construct<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *,std::_List_node<CBloodCastle::_EVENT_TIME,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@YAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@YAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<CBloodCastle::_EVENT_TIME,void *> * &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@YAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<CBloodCastle::_EVENT_TIME,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_EVENT_TIME@CBloodCastle@@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAU_EVENT_TIME@CBloodCastle@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_EVENT_TIME@CBloodCastle@@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAU_EVENT_TIME@CBloodCastle@@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::destroy<CBloodCastle::_EVENT_TIME>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@U_EVENT_TIME@CBloodCastle@@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAU_EVENT_TIME@CBloodCastle@@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::destroy<CBloodCastle::_EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@U_EVENT_TIME@CBloodCastle@@@std@@YAPAU_EVENT_TIME@CBloodCastle@@AAU12@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@U_EVENT_TIME@CBloodCastle@@@std@@YAPAU_EVENT_TIME@CBloodCastle@@AAU12@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<CBloodCastle::_EVENT_TIME>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@U_EVENT_TIME@CBloodCastle@@@std@@YAPAU_EVENT_TIME@CBloodCastle@@AAU12@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<CBloodCastle::_EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0U_EVENT_TIME@CBloodCastle@@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U_EVENT_TIME@CBloodCastle@@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z PROC ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> ><CBloodCastle::_EVENT_TIME>, COMDAT
; _this$ = ecx

; 628  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0U_EVENT_TIME@CBloodCastle@@@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z ENDP ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> ><CBloodCastle::_EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > ><std::allocator<CBloodCastle::_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 869  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > ><std::allocator<CBloodCastle::_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@YAABV?$allocator@U_EVENT_TIME@CBloodCastle@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@YAABV?$allocator@U_EVENT_TIME@CBloodCastle@@@0@ABV10@@Z PROC ; std::forward<std::allocator<CBloodCastle::_EVENT_TIME> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@YAABV?$allocator@U_EVENT_TIME@CBloodCastle@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<CBloodCastle::_EVENT_TIME> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::destroy<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@1@PAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::destroy<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@YAPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@0@AAPAU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@YAPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@0@AAPAU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@YAPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@0@AAPAU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Buynode@ABU_EVENT_TIME@CBloodCastle@@@?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PAU21@0ABU_EVENT_TIME@CBloodCastle@@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$_Buynode@ABU_EVENT_TIME@CBloodCastle@@@?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PAU21@0ABU_EVENT_TIME@CBloodCastle@@@Z PROC ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Buynode<CBloodCastle::_EVENT_TIME const &>, COMDAT
; _this$ = ecx

; 828  : 		{	// allocate a node and set links and value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 829  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  00004	ff 75 0c	 push	 DWORD PTR __Prev$[ebp]
  00007	ff 75 08	 push	 DWORD PTR __Next$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buynode0

; 541  : 		return ((reference)_Pnode->_Myval);

  0000f	8d 70 08	 lea	 esi, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00012	85 f6		 test	 esi, esi
  00014	74 0d		 je	 SHORT $LN39@Buynode
  00016	8b 55 10	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  00019	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0001b	89 0e		 mov	 DWORD PTR [esi], ecx
  0001d	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00020	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN39@Buynode:
  00023	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 841  : 		}

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
??$_Buynode@ABU_EVENT_TIME@CBloodCastle@@@?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PAU21@0ABU_EVENT_TIME@CBloodCastle@@@Z ENDP ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Buynode<CBloodCastle::_EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABU_EVENT_TIME@CBloodCastle@@@std@@YAABU_EVENT_TIME@CBloodCastle@@ABU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU_EVENT_TIME@CBloodCastle@@@std@@YAABU_EVENT_TIME@CBloodCastle@@ABU12@@Z PROC ; std::forward<CBloodCastle::_EVENT_TIME const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABU_EVENT_TIME@CBloodCastle@@@std@@YAABU_EVENT_TIME@CBloodCastle@@ABU12@@Z ENDP ; std::forward<CBloodCastle::_EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::construct<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *,std::_List_node<CBloodCastle::_EVENT_TIME,void *> * &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::construct<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *,std::_List_node<CBloodCastle::_EVENT_TIME,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_EVENT_TIME@CBloodCastle@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_EVENT_TIME@CBloodCastle@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::destroy<CBloodCastle::_EVENT_TIME>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U_EVENT_TIME@CBloodCastle@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAU_EVENT_TIME@CBloodCastle@@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::destroy<CBloodCastle::_EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U_EVENT_TIME@CBloodCastle@@@std@@YAPAU_EVENT_TIME@CBloodCastle@@AAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_EVENT_TIME@CBloodCastle@@@std@@YAPAU_EVENT_TIME@CBloodCastle@@AAU12@@Z PROC ; std::addressof<CBloodCastle::_EVENT_TIME>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U_EVENT_TIME@CBloodCastle@@@std@@YAPAU_EVENT_TIME@CBloodCastle@@AAU12@@Z ENDP ; std::addressof<CBloodCastle::_EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1><std::allocator<CBloodCastle::_EVENT_TIME> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 525  : 		this->_Myhead = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 526  : 		this->_Mysize = 0;

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  0000f	c2 08 00	 ret	 8
??$?0ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1><std::allocator<CBloodCastle::_EVENT_TIME> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::destroy<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::destroy<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@YAPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@YAPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@YAPAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<CBloodCastle::_EVENT_TIME,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??$_Insert@ABU_EVENT_TIME@CBloodCastle@@@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@1@ABU_EVENT_TIME@CBloodCastle@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@ABU_EVENT_TIME@CBloodCastle@@@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@1@ABU_EVENT_TIME@CBloodCastle@@@Z PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Insert<CBloodCastle::_EVENT_TIME const &>, COMDAT
; _this$ = ecx

; 1058 : 		{	// insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00007	57		 push	 edi

; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

  00008	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  0000b	8b f9		 mov	 edi, ecx
  0000d	ff 76 04	 push	 DWORD PTR [esi+4]
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??$_Buynode@ABU_EVENT_TIME@CBloodCastle@@@?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PAU21@0ABU_EVENT_TIME@CBloodCastle@@@Z ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Buynode<CBloodCastle::_EVENT_TIME const &>
  00016	8b d0		 mov	 edx, eax

; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Copy_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead()),
; 1117 : 			&this->_Get_data()));
; 1118 : 		}
; 1119 : 
; 1120 : 	const_iterator begin() const _NOEXCEPT
; 1121 : 		{	// return iterator for beginning of nonmutable sequence
; 1122 : 		return (const_iterator(this->_Nextnode(this->_Myhead()),
; 1123 : 			&this->_Get_data()));
; 1124 : 		}
; 1125 : 
; 1126 : 	iterator end() _NOEXCEPT
; 1127 : 		{	// return iterator for end of mutable sequence
; 1128 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1129 : 		}
; 1130 : 
; 1131 : 	const_iterator end() const _NOEXCEPT
; 1132 : 		{	// return iterator for end of nonmutable sequence
; 1133 : 		return (const_iterator(this->_Myhead(), &this->_Get_data()));
; 1134 : 		}
; 1135 : 
; 1136 : 	_Unchecked_iterator _Unchecked_begin()
; 1137 : 		{	// return iterator for beginning of mutable sequence
; 1138 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead()),
; 1139 : 			&this->_Get_data()));
; 1140 : 		}
; 1141 : 
; 1142 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1143 : 		{	// return iterator for beginning of nonmutable sequence
; 1144 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead()),
; 1145 : 			&this->_Get_data()));
; 1146 : 		}
; 1147 : 
; 1148 : 	_Unchecked_iterator _Unchecked_end()
; 1149 : 		{	// return unchecked iterator for end of mutable sequence
; 1150 : 		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));
; 1151 : 		}
; 1152 : 
; 1153 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1154 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1155 : 		return (_Unchecked_const_iterator(this->_Myhead(),
; 1156 : 			&this->_Get_data()));
; 1157 : 		}
; 1158 : 
; 1159 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1160 : 		{	// make iterator from const_iterator
; 1161 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1162 : 		}
; 1163 : 
; 1164 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1165 : 		{	// make iterator from _Unchecked_const_iterator
; 1166 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1167 : 		}
; 1168 : 
; 1169 : 	reverse_iterator rbegin() _NOEXCEPT
; 1170 : 		{	// return iterator for beginning of reversed mutable sequence
; 1171 : 		return (reverse_iterator(end()));
; 1172 : 		}
; 1173 : 
; 1174 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1175 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1176 : 		return (const_reverse_iterator(end()));
; 1177 : 		}
; 1178 : 
; 1179 : 	reverse_iterator rend() _NOEXCEPT
; 1180 : 		{	// return iterator for end of reversed mutable sequence
; 1181 : 		return (reverse_iterator(begin()));
; 1182 : 		}
; 1183 : 
; 1184 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1185 : 		{	// return iterator for end of reversed nonmutable sequence
; 1186 : 		return (const_reverse_iterator(begin()));
; 1187 : 		}
; 1188 : 
; 1189 : 	const_iterator cbegin() const _NOEXCEPT
; 1190 : 		{	// return iterator for beginning of nonmutable sequence
; 1191 : 		return (begin());
; 1192 : 		}
; 1193 : 
; 1194 : 	const_iterator cend() const _NOEXCEPT
; 1195 : 		{	// return iterator for end of nonmutable sequence
; 1196 : 		return (end());
; 1197 : 		}
; 1198 : 
; 1199 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1200 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1201 : 		return (rbegin());
; 1202 : 		}
; 1203 : 
; 1204 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1205 : 		{	// return iterator for end of reversed nonmutable sequence
; 1206 : 		return (rend());
; 1207 : 		}
; 1208 : 
; 1209 : 	void resize(size_type _Newsize)
; 1210 : 		{	// determine new length, padding with _Ty() elements as needed
; 1211 : 		if (this->_Mysize() < _Newsize)
; 1212 : 			{	// pad to make larger
; 1213 : 			size_type _Count = 0;
; 1214 : 			_TRY_BEGIN
; 1215 : 			for (; this->_Mysize() < _Newsize; ++_Count)
; 1216 : 				_Insert(_Unchecked_end());
; 1217 : 			_CATCH_ALL
; 1218 : 			for (; 0 < _Count; --_Count)
; 1219 : 				pop_back();	// undo inserts
; 1220 : 			_RERAISE;
; 1221 : 			_CATCH_END
; 1222 : 			}
; 1223 : 		else
; 1224 : 			while (_Newsize < this->_Mysize())
; 1225 : 				pop_back();
; 1226 : 		}
; 1227 : 
; 1228 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1229 : 		{	// determine new length, padding with _Val elements as needed
; 1230 : 		if (this->_Mysize() < _Newsize)
; 1231 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize(), _Val);
; 1232 : 		else
; 1233 : 			while (_Newsize < this->_Mysize())
; 1234 : 				pop_back();
; 1235 : 		}
; 1236 : 
; 1237 : 	size_type size() const _NOEXCEPT
; 1238 : 		{	// return length of sequence
; 1239 : 		return (this->_Mysize());
; 1240 : 		}
; 1241 : 
; 1242 : 	size_type max_size() const _NOEXCEPT
; 1243 : 		{	// return maximum possible length of sequence
; 1244 : 		return (this->_Getal().max_size());
; 1245 : 		}
; 1246 : 
; 1247 : 	bool empty() const _NOEXCEPT
; 1248 : 		{	// test if sequence is empty
; 1249 : 		return (this->_Mysize() == 0);
; 1250 : 		}
; 1251 : 
; 1252 : 	allocator_type get_allocator() const _NOEXCEPT
; 1253 : 		{	// return allocator object for values
; 1254 : 		return (this->_Getal());
; 1255 : 		}
; 1256 : 
; 1257 : 	reference front()
; 1258 : 		{	// return first element of mutable sequence
; 1259 : 		return (*begin());
; 1260 : 		}
; 1261 : 
; 1262 : 	const_reference front() const
; 1263 : 		{	// return first element of nonmutable sequence
; 1264 : 		return (*begin());
; 1265 : 		}
; 1266 : 
; 1267 : 	reference back()
; 1268 : 		{	// return last element of mutable sequence
; 1269 : 		return (*(--end()));
; 1270 : 		}
; 1271 : 
; 1272 : 	const_reference back() const
; 1273 : 		{	// return last element of nonmutable sequence
; 1274 : 		return (*(--end()));
; 1275 : 		}
; 1276 : 
; 1277 : 	void push_front(const _Ty& _Val)
; 1278 : 		{	// insert element at beginning
; 1279 : 		_Insert(_Unchecked_begin(), _Val);
; 1280 : 		}
; 1281 : 
; 1282 : 	void pop_front()
; 1283 : 		{	// erase element at beginning
; 1284 : 		erase(begin());
; 1285 : 		}
; 1286 : 
; 1287 : 	void push_back(const _Ty& _Val)
; 1288 : 		{	// insert element at end
; 1289 : 		_Insert(_Unchecked_end(), _Val);
; 1290 : 		}
; 1291 : 
; 1292 : 	void pop_back()
; 1293 : 		{	// erase element at end
; 1294 : 		erase(--end());
; 1295 : 		}
; 1296 : 
; 1297 : 	template<class _Iter>
; 1298 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1299 : 			void>::type
; 1300 : 		assign(_Iter _First, _Iter _Last)
; 1301 : 		{	// assign [_First, _Last), input iterators
; 1302 : 		iterator _Old = begin();
; 1303 : 		_TRY_BEGIN
; 1304 : 		for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)
; 1305 : 			_Reusenode(_Old, *_First);
; 1306 : 		for (; _First != _Last; ++_First)
; 1307 : 			_Insert(_Unchecked_end(), *_First);
; 1308 : 		_CATCH_ALL
; 1309 : 		clear();
; 1310 : 		_RERAISE;
; 1311 : 		_CATCH_END
; 1312 : 		erase(_Old, end());
; 1313 : 		}
; 1314 : 
; 1315 : 	template<class _TArg>
; 1316 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1317 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1318 : 		_TRY_BEGIN
; 1319 : 		this->_Getal().destroy(
; 1320 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1321 : 		this->_Getal().construct(
; 1322 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1323 : 			_STD forward<_TArg>(_Arg));
; 1324 : 		_CATCH_ALL
; 1325 : 		_Unlinknode(_Where);
; 1326 : 		this->_Getal().destroy(
; 1327 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1328 : 		this->_Getal().destroy(
; 1329 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1330 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1331 : 		_RERAISE;
; 1332 : 		_CATCH_END
; 1333 : 		}
; 1334 : 
; 1335 : 	void assign(size_type _Count, const _Ty& _Val)
; 1336 : 		{	// assign _Count * _Val
; 1337 : 		clear();
; 1338 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1339 : 		}
; 1340 : 
; 1341 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1342 : 		{	// insert _Val at _Where
; 1343 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1344 : 		if (_Where._Getcont() != &this->_Get_data())
; 1345 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1346 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1347 : 
; 1348 : 		_Insert(_Where._Unchecked(), _Val);
; 1349 : 		return (_Make_iter(--_Where));
; 1350 : 		}
; 1351 : 
; 1352 : 	iterator insert(const_iterator _Where,
; 1353 : 		size_type _Count, const _Ty& _Val)
; 1354 : 		{	// insert _Count * _Val at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != &this->_Get_data())
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1364 : 			return (begin());
; 1365 : 			}
; 1366 : 		else
; 1367 : 			{	// insert sequence not at beginning
; 1368 : 			--_Prev;
; 1369 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1370 : 			return (++_Prev);
; 1371 : 			}
; 1372 : 		}
; 1373 : 
; 1374 : 	template<class _Iter>
; 1375 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1376 : 			iterator>::type
; 1377 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1378 : 		{	// insert [_First, _Last) at _Where
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_Where._Getcont() != &this->_Get_data())
; 1381 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1382 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1383 : 
; 1384 : 		iterator _Prev = _Make_iter(_Where);
; 1385 : 		if (_Prev == begin())
; 1386 : 			{	// insert sequence at beginning
; 1387 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1388 : 				_Iter_cat(_First));
; 1389 : 			return (begin());
; 1390 : 			}
; 1391 : 		else
; 1392 : 			{	// insert sequence not at beginning
; 1393 : 			--_Prev;
; 1394 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1395 : 				_Iter_cat(_First));
; 1396 : 			return (++_Prev);
; 1397 : 			}
; 1398 : 		}
; 1399 : 
; 1400 : 	template<class _Iter>
; 1401 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1402 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1403 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1404 : 		size_type _Num = 0;
; 1405 : 
; 1406 : 		_TRY_BEGIN
; 1407 : 		for (; _First != _Last; ++_First, (void)++_Num)
; 1408 : 			_Insert(_Where, *_First);
; 1409 : 		_CATCH_ALL
; 1410 : 		for (; 0 < _Num; --_Num)
; 1411 : 			{	// undo inserts
; 1412 : 			_Unchecked_const_iterator _Before = _Where;
; 1413 : 			_Unchecked_erase(--_Before);
; 1414 : 			}
; 1415 : 		_RERAISE;
; 1416 : 		_CATCH_END
; 1417 : 		}
; 1418 : 
; 1419 : 	template<class _Iter>
; 1420 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1421 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1422 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1423 : 		_DEBUG_RANGE(_First, _Last);
; 1424 : 		_Iter _Next = _First;
; 1425 : 
; 1426 : 		_TRY_BEGIN
; 1427 : 		for (; _First != _Last; ++_First)
; 1428 : 			_Insert(_Where, *_First);
; 1429 : 		_CATCH_ALL
; 1430 : 		for (; _Next != _First; ++_Next)
; 1431 : 			{	// undo inserts
; 1432 : 			_Unchecked_const_iterator _Before = _Where;
; 1433 : 			_Unchecked_erase(--_Before);
; 1434 : 			}
; 1435 : 		_RERAISE;
; 1436 : 		_CATCH_END
; 1437 : 		}
; 1438 : 
; 1439 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1440 : 		{	// unlink node at _Where from the list
; 1441 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1442 : 		if (_Where._Getcont() != &this->_Get_data()
; 1443 : 			|| _Where._Ptr == this->_Myhead())
; 1444 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1445 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1446 : 		_Orphan_ptr(_Pnode);
; 1447 : 
; 1448 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1449 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1453 : 			this->_Nextnode(_Pnode);
; 1454 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1455 : 			this->_Prevnode(_Pnode);
; 1456 : 
; 1457 : 		--this->_Mysize();
; 1458 : 		return (_Pnode);
; 1459 : 		}
; 1460 : 
; 1461 : 	iterator erase(const_iterator _Where)
; 1462 : 		{	// erase element at _Where
; 1463 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1464 : 		this->_Freenode(_Pnode);
; 1465 : 		return (_Make_iter(_Where));
; 1466 : 		}
; 1467 : 
; 1468 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1469 : 		{	// erase element at _Where
; 1470 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1471 : 
; 1472 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1473 : 			this->_Nextnode(_Pnode);
; 1474 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1475 : 			this->_Prevnode(_Pnode);
; 1476 : 		this->_Freenode(_Pnode);
; 1477 : 		--this->_Mysize();
; 1478 : 		}
; 1479 : 
; 1480 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1481 : 		{	// erase [_First, _Last)
; 1482 : 		if (_First == begin() && _Last == end())
; 1483 : 			{	// erase all and return fresh iterator
; 1484 : 			clear();
; 1485 : 			return (end());
; 1486 : 			}
; 1487 : 		else
; 1488 : 			{	// erase subrange
; 1489 : 			while (_First != _Last)
; 1490 : 				_First = erase(_First);
; 1491 : 			return (_Make_iter(_Last));
; 1492 : 			}
; 1493 : 		}
; 1494 : 
; 1495 : 	void clear() _NOEXCEPT
; 1496 : 		{	// erase all
; 1497 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1498 : 
; 1499 : 		this->_Orphan_ptr(nullptr);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());
; 1502 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();
; 1503 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();
; 1504 : 		this->_Mysize() = 0;
; 1505 : 
; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)
; 1507 : 			{	// delete an element
; 1508 : 			_Pnext = this->_Nextnode(_Pnode);
; 1509 : 			this->_Freenode(_Pnode);
; 1510 : 			}
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		_NOEXCEPT_OP(_Alty::is_always_equal::value)
; 1515 : 		{	// exchange contents with _Right
; 1516 : 		if (this == &_Right)
; 1517 : 			;	// same object, do nothing
; 1518 : 		else if (this->_Getal() == _Right._Getal())
; 1519 : 			{	// same allocator, swap control information
; 1520 : 			this->_Swap_all(_Right);
; 1521 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1522 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1529 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1530 : 			}
; 1531 : 
; 1532 : 		else	// containers are incompatible
; 1533 : 
; 1534 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1535 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1536 : 
; 1537 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 			_XSTD terminate();
; 1539 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 		}
; 1541 : 
; 1542 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1543 : 		{	// splice all of _Right at _Where
; 1544 : 		if (this != &_Right && !_Right.empty())
; 1545 : 			{	// worth splicing, do it
; 1546 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1547 : 				_Right._Mysize());
; 1548 : 			}
; 1549 : 		}
; 1550 : 
; 1551 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1552 : 		{	// splice all of _Right at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1557 : 		const_iterator _First)
; 1558 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1559 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1560 : 		if (_First == _Right.end())
; 1561 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1562 : 		else
; 1563 : 
; 1564 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1565 : 		if (_First != _Right.end())
; 1566 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1567 : 
; 1568 : 			{	// element exists, try splice
; 1569 : 			const_iterator _Last = _First;
; 1570 : 			++_Last;
; 1571 : 			if (this != &_Right
; 1572 : 				|| (_Where != _First && _Where != _Last))
; 1573 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1574 : 			}
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1578 : 		const_iterator _First)
; 1579 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1580 : 		splice(_Where, (_Myt&)_Right, _First);
; 1581 : 		}
; 1582 : 
; 1583 : 	void splice(const_iterator _Where,
; 1584 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1585 : 		{	// splice _Right [_First, _Last) at _Where
; 1586 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1587 : 			{	// worth splicing, do it
; 1588 : 			size_type _Count = 0;
; 1589 : 
; 1590 : 			if (this == &_Right)
; 1591 : 				;	// just rearrange this list
; 1592 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1593 : 				_Count = _Right._Mysize();	// splice in whole list
; 1594 : 			else
; 1595 : 				{	// count nodes and check for knot
; 1596 : 				const_iterator _Next = _First;
; 1597 : 
; 1598 : 				for (; _Next != _Last; ++_Next, (void)++_Count)
; 1599 : 					if (_Next == _Right.end())
; 1600 : 						_Xlength_error("list<T> bad splice");
; 1601 : 				}
; 1602 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1603 : 			}
; 1604 : 		}
; 1605 : 
; 1606 : 	void splice(const_iterator _Where,
; 1607 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1608 : 		{	// splice _Right [_First, _Last) at _Where
; 1609 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1610 : 		}
; 1611 : 
; 1612 : 	void remove(const _Ty& _Val)
; 1613 : 		{	// erase each element matching _Val
; 1614 : 		iterator _Val_it = end();
; 1615 : 
; 1616 : 		for (iterator _First = begin(); _First != end(); )
; 1617 : 			if (*_First == _Val)
; 1618 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1619 : 					_Val_it = _First++;
; 1620 : 				else
; 1621 : 					_First = erase(_First);
; 1622 : 			else
; 1623 : 				++_First;
; 1624 : 
; 1625 : 		if (_Val_it != end())
; 1626 : 			erase(_Val_it);
; 1627 : 		}
; 1628 : 
; 1629 : 	template<class _Pr1>
; 1630 : 		void remove_if(_Pr1 _Pred)
; 1631 : 		{	// erase each element satisfying _Pred
; 1632 : 		for (iterator _First = begin(); _First != end(); )
; 1633 : 			if (_Pred(*_First))
; 1634 : 				_First = erase(_First);
; 1635 : 			else
; 1636 : 				++_First;
; 1637 : 		}
; 1638 : 
; 1639 : 	void unique()
; 1640 : 		{	// erase each element matching previous
; 1641 : 		unique(equal_to<>());
; 1642 : 		}
; 1643 : 
; 1644 : 	template<class _Pr2>
; 1645 : 		void unique(_Pr2 _Pred)
; 1646 : 		{	// erase each element satisfying _Pred with previous
; 1647 : 		const _Nodeptr _Phead = this->_Myhead();
; 1648 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1649 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1650 : 
; 1651 : 		while (_Pnode != _Phead)
; 1652 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1653 : 				{	// match, remove it
; 1654 : 				const _Nodeptr _Perase = _Pnode;
; 1655 : 				_Pnode = this->_Nextnode(_Pnode);
; 1656 : 
; 1657 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1658 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1659 : 				this->_Freenode(_Perase);
; 1660 : 
; 1661 : 				--this->_Mysize();
; 1662 : 				}
; 1663 : 			else
; 1664 : 				{	// no match, advance
; 1665 : 				_Pprev = _Pnode;
; 1666 : 				_Pnode = this->_Nextnode(_Pnode);
; 1667 : 				}
; 1668 : 		}
; 1669 : 
; 1670 : 	void merge(_Myt& _Right)
; 1671 : 		{	// merge in elements from _Right, both ordered by operator<
; 1672 : 		merge(_Right, less<>());
; 1673 : 		}
; 1674 : 
; 1675 : 	void merge(_Myt&& _Right)
; 1676 : 		{	// merge in elements from _Right, both ordered by operator<
; 1677 : 		merge((_Myt&)_Right);
; 1678 : 		}
; 1679 : 
; 1680 : 	template<class _Pr2>
; 1681 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1682 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1683 : 		if (&_Right != this)
; 1684 : 			{	// safe to merge, do it
; 1685 : 			iterator _First1 = begin(), _Last1 = end();
; 1686 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1687 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1688 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1689 : 
; 1690 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1691 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1692 : 					{	// splice in an element from _Right
; 1693 : 					iterator _Mid2 = _First2;
; 1694 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1695 : 					_First2 = _Mid2;
; 1696 : 					}
; 1697 : 				else
; 1698 : 					++_First1;
; 1699 : 
; 1700 : 			if (_First2 != _Last2)
; 1701 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1702 : 					_Right._Mysize());	// splice remainder of _Right
; 1703 : 			}
; 1704 : 		}
; 1705 : 
; 1706 : 	template<class _Pr2>
; 1707 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1708 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1709 : 		merge((_Myt&)_Right, _Pred);
; 1710 : 		}
; 1711 : 
; 1712 : 	void sort()
; 1713 : 		{	// order sequence, using operator<
; 1714 : 		sort(less<>());
; 1715 : 		}
; 1716 : 
; 1717 : 	template<class _Pr2>
; 1718 : 		void sort(_Pr2 _Pred)
; 1719 : 		{	// order sequence, using _Pred
; 1720 : 		_Sort(begin(), end(), _Pred, this->_Mysize());
; 1721 : 		}
; 1722 : 
; 1723 : 	template<class _Pr2>
; 1724 : 		iterator _Sort(iterator _First, iterator _Last, _Pr2 _Pred,
; 1725 : 			size_type _Size)
; 1726 : 		{	// order [_First, _Last), using _Pred, return new first
; 1727 : 			// _Size must be distance from _First to _Last
; 1728 : 		if (_Size < 2)
; 1729 : 			return (_First);	// nothing to do
; 1730 : 
; 1731 : 		iterator _Mid = _STD next(_First, _Size / 2);
; 1732 : 		_First = _Sort(_First, _Mid, _Pred, _Size / 2);
; 1733 : 		_Mid = _Sort(_Mid, _Last, _Pred, _Size - _Size / 2);
; 1734 : 		iterator _Newfirst = _First;
; 1735 : 
; 1736 : 		for (bool _Initial_loop = true; ; _Initial_loop = false)
; 1737 : 			{	// [_First, _Mid) and [_Mid, _Last) are sorted and non-empty
; 1738 : 			if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
; 1739 : 				{	// consume _Mid
; 1740 : 				if (_Initial_loop)
; 1741 : 					_Newfirst = _Mid;	// update return value
; 1742 : 				splice(_First, *this, _Mid++);
; 1743 : 				if (_Mid == _Last)
; 1744 : 					return (_Newfirst);	// exhausted [_Mid, _Last); done
; 1745 : 				}
; 1746 : 			else
; 1747 : 				{	// consume _First
; 1748 : 				++_First;
; 1749 : 				if (_First == _Mid)
; 1750 : 					return (_Newfirst);	// exhausted [_First, _Mid); done
; 1751 : 				}
; 1752 : 			}
; 1753 : 		}
; 1754 : 
; 1755 : 	void reverse() _NOEXCEPT
; 1756 : 		{	// reverse sequence
; 1757 : 		const _Nodeptr _Phead = this->_Myhead();
; 1758 : 		_Nodeptr _Pnode = _Phead;
; 1759 : 
; 1760 : 		for (; ; )
; 1761 : 			{	// flip pointers in a node
; 1762 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1763 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1764 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1765 : 
; 1766 : 			if (_Pnext == _Phead)
; 1767 : 				break;
; 1768 : 			_Pnode = _Pnext;
; 1769 : 			}
; 1770 : 		}
; 1771 : 
; 1772 : 	void _Splice(const_iterator _Where,
; 1773 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1774 : 		size_type _Count)
; 1775 : 		{	// splice _Right [_First, _Last) before _Where
; 1776 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1777 : 		if (_Where._Getcont() != &this->_Get_data())
; 1778 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1779 : 		if (this->_Getal() != _Right._Getal())
; 1780 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1781 : 
; 1782 : 		if (this != &_Right)
; 1783 : 			{	// transfer ownership
; 1784 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1785 : 
; 1786 : 			const bool _One = _Count == 1;
; 1787 : 			const bool _All = !_One && _Count == _Right.size();
; 1788 : 			const bool _Some = !_One && !_All;
; 1789 : 
; 1790 : 			_Nodeptr _Oldprev = this->_Prevnode(_First._Ptr);
; 1791 : 
; 1792 : 			if (_Some)
; 1793 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1794 : 					_Ptr = this->_Nextnode(_Ptr))
; 1795 : 					{	// mark _Prev pointers
; 1796 : 					this->_Prevnode(_Ptr) = 0;
; 1797 : 					}
; 1798 : 
; 1799 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1800 : 
; 1801 : 			if (_Pnext == 0)
; 1802 : 				_DEBUG_ERROR("list container corrupted");
; 1803 : 
; 1804 : 			while (*_Pnext != 0)
; 1805 : 				{	// check the iterator
; 1806 : 				const_iterator& _Iter = **_Pnext;
; 1807 : 
; 1808 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1809 : 					|| (_All && _Iter._Ptr != _Right._Myhead())
; 1810 : 					|| (_Some && this->_Prevnode(_Iter._Ptr) == 0))
; 1811 : 					{	// adopt the iterator
; 1812 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1813 : 					_Iter._Myproxy = this->_Myproxy();
; 1814 : 					_Iter._Mynextiter = this->_Myproxy()->_Myfirstiter;
; 1815 : 					this->_Myproxy()->_Myfirstiter = &_Iter;
; 1816 : 					}
; 1817 : 				else
; 1818 : 					{	// skip the iterator
; 1819 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1820 : 					}
; 1821 : 				}
; 1822 : 
; 1823 : 			if (_Some)
; 1824 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1825 : 					_Ptr = this->_Nextnode(_Ptr))
; 1826 : 					{	// restore _Prev pointers
; 1827 : 					this->_Prevnode(_Ptr) = _Oldprev;
; 1828 : 					_Oldprev = _Ptr;
; 1829 : 					}
; 1830 : 			}
; 1831 : 
; 1832 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1833 : 		if (this->_Getal() != _Right._Getal())
; 1834 : 			_XSTD terminate();
; 1835 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1836 : 
; 1837 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1838 : 		}
; 1839 : 
; 1840 : 	void _Splice_same(const_iterator _Where,
; 1841 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1842 : 		size_type _Count)
; 1843 : 		{	// splice _Right [_First, _Last) before _Where
; 1844 : 		if (this != &_Right)
; 1845 : 			{	// splicing from another list, adjust counts
; 1846 : 			_Incsize(_Count);
; 1847 : 			_Right._Mysize() -= _Count;
; 1848 : 			}
; 1849 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1850 : 			_Last._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1852 : 			_Where._Mynode();
; 1853 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1854 : 			_First._Mynode();
; 1855 : 
; 1856 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1857 : 		this->_Prevnode(_Where._Mynode()) =
; 1858 : 			this->_Prevnode(_Last._Mynode());
; 1859 : 		this->_Prevnode(_Last._Mynode()) =
; 1860 : 			this->_Prevnode(_First._Mynode());
; 1861 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1862 : 		}
; 1863 : 
; 1864 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1865 : 		_Unchecked_const_iterator _First,
; 1866 : 		_Unchecked_const_iterator _Last)
; 1867 : 		{	// splice [_First, _Last) before _Where
; 1868 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1869 : 			_Last._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1871 : 			_Where._Mynode();
; 1872 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1873 : 			_First._Mynode();
; 1874 : 
; 1875 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1876 : 		this->_Prevnode(_Where._Mynode()) =
; 1877 : 			this->_Prevnode(_Last._Mynode());
; 1878 : 		this->_Prevnode(_Last._Mynode()) =
; 1879 : 			this->_Prevnode(_First._Mynode());
; 1880 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1881 : 		}
; 1882 : 
; 1883 : 	void _Tidy()
; 1884 : 		{	// free all storage
; 1885 : 		clear();
; 1886 : 		}
; 1887 : 
; 1888 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1889 : 		size_type _Count, const _Ty& _Val)
; 1890 : 		{	// insert _Count * _Val at _Where
; 1891 : 		size_type _Countsave = _Count;
; 1892 : 
; 1893 : 		_TRY_BEGIN
; 1894 : 		for (; 0 < _Count; --_Count)
; 1895 : 			_Insert(_Where, _Val);
; 1896 : 		_CATCH_ALL
; 1897 : 		for (; _Count < _Countsave; ++_Count)
; 1898 : 			{	// undo inserts
; 1899 : 			_Unchecked_const_iterator _Before = _Where;
; 1900 : 			_Unchecked_erase(--_Before);
; 1901 : 			}
; 1902 : 		_RERAISE;
; 1903 : 		_CATCH_END
; 1904 : 		}
; 1905 : 
; 1906 : 	void _Incsize(size_type _Count)
; 1907 : 		{	// alter element count, with checking
; 1908 : 		if (max_size() - this->_Mysize() - 1 < _Count)

  00018	b9 fe ff ff 0f	 mov	 ecx, 268435454		; 0ffffffeH
  0001d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00020	2b c8		 sub	 ecx, eax
  00022	83 f9 01	 cmp	 ecx, 1
  00025	72 12		 jb	 SHORT $LN65@Insert

; 1910 : 		this->_Mysize() += _Count;

  00027	40		 inc	 eax
  00028	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1062 : 				_STD forward<_Valty>(_Val)...);
; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

  0002b	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 531  : 		return ((_Nodepref)_Pnode->_Next);

  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  00033	89 10		 mov	 DWORD PTR [eax], edx

; 1066 : 		}

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
$LN65@Insert:

; 1909 : 			_Xlength_error("list<T> too long");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN67@Insert:
$LN64@Insert:
  00043	cc		 int	 3
??$_Insert@ABU_EVENT_TIME@CBloodCastle@@@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@1@ABU_EVENT_TIME@CBloodCastle@@@Z ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Insert<CBloodCastle::_EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 125  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 376  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  0000a	8b 12		 mov	 edx, DWORD PTR [edx]
  0000c	89 11		 mov	 DWORD PTR [ecx], edx

; 378  : 		++*this;
; 379  : 		return (_Tmp);
; 380  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 374  : 
; 375  : 	_Myiter operator++(int)
; 376  : 		{	// postincrement
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		++*this;
; 379  : 		return (_Tmp);
; 380  : 		}
; 381  : 
; 382  : 	_Myiter& operator--()
; 383  : 		{	// predecrement
; 384  : 		--(*(_Mybase *)this);
; 385  : 		return (*this);
; 386  : 		}
; 387  : 
; 388  : 	_Myiter operator--(int)
; 389  : 		{	// postdecrement
; 390  : 		_Myiter _Tmp = *this;
; 391  : 		--*this;
; 392  : 		return (_Tmp);
; 393  : 		}
; 394  : 	};
; 395  : 
; 396  : template<class _Mylist> inline
; 397  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 398  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 399  : 	{	// convert to unchecked
; 400  : 	return (_Iter._Unchecked());
; 401  : 	}
; 402  : 
; 403  : template<class _Mylist> inline
; 404  : 	_List_iterator<_Mylist>&
; 405  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 406  : 			typename _List_iterator<_Mylist>
; 407  : 				::_Unchecked_type _Right)
; 408  : 	{	// convert to checked
; 409  : 	return (_Iter._Rechecked(_Right));
; 410  : 	}
; 411  : 
; 412  : 		// list TYPE WRAPPERS
; 413  : template<class _Value_type,
; 414  : 	class _Size_type,
; 415  : 	class _Difference_type,
; 416  : 	class _Pointer,
; 417  : 	class _Const_pointer,
; 418  : 	class _Reference,
; 419  : 	class _Const_reference,
; 420  : 	class _Nodeptr_type>
; 421  : 	struct _List_iter_types
; 422  : 	{	// wraps types needed by iterators
; 423  : 	typedef _Value_type value_type;
; 424  : 	typedef _Size_type size_type;
; 425  : 	typedef _Difference_type difference_type;
; 426  : 	typedef _Pointer pointer;
; 427  : 	typedef _Const_pointer const_pointer;
; 428  : 	typedef _Reference reference;
; 429  : 	typedef _Const_reference const_reference;
; 430  : 	typedef _Nodeptr_type _Nodeptr;
; 431  : 	};
; 432  : 
; 433  : template<class _Value_type,
; 434  : 	class _Voidptr>
; 435  : 	struct _List_node
; 436  : 		{	// list node
; 437  : 		_Voidptr _Next;	// successor node, or first element if head
; 438  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 439  : 		_Value_type _Myval;	// the stored value, unused if head
; 440  : 
; 441  : 	private:
; 442  : 		_List_node& operator=(const _List_node&);
; 443  : 		};
; 444  : 
; 445  : template<class _Value_type>
; 446  : 	struct _List_node<_Value_type, void *>
; 447  : 		{	// list node
; 448  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 449  : 		_Nodeptr _Next;	// successor node, or first element if head
; 450  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 451  : 		_Value_type _Myval;	// the stored value, unused if head
; 452  : 
; 453  : 	private:
; 454  : 		_List_node& operator=(const _List_node&);
; 455  : 		};
; 456  : 
; 457  : template<class _Ty>
; 458  : 	struct _List_simple_types
; 459  : 		: public _Simple_types<_Ty>
; 460  : 	{	// wraps types needed by iterators
; 461  : 	typedef _List_node<_Ty, void *> _Node;
; 462  : 	typedef _Node *_Nodeptr;
; 463  : 	};
; 464  : 
; 465  : template<class _Ty,
; 466  : 	class _Alloc0>
; 467  : 	struct _List_base_types
; 468  : 	{	// types needed for a container base
; 469  : 	typedef _Alloc0 _Alloc;
; 470  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 471  : 
; 472  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 473  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 474  : 
; 475  : 
; 476  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 477  : 		_Voidptr;
; 478  : 	typedef _List_node<typename _Alty::value_type,
; 479  : 		_Voidptr> _Node;
; 480  : 
; 481  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 482  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 483  : 	typedef _Nodeptr& _Nodepref;
; 484  : 
; 485  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 486  : 		_List_simple_types<typename _Alty::value_type>,
; 487  : 		_List_iter_types<typename _Alty::value_type,
; 488  : 			typename _Alty::size_type,
; 489  : 			typename _Alty::difference_type,
; 490  : 			typename _Alty::pointer,
; 491  : 			typename _Alty::const_pointer,
; 492  : 			typename _Alty::reference,
; 493  : 			typename _Alty::const_reference,
; 494  : 			_Nodeptr> >::type
; 495  : 		_Val_types;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _List_val
; 499  : template<class _Val_types>
; 500  : 	class _List_val
; 501  : 		: public _Container_base
; 502  : 	{	// base class for list to hold data
; 503  : public:
; 504  : 	typedef _List_val<_Val_types> _Myt;
; 505  : 
; 506  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 507  : 	typedef _Nodeptr& _Nodepref;
; 508  : 
; 509  : 	typedef typename _Val_types::value_type value_type;
; 510  : 	typedef typename _Val_types::size_type size_type;
; 511  : 	typedef typename _Val_types::difference_type difference_type;
; 512  : 	typedef typename _Val_types::pointer pointer;
; 513  : 	typedef typename _Val_types::const_pointer const_pointer;
; 514  : 	typedef typename _Val_types::reference reference;
; 515  : 	typedef typename _Val_types::const_reference const_reference;
; 516  : 
; 517  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 518  : 	typedef _List_iterator<_Myt> iterator;
; 519  : 
; 520  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 521  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 522  : 
; 523  : 	_List_val()
; 524  : 		{	// initialize data
; 525  : 		this->_Myhead = 0;
; 526  : 		this->_Mysize = 0;
; 527  : 		}
; 528  : 
; 529  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 530  : 		{	// return reference to successor pointer in node
; 531  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 371  : 		++(*(_Mybase *)this);
; 372  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 373  : 		}

  00008	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEAAU_EVENT_TIME@CBloodCastle@@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEAAU_EVENT_TIME@CBloodCastle@@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 363  : 
; 364  : 	pointer operator->() const
; 365  : 		{	// return pointer to class object
; 366  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 367  : 		}
; 368  : 
; 369  : 	_Myiter& operator++()
; 370  : 		{	// preincrement
; 371  : 		++(*(_Mybase *)this);
; 372  : 		return (*this);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator++(int)
; 376  : 		{	// postincrement
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		++*this;
; 379  : 		return (_Tmp);
; 380  : 		}
; 381  : 
; 382  : 	_Myiter& operator--()
; 383  : 		{	// predecrement
; 384  : 		--(*(_Mybase *)this);
; 385  : 		return (*this);
; 386  : 		}
; 387  : 
; 388  : 	_Myiter operator--(int)
; 389  : 		{	// postdecrement
; 390  : 		_Myiter _Tmp = *this;
; 391  : 		--*this;
; 392  : 		return (_Tmp);
; 393  : 		}
; 394  : 	};
; 395  : 
; 396  : template<class _Mylist> inline
; 397  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 398  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 399  : 	{	// convert to unchecked
; 400  : 	return (_Iter._Unchecked());
; 401  : 	}
; 402  : 
; 403  : template<class _Mylist> inline
; 404  : 	_List_iterator<_Mylist>&
; 405  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 406  : 			typename _List_iterator<_Mylist>
; 407  : 				::_Unchecked_type _Right)
; 408  : 	{	// convert to checked
; 409  : 	return (_Iter._Rechecked(_Right));
; 410  : 	}
; 411  : 
; 412  : 		// list TYPE WRAPPERS
; 413  : template<class _Value_type,
; 414  : 	class _Size_type,
; 415  : 	class _Difference_type,
; 416  : 	class _Pointer,
; 417  : 	class _Const_pointer,
; 418  : 	class _Reference,
; 419  : 	class _Const_reference,
; 420  : 	class _Nodeptr_type>
; 421  : 	struct _List_iter_types
; 422  : 	{	// wraps types needed by iterators
; 423  : 	typedef _Value_type value_type;
; 424  : 	typedef _Size_type size_type;
; 425  : 	typedef _Difference_type difference_type;
; 426  : 	typedef _Pointer pointer;
; 427  : 	typedef _Const_pointer const_pointer;
; 428  : 	typedef _Reference reference;
; 429  : 	typedef _Const_reference const_reference;
; 430  : 	typedef _Nodeptr_type _Nodeptr;
; 431  : 	};
; 432  : 
; 433  : template<class _Value_type,
; 434  : 	class _Voidptr>
; 435  : 	struct _List_node
; 436  : 		{	// list node
; 437  : 		_Voidptr _Next;	// successor node, or first element if head
; 438  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 439  : 		_Value_type _Myval;	// the stored value, unused if head
; 440  : 
; 441  : 	private:
; 442  : 		_List_node& operator=(const _List_node&);
; 443  : 		};
; 444  : 
; 445  : template<class _Value_type>
; 446  : 	struct _List_node<_Value_type, void *>
; 447  : 		{	// list node
; 448  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 449  : 		_Nodeptr _Next;	// successor node, or first element if head
; 450  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 451  : 		_Value_type _Myval;	// the stored value, unused if head
; 452  : 
; 453  : 	private:
; 454  : 		_List_node& operator=(const _List_node&);
; 455  : 		};
; 456  : 
; 457  : template<class _Ty>
; 458  : 	struct _List_simple_types
; 459  : 		: public _Simple_types<_Ty>
; 460  : 	{	// wraps types needed by iterators
; 461  : 	typedef _List_node<_Ty, void *> _Node;
; 462  : 	typedef _Node *_Nodeptr;
; 463  : 	};
; 464  : 
; 465  : template<class _Ty,
; 466  : 	class _Alloc0>
; 467  : 	struct _List_base_types
; 468  : 	{	// types needed for a container base
; 469  : 	typedef _Alloc0 _Alloc;
; 470  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 471  : 
; 472  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 473  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 474  : 
; 475  : 
; 476  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 477  : 		_Voidptr;
; 478  : 	typedef _List_node<typename _Alty::value_type,
; 479  : 		_Voidptr> _Node;
; 480  : 
; 481  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 482  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 483  : 	typedef _Nodeptr& _Nodepref;
; 484  : 
; 485  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 486  : 		_List_simple_types<typename _Alty::value_type>,
; 487  : 		_List_iter_types<typename _Alty::value_type,
; 488  : 			typename _Alty::size_type,
; 489  : 			typename _Alty::difference_type,
; 490  : 			typename _Alty::pointer,
; 491  : 			typename _Alty::const_pointer,
; 492  : 			typename _Alty::reference,
; 493  : 			typename _Alty::const_reference,
; 494  : 			_Nodeptr> >::type
; 495  : 		_Val_types;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _List_val
; 499  : template<class _Val_types>
; 500  : 	class _List_val
; 501  : 		: public _Container_base
; 502  : 	{	// base class for list to hold data
; 503  : public:
; 504  : 	typedef _List_val<_Val_types> _Myt;
; 505  : 
; 506  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 507  : 	typedef _Nodeptr& _Nodepref;
; 508  : 
; 509  : 	typedef typename _Val_types::value_type value_type;
; 510  : 	typedef typename _Val_types::size_type size_type;
; 511  : 	typedef typename _Val_types::difference_type difference_type;
; 512  : 	typedef typename _Val_types::pointer pointer;
; 513  : 	typedef typename _Val_types::const_pointer const_pointer;
; 514  : 	typedef typename _Val_types::reference reference;
; 515  : 	typedef typename _Val_types::const_reference const_reference;
; 516  : 
; 517  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 518  : 	typedef _List_iterator<_Myt> iterator;
; 519  : 
; 520  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 521  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 522  : 
; 523  : 	_List_val()
; 524  : 		{	// initialize data
; 525  : 		this->_Myhead = 0;
; 526  : 		this->_Mysize = 0;
; 527  : 		}
; 528  : 
; 529  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 530  : 		{	// return reference to successor pointer in node
; 531  : 		return ((_Nodepref)_Pnode->_Next);
; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);
; 537  : 		}
; 538  : 
; 539  : 	static reference _Myval(_Nodeptr _Pnode)
; 540  : 		{	// return reference to value in node
; 541  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 361  : 		return ((reference)**(_Mybase *)this);
; 362  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEAAU_EVENT_TIME@CBloodCastle@@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 343  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 344  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 338  : 		{	// construct with null node
; 339  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::_List_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 300  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 296  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]

; 301  : 		return (!(*this == _Right));

  00005	33 c0		 xor	 eax, eax

; 296  : 		return (this->_Ptr == _Right._Ptr);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]

; 301  : 		return (!(*this == _Right));

  0000c	0f 95 c0	 setne	 al

; 302  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 284  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() != _Right._Getcont())
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("list iterators incompatible");
; 289  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 290  : 			}
; 291  : 
; 292  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 293  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 294  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 295  : 
; 296  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	33 c0		 xor	 eax, eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000c	0f 94 c0	 sete	 al

; 297  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() != _Right._Getcont())
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("list iterators incompatible");
; 289  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 290  : 			}
; 291  : 
; 292  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 293  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 294  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 295  : 
; 296  : 		return (this->_Ptr == _Right._Ptr);
; 297  : 		}
; 298  : 
; 299  : 	bool operator!=(const _Myiter& _Right) const
; 300  : 		{	// test for iterator inequality
; 301  : 		return (!(*this == _Right));
; 302  : 		}
; 303  : 	};
; 304  : 
; 305  : template<class _Mylist> inline
; 306  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 307  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 308  : 	{	// convert to unchecked
; 309  : 	return (_Iter._Unchecked());
; 310  : 	}
; 311  : 
; 312  : template<class _Mylist> inline
; 313  : 	_List_const_iterator<_Mylist>&
; 314  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 315  : 			typename _List_const_iterator<_Mylist>
; 316  : 				::_Unchecked_type _Right)
; 317  : 	{	// convert to checked
; 318  : 	return (_Iter._Rechecked(_Right));
; 319  : 	}
; 320  : 
; 321  : 	// TEMPLATE CLASS _List_iterator
; 322  : template<class _Mylist>
; 323  : 	class _List_iterator
; 324  : 		: public _List_const_iterator<_Mylist>
; 325  : 	{	// iterator for mutable list
; 326  : public:
; 327  : 	typedef _List_iterator<_Mylist> _Myiter;
; 328  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 329  : 	typedef bidirectional_iterator_tag iterator_category;
; 330  : 
; 331  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 332  : 	typedef typename _Mylist::value_type value_type;
; 333  : 	typedef typename _Mylist::difference_type difference_type;
; 334  : 	typedef typename _Mylist::pointer pointer;
; 335  : 	typedef typename _Mylist::reference reference;
; 336  : 
; 337  : 	_List_iterator()
; 338  : 		{	// construct with null node
; 339  : 		}
; 340  : 
; 341  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 342  : 		: _Mybase(_Pnode, _Plist)
; 343  : 		{	// construct with node pointer _Pnode
; 344  : 		}
; 345  : 
; 346  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 347  : 
; 348  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 349  : 		{	// reset from unchecked iterator
; 350  : 		this->_Ptr = _Right._Ptr;
; 351  : 		return (*this);
; 352  : 		}
; 353  : 
; 354  : 	_Unchecked_type _Unchecked() const
; 355  : 		{	// make an unchecked iterator
; 356  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 357  : 		}
; 358  : 
; 359  : 	reference operator*() const
; 360  : 		{	// return designated value
; 361  : 		return ((reference)**(_Mybase *)this);
; 362  : 		}
; 363  : 
; 364  : 	pointer operator->() const
; 365  : 		{	// return pointer to class object
; 366  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 367  : 		}
; 368  : 
; 369  : 	_Myiter& operator++()
; 370  : 		{	// preincrement
; 371  : 		++(*(_Mybase *)this);
; 372  : 		return (*this);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator++(int)
; 376  : 		{	// postincrement
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		++*this;
; 379  : 		return (_Tmp);
; 380  : 		}
; 381  : 
; 382  : 	_Myiter& operator--()
; 383  : 		{	// predecrement
; 384  : 		--(*(_Mybase *)this);
; 385  : 		return (*this);
; 386  : 		}
; 387  : 
; 388  : 	_Myiter operator--(int)
; 389  : 		{	// postdecrement
; 390  : 		_Myiter _Tmp = *this;
; 391  : 		--*this;
; 392  : 		return (_Tmp);
; 393  : 		}
; 394  : 	};
; 395  : 
; 396  : template<class _Mylist> inline
; 397  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 398  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 399  : 	{	// convert to unchecked
; 400  : 	return (_Iter._Unchecked());
; 401  : 	}
; 402  : 
; 403  : template<class _Mylist> inline
; 404  : 	_List_iterator<_Mylist>&
; 405  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 406  : 			typename _List_iterator<_Mylist>
; 407  : 				::_Unchecked_type _Right)
; 408  : 	{	// convert to checked
; 409  : 	return (_Iter._Rechecked(_Right));
; 410  : 	}
; 411  : 
; 412  : 		// list TYPE WRAPPERS
; 413  : template<class _Value_type,
; 414  : 	class _Size_type,
; 415  : 	class _Difference_type,
; 416  : 	class _Pointer,
; 417  : 	class _Const_pointer,
; 418  : 	class _Reference,
; 419  : 	class _Const_reference,
; 420  : 	class _Nodeptr_type>
; 421  : 	struct _List_iter_types
; 422  : 	{	// wraps types needed by iterators
; 423  : 	typedef _Value_type value_type;
; 424  : 	typedef _Size_type size_type;
; 425  : 	typedef _Difference_type difference_type;
; 426  : 	typedef _Pointer pointer;
; 427  : 	typedef _Const_pointer const_pointer;
; 428  : 	typedef _Reference reference;
; 429  : 	typedef _Const_reference const_reference;
; 430  : 	typedef _Nodeptr_type _Nodeptr;
; 431  : 	};
; 432  : 
; 433  : template<class _Value_type,
; 434  : 	class _Voidptr>
; 435  : 	struct _List_node
; 436  : 		{	// list node
; 437  : 		_Voidptr _Next;	// successor node, or first element if head
; 438  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 439  : 		_Value_type _Myval;	// the stored value, unused if head
; 440  : 
; 441  : 	private:
; 442  : 		_List_node& operator=(const _List_node&);
; 443  : 		};
; 444  : 
; 445  : template<class _Value_type>
; 446  : 	struct _List_node<_Value_type, void *>
; 447  : 		{	// list node
; 448  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 449  : 		_Nodeptr _Next;	// successor node, or first element if head
; 450  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 451  : 		_Value_type _Myval;	// the stored value, unused if head
; 452  : 
; 453  : 	private:
; 454  : 		_List_node& operator=(const _List_node&);
; 455  : 		};
; 456  : 
; 457  : template<class _Ty>
; 458  : 	struct _List_simple_types
; 459  : 		: public _Simple_types<_Ty>
; 460  : 	{	// wraps types needed by iterators
; 461  : 	typedef _List_node<_Ty, void *> _Node;
; 462  : 	typedef _Node *_Nodeptr;
; 463  : 	};
; 464  : 
; 465  : template<class _Ty,
; 466  : 	class _Alloc0>
; 467  : 	struct _List_base_types
; 468  : 	{	// types needed for a container base
; 469  : 	typedef _Alloc0 _Alloc;
; 470  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 471  : 
; 472  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 473  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 474  : 
; 475  : 
; 476  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 477  : 		_Voidptr;
; 478  : 	typedef _List_node<typename _Alty::value_type,
; 479  : 		_Voidptr> _Node;
; 480  : 
; 481  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 482  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 483  : 	typedef _Nodeptr& _Nodepref;
; 484  : 
; 485  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 486  : 		_List_simple_types<typename _Alty::value_type>,
; 487  : 		_List_iter_types<typename _Alty::value_type,
; 488  : 			typename _Alty::size_type,
; 489  : 			typename _Alty::difference_type,
; 490  : 			typename _Alty::pointer,
; 491  : 			typename _Alty::const_pointer,
; 492  : 			typename _Alty::reference,
; 493  : 			typename _Alty::const_reference,
; 494  : 			_Nodeptr> >::type
; 495  : 		_Val_types;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _List_val
; 499  : template<class _Val_types>
; 500  : 	class _List_val
; 501  : 		: public _Container_base
; 502  : 	{	// base class for list to hold data
; 503  : public:
; 504  : 	typedef _List_val<_Val_types> _Myt;
; 505  : 
; 506  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 507  : 	typedef _Nodeptr& _Nodepref;
; 508  : 
; 509  : 	typedef typename _Val_types::value_type value_type;
; 510  : 	typedef typename _Val_types::size_type size_type;
; 511  : 	typedef typename _Val_types::difference_type difference_type;
; 512  : 	typedef typename _Val_types::pointer pointer;
; 513  : 	typedef typename _Val_types::const_pointer const_pointer;
; 514  : 	typedef typename _Val_types::reference reference;
; 515  : 	typedef typename _Val_types::const_reference const_reference;
; 516  : 
; 517  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 518  : 	typedef _List_iterator<_Myt> iterator;
; 519  : 
; 520  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 521  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 522  : 
; 523  : 	_List_val()
; 524  : 		{	// initialize data
; 525  : 		this->_Myhead = 0;
; 526  : 		this->_Mysize = 0;
; 527  : 		}
; 528  : 
; 529  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 530  : 		{	// return reference to successor pointer in node
; 531  : 		return ((_Nodepref)_Pnode->_Next);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00002	8b 00		 mov	 eax, DWORD PTR [eax]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 241  : 		return (*this);

  00006	8b c1		 mov	 eax, ecx

; 242  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABU_EVENT_TIME@CBloodCastle@@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABU_EVENT_TIME@CBloodCastle@@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() != _Right._Getcont())
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("list iterators incompatible");
; 289  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 290  : 			}
; 291  : 
; 292  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 293  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 294  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 295  : 
; 296  : 		return (this->_Ptr == _Right._Ptr);
; 297  : 		}
; 298  : 
; 299  : 	bool operator!=(const _Myiter& _Right) const
; 300  : 		{	// test for iterator inequality
; 301  : 		return (!(*this == _Right));
; 302  : 		}
; 303  : 	};
; 304  : 
; 305  : template<class _Mylist> inline
; 306  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 307  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 308  : 	{	// convert to unchecked
; 309  : 	return (_Iter._Unchecked());
; 310  : 	}
; 311  : 
; 312  : template<class _Mylist> inline
; 313  : 	_List_const_iterator<_Mylist>&
; 314  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 315  : 			typename _List_const_iterator<_Mylist>
; 316  : 				::_Unchecked_type _Right)
; 317  : 	{	// convert to checked
; 318  : 	return (_Iter._Rechecked(_Right));
; 319  : 	}
; 320  : 
; 321  : 	// TEMPLATE CLASS _List_iterator
; 322  : template<class _Mylist>
; 323  : 	class _List_iterator
; 324  : 		: public _List_const_iterator<_Mylist>
; 325  : 	{	// iterator for mutable list
; 326  : public:
; 327  : 	typedef _List_iterator<_Mylist> _Myiter;
; 328  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 329  : 	typedef bidirectional_iterator_tag iterator_category;
; 330  : 
; 331  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 332  : 	typedef typename _Mylist::value_type value_type;
; 333  : 	typedef typename _Mylist::difference_type difference_type;
; 334  : 	typedef typename _Mylist::pointer pointer;
; 335  : 	typedef typename _Mylist::reference reference;
; 336  : 
; 337  : 	_List_iterator()
; 338  : 		{	// construct with null node
; 339  : 		}
; 340  : 
; 341  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 342  : 		: _Mybase(_Pnode, _Plist)
; 343  : 		{	// construct with node pointer _Pnode
; 344  : 		}
; 345  : 
; 346  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 347  : 
; 348  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 349  : 		{	// reset from unchecked iterator
; 350  : 		this->_Ptr = _Right._Ptr;
; 351  : 		return (*this);
; 352  : 		}
; 353  : 
; 354  : 	_Unchecked_type _Unchecked() const
; 355  : 		{	// make an unchecked iterator
; 356  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 357  : 		}
; 358  : 
; 359  : 	reference operator*() const
; 360  : 		{	// return designated value
; 361  : 		return ((reference)**(_Mybase *)this);
; 362  : 		}
; 363  : 
; 364  : 	pointer operator->() const
; 365  : 		{	// return pointer to class object
; 366  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 367  : 		}
; 368  : 
; 369  : 	_Myiter& operator++()
; 370  : 		{	// preincrement
; 371  : 		++(*(_Mybase *)this);
; 372  : 		return (*this);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator++(int)
; 376  : 		{	// postincrement
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		++*this;
; 379  : 		return (_Tmp);
; 380  : 		}
; 381  : 
; 382  : 	_Myiter& operator--()
; 383  : 		{	// predecrement
; 384  : 		--(*(_Mybase *)this);
; 385  : 		return (*this);
; 386  : 		}
; 387  : 
; 388  : 	_Myiter operator--(int)
; 389  : 		{	// postdecrement
; 390  : 		_Myiter _Tmp = *this;
; 391  : 		--*this;
; 392  : 		return (_Tmp);
; 393  : 		}
; 394  : 	};
; 395  : 
; 396  : template<class _Mylist> inline
; 397  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 398  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 399  : 	{	// convert to unchecked
; 400  : 	return (_Iter._Unchecked());
; 401  : 	}
; 402  : 
; 403  : template<class _Mylist> inline
; 404  : 	_List_iterator<_Mylist>&
; 405  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 406  : 			typename _List_iterator<_Mylist>
; 407  : 				::_Unchecked_type _Right)
; 408  : 	{	// convert to checked
; 409  : 	return (_Iter._Rechecked(_Right));
; 410  : 	}
; 411  : 
; 412  : 		// list TYPE WRAPPERS
; 413  : template<class _Value_type,
; 414  : 	class _Size_type,
; 415  : 	class _Difference_type,
; 416  : 	class _Pointer,
; 417  : 	class _Const_pointer,
; 418  : 	class _Reference,
; 419  : 	class _Const_reference,
; 420  : 	class _Nodeptr_type>
; 421  : 	struct _List_iter_types
; 422  : 	{	// wraps types needed by iterators
; 423  : 	typedef _Value_type value_type;
; 424  : 	typedef _Size_type size_type;
; 425  : 	typedef _Difference_type difference_type;
; 426  : 	typedef _Pointer pointer;
; 427  : 	typedef _Const_pointer const_pointer;
; 428  : 	typedef _Reference reference;
; 429  : 	typedef _Const_reference const_reference;
; 430  : 	typedef _Nodeptr_type _Nodeptr;
; 431  : 	};
; 432  : 
; 433  : template<class _Value_type,
; 434  : 	class _Voidptr>
; 435  : 	struct _List_node
; 436  : 		{	// list node
; 437  : 		_Voidptr _Next;	// successor node, or first element if head
; 438  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 439  : 		_Value_type _Myval;	// the stored value, unused if head
; 440  : 
; 441  : 	private:
; 442  : 		_List_node& operator=(const _List_node&);
; 443  : 		};
; 444  : 
; 445  : template<class _Value_type>
; 446  : 	struct _List_node<_Value_type, void *>
; 447  : 		{	// list node
; 448  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 449  : 		_Nodeptr _Next;	// successor node, or first element if head
; 450  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 451  : 		_Value_type _Myval;	// the stored value, unused if head
; 452  : 
; 453  : 	private:
; 454  : 		_List_node& operator=(const _List_node&);
; 455  : 		};
; 456  : 
; 457  : template<class _Ty>
; 458  : 	struct _List_simple_types
; 459  : 		: public _Simple_types<_Ty>
; 460  : 	{	// wraps types needed by iterators
; 461  : 	typedef _List_node<_Ty, void *> _Node;
; 462  : 	typedef _Node *_Nodeptr;
; 463  : 	};
; 464  : 
; 465  : template<class _Ty,
; 466  : 	class _Alloc0>
; 467  : 	struct _List_base_types
; 468  : 	{	// types needed for a container base
; 469  : 	typedef _Alloc0 _Alloc;
; 470  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 471  : 
; 472  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 473  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 474  : 
; 475  : 
; 476  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 477  : 		_Voidptr;
; 478  : 	typedef _List_node<typename _Alty::value_type,
; 479  : 		_Voidptr> _Node;
; 480  : 
; 481  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 482  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 483  : 	typedef _Nodeptr& _Nodepref;
; 484  : 
; 485  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 486  : 		_List_simple_types<typename _Alty::value_type>,
; 487  : 		_List_iter_types<typename _Alty::value_type,
; 488  : 			typename _Alty::size_type,
; 489  : 			typename _Alty::difference_type,
; 490  : 			typename _Alty::pointer,
; 491  : 			typename _Alty::const_pointer,
; 492  : 			typename _Alty::reference,
; 493  : 			typename _Alty::const_reference,
; 494  : 			_Nodeptr> >::type
; 495  : 		_Val_types;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _List_val
; 499  : template<class _Val_types>
; 500  : 	class _List_val
; 501  : 		: public _Container_base
; 502  : 	{	// base class for list to hold data
; 503  : public:
; 504  : 	typedef _List_val<_Val_types> _Myt;
; 505  : 
; 506  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 507  : 	typedef _Nodeptr& _Nodepref;
; 508  : 
; 509  : 	typedef typename _Val_types::value_type value_type;
; 510  : 	typedef typename _Val_types::size_type size_type;
; 511  : 	typedef typename _Val_types::difference_type difference_type;
; 512  : 	typedef typename _Val_types::pointer pointer;
; 513  : 	typedef typename _Val_types::const_pointer const_pointer;
; 514  : 	typedef typename _Val_types::reference reference;
; 515  : 	typedef typename _Val_types::const_reference const_reference;
; 516  : 
; 517  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 518  : 	typedef _List_iterator<_Myt> iterator;
; 519  : 
; 520  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 521  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 522  : 
; 523  : 	_List_val()
; 524  : 		{	// initialize data
; 525  : 		this->_Myhead = 0;
; 526  : 		this->_Mysize = 0;
; 527  : 		}
; 528  : 
; 529  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 530  : 		{	// return reference to successor pointer in node
; 531  : 		return ((_Nodepref)_Pnode->_Next);
; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);
; 537  : 		}
; 538  : 
; 539  : 	static reference _Myval(_Nodeptr _Pnode)
; 540  : 		{	// return reference to value in node
; 541  : 		return ((reference)_Pnode->_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 08	 add	 eax, 8

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABU_EVENT_TIME@CBloodCastle@@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 188  : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 183  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 96   : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 97   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 40   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_BloodCastle@@YAXXZ
text$yd	SEGMENT
??__Fg_BloodCastle@@YAXXZ PROC				; `dynamic atexit destructor for 'g_BloodCastle'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00005	e9 00 00 00 00	 jmp	 ??1CBloodCastle@@UAE@XZ	; CBloodCastle::~CBloodCastle
??__Fg_BloodCastle@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_BloodCastle''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ??__Eg_BloodCastle@@YAXXZ
text$di	SEGMENT
??__Eg_BloodCastle@@YAXXZ PROC				; `dynamic initializer for 'g_BloodCastle'', COMDAT

; 30   : CBloodCastle g_BloodCastle;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00005	e8 00 00 00 00	 call	 ??0CBloodCastle@@QAE@XZ	; CBloodCastle::CBloodCastle
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_BloodCastle@@YAXXZ ; `dynamic atexit destructor for 'g_BloodCastle''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_BloodCastle@@YAXXZ ENDP				; `dynamic initializer for 'g_BloodCastle''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\user.h
;	COMDAT ??__FObjectStruct@@YAXXZ
text$yd	SEGMENT
??__FObjectStruct@@YAXXZ PROC				; `dynamic atexit destructor for 'ObjectStruct'', COMDAT

; 1377 : 	virtual ~CObjectStruct(){};

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ObjectStruct@@3VCObjectStruct@@A, OFFSET ??_7CObjectStruct@@6B@ ; ObjectStruct
  0000a	c3		 ret	 0
??__FObjectStruct@@YAXXZ ENDP				; `dynamic atexit destructor for 'ObjectStruct''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ??__EObjectStruct@@YAXXZ
text$di	SEGMENT
??__EObjectStruct@@YAXXZ PROC				; `dynamic initializer for 'ObjectStruct'', COMDAT

; 29   : CObjectStruct ObjectStruct;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ObjectStruct@@3VCObjectStruct@@A ; ObjectStruct
  00005	e8 00 00 00 00	 call	 ??0CObjectStruct@@QAE@XZ ; CObjectStruct::CObjectStruct
  0000a	68 00 00 00 00	 push	 OFFSET ??__FObjectStruct@@YAXXZ ; `dynamic atexit destructor for 'ObjectStruct''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EObjectStruct@@YAXXZ ENDP				; `dynamic initializer for 'ObjectStruct''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	int ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA, 0
  00017	53		 push	 ebx
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8b d8		 mov	 ebx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	83 fb ff	 cmp	 ebx, -1
  00033	74 5d		 je	 SHORT $LN43@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)
; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  00038	75 30		 jne	 SHORT $LN2@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00040	e8 00 00 00 00	 call	 _fgetc
  00045	8b d8		 mov	 ebx, eax
  00047	83 c4 04	 add	 esp, 4
  0004a	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  0004d	75 1b		 jne	 SHORT $LN2@GetToken
  0004f	90		 npad	 1
$LL5@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	83 fb ff	 cmp	 ebx, -1
  00053	74 3d		 je	 SHORT $LN43@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0005b	e8 00 00 00 00	 call	 _fgetc
  00060	8b d8		 mov	 ebx, eax
  00062	83 c4 04	 add	 esp, 4
  00065	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00068	75 e6		 jne	 SHORT $LL5@GetToken
$LN2@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _isspace
  00070	83 c4 04	 add	 esp, 4
  00073	85 c0		 test	 eax, eax
  00075	75 a9		 jne	 SHORT $LL4@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00077	8d 43 de	 lea	 eax, DWORD PTR [ebx-34]
  0007a	56		 push	 esi
  0007b	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  0007e	0f 87 89 01 00
	00		 ja	 $LN29@GetToken
  00084	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN58@GetToken[eax]
  0008b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN64@GetToken[eax*4]
$LN43@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE

  00092	b8 02 00 00 00	 mov	 eax, 2
  00097	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	33 cd		 xor	 ecx, ebp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN20@GetToken:
  000a6	5e		 pop	 esi

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000a7	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  000b1	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b6	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
$LN21@GetToken:
  000c5	5e		 pop	 esi

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000c6	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  000d0	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000d5	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN22@GetToken:
  000e4	5e		 pop	 esi

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000e5	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  000ef	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000f4	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f8	33 cd		 xor	 ecx, ebp
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN23@GetToken:
  00103	5e		 pop	 esi

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00104	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0010e	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  00113	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00114	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	33 cd		 xor	 ecx, ebp
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN24@GetToken:
  00122	5e		 pop	 esi

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00123	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  0012d	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  00132	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
$LN25@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00141	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00147	53		 push	 ebx
  00148	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  0014d	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00153	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  00156	e8 00 00 00 00	 call	 _getc
  0015b	8b d8		 mov	 ebx, eax
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	83 fb ff	 cmp	 ebx, -1
  00163	74 2f		 je	 SHORT $LN59@GetToken
$LL9@GetToken:
  00165	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00168	74 12		 je	 SHORT $LN26@GetToken
  0016a	53		 push	 ebx
  0016b	e8 00 00 00 00	 call	 _isdigit
  00170	83 c4 04	 add	 esp, 4
  00173	85 c0		 test	 eax, eax
  00175	75 05		 jne	 SHORT $LN26@GetToken
  00177	83 fb 2d	 cmp	 ebx, 45			; 0000002dH
  0017a	75 18		 jne	 SHORT $LN59@GetToken
$LN26@GetToken:
  0017c	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00182	88 1e		 mov	 BYTE PTR [esi], bl

; 102  : 			p++;

  00184	46		 inc	 esi
  00185	e8 00 00 00 00	 call	 _getc
  0018a	8b d8		 mov	 ebx, eax
  0018c	83 c4 04	 add	 esp, 4
  0018f	83 fb ff	 cmp	 ebx, -1
  00192	75 d1		 jne	 SHORT $LL9@GetToken
$LN59@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = (float)atof( TempString);	// Select the first Byte as Main ID

  00194	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  00197	c6 06 00	 mov	 BYTE PTR [esi], 0
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _atof
  001a0	83 c4 04	 add	 esp, 4

; 106  : 		return CurrentToken  = NUMBER ;

  001a3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  001ad	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA
  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  001ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bd	33 cd		 xor	 ecx, ebp
  001bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$LN27@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  001c8	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  001ce	be 00 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA
  001d3	e8 00 00 00 00	 call	 _getc
  001d8	83 c4 04	 add	 esp, 4
  001db	83 f8 ff	 cmp	 eax, -1
  001de	74 1f		 je	 SHORT $LN12@GetToken
$LL11@GetToken:
  001e0	83 f8 22	 cmp	 eax, 34			; 00000022H
  001e3	0f 84 95 00 00
	00		 je	 $LN28@GetToken
  001e9	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 113  : 		{
; 114  : 			*p = ch;

  001ef	88 06		 mov	 BYTE PTR [esi], al

; 115  : 			p++;

  001f1	46		 inc	 esi
  001f2	e8 00 00 00 00	 call	 _getc
  001f7	83 c4 04	 add	 esp, 4
  001fa	83 f8 ff	 cmp	 eax, -1
  001fd	75 e1		 jne	 SHORT $LL11@GetToken
$LN12@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001ff	83 f8 22	 cmp	 eax, 34			; 00000022H
  00202	74 7a		 je	 SHORT $LN28@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00204	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0020a	50		 push	 eax

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  0020b	eb 69		 jmp	 SHORT $LN62@GetToken
$LN29@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0020d	53		 push	 ebx
  0020e	e8 00 00 00 00	 call	 _isalpha
  00213	83 c4 04	 add	 esp, 4
  00216	85 c0		 test	 eax, eax
  00218	0f 84 7f 00 00
	00		 je	 $LN30@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  0021e	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00224	88 1d 00 00 00
	00		 mov	 BYTE PTR ?TokenString@@3PADA, bl
  0022a	be 01 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA+1
  0022f	e8 00 00 00 00	 call	 _getc
  00234	8b d8		 mov	 ebx, eax
  00236	83 c4 04	 add	 esp, 4
  00239	83 fb ff	 cmp	 ebx, -1
  0023c	74 31		 je	 SHORT $LN60@GetToken
  0023e	66 90		 npad	 2
$LL13@GetToken:
  00240	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00243	74 12		 je	 SHORT $LN32@GetToken
  00245	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00248	74 0d		 je	 SHORT $LN32@GetToken
  0024a	53		 push	 ebx
  0024b	e8 00 00 00 00	 call	 _isalnum
  00250	83 c4 04	 add	 esp, 4
  00253	85 c0		 test	 eax, eax
  00255	74 18		 je	 SHORT $LN60@GetToken
$LN32@GetToken:
  00257	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 133  : 			{
; 134  : 				*p=ch;

  0025d	88 1e		 mov	 BYTE PTR [esi], bl

; 135  : 				p++;

  0025f	46		 inc	 esi
  00260	e8 00 00 00 00	 call	 _getc
  00265	8b d8		 mov	 ebx, eax
  00267	83 c4 04	 add	 esp, 4
  0026a	83 fb ff	 cmp	 ebx, -1
  0026d	75 d1		 jne	 SHORT $LL13@GetToken
$LN60@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0026f	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00275	53		 push	 ebx
$LN62@GetToken:
  00276	e8 00 00 00 00	 call	 _ungetc
  0027b	83 c4 08	 add	 esp, 8
$LN28@GetToken:

; 140  : 			*p=0;

  0027e	c6 06 00	 mov	 BYTE PTR [esi], 0

; 141  : 			CurrentToken=NAME;
; 142  : 			return CurrentToken;

  00281	33 c0		 xor	 eax, eax
  00283	5e		 pop	 esi
  00284	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0028e	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0028f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00292	33 cd		 xor	 ecx, ebp
  00294	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00299	8b e5		 mov	 esp, ebp
  0029b	5d		 pop	 ebp
  0029c	c3		 ret	 0
$LN30@GetToken:
  0029d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a0	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  002a5	5e		 pop	 esi
  002a6	33 cd		 xor	 ecx, ebp
  002a8	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  002b2	5b		 pop	 ebx
  002b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
$LN64@GetToken:
  002bc	00 00 00 00	 DD	 $LN27@GetToken
  002c0	00 00 00 00	 DD	 $LN20@GetToken
  002c4	00 00 00 00	 DD	 $LN22@GetToken
  002c8	00 00 00 00	 DD	 $LN25@GetToken
  002cc	00 00 00 00	 DD	 $LN21@GetToken
  002d0	00 00 00 00	 DD	 $LN23@GetToken
  002d4	00 00 00 00	 DD	 $LN24@GetToken
  002d8	00 00 00 00	 DD	 $LN29@GetToken
$LN58@GetToken:
  002dc	00		 DB	 0
  002dd	01		 DB	 1
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	07		 DB	 7
  002e2	07		 DB	 7
  002e3	07		 DB	 7
  002e4	07		 DB	 7
  002e5	07		 DB	 7
  002e6	02		 DB	 2
  002e7	03		 DB	 3
  002e8	03		 DB	 3
  002e9	07		 DB	 7
  002ea	03		 DB	 3
  002eb	03		 DB	 3
  002ec	03		 DB	 3
  002ed	03		 DB	 3
  002ee	03		 DB	 3
  002ef	03		 DB	 3
  002f0	03		 DB	 3
  002f1	03		 DB	 3
  002f2	03		 DB	 3
  002f3	03		 DB	 3
  002f4	07		 DB	 7
  002f5	04		 DB	 4
  002f6	07		 DB	 7
  002f7	07		 DB	 7
  002f8	07		 DB	 7
  002f9	07		 DB	 7
  002fa	07		 DB	 7
  002fb	07		 DB	 7
  002fc	07		 DB	 7
  002fd	07		 DB	 7
  002fe	07		 DB	 7
  002ff	07		 DB	 7
  00300	07		 DB	 7
  00301	07		 DB	 7
  00302	07		 DB	 7
  00303	07		 DB	 7
  00304	07		 DB	 7
  00305	07		 DB	 7
  00306	07		 DB	 7
  00307	07		 DB	 7
  00308	07		 DB	 7
  00309	07		 DB	 7
  0030a	07		 DB	 7
  0030b	07		 DB	 7
  0030c	07		 DB	 7
  0030d	07		 DB	 7
  0030e	07		 DB	 7
  0030f	07		 DB	 7
  00310	07		 DB	 7
  00311	07		 DB	 7
  00312	07		 DB	 7
  00313	07		 DB	 7
  00314	07		 DB	 7
  00315	07		 DB	 7
  00316	07		 DB	 7
  00317	07		 DB	 7
  00318	07		 DB	 7
  00319	07		 DB	 7
  0031a	07		 DB	 7
  0031b	07		 DB	 7
  0031c	07		 DB	 7
  0031d	07		 DB	 7
  0031e	07		 DB	 7
  0031f	07		 DB	 7
  00320	07		 DB	 7
  00321	07		 DB	 7
  00322	07		 DB	 7
  00323	07		 DB	 7
  00324	07		 DB	 7
  00325	07		 DB	 7
  00326	07		 DB	 7
  00327	07		 DB	 7
  00328	07		 DB	 7
  00329	07		 DB	 7
  0032a	07		 DB	 7
  0032b	07		 DB	 7
  0032c	07		 DB	 7
  0032d	07		 DB	 7
  0032e	07		 DB	 7
  0032f	07		 DB	 7
  00330	07		 DB	 7
  00331	07		 DB	 7
  00332	07		 DB	 7
  00333	07		 DB	 7
  00334	07		 DB	 7
  00335	05		 DB	 5
  00336	07		 DB	 7
  00337	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tnotice.h
;	COMDAT ?_ARGB@@YAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?_ARGB@@YAKEEEE@Z PROC					; _ARGB, COMDAT

; 9    : __inline DWORD _ARGB(BYTE a, BYTE r, BYTE g, BYTE b){ return a*16777216 + b*65536 + g*256 + r;}; // in tnotice.h : line 8

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  00007	0f b6 4d 14	 movzx	 ecx, BYTE PTR _b$[ebp]
  0000b	c1 e0 08	 shl	 eax, 8
  0000e	03 c1		 add	 eax, ecx
  00010	0f b6 4d 10	 movzx	 ecx, BYTE PTR _g$[ebp]
  00014	c1 e0 08	 shl	 eax, 8
  00017	03 c1		 add	 eax, ecx
  00019	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _r$[ebp]
  0001d	c1 e0 08	 shl	 eax, 8
  00020	03 c1		 add	 eax, ecx
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_ARGB@@YAKEEEE@Z ENDP					; _ARGB
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCBloodCastle@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBloodCastle@@UAEPAXI@Z PROC			; CBloodCastle::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CBloodCastle@@UAE@XZ	; CBloodCastle::~CBloodCastle
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 88 10 00 00	 push	 4232			; 00001088H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCBloodCastle@@UAEPAXI@Z ENDP			; CBloodCastle::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Incsize@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXI@Z PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Incsize, COMDAT
; _this$ = ecx

; 1907 : 		{	// alter element count, with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1908 : 		if (max_size() - this->_Mysize() - 1 < _Count)

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	b8 fe ff ff 0f	 mov	 eax, 268435454		; 0ffffffeH
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  0000f	2b c2		 sub	 eax, edx
  00011	3b c6		 cmp	 eax, esi
  00013	72 0b		 jb	 SHORT $LN41@Incsize

; 1910 : 		this->_Mysize() += _Count;

  00015	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  00018	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0001b	5e		 pop	 esi

; 1911 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN41@Incsize:

; 1909 : 			_Xlength_error("list<T> too long");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00025	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@Incsize:
$LN40@Incsize:
  0002a	cc		 int	 3
?_Incsize@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXI@Z ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Incsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Tidy@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXXZ PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1884 : 		{	// free all storage

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 531  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 17		 mov	 edx, DWORD PTR [edi]

; 537  : 		}
; 538  : 
; 539  : 	static reference _Myval(_Nodeptr _Pnode)
; 540  : 		{	// return reference to value in node
; 541  : 		return ((reference)_Pnode->_Myval);
; 542  : 		}
; 543  : 
; 544  : 	_Nodeptr _Myhead;	// pointer to head node
; 545  : 	size_type _Mysize;	// number of elements
; 546  : 	};
; 547  : 
; 548  : 		// TEMPLATE CLASS _List_alloc
; 549  : template<class _Alloc_types>
; 550  : 	class _List_alloc
; 551  : 	{	// base class for list to hold allocator
; 552  : public:
; 553  : 	typedef _List_alloc<_Alloc_types> _Myt;
; 554  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 555  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 556  : 	typedef typename _Alloc_types::_Node _Node;
; 557  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 558  : 
; 559  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 560  : 
; 561  : 	typedef _Nodeptr& _Nodepref;
; 562  : 
; 563  : 	typedef typename _Val_types::value_type value_type;
; 564  : 	typedef typename _Val_types::size_type size_type;
; 565  : 	typedef typename _Val_types::difference_type difference_type;
; 566  : 	typedef typename _Val_types::pointer pointer;
; 567  : 	typedef typename _Val_types::const_pointer const_pointer;
; 568  : 	typedef typename _Val_types::reference reference;
; 569  : 	typedef typename _Val_types::const_reference const_reference;
; 570  : 
; 571  : 	typedef _List_const_iterator<_List_val<_Val_types> > const_iterator;
; 572  : 	typedef _List_iterator<_List_val<_Val_types> > iterator;
; 573  : 
; 574  : 	typedef _List_unchecked_const_iterator<_List_val<_Val_types> >
; 575  : 		_Unchecked_const_iterator;
; 576  : 	typedef _List_unchecked_iterator<_List_val<_Val_types> >
; 577  : 		_Unchecked_iterator;
; 578  : 
; 579  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 580  : 		{	// return reference to successor pointer in node
; 581  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));
; 582  : 		}
; 583  : 
; 584  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 585  : 		{	// return reference to predecessor pointer in node
; 586  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));
; 587  : 		}
; 588  : 
; 589  : 	static reference _Myval(_Nodeptr _Pnode)
; 590  : 		{	// return reference to value in node
; 591  : 		return (_List_val<_Val_types>::_Myval(_Pnode));
; 592  : 		}
; 593  : 
; 594  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 595  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 596  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 597  : 		{	// construct head node, allocator from _Al
; 598  : 		_Myhead() = _Buyheadnode();
; 599  : 		}
; 600  : 
; 601  : 	_List_alloc(_Alloc&& _Al)
; 602  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 603  : 		{	// construct head node, allocator from _Al
; 604  : 		_Myhead() = _Buyheadnode();
; 605  : 		}
; 606  : 
; 607  : 	~_List_alloc() _NOEXCEPT
; 608  : 		{	// destroy head node
; 609  : 		_Freeheadnode(_Myhead());
; 610  : 		}
; 611  : 
; 612  : 	void _Copy_alloc(const _Alty& _Al)
; 613  : 		{	// replace old allocator
; 614  : 		_Pocca(_Getal(), _Al);
; 615  : 		}
; 616  : 
; 617  : 	void _Move_alloc(_Alty& _Al)
; 618  : 		{	// replace old allocator
; 619  : 		_Pocma(_Getal(), _Al);
; 620  : 		}
; 621  : 
; 622  : 	void _Swap_alloc(_Myt& _Right)
; 623  : 		{	// swap allocators
; 624  : 		_Pocs(_Getal(), _Right._Getal());
; 625  : 		}
; 626  : 
; 627  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 628  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 629  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 630  : 		{	// construct head node, allocator from _Al
; 631  : 		_Myhead() = _Buyheadnode();
; 632  : 		_TRY_BEGIN
; 633  : 		_Alloc_proxy();
; 634  : 		_CATCH_ALL
; 635  : 		_Freeheadnode(_Myhead());
; 636  : 		_RERAISE;
; 637  : 		_CATCH_END
; 638  : 		}
; 639  : 
; 640  : 	_List_alloc(_Alloc&& _Al)
; 641  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 642  : 		{	// construct head node, allocator from _Al
; 643  : 		_Myhead() = _Buyheadnode();
; 644  : 		_TRY_BEGIN
; 645  : 		_Alloc_proxy();
; 646  : 		_CATCH_ALL
; 647  : 		_Freeheadnode(_Myhead());
; 648  : 		_RERAISE;
; 649  : 		_CATCH_END
; 650  : 		}
; 651  : 
; 652  : 	~_List_alloc() _NOEXCEPT
; 653  : 		{	// destroy proxy
; 654  : 		_Freeheadnode(_Myhead());
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Copy_alloc(const _Alty& _Al)
; 659  : 		{	// replace old allocator
; 660  : 		_Free_proxy();
; 661  : 		_Pocca(_Getal(), _Al);
; 662  : 		_Alloc_proxy();
; 663  : 		}
; 664  : 
; 665  : 	void _Move_alloc(_Alty& _Al)
; 666  : 		{	// replace old allocator
; 667  : 		_Free_proxy();
; 668  : 		_Pocma(_Getal(), _Al);
; 669  : 		_Alloc_proxy();
; 670  : 		}
; 671  : 
; 672  : 	void _Swap_alloc(_Myt& _Right)
; 673  : 		{	// swap allocators
; 674  : 		_Pocs(_Getal(), _Right._Getal());
; 675  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 676  : 		}
; 677  : 
; 678  : 	void _Alloc_proxy()
; 679  : 		{	// construct proxy
; 680  : 		typename _Alty::template rebind<_Container_proxy>::other
; 681  : 			_Alproxy(_Getal());
; 682  : 		_Myproxy() = _Alproxy.allocate(1);
; 683  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 684  : 		_Myproxy()->_Mycont = &_Get_data();
; 685  : 		}
; 686  : 
; 687  : 	void _Free_proxy()
; 688  : 		{	// destroy proxy
; 689  : 		typename _Alty::template rebind<_Container_proxy>::other
; 690  : 			_Alproxy(_Getal());
; 691  : 		_Orphan_all();
; 692  : 		_Alproxy.destroy(_Myproxy());
; 693  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 694  : 		_Myproxy() = 0;
; 695  : 		}
; 696  : 
; 697  : 	_Iterator_base12 **_Getpfirst() const
; 698  : 		{	// get address of iterator chain
; 699  : 		return (_Get_data()._Getpfirst());
; 700  : 		}
; 701  : 
; 702  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 703  : 		{	// return reference to _Myproxy
; 704  : 		return (_Get_data()._Myproxy);
; 705  : 		}
; 706  : 
; 707  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 708  : 		{	// return const reference to _Myproxy
; 709  : 		return (_Get_data()._Myproxy);
; 710  : 		}
; 711  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 712  : 
; 713  : 	_Nodeptr _Buyheadnode()
; 714  : 		{	// get head node using current allocator
; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 716  : 		}
; 717  : 
; 718  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 719  : 		{	// free head node using current allocator
; 720  : 		_Getal().destroy(
; 721  : 			_STD addressof(_Nextnode(_Pnode)));
; 722  : 		_Getal().destroy(
; 723  : 			_STD addressof(_Prevnode(_Pnode)));
; 724  : 		_Getal().deallocate(_Pnode, 1);
; 725  : 		}
; 726  : 
; 727  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 728  : 		_Nodeptr _Prev)
; 729  : 		{	// allocate a node and set links
; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);
; 731  : 
; 732  : 		if (_Next == _Nodeptr())
; 733  : 			{	// point at self
; 734  : 			_Next = _Pnode;
; 735  : 			_Prev = _Pnode;
; 736  : 			}
; 737  : 		_TRY_BEGIN
; 738  : 		_Getal().construct(
; 739  : 			_STD addressof(_Nextnode(_Pnode)), _Next);
; 740  : 		_Getal().construct(
; 741  : 			_STD addressof(_Prevnode(_Pnode)), _Prev);
; 742  : 		_CATCH_ALL
; 743  : 		_Getal().deallocate(_Pnode, 1);
; 744  : 		_RERAISE;
; 745  : 		_CATCH_END
; 746  : 
; 747  : 		return (_Pnode);
; 748  : 		}
; 749  : 
; 750  : 	void _Orphan_all()
; 751  : 		{	// orphan all iterators
; 752  : 		_Get_data()._Orphan_all();
; 753  : 		}
; 754  : 
; 755  : 	void _Swap_all(_Myt& _Right)
; 756  : 		{	// swap all iterators
; 757  : 		_Get_data()._Swap_all(_Right._Get_data());
; 758  : 		}
; 759  : 
; 760  : 	_Alty& _Getal() _NOEXCEPT
; 761  : 		{	// return reference to allocator
; 762  : 		return (_Mypair._Get_first());
; 763  : 		}
; 764  : 
; 765  : 	const _Alty& _Getal() const _NOEXCEPT
; 766  : 		{	// return const reference to allocator
; 767  : 		return (_Mypair._Get_first());
; 768  : 		}
; 769  : 
; 770  : 	_List_val<_Val_types>& _Get_data() _NOEXCEPT
; 771  : 		{	// return reference to _List_val
; 772  : 		return (_Mypair._Get_second());
; 773  : 		}
; 774  : 
; 775  : 	const _List_val<_Val_types>& _Get_data() const _NOEXCEPT
; 776  : 		{	// return const reference to _List_val
; 777  : 		return (_Mypair._Get_second());
; 778  : 		}
; 779  : 
; 780  : 	_Nodeptr& _Myhead() _NOEXCEPT
; 781  : 		{	// return reference to _Myhead
; 782  : 		return (_Get_data()._Myhead);
; 783  : 		}
; 784  : 
; 785  : 	const _Nodeptr& _Myhead() const _NOEXCEPT
; 786  : 		{	// return const reference to _Myhead
; 787  : 		return (_Get_data()._Myhead);
; 788  : 		}
; 789  : 
; 790  : 	size_type& _Mysize() _NOEXCEPT
; 791  : 		{	// return reference to _Mysize
; 792  : 		return (_Get_data()._Mysize);
; 793  : 		}
; 794  : 
; 795  : 	const size_type& _Mysize() const _NOEXCEPT
; 796  : 		{	// return const reference to _Mysize
; 797  : 		return (_Get_data()._Mysize);
; 798  : 		}
; 799  : 
; 800  : private:
; 801  : 	_Compressed_pair<_Alty, _List_val<_Val_types> > _Mypair;
; 802  : 	};
; 803  : 
; 804  : 		// TEMPLATE CLASS _List_buy
; 805  : template<class _Ty,
; 806  : 	class _Alloc>
; 807  : 	class _List_buy
; 808  : 		: public _List_alloc<_List_base_types<_Ty, _Alloc> >
; 809  : 	{	// base class for list to hold buynode/freenode functions
; 810  : public:
; 811  : 	typedef _List_alloc<_List_base_types<_Ty, _Alloc> > _Mybase;
; 812  : 	typedef typename _Mybase::_Alty _Alty;
; 813  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 814  : 
; 815  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from allocator
; 818  : 		}
; 819  : 
; 820  : 	_List_buy(_Alloc&& _Al)
; 821  : 		: _Mybase(_STD move(_Al))
; 822  : 		{	// construct from allocator
; 823  : 		}
; 824  : 
; 825  : 	template<class... _Valty>
; 826  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 827  : 			_Valty&&... _Val)
; 828  : 		{	// allocate a node and set links and value
; 829  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 830  : 
; 831  : 		_TRY_BEGIN
; 832  : 		this->_Getal().construct(
; 833  : 			_STD addressof(this->_Myval(_Pnode)),
; 834  : 				_STD forward<_Valty>(_Val)...);
; 835  : 		_CATCH_ALL
; 836  : 		this->_Getal().deallocate(_Pnode, 1);
; 837  : 		_RERAISE;
; 838  : 		_CATCH_END
; 839  : 
; 840  : 		return (_Pnode);
; 841  : 		}
; 842  : 
; 843  : 
; 844  : 	void _Freenode(_Nodeptr _Pnode)
; 845  : 		{	// give node back
; 846  : 		this->_Getal().destroy(
; 847  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 848  : 		this->_Getal().destroy(
; 849  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 850  : 		this->_Getal().destroy(
; 851  : 			_STD addressof(this->_Myval(_Pnode)));
; 852  : 		this->_Getal().deallocate(_Pnode, 1);
; 853  : 		}
; 854  : 	};
; 855  : 
; 856  : 		// TEMPLATE CLASS list
; 857  : template<class _Ty,
; 858  : 	class _Alloc = allocator<_Ty> >
; 859  : 	class list
; 860  : 		: public _List_buy<_Ty, _Alloc>
; 861  : 	{	// bidirectional linked list
; 862  : public:
; 863  : 	typedef list<_Ty, _Alloc> _Myt;
; 864  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 865  : 	typedef typename _Mybase::_Node _Node;
; 866  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 867  : 	typedef typename _Mybase::_Alty _Alty;
; 868  : 
; 869  : 	typedef _Alloc allocator_type;
; 870  : 	typedef typename _Mybase::size_type size_type;
; 871  : 	typedef typename _Mybase::difference_type difference_type;
; 872  : 	typedef typename _Mybase::pointer pointer;
; 873  : 	typedef typename _Mybase::const_pointer const_pointer;
; 874  : 	typedef typename _Mybase::reference reference;
; 875  : 	typedef typename _Mybase::const_reference const_reference;
; 876  : 	typedef typename _Mybase::value_type value_type;
; 877  : 
; 878  : 	typedef typename _Mybase::const_iterator const_iterator;
; 879  : 	typedef typename _Mybase::iterator iterator;
; 880  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 881  : 		_Unchecked_const_iterator;
; 882  : 	typedef typename _Mybase::_Unchecked_iterator
; 883  : 		_Unchecked_iterator;
; 884  : 
; 885  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 886  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 887  : 
; 888  : 	list()
; 889  : 		: _Mybase()
; 890  : 		{	// construct empty list
; 891  : 		}
; 892  : 
; 893  : 	explicit list(const _Alloc& _Al)
; 894  : 		: _Mybase(_Al)
; 895  : 		{	// construct empty list, allocator
; 896  : 		}
; 897  : 
; 898  : 	explicit list(size_type _Count)
; 899  : 		: _Mybase()
; 900  : 		{	// construct list from _Count * _Ty()
; 901  : 		resize(_Count);
; 902  : 		}
; 903  : 
; 904  : 	list(size_type _Count, const _Ty& _Val)
; 905  : 		: _Mybase()
; 906  : 		{	// construct list from _Count * _Val
; 907  : 		_Construct_n(_Count, _Val);
; 908  : 		}
; 909  : 
; 910  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 911  : 		: _Mybase(_Al)
; 912  : 		{	// construct list from _Count * _Val, allocator
; 913  : 		_Construct_n(_Count, _Val);
; 914  : 		}
; 915  : 
; 916  : 	list(const _Myt& _Right)
; 917  : 
; 918  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 919  : 
; 920  : 
; 921  : 		{	// construct list by copying _Right
; 922  : 		_TRY_BEGIN
; 923  : 		insert(begin(), _Right.begin(), _Right.end());
; 924  : 		_CATCH_ALL
; 925  : 		_Tidy();
; 926  : 		_RERAISE;
; 927  : 		_CATCH_END
; 928  : 		}
; 929  : 
; 930  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 931  : 		: _Mybase(_Al)
; 932  : 		{	// construct list by copying _Right, allocator
; 933  : 		_TRY_BEGIN
; 934  : 		insert(begin(), _Right.begin(), _Right.end());
; 935  : 		_CATCH_ALL
; 936  : 		_Tidy();
; 937  : 		_RERAISE;
; 938  : 		_CATCH_END
; 939  : 		}
; 940  : 
; 941  : 	template<class _Iter,
; 942  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 943  : 			void>::type>
; 944  : 		list(_Iter _First, _Iter _Last)
; 945  : 		: _Mybase()
; 946  : 		{	// construct list from [_First, _Last)
; 947  : 		_Construct(_First, _Last);
; 948  : 		}
; 949  : 
; 950  : 	template<class _Iter,
; 951  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 952  : 			void>::type>
; 953  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 954  : 		: _Mybase(_Al)
; 955  : 		{	// construct list, allocator from [_First, _Last)
; 956  : 		_Construct(_First, _Last);
; 957  : 		}
; 958  : 
; 959  : 	template<class _Iter>
; 960  : 		void _Construct(_Iter _First, _Iter _Last)
; 961  : 		{	// construct list from [_First, _Last), input iterators
; 962  : 		_TRY_BEGIN
; 963  : 		insert(begin(), _First, _Last);
; 964  : 		_CATCH_ALL
; 965  : 		_Tidy();
; 966  : 		_RERAISE;
; 967  : 		_CATCH_END
; 968  : 		}
; 969  : 
; 970  : 	void _Construct_n(size_type _Count,
; 971  : 		const _Ty& _Val)
; 972  : 		{	// construct from _Count * _Val
; 973  : 		_TRY_BEGIN
; 974  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 975  : 		_CATCH_ALL
; 976  : 		_Tidy();
; 977  : 		_RERAISE;
; 978  : 		_CATCH_END
; 979  : 		}
; 980  : 
; 981  : 	list(_Myt&& _Right)
; 982  : 		: _Mybase(_STD move(_Right._Getal()))
; 983  : 		{	// construct list by moving _Right
; 984  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 985  : 		}
; 986  : 
; 987  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 988  : 		: _Mybase(_Al)
; 989  : 		{	// construct list by moving _Right, allocator
; 990  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 991  : 		}
; 992  : 
; 993  : 	_Myt& operator=(_Myt&& _Right)
; 994  : 		_NOEXCEPT_OP(_Alty::is_always_equal::value)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Move_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1013 : 		_STD swap(this->_Mysize(), _Right._Mysize());
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != &this->_Get_data())
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);
; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;
; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
; 1066 : 		}
; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Copy_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead()),
; 1117 : 			&this->_Get_data()));
; 1118 : 		}
; 1119 : 
; 1120 : 	const_iterator begin() const _NOEXCEPT
; 1121 : 		{	// return iterator for beginning of nonmutable sequence
; 1122 : 		return (const_iterator(this->_Nextnode(this->_Myhead()),
; 1123 : 			&this->_Get_data()));
; 1124 : 		}
; 1125 : 
; 1126 : 	iterator end() _NOEXCEPT
; 1127 : 		{	// return iterator for end of mutable sequence
; 1128 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1129 : 		}
; 1130 : 
; 1131 : 	const_iterator end() const _NOEXCEPT
; 1132 : 		{	// return iterator for end of nonmutable sequence
; 1133 : 		return (const_iterator(this->_Myhead(), &this->_Get_data()));
; 1134 : 		}
; 1135 : 
; 1136 : 	_Unchecked_iterator _Unchecked_begin()
; 1137 : 		{	// return iterator for beginning of mutable sequence
; 1138 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead()),
; 1139 : 			&this->_Get_data()));
; 1140 : 		}
; 1141 : 
; 1142 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1143 : 		{	// return iterator for beginning of nonmutable sequence
; 1144 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead()),
; 1145 : 			&this->_Get_data()));
; 1146 : 		}
; 1147 : 
; 1148 : 	_Unchecked_iterator _Unchecked_end()
; 1149 : 		{	// return unchecked iterator for end of mutable sequence
; 1150 : 		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));
; 1151 : 		}
; 1152 : 
; 1153 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1154 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1155 : 		return (_Unchecked_const_iterator(this->_Myhead(),
; 1156 : 			&this->_Get_data()));
; 1157 : 		}
; 1158 : 
; 1159 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1160 : 		{	// make iterator from const_iterator
; 1161 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1162 : 		}
; 1163 : 
; 1164 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1165 : 		{	// make iterator from _Unchecked_const_iterator
; 1166 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1167 : 		}
; 1168 : 
; 1169 : 	reverse_iterator rbegin() _NOEXCEPT
; 1170 : 		{	// return iterator for beginning of reversed mutable sequence
; 1171 : 		return (reverse_iterator(end()));
; 1172 : 		}
; 1173 : 
; 1174 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1175 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1176 : 		return (const_reverse_iterator(end()));
; 1177 : 		}
; 1178 : 
; 1179 : 	reverse_iterator rend() _NOEXCEPT
; 1180 : 		{	// return iterator for end of reversed mutable sequence
; 1181 : 		return (reverse_iterator(begin()));
; 1182 : 		}
; 1183 : 
; 1184 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1185 : 		{	// return iterator for end of reversed nonmutable sequence
; 1186 : 		return (const_reverse_iterator(begin()));
; 1187 : 		}
; 1188 : 
; 1189 : 	const_iterator cbegin() const _NOEXCEPT
; 1190 : 		{	// return iterator for beginning of nonmutable sequence
; 1191 : 		return (begin());
; 1192 : 		}
; 1193 : 
; 1194 : 	const_iterator cend() const _NOEXCEPT
; 1195 : 		{	// return iterator for end of nonmutable sequence
; 1196 : 		return (end());
; 1197 : 		}
; 1198 : 
; 1199 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1200 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1201 : 		return (rbegin());
; 1202 : 		}
; 1203 : 
; 1204 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1205 : 		{	// return iterator for end of reversed nonmutable sequence
; 1206 : 		return (rend());
; 1207 : 		}
; 1208 : 
; 1209 : 	void resize(size_type _Newsize)
; 1210 : 		{	// determine new length, padding with _Ty() elements as needed
; 1211 : 		if (this->_Mysize() < _Newsize)
; 1212 : 			{	// pad to make larger
; 1213 : 			size_type _Count = 0;
; 1214 : 			_TRY_BEGIN
; 1215 : 			for (; this->_Mysize() < _Newsize; ++_Count)
; 1216 : 				_Insert(_Unchecked_end());
; 1217 : 			_CATCH_ALL
; 1218 : 			for (; 0 < _Count; --_Count)
; 1219 : 				pop_back();	// undo inserts
; 1220 : 			_RERAISE;
; 1221 : 			_CATCH_END
; 1222 : 			}
; 1223 : 		else
; 1224 : 			while (_Newsize < this->_Mysize())
; 1225 : 				pop_back();
; 1226 : 		}
; 1227 : 
; 1228 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1229 : 		{	// determine new length, padding with _Val elements as needed
; 1230 : 		if (this->_Mysize() < _Newsize)
; 1231 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize(), _Val);
; 1232 : 		else
; 1233 : 			while (_Newsize < this->_Mysize())
; 1234 : 				pop_back();
; 1235 : 		}
; 1236 : 
; 1237 : 	size_type size() const _NOEXCEPT
; 1238 : 		{	// return length of sequence
; 1239 : 		return (this->_Mysize());
; 1240 : 		}
; 1241 : 
; 1242 : 	size_type max_size() const _NOEXCEPT
; 1243 : 		{	// return maximum possible length of sequence
; 1244 : 		return (this->_Getal().max_size());
; 1245 : 		}
; 1246 : 
; 1247 : 	bool empty() const _NOEXCEPT
; 1248 : 		{	// test if sequence is empty
; 1249 : 		return (this->_Mysize() == 0);
; 1250 : 		}
; 1251 : 
; 1252 : 	allocator_type get_allocator() const _NOEXCEPT
; 1253 : 		{	// return allocator object for values
; 1254 : 		return (this->_Getal());
; 1255 : 		}
; 1256 : 
; 1257 : 	reference front()
; 1258 : 		{	// return first element of mutable sequence
; 1259 : 		return (*begin());
; 1260 : 		}
; 1261 : 
; 1262 : 	const_reference front() const
; 1263 : 		{	// return first element of nonmutable sequence
; 1264 : 		return (*begin());
; 1265 : 		}
; 1266 : 
; 1267 : 	reference back()
; 1268 : 		{	// return last element of mutable sequence
; 1269 : 		return (*(--end()));
; 1270 : 		}
; 1271 : 
; 1272 : 	const_reference back() const
; 1273 : 		{	// return last element of nonmutable sequence
; 1274 : 		return (*(--end()));
; 1275 : 		}
; 1276 : 
; 1277 : 	void push_front(const _Ty& _Val)
; 1278 : 		{	// insert element at beginning
; 1279 : 		_Insert(_Unchecked_begin(), _Val);
; 1280 : 		}
; 1281 : 
; 1282 : 	void pop_front()
; 1283 : 		{	// erase element at beginning
; 1284 : 		erase(begin());
; 1285 : 		}
; 1286 : 
; 1287 : 	void push_back(const _Ty& _Val)
; 1288 : 		{	// insert element at end
; 1289 : 		_Insert(_Unchecked_end(), _Val);
; 1290 : 		}
; 1291 : 
; 1292 : 	void pop_back()
; 1293 : 		{	// erase element at end
; 1294 : 		erase(--end());
; 1295 : 		}
; 1296 : 
; 1297 : 	template<class _Iter>
; 1298 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1299 : 			void>::type
; 1300 : 		assign(_Iter _First, _Iter _Last)
; 1301 : 		{	// assign [_First, _Last), input iterators
; 1302 : 		iterator _Old = begin();
; 1303 : 		_TRY_BEGIN
; 1304 : 		for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)
; 1305 : 			_Reusenode(_Old, *_First);
; 1306 : 		for (; _First != _Last; ++_First)
; 1307 : 			_Insert(_Unchecked_end(), *_First);
; 1308 : 		_CATCH_ALL
; 1309 : 		clear();
; 1310 : 		_RERAISE;
; 1311 : 		_CATCH_END
; 1312 : 		erase(_Old, end());
; 1313 : 		}
; 1314 : 
; 1315 : 	template<class _TArg>
; 1316 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1317 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1318 : 		_TRY_BEGIN
; 1319 : 		this->_Getal().destroy(
; 1320 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1321 : 		this->_Getal().construct(
; 1322 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1323 : 			_STD forward<_TArg>(_Arg));
; 1324 : 		_CATCH_ALL
; 1325 : 		_Unlinknode(_Where);
; 1326 : 		this->_Getal().destroy(
; 1327 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1328 : 		this->_Getal().destroy(
; 1329 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1330 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1331 : 		_RERAISE;
; 1332 : 		_CATCH_END
; 1333 : 		}
; 1334 : 
; 1335 : 	void assign(size_type _Count, const _Ty& _Val)
; 1336 : 		{	// assign _Count * _Val
; 1337 : 		clear();
; 1338 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1339 : 		}
; 1340 : 
; 1341 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1342 : 		{	// insert _Val at _Where
; 1343 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1344 : 		if (_Where._Getcont() != &this->_Get_data())
; 1345 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1346 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1347 : 
; 1348 : 		_Insert(_Where._Unchecked(), _Val);
; 1349 : 		return (_Make_iter(--_Where));
; 1350 : 		}
; 1351 : 
; 1352 : 	iterator insert(const_iterator _Where,
; 1353 : 		size_type _Count, const _Ty& _Val)
; 1354 : 		{	// insert _Count * _Val at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != &this->_Get_data())
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1364 : 			return (begin());
; 1365 : 			}
; 1366 : 		else
; 1367 : 			{	// insert sequence not at beginning
; 1368 : 			--_Prev;
; 1369 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1370 : 			return (++_Prev);
; 1371 : 			}
; 1372 : 		}
; 1373 : 
; 1374 : 	template<class _Iter>
; 1375 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1376 : 			iterator>::type
; 1377 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1378 : 		{	// insert [_First, _Last) at _Where
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_Where._Getcont() != &this->_Get_data())
; 1381 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1382 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1383 : 
; 1384 : 		iterator _Prev = _Make_iter(_Where);
; 1385 : 		if (_Prev == begin())
; 1386 : 			{	// insert sequence at beginning
; 1387 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1388 : 				_Iter_cat(_First));
; 1389 : 			return (begin());
; 1390 : 			}
; 1391 : 		else
; 1392 : 			{	// insert sequence not at beginning
; 1393 : 			--_Prev;
; 1394 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1395 : 				_Iter_cat(_First));
; 1396 : 			return (++_Prev);
; 1397 : 			}
; 1398 : 		}
; 1399 : 
; 1400 : 	template<class _Iter>
; 1401 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1402 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1403 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1404 : 		size_type _Num = 0;
; 1405 : 
; 1406 : 		_TRY_BEGIN
; 1407 : 		for (; _First != _Last; ++_First, (void)++_Num)
; 1408 : 			_Insert(_Where, *_First);
; 1409 : 		_CATCH_ALL
; 1410 : 		for (; 0 < _Num; --_Num)
; 1411 : 			{	// undo inserts
; 1412 : 			_Unchecked_const_iterator _Before = _Where;
; 1413 : 			_Unchecked_erase(--_Before);
; 1414 : 			}
; 1415 : 		_RERAISE;
; 1416 : 		_CATCH_END
; 1417 : 		}
; 1418 : 
; 1419 : 	template<class _Iter>
; 1420 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1421 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1422 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1423 : 		_DEBUG_RANGE(_First, _Last);
; 1424 : 		_Iter _Next = _First;
; 1425 : 
; 1426 : 		_TRY_BEGIN
; 1427 : 		for (; _First != _Last; ++_First)
; 1428 : 			_Insert(_Where, *_First);
; 1429 : 		_CATCH_ALL
; 1430 : 		for (; _Next != _First; ++_Next)
; 1431 : 			{	// undo inserts
; 1432 : 			_Unchecked_const_iterator _Before = _Where;
; 1433 : 			_Unchecked_erase(--_Before);
; 1434 : 			}
; 1435 : 		_RERAISE;
; 1436 : 		_CATCH_END
; 1437 : 		}
; 1438 : 
; 1439 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1440 : 		{	// unlink node at _Where from the list
; 1441 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1442 : 		if (_Where._Getcont() != &this->_Get_data()
; 1443 : 			|| _Where._Ptr == this->_Myhead())
; 1444 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1445 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1446 : 		_Orphan_ptr(_Pnode);
; 1447 : 
; 1448 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1449 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1453 : 			this->_Nextnode(_Pnode);
; 1454 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1455 : 			this->_Prevnode(_Pnode);
; 1456 : 
; 1457 : 		--this->_Mysize();
; 1458 : 		return (_Pnode);
; 1459 : 		}
; 1460 : 
; 1461 : 	iterator erase(const_iterator _Where)
; 1462 : 		{	// erase element at _Where
; 1463 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1464 : 		this->_Freenode(_Pnode);
; 1465 : 		return (_Make_iter(_Where));
; 1466 : 		}
; 1467 : 
; 1468 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1469 : 		{	// erase element at _Where
; 1470 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1471 : 
; 1472 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1473 : 			this->_Nextnode(_Pnode);
; 1474 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1475 : 			this->_Prevnode(_Pnode);
; 1476 : 		this->_Freenode(_Pnode);
; 1477 : 		--this->_Mysize();
; 1478 : 		}
; 1479 : 
; 1480 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1481 : 		{	// erase [_First, _Last)
; 1482 : 		if (_First == begin() && _Last == end())
; 1483 : 			{	// erase all and return fresh iterator
; 1484 : 			clear();
; 1485 : 			return (end());
; 1486 : 			}
; 1487 : 		else
; 1488 : 			{	// erase subrange
; 1489 : 			while (_First != _Last)
; 1490 : 				_First = erase(_First);
; 1491 : 			return (_Make_iter(_Last));
; 1492 : 			}
; 1493 : 		}
; 1494 : 
; 1495 : 	void clear() _NOEXCEPT
; 1496 : 		{	// erase all
; 1497 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1498 : 
; 1499 : 		this->_Orphan_ptr(nullptr);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

  00005	8b 02		 mov	 eax, DWORD PTR [edx]

; 1502 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

  00007	89 12		 mov	 DWORD PTR [edx], edx

; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);

  00009	8b 17		 mov	 edx, DWORD PTR [edi]

; 1503 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

  0000b	89 52 04	 mov	 DWORD PTR [edx+4], edx

; 1504 : 		this->_Mysize() = 0;

  0000e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  00015	3b 07		 cmp	 eax, DWORD PTR [edi]
  00017	74 19		 je	 SHORT $LN5@Tidy
  00019	56		 push	 esi
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL6@Tidy:

; 1507 : 			{	// delete an element
; 1508 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 30		 mov	 esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  0002b	8b c6		 mov	 eax, esi
  0002d	3b 37		 cmp	 esi, DWORD PTR [edi]
  0002f	75 ef		 jne	 SHORT $LL6@Tidy
  00031	5e		 pop	 esi
$LN5@Tidy:
  00032	5f		 pop	 edi

; 1885 : 		clear();
; 1886 : 		}

  00033	c3		 ret	 0
?_Tidy@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXXZ ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?clear@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXXZ PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::clear, COMDAT
; _this$ = ecx

; 1496 : 		{	// erase all

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 531  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 17		 mov	 edx, DWORD PTR [edi]

; 1497 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1498 : 
; 1499 : 		this->_Orphan_ptr(nullptr);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

  00005	8b 02		 mov	 eax, DWORD PTR [edx]

; 1502 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

  00007	89 12		 mov	 DWORD PTR [edx], edx

; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);

  00009	8b 17		 mov	 edx, DWORD PTR [edi]

; 1503 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

  0000b	89 52 04	 mov	 DWORD PTR [edx+4], edx

; 1504 : 		this->_Mysize() = 0;

  0000e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  00015	3b 07		 cmp	 eax, DWORD PTR [edi]
  00017	74 19		 je	 SHORT $LN3@clear
  00019	56		 push	 esi
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@clear:

; 1507 : 			{	// delete an element
; 1508 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 30		 mov	 esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  0002b	8b c6		 mov	 eax, esi
  0002d	3b 37		 cmp	 esi, DWORD PTR [edi]
  0002f	75 ef		 jne	 SHORT $LL4@clear
  00031	5e		 pop	 esi
$LN3@clear:
  00032	5f		 pop	 edi

; 1509 : 			this->_Freenode(_Pnode);
; 1510 : 			}
; 1511 : 		}

  00033	c3		 ret	 0
?clear@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXXZ ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?push_back@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXABU_EVENT_TIME@CBloodCastle@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXABU_EVENT_TIME@CBloodCastle@@@Z PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::push_back, COMDAT
; _this$ = ecx

; 1288 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);
; 537  : 		}
; 538  : 
; 539  : 	static reference _Myval(_Nodeptr _Pnode)
; 540  : 		{	// return reference to value in node
; 541  : 		return ((reference)_Pnode->_Myval);
; 542  : 		}
; 543  : 
; 544  : 	_Nodeptr _Myhead;	// pointer to head node
; 545  : 	size_type _Mysize;	// number of elements
; 546  : 	};
; 547  : 
; 548  : 		// TEMPLATE CLASS _List_alloc
; 549  : template<class _Alloc_types>
; 550  : 	class _List_alloc
; 551  : 	{	// base class for list to hold allocator
; 552  : public:
; 553  : 	typedef _List_alloc<_Alloc_types> _Myt;
; 554  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 555  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 556  : 	typedef typename _Alloc_types::_Node _Node;
; 557  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 558  : 
; 559  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 560  : 
; 561  : 	typedef _Nodeptr& _Nodepref;
; 562  : 
; 563  : 	typedef typename _Val_types::value_type value_type;
; 564  : 	typedef typename _Val_types::size_type size_type;
; 565  : 	typedef typename _Val_types::difference_type difference_type;
; 566  : 	typedef typename _Val_types::pointer pointer;
; 567  : 	typedef typename _Val_types::const_pointer const_pointer;
; 568  : 	typedef typename _Val_types::reference reference;
; 569  : 	typedef typename _Val_types::const_reference const_reference;
; 570  : 
; 571  : 	typedef _List_const_iterator<_List_val<_Val_types> > const_iterator;
; 572  : 	typedef _List_iterator<_List_val<_Val_types> > iterator;
; 573  : 
; 574  : 	typedef _List_unchecked_const_iterator<_List_val<_Val_types> >
; 575  : 		_Unchecked_const_iterator;
; 576  : 	typedef _List_unchecked_iterator<_List_val<_Val_types> >
; 577  : 		_Unchecked_iterator;
; 578  : 
; 579  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 580  : 		{	// return reference to successor pointer in node
; 581  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));
; 582  : 		}
; 583  : 
; 584  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 585  : 		{	// return reference to predecessor pointer in node
; 586  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));
; 587  : 		}
; 588  : 
; 589  : 	static reference _Myval(_Nodeptr _Pnode)
; 590  : 		{	// return reference to value in node
; 591  : 		return (_List_val<_Val_types>::_Myval(_Pnode));
; 592  : 		}
; 593  : 
; 594  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 595  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 596  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 597  : 		{	// construct head node, allocator from _Al
; 598  : 		_Myhead() = _Buyheadnode();
; 599  : 		}
; 600  : 
; 601  : 	_List_alloc(_Alloc&& _Al)
; 602  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 603  : 		{	// construct head node, allocator from _Al
; 604  : 		_Myhead() = _Buyheadnode();
; 605  : 		}
; 606  : 
; 607  : 	~_List_alloc() _NOEXCEPT
; 608  : 		{	// destroy head node
; 609  : 		_Freeheadnode(_Myhead());
; 610  : 		}
; 611  : 
; 612  : 	void _Copy_alloc(const _Alty& _Al)
; 613  : 		{	// replace old allocator
; 614  : 		_Pocca(_Getal(), _Al);
; 615  : 		}
; 616  : 
; 617  : 	void _Move_alloc(_Alty& _Al)
; 618  : 		{	// replace old allocator
; 619  : 		_Pocma(_Getal(), _Al);
; 620  : 		}
; 621  : 
; 622  : 	void _Swap_alloc(_Myt& _Right)
; 623  : 		{	// swap allocators
; 624  : 		_Pocs(_Getal(), _Right._Getal());
; 625  : 		}
; 626  : 
; 627  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 628  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 629  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 630  : 		{	// construct head node, allocator from _Al
; 631  : 		_Myhead() = _Buyheadnode();
; 632  : 		_TRY_BEGIN
; 633  : 		_Alloc_proxy();
; 634  : 		_CATCH_ALL
; 635  : 		_Freeheadnode(_Myhead());
; 636  : 		_RERAISE;
; 637  : 		_CATCH_END
; 638  : 		}
; 639  : 
; 640  : 	_List_alloc(_Alloc&& _Al)
; 641  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 642  : 		{	// construct head node, allocator from _Al
; 643  : 		_Myhead() = _Buyheadnode();
; 644  : 		_TRY_BEGIN
; 645  : 		_Alloc_proxy();
; 646  : 		_CATCH_ALL
; 647  : 		_Freeheadnode(_Myhead());
; 648  : 		_RERAISE;
; 649  : 		_CATCH_END
; 650  : 		}
; 651  : 
; 652  : 	~_List_alloc() _NOEXCEPT
; 653  : 		{	// destroy proxy
; 654  : 		_Freeheadnode(_Myhead());
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Copy_alloc(const _Alty& _Al)
; 659  : 		{	// replace old allocator
; 660  : 		_Free_proxy();
; 661  : 		_Pocca(_Getal(), _Al);
; 662  : 		_Alloc_proxy();
; 663  : 		}
; 664  : 
; 665  : 	void _Move_alloc(_Alty& _Al)
; 666  : 		{	// replace old allocator
; 667  : 		_Free_proxy();
; 668  : 		_Pocma(_Getal(), _Al);
; 669  : 		_Alloc_proxy();
; 670  : 		}
; 671  : 
; 672  : 	void _Swap_alloc(_Myt& _Right)
; 673  : 		{	// swap allocators
; 674  : 		_Pocs(_Getal(), _Right._Getal());
; 675  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 676  : 		}
; 677  : 
; 678  : 	void _Alloc_proxy()
; 679  : 		{	// construct proxy
; 680  : 		typename _Alty::template rebind<_Container_proxy>::other
; 681  : 			_Alproxy(_Getal());
; 682  : 		_Myproxy() = _Alproxy.allocate(1);
; 683  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 684  : 		_Myproxy()->_Mycont = &_Get_data();
; 685  : 		}
; 686  : 
; 687  : 	void _Free_proxy()
; 688  : 		{	// destroy proxy
; 689  : 		typename _Alty::template rebind<_Container_proxy>::other
; 690  : 			_Alproxy(_Getal());
; 691  : 		_Orphan_all();
; 692  : 		_Alproxy.destroy(_Myproxy());
; 693  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 694  : 		_Myproxy() = 0;
; 695  : 		}
; 696  : 
; 697  : 	_Iterator_base12 **_Getpfirst() const
; 698  : 		{	// get address of iterator chain
; 699  : 		return (_Get_data()._Getpfirst());
; 700  : 		}
; 701  : 
; 702  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 703  : 		{	// return reference to _Myproxy
; 704  : 		return (_Get_data()._Myproxy);
; 705  : 		}
; 706  : 
; 707  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 708  : 		{	// return const reference to _Myproxy
; 709  : 		return (_Get_data()._Myproxy);
; 710  : 		}
; 711  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 712  : 
; 713  : 	_Nodeptr _Buyheadnode()
; 714  : 		{	// get head node using current allocator
; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 716  : 		}
; 717  : 
; 718  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 719  : 		{	// free head node using current allocator
; 720  : 		_Getal().destroy(
; 721  : 			_STD addressof(_Nextnode(_Pnode)));
; 722  : 		_Getal().destroy(
; 723  : 			_STD addressof(_Prevnode(_Pnode)));
; 724  : 		_Getal().deallocate(_Pnode, 1);
; 725  : 		}
; 726  : 
; 727  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 728  : 		_Nodeptr _Prev)
; 729  : 		{	// allocate a node and set links
; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);
; 731  : 
; 732  : 		if (_Next == _Nodeptr())
; 733  : 			{	// point at self
; 734  : 			_Next = _Pnode;
; 735  : 			_Prev = _Pnode;
; 736  : 			}
; 737  : 		_TRY_BEGIN
; 738  : 		_Getal().construct(
; 739  : 			_STD addressof(_Nextnode(_Pnode)), _Next);
; 740  : 		_Getal().construct(
; 741  : 			_STD addressof(_Prevnode(_Pnode)), _Prev);
; 742  : 		_CATCH_ALL
; 743  : 		_Getal().deallocate(_Pnode, 1);
; 744  : 		_RERAISE;
; 745  : 		_CATCH_END
; 746  : 
; 747  : 		return (_Pnode);
; 748  : 		}
; 749  : 
; 750  : 	void _Orphan_all()
; 751  : 		{	// orphan all iterators
; 752  : 		_Get_data()._Orphan_all();
; 753  : 		}
; 754  : 
; 755  : 	void _Swap_all(_Myt& _Right)
; 756  : 		{	// swap all iterators
; 757  : 		_Get_data()._Swap_all(_Right._Get_data());
; 758  : 		}
; 759  : 
; 760  : 	_Alty& _Getal() _NOEXCEPT
; 761  : 		{	// return reference to allocator
; 762  : 		return (_Mypair._Get_first());
; 763  : 		}
; 764  : 
; 765  : 	const _Alty& _Getal() const _NOEXCEPT
; 766  : 		{	// return const reference to allocator
; 767  : 		return (_Mypair._Get_first());
; 768  : 		}
; 769  : 
; 770  : 	_List_val<_Val_types>& _Get_data() _NOEXCEPT
; 771  : 		{	// return reference to _List_val
; 772  : 		return (_Mypair._Get_second());
; 773  : 		}
; 774  : 
; 775  : 	const _List_val<_Val_types>& _Get_data() const _NOEXCEPT
; 776  : 		{	// return const reference to _List_val
; 777  : 		return (_Mypair._Get_second());
; 778  : 		}
; 779  : 
; 780  : 	_Nodeptr& _Myhead() _NOEXCEPT
; 781  : 		{	// return reference to _Myhead
; 782  : 		return (_Get_data()._Myhead);
; 783  : 		}
; 784  : 
; 785  : 	const _Nodeptr& _Myhead() const _NOEXCEPT
; 786  : 		{	// return const reference to _Myhead
; 787  : 		return (_Get_data()._Myhead);
; 788  : 		}
; 789  : 
; 790  : 	size_type& _Mysize() _NOEXCEPT
; 791  : 		{	// return reference to _Mysize
; 792  : 		return (_Get_data()._Mysize);
; 793  : 		}
; 794  : 
; 795  : 	const size_type& _Mysize() const _NOEXCEPT
; 796  : 		{	// return const reference to _Mysize
; 797  : 		return (_Get_data()._Mysize);
; 798  : 		}
; 799  : 
; 800  : private:
; 801  : 	_Compressed_pair<_Alty, _List_val<_Val_types> > _Mypair;
; 802  : 	};
; 803  : 
; 804  : 		// TEMPLATE CLASS _List_buy
; 805  : template<class _Ty,
; 806  : 	class _Alloc>
; 807  : 	class _List_buy
; 808  : 		: public _List_alloc<_List_base_types<_Ty, _Alloc> >
; 809  : 	{	// base class for list to hold buynode/freenode functions
; 810  : public:
; 811  : 	typedef _List_alloc<_List_base_types<_Ty, _Alloc> > _Mybase;
; 812  : 	typedef typename _Mybase::_Alty _Alty;
; 813  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 814  : 
; 815  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from allocator
; 818  : 		}
; 819  : 
; 820  : 	_List_buy(_Alloc&& _Al)
; 821  : 		: _Mybase(_STD move(_Al))
; 822  : 		{	// construct from allocator
; 823  : 		}
; 824  : 
; 825  : 	template<class... _Valty>
; 826  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 827  : 			_Valty&&... _Val)
; 828  : 		{	// allocate a node and set links and value
; 829  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 830  : 
; 831  : 		_TRY_BEGIN
; 832  : 		this->_Getal().construct(
; 833  : 			_STD addressof(this->_Myval(_Pnode)),
; 834  : 				_STD forward<_Valty>(_Val)...);
; 835  : 		_CATCH_ALL
; 836  : 		this->_Getal().deallocate(_Pnode, 1);
; 837  : 		_RERAISE;
; 838  : 		_CATCH_END
; 839  : 
; 840  : 		return (_Pnode);
; 841  : 		}
; 842  : 
; 843  : 
; 844  : 	void _Freenode(_Nodeptr _Pnode)
; 845  : 		{	// give node back
; 846  : 		this->_Getal().destroy(
; 847  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 848  : 		this->_Getal().destroy(
; 849  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 850  : 		this->_Getal().destroy(
; 851  : 			_STD addressof(this->_Myval(_Pnode)));
; 852  : 		this->_Getal().deallocate(_Pnode, 1);
; 853  : 		}
; 854  : 	};
; 855  : 
; 856  : 		// TEMPLATE CLASS list
; 857  : template<class _Ty,
; 858  : 	class _Alloc = allocator<_Ty> >
; 859  : 	class list
; 860  : 		: public _List_buy<_Ty, _Alloc>
; 861  : 	{	// bidirectional linked list
; 862  : public:
; 863  : 	typedef list<_Ty, _Alloc> _Myt;
; 864  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 865  : 	typedef typename _Mybase::_Node _Node;
; 866  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 867  : 	typedef typename _Mybase::_Alty _Alty;
; 868  : 
; 869  : 	typedef _Alloc allocator_type;
; 870  : 	typedef typename _Mybase::size_type size_type;
; 871  : 	typedef typename _Mybase::difference_type difference_type;
; 872  : 	typedef typename _Mybase::pointer pointer;
; 873  : 	typedef typename _Mybase::const_pointer const_pointer;
; 874  : 	typedef typename _Mybase::reference reference;
; 875  : 	typedef typename _Mybase::const_reference const_reference;
; 876  : 	typedef typename _Mybase::value_type value_type;
; 877  : 
; 878  : 	typedef typename _Mybase::const_iterator const_iterator;
; 879  : 	typedef typename _Mybase::iterator iterator;
; 880  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 881  : 		_Unchecked_const_iterator;
; 882  : 	typedef typename _Mybase::_Unchecked_iterator
; 883  : 		_Unchecked_iterator;
; 884  : 
; 885  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 886  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 887  : 
; 888  : 	list()
; 889  : 		: _Mybase()
; 890  : 		{	// construct empty list
; 891  : 		}
; 892  : 
; 893  : 	explicit list(const _Alloc& _Al)
; 894  : 		: _Mybase(_Al)
; 895  : 		{	// construct empty list, allocator
; 896  : 		}
; 897  : 
; 898  : 	explicit list(size_type _Count)
; 899  : 		: _Mybase()
; 900  : 		{	// construct list from _Count * _Ty()
; 901  : 		resize(_Count);
; 902  : 		}
; 903  : 
; 904  : 	list(size_type _Count, const _Ty& _Val)
; 905  : 		: _Mybase()
; 906  : 		{	// construct list from _Count * _Val
; 907  : 		_Construct_n(_Count, _Val);
; 908  : 		}
; 909  : 
; 910  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 911  : 		: _Mybase(_Al)
; 912  : 		{	// construct list from _Count * _Val, allocator
; 913  : 		_Construct_n(_Count, _Val);
; 914  : 		}
; 915  : 
; 916  : 	list(const _Myt& _Right)
; 917  : 
; 918  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 919  : 
; 920  : 
; 921  : 		{	// construct list by copying _Right
; 922  : 		_TRY_BEGIN
; 923  : 		insert(begin(), _Right.begin(), _Right.end());
; 924  : 		_CATCH_ALL
; 925  : 		_Tidy();
; 926  : 		_RERAISE;
; 927  : 		_CATCH_END
; 928  : 		}
; 929  : 
; 930  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 931  : 		: _Mybase(_Al)
; 932  : 		{	// construct list by copying _Right, allocator
; 933  : 		_TRY_BEGIN
; 934  : 		insert(begin(), _Right.begin(), _Right.end());
; 935  : 		_CATCH_ALL
; 936  : 		_Tidy();
; 937  : 		_RERAISE;
; 938  : 		_CATCH_END
; 939  : 		}
; 940  : 
; 941  : 	template<class _Iter,
; 942  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 943  : 			void>::type>
; 944  : 		list(_Iter _First, _Iter _Last)
; 945  : 		: _Mybase()
; 946  : 		{	// construct list from [_First, _Last)
; 947  : 		_Construct(_First, _Last);
; 948  : 		}
; 949  : 
; 950  : 	template<class _Iter,
; 951  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 952  : 			void>::type>
; 953  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 954  : 		: _Mybase(_Al)
; 955  : 		{	// construct list, allocator from [_First, _Last)
; 956  : 		_Construct(_First, _Last);
; 957  : 		}
; 958  : 
; 959  : 	template<class _Iter>
; 960  : 		void _Construct(_Iter _First, _Iter _Last)
; 961  : 		{	// construct list from [_First, _Last), input iterators
; 962  : 		_TRY_BEGIN
; 963  : 		insert(begin(), _First, _Last);
; 964  : 		_CATCH_ALL
; 965  : 		_Tidy();
; 966  : 		_RERAISE;
; 967  : 		_CATCH_END
; 968  : 		}
; 969  : 
; 970  : 	void _Construct_n(size_type _Count,
; 971  : 		const _Ty& _Val)
; 972  : 		{	// construct from _Count * _Val
; 973  : 		_TRY_BEGIN
; 974  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 975  : 		_CATCH_ALL
; 976  : 		_Tidy();
; 977  : 		_RERAISE;
; 978  : 		_CATCH_END
; 979  : 		}
; 980  : 
; 981  : 	list(_Myt&& _Right)
; 982  : 		: _Mybase(_STD move(_Right._Getal()))
; 983  : 		{	// construct list by moving _Right
; 984  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 985  : 		}
; 986  : 
; 987  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 988  : 		: _Mybase(_Al)
; 989  : 		{	// construct list by moving _Right, allocator
; 990  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 991  : 		}
; 992  : 
; 993  : 	_Myt& operator=(_Myt&& _Right)
; 994  : 		_NOEXCEPT_OP(_Alty::is_always_equal::value)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Move_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1013 : 		_STD swap(this->_Mysize(), _Right._Mysize());
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != &this->_Get_data())
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

  00007	ff 75 08	 push	 DWORD PTR __Val$[ebp]

; 96   : 		return (_Ptr);

  0000a	8b 3e		 mov	 edi, DWORD PTR [esi]

; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);
; 537  : 		}
; 538  : 
; 539  : 	static reference _Myval(_Nodeptr _Pnode)
; 540  : 		{	// return reference to value in node
; 541  : 		return ((reference)_Pnode->_Myval);
; 542  : 		}
; 543  : 
; 544  : 	_Nodeptr _Myhead;	// pointer to head node
; 545  : 	size_type _Mysize;	// number of elements
; 546  : 	};
; 547  : 
; 548  : 		// TEMPLATE CLASS _List_alloc
; 549  : template<class _Alloc_types>
; 550  : 	class _List_alloc
; 551  : 	{	// base class for list to hold allocator
; 552  : public:
; 553  : 	typedef _List_alloc<_Alloc_types> _Myt;
; 554  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 555  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 556  : 	typedef typename _Alloc_types::_Node _Node;
; 557  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 558  : 
; 559  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 560  : 
; 561  : 	typedef _Nodeptr& _Nodepref;
; 562  : 
; 563  : 	typedef typename _Val_types::value_type value_type;
; 564  : 	typedef typename _Val_types::size_type size_type;
; 565  : 	typedef typename _Val_types::difference_type difference_type;
; 566  : 	typedef typename _Val_types::pointer pointer;
; 567  : 	typedef typename _Val_types::const_pointer const_pointer;
; 568  : 	typedef typename _Val_types::reference reference;
; 569  : 	typedef typename _Val_types::const_reference const_reference;
; 570  : 
; 571  : 	typedef _List_const_iterator<_List_val<_Val_types> > const_iterator;
; 572  : 	typedef _List_iterator<_List_val<_Val_types> > iterator;
; 573  : 
; 574  : 	typedef _List_unchecked_const_iterator<_List_val<_Val_types> >
; 575  : 		_Unchecked_const_iterator;
; 576  : 	typedef _List_unchecked_iterator<_List_val<_Val_types> >
; 577  : 		_Unchecked_iterator;
; 578  : 
; 579  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 580  : 		{	// return reference to successor pointer in node
; 581  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));
; 582  : 		}
; 583  : 
; 584  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 585  : 		{	// return reference to predecessor pointer in node
; 586  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));
; 587  : 		}
; 588  : 
; 589  : 	static reference _Myval(_Nodeptr _Pnode)
; 590  : 		{	// return reference to value in node
; 591  : 		return (_List_val<_Val_types>::_Myval(_Pnode));
; 592  : 		}
; 593  : 
; 594  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 595  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 596  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 597  : 		{	// construct head node, allocator from _Al
; 598  : 		_Myhead() = _Buyheadnode();
; 599  : 		}
; 600  : 
; 601  : 	_List_alloc(_Alloc&& _Al)
; 602  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 603  : 		{	// construct head node, allocator from _Al
; 604  : 		_Myhead() = _Buyheadnode();
; 605  : 		}
; 606  : 
; 607  : 	~_List_alloc() _NOEXCEPT
; 608  : 		{	// destroy head node
; 609  : 		_Freeheadnode(_Myhead());
; 610  : 		}
; 611  : 
; 612  : 	void _Copy_alloc(const _Alty& _Al)
; 613  : 		{	// replace old allocator
; 614  : 		_Pocca(_Getal(), _Al);
; 615  : 		}
; 616  : 
; 617  : 	void _Move_alloc(_Alty& _Al)
; 618  : 		{	// replace old allocator
; 619  : 		_Pocma(_Getal(), _Al);
; 620  : 		}
; 621  : 
; 622  : 	void _Swap_alloc(_Myt& _Right)
; 623  : 		{	// swap allocators
; 624  : 		_Pocs(_Getal(), _Right._Getal());
; 625  : 		}
; 626  : 
; 627  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 628  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 629  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 630  : 		{	// construct head node, allocator from _Al
; 631  : 		_Myhead() = _Buyheadnode();
; 632  : 		_TRY_BEGIN
; 633  : 		_Alloc_proxy();
; 634  : 		_CATCH_ALL
; 635  : 		_Freeheadnode(_Myhead());
; 636  : 		_RERAISE;
; 637  : 		_CATCH_END
; 638  : 		}
; 639  : 
; 640  : 	_List_alloc(_Alloc&& _Al)
; 641  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 642  : 		{	// construct head node, allocator from _Al
; 643  : 		_Myhead() = _Buyheadnode();
; 644  : 		_TRY_BEGIN
; 645  : 		_Alloc_proxy();
; 646  : 		_CATCH_ALL
; 647  : 		_Freeheadnode(_Myhead());
; 648  : 		_RERAISE;
; 649  : 		_CATCH_END
; 650  : 		}
; 651  : 
; 652  : 	~_List_alloc() _NOEXCEPT
; 653  : 		{	// destroy proxy
; 654  : 		_Freeheadnode(_Myhead());
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Copy_alloc(const _Alty& _Al)
; 659  : 		{	// replace old allocator
; 660  : 		_Free_proxy();
; 661  : 		_Pocca(_Getal(), _Al);
; 662  : 		_Alloc_proxy();
; 663  : 		}
; 664  : 
; 665  : 	void _Move_alloc(_Alty& _Al)
; 666  : 		{	// replace old allocator
; 667  : 		_Free_proxy();
; 668  : 		_Pocma(_Getal(), _Al);
; 669  : 		_Alloc_proxy();
; 670  : 		}
; 671  : 
; 672  : 	void _Swap_alloc(_Myt& _Right)
; 673  : 		{	// swap allocators
; 674  : 		_Pocs(_Getal(), _Right._Getal());
; 675  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 676  : 		}
; 677  : 
; 678  : 	void _Alloc_proxy()
; 679  : 		{	// construct proxy
; 680  : 		typename _Alty::template rebind<_Container_proxy>::other
; 681  : 			_Alproxy(_Getal());
; 682  : 		_Myproxy() = _Alproxy.allocate(1);
; 683  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 684  : 		_Myproxy()->_Mycont = &_Get_data();
; 685  : 		}
; 686  : 
; 687  : 	void _Free_proxy()
; 688  : 		{	// destroy proxy
; 689  : 		typename _Alty::template rebind<_Container_proxy>::other
; 690  : 			_Alproxy(_Getal());
; 691  : 		_Orphan_all();
; 692  : 		_Alproxy.destroy(_Myproxy());
; 693  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 694  : 		_Myproxy() = 0;
; 695  : 		}
; 696  : 
; 697  : 	_Iterator_base12 **_Getpfirst() const
; 698  : 		{	// get address of iterator chain
; 699  : 		return (_Get_data()._Getpfirst());
; 700  : 		}
; 701  : 
; 702  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 703  : 		{	// return reference to _Myproxy
; 704  : 		return (_Get_data()._Myproxy);
; 705  : 		}
; 706  : 
; 707  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 708  : 		{	// return const reference to _Myproxy
; 709  : 		return (_Get_data()._Myproxy);
; 710  : 		}
; 711  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 712  : 
; 713  : 	_Nodeptr _Buyheadnode()
; 714  : 		{	// get head node using current allocator
; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 716  : 		}
; 717  : 
; 718  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 719  : 		{	// free head node using current allocator
; 720  : 		_Getal().destroy(
; 721  : 			_STD addressof(_Nextnode(_Pnode)));
; 722  : 		_Getal().destroy(
; 723  : 			_STD addressof(_Prevnode(_Pnode)));
; 724  : 		_Getal().deallocate(_Pnode, 1);
; 725  : 		}
; 726  : 
; 727  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 728  : 		_Nodeptr _Prev)
; 729  : 		{	// allocate a node and set links
; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);
; 731  : 
; 732  : 		if (_Next == _Nodeptr())
; 733  : 			{	// point at self
; 734  : 			_Next = _Pnode;
; 735  : 			_Prev = _Pnode;
; 736  : 			}
; 737  : 		_TRY_BEGIN
; 738  : 		_Getal().construct(
; 739  : 			_STD addressof(_Nextnode(_Pnode)), _Next);
; 740  : 		_Getal().construct(
; 741  : 			_STD addressof(_Prevnode(_Pnode)), _Prev);
; 742  : 		_CATCH_ALL
; 743  : 		_Getal().deallocate(_Pnode, 1);
; 744  : 		_RERAISE;
; 745  : 		_CATCH_END
; 746  : 
; 747  : 		return (_Pnode);
; 748  : 		}
; 749  : 
; 750  : 	void _Orphan_all()
; 751  : 		{	// orphan all iterators
; 752  : 		_Get_data()._Orphan_all();
; 753  : 		}
; 754  : 
; 755  : 	void _Swap_all(_Myt& _Right)
; 756  : 		{	// swap all iterators
; 757  : 		_Get_data()._Swap_all(_Right._Get_data());
; 758  : 		}
; 759  : 
; 760  : 	_Alty& _Getal() _NOEXCEPT
; 761  : 		{	// return reference to allocator
; 762  : 		return (_Mypair._Get_first());
; 763  : 		}
; 764  : 
; 765  : 	const _Alty& _Getal() const _NOEXCEPT
; 766  : 		{	// return const reference to allocator
; 767  : 		return (_Mypair._Get_first());
; 768  : 		}
; 769  : 
; 770  : 	_List_val<_Val_types>& _Get_data() _NOEXCEPT
; 771  : 		{	// return reference to _List_val
; 772  : 		return (_Mypair._Get_second());
; 773  : 		}
; 774  : 
; 775  : 	const _List_val<_Val_types>& _Get_data() const _NOEXCEPT
; 776  : 		{	// return const reference to _List_val
; 777  : 		return (_Mypair._Get_second());
; 778  : 		}
; 779  : 
; 780  : 	_Nodeptr& _Myhead() _NOEXCEPT
; 781  : 		{	// return reference to _Myhead
; 782  : 		return (_Get_data()._Myhead);
; 783  : 		}
; 784  : 
; 785  : 	const _Nodeptr& _Myhead() const _NOEXCEPT
; 786  : 		{	// return const reference to _Myhead
; 787  : 		return (_Get_data()._Myhead);
; 788  : 		}
; 789  : 
; 790  : 	size_type& _Mysize() _NOEXCEPT
; 791  : 		{	// return reference to _Mysize
; 792  : 		return (_Get_data()._Mysize);
; 793  : 		}
; 794  : 
; 795  : 	const size_type& _Mysize() const _NOEXCEPT
; 796  : 		{	// return const reference to _Mysize
; 797  : 		return (_Get_data()._Mysize);
; 798  : 		}
; 799  : 
; 800  : private:
; 801  : 	_Compressed_pair<_Alty, _List_val<_Val_types> > _Mypair;
; 802  : 	};
; 803  : 
; 804  : 		// TEMPLATE CLASS _List_buy
; 805  : template<class _Ty,
; 806  : 	class _Alloc>
; 807  : 	class _List_buy
; 808  : 		: public _List_alloc<_List_base_types<_Ty, _Alloc> >
; 809  : 	{	// base class for list to hold buynode/freenode functions
; 810  : public:
; 811  : 	typedef _List_alloc<_List_base_types<_Ty, _Alloc> > _Mybase;
; 812  : 	typedef typename _Mybase::_Alty _Alty;
; 813  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 814  : 
; 815  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from allocator
; 818  : 		}
; 819  : 
; 820  : 	_List_buy(_Alloc&& _Al)
; 821  : 		: _Mybase(_STD move(_Al))
; 822  : 		{	// construct from allocator
; 823  : 		}
; 824  : 
; 825  : 	template<class... _Valty>
; 826  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 827  : 			_Valty&&... _Val)
; 828  : 		{	// allocate a node and set links and value
; 829  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 830  : 
; 831  : 		_TRY_BEGIN
; 832  : 		this->_Getal().construct(
; 833  : 			_STD addressof(this->_Myval(_Pnode)),
; 834  : 				_STD forward<_Valty>(_Val)...);
; 835  : 		_CATCH_ALL
; 836  : 		this->_Getal().deallocate(_Pnode, 1);
; 837  : 		_RERAISE;
; 838  : 		_CATCH_END
; 839  : 
; 840  : 		return (_Pnode);
; 841  : 		}
; 842  : 
; 843  : 
; 844  : 	void _Freenode(_Nodeptr _Pnode)
; 845  : 		{	// give node back
; 846  : 		this->_Getal().destroy(
; 847  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 848  : 		this->_Getal().destroy(
; 849  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 850  : 		this->_Getal().destroy(
; 851  : 			_STD addressof(this->_Myval(_Pnode)));
; 852  : 		this->_Getal().deallocate(_Pnode, 1);
; 853  : 		}
; 854  : 	};
; 855  : 
; 856  : 		// TEMPLATE CLASS list
; 857  : template<class _Ty,
; 858  : 	class _Alloc = allocator<_Ty> >
; 859  : 	class list
; 860  : 		: public _List_buy<_Ty, _Alloc>
; 861  : 	{	// bidirectional linked list
; 862  : public:
; 863  : 	typedef list<_Ty, _Alloc> _Myt;
; 864  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 865  : 	typedef typename _Mybase::_Node _Node;
; 866  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 867  : 	typedef typename _Mybase::_Alty _Alty;
; 868  : 
; 869  : 	typedef _Alloc allocator_type;
; 870  : 	typedef typename _Mybase::size_type size_type;
; 871  : 	typedef typename _Mybase::difference_type difference_type;
; 872  : 	typedef typename _Mybase::pointer pointer;
; 873  : 	typedef typename _Mybase::const_pointer const_pointer;
; 874  : 	typedef typename _Mybase::reference reference;
; 875  : 	typedef typename _Mybase::const_reference const_reference;
; 876  : 	typedef typename _Mybase::value_type value_type;
; 877  : 
; 878  : 	typedef typename _Mybase::const_iterator const_iterator;
; 879  : 	typedef typename _Mybase::iterator iterator;
; 880  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 881  : 		_Unchecked_const_iterator;
; 882  : 	typedef typename _Mybase::_Unchecked_iterator
; 883  : 		_Unchecked_iterator;
; 884  : 
; 885  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 886  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 887  : 
; 888  : 	list()
; 889  : 		: _Mybase()
; 890  : 		{	// construct empty list
; 891  : 		}
; 892  : 
; 893  : 	explicit list(const _Alloc& _Al)
; 894  : 		: _Mybase(_Al)
; 895  : 		{	// construct empty list, allocator
; 896  : 		}
; 897  : 
; 898  : 	explicit list(size_type _Count)
; 899  : 		: _Mybase()
; 900  : 		{	// construct list from _Count * _Ty()
; 901  : 		resize(_Count);
; 902  : 		}
; 903  : 
; 904  : 	list(size_type _Count, const _Ty& _Val)
; 905  : 		: _Mybase()
; 906  : 		{	// construct list from _Count * _Val
; 907  : 		_Construct_n(_Count, _Val);
; 908  : 		}
; 909  : 
; 910  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 911  : 		: _Mybase(_Al)
; 912  : 		{	// construct list from _Count * _Val, allocator
; 913  : 		_Construct_n(_Count, _Val);
; 914  : 		}
; 915  : 
; 916  : 	list(const _Myt& _Right)
; 917  : 
; 918  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 919  : 
; 920  : 
; 921  : 		{	// construct list by copying _Right
; 922  : 		_TRY_BEGIN
; 923  : 		insert(begin(), _Right.begin(), _Right.end());
; 924  : 		_CATCH_ALL
; 925  : 		_Tidy();
; 926  : 		_RERAISE;
; 927  : 		_CATCH_END
; 928  : 		}
; 929  : 
; 930  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 931  : 		: _Mybase(_Al)
; 932  : 		{	// construct list by copying _Right, allocator
; 933  : 		_TRY_BEGIN
; 934  : 		insert(begin(), _Right.begin(), _Right.end());
; 935  : 		_CATCH_ALL
; 936  : 		_Tidy();
; 937  : 		_RERAISE;
; 938  : 		_CATCH_END
; 939  : 		}
; 940  : 
; 941  : 	template<class _Iter,
; 942  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 943  : 			void>::type>
; 944  : 		list(_Iter _First, _Iter _Last)
; 945  : 		: _Mybase()
; 946  : 		{	// construct list from [_First, _Last)
; 947  : 		_Construct(_First, _Last);
; 948  : 		}
; 949  : 
; 950  : 	template<class _Iter,
; 951  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 952  : 			void>::type>
; 953  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 954  : 		: _Mybase(_Al)
; 955  : 		{	// construct list, allocator from [_First, _Last)
; 956  : 		_Construct(_First, _Last);
; 957  : 		}
; 958  : 
; 959  : 	template<class _Iter>
; 960  : 		void _Construct(_Iter _First, _Iter _Last)
; 961  : 		{	// construct list from [_First, _Last), input iterators
; 962  : 		_TRY_BEGIN
; 963  : 		insert(begin(), _First, _Last);
; 964  : 		_CATCH_ALL
; 965  : 		_Tidy();
; 966  : 		_RERAISE;
; 967  : 		_CATCH_END
; 968  : 		}
; 969  : 
; 970  : 	void _Construct_n(size_type _Count,
; 971  : 		const _Ty& _Val)
; 972  : 		{	// construct from _Count * _Val
; 973  : 		_TRY_BEGIN
; 974  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 975  : 		_CATCH_ALL
; 976  : 		_Tidy();
; 977  : 		_RERAISE;
; 978  : 		_CATCH_END
; 979  : 		}
; 980  : 
; 981  : 	list(_Myt&& _Right)
; 982  : 		: _Mybase(_STD move(_Right._Getal()))
; 983  : 		{	// construct list by moving _Right
; 984  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 985  : 		}
; 986  : 
; 987  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 988  : 		: _Mybase(_Al)
; 989  : 		{	// construct list by moving _Right, allocator
; 990  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 991  : 		}
; 992  : 
; 993  : 	_Myt& operator=(_Myt&& _Right)
; 994  : 		_NOEXCEPT_OP(_Alty::is_always_equal::value)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Move_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1013 : 		_STD swap(this->_Mysize(), _Right._Mysize());
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != &this->_Get_data())
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

  0000c	ff 77 04	 push	 DWORD PTR [edi+4]
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 ??$_Buynode@ABU_EVENT_TIME@CBloodCastle@@@?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PAU21@0ABU_EVENT_TIME@CBloodCastle@@@Z ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Buynode<CBloodCastle::_EVENT_TIME const &>
  00015	8b d0		 mov	 edx, eax

; 1291 : 
; 1292 : 	void pop_back()
; 1293 : 		{	// erase element at end
; 1294 : 		erase(--end());
; 1295 : 		}
; 1296 : 
; 1297 : 	template<class _Iter>
; 1298 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1299 : 			void>::type
; 1300 : 		assign(_Iter _First, _Iter _Last)
; 1301 : 		{	// assign [_First, _Last), input iterators
; 1302 : 		iterator _Old = begin();
; 1303 : 		_TRY_BEGIN
; 1304 : 		for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)
; 1305 : 			_Reusenode(_Old, *_First);
; 1306 : 		for (; _First != _Last; ++_First)
; 1307 : 			_Insert(_Unchecked_end(), *_First);
; 1308 : 		_CATCH_ALL
; 1309 : 		clear();
; 1310 : 		_RERAISE;
; 1311 : 		_CATCH_END
; 1312 : 		erase(_Old, end());
; 1313 : 		}
; 1314 : 
; 1315 : 	template<class _TArg>
; 1316 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1317 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1318 : 		_TRY_BEGIN
; 1319 : 		this->_Getal().destroy(
; 1320 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1321 : 		this->_Getal().construct(
; 1322 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1323 : 			_STD forward<_TArg>(_Arg));
; 1324 : 		_CATCH_ALL
; 1325 : 		_Unlinknode(_Where);
; 1326 : 		this->_Getal().destroy(
; 1327 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1328 : 		this->_Getal().destroy(
; 1329 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1330 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1331 : 		_RERAISE;
; 1332 : 		_CATCH_END
; 1333 : 		}
; 1334 : 
; 1335 : 	void assign(size_type _Count, const _Ty& _Val)
; 1336 : 		{	// assign _Count * _Val
; 1337 : 		clear();
; 1338 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1339 : 		}
; 1340 : 
; 1341 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1342 : 		{	// insert _Val at _Where
; 1343 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1344 : 		if (_Where._Getcont() != &this->_Get_data())
; 1345 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1346 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1347 : 
; 1348 : 		_Insert(_Where._Unchecked(), _Val);
; 1349 : 		return (_Make_iter(--_Where));
; 1350 : 		}
; 1351 : 
; 1352 : 	iterator insert(const_iterator _Where,
; 1353 : 		size_type _Count, const _Ty& _Val)
; 1354 : 		{	// insert _Count * _Val at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != &this->_Get_data())
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1364 : 			return (begin());
; 1365 : 			}
; 1366 : 		else
; 1367 : 			{	// insert sequence not at beginning
; 1368 : 			--_Prev;
; 1369 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1370 : 			return (++_Prev);
; 1371 : 			}
; 1372 : 		}
; 1373 : 
; 1374 : 	template<class _Iter>
; 1375 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1376 : 			iterator>::type
; 1377 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1378 : 		{	// insert [_First, _Last) at _Where
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_Where._Getcont() != &this->_Get_data())
; 1381 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1382 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1383 : 
; 1384 : 		iterator _Prev = _Make_iter(_Where);
; 1385 : 		if (_Prev == begin())
; 1386 : 			{	// insert sequence at beginning
; 1387 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1388 : 				_Iter_cat(_First));
; 1389 : 			return (begin());
; 1390 : 			}
; 1391 : 		else
; 1392 : 			{	// insert sequence not at beginning
; 1393 : 			--_Prev;
; 1394 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1395 : 				_Iter_cat(_First));
; 1396 : 			return (++_Prev);
; 1397 : 			}
; 1398 : 		}
; 1399 : 
; 1400 : 	template<class _Iter>
; 1401 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1402 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1403 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1404 : 		size_type _Num = 0;
; 1405 : 
; 1406 : 		_TRY_BEGIN
; 1407 : 		for (; _First != _Last; ++_First, (void)++_Num)
; 1408 : 			_Insert(_Where, *_First);
; 1409 : 		_CATCH_ALL
; 1410 : 		for (; 0 < _Num; --_Num)
; 1411 : 			{	// undo inserts
; 1412 : 			_Unchecked_const_iterator _Before = _Where;
; 1413 : 			_Unchecked_erase(--_Before);
; 1414 : 			}
; 1415 : 		_RERAISE;
; 1416 : 		_CATCH_END
; 1417 : 		}
; 1418 : 
; 1419 : 	template<class _Iter>
; 1420 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1421 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1422 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1423 : 		_DEBUG_RANGE(_First, _Last);
; 1424 : 		_Iter _Next = _First;
; 1425 : 
; 1426 : 		_TRY_BEGIN
; 1427 : 		for (; _First != _Last; ++_First)
; 1428 : 			_Insert(_Where, *_First);
; 1429 : 		_CATCH_ALL
; 1430 : 		for (; _Next != _First; ++_Next)
; 1431 : 			{	// undo inserts
; 1432 : 			_Unchecked_const_iterator _Before = _Where;
; 1433 : 			_Unchecked_erase(--_Before);
; 1434 : 			}
; 1435 : 		_RERAISE;
; 1436 : 		_CATCH_END
; 1437 : 		}
; 1438 : 
; 1439 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1440 : 		{	// unlink node at _Where from the list
; 1441 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1442 : 		if (_Where._Getcont() != &this->_Get_data()
; 1443 : 			|| _Where._Ptr == this->_Myhead())
; 1444 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1445 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1446 : 		_Orphan_ptr(_Pnode);
; 1447 : 
; 1448 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1449 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1453 : 			this->_Nextnode(_Pnode);
; 1454 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1455 : 			this->_Prevnode(_Pnode);
; 1456 : 
; 1457 : 		--this->_Mysize();
; 1458 : 		return (_Pnode);
; 1459 : 		}
; 1460 : 
; 1461 : 	iterator erase(const_iterator _Where)
; 1462 : 		{	// erase element at _Where
; 1463 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1464 : 		this->_Freenode(_Pnode);
; 1465 : 		return (_Make_iter(_Where));
; 1466 : 		}
; 1467 : 
; 1468 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1469 : 		{	// erase element at _Where
; 1470 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1471 : 
; 1472 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1473 : 			this->_Nextnode(_Pnode);
; 1474 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1475 : 			this->_Prevnode(_Pnode);
; 1476 : 		this->_Freenode(_Pnode);
; 1477 : 		--this->_Mysize();
; 1478 : 		}
; 1479 : 
; 1480 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1481 : 		{	// erase [_First, _Last)
; 1482 : 		if (_First == begin() && _Last == end())
; 1483 : 			{	// erase all and return fresh iterator
; 1484 : 			clear();
; 1485 : 			return (end());
; 1486 : 			}
; 1487 : 		else
; 1488 : 			{	// erase subrange
; 1489 : 			while (_First != _Last)
; 1490 : 				_First = erase(_First);
; 1491 : 			return (_Make_iter(_Last));
; 1492 : 			}
; 1493 : 		}
; 1494 : 
; 1495 : 	void clear() _NOEXCEPT
; 1496 : 		{	// erase all
; 1497 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1498 : 
; 1499 : 		this->_Orphan_ptr(nullptr);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());
; 1502 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();
; 1503 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();
; 1504 : 		this->_Mysize() = 0;
; 1505 : 
; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)
; 1507 : 			{	// delete an element
; 1508 : 			_Pnext = this->_Nextnode(_Pnode);
; 1509 : 			this->_Freenode(_Pnode);
; 1510 : 			}
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		_NOEXCEPT_OP(_Alty::is_always_equal::value)
; 1515 : 		{	// exchange contents with _Right
; 1516 : 		if (this == &_Right)
; 1517 : 			;	// same object, do nothing
; 1518 : 		else if (this->_Getal() == _Right._Getal())
; 1519 : 			{	// same allocator, swap control information
; 1520 : 			this->_Swap_all(_Right);
; 1521 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1522 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1529 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1530 : 			}
; 1531 : 
; 1532 : 		else	// containers are incompatible
; 1533 : 
; 1534 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1535 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1536 : 
; 1537 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 			_XSTD terminate();
; 1539 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 		}
; 1541 : 
; 1542 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1543 : 		{	// splice all of _Right at _Where
; 1544 : 		if (this != &_Right && !_Right.empty())
; 1545 : 			{	// worth splicing, do it
; 1546 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1547 : 				_Right._Mysize());
; 1548 : 			}
; 1549 : 		}
; 1550 : 
; 1551 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1552 : 		{	// splice all of _Right at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1557 : 		const_iterator _First)
; 1558 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1559 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1560 : 		if (_First == _Right.end())
; 1561 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1562 : 		else
; 1563 : 
; 1564 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1565 : 		if (_First != _Right.end())
; 1566 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1567 : 
; 1568 : 			{	// element exists, try splice
; 1569 : 			const_iterator _Last = _First;
; 1570 : 			++_Last;
; 1571 : 			if (this != &_Right
; 1572 : 				|| (_Where != _First && _Where != _Last))
; 1573 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1574 : 			}
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1578 : 		const_iterator _First)
; 1579 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1580 : 		splice(_Where, (_Myt&)_Right, _First);
; 1581 : 		}
; 1582 : 
; 1583 : 	void splice(const_iterator _Where,
; 1584 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1585 : 		{	// splice _Right [_First, _Last) at _Where
; 1586 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1587 : 			{	// worth splicing, do it
; 1588 : 			size_type _Count = 0;
; 1589 : 
; 1590 : 			if (this == &_Right)
; 1591 : 				;	// just rearrange this list
; 1592 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1593 : 				_Count = _Right._Mysize();	// splice in whole list
; 1594 : 			else
; 1595 : 				{	// count nodes and check for knot
; 1596 : 				const_iterator _Next = _First;
; 1597 : 
; 1598 : 				for (; _Next != _Last; ++_Next, (void)++_Count)
; 1599 : 					if (_Next == _Right.end())
; 1600 : 						_Xlength_error("list<T> bad splice");
; 1601 : 				}
; 1602 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1603 : 			}
; 1604 : 		}
; 1605 : 
; 1606 : 	void splice(const_iterator _Where,
; 1607 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1608 : 		{	// splice _Right [_First, _Last) at _Where
; 1609 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1610 : 		}
; 1611 : 
; 1612 : 	void remove(const _Ty& _Val)
; 1613 : 		{	// erase each element matching _Val
; 1614 : 		iterator _Val_it = end();
; 1615 : 
; 1616 : 		for (iterator _First = begin(); _First != end(); )
; 1617 : 			if (*_First == _Val)
; 1618 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1619 : 					_Val_it = _First++;
; 1620 : 				else
; 1621 : 					_First = erase(_First);
; 1622 : 			else
; 1623 : 				++_First;
; 1624 : 
; 1625 : 		if (_Val_it != end())
; 1626 : 			erase(_Val_it);
; 1627 : 		}
; 1628 : 
; 1629 : 	template<class _Pr1>
; 1630 : 		void remove_if(_Pr1 _Pred)
; 1631 : 		{	// erase each element satisfying _Pred
; 1632 : 		for (iterator _First = begin(); _First != end(); )
; 1633 : 			if (_Pred(*_First))
; 1634 : 				_First = erase(_First);
; 1635 : 			else
; 1636 : 				++_First;
; 1637 : 		}
; 1638 : 
; 1639 : 	void unique()
; 1640 : 		{	// erase each element matching previous
; 1641 : 		unique(equal_to<>());
; 1642 : 		}
; 1643 : 
; 1644 : 	template<class _Pr2>
; 1645 : 		void unique(_Pr2 _Pred)
; 1646 : 		{	// erase each element satisfying _Pred with previous
; 1647 : 		const _Nodeptr _Phead = this->_Myhead();
; 1648 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1649 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1650 : 
; 1651 : 		while (_Pnode != _Phead)
; 1652 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1653 : 				{	// match, remove it
; 1654 : 				const _Nodeptr _Perase = _Pnode;
; 1655 : 				_Pnode = this->_Nextnode(_Pnode);
; 1656 : 
; 1657 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1658 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1659 : 				this->_Freenode(_Perase);
; 1660 : 
; 1661 : 				--this->_Mysize();
; 1662 : 				}
; 1663 : 			else
; 1664 : 				{	// no match, advance
; 1665 : 				_Pprev = _Pnode;
; 1666 : 				_Pnode = this->_Nextnode(_Pnode);
; 1667 : 				}
; 1668 : 		}
; 1669 : 
; 1670 : 	void merge(_Myt& _Right)
; 1671 : 		{	// merge in elements from _Right, both ordered by operator<
; 1672 : 		merge(_Right, less<>());
; 1673 : 		}
; 1674 : 
; 1675 : 	void merge(_Myt&& _Right)
; 1676 : 		{	// merge in elements from _Right, both ordered by operator<
; 1677 : 		merge((_Myt&)_Right);
; 1678 : 		}
; 1679 : 
; 1680 : 	template<class _Pr2>
; 1681 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1682 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1683 : 		if (&_Right != this)
; 1684 : 			{	// safe to merge, do it
; 1685 : 			iterator _First1 = begin(), _Last1 = end();
; 1686 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1687 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1688 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1689 : 
; 1690 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1691 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1692 : 					{	// splice in an element from _Right
; 1693 : 					iterator _Mid2 = _First2;
; 1694 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1695 : 					_First2 = _Mid2;
; 1696 : 					}
; 1697 : 				else
; 1698 : 					++_First1;
; 1699 : 
; 1700 : 			if (_First2 != _Last2)
; 1701 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1702 : 					_Right._Mysize());	// splice remainder of _Right
; 1703 : 			}
; 1704 : 		}
; 1705 : 
; 1706 : 	template<class _Pr2>
; 1707 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1708 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1709 : 		merge((_Myt&)_Right, _Pred);
; 1710 : 		}
; 1711 : 
; 1712 : 	void sort()
; 1713 : 		{	// order sequence, using operator<
; 1714 : 		sort(less<>());
; 1715 : 		}
; 1716 : 
; 1717 : 	template<class _Pr2>
; 1718 : 		void sort(_Pr2 _Pred)
; 1719 : 		{	// order sequence, using _Pred
; 1720 : 		_Sort(begin(), end(), _Pred, this->_Mysize());
; 1721 : 		}
; 1722 : 
; 1723 : 	template<class _Pr2>
; 1724 : 		iterator _Sort(iterator _First, iterator _Last, _Pr2 _Pred,
; 1725 : 			size_type _Size)
; 1726 : 		{	// order [_First, _Last), using _Pred, return new first
; 1727 : 			// _Size must be distance from _First to _Last
; 1728 : 		if (_Size < 2)
; 1729 : 			return (_First);	// nothing to do
; 1730 : 
; 1731 : 		iterator _Mid = _STD next(_First, _Size / 2);
; 1732 : 		_First = _Sort(_First, _Mid, _Pred, _Size / 2);
; 1733 : 		_Mid = _Sort(_Mid, _Last, _Pred, _Size - _Size / 2);
; 1734 : 		iterator _Newfirst = _First;
; 1735 : 
; 1736 : 		for (bool _Initial_loop = true; ; _Initial_loop = false)
; 1737 : 			{	// [_First, _Mid) and [_Mid, _Last) are sorted and non-empty
; 1738 : 			if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
; 1739 : 				{	// consume _Mid
; 1740 : 				if (_Initial_loop)
; 1741 : 					_Newfirst = _Mid;	// update return value
; 1742 : 				splice(_First, *this, _Mid++);
; 1743 : 				if (_Mid == _Last)
; 1744 : 					return (_Newfirst);	// exhausted [_Mid, _Last); done
; 1745 : 				}
; 1746 : 			else
; 1747 : 				{	// consume _First
; 1748 : 				++_First;
; 1749 : 				if (_First == _Mid)
; 1750 : 					return (_Newfirst);	// exhausted [_First, _Mid); done
; 1751 : 				}
; 1752 : 			}
; 1753 : 		}
; 1754 : 
; 1755 : 	void reverse() _NOEXCEPT
; 1756 : 		{	// reverse sequence
; 1757 : 		const _Nodeptr _Phead = this->_Myhead();
; 1758 : 		_Nodeptr _Pnode = _Phead;
; 1759 : 
; 1760 : 		for (; ; )
; 1761 : 			{	// flip pointers in a node
; 1762 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1763 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1764 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1765 : 
; 1766 : 			if (_Pnext == _Phead)
; 1767 : 				break;
; 1768 : 			_Pnode = _Pnext;
; 1769 : 			}
; 1770 : 		}
; 1771 : 
; 1772 : 	void _Splice(const_iterator _Where,
; 1773 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1774 : 		size_type _Count)
; 1775 : 		{	// splice _Right [_First, _Last) before _Where
; 1776 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1777 : 		if (_Where._Getcont() != &this->_Get_data())
; 1778 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1779 : 		if (this->_Getal() != _Right._Getal())
; 1780 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1781 : 
; 1782 : 		if (this != &_Right)
; 1783 : 			{	// transfer ownership
; 1784 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1785 : 
; 1786 : 			const bool _One = _Count == 1;
; 1787 : 			const bool _All = !_One && _Count == _Right.size();
; 1788 : 			const bool _Some = !_One && !_All;
; 1789 : 
; 1790 : 			_Nodeptr _Oldprev = this->_Prevnode(_First._Ptr);
; 1791 : 
; 1792 : 			if (_Some)
; 1793 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1794 : 					_Ptr = this->_Nextnode(_Ptr))
; 1795 : 					{	// mark _Prev pointers
; 1796 : 					this->_Prevnode(_Ptr) = 0;
; 1797 : 					}
; 1798 : 
; 1799 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1800 : 
; 1801 : 			if (_Pnext == 0)
; 1802 : 				_DEBUG_ERROR("list container corrupted");
; 1803 : 
; 1804 : 			while (*_Pnext != 0)
; 1805 : 				{	// check the iterator
; 1806 : 				const_iterator& _Iter = **_Pnext;
; 1807 : 
; 1808 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1809 : 					|| (_All && _Iter._Ptr != _Right._Myhead())
; 1810 : 					|| (_Some && this->_Prevnode(_Iter._Ptr) == 0))
; 1811 : 					{	// adopt the iterator
; 1812 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1813 : 					_Iter._Myproxy = this->_Myproxy();
; 1814 : 					_Iter._Mynextiter = this->_Myproxy()->_Myfirstiter;
; 1815 : 					this->_Myproxy()->_Myfirstiter = &_Iter;
; 1816 : 					}
; 1817 : 				else
; 1818 : 					{	// skip the iterator
; 1819 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1820 : 					}
; 1821 : 				}
; 1822 : 
; 1823 : 			if (_Some)
; 1824 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1825 : 					_Ptr = this->_Nextnode(_Ptr))
; 1826 : 					{	// restore _Prev pointers
; 1827 : 					this->_Prevnode(_Ptr) = _Oldprev;
; 1828 : 					_Oldprev = _Ptr;
; 1829 : 					}
; 1830 : 			}
; 1831 : 
; 1832 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1833 : 		if (this->_Getal() != _Right._Getal())
; 1834 : 			_XSTD terminate();
; 1835 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1836 : 
; 1837 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1838 : 		}
; 1839 : 
; 1840 : 	void _Splice_same(const_iterator _Where,
; 1841 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1842 : 		size_type _Count)
; 1843 : 		{	// splice _Right [_First, _Last) before _Where
; 1844 : 		if (this != &_Right)
; 1845 : 			{	// splicing from another list, adjust counts
; 1846 : 			_Incsize(_Count);
; 1847 : 			_Right._Mysize() -= _Count;
; 1848 : 			}
; 1849 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1850 : 			_Last._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1852 : 			_Where._Mynode();
; 1853 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1854 : 			_First._Mynode();
; 1855 : 
; 1856 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1857 : 		this->_Prevnode(_Where._Mynode()) =
; 1858 : 			this->_Prevnode(_Last._Mynode());
; 1859 : 		this->_Prevnode(_Last._Mynode()) =
; 1860 : 			this->_Prevnode(_First._Mynode());
; 1861 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1862 : 		}
; 1863 : 
; 1864 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1865 : 		_Unchecked_const_iterator _First,
; 1866 : 		_Unchecked_const_iterator _Last)
; 1867 : 		{	// splice [_First, _Last) before _Where
; 1868 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1869 : 			_Last._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1871 : 			_Where._Mynode();
; 1872 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1873 : 			_First._Mynode();
; 1874 : 
; 1875 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1876 : 		this->_Prevnode(_Where._Mynode()) =
; 1877 : 			this->_Prevnode(_Last._Mynode());
; 1878 : 		this->_Prevnode(_Last._Mynode()) =
; 1879 : 			this->_Prevnode(_First._Mynode());
; 1880 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1881 : 		}
; 1882 : 
; 1883 : 	void _Tidy()
; 1884 : 		{	// free all storage
; 1885 : 		clear();
; 1886 : 		}
; 1887 : 
; 1888 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1889 : 		size_type _Count, const _Ty& _Val)
; 1890 : 		{	// insert _Count * _Val at _Where
; 1891 : 		size_type _Countsave = _Count;
; 1892 : 
; 1893 : 		_TRY_BEGIN
; 1894 : 		for (; 0 < _Count; --_Count)
; 1895 : 			_Insert(_Where, _Val);
; 1896 : 		_CATCH_ALL
; 1897 : 		for (; _Count < _Countsave; ++_Count)
; 1898 : 			{	// undo inserts
; 1899 : 			_Unchecked_const_iterator _Before = _Where;
; 1900 : 			_Unchecked_erase(--_Before);
; 1901 : 			}
; 1902 : 		_RERAISE;
; 1903 : 		_CATCH_END
; 1904 : 		}
; 1905 : 
; 1906 : 	void _Incsize(size_type _Count)
; 1907 : 		{	// alter element count, with checking
; 1908 : 		if (max_size() - this->_Mysize() - 1 < _Count)

  00017	b9 fe ff ff 0f	 mov	 ecx, 268435454		; 0ffffffeH
  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	2b c8		 sub	 ecx, eax
  00021	83 f9 01	 cmp	 ecx, 1
  00024	72 12		 jb	 SHORT $LN91@push_back

; 1910 : 		this->_Mysize() += _Count;

  00026	40		 inc	 eax
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1062 : 				_STD forward<_Valty>(_Val)...);
; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

  0002a	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() != _Right._Getcont())
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("list iterators incompatible");
; 289  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 290  : 			}
; 291  : 
; 292  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 293  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 294  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 295  : 
; 296  : 		return (this->_Ptr == _Right._Ptr);
; 297  : 		}
; 298  : 
; 299  : 	bool operator!=(const _Myiter& _Right) const
; 300  : 		{	// test for iterator inequality
; 301  : 		return (!(*this == _Right));
; 302  : 		}
; 303  : 	};
; 304  : 
; 305  : template<class _Mylist> inline
; 306  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 307  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 308  : 	{	// convert to unchecked
; 309  : 	return (_Iter._Unchecked());
; 310  : 	}
; 311  : 
; 312  : template<class _Mylist> inline
; 313  : 	_List_const_iterator<_Mylist>&
; 314  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 315  : 			typename _List_const_iterator<_Mylist>
; 316  : 				::_Unchecked_type _Right)
; 317  : 	{	// convert to checked
; 318  : 	return (_Iter._Rechecked(_Right));
; 319  : 	}
; 320  : 
; 321  : 	// TEMPLATE CLASS _List_iterator
; 322  : template<class _Mylist>
; 323  : 	class _List_iterator
; 324  : 		: public _List_const_iterator<_Mylist>
; 325  : 	{	// iterator for mutable list
; 326  : public:
; 327  : 	typedef _List_iterator<_Mylist> _Myiter;
; 328  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 329  : 	typedef bidirectional_iterator_tag iterator_category;
; 330  : 
; 331  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 332  : 	typedef typename _Mylist::value_type value_type;
; 333  : 	typedef typename _Mylist::difference_type difference_type;
; 334  : 	typedef typename _Mylist::pointer pointer;
; 335  : 	typedef typename _Mylist::reference reference;
; 336  : 
; 337  : 	_List_iterator()
; 338  : 		{	// construct with null node
; 339  : 		}
; 340  : 
; 341  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 342  : 		: _Mybase(_Pnode, _Plist)
; 343  : 		{	// construct with node pointer _Pnode
; 344  : 		}
; 345  : 
; 346  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 347  : 
; 348  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 349  : 		{	// reset from unchecked iterator
; 350  : 		this->_Ptr = _Right._Ptr;
; 351  : 		return (*this);
; 352  : 		}
; 353  : 
; 354  : 	_Unchecked_type _Unchecked() const
; 355  : 		{	// make an unchecked iterator
; 356  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 357  : 		}
; 358  : 
; 359  : 	reference operator*() const
; 360  : 		{	// return designated value
; 361  : 		return ((reference)**(_Mybase *)this);
; 362  : 		}
; 363  : 
; 364  : 	pointer operator->() const
; 365  : 		{	// return pointer to class object
; 366  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 367  : 		}
; 368  : 
; 369  : 	_Myiter& operator++()
; 370  : 		{	// preincrement
; 371  : 		++(*(_Mybase *)this);
; 372  : 		return (*this);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator++(int)
; 376  : 		{	// postincrement
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		++*this;
; 379  : 		return (_Tmp);
; 380  : 		}
; 381  : 
; 382  : 	_Myiter& operator--()
; 383  : 		{	// predecrement
; 384  : 		--(*(_Mybase *)this);
; 385  : 		return (*this);
; 386  : 		}
; 387  : 
; 388  : 	_Myiter operator--(int)
; 389  : 		{	// postdecrement
; 390  : 		_Myiter _Tmp = *this;
; 391  : 		--*this;
; 392  : 		return (_Tmp);
; 393  : 		}
; 394  : 	};
; 395  : 
; 396  : template<class _Mylist> inline
; 397  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 398  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 399  : 	{	// convert to unchecked
; 400  : 	return (_Iter._Unchecked());
; 401  : 	}
; 402  : 
; 403  : template<class _Mylist> inline
; 404  : 	_List_iterator<_Mylist>&
; 405  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 406  : 			typename _List_iterator<_Mylist>
; 407  : 				::_Unchecked_type _Right)
; 408  : 	{	// convert to checked
; 409  : 	return (_Iter._Rechecked(_Right));
; 410  : 	}
; 411  : 
; 412  : 		// list TYPE WRAPPERS
; 413  : template<class _Value_type,
; 414  : 	class _Size_type,
; 415  : 	class _Difference_type,
; 416  : 	class _Pointer,
; 417  : 	class _Const_pointer,
; 418  : 	class _Reference,
; 419  : 	class _Const_reference,
; 420  : 	class _Nodeptr_type>
; 421  : 	struct _List_iter_types
; 422  : 	{	// wraps types needed by iterators
; 423  : 	typedef _Value_type value_type;
; 424  : 	typedef _Size_type size_type;
; 425  : 	typedef _Difference_type difference_type;
; 426  : 	typedef _Pointer pointer;
; 427  : 	typedef _Const_pointer const_pointer;
; 428  : 	typedef _Reference reference;
; 429  : 	typedef _Const_reference const_reference;
; 430  : 	typedef _Nodeptr_type _Nodeptr;
; 431  : 	};
; 432  : 
; 433  : template<class _Value_type,
; 434  : 	class _Voidptr>
; 435  : 	struct _List_node
; 436  : 		{	// list node
; 437  : 		_Voidptr _Next;	// successor node, or first element if head
; 438  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 439  : 		_Value_type _Myval;	// the stored value, unused if head
; 440  : 
; 441  : 	private:
; 442  : 		_List_node& operator=(const _List_node&);
; 443  : 		};
; 444  : 
; 445  : template<class _Value_type>
; 446  : 	struct _List_node<_Value_type, void *>
; 447  : 		{	// list node
; 448  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 449  : 		_Nodeptr _Next;	// successor node, or first element if head
; 450  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 451  : 		_Value_type _Myval;	// the stored value, unused if head
; 452  : 
; 453  : 	private:
; 454  : 		_List_node& operator=(const _List_node&);
; 455  : 		};
; 456  : 
; 457  : template<class _Ty>
; 458  : 	struct _List_simple_types
; 459  : 		: public _Simple_types<_Ty>
; 460  : 	{	// wraps types needed by iterators
; 461  : 	typedef _List_node<_Ty, void *> _Node;
; 462  : 	typedef _Node *_Nodeptr;
; 463  : 	};
; 464  : 
; 465  : template<class _Ty,
; 466  : 	class _Alloc0>
; 467  : 	struct _List_base_types
; 468  : 	{	// types needed for a container base
; 469  : 	typedef _Alloc0 _Alloc;
; 470  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 471  : 
; 472  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 473  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 474  : 
; 475  : 
; 476  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 477  : 		_Voidptr;
; 478  : 	typedef _List_node<typename _Alty::value_type,
; 479  : 		_Voidptr> _Node;
; 480  : 
; 481  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 482  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 483  : 	typedef _Nodeptr& _Nodepref;
; 484  : 
; 485  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 486  : 		_List_simple_types<typename _Alty::value_type>,
; 487  : 		_List_iter_types<typename _Alty::value_type,
; 488  : 			typename _Alty::size_type,
; 489  : 			typename _Alty::difference_type,
; 490  : 			typename _Alty::pointer,
; 491  : 			typename _Alty::const_pointer,
; 492  : 			typename _Alty::reference,
; 493  : 			typename _Alty::const_reference,
; 494  : 			_Nodeptr> >::type
; 495  : 		_Val_types;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _List_val
; 499  : template<class _Val_types>
; 500  : 	class _List_val
; 501  : 		: public _Container_base
; 502  : 	{	// base class for list to hold data
; 503  : public:
; 504  : 	typedef _List_val<_Val_types> _Myt;
; 505  : 
; 506  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 507  : 	typedef _Nodeptr& _Nodepref;
; 508  : 
; 509  : 	typedef typename _Val_types::value_type value_type;
; 510  : 	typedef typename _Val_types::size_type size_type;
; 511  : 	typedef typename _Val_types::difference_type difference_type;
; 512  : 	typedef typename _Val_types::pointer pointer;
; 513  : 	typedef typename _Val_types::const_pointer const_pointer;
; 514  : 	typedef typename _Val_types::reference reference;
; 515  : 	typedef typename _Val_types::const_reference const_reference;
; 516  : 
; 517  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 518  : 	typedef _List_iterator<_Myt> iterator;
; 519  : 
; 520  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 521  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 522  : 
; 523  : 	_List_val()
; 524  : 		{	// initialize data
; 525  : 		this->_Myhead = 0;
; 526  : 		this->_Mysize = 0;
; 527  : 		}
; 528  : 
; 529  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 530  : 		{	// return reference to successor pointer in node
; 531  : 		return ((_Nodepref)_Pnode->_Next);

  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  00032	89 10		 mov	 DWORD PTR [eax], edx

; 1289 : 		_Insert(_Unchecked_end(), _Val);
; 1290 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN91@push_back:

; 1909 : 			_Xlength_error("list<T> too long");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN93@push_back:
$LN90@push_back:
  00042	cc		 int	 3
?push_back@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXABU_EVENT_TIME@CBloodCastle@@@Z ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?max_size@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QBEIXZ PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::max_size, COMDAT
; _this$ = ecx

; 1244 : 		return (this->_Getal().max_size());

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 1245 : 		}

  00005	c3		 ret	 0
?max_size@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QBEIXZ ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?size@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QBEIXZ PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::size, COMDAT
; _this$ = ecx

; 1239 : 		return (this->_Mysize());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1240 : 		}

  00003	c3		 ret	 0
?size@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QBEIXZ ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Unchecked_end@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@2@XZ PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1149 : 		{	// return unchecked iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1150 : 		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));
; 1151 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?_Unchecked_end@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@2@XZ ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?end@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@2@XZ PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::end, COMDAT
; _this$ = ecx

; 1127 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		: _Ptr(_Pnode)

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1128 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1129 : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@2@XZ ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?begin@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@2@XZ PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::begin, COMDAT
; _this$ = ecx

; 1115 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   : 		{	// construct with node pointer _Pnode
; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() != _Right._Getcont())
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("list iterators incompatible");
; 289  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 290  : 			}
; 291  : 
; 292  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 293  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 294  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 295  : 
; 296  : 		return (this->_Ptr == _Right._Ptr);
; 297  : 		}
; 298  : 
; 299  : 	bool operator!=(const _Myiter& _Right) const
; 300  : 		{	// test for iterator inequality
; 301  : 		return (!(*this == _Right));
; 302  : 		}
; 303  : 	};
; 304  : 
; 305  : template<class _Mylist> inline
; 306  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 307  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 308  : 	{	// convert to unchecked
; 309  : 	return (_Iter._Unchecked());
; 310  : 	}
; 311  : 
; 312  : template<class _Mylist> inline
; 313  : 	_List_const_iterator<_Mylist>&
; 314  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 315  : 			typename _List_const_iterator<_Mylist>
; 316  : 				::_Unchecked_type _Right)
; 317  : 	{	// convert to checked
; 318  : 	return (_Iter._Rechecked(_Right));
; 319  : 	}
; 320  : 
; 321  : 	// TEMPLATE CLASS _List_iterator
; 322  : template<class _Mylist>
; 323  : 	class _List_iterator
; 324  : 		: public _List_const_iterator<_Mylist>
; 325  : 	{	// iterator for mutable list
; 326  : public:
; 327  : 	typedef _List_iterator<_Mylist> _Myiter;
; 328  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 329  : 	typedef bidirectional_iterator_tag iterator_category;
; 330  : 
; 331  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 332  : 	typedef typename _Mylist::value_type value_type;
; 333  : 	typedef typename _Mylist::difference_type difference_type;
; 334  : 	typedef typename _Mylist::pointer pointer;
; 335  : 	typedef typename _Mylist::reference reference;
; 336  : 
; 337  : 	_List_iterator()
; 338  : 		{	// construct with null node
; 339  : 		}
; 340  : 
; 341  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 342  : 		: _Mybase(_Pnode, _Plist)
; 343  : 		{	// construct with node pointer _Pnode
; 344  : 		}
; 345  : 
; 346  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 347  : 
; 348  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 349  : 		{	// reset from unchecked iterator
; 350  : 		this->_Ptr = _Right._Ptr;
; 351  : 		return (*this);
; 352  : 		}
; 353  : 
; 354  : 	_Unchecked_type _Unchecked() const
; 355  : 		{	// make an unchecked iterator
; 356  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 357  : 		}
; 358  : 
; 359  : 	reference operator*() const
; 360  : 		{	// return designated value
; 361  : 		return ((reference)**(_Mybase *)this);
; 362  : 		}
; 363  : 
; 364  : 	pointer operator->() const
; 365  : 		{	// return pointer to class object
; 366  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 367  : 		}
; 368  : 
; 369  : 	_Myiter& operator++()
; 370  : 		{	// preincrement
; 371  : 		++(*(_Mybase *)this);
; 372  : 		return (*this);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator++(int)
; 376  : 		{	// postincrement
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		++*this;
; 379  : 		return (_Tmp);
; 380  : 		}
; 381  : 
; 382  : 	_Myiter& operator--()
; 383  : 		{	// predecrement
; 384  : 		--(*(_Mybase *)this);
; 385  : 		return (*this);
; 386  : 		}
; 387  : 
; 388  : 	_Myiter operator--(int)
; 389  : 		{	// postdecrement
; 390  : 		_Myiter _Tmp = *this;
; 391  : 		--*this;
; 392  : 		return (_Tmp);
; 393  : 		}
; 394  : 	};
; 395  : 
; 396  : template<class _Mylist> inline
; 397  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 398  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 399  : 	{	// convert to unchecked
; 400  : 	return (_Iter._Unchecked());
; 401  : 	}
; 402  : 
; 403  : template<class _Mylist> inline
; 404  : 	_List_iterator<_Mylist>&
; 405  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 406  : 			typename _List_iterator<_Mylist>
; 407  : 				::_Unchecked_type _Right)
; 408  : 	{	// convert to checked
; 409  : 	return (_Iter._Rechecked(_Right));
; 410  : 	}
; 411  : 
; 412  : 		// list TYPE WRAPPERS
; 413  : template<class _Value_type,
; 414  : 	class _Size_type,
; 415  : 	class _Difference_type,
; 416  : 	class _Pointer,
; 417  : 	class _Const_pointer,
; 418  : 	class _Reference,
; 419  : 	class _Const_reference,
; 420  : 	class _Nodeptr_type>
; 421  : 	struct _List_iter_types
; 422  : 	{	// wraps types needed by iterators
; 423  : 	typedef _Value_type value_type;
; 424  : 	typedef _Size_type size_type;
; 425  : 	typedef _Difference_type difference_type;
; 426  : 	typedef _Pointer pointer;
; 427  : 	typedef _Const_pointer const_pointer;
; 428  : 	typedef _Reference reference;
; 429  : 	typedef _Const_reference const_reference;
; 430  : 	typedef _Nodeptr_type _Nodeptr;
; 431  : 	};
; 432  : 
; 433  : template<class _Value_type,
; 434  : 	class _Voidptr>
; 435  : 	struct _List_node
; 436  : 		{	// list node
; 437  : 		_Voidptr _Next;	// successor node, or first element if head
; 438  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 439  : 		_Value_type _Myval;	// the stored value, unused if head
; 440  : 
; 441  : 	private:
; 442  : 		_List_node& operator=(const _List_node&);
; 443  : 		};
; 444  : 
; 445  : template<class _Value_type>
; 446  : 	struct _List_node<_Value_type, void *>
; 447  : 		{	// list node
; 448  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 449  : 		_Nodeptr _Next;	// successor node, or first element if head
; 450  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 451  : 		_Value_type _Myval;	// the stored value, unused if head
; 452  : 
; 453  : 	private:
; 454  : 		_List_node& operator=(const _List_node&);
; 455  : 		};
; 456  : 
; 457  : template<class _Ty>
; 458  : 	struct _List_simple_types
; 459  : 		: public _Simple_types<_Ty>
; 460  : 	{	// wraps types needed by iterators
; 461  : 	typedef _List_node<_Ty, void *> _Node;
; 462  : 	typedef _Node *_Nodeptr;
; 463  : 	};
; 464  : 
; 465  : template<class _Ty,
; 466  : 	class _Alloc0>
; 467  : 	struct _List_base_types
; 468  : 	{	// types needed for a container base
; 469  : 	typedef _Alloc0 _Alloc;
; 470  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 471  : 
; 472  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 473  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 474  : 
; 475  : 
; 476  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 477  : 		_Voidptr;
; 478  : 	typedef _List_node<typename _Alty::value_type,
; 479  : 		_Voidptr> _Node;
; 480  : 
; 481  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 482  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 483  : 	typedef _Nodeptr& _Nodepref;
; 484  : 
; 485  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 486  : 		_List_simple_types<typename _Alty::value_type>,
; 487  : 		_List_iter_types<typename _Alty::value_type,
; 488  : 			typename _Alty::size_type,
; 489  : 			typename _Alty::difference_type,
; 490  : 			typename _Alty::pointer,
; 491  : 			typename _Alty::const_pointer,
; 492  : 			typename _Alty::reference,
; 493  : 			typename _Alty::const_reference,
; 494  : 			_Nodeptr> >::type
; 495  : 		_Val_types;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _List_val
; 499  : template<class _Val_types>
; 500  : 	class _List_val
; 501  : 		: public _Container_base
; 502  : 	{	// base class for list to hold data
; 503  : public:
; 504  : 	typedef _List_val<_Val_types> _Myt;
; 505  : 
; 506  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 507  : 	typedef _Nodeptr& _Nodepref;
; 508  : 
; 509  : 	typedef typename _Val_types::value_type value_type;
; 510  : 	typedef typename _Val_types::size_type size_type;
; 511  : 	typedef typename _Val_types::difference_type difference_type;
; 512  : 	typedef typename _Val_types::pointer pointer;
; 513  : 	typedef typename _Val_types::const_pointer const_pointer;
; 514  : 	typedef typename _Val_types::reference reference;
; 515  : 	typedef typename _Val_types::const_reference const_reference;
; 516  : 
; 517  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 518  : 	typedef _List_iterator<_Myt> iterator;
; 519  : 
; 520  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 521  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 522  : 
; 523  : 	_List_val()
; 524  : 		{	// initialize data
; 525  : 		this->_Myhead = 0;
; 526  : 		this->_Mysize = 0;
; 527  : 		}
; 528  : 
; 529  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 530  : 		{	// return reference to successor pointer in node
; 531  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead()),
; 1117 : 			&this->_Get_data()));
; 1118 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@2@XZ ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::~list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 1094 : 		{	// destroy the object

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 531  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 07		 mov	 eax, DWORD PTR [edi]

; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Copy_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead()),
; 1117 : 			&this->_Get_data()));
; 1118 : 		}
; 1119 : 
; 1120 : 	const_iterator begin() const _NOEXCEPT
; 1121 : 		{	// return iterator for beginning of nonmutable sequence
; 1122 : 		return (const_iterator(this->_Nextnode(this->_Myhead()),
; 1123 : 			&this->_Get_data()));
; 1124 : 		}
; 1125 : 
; 1126 : 	iterator end() _NOEXCEPT
; 1127 : 		{	// return iterator for end of mutable sequence
; 1128 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1129 : 		}
; 1130 : 
; 1131 : 	const_iterator end() const _NOEXCEPT
; 1132 : 		{	// return iterator for end of nonmutable sequence
; 1133 : 		return (const_iterator(this->_Myhead(), &this->_Get_data()));
; 1134 : 		}
; 1135 : 
; 1136 : 	_Unchecked_iterator _Unchecked_begin()
; 1137 : 		{	// return iterator for beginning of mutable sequence
; 1138 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead()),
; 1139 : 			&this->_Get_data()));
; 1140 : 		}
; 1141 : 
; 1142 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1143 : 		{	// return iterator for beginning of nonmutable sequence
; 1144 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead()),
; 1145 : 			&this->_Get_data()));
; 1146 : 		}
; 1147 : 
; 1148 : 	_Unchecked_iterator _Unchecked_end()
; 1149 : 		{	// return unchecked iterator for end of mutable sequence
; 1150 : 		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));
; 1151 : 		}
; 1152 : 
; 1153 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1154 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1155 : 		return (_Unchecked_const_iterator(this->_Myhead(),
; 1156 : 			&this->_Get_data()));
; 1157 : 		}
; 1158 : 
; 1159 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1160 : 		{	// make iterator from const_iterator
; 1161 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1162 : 		}
; 1163 : 
; 1164 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1165 : 		{	// make iterator from _Unchecked_const_iterator
; 1166 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1167 : 		}
; 1168 : 
; 1169 : 	reverse_iterator rbegin() _NOEXCEPT
; 1170 : 		{	// return iterator for beginning of reversed mutable sequence
; 1171 : 		return (reverse_iterator(end()));
; 1172 : 		}
; 1173 : 
; 1174 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1175 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1176 : 		return (const_reverse_iterator(end()));
; 1177 : 		}
; 1178 : 
; 1179 : 	reverse_iterator rend() _NOEXCEPT
; 1180 : 		{	// return iterator for end of reversed mutable sequence
; 1181 : 		return (reverse_iterator(begin()));
; 1182 : 		}
; 1183 : 
; 1184 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1185 : 		{	// return iterator for end of reversed nonmutable sequence
; 1186 : 		return (const_reverse_iterator(begin()));
; 1187 : 		}
; 1188 : 
; 1189 : 	const_iterator cbegin() const _NOEXCEPT
; 1190 : 		{	// return iterator for beginning of nonmutable sequence
; 1191 : 		return (begin());
; 1192 : 		}
; 1193 : 
; 1194 : 	const_iterator cend() const _NOEXCEPT
; 1195 : 		{	// return iterator for end of nonmutable sequence
; 1196 : 		return (end());
; 1197 : 		}
; 1198 : 
; 1199 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1200 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1201 : 		return (rbegin());
; 1202 : 		}
; 1203 : 
; 1204 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1205 : 		{	// return iterator for end of reversed nonmutable sequence
; 1206 : 		return (rend());
; 1207 : 		}
; 1208 : 
; 1209 : 	void resize(size_type _Newsize)
; 1210 : 		{	// determine new length, padding with _Ty() elements as needed
; 1211 : 		if (this->_Mysize() < _Newsize)
; 1212 : 			{	// pad to make larger
; 1213 : 			size_type _Count = 0;
; 1214 : 			_TRY_BEGIN
; 1215 : 			for (; this->_Mysize() < _Newsize; ++_Count)
; 1216 : 				_Insert(_Unchecked_end());
; 1217 : 			_CATCH_ALL
; 1218 : 			for (; 0 < _Count; --_Count)
; 1219 : 				pop_back();	// undo inserts
; 1220 : 			_RERAISE;
; 1221 : 			_CATCH_END
; 1222 : 			}
; 1223 : 		else
; 1224 : 			while (_Newsize < this->_Mysize())
; 1225 : 				pop_back();
; 1226 : 		}
; 1227 : 
; 1228 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1229 : 		{	// determine new length, padding with _Val elements as needed
; 1230 : 		if (this->_Mysize() < _Newsize)
; 1231 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize(), _Val);
; 1232 : 		else
; 1233 : 			while (_Newsize < this->_Mysize())
; 1234 : 				pop_back();
; 1235 : 		}
; 1236 : 
; 1237 : 	size_type size() const _NOEXCEPT
; 1238 : 		{	// return length of sequence
; 1239 : 		return (this->_Mysize());
; 1240 : 		}
; 1241 : 
; 1242 : 	size_type max_size() const _NOEXCEPT
; 1243 : 		{	// return maximum possible length of sequence
; 1244 : 		return (this->_Getal().max_size());
; 1245 : 		}
; 1246 : 
; 1247 : 	bool empty() const _NOEXCEPT
; 1248 : 		{	// test if sequence is empty
; 1249 : 		return (this->_Mysize() == 0);
; 1250 : 		}
; 1251 : 
; 1252 : 	allocator_type get_allocator() const _NOEXCEPT
; 1253 : 		{	// return allocator object for values
; 1254 : 		return (this->_Getal());
; 1255 : 		}
; 1256 : 
; 1257 : 	reference front()
; 1258 : 		{	// return first element of mutable sequence
; 1259 : 		return (*begin());
; 1260 : 		}
; 1261 : 
; 1262 : 	const_reference front() const
; 1263 : 		{	// return first element of nonmutable sequence
; 1264 : 		return (*begin());
; 1265 : 		}
; 1266 : 
; 1267 : 	reference back()
; 1268 : 		{	// return last element of mutable sequence
; 1269 : 		return (*(--end()));
; 1270 : 		}
; 1271 : 
; 1272 : 	const_reference back() const
; 1273 : 		{	// return last element of nonmutable sequence
; 1274 : 		return (*(--end()));
; 1275 : 		}
; 1276 : 
; 1277 : 	void push_front(const _Ty& _Val)
; 1278 : 		{	// insert element at beginning
; 1279 : 		_Insert(_Unchecked_begin(), _Val);
; 1280 : 		}
; 1281 : 
; 1282 : 	void pop_front()
; 1283 : 		{	// erase element at beginning
; 1284 : 		erase(begin());
; 1285 : 		}
; 1286 : 
; 1287 : 	void push_back(const _Ty& _Val)
; 1288 : 		{	// insert element at end
; 1289 : 		_Insert(_Unchecked_end(), _Val);
; 1290 : 		}
; 1291 : 
; 1292 : 	void pop_back()
; 1293 : 		{	// erase element at end
; 1294 : 		erase(--end());
; 1295 : 		}
; 1296 : 
; 1297 : 	template<class _Iter>
; 1298 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1299 : 			void>::type
; 1300 : 		assign(_Iter _First, _Iter _Last)
; 1301 : 		{	// assign [_First, _Last), input iterators
; 1302 : 		iterator _Old = begin();
; 1303 : 		_TRY_BEGIN
; 1304 : 		for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)
; 1305 : 			_Reusenode(_Old, *_First);
; 1306 : 		for (; _First != _Last; ++_First)
; 1307 : 			_Insert(_Unchecked_end(), *_First);
; 1308 : 		_CATCH_ALL
; 1309 : 		clear();
; 1310 : 		_RERAISE;
; 1311 : 		_CATCH_END
; 1312 : 		erase(_Old, end());
; 1313 : 		}
; 1314 : 
; 1315 : 	template<class _TArg>
; 1316 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1317 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1318 : 		_TRY_BEGIN
; 1319 : 		this->_Getal().destroy(
; 1320 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1321 : 		this->_Getal().construct(
; 1322 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1323 : 			_STD forward<_TArg>(_Arg));
; 1324 : 		_CATCH_ALL
; 1325 : 		_Unlinknode(_Where);
; 1326 : 		this->_Getal().destroy(
; 1327 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1328 : 		this->_Getal().destroy(
; 1329 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1330 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1331 : 		_RERAISE;
; 1332 : 		_CATCH_END
; 1333 : 		}
; 1334 : 
; 1335 : 	void assign(size_type _Count, const _Ty& _Val)
; 1336 : 		{	// assign _Count * _Val
; 1337 : 		clear();
; 1338 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1339 : 		}
; 1340 : 
; 1341 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1342 : 		{	// insert _Val at _Where
; 1343 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1344 : 		if (_Where._Getcont() != &this->_Get_data())
; 1345 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1346 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1347 : 
; 1348 : 		_Insert(_Where._Unchecked(), _Val);
; 1349 : 		return (_Make_iter(--_Where));
; 1350 : 		}
; 1351 : 
; 1352 : 	iterator insert(const_iterator _Where,
; 1353 : 		size_type _Count, const _Ty& _Val)
; 1354 : 		{	// insert _Count * _Val at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != &this->_Get_data())
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1364 : 			return (begin());
; 1365 : 			}
; 1366 : 		else
; 1367 : 			{	// insert sequence not at beginning
; 1368 : 			--_Prev;
; 1369 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1370 : 			return (++_Prev);
; 1371 : 			}
; 1372 : 		}
; 1373 : 
; 1374 : 	template<class _Iter>
; 1375 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1376 : 			iterator>::type
; 1377 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1378 : 		{	// insert [_First, _Last) at _Where
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_Where._Getcont() != &this->_Get_data())
; 1381 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1382 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1383 : 
; 1384 : 		iterator _Prev = _Make_iter(_Where);
; 1385 : 		if (_Prev == begin())
; 1386 : 			{	// insert sequence at beginning
; 1387 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1388 : 				_Iter_cat(_First));
; 1389 : 			return (begin());
; 1390 : 			}
; 1391 : 		else
; 1392 : 			{	// insert sequence not at beginning
; 1393 : 			--_Prev;
; 1394 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1395 : 				_Iter_cat(_First));
; 1396 : 			return (++_Prev);
; 1397 : 			}
; 1398 : 		}
; 1399 : 
; 1400 : 	template<class _Iter>
; 1401 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1402 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1403 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1404 : 		size_type _Num = 0;
; 1405 : 
; 1406 : 		_TRY_BEGIN
; 1407 : 		for (; _First != _Last; ++_First, (void)++_Num)
; 1408 : 			_Insert(_Where, *_First);
; 1409 : 		_CATCH_ALL
; 1410 : 		for (; 0 < _Num; --_Num)
; 1411 : 			{	// undo inserts
; 1412 : 			_Unchecked_const_iterator _Before = _Where;
; 1413 : 			_Unchecked_erase(--_Before);
; 1414 : 			}
; 1415 : 		_RERAISE;
; 1416 : 		_CATCH_END
; 1417 : 		}
; 1418 : 
; 1419 : 	template<class _Iter>
; 1420 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1421 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1422 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1423 : 		_DEBUG_RANGE(_First, _Last);
; 1424 : 		_Iter _Next = _First;
; 1425 : 
; 1426 : 		_TRY_BEGIN
; 1427 : 		for (; _First != _Last; ++_First)
; 1428 : 			_Insert(_Where, *_First);
; 1429 : 		_CATCH_ALL
; 1430 : 		for (; _Next != _First; ++_Next)
; 1431 : 			{	// undo inserts
; 1432 : 			_Unchecked_const_iterator _Before = _Where;
; 1433 : 			_Unchecked_erase(--_Before);
; 1434 : 			}
; 1435 : 		_RERAISE;
; 1436 : 		_CATCH_END
; 1437 : 		}
; 1438 : 
; 1439 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1440 : 		{	// unlink node at _Where from the list
; 1441 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1442 : 		if (_Where._Getcont() != &this->_Get_data()
; 1443 : 			|| _Where._Ptr == this->_Myhead())
; 1444 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1445 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1446 : 		_Orphan_ptr(_Pnode);
; 1447 : 
; 1448 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1449 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1453 : 			this->_Nextnode(_Pnode);
; 1454 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1455 : 			this->_Prevnode(_Pnode);
; 1456 : 
; 1457 : 		--this->_Mysize();
; 1458 : 		return (_Pnode);
; 1459 : 		}
; 1460 : 
; 1461 : 	iterator erase(const_iterator _Where)
; 1462 : 		{	// erase element at _Where
; 1463 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1464 : 		this->_Freenode(_Pnode);
; 1465 : 		return (_Make_iter(_Where));
; 1466 : 		}
; 1467 : 
; 1468 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1469 : 		{	// erase element at _Where
; 1470 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1471 : 
; 1472 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1473 : 			this->_Nextnode(_Pnode);
; 1474 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1475 : 			this->_Prevnode(_Pnode);
; 1476 : 		this->_Freenode(_Pnode);
; 1477 : 		--this->_Mysize();
; 1478 : 		}
; 1479 : 
; 1480 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1481 : 		{	// erase [_First, _Last)
; 1482 : 		if (_First == begin() && _Last == end())
; 1483 : 			{	// erase all and return fresh iterator
; 1484 : 			clear();
; 1485 : 			return (end());
; 1486 : 			}
; 1487 : 		else
; 1488 : 			{	// erase subrange
; 1489 : 			while (_First != _Last)
; 1490 : 				_First = erase(_First);
; 1491 : 			return (_Make_iter(_Last));
; 1492 : 			}
; 1493 : 		}
; 1494 : 
; 1495 : 	void clear() _NOEXCEPT
; 1496 : 		{	// erase all
; 1497 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1498 : 
; 1499 : 		this->_Orphan_ptr(nullptr);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

  00005	8b 10		 mov	 edx, DWORD PTR [eax]

; 1502 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

  00007	89 00		 mov	 DWORD PTR [eax], eax

; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);

  00009	8b 07		 mov	 eax, DWORD PTR [edi]

; 1503 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

  0000b	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1504 : 		this->_Mysize() = 0;

  0000e	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  00015	3b 17		 cmp	 edx, DWORD PTR [edi]
  00017	74 19		 je	 SHORT $LN7@list
  00019	56		 push	 esi
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL8@list:

; 1507 : 			{	// delete an element
; 1508 : 			_Pnext = this->_Nextnode(_Pnode);

  00020	8b 32		 mov	 esi, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00022	52		 push	 edx
  00023	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00028	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  0002b	8b d6		 mov	 edx, esi
  0002d	3b 37		 cmp	 esi, DWORD PTR [edi]
  0002f	75 ef		 jne	 SHORT $LL8@list
  00031	5e		 pop	 esi
$LN7@list:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00032	ff 37		 push	 DWORD PTR [edi]
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
  0003c	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 1096 : 		}

  0003d	c3		 ret	 0
??1?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::~list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ PROC ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 890  : 		{	// construct empty list

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 599  : 		}
; 600  : 
; 601  : 	_List_alloc(_Alloc&& _Al)
; 602  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 603  : 		{	// construct head node, allocator from _Al
; 604  : 		_Myhead() = _Buyheadnode();
; 605  : 		}
; 606  : 
; 607  : 	~_List_alloc() _NOEXCEPT
; 608  : 		{	// destroy head node
; 609  : 		_Freeheadnode(_Myhead());
; 610  : 		}
; 611  : 
; 612  : 	void _Copy_alloc(const _Alty& _Al)
; 613  : 		{	// replace old allocator
; 614  : 		_Pocca(_Getal(), _Al);
; 615  : 		}
; 616  : 
; 617  : 	void _Move_alloc(_Alty& _Al)
; 618  : 		{	// replace old allocator
; 619  : 		_Pocma(_Getal(), _Al);
; 620  : 		}
; 621  : 
; 622  : 	void _Swap_alloc(_Myt& _Right)
; 623  : 		{	// swap allocators
; 624  : 		_Pocs(_Getal(), _Right._Getal());
; 625  : 		}
; 626  : 
; 627  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 628  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 629  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 630  : 		{	// construct head node, allocator from _Al
; 631  : 		_Myhead() = _Buyheadnode();
; 632  : 		_TRY_BEGIN
; 633  : 		_Alloc_proxy();
; 634  : 		_CATCH_ALL
; 635  : 		_Freeheadnode(_Myhead());
; 636  : 		_RERAISE;
; 637  : 		_CATCH_END
; 638  : 		}
; 639  : 
; 640  : 	_List_alloc(_Alloc&& _Al)
; 641  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 642  : 		{	// construct head node, allocator from _Al
; 643  : 		_Myhead() = _Buyheadnode();
; 644  : 		_TRY_BEGIN
; 645  : 		_Alloc_proxy();
; 646  : 		_CATCH_ALL
; 647  : 		_Freeheadnode(_Myhead());
; 648  : 		_RERAISE;
; 649  : 		_CATCH_END
; 650  : 		}
; 651  : 
; 652  : 	~_List_alloc() _NOEXCEPT
; 653  : 		{	// destroy proxy
; 654  : 		_Freeheadnode(_Myhead());
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Copy_alloc(const _Alty& _Al)
; 659  : 		{	// replace old allocator
; 660  : 		_Free_proxy();
; 661  : 		_Pocca(_Getal(), _Al);
; 662  : 		_Alloc_proxy();
; 663  : 		}
; 664  : 
; 665  : 	void _Move_alloc(_Alty& _Al)
; 666  : 		{	// replace old allocator
; 667  : 		_Free_proxy();
; 668  : 		_Pocma(_Getal(), _Al);
; 669  : 		_Alloc_proxy();
; 670  : 		}
; 671  : 
; 672  : 	void _Swap_alloc(_Myt& _Right)
; 673  : 		{	// swap allocators
; 674  : 		_Pocs(_Getal(), _Right._Getal());
; 675  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 676  : 		}
; 677  : 
; 678  : 	void _Alloc_proxy()
; 679  : 		{	// construct proxy
; 680  : 		typename _Alty::template rebind<_Container_proxy>::other
; 681  : 			_Alproxy(_Getal());
; 682  : 		_Myproxy() = _Alproxy.allocate(1);
; 683  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 684  : 		_Myproxy()->_Mycont = &_Get_data();
; 685  : 		}
; 686  : 
; 687  : 	void _Free_proxy()
; 688  : 		{	// destroy proxy
; 689  : 		typename _Alty::template rebind<_Container_proxy>::other
; 690  : 			_Alproxy(_Getal());
; 691  : 		_Orphan_all();
; 692  : 		_Alproxy.destroy(_Myproxy());
; 693  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 694  : 		_Myproxy() = 0;
; 695  : 		}
; 696  : 
; 697  : 	_Iterator_base12 **_Getpfirst() const
; 698  : 		{	// get address of iterator chain
; 699  : 		return (_Get_data()._Getpfirst());
; 700  : 		}
; 701  : 
; 702  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 703  : 		{	// return reference to _Myproxy
; 704  : 		return (_Get_data()._Myproxy);
; 705  : 		}
; 706  : 
; 707  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 708  : 		{	// return const reference to _Myproxy
; 709  : 		return (_Get_data()._Myproxy);
; 710  : 		}
; 711  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 712  : 
; 713  : 	_Nodeptr _Buyheadnode()
; 714  : 		{	// get head node using current allocator
; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0

; 890  : 		{	// construct empty list

  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi

; 525  : 		this->_Myhead = 0;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 526  : 		this->_Mysize = 0;

  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 599  : 		}
; 600  : 
; 601  : 	_List_alloc(_Alloc&& _Al)
; 602  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 603  : 		{	// construct head node, allocator from _Al
; 604  : 		_Myhead() = _Buyheadnode();
; 605  : 		}
; 606  : 
; 607  : 	~_List_alloc() _NOEXCEPT
; 608  : 		{	// destroy head node
; 609  : 		_Freeheadnode(_Myhead());
; 610  : 		}
; 611  : 
; 612  : 	void _Copy_alloc(const _Alty& _Al)
; 613  : 		{	// replace old allocator
; 614  : 		_Pocca(_Getal(), _Al);
; 615  : 		}
; 616  : 
; 617  : 	void _Move_alloc(_Alty& _Al)
; 618  : 		{	// replace old allocator
; 619  : 		_Pocma(_Getal(), _Al);
; 620  : 		}
; 621  : 
; 622  : 	void _Swap_alloc(_Myt& _Right)
; 623  : 		{	// swap allocators
; 624  : 		_Pocs(_Getal(), _Right._Getal());
; 625  : 		}
; 626  : 
; 627  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 628  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 629  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 630  : 		{	// construct head node, allocator from _Al
; 631  : 		_Myhead() = _Buyheadnode();
; 632  : 		_TRY_BEGIN
; 633  : 		_Alloc_proxy();
; 634  : 		_CATCH_ALL
; 635  : 		_Freeheadnode(_Myhead());
; 636  : 		_RERAISE;
; 637  : 		_CATCH_END
; 638  : 		}
; 639  : 
; 640  : 	_List_alloc(_Alloc&& _Al)
; 641  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 642  : 		{	// construct head node, allocator from _Al
; 643  : 		_Myhead() = _Buyheadnode();
; 644  : 		_TRY_BEGIN
; 645  : 		_Alloc_proxy();
; 646  : 		_CATCH_ALL
; 647  : 		_Freeheadnode(_Myhead());
; 648  : 		_RERAISE;
; 649  : 		_CATCH_END
; 650  : 		}
; 651  : 
; 652  : 	~_List_alloc() _NOEXCEPT
; 653  : 		{	// destroy proxy
; 654  : 		_Freeheadnode(_Myhead());
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Copy_alloc(const _Alty& _Al)
; 659  : 		{	// replace old allocator
; 660  : 		_Free_proxy();
; 661  : 		_Pocca(_Getal(), _Al);
; 662  : 		_Alloc_proxy();
; 663  : 		}
; 664  : 
; 665  : 	void _Move_alloc(_Alty& _Al)
; 666  : 		{	// replace old allocator
; 667  : 		_Free_proxy();
; 668  : 		_Pocma(_Getal(), _Al);
; 669  : 		_Alloc_proxy();
; 670  : 		}
; 671  : 
; 672  : 	void _Swap_alloc(_Myt& _Right)
; 673  : 		{	// swap allocators
; 674  : 		_Pocs(_Getal(), _Right._Getal());
; 675  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 676  : 		}
; 677  : 
; 678  : 	void _Alloc_proxy()
; 679  : 		{	// construct proxy
; 680  : 		typename _Alty::template rebind<_Container_proxy>::other
; 681  : 			_Alproxy(_Getal());
; 682  : 		_Myproxy() = _Alproxy.allocate(1);
; 683  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 684  : 		_Myproxy()->_Mycont = &_Get_data();
; 685  : 		}
; 686  : 
; 687  : 	void _Free_proxy()
; 688  : 		{	// destroy proxy
; 689  : 		typename _Alty::template rebind<_Container_proxy>::other
; 690  : 			_Alproxy(_Getal());
; 691  : 		_Orphan_all();
; 692  : 		_Alproxy.destroy(_Myproxy());
; 693  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 694  : 		_Myproxy() = 0;
; 695  : 		}
; 696  : 
; 697  : 	_Iterator_base12 **_Getpfirst() const
; 698  : 		{	// get address of iterator chain
; 699  : 		return (_Get_data()._Getpfirst());
; 700  : 		}
; 701  : 
; 702  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 703  : 		{	// return reference to _Myproxy
; 704  : 		return (_Get_data()._Myproxy);
; 705  : 		}
; 706  : 
; 707  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 708  : 		{	// return const reference to _Myproxy
; 709  : 		return (_Get_data()._Myproxy);
; 710  : 		}
; 711  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 712  : 
; 713  : 	_Nodeptr _Buyheadnode()
; 714  : 		{	// get head node using current allocator
; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buynode0

; 527  : 		}
; 528  : 
; 529  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 530  : 		{	// return reference to successor pointer in node
; 531  : 		return ((_Nodepref)_Pnode->_Next);
; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);
; 537  : 		}
; 538  : 
; 539  : 	static reference _Myval(_Nodeptr _Pnode)
; 540  : 		{	// return reference to value in node
; 541  : 		return ((reference)_Pnode->_Myval);
; 542  : 		}
; 543  : 
; 544  : 	_Nodeptr _Myhead;	// pointer to head node
; 545  : 	size_type _Mysize;	// number of elements
; 546  : 	};
; 547  : 
; 548  : 		// TEMPLATE CLASS _List_alloc
; 549  : template<class _Alloc_types>
; 550  : 	class _List_alloc
; 551  : 	{	// base class for list to hold allocator
; 552  : public:
; 553  : 	typedef _List_alloc<_Alloc_types> _Myt;
; 554  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 555  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 556  : 	typedef typename _Alloc_types::_Node _Node;
; 557  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 558  : 
; 559  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 560  : 
; 561  : 	typedef _Nodeptr& _Nodepref;
; 562  : 
; 563  : 	typedef typename _Val_types::value_type value_type;
; 564  : 	typedef typename _Val_types::size_type size_type;
; 565  : 	typedef typename _Val_types::difference_type difference_type;
; 566  : 	typedef typename _Val_types::pointer pointer;
; 567  : 	typedef typename _Val_types::const_pointer const_pointer;
; 568  : 	typedef typename _Val_types::reference reference;
; 569  : 	typedef typename _Val_types::const_reference const_reference;
; 570  : 
; 571  : 	typedef _List_const_iterator<_List_val<_Val_types> > const_iterator;
; 572  : 	typedef _List_iterator<_List_val<_Val_types> > iterator;
; 573  : 
; 574  : 	typedef _List_unchecked_const_iterator<_List_val<_Val_types> >
; 575  : 		_Unchecked_const_iterator;
; 576  : 	typedef _List_unchecked_iterator<_List_val<_Val_types> >
; 577  : 		_Unchecked_iterator;
; 578  : 
; 579  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 580  : 		{	// return reference to successor pointer in node
; 581  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));
; 582  : 		}
; 583  : 
; 584  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 585  : 		{	// return reference to predecessor pointer in node
; 586  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));
; 587  : 		}
; 588  : 
; 589  : 	static reference _Myval(_Nodeptr _Pnode)
; 590  : 		{	// return reference to value in node
; 591  : 		return (_List_val<_Val_types>::_Myval(_Pnode));
; 592  : 		}
; 593  : 
; 594  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 595  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 596  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 597  : 		{	// construct head node, allocator from _Al
; 598  : 		_Myhead() = _Buyheadnode();

  00020	89 06		 mov	 DWORD PTR [esi], eax

; 891  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$list@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ ENDP ; std::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::list<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??1?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ PROC ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::~_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 138  : 	::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
  00008	c3		 ret	 0
??1?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ ENDP ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::~_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z PROC ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Freenode, COMDAT
; _this$ = ecx

; 845  : 		{	// give node back

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 853  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freenode@?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z ENDP ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??0?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z PROC ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 817  : 		{	// construct from allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 599  : 		}
; 600  : 
; 601  : 	_List_alloc(_Alloc&& _Al)
; 602  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 603  : 		{	// construct head node, allocator from _Al
; 604  : 		_Myhead() = _Buyheadnode();
; 605  : 		}
; 606  : 
; 607  : 	~_List_alloc() _NOEXCEPT
; 608  : 		{	// destroy head node
; 609  : 		_Freeheadnode(_Myhead());
; 610  : 		}
; 611  : 
; 612  : 	void _Copy_alloc(const _Alty& _Al)
; 613  : 		{	// replace old allocator
; 614  : 		_Pocca(_Getal(), _Al);
; 615  : 		}
; 616  : 
; 617  : 	void _Move_alloc(_Alty& _Al)
; 618  : 		{	// replace old allocator
; 619  : 		_Pocma(_Getal(), _Al);
; 620  : 		}
; 621  : 
; 622  : 	void _Swap_alloc(_Myt& _Right)
; 623  : 		{	// swap allocators
; 624  : 		_Pocs(_Getal(), _Right._Getal());
; 625  : 		}
; 626  : 
; 627  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 628  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 629  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 630  : 		{	// construct head node, allocator from _Al
; 631  : 		_Myhead() = _Buyheadnode();
; 632  : 		_TRY_BEGIN
; 633  : 		_Alloc_proxy();
; 634  : 		_CATCH_ALL
; 635  : 		_Freeheadnode(_Myhead());
; 636  : 		_RERAISE;
; 637  : 		_CATCH_END
; 638  : 		}
; 639  : 
; 640  : 	_List_alloc(_Alloc&& _Al)
; 641  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 642  : 		{	// construct head node, allocator from _Al
; 643  : 		_Myhead() = _Buyheadnode();
; 644  : 		_TRY_BEGIN
; 645  : 		_Alloc_proxy();
; 646  : 		_CATCH_ALL
; 647  : 		_Freeheadnode(_Myhead());
; 648  : 		_RERAISE;
; 649  : 		_CATCH_END
; 650  : 		}
; 651  : 
; 652  : 	~_List_alloc() _NOEXCEPT
; 653  : 		{	// destroy proxy
; 654  : 		_Freeheadnode(_Myhead());
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Copy_alloc(const _Alty& _Al)
; 659  : 		{	// replace old allocator
; 660  : 		_Free_proxy();
; 661  : 		_Pocca(_Getal(), _Al);
; 662  : 		_Alloc_proxy();
; 663  : 		}
; 664  : 
; 665  : 	void _Move_alloc(_Alty& _Al)
; 666  : 		{	// replace old allocator
; 667  : 		_Free_proxy();
; 668  : 		_Pocma(_Getal(), _Al);
; 669  : 		_Alloc_proxy();
; 670  : 		}
; 671  : 
; 672  : 	void _Swap_alloc(_Myt& _Right)
; 673  : 		{	// swap allocators
; 674  : 		_Pocs(_Getal(), _Right._Getal());
; 675  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 676  : 		}
; 677  : 
; 678  : 	void _Alloc_proxy()
; 679  : 		{	// construct proxy
; 680  : 		typename _Alty::template rebind<_Container_proxy>::other
; 681  : 			_Alproxy(_Getal());
; 682  : 		_Myproxy() = _Alproxy.allocate(1);
; 683  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 684  : 		_Myproxy()->_Mycont = &_Get_data();
; 685  : 		}
; 686  : 
; 687  : 	void _Free_proxy()
; 688  : 		{	// destroy proxy
; 689  : 		typename _Alty::template rebind<_Container_proxy>::other
; 690  : 			_Alproxy(_Getal());
; 691  : 		_Orphan_all();
; 692  : 		_Alproxy.destroy(_Myproxy());
; 693  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 694  : 		_Myproxy() = 0;
; 695  : 		}
; 696  : 
; 697  : 	_Iterator_base12 **_Getpfirst() const
; 698  : 		{	// get address of iterator chain
; 699  : 		return (_Get_data()._Getpfirst());
; 700  : 		}
; 701  : 
; 702  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 703  : 		{	// return reference to _Myproxy
; 704  : 		return (_Get_data()._Myproxy);
; 705  : 		}
; 706  : 
; 707  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 708  : 		{	// return const reference to _Myproxy
; 709  : 		return (_Get_data()._Myproxy);
; 710  : 		}
; 711  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 712  : 
; 713  : 	_Nodeptr _Buyheadnode()
; 714  : 		{	// get head node using current allocator
; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0

; 817  : 		{	// construct from allocator

  0000b	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi

; 525  : 		this->_Myhead = 0;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 526  : 		this->_Mysize = 0;

  00014	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 599  : 		}
; 600  : 
; 601  : 	_List_alloc(_Alloc&& _Al)
; 602  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 603  : 		{	// construct head node, allocator from _Al
; 604  : 		_Myhead() = _Buyheadnode();
; 605  : 		}
; 606  : 
; 607  : 	~_List_alloc() _NOEXCEPT
; 608  : 		{	// destroy head node
; 609  : 		_Freeheadnode(_Myhead());
; 610  : 		}
; 611  : 
; 612  : 	void _Copy_alloc(const _Alty& _Al)
; 613  : 		{	// replace old allocator
; 614  : 		_Pocca(_Getal(), _Al);
; 615  : 		}
; 616  : 
; 617  : 	void _Move_alloc(_Alty& _Al)
; 618  : 		{	// replace old allocator
; 619  : 		_Pocma(_Getal(), _Al);
; 620  : 		}
; 621  : 
; 622  : 	void _Swap_alloc(_Myt& _Right)
; 623  : 		{	// swap allocators
; 624  : 		_Pocs(_Getal(), _Right._Getal());
; 625  : 		}
; 626  : 
; 627  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 628  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 629  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 630  : 		{	// construct head node, allocator from _Al
; 631  : 		_Myhead() = _Buyheadnode();
; 632  : 		_TRY_BEGIN
; 633  : 		_Alloc_proxy();
; 634  : 		_CATCH_ALL
; 635  : 		_Freeheadnode(_Myhead());
; 636  : 		_RERAISE;
; 637  : 		_CATCH_END
; 638  : 		}
; 639  : 
; 640  : 	_List_alloc(_Alloc&& _Al)
; 641  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 642  : 		{	// construct head node, allocator from _Al
; 643  : 		_Myhead() = _Buyheadnode();
; 644  : 		_TRY_BEGIN
; 645  : 		_Alloc_proxy();
; 646  : 		_CATCH_ALL
; 647  : 		_Freeheadnode(_Myhead());
; 648  : 		_RERAISE;
; 649  : 		_CATCH_END
; 650  : 		}
; 651  : 
; 652  : 	~_List_alloc() _NOEXCEPT
; 653  : 		{	// destroy proxy
; 654  : 		_Freeheadnode(_Myhead());
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Copy_alloc(const _Alty& _Al)
; 659  : 		{	// replace old allocator
; 660  : 		_Free_proxy();
; 661  : 		_Pocca(_Getal(), _Al);
; 662  : 		_Alloc_proxy();
; 663  : 		}
; 664  : 
; 665  : 	void _Move_alloc(_Alty& _Al)
; 666  : 		{	// replace old allocator
; 667  : 		_Free_proxy();
; 668  : 		_Pocma(_Getal(), _Al);
; 669  : 		_Alloc_proxy();
; 670  : 		}
; 671  : 
; 672  : 	void _Swap_alloc(_Myt& _Right)
; 673  : 		{	// swap allocators
; 674  : 		_Pocs(_Getal(), _Right._Getal());
; 675  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 676  : 		}
; 677  : 
; 678  : 	void _Alloc_proxy()
; 679  : 		{	// construct proxy
; 680  : 		typename _Alty::template rebind<_Container_proxy>::other
; 681  : 			_Alproxy(_Getal());
; 682  : 		_Myproxy() = _Alproxy.allocate(1);
; 683  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 684  : 		_Myproxy()->_Mycont = &_Get_data();
; 685  : 		}
; 686  : 
; 687  : 	void _Free_proxy()
; 688  : 		{	// destroy proxy
; 689  : 		typename _Alty::template rebind<_Container_proxy>::other
; 690  : 			_Alproxy(_Getal());
; 691  : 		_Orphan_all();
; 692  : 		_Alproxy.destroy(_Myproxy());
; 693  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 694  : 		_Myproxy() = 0;
; 695  : 		}
; 696  : 
; 697  : 	_Iterator_base12 **_Getpfirst() const
; 698  : 		{	// get address of iterator chain
; 699  : 		return (_Get_data()._Getpfirst());
; 700  : 		}
; 701  : 
; 702  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 703  : 		{	// return reference to _Myproxy
; 704  : 		return (_Get_data()._Myproxy);
; 705  : 		}
; 706  : 
; 707  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 708  : 		{	// return const reference to _Myproxy
; 709  : 		return (_Get_data()._Myproxy);
; 710  : 		}
; 711  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 712  : 
; 713  : 	_Nodeptr _Buyheadnode()
; 714  : 		{	// get head node using current allocator
; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0001b	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buynode0

; 527  : 		}
; 528  : 
; 529  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 530  : 		{	// return reference to successor pointer in node
; 531  : 		return ((_Nodepref)_Pnode->_Next);
; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);
; 537  : 		}
; 538  : 
; 539  : 	static reference _Myval(_Nodeptr _Pnode)
; 540  : 		{	// return reference to value in node
; 541  : 		return ((reference)_Pnode->_Myval);
; 542  : 		}
; 543  : 
; 544  : 	_Nodeptr _Myhead;	// pointer to head node
; 545  : 	size_type _Mysize;	// number of elements
; 546  : 	};
; 547  : 
; 548  : 		// TEMPLATE CLASS _List_alloc
; 549  : template<class _Alloc_types>
; 550  : 	class _List_alloc
; 551  : 	{	// base class for list to hold allocator
; 552  : public:
; 553  : 	typedef _List_alloc<_Alloc_types> _Myt;
; 554  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 555  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 556  : 	typedef typename _Alloc_types::_Node _Node;
; 557  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 558  : 
; 559  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 560  : 
; 561  : 	typedef _Nodeptr& _Nodepref;
; 562  : 
; 563  : 	typedef typename _Val_types::value_type value_type;
; 564  : 	typedef typename _Val_types::size_type size_type;
; 565  : 	typedef typename _Val_types::difference_type difference_type;
; 566  : 	typedef typename _Val_types::pointer pointer;
; 567  : 	typedef typename _Val_types::const_pointer const_pointer;
; 568  : 	typedef typename _Val_types::reference reference;
; 569  : 	typedef typename _Val_types::const_reference const_reference;
; 570  : 
; 571  : 	typedef _List_const_iterator<_List_val<_Val_types> > const_iterator;
; 572  : 	typedef _List_iterator<_List_val<_Val_types> > iterator;
; 573  : 
; 574  : 	typedef _List_unchecked_const_iterator<_List_val<_Val_types> >
; 575  : 		_Unchecked_const_iterator;
; 576  : 	typedef _List_unchecked_iterator<_List_val<_Val_types> >
; 577  : 		_Unchecked_iterator;
; 578  : 
; 579  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 580  : 		{	// return reference to successor pointer in node
; 581  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));
; 582  : 		}
; 583  : 
; 584  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 585  : 		{	// return reference to predecessor pointer in node
; 586  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));
; 587  : 		}
; 588  : 
; 589  : 	static reference _Myval(_Nodeptr _Pnode)
; 590  : 		{	// return reference to value in node
; 591  : 		return (_List_val<_Val_types>::_Myval(_Pnode));
; 592  : 		}
; 593  : 
; 594  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 595  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 596  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 597  : 		{	// construct head node, allocator from _Al
; 598  : 		_Myhead() = _Buyheadnode();

  00020	89 06		 mov	 DWORD PTR [esi], eax

; 818  : 		}

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z ENDP ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >,std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@SAAAU_EVENT_TIME@CBloodCastle@@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@SAAAU_EVENT_TIME@CBloodCastle@@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >::_Myval, COMDAT

; 540  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 541  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 542  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@SAAAU_EVENT_TIME@CBloodCastle@@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >::_Prevnode, COMDAT

; 535  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  : 		return ((_Nodepref)_Pnode->_Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 537  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >::_Nextnode, COMDAT

; 530  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 531  : 		return ((_Nodepref)_Pnode->_Next);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 532  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 524  : 		{	// initialize data
; 525  : 		this->_Myhead = 0;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 526  : 		this->_Mysize = 0;
; 527  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >::_List_val<std::_List_simple_types<CBloodCastle::_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Mysize, COMDAT
; _this$ = ecx

; 797  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 798  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Mysize, COMDAT
; _this$ = ecx

; 792  : 		return (_Get_data()._Mysize);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 793  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Myhead, COMDAT
; _this$ = ecx

; 782  : 		return (_Get_data()._Myhead);

  00000	8b c1		 mov	 eax, ecx

; 783  : 		}

  00002	c3		 ret	 0
?_Myhead@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Get_data, COMDAT
; _this$ = ecx

; 777  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 778  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Get_data, COMDAT
; _this$ = ecx

; 772  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 773  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@U_EVENT_TIME@CBloodCastle@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Getal, COMDAT
; _this$ = ecx

; 767  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 768  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Getal, COMDAT
; _this$ = ecx

; 762  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 763  : 		}

  00002	c3		 ret	 0
?_Getal@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@0@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@0@Z PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buynode0, COMDAT
; _this$ = ecx

; 729  : 		{	// allocate a node and set links

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 89   : 		_Ptr = ::operator new(_User_size);

  00003	6a 10		 push	 16			; 00000010H
  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0000d	85 c0		 test	 eax, eax
  0000f	74 1f		 je	 SHORT $LN123@Buynode0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 732  : 		if (_Next == _Nodeptr())

  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Next$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 06		 jne	 SHORT $LN121@Buynode0

; 733  : 			{	// point at self
; 734  : 			_Next = _Pnode;

  00018	8b c8		 mov	 ecx, eax

; 735  : 			_Prev = _Pnode;

  0001a	8b d0		 mov	 edx, eax
  0001c	eb 03		 jmp	 SHORT $LN2@Buynode0
$LN121@Buynode0:
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
$LN2@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00021	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 536  : 		return ((_Nodepref)_Pnode->_Prev);

  00023	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00026	85 c9		 test	 ecx, ecx
  00028	74 02		 je	 SHORT $LN4@Buynode0
  0002a	89 11		 mov	 DWORD PTR [ecx], edx
$LN4@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 748  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
$LN123@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN125@Buynode0:
$LN122@Buynode0:
  00035	cc		 int	 3
?_Buynode0@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@0@Z ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 719  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00003	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 725  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buynode0

; 716  : 		}

  00009	c3		 ret	 0
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??1?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::~_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00007	59		 pop	 ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 610  : 		}

  00008	c3		 ret	 0
??1?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::~_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ??0?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 597  : 		{	// construct head node, allocator from _Al

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 600  : 
; 601  : 	_List_alloc(_Alloc&& _Al)
; 602  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 603  : 		{	// construct head node, allocator from _Al
; 604  : 		_Myhead() = _Buyheadnode();
; 605  : 		}
; 606  : 
; 607  : 	~_List_alloc() _NOEXCEPT
; 608  : 		{	// destroy head node
; 609  : 		_Freeheadnode(_Myhead());
; 610  : 		}
; 611  : 
; 612  : 	void _Copy_alloc(const _Alty& _Al)
; 613  : 		{	// replace old allocator
; 614  : 		_Pocca(_Getal(), _Al);
; 615  : 		}
; 616  : 
; 617  : 	void _Move_alloc(_Alty& _Al)
; 618  : 		{	// replace old allocator
; 619  : 		_Pocma(_Getal(), _Al);
; 620  : 		}
; 621  : 
; 622  : 	void _Swap_alloc(_Myt& _Right)
; 623  : 		{	// swap allocators
; 624  : 		_Pocs(_Getal(), _Right._Getal());
; 625  : 		}
; 626  : 
; 627  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 628  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 629  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 630  : 		{	// construct head node, allocator from _Al
; 631  : 		_Myhead() = _Buyheadnode();
; 632  : 		_TRY_BEGIN
; 633  : 		_Alloc_proxy();
; 634  : 		_CATCH_ALL
; 635  : 		_Freeheadnode(_Myhead());
; 636  : 		_RERAISE;
; 637  : 		_CATCH_END
; 638  : 		}
; 639  : 
; 640  : 	_List_alloc(_Alloc&& _Al)
; 641  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 642  : 		{	// construct head node, allocator from _Al
; 643  : 		_Myhead() = _Buyheadnode();
; 644  : 		_TRY_BEGIN
; 645  : 		_Alloc_proxy();
; 646  : 		_CATCH_ALL
; 647  : 		_Freeheadnode(_Myhead());
; 648  : 		_RERAISE;
; 649  : 		_CATCH_END
; 650  : 		}
; 651  : 
; 652  : 	~_List_alloc() _NOEXCEPT
; 653  : 		{	// destroy proxy
; 654  : 		_Freeheadnode(_Myhead());
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Copy_alloc(const _Alty& _Al)
; 659  : 		{	// replace old allocator
; 660  : 		_Free_proxy();
; 661  : 		_Pocca(_Getal(), _Al);
; 662  : 		_Alloc_proxy();
; 663  : 		}
; 664  : 
; 665  : 	void _Move_alloc(_Alty& _Al)
; 666  : 		{	// replace old allocator
; 667  : 		_Free_proxy();
; 668  : 		_Pocma(_Getal(), _Al);
; 669  : 		_Alloc_proxy();
; 670  : 		}
; 671  : 
; 672  : 	void _Swap_alloc(_Myt& _Right)
; 673  : 		{	// swap allocators
; 674  : 		_Pocs(_Getal(), _Right._Getal());
; 675  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 676  : 		}
; 677  : 
; 678  : 	void _Alloc_proxy()
; 679  : 		{	// construct proxy
; 680  : 		typename _Alty::template rebind<_Container_proxy>::other
; 681  : 			_Alproxy(_Getal());
; 682  : 		_Myproxy() = _Alproxy.allocate(1);
; 683  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 684  : 		_Myproxy()->_Mycont = &_Get_data();
; 685  : 		}
; 686  : 
; 687  : 	void _Free_proxy()
; 688  : 		{	// destroy proxy
; 689  : 		typename _Alty::template rebind<_Container_proxy>::other
; 690  : 			_Alproxy(_Getal());
; 691  : 		_Orphan_all();
; 692  : 		_Alproxy.destroy(_Myproxy());
; 693  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 694  : 		_Myproxy() = 0;
; 695  : 		}
; 696  : 
; 697  : 	_Iterator_base12 **_Getpfirst() const
; 698  : 		{	// get address of iterator chain
; 699  : 		return (_Get_data()._Getpfirst());
; 700  : 		}
; 701  : 
; 702  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 703  : 		{	// return reference to _Myproxy
; 704  : 		return (_Get_data()._Myproxy);
; 705  : 		}
; 706  : 
; 707  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 708  : 		{	// return const reference to _Myproxy
; 709  : 		return (_Get_data()._Myproxy);
; 710  : 		}
; 711  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 712  : 
; 713  : 	_Nodeptr _Buyheadnode()
; 714  : 		{	// get head node using current allocator
; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0

; 525  : 		this->_Myhead = 0;

  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 526  : 		this->_Mysize = 0;

  0000d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 600  : 
; 601  : 	_List_alloc(_Alloc&& _Al)
; 602  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 603  : 		{	// construct head node, allocator from _Al
; 604  : 		_Myhead() = _Buyheadnode();
; 605  : 		}
; 606  : 
; 607  : 	~_List_alloc() _NOEXCEPT
; 608  : 		{	// destroy head node
; 609  : 		_Freeheadnode(_Myhead());
; 610  : 		}
; 611  : 
; 612  : 	void _Copy_alloc(const _Alty& _Al)
; 613  : 		{	// replace old allocator
; 614  : 		_Pocca(_Getal(), _Al);
; 615  : 		}
; 616  : 
; 617  : 	void _Move_alloc(_Alty& _Al)
; 618  : 		{	// replace old allocator
; 619  : 		_Pocma(_Getal(), _Al);
; 620  : 		}
; 621  : 
; 622  : 	void _Swap_alloc(_Myt& _Right)
; 623  : 		{	// swap allocators
; 624  : 		_Pocs(_Getal(), _Right._Getal());
; 625  : 		}
; 626  : 
; 627  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 628  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 629  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 630  : 		{	// construct head node, allocator from _Al
; 631  : 		_Myhead() = _Buyheadnode();
; 632  : 		_TRY_BEGIN
; 633  : 		_Alloc_proxy();
; 634  : 		_CATCH_ALL
; 635  : 		_Freeheadnode(_Myhead());
; 636  : 		_RERAISE;
; 637  : 		_CATCH_END
; 638  : 		}
; 639  : 
; 640  : 	_List_alloc(_Alloc&& _Al)
; 641  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 642  : 		{	// construct head node, allocator from _Al
; 643  : 		_Myhead() = _Buyheadnode();
; 644  : 		_TRY_BEGIN
; 645  : 		_Alloc_proxy();
; 646  : 		_CATCH_ALL
; 647  : 		_Freeheadnode(_Myhead());
; 648  : 		_RERAISE;
; 649  : 		_CATCH_END
; 650  : 		}
; 651  : 
; 652  : 	~_List_alloc() _NOEXCEPT
; 653  : 		{	// destroy proxy
; 654  : 		_Freeheadnode(_Myhead());
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Copy_alloc(const _Alty& _Al)
; 659  : 		{	// replace old allocator
; 660  : 		_Free_proxy();
; 661  : 		_Pocca(_Getal(), _Al);
; 662  : 		_Alloc_proxy();
; 663  : 		}
; 664  : 
; 665  : 	void _Move_alloc(_Alty& _Al)
; 666  : 		{	// replace old allocator
; 667  : 		_Free_proxy();
; 668  : 		_Pocma(_Getal(), _Al);
; 669  : 		_Alloc_proxy();
; 670  : 		}
; 671  : 
; 672  : 	void _Swap_alloc(_Myt& _Right)
; 673  : 		{	// swap allocators
; 674  : 		_Pocs(_Getal(), _Right._Getal());
; 675  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 676  : 		}
; 677  : 
; 678  : 	void _Alloc_proxy()
; 679  : 		{	// construct proxy
; 680  : 		typename _Alty::template rebind<_Container_proxy>::other
; 681  : 			_Alproxy(_Getal());
; 682  : 		_Myproxy() = _Alproxy.allocate(1);
; 683  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 684  : 		_Myproxy()->_Mycont = &_Get_data();
; 685  : 		}
; 686  : 
; 687  : 	void _Free_proxy()
; 688  : 		{	// destroy proxy
; 689  : 		typename _Alty::template rebind<_Container_proxy>::other
; 690  : 			_Alproxy(_Getal());
; 691  : 		_Orphan_all();
; 692  : 		_Alproxy.destroy(_Myproxy());
; 693  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 694  : 		_Myproxy() = 0;
; 695  : 		}
; 696  : 
; 697  : 	_Iterator_base12 **_Getpfirst() const
; 698  : 		{	// get address of iterator chain
; 699  : 		return (_Get_data()._Getpfirst());
; 700  : 		}
; 701  : 
; 702  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 703  : 		{	// return reference to _Myproxy
; 704  : 		return (_Get_data()._Myproxy);
; 705  : 		}
; 706  : 
; 707  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 708  : 		{	// return const reference to _Myproxy
; 709  : 		return (_Get_data()._Myproxy);
; 710  : 		}
; 711  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 712  : 
; 713  : 	_Nodeptr _Buyheadnode()
; 714  : 		{	// get head node using current allocator
; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00014	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buynode0

; 598  : 		_Myhead() = _Buyheadnode();

  00019	89 06		 mov	 DWORD PTR [esi], eax

; 599  : 		}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??0?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAE@ABV?$allocator@U_EVENT_TIME@CBloodCastle@@@1@@Z ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Myval@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@SAAAU_EVENT_TIME@CBloodCastle@@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@SAAAU_EVENT_TIME@CBloodCastle@@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Myval, COMDAT

; 590  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 541  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 591  : 		return (_List_val<_Val_types>::_Myval(_Pnode));
; 592  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@SAAAU_EVENT_TIME@CBloodCastle@@PAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Prevnode, COMDAT

; 585  : 		{	// return reference to predecessor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  : 		return ((_Nodepref)_Pnode->_Prev);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 586  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));
; 587  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Prevnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Nextnode, COMDAT

; 580  : 		{	// return reference to successor pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 581  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 582  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Nextnode@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@SAAAPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 931  : 		}

  00005	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 910  : 		}

  00003	5d		 pop	 ebp

; 909  : 		_Mybase::deallocate(_Ptr, _Count);

  00004	e9 00 00 00 00	 jmp	 ?deallocate@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 786  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 668  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	3d ff ff ff 0f	 cmp	 eax, 268435455		; 0fffffffH
  00013	77 3c		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;

  00015	c1 e0 04	 shl	 eax, 4

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00018	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001d	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0001f	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  00022	3b c8		 cmp	 ecx, eax
  00024	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002c	8b c8		 mov	 ecx, eax
  0002e	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00031	85 c9		 test	 ecx, ecx
  00033	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00035	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00038	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003b	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00048	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0004b	85 c0		 test	 eax, eax
  0004d	75 bb		 jne	 SHORT $LN12@allocate
  0004f	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00056	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00065	cc		 int	 3
?allocate@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	81 f9 ff ff ff
	0f		 cmp	 ecx, 268435455		; 0fffffffH
  0000f	77 31		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00011	c1 e1 04	 shl	 ecx, 4

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 19		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001c	a8 1f		 test	 al, 31			; 0000001fH
  0001e	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00020	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00023	3b c8		 cmp	 ecx, eax
  00025	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00027	2b c1		 sub	 eax, ecx
  00029	83 f8 04	 cmp	 eax, 4
  0002c	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002e	83 f8 23	 cmp	 eax, 35			; 00000023H
  00031	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00033	8b c1		 mov	 eax, ecx
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003b	83 c4 04	 add	 esp, 4

; 639  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00042	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00047	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00051	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00056	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005b	cc		 int	 3
?deallocate@?$allocator@U?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@std@@@std@@QAEXPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<CBloodCastle::_EVENT_TIME,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@QAE@XZ PROC ; std::allocator<CBloodCastle::_EVENT_TIME>::allocator<CBloodCastle::_EVENT_TIME>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@QAE@XZ ENDP ; std::allocator<CBloodCastle::_EVENT_TIME>::allocator<CBloodCastle::_EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z PROC	; CBloodCastle::GetAliveUserTotalEXP, COMDAT
; _this$ = ecx

; 2738 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2739 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 67		 js	 SHORT $LN20@GetAliveUs
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fe 07	 cmp	 esi, 7
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 5b		 je	 SHORT $LN20@GetAliveUs

; 2742 : 	}
; 2743 : 
; 2744 : 	int iRET_EXP = 0;

  00017	69 c6 0c 02 00
	00		 imul	 eax, esi, 524
  0001d	33 d2		 xor	 edx, edx
  0001f	53		 push	 ebx
  00020	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00023	57		 push	 edi
  00024	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	8d 72 0a	 lea	 esi, DWORD PTR [edx+10]
  0002d	03 c8		 add	 ecx, eax
  0002f	90		 npad	 1
$LL4@GetAliveUs:

; 2747 : 	{
; 2748 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	83 f8 ff	 cmp	 eax, -1
  00035	74 2a		 je	 SHORT $LN2@GetAliveUs

; 2749 : 		{
; 2750 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00037	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0003d	83 7c 38 04 02	 cmp	 DWORD PTR [eax+edi+4], 2
  00042	7e 1d		 jle	 SHORT $LN2@GetAliveUs

; 2751 : 			{
; 2752 : 				if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  00044	8a 84 38 23 01
	00 00		 mov	 al, BYTE PTR [eax+edi+291]
  0004b	3c 34		 cmp	 al, 52			; 00000034H
  0004d	74 0f		 je	 SHORT $LN21@GetAliveUs
  0004f	3c 0b		 cmp	 al, 11			; 0000000bH
  00051	72 0e		 jb	 SHORT $LN2@GetAliveUs
  00053	b3 11		 mov	 bl, 17			; 00000011H
  00055	3a d8		 cmp	 bl, al
  00057	1b c0		 sbb	 eax, eax
  00059	83 c0 01	 add	 eax, 1
  0005c	74 03		 je	 SHORT $LN2@GetAliveUs
$LN21@GetAliveUs:

; 2753 : 				{
; 2754 : 					iRET_EXP += this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP;

  0005e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
$LN2@GetAliveUs:

; 2745 : 
; 2746 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00061	83 c1 14	 add	 ecx, 20			; 00000014H
  00064	83 ee 01	 sub	 esi, 1
  00067	75 c7		 jne	 SHORT $LL4@GetAliveUs

; 2755 : 				}
; 2756 : 			}
; 2757 : 		}
; 2758 : 	}
; 2759 : 
; 2760 : 	return iRET_EXP;

  00069	5f		 pop	 edi
  0006a	5b		 pop	 ebx
  0006b	8b c2		 mov	 eax, edx
  0006d	5e		 pop	 esi

; 2761 : }

  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
$LN20@GetAliveUs:

; 2740 : 	{
; 2741 : 		return 0;

  00072	33 c0		 xor	 eax, eax
  00074	5e		 pop	 esi

; 2761 : }

  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z ENDP	; CBloodCastle::GetAliveUserTotalEXP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z
_TEXT	SEGMENT
_iMAP_NUM$ = 8						; size = 4
_iSTART_X$ = 12						; size = 4
_iSTART_Y$ = 16						; size = 4
_iEND_X$ = 20						; size = 4
_iEND_Y$ = 24						; size = 4
?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z PROC		; CBloodCastle::ReleaseSector, COMDAT
; _this$ = ecx

; 2435 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2436 : 
; 2437 : 	if ( BC_MAP_RANGE(iMAP_NUM) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iMAP_NUM$[ebp]
  00006	83 f9 34	 cmp	 ecx, 52			; 00000034H
  00009	74 11		 je	 SHORT $LN22@ReleaseSec
  0000b	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0000e	7c 59		 jl	 SHORT $LN3@ReleaseSec
  00010	33 c0		 xor	 eax, eax
  00012	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00015	0f 9e c0	 setle	 al
  00018	85 c0		 test	 eax, eax
  0001a	74 4d		 je	 SHORT $LN3@ReleaseSec
$LN22@ReleaseSec:

; 2438 : 	{
; 2439 : 		return;
; 2440 : 	}
; 2441 : 
; 2442 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  0001c	8b 45 14	 mov	 eax, DWORD PTR _iEND_X$[ebp]
  0001f	56		 push	 esi
  00020	8b 75 0c	 mov	 esi, DWORD PTR _iSTART_X$[ebp]
  00023	3b f0		 cmp	 esi, eax
  00025	7f 41		 jg	 SHORT $LN23@ReleaseSec
  00027	8b 55 18	 mov	 edx, DWORD PTR _iEND_Y$[ebp]
  0002a	53		 push	 ebx
  0002b	8b 5d 10	 mov	 ebx, DWORD PTR _iSTART_Y$[ebp]
  0002e	57		 push	 edi
  0002f	90		 npad	 1
$LL4@ReleaseSec:

; 2443 : 	{
; 2444 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  00030	3b da		 cmp	 ebx, edx
  00032	7f 2d		 jg	 SHORT $LN2@ReleaseSec
  00034	8b c3		 mov	 eax, ebx
  00036	69 f9 28 38 05
	00		 imul	 edi, ecx, 342056
  0003c	2b d3		 sub	 edx, ebx
  0003e	c1 e0 08	 shl	 eax, 8
  00041	42		 inc	 edx
$LL7@ReleaseSec:

; 2445 : 		{
; 2446 : 			MapC[iMAP_NUM].m_attrbuf[j * 256 + i] &= ~4;

  00042	8b 8f 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[edi+16]
  00048	03 c8		 add	 ecx, eax
  0004a	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0004f	80 24 31 fb	 and	 BYTE PTR [ecx+esi], 251	; 000000fbH
  00053	83 ea 01	 sub	 edx, 1
  00056	75 ea		 jne	 SHORT $LL7@ReleaseSec
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _iMAP_NUM$[ebp]
  0005b	8b 55 18	 mov	 edx, DWORD PTR _iEND_Y$[ebp]
  0005e	8b 45 14	 mov	 eax, DWORD PTR _iEND_X$[ebp]
$LN2@ReleaseSec:

; 2438 : 	{
; 2439 : 		return;
; 2440 : 	}
; 2441 : 
; 2442 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  00061	46		 inc	 esi
  00062	3b f0		 cmp	 esi, eax
  00064	7e ca		 jle	 SHORT $LL4@ReleaseSec
  00066	5f		 pop	 edi
  00067	5b		 pop	 ebx
$LN23@ReleaseSec:
  00068	5e		 pop	 esi
$LN3@ReleaseSec:

; 2447 : 		}
; 2448 : 	}
; 2449 : 
; 2450 : }

  00069	5d		 pop	 ebp
  0006a	c2 14 00	 ret	 20			; 00000014H
?ReleaseSector@CBloodCastle@@IAEXHHHHH@Z ENDP		; CBloodCastle::ReleaseSector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?BlockSector@CBloodCastle@@IAEXHHHHH@Z
_TEXT	SEGMENT
_iMAP_NUM$ = 8						; size = 4
_iSTART_X$ = 12						; size = 4
_iSTART_Y$ = 16						; size = 4
_iEND_X$ = 20						; size = 4
_iEND_Y$ = 24						; size = 4
?BlockSector@CBloodCastle@@IAEXHHHHH@Z PROC		; CBloodCastle::BlockSector, COMDAT
; _this$ = ecx

; 2415 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2416 : 	if ( BC_MAP_RANGE(iMAP_NUM) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iMAP_NUM$[ebp]
  00006	83 f9 34	 cmp	 ecx, 52			; 00000034H
  00009	74 11		 je	 SHORT $LN22@BlockSecto
  0000b	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0000e	7c 59		 jl	 SHORT $LN3@BlockSecto
  00010	33 c0		 xor	 eax, eax
  00012	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00015	0f 9e c0	 setle	 al
  00018	85 c0		 test	 eax, eax
  0001a	74 4d		 je	 SHORT $LN3@BlockSecto
$LN22@BlockSecto:

; 2417 : 	{
; 2418 : 		return;
; 2419 : 	}
; 2420 : 
; 2421 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  0001c	8b 45 14	 mov	 eax, DWORD PTR _iEND_X$[ebp]
  0001f	56		 push	 esi
  00020	8b 75 0c	 mov	 esi, DWORD PTR _iSTART_X$[ebp]
  00023	3b f0		 cmp	 esi, eax
  00025	7f 41		 jg	 SHORT $LN23@BlockSecto
  00027	8b 55 18	 mov	 edx, DWORD PTR _iEND_Y$[ebp]
  0002a	53		 push	 ebx
  0002b	8b 5d 10	 mov	 ebx, DWORD PTR _iSTART_Y$[ebp]
  0002e	57		 push	 edi
  0002f	90		 npad	 1
$LL4@BlockSecto:

; 2422 : 	{
; 2423 : 		for ( int j=iSTART_Y;j<=iEND_Y;j++ )

  00030	3b da		 cmp	 ebx, edx
  00032	7f 2d		 jg	 SHORT $LN2@BlockSecto
  00034	8b c3		 mov	 eax, ebx
  00036	69 f9 28 38 05
	00		 imul	 edi, ecx, 342056
  0003c	2b d3		 sub	 edx, ebx
  0003e	c1 e0 08	 shl	 eax, 8
  00041	42		 inc	 edx
$LL7@BlockSecto:

; 2424 : 		{
; 2425 : 			MapC[iMAP_NUM].m_attrbuf[j * 256 + i] |= 4;

  00042	8b 8f 10 00 00
	00		 mov	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[edi+16]
  00048	03 c8		 add	 ecx, eax
  0004a	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0004f	80 0c 31 04	 or	 BYTE PTR [ecx+esi], 4
  00053	83 ea 01	 sub	 edx, 1
  00056	75 ea		 jne	 SHORT $LL7@BlockSecto
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _iMAP_NUM$[ebp]
  0005b	8b 55 18	 mov	 edx, DWORD PTR _iEND_Y$[ebp]
  0005e	8b 45 14	 mov	 eax, DWORD PTR _iEND_X$[ebp]
$LN2@BlockSecto:

; 2417 : 	{
; 2418 : 		return;
; 2419 : 	}
; 2420 : 
; 2421 : 	for ( int i=iSTART_X;i<=iEND_X;i++)

  00061	46		 inc	 esi
  00062	3b f0		 cmp	 esi, eax
  00064	7e ca		 jle	 SHORT $LL4@BlockSecto
  00066	5f		 pop	 edi
  00067	5b		 pop	 ebx
$LN23@BlockSecto:
  00068	5e		 pop	 esi
$LN3@BlockSecto:

; 2426 : 		}
; 2427 : 	}
; 2428 : }

  00069	5d		 pop	 ebp
  0006a	c2 14 00	 ret	 20			; 00000014H
?BlockSector@CBloodCastle@@IAEXHHHHH@Z ENDP		; CBloodCastle::BlockSector
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetState_PlayEnd@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?SetState_PlayEnd@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_PlayEnd, COMDAT
; _this$ = ecx

; 1020 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 1021 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	78 7d		 js	 SHORT $LN3@SetState_P
  0000e	33 c0		 xor	 eax, eax
  00010	83 ff 07	 cmp	 edi, 7
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 71		 je	 SHORT $LN3@SetState_P

; 1022 : 	{
; 1023 : 		return;
; 1024 : 	}
; 1025 : 
; 1026 : 	this->SendNoticeState(iBridgeIndex, 2);

  0001a	56		 push	 esi
  0001b	6a 02		 push	 2
  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 1027 : 	this->ClearMonster(iBridgeIndex, 0);

  00023	6a 00		 push	 0
  00025	57		 push	 edi
  00026	8b cb		 mov	 ecx, ebx
  00028	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 1028 : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  0002d	69 f7 0c 02 00
	00		 imul	 esi, edi, 524
  00033	03 f3		 add	 esi, ebx
  00035	c6 86 63 01 00
	00 00		 mov	 BYTE PTR [esi+355], 0

; 1029 : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = this->m_iBC_TIME_MIN_REST*60*1000;

  0003c	69 83 70 10 00
	00 60 ea 00 00	 imul	 eax, DWORD PTR [ebx+4208], 60000
  00046	89 86 54 01 00
	00		 mov	 DWORD PTR [esi+340], eax

; 1030 : 
; 1031 : 	LogAddTD("[Blood Castle] (%d) SetState PLAYEND", iBridgeIndex+1);

  0004c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0004f	50		 push	 eax
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OPFFLCHN@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0005b	83 c4 08	 add	 esp, 8
  0005e	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00063	83 c6 1c	 add	 esi, 28			; 0000001cH
$LL4@SetState_P:

; 1034 : 	{
; 1035 : 		if ( OBJMAX_RANGE(this->m_BridgeData[iBridgeIndex].m_UserData[n].m_iIndex) != FALSE )

  00066	8b 06		 mov	 eax, DWORD PTR [esi]
  00068	85 c0		 test	 eax, eax
  0006a	78 16		 js	 SHORT $LN2@SetState_P
  0006c	33 c9		 xor	 ecx, ecx
  0006e	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00073	0f 9e c1	 setle	 cl
  00076	85 c9		 test	 ecx, ecx
  00078	74 08		 je	 SHORT $LN2@SetState_P

; 1036 : 		{
; 1037 : 			this->SearchUserDeleteQuestItem(this->m_BridgeData[iBridgeIndex].m_UserData[n].m_iIndex);

  0007a	50		 push	 eax
  0007b	8b cb		 mov	 ecx, ebx
  0007d	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN2@SetState_P:

; 1032 : 
; 1033 : 	for (int n=0;n<MAX_BLOOD_CASTLE_SUB_BRIDGE;n++)

  00082	83 c6 14	 add	 esi, 20			; 00000014H
  00085	83 ef 01	 sub	 edi, 1
  00088	75 dc		 jne	 SHORT $LL4@SetState_P
  0008a	5e		 pop	 esi
$LN3@SetState_P:
  0008b	5f		 pop	 edi
  0008c	5b		 pop	 ebx

; 1038 : 		}
; 1039 : 	}
; 1040 : }

  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
?SetState_PlayEnd@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_PlayEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetState_Playing@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv253 = -292						; size = 4
tv252 = -288						; size = 4
_ServerCmd$ = -284					; size = 7
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_Playing@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_Playing, COMDAT
; _this$ = ecx

; 979  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00018	8b d9		 mov	 ebx, ecx

; 980  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 29 01 00
	00		 js	 $LN1@SetState_P
  00022	33 c0		 xor	 eax, eax
  00024	83 fe 07	 cmp	 esi, 7
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 19 01 00
	00		 je	 $LN1@SetState_P

; 981  : 	{
; 982  : 		return;
; 983  : 	}
; 984  : 
; 985  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  00032	69 ce 0c 02 00
	00		 imul	 ecx, esi, 524
  00038	57		 push	 edi

; 986  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = this->m_iBC_TIME_MIN_PLAY*60*1000;
; 987  : 	this->CheckUsersOnConnect(iBridgeIndex);

  00039	56		 push	 esi
  0003a	c6 84 19 63 01
	00 00 00	 mov	 BYTE PTR [ecx+ebx+355], 0
  00042	69 83 6c 10 00
	00 60 ea 00 00	 imul	 eax, DWORD PTR [ebx+4204], 60000
  0004c	89 84 19 54 01
	00 00		 mov	 DWORD PTR [ecx+ebx+340], eax
  00053	8b cb		 mov	 ecx, ebx
  00055	e8 00 00 00 00	 call	 ?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ; CBloodCastle::CheckUsersOnConnect

; 988  : 
; 989  : 	PMSG_NOTICE pNotice;
; 990  : 
; 991  : 	TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 139)), iBridgeIndex+1, 60);

  0005a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0005d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00062	6a 3c		 push	 60			; 0000003cH
  00064	50		 push	 eax
  00065	68 8b 04 00 00	 push	 1163			; 0000048bH
  0006a	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv253[ebp], eax
  00070	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00075	50		 push	 eax
  00076	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  0007c	6a 01		 push	 1
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 992  : 	this->SendBridgeAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  00084	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  0008b	83 c4 14	 add	 esp, 20			; 00000014H
  0008e	8b cb		 mov	 ecx, ebx
  00090	56		 push	 esi
  00091	50		 push	 eax
  00092	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 993  : 
; 994  : 	PMSG_SERVERCMD ServerCmd;
; 995  : 
; 996  : 	PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  0009e	6a 07		 push	 7
  000a0	6a 40		 push	 64			; 00000040H
  000a2	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _ServerCmd$[ebp]
  000a8	68 f3 00 00 00	 push	 243			; 000000f3H
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 997  : 	ServerCmd.CmdType = 1;
; 998  : 	ServerCmd.X = 45;
; 999  : 	ServerCmd.Y = 0;
; 1000 : 
; 1001 : 	this->SendBridgeAnyMsg((BYTE *)&ServerCmd, ServerCmd.h.size, iBridgeIndex);

  000b3	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _ServerCmd$[ebp+1]
  000ba	83 c4 10	 add	 esp, 16			; 00000010H
  000bd	8b cb		 mov	 ecx, ebx
  000bf	66 c7 85 e8 fe
	ff ff 01 2d	 mov	 WORD PTR _ServerCmd$[ebp+4], 11521 ; 00002d01H
  000c8	c6 85 ea fe ff
	ff 00		 mov	 BYTE PTR _ServerCmd$[ebp+6], 0
  000cf	56		 push	 esi
  000d0	50		 push	 eax
  000d1	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _ServerCmd$[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 1004 : 	{
; 1005 : 		if ( gObj[n].MapNumber == GetEventMap(iBridgeIndex) && gObj[n].Connected > PLAYER_LOGGED )

  000dd	56		 push	 esi
  000de	8b cb		 mov	 ecx, ebx
  000e0	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  000e5	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  000ea	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv252[ebp], eax
  000f0	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
  000f5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@SetState_P:
  00100	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00106	0f b6 8c 32 23
	01 00 00	 movzx	 ecx, BYTE PTR [edx+esi+291]
  0010e	3b c8		 cmp	 ecx, eax
  00110	75 15		 jne	 SHORT $LN2@SetState_P
  00112	83 7c 32 04 02	 cmp	 DWORD PTR [edx+esi+4], 2
  00117	7e 0e		 jle	 SHORT $LN2@SetState_P

; 1006 : 		{
; 1007 : 			this->SearchUserDeleteQuestItem(n);

  00119	57		 push	 edi
  0011a	8b cb		 mov	 ecx, ebx
  0011c	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
  00121	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv252[ebp]
$LN2@SetState_P:

; 1002 : 
; 1003 : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  00127	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  0012d	47		 inc	 edi
  0012e	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00134	7c ca		 jl	 SHORT $LL4@SetState_P

; 1008 : 		}
; 1009 : 	}
; 1010 : 
; 1011 : 	LogAddTD("[Blood Castle] (%d) SetState PLAYING", iBridgeIndex+1);

  00136	ff b5 dc fe ff
	ff		 push	 DWORD PTR tv253[ebp]
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@IOKOFOAG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5PLA@
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00147	83 c4 08	 add	 esp, 8
  0014a	5f		 pop	 edi
$LN1@SetState_P:

; 1012 : }

  0014b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014e	5e		 pop	 esi
  0014f	33 cd		 xor	 ecx, ebp
  00151	5b		 pop	 ebx
  00152	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c2 04 00	 ret	 4
?SetState_Playing@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_Playing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetState_Closed@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
tv241 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_Closed@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_Closed, COMDAT
; _this$ = ecx

; 945  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi

; 946  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00009	8b d9		 mov	 ebx, ecx
  0000b	85 ff		 test	 edi, edi
  0000d	0f 88 c1 00 00
	00		 js	 $LN1@SetState_C
  00013	33 c0		 xor	 eax, eax
  00015	83 ff 07	 cmp	 edi, 7
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	0f 84 b1 00 00
	00		 je	 $LN1@SetState_C

; 947  : 	{
; 948  : 		return;
; 949  : 	}
; 950  : 
; 951  : 	this->SendNoticeState(iBridgeIndex, 2);

  00023	56		 push	 esi
  00024	6a 02		 push	 2
  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 952  : 	this->ClearBridgeData(iBridgeIndex);

  0002c	57		 push	 edi
  0002d	8b cb		 mov	 ecx, ebx
  0002f	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 953  : 	this->ClearMonster(iBridgeIndex, 1);

  00034	6a 01		 push	 1
  00036	57		 push	 edi
  00037	8b cb		 mov	 ecx, ebx
  00039	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 954  : 	this->CheckAngelKingExist(iBridgeIndex);

  0003e	57		 push	 edi
  0003f	8b cb		 mov	 ecx, ebx
  00041	e8 00 00 00 00	 call	 ?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckAngelKingExist

; 957  : 	{
; 958  : 		int MapNumber = GetEventMap(iBridgeIndex);

  00046	57		 push	 edi
  00047	8b cb		 mov	 ecx, ebx
  00049	be 04 29 00 00	 mov	 esi, 10500		; 00002904H
  0004e	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00053	89 45 fc	 mov	 DWORD PTR tv241[ebp], eax
  00056	bf 00 dd 49 06	 mov	 edi, 105504000		; 0649dd00H
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@SetState_C:

; 959  : 		if ( gObj[n].MapNumber == MapNumber && gObj[n].Connected > PLAYER_LOGGED )

  00060	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	0f b6 8c 3a 23
	01 00 00	 movzx	 ecx, BYTE PTR [edx+edi+291]
  0006e	3b c8		 cmp	 ecx, eax
  00070	75 1d		 jne	 SHORT $LN2@SetState_C
  00072	83 7c 3a 04 02	 cmp	 DWORD PTR [edx+edi+4], 2
  00077	7e 16		 jle	 SHORT $LN2@SetState_C

; 960  : 		{
; 961  : 			this->SearchUserDeleteQuestItem(n);

  00079	56		 push	 esi
  0007a	8b cb		 mov	 ecx, ebx
  0007c	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem

; 962  : 			gObjMoveGate(n, 22);

  00081	6a 16		 push	 22			; 00000016H
  00083	56		 push	 esi
  00084	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00089	8b 45 fc	 mov	 eax, DWORD PTR tv241[ebp]
  0008c	83 c4 08	 add	 esp, 8
$LN2@SetState_C:

; 955  : 
; 956  : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  0008f	81 c7 40 27 00
	00		 add	 edi, 10048		; 00002740H
  00095	46		 inc	 esi
  00096	81 ff 00 2f e3
	06		 cmp	 edi, 115552000		; 06e32f00H
  0009c	7c c2		 jl	 SHORT $LL4@SetState_C

; 963  : 		}
; 964  : 	}
; 965  : 
; 966  : 	this->BlockCastleDoor(iBridgeIndex);

  0009e	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  000a1	8b cb		 mov	 ecx, ebx
  000a3	56		 push	 esi
  000a4	e8 00 00 00 00	 call	 ?BlockCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleDoor

; 967  : 	this->BlockCastleBridge(iBridgeIndex);

  000a9	56		 push	 esi
  000aa	8b cb		 mov	 ecx, ebx
  000ac	e8 00 00 00 00	 call	 ?BlockCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleBridge

; 968  : 	this->BlockCastleEntrance(iBridgeIndex);

  000b1	56		 push	 esi
  000b2	8b cb		 mov	 ecx, ebx
  000b4	e8 00 00 00 00	 call	 ?BlockCastleEntrance@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleEntrance

; 969  : 	this->CheckSync(iBridgeIndex);

  000b9	56		 push	 esi
  000ba	8b cb		 mov	 ecx, ebx
  000bc	e8 00 00 00 00	 call	 ?CheckSync@CBloodCastle@@IAEXH@Z ; CBloodCastle::CheckSync

; 970  : 	LogAddTD("[Blood Castle] (%d) SetState CLOSED", iBridgeIndex+1);

  000c1	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000c4	50		 push	 eax
  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@INEHOCBG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5SetState?5CLO@
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000d0	83 c4 08	 add	 esp, 8
  000d3	5e		 pop	 esi
$LN1@SetState_C:
  000d4	5f		 pop	 edi
  000d5	5b		 pop	 ebx

; 971  : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
?SetState_Closed@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_Closed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetState_None@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv216 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetState_None@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::SetState_None, COMDAT
; _this$ = ecx

; 917  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 918  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	89 75 fc	 mov	 DWORD PTR _this$1$[ebp], esi
  0000e	85 db		 test	 ebx, ebx
  00010	0f 88 aa 00 00
	00		 js	 $LN1@SetState_N
  00016	33 c0		 xor	 eax, eax
  00018	83 fb 07	 cmp	 ebx, 7
  0001b	0f 9e c0	 setle	 al
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 9a 00 00
	00		 je	 $LN1@SetState_N

; 919  : 	{
; 920  : 		return;
; 921  : 	}
; 922  : 
; 923  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = -1;

  00026	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524
  0002c	57		 push	 edi

; 924  : 	this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = -1;
; 925  : 	this->SendNoticeState(iBridgeIndex, 2);

  0002d	6a 02		 push	 2
  0002f	53		 push	 ebx
  00030	c7 84 30 54 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [eax+esi+340], -1
  0003b	c7 84 30 58 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [eax+esi+344], -1
  00046	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 926  : 	this->ClearBridgeData(iBridgeIndex);

  0004b	53		 push	 ebx
  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData

; 927  : 	this->ClearMonster(iBridgeIndex, 1);

  00053	6a 01		 push	 1
  00055	53		 push	 ebx
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?ClearMonster@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::ClearMonster

; 930  : 	{
; 931  : 		int MapNumber = GetEventMap(iBridgeIndex);

  0005d	53		 push	 ebx
  0005e	8b ce		 mov	 ecx, esi
  00060	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  00065	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  0006a	89 45 08	 mov	 DWORD PTR tv216[ebp], eax
  0006d	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
  00072	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL4@SetState_N:

; 932  : 		if ( gObj[n].MapNumber == MapNumber && gObj[n].Connected == PLAYER_PLAYING )

  00080	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00086	0f b6 8c 32 23
	01 00 00	 movzx	 ecx, BYTE PTR [edx+esi+291]
  0008e	3b c8		 cmp	 ecx, eax
  00090	75 15		 jne	 SHORT $LN2@SetState_N
  00092	83 7c 32 04 03	 cmp	 DWORD PTR [edx+esi+4], 3
  00097	75 0e		 jne	 SHORT $LN2@SetState_N

; 933  : 		{
; 934  : 			gObjMoveGate(n, 22);

  00099	6a 16		 push	 22			; 00000016H
  0009b	57		 push	 edi
  0009c	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000a1	8b 45 08	 mov	 eax, DWORD PTR tv216[ebp]
  000a4	83 c4 08	 add	 esp, 8
$LN2@SetState_N:

; 928  : 
; 929  : 	for (int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  000a7	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  000ad	47		 inc	 edi
  000ae	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  000b4	7c ca		 jl	 SHORT $LL4@SetState_N

; 935  : 		}
; 936  : 	}
; 937  : 
; 938  : 	this->BlockCastleDoor(iBridgeIndex);

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000b9	53		 push	 ebx
  000ba	e8 00 00 00 00	 call	 ?BlockCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::BlockCastleDoor
  000bf	5f		 pop	 edi
$LN1@SetState_N:
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx

; 939  : }

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 04 00	 ret	 4
?SetState_None@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::SetState_None
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_pMsg$1 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_PlayEnd, COMDAT
; _this$ = ecx

; 882  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 883  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00007	56		 push	 esi
  00008	69 f3 0c 02 00
	00		 imul	 esi, ebx, 524
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	03 f7		 add	 esi, edi
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00019	2b 86 58 01 00
	00		 sub	 eax, DWORD PTR [esi+344]

; 884  : 
; 885  : 	if ( iTICK_MSEC >= 1000 )

  0001f	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00024	7c 58		 jl	 SHORT $LN3@ProcState_

; 886  : 	{
; 887  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  00026	29 86 54 01 00
	00		 sub	 DWORD PTR [esi+340], eax

; 888  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00032	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax

; 889  : 
; 890  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex]. m_bBC_MSG_BEFORE_QUIT == false)

  00038	8b 86 54 01 00
	00		 mov	 eax, DWORD PTR [esi+340]
  0003e	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00043	7f 39		 jg	 SHORT $LN3@ProcState_
  00045	85 c0		 test	 eax, eax
  00047	7e 35		 jle	 SHORT $LN3@ProcState_
  00049	80 be 6a 01 00
	00 00		 cmp	 BYTE PTR [esi+362], 0
  00050	75 2c		 jne	 SHORT $LN3@ProcState_

; 891  : 		{
; 892  : 			this->m_BridgeData[iBridgeIndex]. m_bBC_MSG_BEFORE_QUIT = true;
; 893  : 
; 894  : 			PMSG_SET_DEVILSQUARE pMsg;
; 895  : 
; 896  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00052	6a 04		 push	 4
  00054	8d 45 08	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00057	c6 86 6a 01 00
	00 01		 mov	 BYTE PTR [esi+362], 1
  0005e	68 92 00 00 00	 push	 146			; 00000092H
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 897  : 			pMsg.Type = 6;

  0006c	c6 45 0b 06	 mov	 BYTE PTR _pMsg$1[ebp+3], 6

; 898  : 
; 899  : 			this->SendBridgeAnyMsg((BYTE *)&pMsg, sizeof(pMsg), iBridgeIndex);

  00070	8d 45 08	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00073	8b cf		 mov	 ecx, edi
  00075	53		 push	 ebx
  00076	6a 04		 push	 4
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN3@ProcState_:

; 900  : 		}
; 901  : 
; 902  : 
; 903  : 	}
; 904  : 
; 905  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  0007e	83 be 54 01 00
	00 00		 cmp	 DWORD PTR [esi+340], 0
  00085	7f 0a		 jg	 SHORT $LN4@ProcState_

; 906  : 	{
; 907  : 		this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  00087	6a 01		 push	 1
  00089	53		 push	 ebx
  0008a	8b cf		 mov	 ecx, edi
  0008c	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN4@ProcState_:
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx

; 908  : 	}
; 909  : }

  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_PlayEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ProcState_Playing@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$GSCopy$1$ = -288				; size = 4
_pMsg$1 = -284						; size = 4
_pMsg$2 = -284						; size = 4
_this$GSCopy$1$ = -280					; size = 4
_pNotice$3 = -276					; size = 272
_pNotice$4 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_Playing@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_Playing, COMDAT
; _this$ = ecx

; 720  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00019	8b f1		 mov	 esi, ecx

; 721  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;

  0001b	69 df 0c 02 00
	00		 imul	 ebx, edi, 524
  00021	89 b5 e8 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00027	89 bd e0 fe ff
	ff		 mov	 DWORD PTR _iBridgeIndex$GSCopy$1$[ebp], edi
  0002d	03 de		 add	 ebx, esi
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00035	2b 83 58 01 00
	00		 sub	 eax, DWORD PTR [ebx+344]

; 722  : 
; 723  : 	if ( iTICK_MSEC >= 1000 )

  0003b	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00040	0f 8c a9 03 00
	00		 jl	 $LN20@ProcState_

; 724  : 	{
; 725  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  00046	29 83 54 01 00
	00		 sub	 DWORD PTR [ebx+340], eax

; 726  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00052	89 83 58 01 00
	00		 mov	 DWORD PTR [ebx+344], eax

; 727  : 
; 728  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ((this->m_iBC_TIME_MIN_PLAY*60-30)*1000) )

  00058	69 86 6c 10 00
	00 60 ea 00 00	 imul	 eax, DWORD PTR [esi+4204], 60000
  00062	2d 30 75 00 00	 sub	 eax, 30000		; 00007530H
  00067	39 83 54 01 00
	00		 cmp	 DWORD PTR [ebx+340], eax
  0006d	7f 3e		 jg	 SHORT $LN4@ProcState_

; 729  : 		{
; 730  : 			if ( this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY == false )

  0006f	80 bb 68 01 00
	00 00		 cmp	 BYTE PTR [ebx+360], 0
  00076	75 35		 jne	 SHORT $LN4@ProcState_

; 731  : 			{
; 732  : 				this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY = true;
; 733  : 				
; 734  : 				PMSG_SET_DEVILSQUARE pMsg;
; 735  : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00078	6a 04		 push	 4
  0007a	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$2[ebp]
  00080	c6 83 68 01 00
	00 01		 mov	 BYTE PTR [ebx+360], 1
  00087	68 92 00 00 00	 push	 146			; 00000092H
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 736  : 				pMsg.Type = 4;

  00095	c6 85 e7 fe ff
	ff 04		 mov	 BYTE PTR _pMsg$2[ebp+3], 4

; 737  : 				this->SendBridgeAnyMsg((BYTE*)&pMsg, sizeof(pMsg), iBridgeIndex);

  0009c	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$2[ebp]
  000a2	8b ce		 mov	 ecx, esi
  000a4	57		 push	 edi
  000a5	6a 04		 push	 4
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN4@ProcState_:

; 738  : 			}
; 739  : 		}
; 740  : 
; 741  : 		if ( this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE != false	)

  000ad	80 bb 60 01 00
	00 00		 cmp	 BYTE PTR [ebx+352], 0
  000b4	0f 84 a1 00 00
	00		 je	 $LN9@ProcState_

; 742  : 		{
; 743  : 			if ( this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN != -1 )

  000ba	83 bb 80 01 00
	00 ff		 cmp	 DWORD PTR [ebx+384], -1
  000c1	0f 84 94 00 00
	00		 je	 $LN9@ProcState_

; 744  : 			{
; 745  : 				if ( GetTickCount() > this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN )

  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000cd	3b 83 80 01 00
	00		 cmp	 eax, DWORD PTR [ebx+384]
  000d3	0f 86 82 00 00
	00		 jbe	 $LN9@ProcState_

; 746  : 				{
; 747  : 					this->ReleaseCastleBridge(iBridgeIndex);

  000d9	57		 push	 edi
  000da	8b ce		 mov	 ecx, esi
  000dc	e8 00 00 00 00	 call	 ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleBridge

; 748  : 					this->SendCastleBridgeBlockInfo(iBridgeIndex, 0);

  000e1	6a 00		 push	 0
  000e3	57		 push	 edi
  000e4	8b ce		 mov	 ecx, esi
  000e6	e8 00 00 00 00	 call	 ?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleBridgeBlockInfo

; 749  : 					LogAddTD("[Blood Castle] (%d) Bridge Change Bridge Attribute -> Open", iBridgeIndex+1);

  000eb	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000ee	50		 push	 eax
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ILEHECHL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Bridge?5Chang@
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 750  : 					this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN = -1; // Prevent multiple openings
; 751  : 					this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1002;
; 752  : 
; 753  : 					if( this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX == -1 )

  000fa	8b 93 04 02 00
	00		 mov	 edx, DWORD PTR [ebx+516]
  00100	83 c4 08	 add	 esp, 8
  00103	c7 83 80 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [ebx+384], -1
  0010d	c7 83 0c 02 00
	00 ea 03 00 00	 mov	 DWORD PTR [ebx+524], 1002 ; 000003eaH
  00117	83 fa ff	 cmp	 edx, -1
  0011a	75 14		 jne	 SHORT $LN8@ProcState_

; 754  : 					{
; 755  : 						LogAddTD("[Blood Castle] (%d) Door Not Subsist",iBridgeIndex+1);

  0011c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0011f	50		 push	 eax
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@KANJAKKG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Not?5Sub@
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0012b	83 c4 08	 add	 esp, 8

; 756  : 					}
; 757  : 					else

  0012e	eb 2b		 jmp	 SHORT $LN9@ProcState_
$LN8@ProcState_:

; 758  : 					{
; 759  : 						LogAddTD("[Blood Castle] (%d) Door Subsist (%d)(Name: %s)(Dieregen:%d)",

  00130	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00136	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013c	0f be 81 8a 05
	00 00		 movsx	 eax, BYTE PTR [ecx+1418]
  00143	50		 push	 eax
  00144	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00147	50		 push	 eax
  00148	52		 push	 edx
  00149	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0014c	50		 push	 eax
  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HMEAEABF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Subsist@
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00158	83 c4 14	 add	 esp, 20			; 00000014H
$LN9@ProcState_:

; 760  : 							iBridgeIndex+1,m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX,gObj[m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX].Name,gObj[m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX].DieRegen);
; 761  : 					}
; 762  : 				}
; 763  : 			}
; 764  : 		}
; 765  : 
; 766  : 		// Set Play Quest
; 767  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= ((this->m_iBC_TIME_MIN_PLAY*60-60)*1000) && this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START == false )

  0015b	69 8e 6c 10 00
	00 60 ea 00 00	 imul	 ecx, DWORD PTR [esi+4204], 60000
  00165	8d 81 a0 15 ff
	ff		 lea	 eax, DWORD PTR [ecx-60000]
  0016b	39 83 54 01 00
	00		 cmp	 DWORD PTR [ebx+340], eax
  00171	0f 8f b4 00 00
	00		 jg	 $LN10@ProcState_
  00177	80 bb 65 01 00
	00 00		 cmp	 BYTE PTR [ebx+357], 0
  0017e	0f 85 a7 00 00
	00		 jne	 $LN10@ProcState_

; 768  : 		{
; 769  : 			PMSG_NOTICE pNotice;
; 770  : 
; 771  : 			this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (this->m_iBC_TIME_MIN_PLAY*60)*1000;
; 772  : 			this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = false;
; 773  : 			TNotice::MakeNoticeMsgEx((TNotice*)&pNotice, 0, lMsg.Get(MSGGET(4, 137)), iBridgeIndex+1);

  00184	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  00187	89 8b 54 01 00
	00		 mov	 DWORD PTR [ebx+340], ecx
  0018d	56		 push	 esi
  0018e	68 89 04 00 00	 push	 1161			; 00000489H
  00193	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00198	c6 83 64 01 00
	00 00		 mov	 BYTE PTR [ebx+356], 0
  0019f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001a4	50		 push	 eax
  001a5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$4[ebp]
  001ab	6a 00		 push	 0
  001ad	50		 push	 eax
  001ae	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 774  : 			this->SendBridgeAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  001b3	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$4[ebp+1]
  001ba	83 c4 10	 add	 esp, 16			; 00000010H
  001bd	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001c3	57		 push	 edi
  001c4	50		 push	 eax
  001c5	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$4[ebp]
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 775  : 			this->ReleaseCastleEntrance(iBridgeIndex);

  001d1	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001d7	57		 push	 edi
  001d8	e8 00 00 00 00	 call	 ?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleEntrance

; 776  : 			this->SendCastleEntranceBlockInfo(iBridgeIndex, 0);

  001dd	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001e3	6a 00		 push	 0
  001e5	57		 push	 edi
  001e6	e8 00 00 00 00	 call	 ?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleEntranceBlockInfo

; 777  : 			this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START = true;
; 778  : 			this->SetMonster(iBridgeIndex);

  001eb	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001f1	57		 push	 edi
  001f2	c6 83 65 01 00
	00 01		 mov	 BYTE PTR [ebx+357], 1
  001f9	e8 00 00 00 00	 call	 ?SetMonster@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetMonster

; 779  : 			this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1001;
; 780  : 			this->SendNoticeState(iBridgeIndex, false);

  001fe	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00204	6a 00		 push	 0
  00206	57		 push	 edi
  00207	c7 83 0c 02 00
	00 e9 03 00 00	 mov	 DWORD PTR [ebx+524], 1001 ; 000003e9H
  00211	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState

; 781  : 
; 782  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Start", iBridgeIndex+1);

  00216	56		 push	 esi
  00217	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CMBLFMKI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00222	8b b5 e8 fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00228	83 c4 08	 add	 esp, 8
$LN10@ProcState_:

; 783  : 		}
; 784  : 
; 785  : 		if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END == false)	// Set counter to kick

  0022b	8b 83 54 01 00
	00		 mov	 eax, DWORD PTR [ebx+340]
  00231	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00236	7f 42		 jg	 SHORT $LN11@ProcState_
  00238	85 c0		 test	 eax, eax
  0023a	7e 3e		 jle	 SHORT $LN11@ProcState_
  0023c	80 bb 69 01 00
	00 00		 cmp	 BYTE PTR [ebx+361], 0
  00243	75 35		 jne	 SHORT $LN11@ProcState_

; 786  : 		{
; 787  : 			this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END = true;
; 788  : 			PMSG_SET_DEVILSQUARE pMsg;
; 789  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00245	6a 04		 push	 4
  00247	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0024d	c6 83 69 01 00
	00 01		 mov	 BYTE PTR [ebx+361], 1
  00254	68 92 00 00 00	 push	 146			; 00000092H
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0025f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 790  : 			pMsg.Type = 5;

  00262	c6 85 e7 fe ff
	ff 05		 mov	 BYTE PTR _pMsg$1[ebp+3], 5

; 791  : 			this->SendBridgeAnyMsg((BYTE *)&pMsg, sizeof(pMsg), iBridgeIndex);

  00269	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0026f	8b ce		 mov	 ecx, esi
  00271	57		 push	 edi
  00272	6a 04		 push	 4
  00274	50		 push	 eax
  00275	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg
$LN11@ProcState_:

; 792  : 		}
; 793  : 
; 794  : 		if ( this->CheckEveryUserDie(iBridgeIndex) != false )

  0027a	57		 push	 edi
  0027b	8b ce		 mov	 ecx, esi
  0027d	e8 00 00 00 00	 call	 ?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckEveryUserDie
  00282	84 c0		 test	 al, al
  00284	0f 84 a3 00 00
	00		 je	 $LN12@ProcState_

; 795  : 		{
; 796  : 			PMSG_NOTICE pNotice;
; 797  : 
; 798  : 			TNotice::MakeNoticeMsg(&pNotice, 0, lMsg.Get(MSGGET(4, 138)));

  0028a	68 8a 04 00 00	 push	 1162			; 0000048aH
  0028f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00294	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00299	50		 push	 eax
  0029a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  002a0	6a 00		 push	 0
  002a2	50		 push	 eax
  002a3	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 799  : 			this->SendBridgeAnyMsg( (LPBYTE)&pNotice, pNotice.h.size, iBridgeIndex);

  002a8	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$3[ebp+1]
  002af	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b2	8b ce		 mov	 ecx, esi
  002b4	57		 push	 edi
  002b5	50		 push	 eax
  002b6	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$3[ebp]
  002bc	50		 push	 eax
  002bd	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 800  : 
; 801  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Castle Door [%s][%s]",

  002c2	8d 83 b3 01 00
	00		 lea	 eax, DWORD PTR [ebx+435]
  002c8	47		 inc	 edi
  002c9	50		 push	 eax
  002ca	8d b3 a8 01 00
	00		 lea	 esi, DWORD PTR [ebx+424]
  002d0	56		 push	 esi
  002d1	57		 push	 edi
  002d2	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  002d7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 802  : 				iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID,
; 803  : 				this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName);
; 804  : 
; 805  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Saint Status [%s][%s]",

  002dd	8d 83 c8 01 00
	00		 lea	 eax, DWORD PTR [ebx+456]
  002e3	50		 push	 eax
  002e4	56		 push	 esi
  002e5	57		 push	 edi
  002e6	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  002eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 806  : 				iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID,
; 807  : 				this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName);
; 808  : 			this->GiveReward_Fail(iBridgeIndex);

  002f1	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  002f7	83 c4 20	 add	 esp, 32			; 00000020H
  002fa	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00300	56		 push	 esi
  00301	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 809  : 			this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  00306	6a 01		 push	 1
  00308	56		 push	 esi
  00309	8b b5 e8 fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  0030f	8b ce		 mov	 ecx, esi
  00311	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 810  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Failed -> Every User Out", iBridgeIndex+1);

  00316	57		 push	 edi
  00317	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@OKAIGEKM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  0031c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 811  : 		}
; 812  : 		else

  00322	8b bd e0 fe ff
	ff		 mov	 edi, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  00328	83 c4 08	 add	 esp, 8
  0032b	eb 29		 jmp	 SHORT $LN16@ProcState_
$LN12@ProcState_:

; 813  : 		{
; 814  : 			if ( this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START != false )

  0032d	80 bb 65 01 00
	00 00		 cmp	 BYTE PTR [ebx+357], 0
  00334	74 20		 je	 SHORT $LN16@ProcState_

; 815  : 			{
; 816  : 				if ( this->m_BridgeData[iBridgeIndex].m_bBC_DOOR_TERMINATE_COMPLETE == false || this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE != false )

  00336	80 bb 62 01 00
	00 00		 cmp	 BYTE PTR [ebx+354], 0
  0033d	74 0d		 je	 SHORT $LN17@ProcState_
  0033f	80 bb 61 01 00
	00 00		 cmp	 BYTE PTR [ebx+353], 0
  00346	75 04		 jne	 SHORT $LN17@ProcState_

; 819  : 				}
; 820  : 				else
; 821  : 				{
; 822  : 					this->SendNoticeState(iBridgeIndex, 4);

  00348	6a 04		 push	 4
  0034a	eb 02		 jmp	 SHORT $LN25@ProcState_
$LN17@ProcState_:

; 817  : 				{
; 818  : 					this->SendNoticeState(iBridgeIndex, 1);

  0034c	6a 01		 push	 1
$LN25@ProcState_:
  0034e	57		 push	 edi
  0034f	8b ce		 mov	 ecx, esi
  00351	e8 00 00 00 00	 call	 ?SendNoticeState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SendNoticeState
$LN16@ProcState_:

; 823  : 				}
; 824  : 			}
; 825  : 		}
; 826  : 
; 827  : 		if ( this->CheckWinnerExist(iBridgeIndex) == true )

  00356	57		 push	 edi
  00357	8b ce		 mov	 ecx, esi
  00359	e8 00 00 00 00	 call	 ?CheckWinnerExist@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerExist
  0035e	3c 01		 cmp	 al, 1
  00360	0f 85 89 00 00
	00		 jne	 $LN20@ProcState_

; 828  : 		{
; 829  : 			if ( this->CheckWinnerValid(iBridgeIndex) == true )

  00366	57		 push	 edi
  00367	8b ce		 mov	 ecx, esi
  00369	e8 00 00 00 00	 call	 ?CheckWinnerValid@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerValid

; 830  : 			{
; 831  : 				if ( this->CheckWinnerPartyComplete(iBridgeIndex) == true )

  0036e	8b ce		 mov	 ecx, esi
  00370	57		 push	 edi
  00371	3c 01		 cmp	 al, 1
  00373	75 46		 jne	 SHORT $LN19@ProcState_
  00375	e8 00 00 00 00	 call	 ?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckWinnerPartyComplete
  0037a	3c 01		 cmp	 al, 1
  0037c	75 71		 jne	 SHORT $LN20@ProcState_

; 832  : 				{
; 833  : 					this->GiveReward_Win(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX, iBridgeIndex);

  0037e	57		 push	 edi
  0037f	ff b3 00 02 00
	00		 push	 DWORD PTR [ebx+512]
  00385	8b ce		 mov	 ecx, esi
  00387	e8 00 00 00 00	 call	 ?GiveReward_Win@CBloodCastle@@QAEXHH@Z ; CBloodCastle::GiveReward_Win

; 834  : 					this->SetState(iBridgeIndex, BC_STATE_PLAYEND);

  0038c	6a 03		 push	 3
  0038e	57		 push	 edi
  0038f	8b ce		 mov	 ecx, esi
  00391	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 835  : 
; 836  : 					LogAddTD("[Blood Castle] (%d) CheckWinnerPartyComplete(iBridgeIndex) == true",

  00396	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00399	50		 push	 eax
  0039a	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@LAGFFAOI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerP@
  0039f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003a5	83 c4 08	 add	 esp, 8
  003a8	5f		 pop	 edi
  003a9	5e		 pop	 esi
  003aa	5b		 pop	 ebx

; 873  : 	}
; 874  : }

  003ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ae	33 cd		 xor	 ecx, ebp
  003b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b5	8b e5		 mov	 esp, ebp
  003b7	5d		 pop	 ebp
  003b8	c2 04 00	 ret	 4
$LN19@ProcState_:

; 837  : 						iBridgeIndex+1);
; 838  : 
; 839  : 					return;
; 840  : 				}
; 841  : 			}
; 842  : 			else
; 843  : 			{
; 844  : 				this->GiveReward_Fail(iBridgeIndex);

  003bb	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 845  : 				this->SetState(iBridgeIndex, BC_STATE_PLAYEND); 

  003c0	6a 03		 push	 3
  003c2	57		 push	 edi
  003c3	8b ce		 mov	 ecx, esi
  003c5	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState

; 846  : 
; 847  : 				LogAddTD("[Blood Castle] (%d) CheckWinnerValid(iBridgeIndex) == false",

  003ca	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  003cd	50		 push	 eax
  003ce	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@EMKPJGDI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CheckWinnerV@
  003d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003d9	83 c4 08	 add	 esp, 8
  003dc	5f		 pop	 edi
  003dd	5e		 pop	 esi
  003de	5b		 pop	 ebx

; 873  : 	}
; 874  : }

  003df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e2	33 cd		 xor	 ecx, ebp
  003e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e9	8b e5		 mov	 esp, ebp
  003eb	5d		 pop	 ebp
  003ec	c2 04 00	 ret	 4
$LN20@ProcState_:

; 848  : 					iBridgeIndex+1);
; 849  : 
; 850  : 				return;
; 851  : 			}
; 852  : 		}
; 853  : 	}
; 854  : 
; 855  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  003ef	83 bb 54 01 00
	00 00		 cmp	 DWORD PTR [ebx+340], 0
  003f6	7f 6e		 jg	 SHORT $LN22@ProcState_

; 856  : 	{
; 857  : 		if ( this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED == false )

  003f8	80 bb 66 01 00
	00 00		 cmp	 BYTE PTR [ebx+358], 0
  003ff	75 5b		 jne	 SHORT $LN23@ProcState_

; 858  : 		{
; 859  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Castle Door [%s][%s]",

  00401	8d 83 b3 01 00
	00		 lea	 eax, DWORD PTR [ebx+435]
  00407	50		 push	 eax
  00408	8d 83 a8 01 00
	00		 lea	 eax, DWORD PTR [ebx+424]
  0040e	50		 push	 eax
  0040f	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  00412	56		 push	 esi
  00413	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DNPEIOMM@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  00418	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 860  : 				iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID,
; 861  : 				this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName);
; 862  : 
; 863  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Fail Result -> Destroy Saint Status [%s][%s]",

  0041e	8d 83 c8 01 00
	00		 lea	 eax, DWORD PTR [ebx+456]
  00424	50		 push	 eax
  00425	8d 83 d3 01 00
	00		 lea	 eax, DWORD PTR [ebx+467]
  0042b	50		 push	 eax
  0042c	56		 push	 esi
  0042d	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@DMAGKDKC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  00432	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 864  : 				iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID,
; 865  : 				this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName);
; 866  : 			this->GiveReward_Fail(iBridgeIndex);

  00438	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0043e	83 c4 20	 add	 esp, 32			; 00000020H
  00441	57		 push	 edi
  00442	e8 00 00 00 00	 call	 ?GiveReward_Fail@CBloodCastle@@QAEXH@Z ; CBloodCastle::GiveReward_Fail

; 867  : 
; 868  : 			LogAddTD("[Blood Castle] (%d) Blood Castle Quest Failed -> Time Out", iBridgeIndex+1);

  00447	56		 push	 esi
  00448	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@EOCANJIL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Blood?5Castle@
  0044d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00453	8b b5 e8 fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00459	83 c4 08	 add	 esp, 8
$LN23@ProcState_:

; 869  : 			
; 870  : 		}
; 871  : 
; 872  : 		this->SetState(iBridgeIndex, BC_STATE_PLAYEND);

  0045c	6a 03		 push	 3
  0045e	57		 push	 edi
  0045f	8b ce		 mov	 ecx, esi
  00461	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN22@ProcState_:

; 873  : 	}
; 874  : }

  00466	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00469	5f		 pop	 edi
  0046a	5e		 pop	 esi
  0046b	33 cd		 xor	 ecx, ebp
  0046d	5b		 pop	 ebx
  0046e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00473	8b e5		 mov	 esp, ebp
  00475	5d		 pop	 ebp
  00476	c2 04 00	 ret	 4
?ProcState_Playing@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_Playing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ProcState_Closed@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -288					; size = 4
_pMsg$1 = -284						; size = 4
_iBridgeIndex$GSCopy$1$ = -280				; size = 4
_pNotice$2 = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?ProcState_Closed@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_Closed, COMDAT
; _this$ = ecx

; 643  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  00016	53		 push	 ebx

; 644  : 	int iTICK_MSEC = GetTickCount() - this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT;

  00017	69 d8 0c 02 00
	00		 imul	 ebx, eax, 524
  0001d	56		 push	 esi
  0001e	8b f1		 mov	 esi, ecx
  00020	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iBridgeIndex$GSCopy$1$[ebp], eax
  00026	57		 push	 edi
  00027	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  0002d	89 b5 e0 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00033	03 de		 add	 ebx, esi
  00035	ff d7		 call	 edi
  00037	2b 83 58 01 00
	00		 sub	 eax, DWORD PTR [ebx+344]

; 645  : 
; 646  : 	if ( iTICK_MSEC >= 1000 )

  0003d	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00042	0f 8c 8d 01 00
	00		 jl	 $LN39@ProcState_

; 647  : 	{
; 648  : 		this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= iTICK_MSEC;

  00048	29 83 54 01 00
	00		 sub	 DWORD PTR [ebx+340], eax

; 649  : 		this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  0004e	ff d7		 call	 edi
  00050	89 83 58 01 00
	00		 mov	 DWORD PTR [ebx+344], eax

; 650  : 
; 651  : 		if ( g_bBloodCastle != FALSE )

  00056	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  0005d	0f 84 72 01 00
	00		 je	 $LN39@ProcState_

; 652  : 		{
; 653  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER == false)

  00063	69 86 68 10 00
	00 60 ea 00 00	 imul	 eax, DWORD PTR [esi+4200], 60000
  0006d	8b 8b 54 01 00
	00		 mov	 ecx, DWORD PTR [ebx+340]
  00073	3b c8		 cmp	 ecx, eax
  00075	7d 12		 jge	 SHORT $LN7@ProcState_
  00077	80 bb 63 01 00
	00 00		 cmp	 BYTE PTR [ebx+355], 0
  0007e	75 09		 jne	 SHORT $LN7@ProcState_

; 654  : 			{
; 655  : 				this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = true;

  00080	66 c7 83 63 01
	00 00 01 01	 mov	 WORD PTR [ebx+355], 257	; 00000101H
$LN7@ProcState_:

; 656  : 				this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = true;
; 657  : 			}
; 658  : 
; 659  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < ( this->m_iBC_TIME_MIN_OPEN * 60 * 1000 ) && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && (this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC/60000) !=this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT)

  00089	69 86 68 10 00
	00 60 ea 00 00	 imul	 eax, DWORD PTR [esi+4200], 60000
  00093	3b c8		 cmp	 ecx, eax
  00095	7d 6b		 jge	 SHORT $LN33@ProcState_
  00097	85 c9		 test	 ecx, ecx
  00099	7e 67		 jle	 SHORT $LN33@ProcState_
  0009b	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  000a0	f7 e9		 imul	 ecx
  000a2	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  000a5	8b c2		 mov	 eax, edx
  000a7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000aa	03 c2		 add	 eax, edx
  000ac	3b 83 5c 01 00
	00		 cmp	 eax, DWORD PTR [ebx+348]
  000b2	74 4e		 je	 SHORT $LN33@ProcState_

; 660  : 			{
; 661  : 				this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 60000;
; 662  : 
; 663  : 				if ( iBridgeIndex == 0 )

  000b4	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _iBridgeIndex$GSCopy$1$[ebp], 0
  000bb	89 83 5c 01 00
	00		 mov	 DWORD PTR [ebx+348], eax
  000c1	75 3f		 jne	 SHORT $LN33@ProcState_

; 664  : 				{
; 665  : 					PMSG_NOTICE pNotice;
; 666  : 
; 667  : 					TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get( MSGGET(4, 136)), this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT+1);

  000c3	8b 86 5c 01 00
	00		 mov	 eax, DWORD PTR [esi+348]
  000c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000ce	40		 inc	 eax
  000cf	50		 push	 eax
  000d0	68 88 04 00 00	 push	 1160			; 00000488H
  000d5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000da	50		 push	 eax
  000db	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$2[ebp]
  000e1	6a 00		 push	 0
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 668  : 					this->SendAllUserAnyMsg((BYTE *)&pNotice, pNotice.h.size);

  000e9	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$2[ebp+1]
  000f0	83 c4 10	 add	 esp, 16			; 00000010H
  000f3	8b ce		 mov	 ecx, esi
  000f5	50		 push	 eax
  000f6	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$2[ebp]
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 ?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z ; CBloodCastle::SendAllUserAnyMsg
$LN33@ProcState_:

; 669  : 				}
; 670  : 			}
; 671  : 
; 672  : 			if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 30000 && this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC > 0 && this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER == false )

  00102	8b 83 54 01 00
	00		 mov	 eax, DWORD PTR [ebx+340]
  00108	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  0010d	0f 8f c2 00 00
	00		 jg	 $LN39@ProcState_
  00113	85 c0		 test	 eax, eax
  00115	0f 8e ba 00 00
	00		 jle	 $LN39@ProcState_
  0011b	80 bb 67 01 00
	00 00		 cmp	 BYTE PTR [ebx+359], 0

; 673  : 			{
; 674  : 				this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER = true;
; 675  : 
; 676  : 				if ( iBridgeIndex == 0 )

  00122	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  00128	0f 85 ad 00 00
	00		 jne	 $LN34@ProcState_
  0012e	c6 83 67 01 00
	00 01		 mov	 BYTE PTR [ebx+359], 1
  00135	85 c0		 test	 eax, eax
  00137	0f 85 9e 00 00
	00		 jne	 $LN34@ProcState_

; 677  : 				{
; 678  : 					PMSG_SET_DEVILSQUARE pMsg;
; 679  : 
; 680  : 					PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  0013d	6a 04		 push	 4
  0013f	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00145	68 92 00 00 00	 push	 146			; 00000092H
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH

; 681  : 					pMsg.Type = 3;

  00153	c6 85 e7 fe ff
	ff 03		 mov	 BYTE PTR _pMsg$1[ebp+3], 3

; 682  : 
; 683  : 					for (int i= OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  0015a	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  0015f	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL4@ProcState_:

; 684  : 					{
; 685  : 						if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_USER)

  00164	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00169	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0016e	75 50		 jne	 SHORT $LN2@ProcState_
  00170	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00175	75 49		 jne	 SHORT $LN2@ProcState_

; 686  : 						{
; 687  : 							if ( BC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  00177	8a 8c 06 23 01
	00 00		 mov	 cl, BYTE PTR [esi+eax+291]
  0017e	80 f9 34	 cmp	 cl, 52			; 00000034H
  00181	74 3d		 je	 SHORT $LN2@ProcState_
  00183	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00186	72 0b		 jb	 SHORT $LN31@ProcState_
  00188	b0 11		 mov	 al, 17			; 00000011H
  0018a	3a c1		 cmp	 al, cl
  0018c	1b c0		 sbb	 eax, eax
  0018e	83 c0 01	 add	 eax, 1
  00191	75 2d		 jne	 SHORT $LN2@ProcState_
$LN31@ProcState_:

; 688  : 							{
; 689  : 								if ( CC_MAP_RANGE(gObj[i].MapNumber) == FALSE )

  00193	80 f9 35	 cmp	 cl, 53			; 00000035H
  00196	74 28		 je	 SHORT $LN2@ProcState_
  00198	80 f9 12	 cmp	 cl, 18			; 00000012H
  0019b	72 0b		 jb	 SHORT $LN32@ProcState_
  0019d	b0 17		 mov	 al, 23			; 00000017H
  0019f	3a c1		 cmp	 al, cl
  001a1	1b c0		 sbb	 eax, eax
  001a3	83 c0 01	 add	 eax, 1
  001a6	75 18		 jne	 SHORT $LN2@ProcState_
$LN32@ProcState_:

; 690  : 								{
; 691  : 									DataSend(i, (UCHAR*)&pMsg, pMsg.h.size);

  001a8	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  001af	50		 push	 eax
  001b0	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  001b6	50		 push	 eax
  001b7	57		 push	 edi
  001b8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@ProcState_:

; 682  : 
; 683  : 					for (int i= OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  001c0	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  001c6	47		 inc	 edi
  001c7	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  001cd	7c 95		 jl	 SHORT $LL4@ProcState_
  001cf	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
$LN39@ProcState_:
  001d5	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
$LN34@ProcState_:

; 692  : 								}
; 693  : 							}
; 694  : 						}
; 695  : 					}
; 696  : 				}
; 697  : 			}
; 698  : 		}
; 699  : 	}
; 700  : 
; 701  : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= 0 )

  001db	83 bb 54 01 00
	00 00		 cmp	 DWORD PTR [ebx+340], 0
  001e2	7f 17		 jg	 SHORT $LN17@ProcState_

; 702  : 	{
; 703  : 		if ( g_bBloodCastle != FALSE )

  001e4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle

; 704  : 		{
; 705  : 			this->SetState(iBridgeIndex, BC_STATE_PLAYING);

  001eb	8b ce		 mov	 ecx, esi
  001ed	74 04		 je	 SHORT $LN16@ProcState_
  001ef	6a 02		 push	 2

; 706  : 		}
; 707  : 		else

  001f1	eb 02		 jmp	 SHORT $LN40@ProcState_
$LN16@ProcState_:

; 708  : 		{
; 709  : 			this->SetState(iBridgeIndex, BC_STATE_CLOSED);

  001f3	6a 01		 push	 1
$LN40@ProcState_:
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
$LN17@ProcState_:

; 710  : 		}
; 711  : 	}
; 712  : }

  001fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
  00200	33 cd		 xor	 ecx, ebp
  00202	5b		 pop	 ebx
  00203	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c2 04 00	 ret	 4
?ProcState_Closed@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_Closed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ProcState_None@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?ProcState_None@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ProcState_None, COMDAT
; _this$ = ecx

; 636  : 	return;
; 637  : }

  00000	c2 04 00	 ret	 4
?ProcState_None@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ProcState_None
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ClearBridgeData@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?ClearBridgeData@CBloodCastle@@IAEXH@Z PROC		; CBloodCastle::ClearBridgeData, COMDAT
; _this$ = ecx

; 488  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 489  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 88 d0 08 00
	00		 js	 $LN13@ClearBridg
  00010	33 c0		 xor	 eax, eax
  00012	83 f9 07	 cmp	 ecx, 7
  00015	0f 9e c0	 setle	 al
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 c0 08 00
	00		 je	 $LN13@ClearBridg

; 490  : 	{
; 491  : 		return;
; 492  : 	}
; 493  : 
; 494  : 	this->m_BridgeData[iBridgeIndex].m_iTOTAL_EXP = 0;

  00020	56		 push	 esi
  00021	69 f1 0c 02 00
	00		 imul	 esi, ecx, 524
  00027	0f 57 c0	 xorps	 xmm0, xmm0
  0002a	c7 84 16 3c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+316], 0

; 495  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = 0;

  00035	c7 84 16 74 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+372], 0

; 496  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT = 0;

  00040	c7 84 16 78 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+376], 0

; 497  : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_SUCCESS_MSG_COUNT = 0;

  0004b	c7 84 16 7c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+380], 0

; 498  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT = 0;

  00056	c7 84 16 84 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+388], 0

; 499  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT = 0;

  00061	c7 84 16 88 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+392], 0

; 500  : 	this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT = 0;

  0006c	c7 84 16 8c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+396], 0

; 501  : 	this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER = 0;

  00077	c6 84 16 98 01
	00 00 00	 mov	 BYTE PTR [esi+edx+408], 0

; 502  : 	this->m_BridgeData[iBridgeIndex].m_dwBC_TICK_DOOR_OPEN = -1;

  0007f	c7 84 16 80 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+384], -1

; 503  : 	this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL = -1;

  0008a	c7 84 16 90 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+400], -1

; 504  : 	this->m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX = -1;

  00095	c7 84 16 94 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+404], -1

; 505  : 	this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS = -1;

  000a0	c7 84 16 48 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+328], -1

; 506  : 	this->m_BridgeData[iBridgeIndex].m_iBC_NOTIFY_COUNT = -1;

  000ab	c7 84 16 5c 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+348], -1

; 507  : 	this->m_BridgeData[iBridgeIndex].m_bCASTLE_DOOR_LIVE = TRUE;

  000b6	c7 84 16 4c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+edx+332], 1

; 508  : 	this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED = false;

  000c1	c7 84 16 66 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+358], 0

; 509  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_ENTER = false;
; 510  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_PLAY = false;
; 511  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_END = false;
; 512  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MSG_BEFORE_QUIT = false;

  000cc	c6 84 16 6a 01
	00 00 00	 mov	 BYTE PTR [esi+edx+362], 0

; 513  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER = false;

  000d4	66 c7 84 16 63
	01 00 00 00 00	 mov	 WORD PTR [esi+edx+355], 0

; 514  : 	this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY = false;
; 515  : 	this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START = false;

  000de	c6 84 16 65 01
	00 00 00	 mov	 BYTE PTR [esi+edx+357], 0

; 516  : 	this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE = false;

  000e6	66 c7 84 16 60
	01 00 00 00 00	 mov	 WORD PTR [esi+edx+352], 0

; 517  : 	this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE = false;
; 518  : 	this->m_BridgeData[iBridgeIndex].m_bBC_DOOR_TERMINATE_COMPLETE = false;

  000f0	c6 84 16 62 01
	00 00 00	 mov	 BYTE PTR [esi+edx+354], 0

; 519  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index = -10;

  000f8	c7 84 16 a4 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [esi+edx+420], -10 ; fffffff6H

; 520  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party = -10;

  00103	c7 84 16 a0 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [esi+edx+416], -10 ; fffffff6H

; 521  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index = -10;

  0010e	c7 84 16 c4 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [esi+edx+452], -10 ; fffffff6H

; 522  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party = -10;

  00119	c7 84 16 c0 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [esi+edx+448], -10 ; fffffff6H

; 523  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Index = -10;

  00124	c7 84 16 e4 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [esi+edx+484], -10 ; fffffff6H

; 524  : 	this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Party = -10;

  0012f	c7 84 16 e0 01
	00 00 f6 ff ff
	ff		 mov	 DWORD PTR [esi+edx+480], -10 ; fffffff6H

; 525  : 
; 526  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName , 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Door_CharName));

  0013a	66 0f d6 84 16
	b3 01 00 00	 movq	 QWORD PTR [esi+edx+435], xmm0
  00143	66 c7 84 16 bb
	01 00 00 00 00	 mov	 WORD PTR [esi+edx+443], 0
  0014d	c6 84 16 bd 01
	00 00 00	 mov	 BYTE PTR [esi+edx+445], 0

; 527  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Status_CharName));

  00155	66 0f d6 84 16
	c8 01 00 00	 movq	 QWORD PTR [esi+edx+456], xmm0
  0015e	66 c7 84 16 d0
	01 00 00 00 00	 mov	 WORD PTR [esi+edx+464], 0
  00168	c6 84 16 d2 01
	00 00 00	 mov	 BYTE PTR [esi+edx+466], 0

; 528  : 	memset(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_CharName, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_CharName));

  00170	66 0f d6 84 16
	e8 01 00 00	 movq	 QWORD PTR [esi+edx+488], xmm0
  00179	66 c7 84 16 f0
	01 00 00 00 00	 mov	 WORD PTR [esi+edx+496], 0
  00183	c6 84 16 f2 01
	00 00 00	 mov	 BYTE PTR [esi+edx+498], 0

; 529  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Door_AccountID));

  0018b	66 0f d6 84 16
	a8 01 00 00	 movq	 QWORD PTR [esi+edx+424], xmm0
  00194	66 c7 84 16 b0
	01 00 00 00 00	 mov	 WORD PTR [esi+edx+432], 0
  0019e	c6 84 16 b2 01
	00 00 00	 mov	 BYTE PTR [esi+edx+434], 0

; 530  : 	memset(this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szKill_Status_AccountID));

  001a6	66 0f d6 84 16
	d3 01 00 00	 movq	 QWORD PTR [esi+edx+467], xmm0
  001af	66 c7 84 16 db
	01 00 00 00 00	 mov	 WORD PTR [esi+edx+475], 0
  001b9	c6 84 16 dd 01
	00 00 00	 mov	 BYTE PTR [esi+edx+477], 0

; 531  : 	memset(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_AccountID, 0, sizeof(this->m_BridgeData[iBridgeIndex].m_szWin_Quest_AccountID));

  001c1	66 0f d6 84 16
	f3 01 00 00	 movq	 QWORD PTR [esi+edx+499], xmm0
  001ca	66 c7 84 16 fb
	01 00 00 00 00	 mov	 WORD PTR [esi+edx+507], 0
  001d4	c6 84 16 fd 01
	00 00 00	 mov	 BYTE PTR [esi+edx+509], 0

; 532  : 	
; 533  : 
; 534  : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)
; 535  : 	{
; 536  : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  001dc	8b 44 16 1c	 mov	 eax, DWORD PTR [esi+edx+28]
  001e0	83 f8 ff	 cmp	 eax, -1
  001e3	74 55		 je	 SHORT $LN6@ClearBridg

; 537  : 		{
; 538  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  001e5	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  001eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f0	c7 84 01 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4664], 0

; 539  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  001fb	69 4c 16 1c 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+28], 10048
  00203	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00208	c6 84 01 36 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4662], -1

; 540  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  00210	69 4c 16 1c 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+28], 10048
  00218	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021d	c6 84 01 37 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4663], -1

; 541  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  00225	69 4c 16 1c 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+28], 10048
  0022d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00232	c6 84 01 3c 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4668], 0
$LN6@ClearBridg:

; 542  : 		}
; 543  : 
; 544  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  0023a	c7 44 16 20 00
	00 00 00	 mov	 DWORD PTR [esi+edx+32], 0

; 545  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  00242	c7 44 16 24 00
	00 00 00	 mov	 DWORD PTR [esi+edx+36], 0

; 546  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0024a	c7 44 16 1c ff
	ff ff ff	 mov	 DWORD PTR [esi+edx+28], -1

; 547  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00252	c7 44 16 28 00
	00 00 00	 mov	 DWORD PTR [esi+edx+40], 0

; 548  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  0025a	66 c7 44 16 2c
	00 00		 mov	 WORD PTR [esi+edx+44], 0

; 549  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 550  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  00261	c7 84 16 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+512], -1

; 551  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX = -1;

  0026c	c7 84 16 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+516], -1

; 552  : 		this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1000;

  00277	c7 84 16 0c 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+524], 1000 ; 000003e8H
  00282	8b 44 16 30	 mov	 eax, DWORD PTR [esi+edx+48]
  00286	83 f8 ff	 cmp	 eax, -1
  00289	74 55		 je	 SHORT $LN17@ClearBridg

; 537  : 		{
; 538  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  0028b	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00291	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00296	c7 84 01 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4664], 0

; 539  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  002a1	69 4c 16 30 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+48], 10048
  002a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ae	c6 84 01 36 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4662], -1

; 540  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  002b6	69 4c 16 30 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+48], 10048
  002be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c3	c6 84 01 37 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4663], -1

; 541  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  002cb	69 4c 16 30 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+48], 10048
  002d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d8	c6 84 01 3c 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4668], 0
$LN17@ClearBridg:

; 542  : 		}
; 543  : 
; 544  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  002e0	c7 44 16 34 00
	00 00 00	 mov	 DWORD PTR [esi+edx+52], 0

; 545  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  002e8	c7 44 16 38 00
	00 00 00	 mov	 DWORD PTR [esi+edx+56], 0

; 546  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  002f0	c7 44 16 30 ff
	ff ff ff	 mov	 DWORD PTR [esi+edx+48], -1

; 547  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  002f8	c7 44 16 3c 00
	00 00 00	 mov	 DWORD PTR [esi+edx+60], 0

; 548  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  00300	66 c7 44 16 40
	00 00		 mov	 WORD PTR [esi+edx+64], 0

; 549  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 550  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  00307	c7 84 16 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+512], -1

; 551  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX = -1;

  00312	c7 84 16 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+516], -1

; 552  : 		this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1000;

  0031d	c7 84 16 0c 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+524], 1000 ; 000003e8H
  00328	8b 44 16 44	 mov	 eax, DWORD PTR [esi+edx+68]
  0032c	83 f8 ff	 cmp	 eax, -1
  0032f	74 55		 je	 SHORT $LN19@ClearBridg

; 537  : 		{
; 538  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  00331	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00337	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0033c	c7 84 01 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4664], 0

; 539  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  00347	69 4c 16 44 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+68], 10048
  0034f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00354	c6 84 01 36 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4662], -1

; 540  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  0035c	69 4c 16 44 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+68], 10048
  00364	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00369	c6 84 01 37 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4663], -1

; 541  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  00371	69 4c 16 44 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+68], 10048
  00379	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0037e	c6 84 01 3c 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4668], 0
$LN19@ClearBridg:

; 542  : 		}
; 543  : 
; 544  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  00386	c7 44 16 48 00
	00 00 00	 mov	 DWORD PTR [esi+edx+72], 0

; 545  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  0038e	c7 44 16 4c 00
	00 00 00	 mov	 DWORD PTR [esi+edx+76], 0

; 546  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  00396	c7 44 16 44 ff
	ff ff ff	 mov	 DWORD PTR [esi+edx+68], -1

; 547  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  0039e	c7 44 16 50 00
	00 00 00	 mov	 DWORD PTR [esi+edx+80], 0

; 548  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  003a6	66 c7 44 16 54
	00 00		 mov	 WORD PTR [esi+edx+84], 0

; 549  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 550  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  003ad	c7 84 16 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+512], -1

; 551  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX = -1;

  003b8	c7 84 16 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+516], -1

; 552  : 		this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1000;

  003c3	c7 84 16 0c 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+524], 1000 ; 000003e8H
  003ce	8b 44 16 58	 mov	 eax, DWORD PTR [esi+edx+88]
  003d2	83 f8 ff	 cmp	 eax, -1
  003d5	74 55		 je	 SHORT $LN21@ClearBridg

; 537  : 		{
; 538  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  003d7	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  003dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003e2	c7 84 01 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4664], 0

; 539  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  003ed	69 4c 16 58 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+88], 10048
  003f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003fa	c6 84 01 36 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4662], -1

; 540  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  00402	69 4c 16 58 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+88], 10048
  0040a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0040f	c6 84 01 37 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4663], -1

; 541  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  00417	69 4c 16 58 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+88], 10048
  0041f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00424	c6 84 01 3c 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4668], 0
$LN21@ClearBridg:

; 542  : 		}
; 543  : 
; 544  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  0042c	c7 44 16 5c 00
	00 00 00	 mov	 DWORD PTR [esi+edx+92], 0

; 545  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  00434	c7 44 16 60 00
	00 00 00	 mov	 DWORD PTR [esi+edx+96], 0

; 546  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0043c	c7 44 16 58 ff
	ff ff ff	 mov	 DWORD PTR [esi+edx+88], -1

; 547  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00444	c7 44 16 64 00
	00 00 00	 mov	 DWORD PTR [esi+edx+100], 0

; 548  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  0044c	66 c7 44 16 68
	00 00		 mov	 WORD PTR [esi+edx+104], 0

; 549  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 550  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  00453	c7 84 16 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+512], -1

; 551  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX = -1;

  0045e	c7 84 16 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+516], -1

; 552  : 		this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1000;

  00469	c7 84 16 0c 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+524], 1000 ; 000003e8H
  00474	8b 44 16 6c	 mov	 eax, DWORD PTR [esi+edx+108]
  00478	83 f8 ff	 cmp	 eax, -1
  0047b	74 55		 je	 SHORT $LN23@ClearBridg

; 537  : 		{
; 538  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  0047d	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00483	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00488	c7 84 01 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4664], 0

; 539  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  00493	69 4c 16 6c 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+108], 10048
  0049b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004a0	c6 84 01 36 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4662], -1

; 540  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  004a8	69 4c 16 6c 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+108], 10048
  004b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b5	c6 84 01 37 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4663], -1

; 541  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  004bd	69 4c 16 6c 40
	27 00 00	 imul	 ecx, DWORD PTR [esi+edx+108], 10048
  004c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004ca	c6 84 01 3c 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4668], 0
$LN23@ClearBridg:

; 542  : 		}
; 543  : 
; 544  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  004d2	c7 44 16 70 00
	00 00 00	 mov	 DWORD PTR [esi+edx+112], 0

; 545  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  004da	c7 44 16 74 00
	00 00 00	 mov	 DWORD PTR [esi+edx+116], 0

; 546  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  004e2	c7 44 16 6c ff
	ff ff ff	 mov	 DWORD PTR [esi+edx+108], -1

; 547  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  004ea	c7 44 16 78 00
	00 00 00	 mov	 DWORD PTR [esi+edx+120], 0

; 548  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  004f2	66 c7 44 16 7c
	00 00		 mov	 WORD PTR [esi+edx+124], 0

; 549  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 550  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  004f9	c7 84 16 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+512], -1

; 551  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX = -1;

  00504	c7 84 16 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+516], -1

; 552  : 		this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1000;

  0050f	c7 84 16 0c 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+524], 1000 ; 000003e8H
  0051a	8b 84 16 80 00
	00 00		 mov	 eax, DWORD PTR [esi+edx+128]
  00521	83 f8 ff	 cmp	 eax, -1
  00524	74 5e		 je	 SHORT $LN25@ClearBridg

; 537  : 		{
; 538  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  00526	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  0052c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00531	c7 84 01 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4664], 0

; 539  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  0053c	69 8c 16 80 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+128], 10048
  00547	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0054c	c6 84 01 36 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4662], -1

; 540  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  00554	69 8c 16 80 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+128], 10048
  0055f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00564	c6 84 01 37 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4663], -1

; 541  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  0056c	69 8c 16 80 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+128], 10048
  00577	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0057c	c6 84 01 3c 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4668], 0
$LN25@ClearBridg:

; 542  : 		}
; 543  : 
; 544  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  00584	c7 84 16 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+132], 0

; 545  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  0058f	c7 84 16 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+136], 0

; 546  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0059a	c7 84 16 80 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+128], -1

; 547  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  005a5	c7 84 16 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+140], 0

; 548  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  005b0	66 c7 84 16 90
	00 00 00 00 00	 mov	 WORD PTR [esi+edx+144], 0

; 549  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 550  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  005ba	c7 84 16 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+512], -1

; 551  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX = -1;

  005c5	c7 84 16 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+516], -1

; 552  : 		this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1000;

  005d0	c7 84 16 0c 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+524], 1000 ; 000003e8H
  005db	8b 84 16 94 00
	00 00		 mov	 eax, DWORD PTR [esi+edx+148]
  005e2	83 f8 ff	 cmp	 eax, -1
  005e5	74 5e		 je	 SHORT $LN27@ClearBridg

; 537  : 		{
; 538  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  005e7	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  005ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005f2	c7 84 01 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4664], 0

; 539  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  005fd	69 8c 16 94 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+148], 10048
  00608	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0060d	c6 84 01 36 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4662], -1

; 540  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  00615	69 8c 16 94 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+148], 10048
  00620	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00625	c6 84 01 37 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4663], -1

; 541  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  0062d	69 8c 16 94 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+148], 10048
  00638	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0063d	c6 84 01 3c 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4668], 0
$LN27@ClearBridg:

; 542  : 		}
; 543  : 
; 544  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  00645	c7 84 16 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+152], 0

; 545  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  00650	c7 84 16 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+156], 0

; 546  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0065b	c7 84 16 94 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+148], -1

; 547  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00666	c7 84 16 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+160], 0

; 548  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  00671	66 c7 84 16 a4
	00 00 00 00 00	 mov	 WORD PTR [esi+edx+164], 0

; 549  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 550  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  0067b	c7 84 16 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+512], -1

; 551  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX = -1;

  00686	c7 84 16 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+516], -1

; 552  : 		this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1000;

  00691	c7 84 16 0c 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+524], 1000 ; 000003e8H
  0069c	8b 84 16 a8 00
	00 00		 mov	 eax, DWORD PTR [esi+edx+168]
  006a3	83 f8 ff	 cmp	 eax, -1
  006a6	74 5e		 je	 SHORT $LN29@ClearBridg

; 537  : 		{
; 538  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  006a8	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  006ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006b3	c7 84 01 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4664], 0

; 539  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  006be	69 8c 16 a8 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+168], 10048
  006c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006ce	c6 84 01 36 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4662], -1

; 540  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  006d6	69 8c 16 a8 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+168], 10048
  006e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006e6	c6 84 01 37 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4663], -1

; 541  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  006ee	69 8c 16 a8 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+168], 10048
  006f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006fe	c6 84 01 3c 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4668], 0
$LN29@ClearBridg:

; 542  : 		}
; 543  : 
; 544  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  00706	c7 84 16 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+172], 0

; 545  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  00711	c7 84 16 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+176], 0

; 546  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0071c	c7 84 16 a8 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+168], -1

; 547  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  00727	c7 84 16 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+180], 0

; 548  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  00732	66 c7 84 16 b8
	00 00 00 00 00	 mov	 WORD PTR [esi+edx+184], 0

; 549  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 550  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  0073c	c7 84 16 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+512], -1

; 551  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX = -1;

  00747	c7 84 16 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+516], -1

; 552  : 		this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1000;

  00752	c7 84 16 0c 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+524], 1000 ; 000003e8H
  0075d	8b 84 16 bc 00
	00 00		 mov	 eax, DWORD PTR [esi+edx+188]
  00764	83 f8 ff	 cmp	 eax, -1
  00767	74 5e		 je	 SHORT $LN31@ClearBridg

; 537  : 		{
; 538  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  00769	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  0076f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00774	c7 84 01 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4664], 0

; 539  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  0077f	69 8c 16 bc 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+188], 10048
  0078a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0078f	c6 84 01 36 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4662], -1

; 540  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  00797	69 8c 16 bc 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+188], 10048
  007a2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007a7	c6 84 01 37 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4663], -1

; 541  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  007af	69 8c 16 bc 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+188], 10048
  007ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007bf	c6 84 01 3c 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4668], 0
$LN31@ClearBridg:

; 542  : 		}
; 543  : 
; 544  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  007c7	c7 84 16 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+192], 0

; 545  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  007d2	c7 84 16 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+196], 0

; 546  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  007dd	c7 84 16 bc 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+188], -1

; 547  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  007e8	c7 84 16 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+200], 0

; 548  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  007f3	66 c7 84 16 cc
	00 00 00 00 00	 mov	 WORD PTR [esi+edx+204], 0

; 549  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 550  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  007fd	c7 84 16 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+512], -1

; 551  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX = -1;

  00808	c7 84 16 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+516], -1

; 552  : 		this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1000;

  00813	c7 84 16 0c 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+524], 1000 ; 000003e8H
  0081e	8b 84 16 d0 00
	00 00		 mov	 eax, DWORD PTR [esi+edx+208]
  00825	83 f8 ff	 cmp	 eax, -1
  00828	74 5e		 je	 SHORT $LN33@ClearBridg

; 537  : 		{
; 538  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP = 0;

  0082a	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00830	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00835	c7 84 01 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4664], 0

; 539  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex = -1;

  00840	69 8c 16 d0 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+208], 10048
  0084b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00850	c6 84 01 36 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4662], -1

; 540  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex = -1;

  00858	69 8c 16 d0 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+208], 10048
  00863	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00868	c6 84 01 37 12
	00 00 ff	 mov	 BYTE PTR [ecx+eax+4663], -1

; 541  : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_bBloodCastleComplete = false;

  00870	69 8c 16 d0 00
	00 00 40 27 00
	00		 imul	 ecx, DWORD PTR [esi+edx+208], 10048
  0087b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00880	c6 84 01 3c 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4668], 0
$LN33@ClearBridg:

; 542  : 		}
; 543  : 
; 544  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  00888	c7 84 16 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+212], 0

; 545  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  00893	c7 84 16 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+216], 0

; 546  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  0089e	c7 84 16 d0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+208], -1

; 547  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState= 0;

  008a9	c7 84 16 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edx+220], 0

; 548  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = false;

  008b4	66 c7 84 16 e0
	00 00 00 00 00	 mov	 WORD PTR [esi+edx+224], 0

; 549  : 		this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak = false;
; 550  : 		this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = -1;

  008be	c7 84 16 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+512], -1

; 551  : 		this->m_BridgeData[iBridgeIndex].m_iBC_DOOR_SUBSIST_INDEX = -1;

  008c9	c7 84 16 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [esi+edx+516], -1

; 552  : 		this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = 1000;

  008d4	c7 84 16 0c 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [esi+edx+524], 1000 ; 000003e8H
  008df	5e		 pop	 esi
$LN13@ClearBridg:

; 553  : 	}
; 554  : }

  008e0	5d		 pop	 ebp
  008e1	c2 04 00	 ret	 4
?ClearBridgeData@CBloodCastle@@IAEXH@Z ENDP		; CBloodCastle::ClearBridgeData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckSync@CBloodCastle@@IAEXH@Z
_TEXT	SEGMENT
_pTime$ = -36						; size = 8
_ltime$ = -36						; size = 8
_today$1$ = -28						; size = 4
_this$1$ = -24						; size = 4
_pFirstTime$2$ = -20					; size = 4
_pFirstTime$1$ = -16					; size = 4
_FIRST_TIME$1$ = -12					; size = 4
tv777 = -8						; size = 4
_pTime$2$ = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckSync@CBloodCastle@@IAEXH@Z PROC			; CBloodCastle::CheckSync, COMDAT
; _this$ = ecx

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 379  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0000c	89 75 e8	 mov	 DWORD PTR _this$1$[ebp], esi
  0000f	85 c9		 test	 ecx, ecx
  00011	0f 88 a1 01 00
	00		 js	 $LN1@CheckSync
  00017	33 c0		 xor	 eax, eax
  00019	83 f9 07	 cmp	 ecx, 7
  0001c	0f 9e c0	 setle	 al
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 91 01 00
	00		 je	 $LN1@CheckSync

; 380  : 	{
; 381  : 		return;
; 382  : 	}
; 383  : 
; 384  : 	std::list<_EVENT_TIME>::iterator Itor_;
; 385  : 
; 386  : 	_EVENT_TIME pFirstTime;
; 387  : 	_EVENT_TIME pTime;
; 388  : 
; 389  : 	DWORD FIRST_TIME = 0;
; 390  : 	DWORD CHECK_TIME = 0;
; 391  : 	DWORD NOW_TIME = 0;
; 392  : 
; 393  : 	this->m_BridgeData[iBridgeIndex].m_iBC_TICK_COUNT = GetTickCount();

  00027	53		 push	 ebx
  00028	69 d9 0c 02 00
	00		 imul	 ebx, ecx, 524
  0002e	03 de		 add	 ebx, esi
  00030	89 5d f8	 mov	 DWORD PTR tv777[ebp], ebx
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00039	89 83 58 01 00
	00		 mov	 DWORD PTR [ebx+344], eax

; 394  : 
; 395  : 	if( m_EventTime.size() == 0)

  0003f	83 be 84 10 00
	00 00		 cmp	 DWORD PTR [esi+4228], 0
  00046	75 15		 jne	 SHORT $LN8@CheckSync

; 396  : 	{
; 397  : 		MsgBox("Error : Blood Castle StartTime size is 0");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@HNEOPLMK@Error?5?3?5Blood?5Castle?5StartTime?5s@
  0004d	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00052	83 c4 04	 add	 esp, 4
  00055	5b		 pop	 ebx
  00056	5e		 pop	 esi

; 478  : 
; 479  : 
; 480  : }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
$LN8@CheckSync:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  0005d	8d 45 dc	 lea	 eax, DWORD PTR _ltime$[ebp]
  00060	57		 push	 edi
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 __time64

; 511  :             return _localtime64(_Time);

  00067	8d 45 dc	 lea	 eax, DWORD PTR _ltime$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 __localtime64
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 405  : 	today = localtime(&ltime);

  00070	89 45 e4	 mov	 DWORD PTR _today$1$[ebp], eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 511  :             return _localtime64(_Time);

  00073	83 c4 08	 add	 esp, 8
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 407  : 	NOW_TIME = today->tm_hour * 60 + today->tm_min;

  00076	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00079	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007c	c1 e2 04	 shl	 edx, 4
  0007f	2b 50 08	 sub	 edx, DWORD PTR [eax+8]
  00082	8d 3c 91	 lea	 edi, DWORD PTR [ecx+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 531  : 		return ((_Nodepref)_Pnode->_Next);

  00085	8b 8e 80 10 00
	00		 mov	 ecx, DWORD PTR [esi+4224]

; 43   : 		: _Ptr(_Pnode)

  0008b	8b 01		 mov	 eax, DWORD PTR [ecx]
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 409  : 	pFirstTime = *m_EventTime.begin();

  0008d	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00090	89 55 f0	 mov	 DWORD PTR _pFirstTime$1$[ebp], edx
  00093	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00096	89 55 ec	 mov	 DWORD PTR _pFirstTime$2$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 296  : 		return (this->_Ptr == _Right._Ptr);

  00099	3b c1		 cmp	 eax, ecx
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 411  : 	for( Itor_ = m_EventTime.begin() ; Itor_ != m_EventTime.end(); ++Itor_ )

  0009b	74 55		 je	 SHORT $LN282@CheckSync
  0009d	0f 1f 00	 npad	 3
$LL4@CheckSync:

; 412  : 	{
; 413  : 		pTime = *Itor_;

  000a0	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]

; 414  : 
; 415  : 		FIRST_TIME = pFirstTime.Hour * 60 + pFirstTime.Min;

  000a3	8b 5d ec	 mov	 ebx, DWORD PTR _pFirstTime$2$[ebp]
  000a6	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  000a9	89 55 fc	 mov	 DWORD PTR _pTime$2$[ebp], edx
  000ac	8b 55 f0	 mov	 edx, DWORD PTR _pFirstTime$1$[ebp]
  000af	c1 e2 04	 shl	 edx, 4
  000b2	2b 55 f0	 sub	 edx, DWORD PTR _pFirstTime$1$[ebp]
  000b5	8d 14 93	 lea	 edx, DWORD PTR [ebx+edx*4]

; 416  : 		CHECK_TIME = pTime.Hour * 60 + pTime.Min;

  000b8	8b 5d fc	 mov	 ebx, DWORD PTR _pTime$2$[ebp]
  000bb	89 55 f4	 mov	 DWORD PTR _FIRST_TIME$1$[ebp], edx
  000be	8b d6		 mov	 edx, esi
  000c0	c1 e2 04	 shl	 edx, 4
  000c3	2b d6		 sub	 edx, esi
  000c5	8d 14 93	 lea	 edx, DWORD PTR [ebx+edx*4]

; 417  : 
; 418  : 		if( FIRST_TIME == CHECK_TIME )

  000c8	39 55 f4	 cmp	 DWORD PTR _FIRST_TIME$1$[ebp], edx
  000cb	75 09		 jne	 SHORT $LN9@CheckSync

; 419  : 		{
; 420  : 			if( NOW_TIME < CHECK_TIME )

  000cd	3b fa		 cmp	 edi, edx
  000cf	73 19		 jae	 SHORT $LN2@CheckSync

; 421  : 			{
; 422  : 				pTime = *Itor_;

  000d1	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000d4	eb 22		 jmp	 SHORT $LN284@CheckSync
$LN9@CheckSync:

; 423  : 				break;
; 424  : 			}
; 425  : 			continue;
; 426  : 		}
; 427  : 
; 428  : 		if( NOW_TIME >= FIRST_TIME &&

  000d6	3b 7d f4	 cmp	 edi, DWORD PTR _FIRST_TIME$1$[ebp]
  000d9	72 04		 jb	 SHORT $LN11@CheckSync
  000db	3b fa		 cmp	 edi, edx
  000dd	72 1c		 jb	 SHORT $LN281@CheckSync
$LN11@CheckSync:

; 429  : 			NOW_TIME < CHECK_TIME )
; 430  : 		{
; 431  : 			break;
; 432  : 		}
; 433  : 
; 434  : 		pFirstTime = *Itor_;

  000df	8b d6		 mov	 edx, esi
  000e1	89 55 f0	 mov	 DWORD PTR _pFirstTime$1$[ebp], edx
  000e4	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000e7	89 55 ec	 mov	 DWORD PTR _pFirstTime$2$[ebp], edx
$LN2@CheckSync:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  000ea	8b 00		 mov	 eax, DWORD PTR [eax]

; 296  : 		return (this->_Ptr == _Right._Ptr);

  000ec	3b c1		 cmp	 eax, ecx
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 411  : 	for( Itor_ = m_EventTime.begin() ; Itor_ != m_EventTime.end(); ++Itor_ )

  000ee	75 b0		 jne	 SHORT $LL4@CheckSync
  000f0	eb 09		 jmp	 SHORT $LN281@CheckSync
$LN282@CheckSync:

; 421  : 			{
; 422  : 				pTime = *Itor_;

  000f2	8b 55 e0	 mov	 edx, DWORD PTR _pTime$[ebp+4]
  000f5	8b 75 dc	 mov	 esi, DWORD PTR _pTime$[ebp]
$LN284@CheckSync:
  000f8	89 55 fc	 mov	 DWORD PTR _pTime$2$[ebp], edx
$LN281@CheckSync:

; 435  : 	}
; 436  : 
; 437  : 	int CHECK_COUNT = 2;

  000fb	ba 02 00 00 00	 mov	 edx, 2
$LL5@CheckSync:

; 438  : 
; 439  : 	while( CHECK_COUNT-- )

  00100	4a		 dec	 edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 296  : 		return (this->_Ptr == _Right._Ptr);

  00101	3b c1		 cmp	 eax, ecx
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 441  : 		if( Itor_ == m_EventTime.end() )

  00103	75 0b		 jne	 SHORT $LN12@CheckSync

; 442  : 		{
; 443  : 			Itor_ = m_EventTime.begin();

  00105	8b 01		 mov	 eax, DWORD PTR [ecx]

; 444  : 			pTime = *Itor_;

  00107	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0010a	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0010d	89 4d fc	 mov	 DWORD PTR _pTime$2$[ebp], ecx
$LN12@CheckSync:

; 445  : 		}
; 446  : 
; 447  : 		CHECK_TIME = pTime.Hour * 60 + pTime.Min;

  00110	8b 5d fc	 mov	 ebx, DWORD PTR _pTime$2$[ebp]
  00113	8b ce		 mov	 ecx, esi
  00115	c1 e1 04	 shl	 ecx, 4
  00118	2b ce		 sub	 ecx, esi
  0011a	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]

; 448  : 
; 449  : 		if( today->tm_hour <= pTime.Hour &&

  0011d	8b 5d e4	 mov	 ebx, DWORD PTR _today$1$[ebp]
  00120	39 73 08	 cmp	 DWORD PTR [ebx+8], esi
  00123	8b 5d f8	 mov	 ebx, DWORD PTR tv777[ebp]
  00126	7f 08		 jg	 SHORT $LN13@CheckSync
  00128	3b cf		 cmp	 ecx, edi
  0012a	76 04		 jbe	 SHORT $LN13@CheckSync

; 450  : 			CHECK_TIME > NOW_TIME )
; 451  : 		{
; 452  : 			this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (CHECK_TIME -NOW_TIME)*60*1000;

  0012c	2b cf		 sub	 ecx, edi

; 453  : 		}
; 454  : 		else

  0012e	eb 08		 jmp	 SHORT $LN285@CheckSync
$LN13@CheckSync:

; 455  : 		{
; 456  : 			this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC = (1440 - NOW_TIME + CHECK_TIME)*60*1000;

  00130	2b cf		 sub	 ecx, edi
  00132	81 c1 a0 05 00
	00		 add	 ecx, 1440		; 000005a0H
$LN285@CheckSync:
  00138	69 c9 60 ea 00
	00		 imul	 ecx, ecx, 60000
  0013e	89 8b 54 01 00
	00		 mov	 DWORD PTR [ebx+340], ecx

; 457  : 		}
; 458  : 
; 459  : 		if( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= m_iBC_TIME_MIN_OPEN*60*1000 )

  00144	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00147	69 89 68 10 00
	00 60 ea 00 00	 imul	 ecx, DWORD PTR [ecx+4200], 60000
  00151	39 8b 54 01 00
	00		 cmp	 DWORD PTR [ebx+340], ecx
  00157	7f 1f		 jg	 SHORT $LN15@CheckSync
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 43   : 		: _Ptr(_Pnode)

  00159	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  0015c	8b 00		 mov	 eax, DWORD PTR [eax]

; 43   : 		: _Ptr(_Pnode)

  0015e	8b 89 80 10 00
	00		 mov	 ecx, DWORD PTR [ecx+4224]

; 296  : 		return (this->_Ptr == _Right._Ptr);

  00164	3b c1		 cmp	 eax, ecx
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 462  : 			if( Itor_ != m_EventTime.end() )

  00166	74 0c		 je	 SHORT $LN17@CheckSync

; 463  : 			{
; 464  : 				pTime = *Itor_;

  00168	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  0016b	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0016e	89 5d fc	 mov	 DWORD PTR _pTime$2$[ebp], ebx
  00171	8b 5d f8	 mov	 ebx, DWORD PTR tv777[ebp]
$LN17@CheckSync:

; 438  : 
; 439  : 	while( CHECK_COUNT-- )

  00174	85 d2		 test	 edx, edx
  00176	75 88		 jne	 SHORT $LL5@CheckSync
$LN15@CheckSync:

; 465  : 			}
; 466  : 		}
; 467  : 		else
; 468  : 		{
; 469  : 			break;
; 470  : 		}
; 471  : 	}
; 472  : 
; 473  : 	DWORD Tick = GetTickCount();

  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 474  : 
; 475  : 	this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC -= today->tm_sec*1000;

  0017e	8b 45 e4	 mov	 eax, DWORD PTR _today$1$[ebp]
  00181	69 00 18 fc ff
	ff		 imul	 eax, DWORD PTR [eax], -1000
  00187	01 83 54 01 00
	00		 add	 DWORD PTR [ebx+340], eax

; 476  : 
; 477  : 	LogAddTD("[BloodCastle] (%d) Sync Open Time. [%d] min remain",iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC/60000);

  0018d	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  00192	f7 ab 54 01 00
	00		 imul	 DWORD PTR [ebx+340]
  00198	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  0019b	8b c2		 mov	 eax, edx
  0019d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001a0	03 c2		 add	 eax, edx
  001a2	50		 push	 eax
  001a3	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  001a6	40		 inc	 eax
  001a7	50		 push	 eax
  001a8	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@ILIPMAJB@?$FLBloodCastle?$FN?5?$CI?$CFd?$CJ?5Sync?5Open?5Tim@
  001ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b6	5f		 pop	 edi
  001b7	5b		 pop	 ebx
$LN1@CheckSync:
  001b8	5e		 pop	 esi

; 478  : 
; 479  : 
; 480  : }

  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c2 04 00	 ret	 4
?CheckSync@CBloodCastle@@IAEXH@Z ENDP			; CBloodCastle::CheckSync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ??1CBloodCastle@@UAE@XZ
_TEXT	SEGMENT
??1CBloodCastle@@UAE@XZ PROC				; CBloodCastle::~CBloodCastle, COMDAT
; _this$ = ecx

; 154  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	bb 08 00 00 00	 mov	 ebx, 8
  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CBloodCastle@@6B@
  00010	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
$LL4@CBloodCast:

; 155  : 	for ( int i =0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )
; 156  : 	{
; 157  : 		DeleteCriticalSection(&this->m_BridgeData[i].m_critUserData);

  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  0001a	81 c6 0c 02 00
	00		 add	 esi, 524		; 0000020cH
  00020	83 eb 01	 sub	 ebx, 1
  00023	75 ee		 jne	 SHORT $LL4@CBloodCast
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 531  : 		return ((_Nodepref)_Pnode->_Next);

  00025	8b 87 80 10 00
	00		 mov	 eax, DWORD PTR [edi+4224]

; 537  : 		}
; 538  : 
; 539  : 	static reference _Myval(_Nodeptr _Pnode)
; 540  : 		{	// return reference to value in node
; 541  : 		return ((reference)_Pnode->_Myval);
; 542  : 		}
; 543  : 
; 544  : 	_Nodeptr _Myhead;	// pointer to head node
; 545  : 	size_type _Mysize;	// number of elements
; 546  : 	};
; 547  : 
; 548  : 		// TEMPLATE CLASS _List_alloc
; 549  : template<class _Alloc_types>
; 550  : 	class _List_alloc
; 551  : 	{	// base class for list to hold allocator
; 552  : public:
; 553  : 	typedef _List_alloc<_Alloc_types> _Myt;
; 554  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 555  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 556  : 	typedef typename _Alloc_types::_Node _Node;
; 557  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 558  : 
; 559  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 560  : 
; 561  : 	typedef _Nodeptr& _Nodepref;
; 562  : 
; 563  : 	typedef typename _Val_types::value_type value_type;
; 564  : 	typedef typename _Val_types::size_type size_type;
; 565  : 	typedef typename _Val_types::difference_type difference_type;
; 566  : 	typedef typename _Val_types::pointer pointer;
; 567  : 	typedef typename _Val_types::const_pointer const_pointer;
; 568  : 	typedef typename _Val_types::reference reference;
; 569  : 	typedef typename _Val_types::const_reference const_reference;
; 570  : 
; 571  : 	typedef _List_const_iterator<_List_val<_Val_types> > const_iterator;
; 572  : 	typedef _List_iterator<_List_val<_Val_types> > iterator;
; 573  : 
; 574  : 	typedef _List_unchecked_const_iterator<_List_val<_Val_types> >
; 575  : 		_Unchecked_const_iterator;
; 576  : 	typedef _List_unchecked_iterator<_List_val<_Val_types> >
; 577  : 		_Unchecked_iterator;
; 578  : 
; 579  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 580  : 		{	// return reference to successor pointer in node
; 581  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));
; 582  : 		}
; 583  : 
; 584  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 585  : 		{	// return reference to predecessor pointer in node
; 586  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));
; 587  : 		}
; 588  : 
; 589  : 	static reference _Myval(_Nodeptr _Pnode)
; 590  : 		{	// return reference to value in node
; 591  : 		return (_List_val<_Val_types>::_Myval(_Pnode));
; 592  : 		}
; 593  : 
; 594  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 595  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 596  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 597  : 		{	// construct head node, allocator from _Al
; 598  : 		_Myhead() = _Buyheadnode();
; 599  : 		}
; 600  : 
; 601  : 	_List_alloc(_Alloc&& _Al)
; 602  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 603  : 		{	// construct head node, allocator from _Al
; 604  : 		_Myhead() = _Buyheadnode();
; 605  : 		}
; 606  : 
; 607  : 	~_List_alloc() _NOEXCEPT
; 608  : 		{	// destroy head node
; 609  : 		_Freeheadnode(_Myhead());
; 610  : 		}
; 611  : 
; 612  : 	void _Copy_alloc(const _Alty& _Al)
; 613  : 		{	// replace old allocator
; 614  : 		_Pocca(_Getal(), _Al);
; 615  : 		}
; 616  : 
; 617  : 	void _Move_alloc(_Alty& _Al)
; 618  : 		{	// replace old allocator
; 619  : 		_Pocma(_Getal(), _Al);
; 620  : 		}
; 621  : 
; 622  : 	void _Swap_alloc(_Myt& _Right)
; 623  : 		{	// swap allocators
; 624  : 		_Pocs(_Getal(), _Right._Getal());
; 625  : 		}
; 626  : 
; 627  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 628  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 629  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 630  : 		{	// construct head node, allocator from _Al
; 631  : 		_Myhead() = _Buyheadnode();
; 632  : 		_TRY_BEGIN
; 633  : 		_Alloc_proxy();
; 634  : 		_CATCH_ALL
; 635  : 		_Freeheadnode(_Myhead());
; 636  : 		_RERAISE;
; 637  : 		_CATCH_END
; 638  : 		}
; 639  : 
; 640  : 	_List_alloc(_Alloc&& _Al)
; 641  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 642  : 		{	// construct head node, allocator from _Al
; 643  : 		_Myhead() = _Buyheadnode();
; 644  : 		_TRY_BEGIN
; 645  : 		_Alloc_proxy();
; 646  : 		_CATCH_ALL
; 647  : 		_Freeheadnode(_Myhead());
; 648  : 		_RERAISE;
; 649  : 		_CATCH_END
; 650  : 		}
; 651  : 
; 652  : 	~_List_alloc() _NOEXCEPT
; 653  : 		{	// destroy proxy
; 654  : 		_Freeheadnode(_Myhead());
; 655  : 		_Free_proxy();
; 656  : 		}
; 657  : 
; 658  : 	void _Copy_alloc(const _Alty& _Al)
; 659  : 		{	// replace old allocator
; 660  : 		_Free_proxy();
; 661  : 		_Pocca(_Getal(), _Al);
; 662  : 		_Alloc_proxy();
; 663  : 		}
; 664  : 
; 665  : 	void _Move_alloc(_Alty& _Al)
; 666  : 		{	// replace old allocator
; 667  : 		_Free_proxy();
; 668  : 		_Pocma(_Getal(), _Al);
; 669  : 		_Alloc_proxy();
; 670  : 		}
; 671  : 
; 672  : 	void _Swap_alloc(_Myt& _Right)
; 673  : 		{	// swap allocators
; 674  : 		_Pocs(_Getal(), _Right._Getal());
; 675  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 676  : 		}
; 677  : 
; 678  : 	void _Alloc_proxy()
; 679  : 		{	// construct proxy
; 680  : 		typename _Alty::template rebind<_Container_proxy>::other
; 681  : 			_Alproxy(_Getal());
; 682  : 		_Myproxy() = _Alproxy.allocate(1);
; 683  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 684  : 		_Myproxy()->_Mycont = &_Get_data();
; 685  : 		}
; 686  : 
; 687  : 	void _Free_proxy()
; 688  : 		{	// destroy proxy
; 689  : 		typename _Alty::template rebind<_Container_proxy>::other
; 690  : 			_Alproxy(_Getal());
; 691  : 		_Orphan_all();
; 692  : 		_Alproxy.destroy(_Myproxy());
; 693  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 694  : 		_Myproxy() = 0;
; 695  : 		}
; 696  : 
; 697  : 	_Iterator_base12 **_Getpfirst() const
; 698  : 		{	// get address of iterator chain
; 699  : 		return (_Get_data()._Getpfirst());
; 700  : 		}
; 701  : 
; 702  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 703  : 		{	// return reference to _Myproxy
; 704  : 		return (_Get_data()._Myproxy);
; 705  : 		}
; 706  : 
; 707  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 708  : 		{	// return const reference to _Myproxy
; 709  : 		return (_Get_data()._Myproxy);
; 710  : 		}
; 711  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 712  : 
; 713  : 	_Nodeptr _Buyheadnode()
; 714  : 		{	// get head node using current allocator
; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 716  : 		}
; 717  : 
; 718  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 719  : 		{	// free head node using current allocator
; 720  : 		_Getal().destroy(
; 721  : 			_STD addressof(_Nextnode(_Pnode)));
; 722  : 		_Getal().destroy(
; 723  : 			_STD addressof(_Prevnode(_Pnode)));
; 724  : 		_Getal().deallocate(_Pnode, 1);
; 725  : 		}
; 726  : 
; 727  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 728  : 		_Nodeptr _Prev)
; 729  : 		{	// allocate a node and set links
; 730  : 		_Nodeptr _Pnode = _Getal().allocate(1);
; 731  : 
; 732  : 		if (_Next == _Nodeptr())
; 733  : 			{	// point at self
; 734  : 			_Next = _Pnode;
; 735  : 			_Prev = _Pnode;
; 736  : 			}
; 737  : 		_TRY_BEGIN
; 738  : 		_Getal().construct(
; 739  : 			_STD addressof(_Nextnode(_Pnode)), _Next);
; 740  : 		_Getal().construct(
; 741  : 			_STD addressof(_Prevnode(_Pnode)), _Prev);
; 742  : 		_CATCH_ALL
; 743  : 		_Getal().deallocate(_Pnode, 1);
; 744  : 		_RERAISE;
; 745  : 		_CATCH_END
; 746  : 
; 747  : 		return (_Pnode);
; 748  : 		}
; 749  : 
; 750  : 	void _Orphan_all()
; 751  : 		{	// orphan all iterators
; 752  : 		_Get_data()._Orphan_all();
; 753  : 		}
; 754  : 
; 755  : 	void _Swap_all(_Myt& _Right)
; 756  : 		{	// swap all iterators
; 757  : 		_Get_data()._Swap_all(_Right._Get_data());
; 758  : 		}
; 759  : 
; 760  : 	_Alty& _Getal() _NOEXCEPT
; 761  : 		{	// return reference to allocator
; 762  : 		return (_Mypair._Get_first());
; 763  : 		}
; 764  : 
; 765  : 	const _Alty& _Getal() const _NOEXCEPT
; 766  : 		{	// return const reference to allocator
; 767  : 		return (_Mypair._Get_first());
; 768  : 		}
; 769  : 
; 770  : 	_List_val<_Val_types>& _Get_data() _NOEXCEPT
; 771  : 		{	// return reference to _List_val
; 772  : 		return (_Mypair._Get_second());
; 773  : 		}
; 774  : 
; 775  : 	const _List_val<_Val_types>& _Get_data() const _NOEXCEPT
; 776  : 		{	// return const reference to _List_val
; 777  : 		return (_Mypair._Get_second());
; 778  : 		}
; 779  : 
; 780  : 	_Nodeptr& _Myhead() _NOEXCEPT
; 781  : 		{	// return reference to _Myhead
; 782  : 		return (_Get_data()._Myhead);
; 783  : 		}
; 784  : 
; 785  : 	const _Nodeptr& _Myhead() const _NOEXCEPT
; 786  : 		{	// return const reference to _Myhead
; 787  : 		return (_Get_data()._Myhead);
; 788  : 		}
; 789  : 
; 790  : 	size_type& _Mysize() _NOEXCEPT
; 791  : 		{	// return reference to _Mysize
; 792  : 		return (_Get_data()._Mysize);
; 793  : 		}
; 794  : 
; 795  : 	const size_type& _Mysize() const _NOEXCEPT
; 796  : 		{	// return const reference to _Mysize
; 797  : 		return (_Get_data()._Mysize);
; 798  : 		}
; 799  : 
; 800  : private:
; 801  : 	_Compressed_pair<_Alty, _List_val<_Val_types> > _Mypair;
; 802  : 	};
; 803  : 
; 804  : 		// TEMPLATE CLASS _List_buy
; 805  : template<class _Ty,
; 806  : 	class _Alloc>
; 807  : 	class _List_buy
; 808  : 		: public _List_alloc<_List_base_types<_Ty, _Alloc> >
; 809  : 	{	// base class for list to hold buynode/freenode functions
; 810  : public:
; 811  : 	typedef _List_alloc<_List_base_types<_Ty, _Alloc> > _Mybase;
; 812  : 	typedef typename _Mybase::_Alty _Alty;
; 813  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 814  : 
; 815  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from allocator
; 818  : 		}
; 819  : 
; 820  : 	_List_buy(_Alloc&& _Al)
; 821  : 		: _Mybase(_STD move(_Al))
; 822  : 		{	// construct from allocator
; 823  : 		}
; 824  : 
; 825  : 	template<class... _Valty>
; 826  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
; 827  : 			_Valty&&... _Val)
; 828  : 		{	// allocate a node and set links and value
; 829  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);
; 830  : 
; 831  : 		_TRY_BEGIN
; 832  : 		this->_Getal().construct(
; 833  : 			_STD addressof(this->_Myval(_Pnode)),
; 834  : 				_STD forward<_Valty>(_Val)...);
; 835  : 		_CATCH_ALL
; 836  : 		this->_Getal().deallocate(_Pnode, 1);
; 837  : 		_RERAISE;
; 838  : 		_CATCH_END
; 839  : 
; 840  : 		return (_Pnode);
; 841  : 		}
; 842  : 
; 843  : 
; 844  : 	void _Freenode(_Nodeptr _Pnode)
; 845  : 		{	// give node back
; 846  : 		this->_Getal().destroy(
; 847  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 848  : 		this->_Getal().destroy(
; 849  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 850  : 		this->_Getal().destroy(
; 851  : 			_STD addressof(this->_Myval(_Pnode)));
; 852  : 		this->_Getal().deallocate(_Pnode, 1);
; 853  : 		}
; 854  : 	};
; 855  : 
; 856  : 		// TEMPLATE CLASS list
; 857  : template<class _Ty,
; 858  : 	class _Alloc = allocator<_Ty> >
; 859  : 	class list
; 860  : 		: public _List_buy<_Ty, _Alloc>
; 861  : 	{	// bidirectional linked list
; 862  : public:
; 863  : 	typedef list<_Ty, _Alloc> _Myt;
; 864  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 865  : 	typedef typename _Mybase::_Node _Node;
; 866  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 867  : 	typedef typename _Mybase::_Alty _Alty;
; 868  : 
; 869  : 	typedef _Alloc allocator_type;
; 870  : 	typedef typename _Mybase::size_type size_type;
; 871  : 	typedef typename _Mybase::difference_type difference_type;
; 872  : 	typedef typename _Mybase::pointer pointer;
; 873  : 	typedef typename _Mybase::const_pointer const_pointer;
; 874  : 	typedef typename _Mybase::reference reference;
; 875  : 	typedef typename _Mybase::const_reference const_reference;
; 876  : 	typedef typename _Mybase::value_type value_type;
; 877  : 
; 878  : 	typedef typename _Mybase::const_iterator const_iterator;
; 879  : 	typedef typename _Mybase::iterator iterator;
; 880  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 881  : 		_Unchecked_const_iterator;
; 882  : 	typedef typename _Mybase::_Unchecked_iterator
; 883  : 		_Unchecked_iterator;
; 884  : 
; 885  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 886  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 887  : 
; 888  : 	list()
; 889  : 		: _Mybase()
; 890  : 		{	// construct empty list
; 891  : 		}
; 892  : 
; 893  : 	explicit list(const _Alloc& _Al)
; 894  : 		: _Mybase(_Al)
; 895  : 		{	// construct empty list, allocator
; 896  : 		}
; 897  : 
; 898  : 	explicit list(size_type _Count)
; 899  : 		: _Mybase()
; 900  : 		{	// construct list from _Count * _Ty()
; 901  : 		resize(_Count);
; 902  : 		}
; 903  : 
; 904  : 	list(size_type _Count, const _Ty& _Val)
; 905  : 		: _Mybase()
; 906  : 		{	// construct list from _Count * _Val
; 907  : 		_Construct_n(_Count, _Val);
; 908  : 		}
; 909  : 
; 910  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 911  : 		: _Mybase(_Al)
; 912  : 		{	// construct list from _Count * _Val, allocator
; 913  : 		_Construct_n(_Count, _Val);
; 914  : 		}
; 915  : 
; 916  : 	list(const _Myt& _Right)
; 917  : 
; 918  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 919  : 
; 920  : 
; 921  : 		{	// construct list by copying _Right
; 922  : 		_TRY_BEGIN
; 923  : 		insert(begin(), _Right.begin(), _Right.end());
; 924  : 		_CATCH_ALL
; 925  : 		_Tidy();
; 926  : 		_RERAISE;
; 927  : 		_CATCH_END
; 928  : 		}
; 929  : 
; 930  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 931  : 		: _Mybase(_Al)
; 932  : 		{	// construct list by copying _Right, allocator
; 933  : 		_TRY_BEGIN
; 934  : 		insert(begin(), _Right.begin(), _Right.end());
; 935  : 		_CATCH_ALL
; 936  : 		_Tidy();
; 937  : 		_RERAISE;
; 938  : 		_CATCH_END
; 939  : 		}
; 940  : 
; 941  : 	template<class _Iter,
; 942  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 943  : 			void>::type>
; 944  : 		list(_Iter _First, _Iter _Last)
; 945  : 		: _Mybase()
; 946  : 		{	// construct list from [_First, _Last)
; 947  : 		_Construct(_First, _Last);
; 948  : 		}
; 949  : 
; 950  : 	template<class _Iter,
; 951  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 952  : 			void>::type>
; 953  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 954  : 		: _Mybase(_Al)
; 955  : 		{	// construct list, allocator from [_First, _Last)
; 956  : 		_Construct(_First, _Last);
; 957  : 		}
; 958  : 
; 959  : 	template<class _Iter>
; 960  : 		void _Construct(_Iter _First, _Iter _Last)
; 961  : 		{	// construct list from [_First, _Last), input iterators
; 962  : 		_TRY_BEGIN
; 963  : 		insert(begin(), _First, _Last);
; 964  : 		_CATCH_ALL
; 965  : 		_Tidy();
; 966  : 		_RERAISE;
; 967  : 		_CATCH_END
; 968  : 		}
; 969  : 
; 970  : 	void _Construct_n(size_type _Count,
; 971  : 		const _Ty& _Val)
; 972  : 		{	// construct from _Count * _Val
; 973  : 		_TRY_BEGIN
; 974  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 975  : 		_CATCH_ALL
; 976  : 		_Tidy();
; 977  : 		_RERAISE;
; 978  : 		_CATCH_END
; 979  : 		}
; 980  : 
; 981  : 	list(_Myt&& _Right)
; 982  : 		: _Mybase(_STD move(_Right._Getal()))
; 983  : 		{	// construct list by moving _Right
; 984  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 985  : 		}
; 986  : 
; 987  : 	list(_Myt&& _Right, const _Alloc& _Al)
; 988  : 		: _Mybase(_Al)
; 989  : 		{	// construct list by moving _Right, allocator
; 990  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 991  : 		}
; 992  : 
; 993  : 	_Myt& operator=(_Myt&& _Right)
; 994  : 		_NOEXCEPT_OP(_Alty::is_always_equal::value)
; 995  : 		{	// assign by moving _Right
; 996  : 		if (this != &_Right)
; 997  : 			{	// different, assign it
; 998  : 			clear();
; 999  : 
; 1000 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1001 : 				&& this->_Getal() != _Right._Getal())
; 1002 : 				this->_Move_alloc(_Right._Getal());
; 1003 : 
; 1004 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1005 : 			}
; 1006 : 		return (*this);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Assign_rv(_Myt&& _Right)
; 1010 : 		{	// swap with empty *this, same allocator
; 1011 : 		this->_Swap_all(_Right);
; 1012 : 		_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1013 : 		_STD swap(this->_Mysize(), _Right._Mysize());
; 1014 : 		}
; 1015 : 
; 1016 : 	void push_front(_Ty&& _Val)
; 1017 : 		{	// insert element at beginning
; 1018 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1019 : 		}
; 1020 : 
; 1021 : 	void push_back(_Ty&& _Val)
; 1022 : 		{	// insert element at end
; 1023 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1024 : 		}
; 1025 : 
; 1026 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1027 : 		{	// insert _Val at _Where
; 1028 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1029 : 		}
; 1030 : 
; 1031 : 	template<class... _Valty>
; 1032 : 		void emplace_front(_Valty&&... _Val)
; 1033 : 		{	// insert element at beginning
; 1034 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1035 : 		}
; 1036 : 
; 1037 : 	template<class... _Valty>
; 1038 : 		void emplace_back(_Valty&&... _Val)
; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);
; 1041 : 		}
; 1042 : 
; 1043 : 	template<class... _Valty>
; 1044 : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 1045 : 		{	// insert element at _Where
; 1046 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1047 : 		if (_Where._Getcont() != &this->_Get_data())
; 1048 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1049 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1050 : 
; 1051 : 		_Insert(_Where._Unchecked(), _STD forward<_Valty>(_Val)...);
; 1052 : 		return (_Make_iter(--_Where));
; 1053 : 		}
; 1054 : 
; 1055 : 	template<class... _Valty>
; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,
; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);
; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;
; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
; 1066 : 		}
; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Copy_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead()),
; 1117 : 			&this->_Get_data()));
; 1118 : 		}
; 1119 : 
; 1120 : 	const_iterator begin() const _NOEXCEPT
; 1121 : 		{	// return iterator for beginning of nonmutable sequence
; 1122 : 		return (const_iterator(this->_Nextnode(this->_Myhead()),
; 1123 : 			&this->_Get_data()));
; 1124 : 		}
; 1125 : 
; 1126 : 	iterator end() _NOEXCEPT
; 1127 : 		{	// return iterator for end of mutable sequence
; 1128 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1129 : 		}
; 1130 : 
; 1131 : 	const_iterator end() const _NOEXCEPT
; 1132 : 		{	// return iterator for end of nonmutable sequence
; 1133 : 		return (const_iterator(this->_Myhead(), &this->_Get_data()));
; 1134 : 		}
; 1135 : 
; 1136 : 	_Unchecked_iterator _Unchecked_begin()
; 1137 : 		{	// return iterator for beginning of mutable sequence
; 1138 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead()),
; 1139 : 			&this->_Get_data()));
; 1140 : 		}
; 1141 : 
; 1142 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1143 : 		{	// return iterator for beginning of nonmutable sequence
; 1144 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead()),
; 1145 : 			&this->_Get_data()));
; 1146 : 		}
; 1147 : 
; 1148 : 	_Unchecked_iterator _Unchecked_end()
; 1149 : 		{	// return unchecked iterator for end of mutable sequence
; 1150 : 		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));
; 1151 : 		}
; 1152 : 
; 1153 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1154 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1155 : 		return (_Unchecked_const_iterator(this->_Myhead(),
; 1156 : 			&this->_Get_data()));
; 1157 : 		}
; 1158 : 
; 1159 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1160 : 		{	// make iterator from const_iterator
; 1161 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1162 : 		}
; 1163 : 
; 1164 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1165 : 		{	// make iterator from _Unchecked_const_iterator
; 1166 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1167 : 		}
; 1168 : 
; 1169 : 	reverse_iterator rbegin() _NOEXCEPT
; 1170 : 		{	// return iterator for beginning of reversed mutable sequence
; 1171 : 		return (reverse_iterator(end()));
; 1172 : 		}
; 1173 : 
; 1174 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1175 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1176 : 		return (const_reverse_iterator(end()));
; 1177 : 		}
; 1178 : 
; 1179 : 	reverse_iterator rend() _NOEXCEPT
; 1180 : 		{	// return iterator for end of reversed mutable sequence
; 1181 : 		return (reverse_iterator(begin()));
; 1182 : 		}
; 1183 : 
; 1184 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1185 : 		{	// return iterator for end of reversed nonmutable sequence
; 1186 : 		return (const_reverse_iterator(begin()));
; 1187 : 		}
; 1188 : 
; 1189 : 	const_iterator cbegin() const _NOEXCEPT
; 1190 : 		{	// return iterator for beginning of nonmutable sequence
; 1191 : 		return (begin());
; 1192 : 		}
; 1193 : 
; 1194 : 	const_iterator cend() const _NOEXCEPT
; 1195 : 		{	// return iterator for end of nonmutable sequence
; 1196 : 		return (end());
; 1197 : 		}
; 1198 : 
; 1199 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1200 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1201 : 		return (rbegin());
; 1202 : 		}
; 1203 : 
; 1204 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1205 : 		{	// return iterator for end of reversed nonmutable sequence
; 1206 : 		return (rend());
; 1207 : 		}
; 1208 : 
; 1209 : 	void resize(size_type _Newsize)
; 1210 : 		{	// determine new length, padding with _Ty() elements as needed
; 1211 : 		if (this->_Mysize() < _Newsize)
; 1212 : 			{	// pad to make larger
; 1213 : 			size_type _Count = 0;
; 1214 : 			_TRY_BEGIN
; 1215 : 			for (; this->_Mysize() < _Newsize; ++_Count)
; 1216 : 				_Insert(_Unchecked_end());
; 1217 : 			_CATCH_ALL
; 1218 : 			for (; 0 < _Count; --_Count)
; 1219 : 				pop_back();	// undo inserts
; 1220 : 			_RERAISE;
; 1221 : 			_CATCH_END
; 1222 : 			}
; 1223 : 		else
; 1224 : 			while (_Newsize < this->_Mysize())
; 1225 : 				pop_back();
; 1226 : 		}
; 1227 : 
; 1228 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1229 : 		{	// determine new length, padding with _Val elements as needed
; 1230 : 		if (this->_Mysize() < _Newsize)
; 1231 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize(), _Val);
; 1232 : 		else
; 1233 : 			while (_Newsize < this->_Mysize())
; 1234 : 				pop_back();
; 1235 : 		}
; 1236 : 
; 1237 : 	size_type size() const _NOEXCEPT
; 1238 : 		{	// return length of sequence
; 1239 : 		return (this->_Mysize());
; 1240 : 		}
; 1241 : 
; 1242 : 	size_type max_size() const _NOEXCEPT
; 1243 : 		{	// return maximum possible length of sequence
; 1244 : 		return (this->_Getal().max_size());
; 1245 : 		}
; 1246 : 
; 1247 : 	bool empty() const _NOEXCEPT
; 1248 : 		{	// test if sequence is empty
; 1249 : 		return (this->_Mysize() == 0);
; 1250 : 		}
; 1251 : 
; 1252 : 	allocator_type get_allocator() const _NOEXCEPT
; 1253 : 		{	// return allocator object for values
; 1254 : 		return (this->_Getal());
; 1255 : 		}
; 1256 : 
; 1257 : 	reference front()
; 1258 : 		{	// return first element of mutable sequence
; 1259 : 		return (*begin());
; 1260 : 		}
; 1261 : 
; 1262 : 	const_reference front() const
; 1263 : 		{	// return first element of nonmutable sequence
; 1264 : 		return (*begin());
; 1265 : 		}
; 1266 : 
; 1267 : 	reference back()
; 1268 : 		{	// return last element of mutable sequence
; 1269 : 		return (*(--end()));
; 1270 : 		}
; 1271 : 
; 1272 : 	const_reference back() const
; 1273 : 		{	// return last element of nonmutable sequence
; 1274 : 		return (*(--end()));
; 1275 : 		}
; 1276 : 
; 1277 : 	void push_front(const _Ty& _Val)
; 1278 : 		{	// insert element at beginning
; 1279 : 		_Insert(_Unchecked_begin(), _Val);
; 1280 : 		}
; 1281 : 
; 1282 : 	void pop_front()
; 1283 : 		{	// erase element at beginning
; 1284 : 		erase(begin());
; 1285 : 		}
; 1286 : 
; 1287 : 	void push_back(const _Ty& _Val)
; 1288 : 		{	// insert element at end
; 1289 : 		_Insert(_Unchecked_end(), _Val);
; 1290 : 		}
; 1291 : 
; 1292 : 	void pop_back()
; 1293 : 		{	// erase element at end
; 1294 : 		erase(--end());
; 1295 : 		}
; 1296 : 
; 1297 : 	template<class _Iter>
; 1298 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1299 : 			void>::type
; 1300 : 		assign(_Iter _First, _Iter _Last)
; 1301 : 		{	// assign [_First, _Last), input iterators
; 1302 : 		iterator _Old = begin();
; 1303 : 		_TRY_BEGIN
; 1304 : 		for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)
; 1305 : 			_Reusenode(_Old, *_First);
; 1306 : 		for (; _First != _Last; ++_First)
; 1307 : 			_Insert(_Unchecked_end(), *_First);
; 1308 : 		_CATCH_ALL
; 1309 : 		clear();
; 1310 : 		_RERAISE;
; 1311 : 		_CATCH_END
; 1312 : 		erase(_Old, end());
; 1313 : 		}
; 1314 : 
; 1315 : 	template<class _TArg>
; 1316 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1317 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1318 : 		_TRY_BEGIN
; 1319 : 		this->_Getal().destroy(
; 1320 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1321 : 		this->_Getal().construct(
; 1322 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1323 : 			_STD forward<_TArg>(_Arg));
; 1324 : 		_CATCH_ALL
; 1325 : 		_Unlinknode(_Where);
; 1326 : 		this->_Getal().destroy(
; 1327 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1328 : 		this->_Getal().destroy(
; 1329 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1330 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1331 : 		_RERAISE;
; 1332 : 		_CATCH_END
; 1333 : 		}
; 1334 : 
; 1335 : 	void assign(size_type _Count, const _Ty& _Val)
; 1336 : 		{	// assign _Count * _Val
; 1337 : 		clear();
; 1338 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1339 : 		}
; 1340 : 
; 1341 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1342 : 		{	// insert _Val at _Where
; 1343 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1344 : 		if (_Where._Getcont() != &this->_Get_data())
; 1345 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1346 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1347 : 
; 1348 : 		_Insert(_Where._Unchecked(), _Val);
; 1349 : 		return (_Make_iter(--_Where));
; 1350 : 		}
; 1351 : 
; 1352 : 	iterator insert(const_iterator _Where,
; 1353 : 		size_type _Count, const _Ty& _Val)
; 1354 : 		{	// insert _Count * _Val at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != &this->_Get_data())
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1364 : 			return (begin());
; 1365 : 			}
; 1366 : 		else
; 1367 : 			{	// insert sequence not at beginning
; 1368 : 			--_Prev;
; 1369 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1370 : 			return (++_Prev);
; 1371 : 			}
; 1372 : 		}
; 1373 : 
; 1374 : 	template<class _Iter>
; 1375 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1376 : 			iterator>::type
; 1377 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1378 : 		{	// insert [_First, _Last) at _Where
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_Where._Getcont() != &this->_Get_data())
; 1381 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1382 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1383 : 
; 1384 : 		iterator _Prev = _Make_iter(_Where);
; 1385 : 		if (_Prev == begin())
; 1386 : 			{	// insert sequence at beginning
; 1387 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1388 : 				_Iter_cat(_First));
; 1389 : 			return (begin());
; 1390 : 			}
; 1391 : 		else
; 1392 : 			{	// insert sequence not at beginning
; 1393 : 			--_Prev;
; 1394 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1395 : 				_Iter_cat(_First));
; 1396 : 			return (++_Prev);
; 1397 : 			}
; 1398 : 		}
; 1399 : 
; 1400 : 	template<class _Iter>
; 1401 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1402 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1403 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1404 : 		size_type _Num = 0;
; 1405 : 
; 1406 : 		_TRY_BEGIN
; 1407 : 		for (; _First != _Last; ++_First, (void)++_Num)
; 1408 : 			_Insert(_Where, *_First);
; 1409 : 		_CATCH_ALL
; 1410 : 		for (; 0 < _Num; --_Num)
; 1411 : 			{	// undo inserts
; 1412 : 			_Unchecked_const_iterator _Before = _Where;
; 1413 : 			_Unchecked_erase(--_Before);
; 1414 : 			}
; 1415 : 		_RERAISE;
; 1416 : 		_CATCH_END
; 1417 : 		}
; 1418 : 
; 1419 : 	template<class _Iter>
; 1420 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1421 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1422 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1423 : 		_DEBUG_RANGE(_First, _Last);
; 1424 : 		_Iter _Next = _First;
; 1425 : 
; 1426 : 		_TRY_BEGIN
; 1427 : 		for (; _First != _Last; ++_First)
; 1428 : 			_Insert(_Where, *_First);
; 1429 : 		_CATCH_ALL
; 1430 : 		for (; _Next != _First; ++_Next)
; 1431 : 			{	// undo inserts
; 1432 : 			_Unchecked_const_iterator _Before = _Where;
; 1433 : 			_Unchecked_erase(--_Before);
; 1434 : 			}
; 1435 : 		_RERAISE;
; 1436 : 		_CATCH_END
; 1437 : 		}
; 1438 : 
; 1439 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1440 : 		{	// unlink node at _Where from the list
; 1441 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1442 : 		if (_Where._Getcont() != &this->_Get_data()
; 1443 : 			|| _Where._Ptr == this->_Myhead())
; 1444 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1445 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1446 : 		_Orphan_ptr(_Pnode);
; 1447 : 
; 1448 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1449 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1453 : 			this->_Nextnode(_Pnode);
; 1454 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1455 : 			this->_Prevnode(_Pnode);
; 1456 : 
; 1457 : 		--this->_Mysize();
; 1458 : 		return (_Pnode);
; 1459 : 		}
; 1460 : 
; 1461 : 	iterator erase(const_iterator _Where)
; 1462 : 		{	// erase element at _Where
; 1463 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1464 : 		this->_Freenode(_Pnode);
; 1465 : 		return (_Make_iter(_Where));
; 1466 : 		}
; 1467 : 
; 1468 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1469 : 		{	// erase element at _Where
; 1470 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1471 : 
; 1472 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1473 : 			this->_Nextnode(_Pnode);
; 1474 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1475 : 			this->_Prevnode(_Pnode);
; 1476 : 		this->_Freenode(_Pnode);
; 1477 : 		--this->_Mysize();
; 1478 : 		}
; 1479 : 
; 1480 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1481 : 		{	// erase [_First, _Last)
; 1482 : 		if (_First == begin() && _Last == end())
; 1483 : 			{	// erase all and return fresh iterator
; 1484 : 			clear();
; 1485 : 			return (end());
; 1486 : 			}
; 1487 : 		else
; 1488 : 			{	// erase subrange
; 1489 : 			while (_First != _Last)
; 1490 : 				_First = erase(_First);
; 1491 : 			return (_Make_iter(_Last));
; 1492 : 			}
; 1493 : 		}
; 1494 : 
; 1495 : 	void clear() _NOEXCEPT
; 1496 : 		{	// erase all
; 1497 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1498 : 
; 1499 : 		this->_Orphan_ptr(nullptr);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1502 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

  0002d	89 00		 mov	 DWORD PTR [eax], eax

; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);

  0002f	8b 87 80 10 00
	00		 mov	 eax, DWORD PTR [edi+4224]

; 1503 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

  00035	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1504 : 		this->_Mysize() = 0;

  00038	89 9f 84 10 00
	00		 mov	 DWORD PTR [edi+4228], ebx

; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  0003e	3b 8f 80 10 00
	00		 cmp	 ecx, DWORD PTR [edi+4224]
  00044	74 15		 je	 SHORT $LN13@CBloodCast
$LL14@CBloodCast:

; 1507 : 			{	// delete an element
; 1508 : 			_Pnext = this->_Nextnode(_Pnode);

  00046	8b 31		 mov	 esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

  00051	8b ce		 mov	 ecx, esi
  00053	3b b7 80 10 00
	00		 cmp	 esi, DWORD PTR [edi+4224]
  00059	75 eb		 jne	 SHORT $LL14@CBloodCast
$LN13@CBloodCast:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 138  : 	::operator delete(_Ptr);

  0005b	ff b7 80 10 00
	00		 push	 DWORD PTR [edi+4224]
  00061	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00066	83 c4 04	 add	 esp, 4
  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 159  : }

  0006c	c3		 ret	 0
??1CBloodCastle@@UAE@XZ ENDP				; CBloodCastle::~CBloodCastle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ??0CBloodCastle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
_this$ = -4						; size = 4
??0CBloodCastle@@QAE@XZ PROC				; CBloodCastle::CBloodCastle, COMDAT
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8d b3 80 10 00
	00		 lea	 esi, DWORD PTR [ebx+4224]
  0000f	89 5d fc	 mov	 DWORD PTR _this$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00012	6a 00		 push	 0
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 126  : {

  00014	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7CBloodCastle@@6B@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0001a	8b ce		 mov	 ecx, esi
  0001c	6a 00		 push	 0
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 126  : {

  0001e	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 525  : 		this->_Myhead = 0;

  00021	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 526  : 		this->_Mysize = 0;

  00027	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 715  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0002e	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@U?$_List_base_types@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> > >::_Buynode0

; 527  : 		}
; 528  : 
; 529  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 530  : 		{	// return reference to successor pointer in node
; 531  : 		return ((_Nodepref)_Pnode->_Next);
; 532  : 		}
; 533  : 
; 534  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 535  : 		{	// return reference to predecessor pointer in node
; 536  : 		return ((_Nodepref)_Pnode->_Prev);
; 537  : 		}
; 538  : 
; 539  : 	static reference _Myval(_Nodeptr _Pnode)
; 540  : 		{	// return reference to value in node
; 541  : 		return ((reference)_Pnode->_Myval);
; 542  : 		}
; 543  : 
; 544  : 	_Nodeptr _Myhead;	// pointer to head node
; 545  : 	size_type _Mysize;	// number of elements
; 546  : 	};
; 547  : 
; 548  : 		// TEMPLATE CLASS _List_alloc
; 549  : template<class _Alloc_types>
; 550  : 	class _List_alloc
; 551  : 	{	// base class for list to hold allocator
; 552  : public:
; 553  : 	typedef _List_alloc<_Alloc_types> _Myt;
; 554  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 555  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 556  : 	typedef typename _Alloc_types::_Node _Node;
; 557  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 558  : 
; 559  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 560  : 
; 561  : 	typedef _Nodeptr& _Nodepref;
; 562  : 
; 563  : 	typedef typename _Val_types::value_type value_type;
; 564  : 	typedef typename _Val_types::size_type size_type;
; 565  : 	typedef typename _Val_types::difference_type difference_type;
; 566  : 	typedef typename _Val_types::pointer pointer;
; 567  : 	typedef typename _Val_types::const_pointer const_pointer;
; 568  : 	typedef typename _Val_types::reference reference;
; 569  : 	typedef typename _Val_types::const_reference const_reference;
; 570  : 
; 571  : 	typedef _List_const_iterator<_List_val<_Val_types> > const_iterator;
; 572  : 	typedef _List_iterator<_List_val<_Val_types> > iterator;
; 573  : 
; 574  : 	typedef _List_unchecked_const_iterator<_List_val<_Val_types> >
; 575  : 		_Unchecked_const_iterator;
; 576  : 	typedef _List_unchecked_iterator<_List_val<_Val_types> >
; 577  : 		_Unchecked_iterator;
; 578  : 
; 579  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 580  : 		{	// return reference to successor pointer in node
; 581  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));
; 582  : 		}
; 583  : 
; 584  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 585  : 		{	// return reference to predecessor pointer in node
; 586  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));
; 587  : 		}
; 588  : 
; 589  : 	static reference _Myval(_Nodeptr _Pnode)
; 590  : 		{	// return reference to value in node
; 591  : 		return (_List_val<_Val_types>::_Myval(_Pnode));
; 592  : 		}
; 593  : 
; 594  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 595  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 596  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 597  : 		{	// construct head node, allocator from _Al
; 598  : 		_Myhead() = _Buyheadnode();

  00033	89 06		 mov	 DWORD PTR [esi], eax
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 133  : 	for ( int i =0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )

  00035	33 ff		 xor	 edi, edi
  00037	c6 83 64 10 00
	00 00		 mov	 BYTE PTR [ebx+4196], 0
  0003e	8d b3 40 01 00
	00		 lea	 esi, DWORD PTR [ebx+320]
  00044	c7 83 68 10 00
	00 0a 00 00 00	 mov	 DWORD PTR [ebx+4200], 10 ; 0000000aH
  0004e	c7 83 74 10 00
	00 64 00 00 00	 mov	 DWORD PTR [ebx+4212], 100 ; 00000064H
  00058	c7 83 78 10 00
	00 b0 04 00 00	 mov	 DWORD PTR [ebx+4216], 1200 ; 000004b0H
  00062	c7 83 7c 10 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+4220], 0
  0006c	0f 1f 40 00	 npad	 4
$LL4@CBloodCast:

; 134  : 	{
; 135  : 		this->m_BridgeData[i].m_iBC_STATE = BC_STATE_NONE;
; 136  : 		this->m_BridgeData[i].m_iMapNumber = GetEventMap(i);

  00070	57		 push	 edi
  00071	8b cb		 mov	 ecx, ebx
  00073	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0007a	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  0007f	89 06		 mov	 DWORD PTR [esi], eax

; 137  : 		this->m_BridgeData[i].m_iBridgeIndex = i;
; 138  : 		this->m_BridgeData[i].m_iBC_REMAIN_MSEC = -1;
; 139  : 		this->m_BridgeData[i].m_iBC_TICK_COUNT = -1;
; 140  : 		this->m_BridgeData[i].m_nSaintStatuePosNum = -1;
; 141  : 		this->m_BridgeData[i].m_nCastleDoorPosNum = -1;
; 142  : 		this->m_BridgeData[i].m_iAngelKingPosNum = -1;
; 143  : 		this->m_BridgeData[i].m_iBC_REWARD_MULTIPLY = 1.0f;
; 144  : 		this->m_BridgeData[i].m_iBC_CASTLE_BLOCKINFO = 1000;
; 145  : 		InitializeCriticalSection(&this->m_BridgeData[i].m_critUserData);

  00081	8d 86 c4 fe ff
	ff		 lea	 eax, DWORD PTR [esi-316]
  00087	50		 push	 eax
  00088	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0008b	c7 46 14 ff ff
	ff ff		 mov	 DWORD PTR [esi+20], -1
  00092	c7 46 18 ff ff
	ff ff		 mov	 DWORD PTR [esi+24], -1
  00099	c7 46 f4 ff ff
	ff ff		 mov	 DWORD PTR [esi-12], -1
  000a0	c7 46 f8 ff ff
	ff ff		 mov	 DWORD PTR [esi-8], -1
  000a7	c7 46 5c ff ff
	ff ff		 mov	 DWORD PTR [esi+92], -1
  000ae	c7 86 c8 00 00
	00 00 00 80 3f	 mov	 DWORD PTR [esi+200], 1065353216 ; 3f800000H
  000b8	c7 86 cc 00 00
	00 e8 03 00 00	 mov	 DWORD PTR [esi+204], 1000 ; 000003e8H
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 146  : 		this->ClearBridgeData(i);

  000c8	57		 push	 edi
  000c9	8b cb		 mov	 ecx, ebx
  000cb	e8 00 00 00 00	 call	 ?ClearBridgeData@CBloodCastle@@IAEXH@Z ; CBloodCastle::ClearBridgeData
  000d0	47		 inc	 edi
  000d1	8d b6 0c 02 00
	00		 lea	 esi, DWORD PTR [esi+524]
  000d7	83 ff 08	 cmp	 edi, 8
  000da	7c 94		 jl	 SHORT $LL4@CBloodCast

; 147  : 	}
; 148  : }

  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	8b c3		 mov	 eax, ebx
  000e0	5b		 pop	 ebx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
??0CBloodCastle@@QAE@XZ ENDP				; CBloodCastle::CBloodCastle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetPlayUserCountRightNow@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetPlayUserCountRightNow@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetPlayUserCountRightNow, COMDAT
; _this$ = ecx

; 4548 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4549 : 	if( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 7b		 js	 SHORT $LN23@GetPlayUse
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 6f		 je	 SHORT $LN23@GetPlayUse

; 4551 : 
; 4552 : 	int nReallyPlayUserCount = 0;

  00016	53		 push	 ebx
  00017	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001d	56		 push	 esi
  0001e	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  00024	33 f6		 xor	 esi, esi
  00026	8d 51 1c	 lea	 edx, DWORD PTR [ecx+28]
  00029	57		 push	 edi
  0002a	8d 7e 0a	 lea	 edi, DWORD PTR [esi+10]
  0002d	03 d0		 add	 edx, eax
  0002f	90		 npad	 1
$LL4@GetPlayUse:

; 4556 : 	{
; 4557 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00030	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 4558 : 
; 4559 : 		if( !OBJMAX_RANGE(iIndex) )

  00032	85 c9		 test	 ecx, ecx
  00034	78 3e		 js	 SHORT $LN2@GetPlayUse
  00036	33 c0		 xor	 eax, eax
  00038	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0003e	0f 9e c0	 setle	 al
  00041	85 c0		 test	 eax, eax
  00043	74 2f		 je	 SHORT $LN2@GetPlayUse

; 4560 : 			continue;
; 4561 : 
; 4562 : 		if( !BC_MAP_RANGE(gObj[iIndex].MapNumber) )

  00045	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  0004b	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  0004e	8a 81 23 01 00
	00		 mov	 al, BYTE PTR [ecx+291]
  00054	3c 34		 cmp	 al, 52			; 00000034H
  00056	74 0f		 je	 SHORT $LN24@GetPlayUse
  00058	3c 0b		 cmp	 al, 11			; 0000000bH
  0005a	72 18		 jb	 SHORT $LN2@GetPlayUse
  0005c	b4 11		 mov	 ah, 17			; 00000011H
  0005e	3a e0		 cmp	 ah, al
  00060	1b c0		 sbb	 eax, eax
  00062	83 c0 01	 add	 eax, 1
  00065	74 0d		 je	 SHORT $LN2@GetPlayUse
$LN24@GetPlayUse:

; 4563 : 			continue;
; 4564 : 
; 4565 : 
; 4566 : 		if( gObj[iIndex].Type != OBJ_USER )

  00067	80 79 50 01	 cmp	 BYTE PTR [ecx+80], 1
  0006b	75 07		 jne	 SHORT $LN2@GetPlayUse

; 4567 : 			continue;
; 4568 : 
; 4569 : 		if( gObj[iIndex].Connected == PLAYER_PLAYING )

  0006d	83 79 04 03	 cmp	 DWORD PTR [ecx+4], 3
  00071	75 01		 jne	 SHORT $LN2@GetPlayUse

; 4570 : 		{
; 4571 : 			nReallyPlayUserCount++;

  00073	46		 inc	 esi
$LN2@GetPlayUse:

; 4553 : 
; 4554 : 
; 4555 : 	for(int i = 0; i < MAX_BLOOD_CASTLE_SUB_BRIDGE; i++)

  00074	83 c2 14	 add	 edx, 20			; 00000014H
  00077	83 ef 01	 sub	 edi, 1
  0007a	75 b4		 jne	 SHORT $LL4@GetPlayUse

; 4572 : 		}
; 4573 : 	}
; 4574 : return nReallyPlayUserCount;

  0007c	5f		 pop	 edi
  0007d	8b c6		 mov	 eax, esi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx

; 4575 : }

  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN23@GetPlayUse:

; 4550 : 		return -1;

  00085	83 c8 ff	 or	 eax, -1

; 4575 : }

  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?GetPlayUserCountRightNow@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetPlayUserCountRightNow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetCastleBlockInfo@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetCastleBlockInfo@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCastleBlockInfo, COMDAT
; _this$ = ecx

; 4540 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4541 : 	if( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 1c		 js	 SHORT $LN6@GetCastleB
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 10		 je	 SHORT $LN6@GetCastleB

; 4543 : 
; 4544 : 	return this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO;

  00016	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00019	69 c0 0c 02 00
	00		 imul	 eax, eax, 524
  0001f	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]

; 4545 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN6@GetCastleB:

; 4542 : 		return false;

  00026	33 c0		 xor	 eax, eax

; 4545 : }

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?GetCastleBlockInfo@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCastleBlockInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetCastleBlockInfo@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iCastleBlockInfo$ = 12					; size = 4
?SetCastleBlockInfo@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::SetCastleBlockInfo, COMDAT
; _this$ = ecx

; 4528 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4529 : 	if( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	78 35		 js	 SHORT $LN9@SetCastleB
  0000d	33 c0		 xor	 eax, eax
  0000f	83 fa 07	 cmp	 edx, 7
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 29		 je	 SHORT $LN9@SetCastleB

; 4531 : 
; 4532 : 	if( !BC_BLOCKINFO(iCastleBlockInfo) )

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR _iCastleBlockInfo$[ebp]
  0001c	85 c9		 test	 ecx, ecx
  0001e	78 22		 js	 SHORT $LN9@SetCastleB
  00020	33 c0		 xor	 eax, eax
  00022	83 f9 08	 cmp	 ecx, 8
  00025	0f 9e c0	 setle	 al
  00028	85 c0		 test	 eax, eax
  0002a	74 16		 je	 SHORT $LN9@SetCastleB

; 4533 : 		return false;
; 4534 : 
; 4535 : 	this->m_BridgeData[iBridgeIndex].m_iBC_CASTLE_BLOCKINFO = iCastleBlockInfo;

  0002c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0002f	69 c0 0c 02 00
	00		 imul	 eax, eax, 524
  00035	89 0c 30	 mov	 DWORD PTR [eax+esi], ecx

; 4536 : 	return true;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	5e		 pop	 esi

; 4537 : }

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN9@SetCastleB:

; 4530 : 		return false;

  00042	33 c0		 xor	 eax, eax
  00044	5e		 pop	 esi

; 4537 : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?SetCastleBlockInfo@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::SetCastleBlockInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SendNoticeMessageToSpecificUser@CBloodCastle@@QAEXHHH@Z
_TEXT	SEGMENT
tv417 = -24						; size = 4
_pMsg$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
_iPlayState$ = 16					; size = 4
?SendNoticeMessageToSpecificUser@CBloodCastle@@QAEXHHH@Z PROC ; CBloodCastle::SendNoticeMessageToSpecificUser, COMDAT
; _this$ = ecx

; 4487 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]

; 4488 : 	PMSG_STATEBLOODCASTLE pMsg;
; 4489 : 	PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  00015	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00018	57		 push	 edi
  00019	6a 0e		 push	 14			; 0000000eH
  0001b	68 9b 00 00 00	 push	 155			; 0000009bH
  00020	50		 push	 eax
  00021	8b d9		 mov	 ebx, ecx
  00023	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 4490 : 
; 4491 : 	pMsg.btPlayState = iPlayState;

  00028	8b 4d 10	 mov	 ecx, DWORD PTR _iPlayState$[ebp]

; 4492 : 	pMsg.wRemainSec = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  0002b	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00030	69 f6 0c 02 00
	00		 imul	 esi, esi, 524
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0003c	89 75 e8	 mov	 DWORD PTR tv417[ebp], esi
  0003f	f7 ac 1e 54 01
	00 00		 imul	 DWORD PTR [esi+ebx+340]
  00046	c1 fa 06	 sar	 edx, 6
  00049	8b c2		 mov	 eax, edx
  0004b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004e	03 c2		 add	 eax, edx
  00050	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4493 : 
; 4494 : 	if ( iPlayState == 4 )

  00054	83 f9 04	 cmp	 ecx, 4
  00057	75 16		 jne	 SHORT $LN5@SendNotice

; 4495 : 	{
; 4496 : 		pMsg.wMaxKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT;

  00059	0f b7 84 1e 84
	01 00 00	 movzx	 eax, WORD PTR [esi+ebx+388]
  00061	66 89 45 f2	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 4497 : 		pMsg.wCurKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT;

  00065	0f b7 84 1e 88
	01 00 00	 movzx	 eax, WORD PTR [esi+ebx+392]

; 4498 : 	}
; 4499 : 	else

  0006d	eb 14		 jmp	 SHORT $LN18@SendNotice
$LN5@SendNotice:

; 4500 : 	{
; 4501 : 		pMsg.wMaxKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT;

  0006f	0f b7 84 1e 74
	01 00 00	 movzx	 eax, WORD PTR [esi+ebx+372]
  00077	66 89 45 f2	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 4502 : 		pMsg.wCurKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT;

  0007b	0f b7 84 1e 78
	01 00 00	 movzx	 eax, WORD PTR [esi+ebx+376]
$LN18@SendNotice:

; 4503 : 	}
; 4504 : 
; 4505 : 	pMsg.wUserHaveWeapon = this->m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX;

  00083	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00089	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  0008c	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+8], ax

; 4506 : 	pMsg.btWeaponNum = this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER + 1;
; 4507 : 
; 4508 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00090	33 c9		 xor	 ecx, ecx
  00092	66 8b 84 1e 94
	01 00 00	 mov	 ax, WORD PTR [esi+ebx+404]
  0009a	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+10], ax
  0009e	8a 84 1e 98 01
	00 00		 mov	 al, BYTE PTR [esi+ebx+408]
  000a5	8b 75 0c	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  000a8	fe c0		 inc	 al
  000aa	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  000ad	03 d3		 add	 edx, ebx
  000af	90		 npad	 1
$LL4@SendNotice:

; 4509 : 	{
; 4510 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iUserIndex )

  000b0	8b 02		 mov	 eax, DWORD PTR [edx]
  000b2	3b c6		 cmp	 eax, esi
  000b4	75 21		 jne	 SHORT $LN2@SendNotice

; 4511 : 		{
; 4512 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000b6	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000bc	83 7c 38 04 02	 cmp	 DWORD PTR [eax+edi+4], 2
  000c1	7e 14		 jle	 SHORT $LN2@SendNotice

; 4513 : 			{
; 4514 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  000c3	80 bc 38 36 12
	00 00 ff	 cmp	 BYTE PTR [eax+edi+4662], -1
  000cb	74 0a		 je	 SHORT $LN2@SendNotice

; 4515 : 				{
; 4516 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  000cd	80 bc 38 37 12
	00 00 ff	 cmp	 BYTE PTR [eax+edi+4663], -1
  000d5	75 1c		 jne	 SHORT $LN13@SendNotice
$LN2@SendNotice:

; 4506 : 	pMsg.btWeaponNum = this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER + 1;
; 4507 : 
; 4508 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000d7	41		 inc	 ecx
  000d8	83 c2 14	 add	 edx, 20			; 00000014H
  000db	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000de	7c d0		 jl	 SHORT $LL4@SendNotice
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx

; 4519 : 						break;
; 4520 : 					}
; 4521 : 				}
; 4522 : 			}
; 4523 : 		}
; 4524 : 	}
; 4525 : }

  000e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e6	33 cd		 xor	 ecx, ebp
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH
$LN13@SendNotice:

; 4517 : 					{
; 4518 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR *)&pMsg, pMsg.h.size);

  000f3	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000f7	50		 push	 eax
  000f8	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000fb	50		 push	 eax
  000fc	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000ff	8b 4d e8	 mov	 ecx, DWORD PTR tv417[ebp]
  00102	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00105	ff 74 18 1c	 push	 DWORD PTR [eax+ebx+28]
  00109	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4519 : 						break;
; 4520 : 					}
; 4521 : 				}
; 4522 : 			}
; 4523 : 		}
; 4524 : 	}
; 4525 : }

  0010e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH
  00114	33 cd		 xor	 ecx, ebp
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 0c 00	 ret	 12			; 0000000cH
?SendNoticeMessageToSpecificUser@CBloodCastle@@QAEXHHH@Z ENDP ; CBloodCastle::SendNoticeMessageToSpecificUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ChangeUserIndex@CBloodCastle@@QAEHHHH@Z
_TEXT	SEGMENT
_iExUserIndex$ = 8					; size = 4
_iCurrentUserIndex$ = 12				; size = 4
_iBridgeIndex$ = 16					; size = 4
?ChangeUserIndex@CBloodCastle@@QAEHHHH@Z PROC		; CBloodCastle::ChangeUserIndex, COMDAT
; _this$ = ecx

; 4467 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4468 : 	if( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 55 10	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	78 67		 js	 SHORT $LN15@ChangeUser
  0000d	33 c0		 xor	 eax, eax
  0000f	83 fa 07	 cmp	 edx, 7
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 5b		 je	 SHORT $LN15@ChangeUser

; 4470 : 
; 4471 : 	EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00019	53		 push	 ebx
  0001a	69 da 0c 02 00
	00		 imul	 ebx, edx, 524
  00020	56		 push	 esi
  00021	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  00024	03 f3		 add	 esi, ebx
  00026	56		 push	 esi
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0002d	8b 55 08	 mov	 edx, DWORD PTR _iExUserIndex$[ebp]
  00030	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]

; 4472 : 
; 4473 : 	for(int i = 0; i < MAX_BLOOD_CASTLE_SUB_BRIDGE; i++)

  00033	33 c0		 xor	 eax, eax
  00035	03 cb		 add	 ecx, ebx
$LL4@ChangeUser:

; 4474 : 	{
; 4475 : 		if( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iExUserIndex )

  00037	39 11		 cmp	 DWORD PTR [ecx], edx
  00039	74 19		 je	 SHORT $LN11@ChangeUser

; 4472 : 
; 4473 : 	for(int i = 0; i < MAX_BLOOD_CASTLE_SUB_BRIDGE; i++)

  0003b	40		 inc	 eax
  0003c	83 c1 14	 add	 ecx, 20			; 00000014H
  0003f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00042	7c f3		 jl	 SHORT $LL4@ChangeUser

; 4480 : 		}
; 4481 : 	}
; 4482 : 	LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00044	56		 push	 esi
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx

; 4483 : 	return false;

  0004d	33 c0		 xor	 eax, eax
  0004f	5f		 pop	 edi

; 4484 : }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN11@ChangeUser:

; 4476 : 		{
; 4477 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = iCurrentUserIndex;

  00054	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00057	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _iCurrentUserIndex$[ebp]

; 4478 : 			LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  0005d	56		 push	 esi
  0005e	89 44 39 1c	 mov	 DWORD PTR [ecx+edi+28], eax
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 4479 : 			return true;

  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	5f		 pop	 edi

; 4484 : }

  00070	5d		 pop	 ebp
  00071	c2 0c 00	 ret	 12			; 0000000cH
$LN15@ChangeUser:

; 4469 : 		return false;

  00074	33 c0		 xor	 eax, eax
  00076	5f		 pop	 edi

; 4484 : }

  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
?ChangeUserIndex@CBloodCastle@@QAEHHHH@Z ENDP		; CBloodCastle::ChangeUserIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetRewardMap@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iRetMap$ = 8						; size = 4
?GetRewardMap@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetRewardMap, COMDAT
; _this$ = ecx

; 4449 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4450 : 	int MapNumber = iRetMap;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iRetMap$[ebp]

; 4451 : 
; 4452 : 	switch( iRetMap )

  00006	8d 88 0a ff ff
	ff		 lea	 ecx, DWORD PTR [eax-246]
  0000c	83 f9 07	 cmp	 ecx, 7
  0000f	77 4b		 ja	 SHORT $LN2@GetRewardM
  00011	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN14@GetRewardM[ecx*4]
$LN4@GetRewardM:

; 4453 : 	{
; 4454 : 	case 246:	MapNumber = 11;	break;

  00018	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH

; 4462 : 	}
; 4463 : return MapNumber;
; 4464 : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN5@GetRewardM:

; 4455 : 	case 247:	MapNumber = 12;	break;

  00021	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 4462 : 	}
; 4463 : return MapNumber;
; 4464 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN6@GetRewardM:

; 4456 : 	case 248:	MapNumber = 13;	break;

  0002a	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 4462 : 	}
; 4463 : return MapNumber;
; 4464 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN7@GetRewardM:

; 4457 : 	case 249:	MapNumber = 14;	break;

  00033	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 4462 : 	}
; 4463 : return MapNumber;
; 4464 : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN8@GetRewardM:

; 4458 : 	case 250:	MapNumber = 15;	break;

  0003c	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH

; 4462 : 	}
; 4463 : return MapNumber;
; 4464 : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN9@GetRewardM:

; 4459 : 	case 251:	MapNumber = 16;	break;

  00045	b8 10 00 00 00	 mov	 eax, 16			; 00000010H

; 4462 : 	}
; 4463 : return MapNumber;
; 4464 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN10@GetRewardM:

; 4460 : 	case 252:	MapNumber = 17;	break;

  0004e	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 4462 : 	}
; 4463 : return MapNumber;
; 4464 : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN11@GetRewardM:

; 4461 : 	case 253:	MapNumber = 52;	break;

  00057	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN2@GetRewardM:

; 4462 : 	}
; 4463 : return MapNumber;
; 4464 : }

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN14@GetRewardM:
  00060	00 00 00 00	 DD	 $LN4@GetRewardM
  00064	00 00 00 00	 DD	 $LN5@GetRewardM
  00068	00 00 00 00	 DD	 $LN6@GetRewardM
  0006c	00 00 00 00	 DD	 $LN7@GetRewardM
  00070	00 00 00 00	 DD	 $LN8@GetRewardM
  00074	00 00 00 00	 DD	 $LN9@GetRewardM
  00078	00 00 00 00	 DD	 $LN10@GetRewardM
  0007c	00 00 00 00	 DD	 $LN11@GetRewardM
?GetRewardMap@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetRewardMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetItemMap@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iRetMap$ = 8						; size = 4
?GetItemMap@CBloodCastle@@QAEHH@Z PROC			; CBloodCastle::GetItemMap, COMDAT
; _this$ = ecx

; 4431 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4432 : 	int MapNumber = iRetMap;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iRetMap$[ebp]

; 4433 : 
; 4434 : 	switch( iRetMap )

  00006	8d 88 12 ff ff
	ff		 lea	 ecx, DWORD PTR [eax-238]
  0000c	83 f9 07	 cmp	 ecx, 7
  0000f	77 4b		 ja	 SHORT $LN2@GetItemMap
  00011	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN14@GetItemMap[ecx*4]
$LN4@GetItemMap:

; 4435 : 	{
; 4436 : 	case 238:	MapNumber = 11;	break;

  00018	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH

; 4444 : 	}
; 4445 : return MapNumber;
; 4446 : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN5@GetItemMap:

; 4437 : 	case 239:	MapNumber = 12;	break;

  00021	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 4444 : 	}
; 4445 : return MapNumber;
; 4446 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN6@GetItemMap:

; 4438 : 	case 240:	MapNumber = 13;	break;

  0002a	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 4444 : 	}
; 4445 : return MapNumber;
; 4446 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN7@GetItemMap:

; 4439 : 	case 241:	MapNumber = 14;	break;

  00033	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 4444 : 	}
; 4445 : return MapNumber;
; 4446 : }

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
$LN8@GetItemMap:

; 4440 : 	case 242:	MapNumber = 15;	break;

  0003c	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH

; 4444 : 	}
; 4445 : return MapNumber;
; 4446 : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN9@GetItemMap:

; 4441 : 	case 243:	MapNumber = 16;	break;

  00045	b8 10 00 00 00	 mov	 eax, 16			; 00000010H

; 4444 : 	}
; 4445 : return MapNumber;
; 4446 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN10@GetItemMap:

; 4442 : 	case 244:	MapNumber = 17;	break;

  0004e	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 4444 : 	}
; 4445 : return MapNumber;
; 4446 : }

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN11@GetItemMap:

; 4443 : 	case 245:	MapNumber = 52;	break;

  00057	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN2@GetItemMap:

; 4444 : 	}
; 4445 : return MapNumber;
; 4446 : }

  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
$LN14@GetItemMap:
  00060	00 00 00 00	 DD	 $LN4@GetItemMap
  00064	00 00 00 00	 DD	 $LN5@GetItemMap
  00068	00 00 00 00	 DD	 $LN6@GetItemMap
  0006c	00 00 00 00	 DD	 $LN7@GetItemMap
  00070	00 00 00 00	 DD	 $LN8@GetItemMap
  00074	00 00 00 00	 DD	 $LN9@GetItemMap
  00078	00 00 00 00	 DD	 $LN10@GetItemMap
  0007c	00 00 00 00	 DD	 $LN11@GetItemMap
?GetItemMap@CBloodCastle@@QAEHH@Z ENDP			; CBloodCastle::GetItemMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetBridgeLevel@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iMapNumber$ = 8					; size = 4
?GetBridgeLevel@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetBridgeLevel, COMDAT
; _this$ = ecx

; 4413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4414 : 	int iLevel = -1;
; 4415 : 
; 4416 : 	switch( iMapNumber )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  00006	83 c9 ff	 or	 ecx, -1
  00009	83 c0 f5	 add	 eax, -11		; fffffff5H
  0000c	83 f8 29	 cmp	 eax, 41			; 00000029H
  0000f	77 5d		 ja	 SHORT $LN2@GetBridgeL
  00011	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN13@GetBridgeL[eax]
  00018	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN15@GetBridgeL[eax*4]
$LN4@GetBridgeL:

; 4417 : 	{
; 4418 : 	case 11:	iLevel = 0; break;

  0001f	33 c9		 xor	 ecx, ecx

; 4426 : 	}
; 4427 : return iLevel;

  00021	8b c1		 mov	 eax, ecx

; 4428 : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN5@GetBridgeL:

; 4419 : 	case 12:	iLevel = 1; break;

  00027	b9 01 00 00 00	 mov	 ecx, 1

; 4426 : 	}
; 4427 : return iLevel;

  0002c	8b c1		 mov	 eax, ecx

; 4428 : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN6@GetBridgeL:

; 4420 : 	case 13:	iLevel = 2; break;

  00032	b9 02 00 00 00	 mov	 ecx, 2

; 4426 : 	}
; 4427 : return iLevel;

  00037	8b c1		 mov	 eax, ecx

; 4428 : }

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN7@GetBridgeL:

; 4421 : 	case 14:	iLevel = 3; break;

  0003d	b9 03 00 00 00	 mov	 ecx, 3

; 4426 : 	}
; 4427 : return iLevel;

  00042	8b c1		 mov	 eax, ecx

; 4428 : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN8@GetBridgeL:

; 4422 : 	case 15:	iLevel = 4; break;

  00048	b9 04 00 00 00	 mov	 ecx, 4

; 4426 : 	}
; 4427 : return iLevel;

  0004d	8b c1		 mov	 eax, ecx

; 4428 : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
$LN9@GetBridgeL:

; 4423 : 	case 16:	iLevel = 5; break;

  00053	b9 05 00 00 00	 mov	 ecx, 5

; 4426 : 	}
; 4427 : return iLevel;

  00058	8b c1		 mov	 eax, ecx

; 4428 : }

  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN10@GetBridgeL:

; 4424 : 	case 17:	iLevel = 6; break;

  0005e	b9 06 00 00 00	 mov	 ecx, 6

; 4426 : 	}
; 4427 : return iLevel;

  00063	8b c1		 mov	 eax, ecx

; 4428 : }

  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
$LN11@GetBridgeL:

; 4425 : 	case 52:	iLevel = 7; break;

  00069	b9 07 00 00 00	 mov	 ecx, 7
$LN2@GetBridgeL:

; 4426 : 	}
; 4427 : return iLevel;

  0006e	8b c1		 mov	 eax, ecx

; 4428 : }

  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN15@GetBridgeL:
  00074	00 00 00 00	 DD	 $LN4@GetBridgeL
  00078	00 00 00 00	 DD	 $LN5@GetBridgeL
  0007c	00 00 00 00	 DD	 $LN6@GetBridgeL
  00080	00 00 00 00	 DD	 $LN7@GetBridgeL
  00084	00 00 00 00	 DD	 $LN8@GetBridgeL
  00088	00 00 00 00	 DD	 $LN9@GetBridgeL
  0008c	00 00 00 00	 DD	 $LN10@GetBridgeL
  00090	00 00 00 00	 DD	 $LN11@GetBridgeL
  00094	00 00 00 00	 DD	 $LN2@GetBridgeL
$LN13@GetBridgeL:
  00098	00		 DB	 0
  00099	01		 DB	 1
  0009a	02		 DB	 2
  0009b	03		 DB	 3
  0009c	04		 DB	 4
  0009d	05		 DB	 5
  0009e	06		 DB	 6
  0009f	08		 DB	 8
  000a0	08		 DB	 8
  000a1	08		 DB	 8
  000a2	08		 DB	 8
  000a3	08		 DB	 8
  000a4	08		 DB	 8
  000a5	08		 DB	 8
  000a6	08		 DB	 8
  000a7	08		 DB	 8
  000a8	08		 DB	 8
  000a9	08		 DB	 8
  000aa	08		 DB	 8
  000ab	08		 DB	 8
  000ac	08		 DB	 8
  000ad	08		 DB	 8
  000ae	08		 DB	 8
  000af	08		 DB	 8
  000b0	08		 DB	 8
  000b1	08		 DB	 8
  000b2	08		 DB	 8
  000b3	08		 DB	 8
  000b4	08		 DB	 8
  000b5	08		 DB	 8
  000b6	08		 DB	 8
  000b7	08		 DB	 8
  000b8	08		 DB	 8
  000b9	08		 DB	 8
  000ba	08		 DB	 8
  000bb	08		 DB	 8
  000bc	08		 DB	 8
  000bd	08		 DB	 8
  000be	08		 DB	 8
  000bf	08		 DB	 8
  000c0	08		 DB	 8
  000c1	07		 DB	 7
?GetBridgeLevel@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetBridgeLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetEventMap@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetEventMap@CBloodCastle@@QAEHH@Z PROC			; CBloodCastle::GetEventMap, COMDAT
; _this$ = ecx

; 4394 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4395 : 	int iMap = 0;
; 4396 : 
; 4397 : 	switch( iBridgeIndex )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	83 f9 07	 cmp	 ecx, 7
  0000b	77 4b		 ja	 SHORT $LN2@GetEventMa
  0000d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN14@GetEventMa[ecx*4]
$LN4@GetEventMa:

; 4398 : 	{
; 4399 : 	case 0:	iMap = 11;	break;

  00014	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH

; 4407 : 	}
; 4408 : 
; 4409 : return iMap;
; 4410 : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN5@GetEventMa:

; 4400 : 	case 1:	iMap = 12;	break;

  0001d	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 4407 : 	}
; 4408 : 
; 4409 : return iMap;
; 4410 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN6@GetEventMa:

; 4401 : 	case 2:	iMap = 13;	break;

  00026	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH

; 4407 : 	}
; 4408 : 
; 4409 : return iMap;
; 4410 : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN7@GetEventMa:

; 4402 : 	case 3:	iMap = 14;	break;

  0002f	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 4407 : 	}
; 4408 : 
; 4409 : return iMap;
; 4410 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN8@GetEventMa:

; 4403 : 	case 4:	iMap = 15;	break;

  00038	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH

; 4407 : 	}
; 4408 : 
; 4409 : return iMap;
; 4410 : }

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN9@GetEventMa:

; 4404 : 	case 5:	iMap = 16;	break;

  00041	b8 10 00 00 00	 mov	 eax, 16			; 00000010H

; 4407 : 	}
; 4408 : 
; 4409 : return iMap;
; 4410 : }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN10@GetEventMa:

; 4405 : 	case 6:	iMap = 17;	break;

  0004a	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 4407 : 	}
; 4408 : 
; 4409 : return iMap;
; 4410 : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
$LN11@GetEventMa:

; 4406 : 	case 7:	iMap = 52;	break;

  00053	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN2@GetEventMa:

; 4407 : 	}
; 4408 : 
; 4409 : return iMap;
; 4410 : }

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN14@GetEventMa:
  0005c	00 00 00 00	 DD	 $LN4@GetEventMa
  00060	00 00 00 00	 DD	 $LN5@GetEventMa
  00064	00 00 00 00	 DD	 $LN6@GetEventMa
  00068	00 00 00 00	 DD	 $LN7@GetEventMa
  0006c	00 00 00 00	 DD	 $LN8@GetEventMa
  00070	00 00 00 00	 DD	 $LN9@GetEventMa
  00074	00 00 00 00	 DD	 $LN10@GetEventMa
  00078	00 00 00 00	 DD	 $LN11@GetEventMa
?GetEventMap@CBloodCastle@@QAEHH@Z ENDP			; CBloodCastle::GetEventMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iBC_STATE$ = 12					; size = 4
?SetState@CBloodCastle@@QAEXHH@Z PROC			; CBloodCastle::SetState, COMDAT
; _this$ = ecx

; 561  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 562  : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	78 54		 js	 SHORT $LN6@SetState
  0000b	33 c0		 xor	 eax, eax
  0000d	83 fa 07	 cmp	 edx, 7
  00010	0f 9e c0	 setle	 al
  00013	85 c0		 test	 eax, eax
  00015	74 48		 je	 SHORT $LN6@SetState

; 563  : 	{
; 564  : 		return;
; 565  : 	}
; 566  : 
; 567  : 	if ( iBC_STATE < BC_STATE_NONE || iBC_STATE > BC_STATE_PLAYEND )

  00017	8b 75 0c	 mov	 esi, DWORD PTR _iBC_STATE$[ebp]
  0001a	83 fe 03	 cmp	 esi, 3
  0001d	77 40		 ja	 SHORT $LN6@SetState

; 568  : 	{
; 569  : 		return;
; 570  : 	}
; 571  : 
; 572  : 	this->m_BridgeData[iBridgeIndex].m_iBC_STATE = iBC_STATE;

  0001f	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  00025	89 b4 08 50 01
	00 00		 mov	 DWORD PTR [eax+ecx+336], esi

; 573  : 
; 574  : 	switch ( this->m_BridgeData[iBridgeIndex].m_iBC_STATE )

  0002c	83 fe 03	 cmp	 esi, 3
  0002f	77 2e		 ja	 SHORT $LN6@SetState
  00031	ff 24 b5 00 00
	00 00		 jmp	 DWORD PTR $LN15@SetState[esi*4]
$LN7@SetState:

; 575  : 	{
; 576  : 		case BC_STATE_NONE:
; 577  : 			this->SetState_None(iBridgeIndex);

  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ?SetState_None@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_None
  0003e	5e		 pop	 esi

; 590  : 			break;
; 591  : 	}
; 592  : }

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
$LN8@SetState:

; 578  : 			break;
; 579  : 
; 580  : 		case BC_STATE_CLOSED:
; 581  : 			this->SetState_Closed(iBridgeIndex);

  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ?SetState_Closed@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_Closed
  00049	5e		 pop	 esi

; 590  : 			break;
; 591  : 	}
; 592  : }

  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN9@SetState:

; 582  : 			break;
; 583  : 
; 584  : 		case BC_STATE_PLAYING:
; 585  : 			this->SetState_Playing(iBridgeIndex);

  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 ?SetState_Playing@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_Playing
  00054	5e		 pop	 esi

; 590  : 			break;
; 591  : 	}
; 592  : }

  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
$LN10@SetState:

; 586  : 			break;
; 587  : 
; 588  : 		case BC_STATE_PLAYEND:
; 589  : 			this->SetState_PlayEnd(iBridgeIndex);

  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?SetState_PlayEnd@CBloodCastle@@IAEXH@Z ; CBloodCastle::SetState_PlayEnd
$LN6@SetState:
  0005f	5e		 pop	 esi

; 590  : 			break;
; 591  : 	}
; 592  : }

  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
$LN15@SetState:
  00064	00 00 00 00	 DD	 $LN7@SetState
  00068	00 00 00 00	 DD	 $LN8@SetState
  0006c	00 00 00 00	 DD	 $LN9@SetState
  00070	00 00 00 00	 DD	 $LN10@SetState
?SetState@CBloodCastle@@QAEXHH@Z ENDP			; CBloodCastle::SetState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?LoadItemDropRate@CBloodCastle@@QAEXXZ
_TEXT	SEGMENT
?LoadItemDropRate@CBloodCastle@@QAEXXZ PROC		; CBloodCastle::LoadItemDropRate, COMDAT
; _this$ = ecx

; 366  : {

  00000	56		 push	 esi

; 367  : 	g_bBloodCastle=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "BloodCastleEvent", 0, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0000b	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00010	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetPrivateProfileIntA@16
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DHAFCNAC@BloodCastleEvent?$AA@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00023	ff d6		 call	 esi

; 368  : 	g_iAngelKingsPaperDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "AngelKingsPaperDropRate", 0, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0002f	a3 00 00 00 00	 mov	 DWORD PTR ?g_bBloodCastle@@3HA, eax ; g_bBloodCastle
  00034	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00039	50		 push	 eax
  0003a	6a 00		 push	 0
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@KPDDGOOE@AngelKingsPaperDropRate?$AA@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00046	ff d6		 call	 esi

; 369  : 	g_iBloodBoneDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "BloodBoneDropRate", 0, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?g_iAngelKingsPaperDropRate@@3HA, eax ; g_iAngelKingsPaperDropRate
  00057	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NGLLHLOE@BloodBoneDropRate?$AA@
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00069	ff d6		 call	 esi

; 370  : 	g_iStoneDropRate=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "StoneDropRate", 0, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00075	a3 00 00 00 00	 mov	 DWORD PTR ?g_iBloodBoneDropRate@@3HA, eax ; g_iBloodBoneDropRate
  0007a	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0007f	50		 push	 eax
  00080	6a 00		 push	 0
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PBCFFJJH@StoneDropRate?$AA@
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0008c	ff d6		 call	 esi

; 371  : 	g_bStoneItemDrop=GetPrivateProfileInt(COMMONSERVER_MAINSECTION, "StoneItemDrop", 0, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00093	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00098	a3 00 00 00 00	 mov	 DWORD PTR ?g_iStoneDropRate@@3HA, eax ; g_iStoneDropRate
  0009d	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  000a2	50		 push	 eax
  000a3	6a 00		 push	 0
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FHPHMJJK@StoneItemDrop?$AA@
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  000af	ff d6		 call	 esi
  000b1	a3 00 00 00 00	 mov	 DWORD PTR ?g_bStoneItemDrop@@3HA, eax ; g_bStoneItemDrop
  000b6	5e		 pop	 esi

; 372  : }

  000b7	c3		 ret	 0
?LoadItemDropRate@CBloodCastle@@QAEXXZ ENDP		; CBloodCastle::LoadItemDropRate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?Load@CBloodCastle@@QAEXPAD@Z
_TEXT	SEGMENT
_pTmp$1 = -12						; size = 8
_type$1$ = -4						; size = 4
_filename$ = 8						; size = 4
?Load@CBloodCastle@@QAEXPAD@Z PROC			; CBloodCastle::Load, COMDAT
; _this$ = ecx

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 230  : 	int Token;
; 231  : 	int type;
; 232  : 	int BridgeCount;
; 233  : 	int iBridgeNum;
; 234  : 	SMDFile=fopen(filename, "r");

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _filename$[ebp]
  0000a	57		 push	 edi
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00010	53		 push	 ebx
  00011	8b f9		 mov	 edi, ecx
  00013	e8 00 00 00 00	 call	 _fopen
  00018	83 c4 08	 add	 esp, 8
  0001b	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax

; 235  : 
; 236  : 	if (SMDFile == 0)

  00020	85 c0		 test	 eax, eax
  00022	75 16		 jne	 SHORT $LN6@Load

; 237  : 	{
; 238  : 		MsgBox("[Blood Castle] Info file Load Fail [%s]", filename);

  00024	53		 push	 ebx
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@EIBEEFOB@?$FLBlood?5Castle?$FN?5Info?5file?5Load?5Fa@
  0002a	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0002f	83 c4 08	 add	 esp, 8
  00032	5f		 pop	 edi
  00033	5b		 pop	 ebx

; 360  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN6@Load:

; 239  : 		return;
; 240  : 	}
; 241  : 
; 242  : 	type=-1;
; 243  : 	BridgeCount=-1;
; 244  : 
; 245  : 	while ( true )
; 246  : 	{
; 247  : 		Token=GetToken();

  0003a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 248  : 
; 249  : 		if ( Token == 2 )

  0003f	83 f8 02	 cmp	 eax, 2
  00042	0f 84 eb 02 00
	00		 je	 $LN131@Load
  00048	56		 push	 esi
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Load:

; 250  : 		{
; 251  : 			break;
; 252  : 		}
; 253  : 
; 254  : 		type=(int)TokenNumber;

  00050	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00058	89 45 fc	 mov	 DWORD PTR _type$1$[ebp], eax
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@Load:

; 255  : 
; 256  : 		while ( true )
; 257  : 		{
; 258  : 			if ( type == 0 )

  00060	85 c0		 test	 eax, eax
  00062	75 75		 jne	 SHORT $LN8@Load

; 259  : 			{
; 260  : 				Token=GetToken();

  00064	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 261  : 
; 262  : 				if (strcmp("end", &TokenString[0]) == 0)

  00069	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  0006e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL136@Load:
  00073	8a 10		 mov	 dl, BYTE PTR [eax]
  00075	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00077	75 1a		 jne	 SHORT $LN137@Load
  00079	84 d2		 test	 dl, dl
  0007b	74 12		 je	 SHORT $LN138@Load
  0007d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00080	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00083	75 0e		 jne	 SHORT $LN137@Load
  00085	83 c0 02	 add	 eax, 2
  00088	83 c1 02	 add	 ecx, 2
  0008b	84 d2		 test	 dl, dl
  0008d	75 e4		 jne	 SHORT $LL136@Load
$LN138@Load:
  0008f	33 c0		 xor	 eax, eax
  00091	eb 05		 jmp	 SHORT $LN139@Load
$LN137@Load:
  00093	1b c0		 sbb	 eax, eax
  00095	83 c8 01	 or	 eax, 1
$LN139@Load:
  00098	85 c0		 test	 eax, eax
  0009a	0f 84 81 02 00
	00		 je	 $LN125@Load

; 263  : 				{
; 264  : 					break;
; 265  : 				}
; 266  : 
; 267  : 				this->m_iBC_TIME_MIN_OPEN = (int)TokenNumber;

  000a0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000a8	89 87 68 10 00
	00		 mov	 DWORD PTR [edi+4200], eax

; 268  : 
; 269  : 				Token = GetToken();

  000ae	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 270  : 				this->m_iBC_TIME_MIN_PLAY =(int)TokenNumber;

  000b3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000bb	89 87 6c 10 00
	00		 mov	 DWORD PTR [edi+4204], eax

; 271  : 
; 272  : 				Token = GetToken();

  000c1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 273  : 				this->m_iBC_TIME_MIN_REST =(int)TokenNumber;

  000c6	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000ce	89 87 70 10 00
	00		 mov	 DWORD PTR [edi+4208], eax
  000d4	8b 45 fc	 mov	 eax, DWORD PTR _type$1$[ebp]
  000d7	eb 87		 jmp	 SHORT $LL4@Load
$LN8@Load:

; 274  : 			}
; 275  : 			else if ( type == 1 )

  000d9	83 f8 01	 cmp	 eax, 1
  000dc	75 7b		 jne	 SHORT $LN11@Load

; 276  : 			{
; 277  : 				Token = GetToken();

  000de	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 278  : 
; 279  : 				if (strcmp("end", &TokenString[0]) == 0)

  000e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  000e8	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  000ed	0f 1f 00	 npad	 3
$LL140@Load:
  000f0	8a 10		 mov	 dl, BYTE PTR [eax]
  000f2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000f4	75 1a		 jne	 SHORT $LN141@Load
  000f6	84 d2		 test	 dl, dl
  000f8	74 12		 je	 SHORT $LN142@Load
  000fa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000fd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00100	75 0e		 jne	 SHORT $LN141@Load
  00102	83 c0 02	 add	 eax, 2
  00105	83 c1 02	 add	 ecx, 2
  00108	84 d2		 test	 dl, dl
  0010a	75 e4		 jne	 SHORT $LL140@Load
$LN142@Load:
  0010c	33 c0		 xor	 eax, eax
  0010e	eb 05		 jmp	 SHORT $LN143@Load
$LN141@Load:
  00110	1b c0		 sbb	 eax, eax
  00112	83 c8 01	 or	 eax, 1
$LN143@Load:
  00115	85 c0		 test	 eax, eax
  00117	0f 84 04 02 00
	00		 je	 $LN125@Load

; 280  : 				{
; 281  : 					break;
; 282  : 				}
; 283  : 
; 284  : 				this->m_iBC_NORMAL_ITEM_DROP = (int)TokenNumber;

  0011d	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00125	89 87 74 10 00
	00		 mov	 DWORD PTR [edi+4212], eax

; 285  : 
; 286  : 				Token = GetToken();

  0012b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 287  : 				this->m_iBC_EXCEL_ITEM_DROP = (int)TokenNumber;

  00130	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00138	89 87 78 10 00
	00		 mov	 DWORD PTR [edi+4216], eax

; 288  : 
; 289  : 				Token = GetToken();

  0013e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 290  : 				this->m_iBC_MONSTER_REGEN = (int)TokenNumber;

  00143	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0014b	89 87 7c 10 00
	00		 mov	 DWORD PTR [edi+4220], eax
  00151	8b 45 fc	 mov	 eax, DWORD PTR _type$1$[ebp]
  00154	e9 07 ff ff ff	 jmp	 $LL4@Load
$LN11@Load:

; 291  : 			}
; 292  : 			else if ( type == 2 )

  00159	83 f8 02	 cmp	 eax, 2
  0015c	0f 85 a0 00 00
	00		 jne	 $LN14@Load

; 293  : 			{
; 294  : 				Token = GetToken();

  00162	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 295  : 
; 296  : 				if (strcmp("end", &TokenString[0]) == 0)

  00167	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  0016c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL144@Load:
  00171	8a 10		 mov	 dl, BYTE PTR [eax]
  00173	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00175	75 1a		 jne	 SHORT $LN145@Load
  00177	84 d2		 test	 dl, dl
  00179	74 12		 je	 SHORT $LN146@Load
  0017b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0017e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00181	75 0e		 jne	 SHORT $LN145@Load
  00183	83 c0 02	 add	 eax, 2
  00186	83 c1 02	 add	 ecx, 2
  00189	84 d2		 test	 dl, dl
  0018b	75 e4		 jne	 SHORT $LL144@Load
$LN146@Load:
  0018d	33 c0		 xor	 eax, eax
  0018f	eb 05		 jmp	 SHORT $LN147@Load
$LN145@Load:
  00191	1b c0		 sbb	 eax, eax
  00193	83 c8 01	 or	 eax, 1
$LN147@Load:
  00196	85 c0		 test	 eax, eax
  00198	0f 84 83 01 00
	00		 je	 $LN125@Load

; 297  : 				{
; 298  : 					break;
; 299  : 				}
; 300  : 			
; 301  : 				iBridgeNum = (int)TokenNumber;

  0019e	f3 0f 2c 35 00
	00 00 00	 cvttss2si esi, DWORD PTR ?TokenNumber@@3MA

; 302  : 
; 303  : 				if ( BC_BRIDGE_RANGE(iBridgeNum) != FALSE )

  001a6	85 f6		 test	 esi, esi
  001a8	78 46		 js	 SHORT $LN17@Load
  001aa	33 c0		 xor	 eax, eax
  001ac	83 fe 07	 cmp	 esi, 7
  001af	0f 9e c0	 setle	 al
  001b2	85 c0		 test	 eax, eax
  001b4	74 3a		 je	 SHORT $LN17@Load

; 304  : 				{
; 305  : 					Token = GetToken();

  001b6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 306  : 					this->m_BridgeData[iBridgeNum].m_iCastleStatueHealth = TokenNumber;

  001bb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  001c3	69 f6 0c 02 00
	00		 imul	 esi, esi, 524
  001c9	f3 0f 11 84 3e
	6c 01 00 00	 movss	 DWORD PTR [esi+edi+364], xmm0

; 307  : 
; 308  : 					Token = GetToken();

  001d2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 309  : 					this->m_BridgeData[iBridgeNum].m_iCastleDoorHealth = TokenNumber;

  001d7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA

; 310  : 				}
; 311  : 				else

  001df	8b 45 fc	 mov	 eax, DWORD PTR _type$1$[ebp]
  001e2	f3 0f 11 84 3e
	70 01 00 00	 movss	 DWORD PTR [esi+edi+368], xmm0
  001eb	e9 70 fe ff ff	 jmp	 $LL4@Load
$LN17@Load:

; 312  : 				{
; 313  : 					Token = GetToken();

  001f0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
$LN22@Load:

; 314  : 					Token = GetToken();

  001f5	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 315  : 				}

  001fa	8b 45 fc	 mov	 eax, DWORD PTR _type$1$[ebp]
  001fd	e9 5e fe ff ff	 jmp	 $LL4@Load
$LN14@Load:

; 316  : 			}
; 317  : 			else if ( type == 3 )

  00202	83 f8 03	 cmp	 eax, 3
  00205	75 78		 jne	 SHORT $LN19@Load

; 318  : 			{
; 319  : 				Token = GetToken();

  00207	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 320  : 
; 321  : 				if (strcmp("end", &TokenString[0]) == 0)

  0020c	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  00211	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL148@Load:
  00216	8a 10		 mov	 dl, BYTE PTR [eax]
  00218	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0021a	75 1a		 jne	 SHORT $LN149@Load
  0021c	84 d2		 test	 dl, dl
  0021e	74 12		 je	 SHORT $LN150@Load
  00220	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00223	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00226	75 0e		 jne	 SHORT $LN149@Load
  00228	83 c0 02	 add	 eax, 2
  0022b	83 c1 02	 add	 ecx, 2
  0022e	84 d2		 test	 dl, dl
  00230	75 e4		 jne	 SHORT $LL148@Load
$LN150@Load:
  00232	33 c0		 xor	 eax, eax
  00234	eb 05		 jmp	 SHORT $LN151@Load
$LN149@Load:
  00236	1b c0		 sbb	 eax, eax
  00238	83 c8 01	 or	 eax, 1
$LN151@Load:
  0023b	85 c0		 test	 eax, eax
  0023d	0f 84 de 00 00
	00		 je	 $LN125@Load

; 322  : 				{
; 323  : 					break;
; 324  : 				}
; 325  : 			
; 326  : 				iBridgeNum = (int)TokenNumber;

  00243	f3 0f 2c 35 00
	00 00 00	 cvttss2si esi, DWORD PTR ?TokenNumber@@3MA

; 327  : 
; 328  : 				if ( BC_BRIDGE_RANGE(iBridgeNum) != FALSE )

  0024b	85 f6		 test	 esi, esi
  0024d	78 a6		 js	 SHORT $LN22@Load
  0024f	33 c0		 xor	 eax, eax
  00251	83 fe 07	 cmp	 esi, 7
  00254	0f 9e c0	 setle	 al
  00257	85 c0		 test	 eax, eax
  00259	74 9a		 je	 SHORT $LN22@Load

; 329  : 				{
; 330  : 					Token = GetToken();

  0025b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 331  : 					this->m_BridgeData[iBridgeNum].m_iBC_REWARD_MULTIPLY = TokenNumber;

  00260	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  00268	69 c6 0c 02 00
	00		 imul	 eax, esi, 524
  0026e	f3 0f 11 84 38
	08 02 00 00	 movss	 DWORD PTR [eax+edi+520], xmm0

; 332  : 				}
; 333  : 				else

  00277	8b 45 fc	 mov	 eax, DWORD PTR _type$1$[ebp]
  0027a	e9 e1 fd ff ff	 jmp	 $LL4@Load
$LN19@Load:

; 334  : 				{
; 335  : 					Token = GetToken();
; 336  : 				}
; 337  : 			}
; 338  : 			else if ( type == 4 )

  0027f	83 f8 04	 cmp	 eax, 4
  00282	0f 85 d8 fd ff
	ff		 jne	 $LL4@Load

; 339  : 			{
; 340  : 				_EVENT_TIME pTmp;
; 341  : 				Token = GetToken();

  00288	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 342  : 
; 343  : 				if (strcmp("end", &TokenString[0]) == 0)

  0028d	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  00292	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL152@Load:
  00297	8a 10		 mov	 dl, BYTE PTR [eax]
  00299	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0029b	75 1a		 jne	 SHORT $LN153@Load
  0029d	84 d2		 test	 dl, dl
  0029f	74 12		 je	 SHORT $LN154@Load
  002a1	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  002a4	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  002a7	75 0e		 jne	 SHORT $LN153@Load
  002a9	83 c0 02	 add	 eax, 2
  002ac	83 c1 02	 add	 ecx, 2
  002af	84 d2		 test	 dl, dl
  002b1	75 e4		 jne	 SHORT $LL152@Load
$LN154@Load:
  002b3	33 c0		 xor	 eax, eax
  002b5	eb 05		 jmp	 SHORT $LN155@Load
$LN153@Load:
  002b7	1b c0		 sbb	 eax, eax
  002b9	83 c8 01	 or	 eax, 1
$LN155@Load:
  002bc	85 c0		 test	 eax, eax
  002be	74 61		 je	 SHORT $LN125@Load

; 344  : 				{
; 345  : 					break;
; 346  : 				}
; 347  : 
; 348  : 				pTmp.Hour = (int)TokenNumber;

  002c0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002c8	89 45 f4	 mov	 DWORD PTR _pTmp$1[ebp], eax

; 349  : 				Token = GetToken();

  002cb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 350  : 				pTmp.Min = (int)TokenNumber;

  002d0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 96   : 		return (_Ptr);

  002d8	8b 9f 80 10 00
	00		 mov	 ebx, DWORD PTR [edi+4224]

; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

  002de	8d 8f 80 10 00
	00		 lea	 ecx, DWORD PTR [edi+4224]
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 350  : 				pTmp.Min = (int)TokenNumber;

  002e4	89 45 f8	 mov	 DWORD PTR _pTmp$1[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

  002e7	8d 45 f4	 lea	 eax, DWORD PTR _pTmp$1[ebp]
  002ea	50		 push	 eax
  002eb	ff 73 04	 push	 DWORD PTR [ebx+4]
  002ee	53		 push	 ebx
  002ef	e8 00 00 00 00	 call	 ??$_Buynode@ABU_EVENT_TIME@CBloodCastle@@@?$_List_buy@U_EVENT_TIME@CBloodCastle@@V?$allocator@U_EVENT_TIME@CBloodCastle@@@std@@@std@@QAEPAU?$_List_node@U_EVENT_TIME@CBloodCastle@@PAX@1@PAU21@0ABU_EVENT_TIME@CBloodCastle@@@Z ; std::_List_buy<CBloodCastle::_EVENT_TIME,std::allocator<CBloodCastle::_EVENT_TIME> >::_Buynode<CBloodCastle::_EVENT_TIME const &>
  002f4	8b d0		 mov	 edx, eax

; 1066 : 		}
; 1067 : 
; 1068 : 
; 1069 : 	list(_XSTD initializer_list<_Ty> _Ilist,
; 1070 : 		const _Alloc& _Al = allocator_type())
; 1071 : 		: _Mybase(_Al)
; 1072 : 		{	// construct from initializer_list
; 1073 : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 1074 : 		}
; 1075 : 
; 1076 : 	_Myt& operator=(_XSTD initializer_list<_Ty> _Ilist)
; 1077 : 		{	// assign initializer_list
; 1078 : 		assign(_Ilist.begin(), _Ilist.end());
; 1079 : 		return (*this);
; 1080 : 		}
; 1081 : 
; 1082 : 	void assign(_XSTD initializer_list<_Ty> _Ilist)
; 1083 : 		{	// assign initializer_list
; 1084 : 		assign(_Ilist.begin(), _Ilist.end());
; 1085 : 		}
; 1086 : 
; 1087 : 	iterator insert(const_iterator _Where,
; 1088 : 		_XSTD initializer_list<_Ty> _Ilist)
; 1089 : 		{	// insert initializer_list
; 1090 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1091 : 		}
; 1092 : 
; 1093 : 	~list() _NOEXCEPT
; 1094 : 		{	// destroy the object
; 1095 : 		_Tidy();
; 1096 : 		}
; 1097 : 
; 1098 : 	_Myt& operator=(const _Myt& _Right)
; 1099 : 		{	// assign _Right
; 1100 : 		if (this != &_Right)
; 1101 : 			{	// different, assign it
; 1102 : 			if (this->_Getal() != _Right._Getal()
; 1103 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1104 : 				{	// change allocator before copying
; 1105 : 				clear();
; 1106 : 				this->_Copy_alloc(_Right._Getal());
; 1107 : 				}
; 1108 : 
; 1109 : 			assign(_Right.begin(), _Right.end());
; 1110 : 			}
; 1111 : 		return (*this);
; 1112 : 		}
; 1113 : 
; 1114 : 	iterator begin() _NOEXCEPT
; 1115 : 		{	// return iterator for beginning of mutable sequence
; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead()),
; 1117 : 			&this->_Get_data()));
; 1118 : 		}
; 1119 : 
; 1120 : 	const_iterator begin() const _NOEXCEPT
; 1121 : 		{	// return iterator for beginning of nonmutable sequence
; 1122 : 		return (const_iterator(this->_Nextnode(this->_Myhead()),
; 1123 : 			&this->_Get_data()));
; 1124 : 		}
; 1125 : 
; 1126 : 	iterator end() _NOEXCEPT
; 1127 : 		{	// return iterator for end of mutable sequence
; 1128 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1129 : 		}
; 1130 : 
; 1131 : 	const_iterator end() const _NOEXCEPT
; 1132 : 		{	// return iterator for end of nonmutable sequence
; 1133 : 		return (const_iterator(this->_Myhead(), &this->_Get_data()));
; 1134 : 		}
; 1135 : 
; 1136 : 	_Unchecked_iterator _Unchecked_begin()
; 1137 : 		{	// return iterator for beginning of mutable sequence
; 1138 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead()),
; 1139 : 			&this->_Get_data()));
; 1140 : 		}
; 1141 : 
; 1142 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1143 : 		{	// return iterator for beginning of nonmutable sequence
; 1144 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead()),
; 1145 : 			&this->_Get_data()));
; 1146 : 		}
; 1147 : 
; 1148 : 	_Unchecked_iterator _Unchecked_end()
; 1149 : 		{	// return unchecked iterator for end of mutable sequence
; 1150 : 		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));
; 1151 : 		}
; 1152 : 
; 1153 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1154 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1155 : 		return (_Unchecked_const_iterator(this->_Myhead(),
; 1156 : 			&this->_Get_data()));
; 1157 : 		}
; 1158 : 
; 1159 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1160 : 		{	// make iterator from const_iterator
; 1161 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1162 : 		}
; 1163 : 
; 1164 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1165 : 		{	// make iterator from _Unchecked_const_iterator
; 1166 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1167 : 		}
; 1168 : 
; 1169 : 	reverse_iterator rbegin() _NOEXCEPT
; 1170 : 		{	// return iterator for beginning of reversed mutable sequence
; 1171 : 		return (reverse_iterator(end()));
; 1172 : 		}
; 1173 : 
; 1174 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1175 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1176 : 		return (const_reverse_iterator(end()));
; 1177 : 		}
; 1178 : 
; 1179 : 	reverse_iterator rend() _NOEXCEPT
; 1180 : 		{	// return iterator for end of reversed mutable sequence
; 1181 : 		return (reverse_iterator(begin()));
; 1182 : 		}
; 1183 : 
; 1184 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1185 : 		{	// return iterator for end of reversed nonmutable sequence
; 1186 : 		return (const_reverse_iterator(begin()));
; 1187 : 		}
; 1188 : 
; 1189 : 	const_iterator cbegin() const _NOEXCEPT
; 1190 : 		{	// return iterator for beginning of nonmutable sequence
; 1191 : 		return (begin());
; 1192 : 		}
; 1193 : 
; 1194 : 	const_iterator cend() const _NOEXCEPT
; 1195 : 		{	// return iterator for end of nonmutable sequence
; 1196 : 		return (end());
; 1197 : 		}
; 1198 : 
; 1199 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1200 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1201 : 		return (rbegin());
; 1202 : 		}
; 1203 : 
; 1204 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1205 : 		{	// return iterator for end of reversed nonmutable sequence
; 1206 : 		return (rend());
; 1207 : 		}
; 1208 : 
; 1209 : 	void resize(size_type _Newsize)
; 1210 : 		{	// determine new length, padding with _Ty() elements as needed
; 1211 : 		if (this->_Mysize() < _Newsize)
; 1212 : 			{	// pad to make larger
; 1213 : 			size_type _Count = 0;
; 1214 : 			_TRY_BEGIN
; 1215 : 			for (; this->_Mysize() < _Newsize; ++_Count)
; 1216 : 				_Insert(_Unchecked_end());
; 1217 : 			_CATCH_ALL
; 1218 : 			for (; 0 < _Count; --_Count)
; 1219 : 				pop_back();	// undo inserts
; 1220 : 			_RERAISE;
; 1221 : 			_CATCH_END
; 1222 : 			}
; 1223 : 		else
; 1224 : 			while (_Newsize < this->_Mysize())
; 1225 : 				pop_back();
; 1226 : 		}
; 1227 : 
; 1228 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1229 : 		{	// determine new length, padding with _Val elements as needed
; 1230 : 		if (this->_Mysize() < _Newsize)
; 1231 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize(), _Val);
; 1232 : 		else
; 1233 : 			while (_Newsize < this->_Mysize())
; 1234 : 				pop_back();
; 1235 : 		}
; 1236 : 
; 1237 : 	size_type size() const _NOEXCEPT
; 1238 : 		{	// return length of sequence
; 1239 : 		return (this->_Mysize());
; 1240 : 		}
; 1241 : 
; 1242 : 	size_type max_size() const _NOEXCEPT
; 1243 : 		{	// return maximum possible length of sequence
; 1244 : 		return (this->_Getal().max_size());
; 1245 : 		}
; 1246 : 
; 1247 : 	bool empty() const _NOEXCEPT
; 1248 : 		{	// test if sequence is empty
; 1249 : 		return (this->_Mysize() == 0);
; 1250 : 		}
; 1251 : 
; 1252 : 	allocator_type get_allocator() const _NOEXCEPT
; 1253 : 		{	// return allocator object for values
; 1254 : 		return (this->_Getal());
; 1255 : 		}
; 1256 : 
; 1257 : 	reference front()
; 1258 : 		{	// return first element of mutable sequence
; 1259 : 		return (*begin());
; 1260 : 		}
; 1261 : 
; 1262 : 	const_reference front() const
; 1263 : 		{	// return first element of nonmutable sequence
; 1264 : 		return (*begin());
; 1265 : 		}
; 1266 : 
; 1267 : 	reference back()
; 1268 : 		{	// return last element of mutable sequence
; 1269 : 		return (*(--end()));
; 1270 : 		}
; 1271 : 
; 1272 : 	const_reference back() const
; 1273 : 		{	// return last element of nonmutable sequence
; 1274 : 		return (*(--end()));
; 1275 : 		}
; 1276 : 
; 1277 : 	void push_front(const _Ty& _Val)
; 1278 : 		{	// insert element at beginning
; 1279 : 		_Insert(_Unchecked_begin(), _Val);
; 1280 : 		}
; 1281 : 
; 1282 : 	void pop_front()
; 1283 : 		{	// erase element at beginning
; 1284 : 		erase(begin());
; 1285 : 		}
; 1286 : 
; 1287 : 	void push_back(const _Ty& _Val)
; 1288 : 		{	// insert element at end
; 1289 : 		_Insert(_Unchecked_end(), _Val);
; 1290 : 		}
; 1291 : 
; 1292 : 	void pop_back()
; 1293 : 		{	// erase element at end
; 1294 : 		erase(--end());
; 1295 : 		}
; 1296 : 
; 1297 : 	template<class _Iter>
; 1298 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1299 : 			void>::type
; 1300 : 		assign(_Iter _First, _Iter _Last)
; 1301 : 		{	// assign [_First, _Last), input iterators
; 1302 : 		iterator _Old = begin();
; 1303 : 		_TRY_BEGIN
; 1304 : 		for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)
; 1305 : 			_Reusenode(_Old, *_First);
; 1306 : 		for (; _First != _Last; ++_First)
; 1307 : 			_Insert(_Unchecked_end(), *_First);
; 1308 : 		_CATCH_ALL
; 1309 : 		clear();
; 1310 : 		_RERAISE;
; 1311 : 		_CATCH_END
; 1312 : 		erase(_Old, end());
; 1313 : 		}
; 1314 : 
; 1315 : 	template<class _TArg>
; 1316 : 		void _Reusenode(iterator _Where, _TArg&& _Arg)
; 1317 : 		{	// destroy the element at _Where and reconstruct from _Arg
; 1318 : 		_TRY_BEGIN
; 1319 : 		this->_Getal().destroy(
; 1320 : 			_STD addressof(this->_Myval(_Where._Ptr)));
; 1321 : 		this->_Getal().construct(
; 1322 : 			_STD addressof(this->_Myval(_Where._Ptr)),
; 1323 : 			_STD forward<_TArg>(_Arg));
; 1324 : 		_CATCH_ALL
; 1325 : 		_Unlinknode(_Where);
; 1326 : 		this->_Getal().destroy(
; 1327 : 			_STD addressof(this->_Nextnode(_Where._Ptr)));
; 1328 : 		this->_Getal().destroy(
; 1329 : 			_STD addressof(this->_Prevnode(_Where._Ptr)));
; 1330 : 		this->_Getal().deallocate(_Where._Ptr, 1);
; 1331 : 		_RERAISE;
; 1332 : 		_CATCH_END
; 1333 : 		}
; 1334 : 
; 1335 : 	void assign(size_type _Count, const _Ty& _Val)
; 1336 : 		{	// assign _Count * _Val
; 1337 : 		clear();
; 1338 : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 1339 : 		}
; 1340 : 
; 1341 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1342 : 		{	// insert _Val at _Where
; 1343 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1344 : 		if (_Where._Getcont() != &this->_Get_data())
; 1345 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1346 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1347 : 
; 1348 : 		_Insert(_Where._Unchecked(), _Val);
; 1349 : 		return (_Make_iter(--_Where));
; 1350 : 		}
; 1351 : 
; 1352 : 	iterator insert(const_iterator _Where,
; 1353 : 		size_type _Count, const _Ty& _Val)
; 1354 : 		{	// insert _Count * _Val at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != &this->_Get_data())
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1364 : 			return (begin());
; 1365 : 			}
; 1366 : 		else
; 1367 : 			{	// insert sequence not at beginning
; 1368 : 			--_Prev;
; 1369 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1370 : 			return (++_Prev);
; 1371 : 			}
; 1372 : 		}
; 1373 : 
; 1374 : 	template<class _Iter>
; 1375 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1376 : 			iterator>::type
; 1377 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1378 : 		{	// insert [_First, _Last) at _Where
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_Where._Getcont() != &this->_Get_data())
; 1381 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1382 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1383 : 
; 1384 : 		iterator _Prev = _Make_iter(_Where);
; 1385 : 		if (_Prev == begin())
; 1386 : 			{	// insert sequence at beginning
; 1387 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1388 : 				_Iter_cat(_First));
; 1389 : 			return (begin());
; 1390 : 			}
; 1391 : 		else
; 1392 : 			{	// insert sequence not at beginning
; 1393 : 			--_Prev;
; 1394 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1395 : 				_Iter_cat(_First));
; 1396 : 			return (++_Prev);
; 1397 : 			}
; 1398 : 		}
; 1399 : 
; 1400 : 	template<class _Iter>
; 1401 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1402 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1403 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1404 : 		size_type _Num = 0;
; 1405 : 
; 1406 : 		_TRY_BEGIN
; 1407 : 		for (; _First != _Last; ++_First, (void)++_Num)
; 1408 : 			_Insert(_Where, *_First);
; 1409 : 		_CATCH_ALL
; 1410 : 		for (; 0 < _Num; --_Num)
; 1411 : 			{	// undo inserts
; 1412 : 			_Unchecked_const_iterator _Before = _Where;
; 1413 : 			_Unchecked_erase(--_Before);
; 1414 : 			}
; 1415 : 		_RERAISE;
; 1416 : 		_CATCH_END
; 1417 : 		}
; 1418 : 
; 1419 : 	template<class _Iter>
; 1420 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1421 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1422 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1423 : 		_DEBUG_RANGE(_First, _Last);
; 1424 : 		_Iter _Next = _First;
; 1425 : 
; 1426 : 		_TRY_BEGIN
; 1427 : 		for (; _First != _Last; ++_First)
; 1428 : 			_Insert(_Where, *_First);
; 1429 : 		_CATCH_ALL
; 1430 : 		for (; _Next != _First; ++_Next)
; 1431 : 			{	// undo inserts
; 1432 : 			_Unchecked_const_iterator _Before = _Where;
; 1433 : 			_Unchecked_erase(--_Before);
; 1434 : 			}
; 1435 : 		_RERAISE;
; 1436 : 		_CATCH_END
; 1437 : 		}
; 1438 : 
; 1439 : 	_Nodeptr _Unlinknode(const_iterator _Where)
; 1440 : 		{	// unlink node at _Where from the list
; 1441 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1442 : 		if (_Where._Getcont() != &this->_Get_data()
; 1443 : 			|| _Where._Ptr == this->_Myhead())
; 1444 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1445 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1446 : 		_Orphan_ptr(_Pnode);
; 1447 : 
; 1448 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1449 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1453 : 			this->_Nextnode(_Pnode);
; 1454 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1455 : 			this->_Prevnode(_Pnode);
; 1456 : 
; 1457 : 		--this->_Mysize();
; 1458 : 		return (_Pnode);
; 1459 : 		}
; 1460 : 
; 1461 : 	iterator erase(const_iterator _Where)
; 1462 : 		{	// erase element at _Where
; 1463 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1464 : 		this->_Freenode(_Pnode);
; 1465 : 		return (_Make_iter(_Where));
; 1466 : 		}
; 1467 : 
; 1468 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1469 : 		{	// erase element at _Where
; 1470 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1471 : 
; 1472 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1473 : 			this->_Nextnode(_Pnode);
; 1474 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1475 : 			this->_Prevnode(_Pnode);
; 1476 : 		this->_Freenode(_Pnode);
; 1477 : 		--this->_Mysize();
; 1478 : 		}
; 1479 : 
; 1480 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1481 : 		{	// erase [_First, _Last)
; 1482 : 		if (_First == begin() && _Last == end())
; 1483 : 			{	// erase all and return fresh iterator
; 1484 : 			clear();
; 1485 : 			return (end());
; 1486 : 			}
; 1487 : 		else
; 1488 : 			{	// erase subrange
; 1489 : 			while (_First != _Last)
; 1490 : 				_First = erase(_First);
; 1491 : 			return (_Make_iter(_Last));
; 1492 : 			}
; 1493 : 		}
; 1494 : 
; 1495 : 	void clear() _NOEXCEPT
; 1496 : 		{	// erase all
; 1497 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1498 : 
; 1499 : 		this->_Orphan_ptr(nullptr);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());
; 1502 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();
; 1503 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();
; 1504 : 		this->_Mysize() = 0;
; 1505 : 
; 1506 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)
; 1507 : 			{	// delete an element
; 1508 : 			_Pnext = this->_Nextnode(_Pnode);
; 1509 : 			this->_Freenode(_Pnode);
; 1510 : 			}
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		_NOEXCEPT_OP(_Alty::is_always_equal::value)
; 1515 : 		{	// exchange contents with _Right
; 1516 : 		if (this == &_Right)
; 1517 : 			;	// same object, do nothing
; 1518 : 		else if (this->_Getal() == _Right._Getal())
; 1519 : 			{	// same allocator, swap control information
; 1520 : 			this->_Swap_all(_Right);
; 1521 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1522 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myhead(), _Right._Myhead());
; 1529 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1530 : 			}
; 1531 : 
; 1532 : 		else	// containers are incompatible
; 1533 : 
; 1534 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1535 : 			_DEBUG_ERROR("list containers incompatible for swap");
; 1536 : 
; 1537 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 			_XSTD terminate();
; 1539 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 		}
; 1541 : 
; 1542 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1543 : 		{	// splice all of _Right at _Where
; 1544 : 		if (this != &_Right && !_Right.empty())
; 1545 : 			{	// worth splicing, do it
; 1546 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1547 : 				_Right._Mysize());
; 1548 : 			}
; 1549 : 		}
; 1550 : 
; 1551 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1552 : 		{	// splice all of _Right at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1557 : 		const_iterator _First)
; 1558 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1559 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1560 : 		if (_First == _Right.end())
; 1561 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1562 : 		else
; 1563 : 
; 1564 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1565 : 		if (_First != _Right.end())
; 1566 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1567 : 
; 1568 : 			{	// element exists, try splice
; 1569 : 			const_iterator _Last = _First;
; 1570 : 			++_Last;
; 1571 : 			if (this != &_Right
; 1572 : 				|| (_Where != _First && _Where != _Last))
; 1573 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1574 : 			}
; 1575 : 		}
; 1576 : 
; 1577 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1578 : 		const_iterator _First)
; 1579 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1580 : 		splice(_Where, (_Myt&)_Right, _First);
; 1581 : 		}
; 1582 : 
; 1583 : 	void splice(const_iterator _Where,
; 1584 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1585 : 		{	// splice _Right [_First, _Last) at _Where
; 1586 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1587 : 			{	// worth splicing, do it
; 1588 : 			size_type _Count = 0;
; 1589 : 
; 1590 : 			if (this == &_Right)
; 1591 : 				;	// just rearrange this list
; 1592 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1593 : 				_Count = _Right._Mysize();	// splice in whole list
; 1594 : 			else
; 1595 : 				{	// count nodes and check for knot
; 1596 : 				const_iterator _Next = _First;
; 1597 : 
; 1598 : 				for (; _Next != _Last; ++_Next, (void)++_Count)
; 1599 : 					if (_Next == _Right.end())
; 1600 : 						_Xlength_error("list<T> bad splice");
; 1601 : 				}
; 1602 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1603 : 			}
; 1604 : 		}
; 1605 : 
; 1606 : 	void splice(const_iterator _Where,
; 1607 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1608 : 		{	// splice _Right [_First, _Last) at _Where
; 1609 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1610 : 		}
; 1611 : 
; 1612 : 	void remove(const _Ty& _Val)
; 1613 : 		{	// erase each element matching _Val
; 1614 : 		iterator _Val_it = end();
; 1615 : 
; 1616 : 		for (iterator _First = begin(); _First != end(); )
; 1617 : 			if (*_First == _Val)
; 1618 : 				if (_STD addressof(*_First) == _STD addressof(_Val))
; 1619 : 					_Val_it = _First++;
; 1620 : 				else
; 1621 : 					_First = erase(_First);
; 1622 : 			else
; 1623 : 				++_First;
; 1624 : 
; 1625 : 		if (_Val_it != end())
; 1626 : 			erase(_Val_it);
; 1627 : 		}
; 1628 : 
; 1629 : 	template<class _Pr1>
; 1630 : 		void remove_if(_Pr1 _Pred)
; 1631 : 		{	// erase each element satisfying _Pred
; 1632 : 		for (iterator _First = begin(); _First != end(); )
; 1633 : 			if (_Pred(*_First))
; 1634 : 				_First = erase(_First);
; 1635 : 			else
; 1636 : 				++_First;
; 1637 : 		}
; 1638 : 
; 1639 : 	void unique()
; 1640 : 		{	// erase each element matching previous
; 1641 : 		unique(equal_to<>());
; 1642 : 		}
; 1643 : 
; 1644 : 	template<class _Pr2>
; 1645 : 		void unique(_Pr2 _Pred)
; 1646 : 		{	// erase each element satisfying _Pred with previous
; 1647 : 		const _Nodeptr _Phead = this->_Myhead();
; 1648 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1649 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1650 : 
; 1651 : 		while (_Pnode != _Phead)
; 1652 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1653 : 				{	// match, remove it
; 1654 : 				const _Nodeptr _Perase = _Pnode;
; 1655 : 				_Pnode = this->_Nextnode(_Pnode);
; 1656 : 
; 1657 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1658 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1659 : 				this->_Freenode(_Perase);
; 1660 : 
; 1661 : 				--this->_Mysize();
; 1662 : 				}
; 1663 : 			else
; 1664 : 				{	// no match, advance
; 1665 : 				_Pprev = _Pnode;
; 1666 : 				_Pnode = this->_Nextnode(_Pnode);
; 1667 : 				}
; 1668 : 		}
; 1669 : 
; 1670 : 	void merge(_Myt& _Right)
; 1671 : 		{	// merge in elements from _Right, both ordered by operator<
; 1672 : 		merge(_Right, less<>());
; 1673 : 		}
; 1674 : 
; 1675 : 	void merge(_Myt&& _Right)
; 1676 : 		{	// merge in elements from _Right, both ordered by operator<
; 1677 : 		merge((_Myt&)_Right);
; 1678 : 		}
; 1679 : 
; 1680 : 	template<class _Pr2>
; 1681 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1682 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1683 : 		if (&_Right != this)
; 1684 : 			{	// safe to merge, do it
; 1685 : 			iterator _First1 = begin(), _Last1 = end();
; 1686 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1687 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1688 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1689 : 
; 1690 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1691 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1692 : 					{	// splice in an element from _Right
; 1693 : 					iterator _Mid2 = _First2;
; 1694 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1695 : 					_First2 = _Mid2;
; 1696 : 					}
; 1697 : 				else
; 1698 : 					++_First1;
; 1699 : 
; 1700 : 			if (_First2 != _Last2)
; 1701 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1702 : 					_Right._Mysize());	// splice remainder of _Right
; 1703 : 			}
; 1704 : 		}
; 1705 : 
; 1706 : 	template<class _Pr2>
; 1707 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1708 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1709 : 		merge((_Myt&)_Right, _Pred);
; 1710 : 		}
; 1711 : 
; 1712 : 	void sort()
; 1713 : 		{	// order sequence, using operator<
; 1714 : 		sort(less<>());
; 1715 : 		}
; 1716 : 
; 1717 : 	template<class _Pr2>
; 1718 : 		void sort(_Pr2 _Pred)
; 1719 : 		{	// order sequence, using _Pred
; 1720 : 		_Sort(begin(), end(), _Pred, this->_Mysize());
; 1721 : 		}
; 1722 : 
; 1723 : 	template<class _Pr2>
; 1724 : 		iterator _Sort(iterator _First, iterator _Last, _Pr2 _Pred,
; 1725 : 			size_type _Size)
; 1726 : 		{	// order [_First, _Last), using _Pred, return new first
; 1727 : 			// _Size must be distance from _First to _Last
; 1728 : 		if (_Size < 2)
; 1729 : 			return (_First);	// nothing to do
; 1730 : 
; 1731 : 		iterator _Mid = _STD next(_First, _Size / 2);
; 1732 : 		_First = _Sort(_First, _Mid, _Pred, _Size / 2);
; 1733 : 		_Mid = _Sort(_Mid, _Last, _Pred, _Size - _Size / 2);
; 1734 : 		iterator _Newfirst = _First;
; 1735 : 
; 1736 : 		for (bool _Initial_loop = true; ; _Initial_loop = false)
; 1737 : 			{	// [_First, _Mid) and [_Mid, _Last) are sorted and non-empty
; 1738 : 			if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
; 1739 : 				{	// consume _Mid
; 1740 : 				if (_Initial_loop)
; 1741 : 					_Newfirst = _Mid;	// update return value
; 1742 : 				splice(_First, *this, _Mid++);
; 1743 : 				if (_Mid == _Last)
; 1744 : 					return (_Newfirst);	// exhausted [_Mid, _Last); done
; 1745 : 				}
; 1746 : 			else
; 1747 : 				{	// consume _First
; 1748 : 				++_First;
; 1749 : 				if (_First == _Mid)
; 1750 : 					return (_Newfirst);	// exhausted [_First, _Mid); done
; 1751 : 				}
; 1752 : 			}
; 1753 : 		}
; 1754 : 
; 1755 : 	void reverse() _NOEXCEPT
; 1756 : 		{	// reverse sequence
; 1757 : 		const _Nodeptr _Phead = this->_Myhead();
; 1758 : 		_Nodeptr _Pnode = _Phead;
; 1759 : 
; 1760 : 		for (; ; )
; 1761 : 			{	// flip pointers in a node
; 1762 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1763 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1764 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1765 : 
; 1766 : 			if (_Pnext == _Phead)
; 1767 : 				break;
; 1768 : 			_Pnode = _Pnext;
; 1769 : 			}
; 1770 : 		}
; 1771 : 
; 1772 : 	void _Splice(const_iterator _Where,
; 1773 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1774 : 		size_type _Count)
; 1775 : 		{	// splice _Right [_First, _Last) before _Where
; 1776 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1777 : 		if (_Where._Getcont() != &this->_Get_data())
; 1778 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1779 : 		if (this->_Getal() != _Right._Getal())
; 1780 : 			_DEBUG_ERROR("list containers incompatible for splice");
; 1781 : 
; 1782 : 		if (this != &_Right)
; 1783 : 			{	// transfer ownership
; 1784 : 			_Lockit _Lock(_LOCK_DEBUG);
; 1785 : 
; 1786 : 			const bool _One = _Count == 1;
; 1787 : 			const bool _All = !_One && _Count == _Right.size();
; 1788 : 			const bool _Some = !_One && !_All;
; 1789 : 
; 1790 : 			_Nodeptr _Oldprev = this->_Prevnode(_First._Ptr);
; 1791 : 
; 1792 : 			if (_Some)
; 1793 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1794 : 					_Ptr = this->_Nextnode(_Ptr))
; 1795 : 					{	// mark _Prev pointers
; 1796 : 					this->_Prevnode(_Ptr) = 0;
; 1797 : 					}
; 1798 : 
; 1799 : 			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();
; 1800 : 
; 1801 : 			if (_Pnext == 0)
; 1802 : 				_DEBUG_ERROR("list container corrupted");
; 1803 : 
; 1804 : 			while (*_Pnext != 0)
; 1805 : 				{	// check the iterator
; 1806 : 				const_iterator& _Iter = **_Pnext;
; 1807 : 
; 1808 : 				if ((_One && _Iter._Ptr == _First._Ptr)
; 1809 : 					|| (_All && _Iter._Ptr != _Right._Myhead())
; 1810 : 					|| (_Some && this->_Prevnode(_Iter._Ptr) == 0))
; 1811 : 					{	// adopt the iterator
; 1812 : 					*_Pnext = (const_iterator *)_Iter._Mynextiter;
; 1813 : 					_Iter._Myproxy = this->_Myproxy();
; 1814 : 					_Iter._Mynextiter = this->_Myproxy()->_Myfirstiter;
; 1815 : 					this->_Myproxy()->_Myfirstiter = &_Iter;
; 1816 : 					}
; 1817 : 				else
; 1818 : 					{	// skip the iterator
; 1819 : 					_Pnext = (const_iterator **)_Iter._Getpnext();
; 1820 : 					}
; 1821 : 				}
; 1822 : 
; 1823 : 			if (_Some)
; 1824 : 				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
; 1825 : 					_Ptr = this->_Nextnode(_Ptr))
; 1826 : 					{	// restore _Prev pointers
; 1827 : 					this->_Prevnode(_Ptr) = _Oldprev;
; 1828 : 					_Oldprev = _Ptr;
; 1829 : 					}
; 1830 : 			}
; 1831 : 
; 1832 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1833 : 		if (this->_Getal() != _Right._Getal())
; 1834 : 			_XSTD terminate();
; 1835 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1836 : 
; 1837 : 		_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1838 : 		}
; 1839 : 
; 1840 : 	void _Splice_same(const_iterator _Where,
; 1841 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1842 : 		size_type _Count)
; 1843 : 		{	// splice _Right [_First, _Last) before _Where
; 1844 : 		if (this != &_Right)
; 1845 : 			{	// splicing from another list, adjust counts
; 1846 : 			_Incsize(_Count);
; 1847 : 			_Right._Mysize() -= _Count;
; 1848 : 			}
; 1849 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1850 : 			_Last._Mynode();
; 1851 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1852 : 			_Where._Mynode();
; 1853 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1854 : 			_First._Mynode();
; 1855 : 
; 1856 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1857 : 		this->_Prevnode(_Where._Mynode()) =
; 1858 : 			this->_Prevnode(_Last._Mynode());
; 1859 : 		this->_Prevnode(_Last._Mynode()) =
; 1860 : 			this->_Prevnode(_First._Mynode());
; 1861 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1862 : 		}
; 1863 : 
; 1864 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1865 : 		_Unchecked_const_iterator _First,
; 1866 : 		_Unchecked_const_iterator _Last)
; 1867 : 		{	// splice [_First, _Last) before _Where
; 1868 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1869 : 			_Last._Mynode();
; 1870 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1871 : 			_Where._Mynode();
; 1872 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1873 : 			_First._Mynode();
; 1874 : 
; 1875 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1876 : 		this->_Prevnode(_Where._Mynode()) =
; 1877 : 			this->_Prevnode(_Last._Mynode());
; 1878 : 		this->_Prevnode(_Last._Mynode()) =
; 1879 : 			this->_Prevnode(_First._Mynode());
; 1880 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1881 : 		}
; 1882 : 
; 1883 : 	void _Tidy()
; 1884 : 		{	// free all storage
; 1885 : 		clear();
; 1886 : 		}
; 1887 : 
; 1888 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1889 : 		size_type _Count, const _Ty& _Val)
; 1890 : 		{	// insert _Count * _Val at _Where
; 1891 : 		size_type _Countsave = _Count;
; 1892 : 
; 1893 : 		_TRY_BEGIN
; 1894 : 		for (; 0 < _Count; --_Count)
; 1895 : 			_Insert(_Where, _Val);
; 1896 : 		_CATCH_ALL
; 1897 : 		for (; _Count < _Countsave; ++_Count)
; 1898 : 			{	// undo inserts
; 1899 : 			_Unchecked_const_iterator _Before = _Where;
; 1900 : 			_Unchecked_erase(--_Before);
; 1901 : 			}
; 1902 : 		_RERAISE;
; 1903 : 		_CATCH_END
; 1904 : 		}
; 1905 : 
; 1906 : 	void _Incsize(size_type _Count)
; 1907 : 		{	// alter element count, with checking
; 1908 : 		if (max_size() - this->_Mysize() - 1 < _Count)

  002f6	b9 fe ff ff 0f	 mov	 ecx, 268435454		; 0ffffffeH
  002fb	8b 87 84 10 00
	00		 mov	 eax, DWORD PTR [edi+4228]
  00301	2b c8		 sub	 ecx, eax
  00303	83 f9 01	 cmp	 ecx, 1
  00306	72 4d		 jb	 SHORT $LN158@Load

; 1910 : 		this->_Mysize() += _Count;

  00308	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0030b	89 8f 84 10 00
	00		 mov	 DWORD PTR [edi+4228], ecx

; 1062 : 				_STD forward<_Valty>(_Val)...);
; 1063 : 		_Incsize(1);
; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

  00311	89 53 04	 mov	 DWORD PTR [ebx+4], edx

; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() != _Right._Getcont())
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("list iterators incompatible");
; 289  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 290  : 			}
; 291  : 
; 292  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 293  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 294  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 295  : 
; 296  : 		return (this->_Ptr == _Right._Ptr);
; 297  : 		}
; 298  : 
; 299  : 	bool operator!=(const _Myiter& _Right) const
; 300  : 		{	// test for iterator inequality
; 301  : 		return (!(*this == _Right));
; 302  : 		}
; 303  : 	};
; 304  : 
; 305  : template<class _Mylist> inline
; 306  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 307  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 308  : 	{	// convert to unchecked
; 309  : 	return (_Iter._Unchecked());
; 310  : 	}
; 311  : 
; 312  : template<class _Mylist> inline
; 313  : 	_List_const_iterator<_Mylist>&
; 314  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 315  : 			typename _List_const_iterator<_Mylist>
; 316  : 				::_Unchecked_type _Right)
; 317  : 	{	// convert to checked
; 318  : 	return (_Iter._Rechecked(_Right));
; 319  : 	}
; 320  : 
; 321  : 	// TEMPLATE CLASS _List_iterator
; 322  : template<class _Mylist>
; 323  : 	class _List_iterator
; 324  : 		: public _List_const_iterator<_Mylist>
; 325  : 	{	// iterator for mutable list
; 326  : public:
; 327  : 	typedef _List_iterator<_Mylist> _Myiter;
; 328  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 329  : 	typedef bidirectional_iterator_tag iterator_category;
; 330  : 
; 331  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 332  : 	typedef typename _Mylist::value_type value_type;
; 333  : 	typedef typename _Mylist::difference_type difference_type;
; 334  : 	typedef typename _Mylist::pointer pointer;
; 335  : 	typedef typename _Mylist::reference reference;
; 336  : 
; 337  : 	_List_iterator()
; 338  : 		{	// construct with null node
; 339  : 		}
; 340  : 
; 341  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 342  : 		: _Mybase(_Pnode, _Plist)
; 343  : 		{	// construct with node pointer _Pnode
; 344  : 		}
; 345  : 
; 346  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 347  : 
; 348  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 349  : 		{	// reset from unchecked iterator
; 350  : 		this->_Ptr = _Right._Ptr;
; 351  : 		return (*this);
; 352  : 		}
; 353  : 
; 354  : 	_Unchecked_type _Unchecked() const
; 355  : 		{	// make an unchecked iterator
; 356  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 357  : 		}
; 358  : 
; 359  : 	reference operator*() const
; 360  : 		{	// return designated value
; 361  : 		return ((reference)**(_Mybase *)this);
; 362  : 		}
; 363  : 
; 364  : 	pointer operator->() const
; 365  : 		{	// return pointer to class object
; 366  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 367  : 		}
; 368  : 
; 369  : 	_Myiter& operator++()
; 370  : 		{	// preincrement
; 371  : 		++(*(_Mybase *)this);
; 372  : 		return (*this);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator++(int)
; 376  : 		{	// postincrement
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		++*this;
; 379  : 		return (_Tmp);
; 380  : 		}
; 381  : 
; 382  : 	_Myiter& operator--()
; 383  : 		{	// predecrement
; 384  : 		--(*(_Mybase *)this);
; 385  : 		return (*this);
; 386  : 		}
; 387  : 
; 388  : 	_Myiter operator--(int)
; 389  : 		{	// postdecrement
; 390  : 		_Myiter _Tmp = *this;
; 391  : 		--*this;
; 392  : 		return (_Tmp);
; 393  : 		}
; 394  : 	};
; 395  : 
; 396  : template<class _Mylist> inline
; 397  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 398  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 399  : 	{	// convert to unchecked
; 400  : 	return (_Iter._Unchecked());
; 401  : 	}
; 402  : 
; 403  : template<class _Mylist> inline
; 404  : 	_List_iterator<_Mylist>&
; 405  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 406  : 			typename _List_iterator<_Mylist>
; 407  : 				::_Unchecked_type _Right)
; 408  : 	{	// convert to checked
; 409  : 	return (_Iter._Rechecked(_Right));
; 410  : 	}
; 411  : 
; 412  : 		// list TYPE WRAPPERS
; 413  : template<class _Value_type,
; 414  : 	class _Size_type,
; 415  : 	class _Difference_type,
; 416  : 	class _Pointer,
; 417  : 	class _Const_pointer,
; 418  : 	class _Reference,
; 419  : 	class _Const_reference,
; 420  : 	class _Nodeptr_type>
; 421  : 	struct _List_iter_types
; 422  : 	{	// wraps types needed by iterators
; 423  : 	typedef _Value_type value_type;
; 424  : 	typedef _Size_type size_type;
; 425  : 	typedef _Difference_type difference_type;
; 426  : 	typedef _Pointer pointer;
; 427  : 	typedef _Const_pointer const_pointer;
; 428  : 	typedef _Reference reference;
; 429  : 	typedef _Const_reference const_reference;
; 430  : 	typedef _Nodeptr_type _Nodeptr;
; 431  : 	};
; 432  : 
; 433  : template<class _Value_type,
; 434  : 	class _Voidptr>
; 435  : 	struct _List_node
; 436  : 		{	// list node
; 437  : 		_Voidptr _Next;	// successor node, or first element if head
; 438  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 439  : 		_Value_type _Myval;	// the stored value, unused if head
; 440  : 
; 441  : 	private:
; 442  : 		_List_node& operator=(const _List_node&);
; 443  : 		};
; 444  : 
; 445  : template<class _Value_type>
; 446  : 	struct _List_node<_Value_type, void *>
; 447  : 		{	// list node
; 448  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 449  : 		_Nodeptr _Next;	// successor node, or first element if head
; 450  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 451  : 		_Value_type _Myval;	// the stored value, unused if head
; 452  : 
; 453  : 	private:
; 454  : 		_List_node& operator=(const _List_node&);
; 455  : 		};
; 456  : 
; 457  : template<class _Ty>
; 458  : 	struct _List_simple_types
; 459  : 		: public _Simple_types<_Ty>
; 460  : 	{	// wraps types needed by iterators
; 461  : 	typedef _List_node<_Ty, void *> _Node;
; 462  : 	typedef _Node *_Nodeptr;
; 463  : 	};
; 464  : 
; 465  : template<class _Ty,
; 466  : 	class _Alloc0>
; 467  : 	struct _List_base_types
; 468  : 	{	// types needed for a container base
; 469  : 	typedef _Alloc0 _Alloc;
; 470  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 471  : 
; 472  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 473  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 474  : 
; 475  : 
; 476  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 477  : 		_Voidptr;
; 478  : 	typedef _List_node<typename _Alty::value_type,
; 479  : 		_Voidptr> _Node;
; 480  : 
; 481  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 482  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 483  : 	typedef _Nodeptr& _Nodepref;
; 484  : 
; 485  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 486  : 		_List_simple_types<typename _Alty::value_type>,
; 487  : 		_List_iter_types<typename _Alty::value_type,
; 488  : 			typename _Alty::size_type,
; 489  : 			typename _Alty::difference_type,
; 490  : 			typename _Alty::pointer,
; 491  : 			typename _Alty::const_pointer,
; 492  : 			typename _Alty::reference,
; 493  : 			typename _Alty::const_reference,
; 494  : 			_Nodeptr> >::type
; 495  : 		_Val_types;
; 496  : 	};
; 497  : 
; 498  : 		// TEMPLATE CLASS _List_val
; 499  : template<class _Val_types>
; 500  : 	class _List_val
; 501  : 		: public _Container_base
; 502  : 	{	// base class for list to hold data
; 503  : public:
; 504  : 	typedef _List_val<_Val_types> _Myt;
; 505  : 
; 506  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 507  : 	typedef _Nodeptr& _Nodepref;
; 508  : 
; 509  : 	typedef typename _Val_types::value_type value_type;
; 510  : 	typedef typename _Val_types::size_type size_type;
; 511  : 	typedef typename _Val_types::difference_type difference_type;
; 512  : 	typedef typename _Val_types::pointer pointer;
; 513  : 	typedef typename _Val_types::const_pointer const_pointer;
; 514  : 	typedef typename _Val_types::reference reference;
; 515  : 	typedef typename _Val_types::const_reference const_reference;
; 516  : 
; 517  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 518  : 	typedef _List_iterator<_Myt> iterator;
; 519  : 
; 520  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 521  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 522  : 
; 523  : 	_List_val()
; 524  : 		{	// initialize data
; 525  : 		this->_Myhead = 0;
; 526  : 		this->_Mysize = 0;
; 527  : 		}
; 528  : 
; 529  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 530  : 		{	// return reference to successor pointer in node
; 531  : 		return ((_Nodepref)_Pnode->_Next);

  00314	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  00317	89 10		 mov	 DWORD PTR [eax], edx
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 354  : 		}

  00319	8b 45 fc	 mov	 eax, DWORD PTR _type$1$[ebp]
  0031c	e9 3f fd ff ff	 jmp	 $LL4@Load
$LN125@Load:

; 239  : 		return;
; 240  : 	}
; 241  : 
; 242  : 	type=-1;
; 243  : 	BridgeCount=-1;
; 244  : 
; 245  : 	while ( true )
; 246  : 	{
; 247  : 		Token=GetToken();

  00321	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 248  : 
; 249  : 		if ( Token == 2 )

  00326	83 f8 02	 cmp	 eax, 2
  00329	0f 85 21 fd ff
	ff		 jne	 $LL2@Load
  0032f	8b 5d 08	 mov	 ebx, DWORD PTR _filename$[ebp]
  00332	5e		 pop	 esi
$LN131@Load:

; 355  : 	}
; 356  : 
; 357  : 	fclose(SMDFile);

  00333	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00339	e8 00 00 00 00	 call	 _fclose

; 358  : 
; 359  : 	LogAdd("%s file load!", filename);

  0033e	53		 push	 ebx
  0033f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB?$AA@
  00344	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0034a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0034d	5f		 pop	 edi
  0034e	5b		 pop	 ebx

; 360  : }

  0034f	8b e5		 mov	 esp, ebp
  00351	5d		 pop	 ebp
  00352	c2 04 00	 ret	 4
$LN158@Load:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 1909 : 			_Xlength_error("list<T> too long");

  00355	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0035a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN159@Load:
$LN157@Load:
  0035f	cc		 int	 3
?Load@CBloodCastle@@QAEXPAD@Z ENDP			; CBloodCastle::Load
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?Init@CBloodCastle@@QAEX_N@Z
_TEXT	SEGMENT
tv637 = 8						; size = 4
_bEVENT_ENABLE$ = 8					; size = 1
?Init@CBloodCastle@@QAEX_N@Z PROC			; CBloodCastle::Init, COMDAT
; _this$ = ecx

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 166  : 	this->m_bBC_EVENT_ENABLE = bEVENT_ENABLE;

  00003	8a 45 08	 mov	 al, BYTE PTR _bEVENT_ENABLE$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	be 08 00 00 00	 mov	 esi, 8
  0000f	88 87 64 10 00
	00		 mov	 BYTE PTR [edi+4196], al
  00015	8d 97 e4 00 00
	00		 lea	 edx, DWORD PTR [edi+228]
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@Init:

; 172  : 	{
; 173  : 		for ( n=0;n<MAX_BLOOD_CASTLE_BOSS_MONSTER;n++)

  00020	8b c2		 mov	 eax, edx
  00022	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00027	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@Init:

; 174  : 		{
; 175  : 			this->m_BridgeData[i].m_iAngelKingPosNum = -1;

  00030	c7 82 b8 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+184], -1
  0003a	8d 40 04	 lea	 eax, DWORD PTR [eax+4]

; 176  : 			this->m_BridgeData[i].m_nBossMonsterPosNum[n] = -1;

  0003d	c7 40 fc ff ff
	ff ff		 mov	 DWORD PTR [eax-4], -1
  00044	83 e9 01	 sub	 ecx, 1
  00047	75 e7		 jne	 SHORT $LL7@Init

; 167  : 
; 168  : 	int i;
; 169  : 	int n;
; 170  : 
; 171  : 	for ( i=0; i<MAX_BLOOD_CASTLE_LEVEL ; i++ )

  00049	81 c2 0c 02 00
	00		 add	 edx, 524		; 0000020cH
  0004f	83 ee 01	 sub	 esi, 1
  00052	75 cc		 jne	 SHORT $LL4@Init

; 177  : 		}
; 178  : 	}
; 179  : 
; 180  : 	for ( n =0; n<OBJ_MAXMONSTER;n++)

  00054	b9 08 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+8
  00059	53		 push	 ebx
  0005a	33 db		 xor	 ebx, ebx
  0005c	89 4d 08	 mov	 DWORD PTR tv637[ebp], ecx
  0005f	90		 npad	 1
$LL10@Init:

; 181  : 	{
; 182  : 		if ( BC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber ) != FALSE )

  00060	8a 09		 mov	 cl, BYTE PTR [ecx]
  00062	80 f9 34	 cmp	 cl, 52			; 00000034H
  00065	74 18		 je	 SHORT $LN52@Init
  00067	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0006a	0f 82 f1 00 00
	00		 jb	 $LN8@Init
  00070	b0 11		 mov	 al, 17			; 00000011H
  00072	3a c1		 cmp	 al, cl
  00074	1b c0		 sbb	 eax, eax
  00076	83 c0 01	 add	 eax, 1
  00079	0f 84 e2 00 00
	00		 je	 $LN8@Init
$LN52@Init:

; 183  : 		{
; 184  : 			WORD btMonsterType = gMSetBase.m_Mp[n].m_Type;

  0007f	8b 45 08	 mov	 eax, DWORD PTR tv637[ebp]
  00082	0f b7 70 fe	 movzx	 esi, WORD PTR [eax-2]

; 185  : 			BYTE btMapNumber = gMSetBase.m_Mp[n].m_MapNumber;
; 186  : 			BYTE btBloodCastleIndex = GetBridgeLevel(btMapNumber);

  00086	0f b6 c1	 movzx	 eax, cl
  00089	8b cf		 mov	 ecx, edi
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  00091	8a d0		 mov	 dl, al

; 187  : 
; 188  : 			if ( btMonsterType == 232 )

  00093	b8 e8 00 00 00	 mov	 eax, 232		; 000000e8H
  00098	66 3b f0	 cmp	 si, ax
  0009b	75 15		 jne	 SHORT $LN18@Init

; 189  : 			{
; 190  : 				this->m_BridgeData[btBloodCastleIndex].m_iAngelKingPosNum = n;

  0009d	0f b6 c2	 movzx	 eax, dl
  000a0	69 c0 0c 02 00
	00		 imul	 eax, eax, 524
  000a6	89 9c 38 9c 01
	00 00		 mov	 DWORD PTR [eax+edi+412], ebx

; 191  : 				continue;

  000ad	e9 af 00 00 00	 jmp	 $LN8@Init
$LN18@Init:

; 192  : 			}
; 193  : 			
; 194  : 			if ( BC_STATUE_RANGE(btMonsterType - 132) != FALSE )

  000b2	8b ce		 mov	 ecx, esi
  000b4	81 c1 7c ff ff
	ff		 add	 ecx, -132		; ffffff7cH
  000ba	78 21		 js	 SHORT $LN19@Init
  000bc	33 c0		 xor	 eax, eax
  000be	83 f9 02	 cmp	 ecx, 2
  000c1	0f 9e c0	 setle	 al
  000c4	85 c0		 test	 eax, eax
  000c6	74 15		 je	 SHORT $LN19@Init

; 195  : 			{
; 196  : 				this->m_BridgeData[btBloodCastleIndex].m_nSaintStatuePosNum = n;

  000c8	0f b6 c2	 movzx	 eax, dl
  000cb	69 c0 0c 02 00
	00		 imul	 eax, eax, 524
  000d1	89 9c 38 34 01
	00 00		 mov	 DWORD PTR [eax+edi+308], ebx

; 197  : 				continue;

  000d8	e9 84 00 00 00	 jmp	 $LN8@Init
$LN19@Init:

; 198  : 			}
; 199  : 			
; 200  : 			if ( btMonsterType == 131 )

  000dd	b8 83 00 00 00	 mov	 eax, 131		; 00000083H
  000e2	66 3b f0	 cmp	 si, ax
  000e5	75 12		 jne	 SHORT $LN20@Init

; 201  : 			{
; 202  : 				this->m_BridgeData[btBloodCastleIndex].m_nCastleDoorPosNum = n;

  000e7	0f b6 c2	 movzx	 eax, dl
  000ea	69 c0 0c 02 00
	00		 imul	 eax, eax, 524
  000f0	89 9c 38 38 01
	00 00		 mov	 DWORD PTR [eax+edi+312], ebx

; 203  : 				continue;

  000f7	eb 68		 jmp	 SHORT $LN8@Init
$LN20@Init:

; 204  : 			}
; 205  : 			
; 206  : 			if ( btMonsterType == 89 || btMonsterType == 95 || btMonsterType == 112 || btMonsterType == 118 || btMonsterType == 124 || btMonsterType == 130 || btMonsterType == 143 || btMonsterType == 433 )

  000f9	83 fe 59	 cmp	 esi, 89			; 00000059H
  000fc	74 32		 je	 SHORT $LN22@Init
  000fe	83 fe 5f	 cmp	 esi, 95			; 0000005fH
  00101	74 2d		 je	 SHORT $LN22@Init
  00103	83 fe 70	 cmp	 esi, 112		; 00000070H
  00106	74 28		 je	 SHORT $LN22@Init
  00108	83 fe 76	 cmp	 esi, 118		; 00000076H
  0010b	74 23		 je	 SHORT $LN22@Init
  0010d	83 fe 7c	 cmp	 esi, 124		; 0000007cH
  00110	74 1e		 je	 SHORT $LN22@Init
  00112	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  00117	66 3b f0	 cmp	 si, ax
  0011a	74 14		 je	 SHORT $LN22@Init
  0011c	b8 8f 00 00 00	 mov	 eax, 143		; 0000008fH
  00121	66 3b f0	 cmp	 si, ax
  00124	74 0a		 je	 SHORT $LN22@Init
  00126	b8 b1 01 00 00	 mov	 eax, 433		; 000001b1H
  0012b	66 3b f0	 cmp	 si, ax
  0012e	75 31		 jne	 SHORT $LN8@Init
$LN22@Init:

; 207  : 			{
; 208  : 				for ( int l=0;l<MAX_BLOOD_CASTLE_BOSS_MONSTER;l++)

  00130	0f b6 d2	 movzx	 edx, dl
  00133	33 c9		 xor	 ecx, ecx
  00135	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0013b	05 e4 00 00 00	 add	 eax, 228		; 000000e4H
  00140	03 c7		 add	 eax, edi
$LL13@Init:

; 209  : 				{
; 210  : 					if ( this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] == -1 )

  00142	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00145	74 0b		 je	 SHORT $LN36@Init

; 207  : 			{
; 208  : 				for ( int l=0;l<MAX_BLOOD_CASTLE_BOSS_MONSTER;l++)

  00147	41		 inc	 ecx
  00148	83 c0 04	 add	 eax, 4
  0014b	83 f9 14	 cmp	 ecx, 20			; 00000014H
  0014e	7c f2		 jl	 SHORT $LL13@Init

; 209  : 				{
; 210  : 					if ( this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] == -1 )

  00150	eb 0f		 jmp	 SHORT $LN8@Init
$LN36@Init:

; 211  : 					{
; 212  : 						this->m_BridgeData[btBloodCastleIndex].m_nBossMonsterPosNum[l] = n;

  00152	69 c2 83 00 00
	00		 imul	 eax, edx, 131
  00158	03 c1		 add	 eax, ecx
  0015a	89 9c 87 e4 00
	00 00		 mov	 DWORD PTR [edi+eax*4+228], ebx
$LN8@Init:

; 177  : 		}
; 178  : 	}
; 179  : 
; 180  : 	for ( n =0; n<OBJ_MAXMONSTER;n++)

  00161	8b 4d 08	 mov	 ecx, DWORD PTR tv637[ebp]
  00164	43		 inc	 ebx
  00165	83 c1 14	 add	 ecx, 20			; 00000014H
  00168	89 4d 08	 mov	 DWORD PTR tv637[ebp], ecx
  0016b	81 f9 58 34 03
	00		 cmp	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+210008
  00171	0f 8c e9 fe ff
	ff		 jl	 $LL10@Init

; 213  : 						break;
; 214  : 					}
; 215  : 				}
; 216  : 			}
; 217  : 		}
; 218  : 
; 219  : 	}
; 220  : 
; 221  : 	for ( i=0;i<MAX_BLOOD_CASTLE_LEVEL;i++)

  00177	33 f6		 xor	 esi, esi
  00179	5b		 pop	 ebx
  0017a	66 0f 1f 44 00
	00		 npad	 6
$LL16@Init:

; 222  : 	{
; 223  : 		this->SetState(i, BC_STATE_CLOSED);

  00180	6a 01		 push	 1
  00182	56		 push	 esi
  00183	8b cf		 mov	 ecx, edi
  00185	e8 00 00 00 00	 call	 ?SetState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetState
  0018a	46		 inc	 esi
  0018b	83 fe 08	 cmp	 esi, 8
  0018e	7c f0		 jl	 SHORT $LL16@Init
  00190	5f		 pop	 edi
  00191	5e		 pop	 esi

; 224  : 	}
; 225  : }

  00192	5d		 pop	 ebp
  00193	c2 04 00	 ret	 4
?Init@CBloodCastle@@QAEX_N@Z ENDP			; CBloodCastle::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?Run@CBloodCastle@@QAEXXZ
_TEXT	SEGMENT
?Run@CBloodCastle@@QAEXXZ PROC				; CBloodCastle::Run, COMDAT
; _this$ = ecx

; 599  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 600  : 	if ( this->m_bBC_EVENT_ENABLE != false )

  00003	80 bb 64 10 00
	00 00		 cmp	 BYTE PTR [ebx+4196], 0
  0000a	74 42		 je	 SHORT $LN3@Run

; 601  : 	{
; 602  : 		for (int iBridgeIndex=0;iBridgeIndex<MAX_BLOOD_CASTLE_LEVEL;iBridgeIndex++)

  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	33 f6		 xor	 esi, esi
  00010	8d bb 50 01 00
	00		 lea	 edi, DWORD PTR [ebx+336]
$LL4@Run:

; 603  : 		{
; 604  : 			switch ( this->m_BridgeData[iBridgeIndex].m_iBC_STATE )

  00016	8b 07		 mov	 eax, DWORD PTR [edi]
  00018	83 f8 03	 cmp	 eax, 3
  0001b	77 23		 ja	 SHORT $LN2@Run
  0001d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@Run[eax*4]
$LN9@Run:

; 605  : 			{
; 606  : 				case BC_STATE_NONE:
; 607  : 					this->ProcState_None(iBridgeIndex);
; 608  : 					break;
; 609  : 
; 610  : 				case BC_STATE_CLOSED:
; 611  : 					this->ProcState_Closed(iBridgeIndex);

  00024	56		 push	 esi
  00025	8b cb		 mov	 ecx, ebx
  00027	e8 00 00 00 00	 call	 ?ProcState_Closed@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_Closed

; 612  : 					break;

  0002c	eb 12		 jmp	 SHORT $LN2@Run
$LN10@Run:

; 613  : 
; 614  : 				case BC_STATE_PLAYING:
; 615  : 					this->ProcState_Playing(iBridgeIndex);

  0002e	56		 push	 esi
  0002f	8b cb		 mov	 ecx, ebx
  00031	e8 00 00 00 00	 call	 ?ProcState_Playing@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_Playing

; 616  : 					break;

  00036	eb 08		 jmp	 SHORT $LN2@Run
$LN11@Run:

; 617  : 
; 618  : 				case BC_STATE_PLAYEND:
; 619  : 					this->ProcState_PlayEnd(iBridgeIndex);

  00038	56		 push	 esi
  00039	8b cb		 mov	 ecx, ebx
  0003b	e8 00 00 00 00	 call	 ?ProcState_PlayEnd@CBloodCastle@@IAEXH@Z ; CBloodCastle::ProcState_PlayEnd
$LN2@Run:

; 601  : 	{
; 602  : 		for (int iBridgeIndex=0;iBridgeIndex<MAX_BLOOD_CASTLE_LEVEL;iBridgeIndex++)

  00040	46		 inc	 esi
  00041	81 c7 0c 02 00
	00		 add	 edi, 524		; 0000020cH
  00047	83 fe 08	 cmp	 esi, 8
  0004a	7c ca		 jl	 SHORT $LL4@Run
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
$LN3@Run:
  0004e	5b		 pop	 ebx

; 620  : 					break;
; 621  : 			}
; 622  : 		}
; 623  : 	}
; 624  : 
; 625  : }

  0004f	c3		 ret	 0
$LN18@Run:
  00050	00 00 00 00	 DD	 $LN2@Run
  00054	00 00 00 00	 DD	 $LN9@Run
  00058	00 00 00 00	 DD	 $LN10@Run
  0005c	00 00 00 00	 DD	 $LN11@Run
?Run@CBloodCastle@@QAEXXZ ENDP				; CBloodCastle::Run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::FixUsersPlayStateFail, COMDAT
; _this$ = ecx

; 4351 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 4352 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	0f 88 97 00 00
	00		 js	 $LN3@FixUsersPl
  0000f	33 c0		 xor	 eax, eax
  00011	83 ff 07	 cmp	 edi, 7
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	0f 84 87 00 00
	00		 je	 $LN3@FixUsersPl

; 4353 : 		return;
; 4354 : 
; 4355 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0001f	53		 push	 ebx
  00020	69 c7 0c 02 00
	00		 imul	 eax, edi, 524
  00026	bb 0a 00 00 00	 mov	 ebx, 10			; 0000000aH
  0002b	56		 push	 esi
  0002c	8d 71 1c	 lea	 esi, DWORD PTR [ecx+28]
  0002f	03 f0		 add	 esi, eax
$LL4@FixUsersPl:

; 4356 : 	{
; 4357 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	83 f8 ff	 cmp	 eax, -1
  00036	74 64		 je	 SHORT $LN2@FixUsersPl

; 4358 : 			continue;
; 4359 : 
; 4360 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < PLAYER_PLAYING )

  00038	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003e	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00044	83 7c 11 04 03	 cmp	 DWORD PTR [ecx+edx+4], 3
  00049	7c 51		 jl	 SHORT $LN2@FixUsersPl

; 4361 : 			continue;
; 4362 : 
; 4363 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 ||
; 4364 : 			 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||

  0004b	8a 84 11 36 12
	00 00		 mov	 al, BYTE PTR [ecx+edx+4662]
  00052	3c ff		 cmp	 al, -1
  00054	74 46		 je	 SHORT $LN2@FixUsersPl
  00056	80 bc 11 37 12
	00 00 ff	 cmp	 BYTE PTR [ecx+edx+4663], -1
  0005e	74 3c		 je	 SHORT $LN2@FixUsersPl
  00060	0f be c0	 movsx	 eax, al
  00063	3b c7		 cmp	 eax, edi
  00065	75 35		 jne	 SHORT $LN2@FixUsersPl

; 4365 : 			 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )
; 4366 : 			continue;
; 4367 : 
; 4368 : 		LPOBJ lpObj = &gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex];
; 4369 : 
; 4370 : 		switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState )

  00067	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0006a	83 e8 03	 sub	 eax, 3
  0006d	74 3c		 je	 SHORT $LN12@FixUsersPl
  0006f	83 e8 01	 sub	 eax, 1
  00072	75 07		 jne	 SHORT $LN14@FixUsersPl
$LN15@FixUsersPl:

; 4374 : 				{
; 4375 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  00074	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1
$LN14@FixUsersPl:

; 4380 : 				}
; 4381 : 				break;
; 4382 : 			case 4:
; 4383 : 				this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;
; 4384 : 				break;
; 4385 : 		}
; 4386 : 
; 4387 : 		LogAddTD("[Blood Castle] (%d) [%s][%s] FixUsersPlayStateFail() - State : %d",

  0007b	ff 76 0c	 push	 DWORD PTR [esi+12]
  0007e	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00081	03 c1		 add	 eax, ecx
  00083	50		 push	 eax
  00084	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  00087	03 c1		 add	 eax, ecx
  00089	50		 push	 eax
  0008a	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@KMBIFBDF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00099	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@FixUsersPl:

; 4353 : 		return;
; 4354 : 
; 4355 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0009c	83 c6 14	 add	 esi, 20			; 00000014H
  0009f	83 eb 01	 sub	 ebx, 1
  000a2	75 8d		 jne	 SHORT $LL4@FixUsersPl
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
$LN3@FixUsersPl:
  000a6	5f		 pop	 edi

; 4388 : 			iBridgeIndex+1, lpObj->AccountID, lpObj->Name,
; 4389 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState);
; 4390 : 	}
; 4391 : }

  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
$LN12@FixUsersPl:

; 4371 : 		{
; 4372 : 			case 3:
; 4373 : 				if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  000ab	8a 84 11 23 01
	00 00		 mov	 al, BYTE PTR [ecx+edx+291]
  000b2	3c 34		 cmp	 al, 52			; 00000034H
  000b4	74 0f		 je	 SHORT $LN28@FixUsersPl
  000b6	3c 0b		 cmp	 al, 11			; 0000000bH
  000b8	72 ba		 jb	 SHORT $LN15@FixUsersPl
  000ba	b4 11		 mov	 ah, 17			; 00000011H
  000bc	3a e0		 cmp	 ah, al
  000be	1b c0		 sbb	 eax, eax
  000c0	83 c0 01	 add	 eax, 1
  000c3	74 af		 je	 SHORT $LN15@FixUsersPl
$LN28@FixUsersPl:
  000c5	80 7c 11 51 00	 cmp	 BYTE PTR [ecx+edx+81], 0
  000ca	74 a8		 je	 SHORT $LN15@FixUsersPl
  000cc	0f 57 c0	 xorps	 xmm0, xmm0
  000cf	0f 2f 84 11 d8
	00 00 00	 comiss	 xmm0, DWORD PTR [ecx+edx+216]
  000d7	73 9b		 jae	 SHORT $LN15@FixUsersPl

; 4376 : 				}
; 4377 : 				else
; 4378 : 				{
; 4379 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;

  000d9	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  000e0	eb 99		 jmp	 SHORT $LN14@FixUsersPl
?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::FixUsersPlayStateFail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv831 = -12						; size = 4
_this$1$ = -8						; size = 4
tv879 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::FixUsersPlayStateWin, COMDAT
; _this$ = ecx

; 4264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 4265 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  0000a	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000d	85 db		 test	 ebx, ebx
  0000f	0f 88 cf 02 00
	00		 js	 $LN3@FixUsersPl
  00015	33 c0		 xor	 eax, eax
  00017	83 fb 07	 cmp	 ebx, 7
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 bf 02 00
	00		 je	 $LN3@FixUsersPl

; 4266 : 		return;
; 4267 : 
; 4268 : 	if ( this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS != -1 )

  00025	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524
  0002b	89 45 f4	 mov	 DWORD PTR tv831[ebp], eax
  0002e	83 bc 08 48 01
	00 00 ff	 cmp	 DWORD PTR [eax+ecx+328], -1
  00036	0f 84 a8 02 00
	00		 je	 $LN3@FixUsersPl

; 4269 : 	{
; 4270 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0003c	56		 push	 esi
  0003d	57		 push	 edi
  0003e	8d 71 28	 lea	 esi, DWORD PTR [ecx+40]
  00041	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	03 f0		 add	 esi, eax
  0004e	89 7d fc	 mov	 DWORD PTR tv879[ebp], edi
$LL4@FixUsersPl:

; 4271 : 		{
; 4272 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  00051	8b 46 f4	 mov	 eax, DWORD PTR [esi-12]
  00054	83 f8 ff	 cmp	 eax, -1
  00057	0f 84 76 02 00
	00		 je	 $LN2@FixUsersPl

; 4273 : 				continue;
; 4274 : 
; 4275 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected < PLAYER_PLAYING )

  0005d	69 d0 40 27 00
	00		 imul	 edx, eax, 10048
  00063	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  00068	0f 8c 65 02 00
	00		 jl	 $LN2@FixUsersPl

; 4276 : 				continue;
; 4277 : 
; 4278 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 ||
; 4279 : 				 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||

  0006e	8a 84 0a 36 12
	00 00		 mov	 al, BYTE PTR [edx+ecx+4662]
  00075	3c ff		 cmp	 al, -1
  00077	0f 84 56 02 00
	00		 je	 $LN2@FixUsersPl
  0007d	80 bc 0a 37 12
	00 00 ff	 cmp	 BYTE PTR [edx+ecx+4663], -1
  00085	0f 84 48 02 00
	00		 je	 $LN2@FixUsersPl
  0008b	0f be c0	 movsx	 eax, al
  0008e	3b c3		 cmp	 eax, ebx
  00090	0f 85 3d 02 00
	00		 jne	 $LN2@FixUsersPl

; 4280 : 				 gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )
; 4281 : 				continue;
; 4282 : 
; 4283 : 			LPOBJ lpObj = &gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex];
; 4284 : 
; 4285 : 			switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState )

  00096	8b 06		 mov	 eax, DWORD PTR [esi]
  00098	83 f8 04	 cmp	 eax, 4
  0009b	0f 87 0c 02 00
	00		 ja	 $LN30@FixUsersPl
  000a1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN74@FixUsersPl[eax*4]
$LN13@FixUsersPl:

; 4286 : 			{
; 4287 : 				case 0:
; 4288 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  000a8	8b bc 0a 0c 06
	00 00		 mov	 edi, DWORD PTR [edx+ecx+1548]
  000af	85 ff		 test	 edi, edi
  000b1	78 7a		 js	 SHORT $LN14@FixUsersPl
  000b3	33 c0		 xor	 eax, eax
  000b5	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  000bb	0f 9e c0	 setle	 al
  000be	85 c0		 test	 eax, eax
  000c0	74 6b		 je	 SHORT $LN14@FixUsersPl
  000c2	8b 5d f4	 mov	 ebx, DWORD PTR tv831[ebp]
  000c5	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]
  000c8	69 84 03 00 02
	00 00 40 27 00
	00		 imul	 eax, DWORD PTR [ebx+eax+512], 10048
  000d3	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  000d6	3b bc 08 0c 06
	00 00		 cmp	 edi, DWORD PTR [eax+ecx+1548]
  000dd	75 4e		 jne	 SHORT $LN14@FixUsersPl

; 4289 : 					{
; 4290 : 						if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Live == TRUE && lpObj->Life > 0.0 )

  000df	8a 84 0a 23 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+291]
  000e6	3c 34		 cmp	 al, 52			; 00000034H
  000e8	74 17		 je	 SHORT $LN63@FixUsersPl
  000ea	3c 0b		 cmp	 al, 11			; 0000000bH
  000ec	0f 82 38 01 00
	00		 jb	 $LN16@FixUsersPl
  000f2	b4 11		 mov	 ah, 17			; 00000011H
  000f4	3a e0		 cmp	 ah, al
  000f6	1b c0		 sbb	 eax, eax
  000f8	83 c0 01	 add	 eax, 1
  000fb	0f 84 29 01 00
	00		 je	 $LN16@FixUsersPl
$LN63@FixUsersPl:
  00101	80 7c 0a 51 01	 cmp	 BYTE PTR [edx+ecx+81], 1
  00106	0f 85 1e 01 00
	00		 jne	 $LN16@FixUsersPl
  0010c	f3 0f 10 84 0a
	d8 00 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+216]
  00115	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0011c	0f 86 08 01 00
	00		 jbe	 $LN16@FixUsersPl

; 4291 : 						{
; 4292 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  00122	c7 06 03 00 00
	00		 mov	 DWORD PTR [esi], 3

; 4293 : 						}
; 4294 : 						else

  00128	e9 7d 01 00 00	 jmp	 $LN72@FixUsersPl
$LN14@FixUsersPl:

; 4295 : 						{
; 4296 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;
; 4297 : 						}
; 4298 : 					}
; 4299 : 					else 
; 4300 : 					{
; 4301 : 						if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  0012d	8a 84 0a 23 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+291]
  00134	3c 34		 cmp	 al, 52			; 00000034H
  00136	74 17		 je	 SHORT $LN64@FixUsersPl
  00138	3c 0b		 cmp	 al, 11			; 0000000bH
  0013a	0f 82 64 01 00
	00		 jb	 $LN31@FixUsersPl
  00140	b4 11		 mov	 ah, 17			; 00000011H
  00142	3a e0		 cmp	 ah, al
  00144	1b c0		 sbb	 eax, eax
  00146	83 c0 01	 add	 eax, 1
  00149	0f 84 55 01 00
	00		 je	 $LN31@FixUsersPl
$LN64@FixUsersPl:
  0014f	80 7c 0a 51 00	 cmp	 BYTE PTR [edx+ecx+81], 0
  00154	0f 84 4a 01 00
	00		 je	 $LN31@FixUsersPl
  0015a	0f 57 c0	 xorps	 xmm0, xmm0
  0015d	0f 2f 84 0a d8
	00 00 00	 comiss	 xmm0, DWORD PTR [edx+ecx+216]
  00165	0f 82 3f 01 00
	00		 jb	 $LN72@FixUsersPl

; 4302 : 						{
; 4303 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;
; 4304 : 						}
; 4305 : 					}
; 4306 : 					break;

  0016b	e9 34 01 00 00	 jmp	 $LN31@FixUsersPl
$LN20@FixUsersPl:

; 4307 : 				case 1:
; 4308 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  00170	8b bc 0a 0c 06
	00 00		 mov	 edi, DWORD PTR [edx+ecx+1548]
  00177	85 ff		 test	 edi, edi
  00179	0f 88 2b 01 00
	00		 js	 $LN72@FixUsersPl
  0017f	33 c0		 xor	 eax, eax
  00181	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00187	0f 9e c0	 setle	 al
  0018a	85 c0		 test	 eax, eax
  0018c	0f 84 18 01 00
	00		 je	 $LN72@FixUsersPl
  00192	8b 5d f4	 mov	 ebx, DWORD PTR tv831[ebp]
  00195	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]
  00198	69 84 03 00 02
	00 00 40 27 00
	00		 imul	 eax, DWORD PTR [ebx+eax+512], 10048
  001a3	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  001a6	3b bc 08 0c 06
	00 00		 cmp	 edi, DWORD PTR [eax+ecx+1548]

; 4311 : 					}
; 4312 : 					break;

  001ad	8b 7d fc	 mov	 edi, DWORD PTR tv879[ebp]
  001b0	0f 85 f7 00 00
	00		 jne	 $LN30@FixUsersPl

; 4309 : 					{
; 4310 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  001b6	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4

; 4311 : 					}
; 4312 : 					break;

  001bc	e9 ec 00 00 00	 jmp	 $LN30@FixUsersPl
$LN22@FixUsersPl:

; 4313 : 				case 3:
; 4314 : 					if ( OBJMAX_RANGE(lpObj->PartyNumber) && lpObj->PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  001c1	8b bc 0a 0c 06
	00 00		 mov	 edi, DWORD PTR [edx+ecx+1548]
  001c8	85 ff		 test	 edi, edi
  001ca	78 66		 js	 SHORT $LN23@FixUsersPl
  001cc	33 c0		 xor	 eax, eax
  001ce	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  001d4	0f 9e c0	 setle	 al
  001d7	85 c0		 test	 eax, eax
  001d9	74 57		 je	 SHORT $LN23@FixUsersPl
  001db	8b 5d f4	 mov	 ebx, DWORD PTR tv831[ebp]
  001de	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]
  001e1	69 84 03 00 02
	00 00 40 27 00
	00		 imul	 eax, DWORD PTR [ebx+eax+512], 10048
  001ec	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  001ef	3b bc 08 0c 06
	00 00		 cmp	 edi, DWORD PTR [eax+ecx+1548]
  001f6	75 3a		 jne	 SHORT $LN23@FixUsersPl

; 4315 : 					{
; 4316 : 						if ( !BC_MAP_RANGE(lpObj->MapNumber) || lpObj->Live == 0 || lpObj->Life <= 0.0 )

  001f8	8a 84 0a 23 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+291]
  001ff	3c 34		 cmp	 al, 52			; 00000034H
  00201	74 0f		 je	 SHORT $LN65@FixUsersPl
  00203	3c 0b		 cmp	 al, 11			; 0000000bH
  00205	72 23		 jb	 SHORT $LN16@FixUsersPl
  00207	b4 11		 mov	 ah, 17			; 00000011H
  00209	3a e0		 cmp	 ah, al
  0020b	1b c0		 sbb	 eax, eax
  0020d	83 c0 01	 add	 eax, 1
  00210	74 18		 je	 SHORT $LN16@FixUsersPl
$LN65@FixUsersPl:
  00212	80 7c 0a 51 00	 cmp	 BYTE PTR [edx+ecx+81], 0
  00217	74 11		 je	 SHORT $LN16@FixUsersPl
  00219	0f 57 c0	 xorps	 xmm0, xmm0
  0021c	0f 2f 84 0a d8
	00 00 00	 comiss	 xmm0, DWORD PTR [edx+ecx+216]
  00224	0f 82 80 00 00
	00		 jb	 $LN72@FixUsersPl
$LN16@FixUsersPl:

; 4317 : 						{
; 4318 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  0022a	c7 06 04 00 00
	00		 mov	 DWORD PTR [esi], 4

; 4319 : 						}
; 4320 : 					}
; 4321 : 					else 

  00230	eb 78		 jmp	 SHORT $LN72@FixUsersPl
$LN23@FixUsersPl:

; 4322 : 					{
; 4323 : 						if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Live == TRUE && lpObj->Life > 0.0 )

  00232	8a 84 0a 23 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+291]
  00239	3c 34		 cmp	 al, 52			; 00000034H
  0023b	74 0f		 je	 SHORT $LN66@FixUsersPl
  0023d	3c 0b		 cmp	 al, 11			; 0000000bH
  0023f	72 63		 jb	 SHORT $LN31@FixUsersPl
  00241	b4 11		 mov	 ah, 17			; 00000011H
  00243	3a e0		 cmp	 ah, al
  00245	1b c0		 sbb	 eax, eax
  00247	83 c0 01	 add	 eax, 1
  0024a	74 58		 je	 SHORT $LN31@FixUsersPl
$LN66@FixUsersPl:
  0024c	80 7c 0a 51 01	 cmp	 BYTE PTR [edx+ecx+81], 1
  00251	75 51		 jne	 SHORT $LN31@FixUsersPl
  00253	f3 0f 10 84 0a
	d8 00 00 00	 movss	 xmm0, DWORD PTR [edx+ecx+216]
  0025c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00263	76 3f		 jbe	 SHORT $LN31@FixUsersPl

; 4324 : 						{
; 4325 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;

  00265	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 4326 : 						}
; 4327 : 						else

  0026b	eb 3d		 jmp	 SHORT $LN72@FixUsersPl
$LN29@FixUsersPl:

; 4328 : 						{
; 4329 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;
; 4330 : 						}
; 4331 : 					}
; 4332 : 					break;
; 4333 : 				case 4:
; 4334 : 					if ( !OBJMAX_RANGE(lpObj->PartyNumber) || lpObj->PartyNumber != gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber )

  0026d	8b bc 0a 0c 06
	00 00		 mov	 edi, DWORD PTR [edx+ecx+1548]
  00274	85 ff		 test	 edi, edi
  00276	78 2c		 js	 SHORT $LN31@FixUsersPl
  00278	33 c0		 xor	 eax, eax
  0027a	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00280	0f 9e c0	 setle	 al
  00283	85 c0		 test	 eax, eax
  00285	74 1d		 je	 SHORT $LN31@FixUsersPl
  00287	8b 5d f4	 mov	 ebx, DWORD PTR tv831[ebp]
  0028a	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]
  0028d	69 84 03 00 02
	00 00 40 27 00
	00		 imul	 eax, DWORD PTR [ebx+eax+512], 10048
  00298	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  0029b	3b bc 08 0c 06
	00 00		 cmp	 edi, DWORD PTR [eax+ecx+1548]
  002a2	74 06		 je	 SHORT $LN72@FixUsersPl
$LN31@FixUsersPl:

; 4335 : 					{
; 4336 : 						this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 1;

  002a4	c7 06 01 00 00
	00		 mov	 DWORD PTR [esi], 1
$LN72@FixUsersPl:
  002aa	8b 7d fc	 mov	 edi, DWORD PTR tv879[ebp]
$LN30@FixUsersPl:

; 4337 : 					}
; 4338 : 					break;
; 4339 : 			}
; 4340 : 
; 4341 : 			LogAddTD("[Blood Castle] (%d) [%s][%s] FixUsersPlayStateWin() - State : %d",

  002ad	ff 36		 push	 DWORD PTR [esi]
  002af	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002b2	03 c2		 add	 eax, edx
  002b4	50		 push	 eax
  002b5	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  002b8	03 c2		 add	 eax, edx
  002ba	50		 push	 eax
  002bb	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  002be	50		 push	 eax
  002bf	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@FFFJNKMC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fix@
  002c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d0	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@FixUsersPl:

; 4269 : 	{
; 4270 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  002d3	83 c6 14	 add	 esi, 20			; 00000014H
  002d6	83 ef 01	 sub	 edi, 1
  002d9	89 7d fc	 mov	 DWORD PTR tv879[ebp], edi
  002dc	0f 85 6f fd ff
	ff		 jne	 $LL4@FixUsersPl
  002e2	5f		 pop	 edi
  002e3	5e		 pop	 esi
$LN3@FixUsersPl:
  002e4	5b		 pop	 ebx

; 4342 : 				iBridgeIndex+1, lpObj->AccountID, lpObj->Name, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState);
; 4343 : 
; 4344 : 		}
; 4345 : 	}
; 4346 : }

  002e5	8b e5		 mov	 esp, ebp
  002e7	5d		 pop	 ebp
  002e8	c2 04 00	 ret	 4
  002eb	90		 npad	 1
$LN74@FixUsersPl:
  002ec	00 00 00 00	 DD	 $LN13@FixUsersPl
  002f0	00 00 00 00	 DD	 $LN20@FixUsersPl
  002f4	00 00 00 00	 DD	 $LN30@FixUsersPl
  002f8	00 00 00 00	 DD	 $LN22@FixUsersPl
  002fc	00 00 00 00	 DD	 $LN29@FixUsersPl
?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::FixUsersPlayStateWin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ChangeMonsterState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv231 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
_lpMA$1$ = 12						; size = 4
_iIndex$ = 12						; size = 4
?ChangeMonsterState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::ChangeMonsterState, COMDAT
; _this$ = ecx

; 4229 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4230 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	0f 88 b0 00 00
	00		 js	 $LN1@ChangeMons
  0000e	33 c0		 xor	 eax, eax
  00010	83 fa 07	 cmp	 edx, 7
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	0f 84 a0 00 00
	00		 je	 $LN1@ChangeMons

; 4231 : 		return;
; 4232 : 
; 4233 : 	int iAddDamageMax = 0;
; 4234 : 	int iAddDamageMin = 0;
; 4235 : 	int iAddDefense = 0;
; 4236 : 
; 4237 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 300000 )

  0001e	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	33 f6		 xor	 esi, esi
  00029	33 ff		 xor	 edi, edi
  0002b	33 db		 xor	 ebx, ebx
  0002d	8b 84 08 54 01
	00 00		 mov	 eax, DWORD PTR [eax+ecx+340]
  00034	3d e0 93 04 00	 cmp	 eax, 300000		; 000493e0H
  00039	7d 0b		 jge	 SHORT $LN3@ChangeMons

; 4238 : 	{
; 4239 : 		iAddDamageMin = g_iBC_MONSTER_CHANGE_STATE[1][0];

  0003b	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]

; 4240 : 		iAddDamageMax = g_iBC_MONSTER_CHANGE_STATE[1][1];

  0003e	8d 73 28	 lea	 esi, DWORD PTR [ebx+40]

; 4241 : 		iAddDefense = g_iBC_MONSTER_CHANGE_STATE[1][2];

  00041	8d 5f cc	 lea	 ebx, DWORD PTR [edi-52]
  00044	eb 12		 jmp	 SHORT $LN5@ChangeMons
$LN3@ChangeMons:

; 4242 : 	}
; 4243 : 	else if ( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC < 600000 )

  00046	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  0004b	7d 0b		 jge	 SHORT $LN5@ChangeMons

; 4244 : 	{
; 4245 : 		iAddDamageMin = g_iBC_MONSTER_CHANGE_STATE[0][0];

  0004d	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH

; 4246 : 		iAddDamageMax = g_iBC_MONSTER_CHANGE_STATE[0][1];

  00052	8d 77 0a	 lea	 esi, DWORD PTR [edi+10]

; 4247 : 		iAddDefense = g_iBC_MONSTER_CHANGE_STATE[0][2];

  00055	8d 5f e8	 lea	 ebx, DWORD PTR [edi-24]
$LN5@ChangeMons:

; 4248 : 	}
; 4249 : 
; 4250 : 	LPMONSTER_ATTRIBUTE lpMA = gMAttr.GetAttr(gObj[iIndex].Class);

  00058	69 4d 0c 40 27
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 10048
  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	89 4d 08	 mov	 DWORD PTR tv231[ebp], ecx
  00067	0f b7 84 01 90
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+144]
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  0007a	89 45 0c	 mov	 DWORD PTR _lpMA$1$[ebp], eax

; 4251 : 
; 4252 : 	if ( lpMA == NULL )

  0007d	85 c0		 test	 eax, eax
  0007f	74 3a		 je	 SHORT $LN10@ChangeMons

; 4253 : 		return;
; 4254 : 
; 4255 : 	gObj[iIndex].m_AttackDamageMin = lpMA->m_DamageMin + iAddDamageMin;

  00081	8b 50 58	 mov	 edx, DWORD PTR [eax+88]
  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008a	03 d7		 add	 edx, edi
  0008c	8b 7d 08	 mov	 edi, DWORD PTR tv231[ebp]
  0008f	89 94 0f 40 06
	00 00		 mov	 DWORD PTR [edi+ecx+1600], edx

; 4256 : 	gObj[iIndex].m_AttackDamageMax = lpMA->m_DamageMax + iAddDamageMax;

  00096	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009e	03 ce		 add	 ecx, esi
  000a0	89 8c 07 44 06
	00 00		 mov	 DWORD PTR [edi+eax+1604], ecx

; 4257 : 	gObj[iIndex].m_Defense = lpMA->m_Defense + iAddDefense;

  000a7	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMA$1$[ebp]
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000af	8b 49 60	 mov	 ecx, DWORD PTR [ecx+96]
  000b2	03 cb		 add	 ecx, ebx
  000b4	89 8c 07 74 06
	00 00		 mov	 DWORD PTR [edi+eax+1652], ecx
$LN10@ChangeMons:
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
$LN1@ChangeMons:

; 4258 : }

  000be	5d		 pop	 ebp
  000bf	c2 08 00	 ret	 8
?ChangeMonsterState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::ChangeMonsterState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWinnerPartyCompletePoint, COMDAT
; _this$ = ecx

; 4217 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4218 : 	int iPartyComplete = this->GetWinnerPartyCompleteCount(iBridgeIndex);

  00003	ff 75 08	 push	 DWORD PTR _iBridgeIndex$[ebp]
  00006	e8 00 00 00 00	 call	 ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount

; 4219 : 	iPartyComplete--;

  0000b	83 e8 01	 sub	 eax, 1

; 4220 : 
; 4221 : 	if ( CHECK_LIMIT(iPartyComplete, MAX_USER_IN_PARTY) )

  0000e	78 17		 js	 SHORT $LN2@GetWinnerP
  00010	33 c9		 xor	 ecx, ecx
  00012	83 f8 04	 cmp	 eax, 4
  00015	0f 9e c1	 setle	 cl
  00018	85 c9		 test	 ecx, ecx
  0001a	74 0b		 je	 SHORT $LN2@GetWinnerP

; 4222 : 		return g_iBC_Party_EventPoint[iPartyComplete];

  0001c	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_Party_EventPoint@@3QBHB[eax*4]

; 4225 : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN2@GetWinnerP:

; 4223 : 
; 4224 : 	return 0;

  00027	33 c0		 xor	 eax, eax

; 4225 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWinnerPartyCompletePoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv274 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWinnerPartyCompleteCount, COMDAT
; _this$ = ecx

; 4177 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4178 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	0f 88 ed 00 00
	00		 js	 $LN27@GetWinnerP
  0000e	33 c0		 xor	 eax, eax
  00010	83 fa 07	 cmp	 edx, 7
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	0f 84 dd 00 00
	00		 je	 $LN27@GetWinnerP

; 4180 : 
; 4181 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX))

  0001e	56		 push	 esi
  0001f	69 f2 0c 02 00
	00		 imul	 esi, edx, 524
  00025	03 f1		 add	 esi, ecx
  00027	ff b6 00 02 00
	00		 push	 DWORD PTR [esi+512]
  0002d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	0f 84 b7 00 00
	00		 je	 $LN28@GetWinnerP

; 4182 : 		return false;
; 4183 : 
; 4184 : 	int iPartyIndex = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  0003d	69 8e 00 02 00
	00 40 27 00 00	 imul	 ecx, DWORD PTR [esi+512], 10048
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	8b 8c 01 0c 06
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+1548]

; 4185 : 	
; 4186 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  00053	85 c9		 test	 ecx, ecx
  00055	0f 88 99 00 00
	00		 js	 $LN28@GetWinnerP
  0005b	33 c0		 xor	 eax, eax
  0005d	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00063	0f 9e c0	 setle	 al
  00066	85 c0		 test	 eax, eax
  00068	0f 84 86 00 00
	00		 je	 $LN28@GetWinnerP

; 4188 : 
; 4189 : 	int iPartyComplete=0;

  0006e	8b c1		 mov	 eax, ecx
  00070	c7 45 08 05 00
	00 00		 mov	 DWORD PTR tv274[ebp], 5
  00077	53		 push	 ebx
  00078	c1 e0 04	 shl	 eax, 4
  0007b	33 db		 xor	 ebx, ebx
  0007d	2b c1		 sub	 eax, ecx
  0007f	57		 push	 edi
  00080	8d 34 85 0c 00
	00 00		 lea	 esi, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
$LL4@GetWinnerP:

; 4193 : 	{
; 4194 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  00087	8b 3e		 mov	 edi, DWORD PTR [esi]

; 4195 : 
; 4196 : 		if ( gObjIsConnected(iUserIndex))

  00089	57		 push	 edi
  0008a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0008f	83 c4 04	 add	 esp, 4
  00092	85 c0		 test	 eax, eax
  00094	74 4c		 je	 SHORT $LN2@GetWinnerP

; 4197 : 		{
; 4198 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  00096	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009b	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  000a1	03 c8		 add	 ecx, eax
  000a3	8a 81 23 01 00
	00		 mov	 al, BYTE PTR [ecx+291]
  000a9	3c 34		 cmp	 al, 52			; 00000034H
  000ab	74 0f		 je	 SHORT $LN29@GetWinnerP
  000ad	3c 0b		 cmp	 al, 11			; 0000000bH
  000af	72 31		 jb	 SHORT $LN2@GetWinnerP
  000b1	b2 11		 mov	 dl, 17			; 00000011H
  000b3	3a d0		 cmp	 dl, al
  000b5	1b c0		 sbb	 eax, eax
  000b7	83 c0 01	 add	 eax, 1
  000ba	74 26		 je	 SHORT $LN2@GetWinnerP
$LN29@GetWinnerP:
  000bc	8a 91 36 12 00
	00		 mov	 dl, BYTE PTR [ecx+4662]
  000c2	84 d2		 test	 dl, dl
  000c4	78 1c		 js	 SHORT $LN2@GetWinnerP
  000c6	33 c0		 xor	 eax, eax
  000c8	80 fa 07	 cmp	 dl, 7
  000cb	0f 9e c0	 setle	 al
  000ce	85 c0		 test	 eax, eax
  000d0	74 10		 je	 SHORT $LN2@GetWinnerP

; 4199 : 			{
; 4200 : 				if ( gObj[iUserIndex].Live == 1 )

  000d2	80 79 51 01	 cmp	 BYTE PTR [ecx+81], 1
  000d6	75 0a		 jne	 SHORT $LN2@GetWinnerP

; 4201 : 				{
; 4202 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == true )

  000d8	80 b9 3c 12 00
	00 01		 cmp	 BYTE PTR [ecx+4668], 1
  000df	75 01		 jne	 SHORT $LN2@GetWinnerP

; 4203 : 					{
; 4204 : 						iPartyComplete++;

  000e1	43		 inc	 ebx
$LN2@GetWinnerP:

; 4190 : 	int iUserIndex;
; 4191 : 
; 4192 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  000e2	83 c6 04	 add	 esi, 4
  000e5	83 6d 08 01	 sub	 DWORD PTR tv274[ebp], 1
  000e9	75 9c		 jne	 SHORT $LL4@GetWinnerP

; 4205 : 					}
; 4206 : 				}
; 4207 : 			}
; 4208 : 		}
; 4209 : 	}
; 4210 : 
; 4211 : 	return iPartyComplete;

  000eb	5f		 pop	 edi
  000ec	8b c3		 mov	 eax, ebx
  000ee	5b		 pop	 ebx
  000ef	5e		 pop	 esi

; 4212 : }

  000f0	5d		 pop	 ebp
  000f1	c2 04 00	 ret	 4
$LN28@GetWinnerP:

; 4187 : 		return false;

  000f4	33 c0		 xor	 eax, eax
  000f6	5e		 pop	 esi

; 4212 : }

  000f7	5d		 pop	 ebp
  000f8	c2 04 00	 ret	 4
$LN27@GetWinnerP:

; 4179 : 		return false;

  000fb	33 c0		 xor	 eax, eax

; 4212 : }

  000fd	5d		 pop	 ebp
  000fe	c2 04 00	 ret	 4
?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWinnerPartyCompleteCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z PROC		; CBloodCastle::SetBridgeWinner, COMDAT
; _this$ = ecx

; 4156 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4157 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 7a		 js	 SHORT $LN13@SetBridgeW
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 6e		 je	 SHORT $LN13@SetBridgeW

; 4159 : 
; 4160 : 	if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) != 0 )

  00016	57		 push	 edi
  00017	69 fa 0c 02 00
	00		 imul	 edi, edx, 524
  0001d	03 f9		 add	 edi, ecx
  0001f	ff b7 00 02 00
	00		 push	 DWORD PTR [edi+512]
  00025	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002a	83 c4 04	 add	 esp, 4
  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN3@SetBridgeW

; 4161 : 		return false;

  00031	32 c0		 xor	 al, al
  00033	5f		 pop	 edi

; 4172 : }

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN3@SetBridgeW:
  00038	56		 push	 esi

; 4162 : 
; 4163 : 	if ( !gObjIsConnected(iIndex))

  00039	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00042	83 c4 04	 add	 esp, 4
  00045	85 c0		 test	 eax, eax
  00047	74 25		 je	 SHORT $LN14@SetBridgeW

; 4164 : 		return false;
; 4165 : 
; 4166 : 	if ( !BC_MAP_RANGE(gObj[iIndex].MapNumber))

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004e	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00054	8a 84 01 23 01
	00 00		 mov	 al, BYTE PTR [ecx+eax+291]
  0005b	3c 34		 cmp	 al, 52			; 00000034H
  0005d	74 17		 je	 SHORT $LN5@SetBridgeW
  0005f	3c 0b		 cmp	 al, 11			; 0000000bH
  00061	72 0b		 jb	 SHORT $LN14@SetBridgeW
  00063	b1 11		 mov	 cl, 17			; 00000011H
  00065	3a c8		 cmp	 cl, al
  00067	1b c0		 sbb	 eax, eax
  00069	83 c0 01	 add	 eax, 1
  0006c	75 08		 jne	 SHORT $LN5@SetBridgeW
$LN14@SetBridgeW:
  0006e	5e		 pop	 esi

; 4167 : 		return false;

  0006f	32 c0		 xor	 al, al
  00071	5f		 pop	 edi

; 4172 : }

  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
$LN5@SetBridgeW:

; 4168 : 
; 4169 : 	this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX = iIndex;

  00076	89 b7 00 02 00
	00		 mov	 DWORD PTR [edi+512], esi

; 4170 : 
; 4171 : 	return true;

  0007c	b0 01		 mov	 al, 1
  0007e	5e		 pop	 esi
  0007f	5f		 pop	 edi

; 4172 : }

  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
$LN13@SetBridgeW:

; 4158 : 		return false;

  00084	32 c0		 xor	 al, al

; 4172 : }

  00086	5d		 pop	 ebp
  00087	c2 08 00	 ret	 8
?SetBridgeWinner@CBloodCastle@@QAE_NHH@Z ENDP		; CBloodCastle::SetBridgeWinner
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckWinnerPartyComplete, COMDAT
; _this$ = ecx

; 4118 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4119 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex) )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	0f 88 f1 00 00
	00		 js	 $LN28@CheckWinne
  0000e	33 c0		 xor	 eax, eax
  00010	83 fa 07	 cmp	 edx, 7
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	0f 84 e1 00 00
	00		 je	 $LN28@CheckWinne

; 4121 : 
; 4122 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX))

  0001e	56		 push	 esi
  0001f	69 f2 0c 02 00
	00		 imul	 esi, edx, 524
  00025	03 f1		 add	 esi, ecx
  00027	ff b6 00 02 00
	00		 push	 DWORD PTR [esi+512]
  0002d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN6@CheckWinne

; 4123 : 		return false;

  00039	32 c0		 xor	 al, al
  0003b	5e		 pop	 esi

; 4151 : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN6@CheckWinne:

; 4124 : 
; 4125 : 	int iPartyIndex = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  00040	69 8e 00 02 00
	00 40 27 00 00	 imul	 ecx, DWORD PTR [esi+512], 10048
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004f	8b 8c 01 0c 06
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+1548]

; 4126 : 	int iUserIndex;
; 4127 : 
; 4128 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  00056	85 c9		 test	 ecx, ecx
  00058	0f 88 9a 00 00
	00		 js	 $LN29@CheckWinne
  0005e	33 c0		 xor	 eax, eax
  00060	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00066	0f 9e c0	 setle	 al
  00069	85 c0		 test	 eax, eax
  0006b	0f 84 87 00 00
	00		 je	 $LN29@CheckWinne

; 4130 : 
; 4131 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  00071	8b c1		 mov	 eax, ecx
  00073	33 f6		 xor	 esi, esi
  00075	c1 e0 04	 shl	 eax, 4
  00078	2b c1		 sub	 eax, ecx
  0007a	57		 push	 edi
  0007b	53		 push	 ebx
  0007c	8d 3c 85 0c 00
	00 00		 lea	 edi, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
$LL4@CheckWinne:

; 4132 : 	{
; 4133 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  00083	8b 1f		 mov	 ebx, DWORD PTR [edi]

; 4134 : 
; 4135 : 		if ( gObjIsConnected(iUserIndex))

  00085	53		 push	 ebx
  00086	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0008b	83 c4 04	 add	 esp, 4
  0008e	85 c0		 test	 eax, eax
  00090	74 4b		 je	 SHORT $LN2@CheckWinne

; 4136 : 		{
; 4137 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00097	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  0009d	03 c8		 add	 ecx, eax
  0009f	8a 81 23 01 00
	00		 mov	 al, BYTE PTR [ecx+291]
  000a5	3c 34		 cmp	 al, 52			; 00000034H
  000a7	74 0f		 je	 SHORT $LN30@CheckWinne
  000a9	3c 0b		 cmp	 al, 11			; 0000000bH
  000ab	72 30		 jb	 SHORT $LN2@CheckWinne
  000ad	b2 11		 mov	 dl, 17			; 00000011H
  000af	3a d0		 cmp	 dl, al
  000b1	1b c0		 sbb	 eax, eax
  000b3	83 c0 01	 add	 eax, 1
  000b6	74 25		 je	 SHORT $LN2@CheckWinne
$LN30@CheckWinne:
  000b8	8a 91 36 12 00
	00		 mov	 dl, BYTE PTR [ecx+4662]
  000be	84 d2		 test	 dl, dl
  000c0	78 1b		 js	 SHORT $LN2@CheckWinne
  000c2	33 c0		 xor	 eax, eax
  000c4	80 fa 07	 cmp	 dl, 7
  000c7	0f 9e c0	 setle	 al
  000ca	85 c0		 test	 eax, eax
  000cc	74 0f		 je	 SHORT $LN2@CheckWinne

; 4138 : 			{
; 4139 : 				if ( gObj[iUserIndex].Live == 1 )

  000ce	80 79 51 01	 cmp	 BYTE PTR [ecx+81], 1
  000d2	75 09		 jne	 SHORT $LN2@CheckWinne

; 4140 : 				{
; 4141 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == false )

  000d4	80 b9 3c 12 00
	00 00		 cmp	 BYTE PTR [ecx+4668], 0
  000db	74 12		 je	 SHORT $LN24@CheckWinne
$LN2@CheckWinne:

; 4130 : 
; 4131 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  000dd	46		 inc	 esi
  000de	83 c7 04	 add	 edi, 4
  000e1	83 fe 05	 cmp	 esi, 5
  000e4	7c 9d		 jl	 SHORT $LL4@CheckWinne

; 4144 : 					}
; 4145 : 				}
; 4146 : 			}
; 4147 : 		}
; 4148 : 	}
; 4149 : 
; 4150 : 	return true;

  000e6	5b		 pop	 ebx
  000e7	5f		 pop	 edi
  000e8	b0 01		 mov	 al, 1
  000ea	5e		 pop	 esi

; 4151 : }

  000eb	5d		 pop	 ebp
  000ec	c2 04 00	 ret	 4
$LN24@CheckWinne:
  000ef	5b		 pop	 ebx
  000f0	5f		 pop	 edi

; 4142 : 					{
; 4143 : 						return false;

  000f1	32 c0		 xor	 al, al
  000f3	5e		 pop	 esi

; 4151 : }

  000f4	5d		 pop	 ebp
  000f5	c2 04 00	 ret	 4
$LN29@CheckWinne:

; 4129 : 		return true;

  000f8	b0 01		 mov	 al, 1
  000fa	5e		 pop	 esi

; 4151 : }

  000fb	5d		 pop	 ebp
  000fc	c2 04 00	 ret	 4
$LN28@CheckWinne:

; 4120 : 		return false;

  000ff	32 c0		 xor	 al, al

; 4151 : }

  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
?CheckWinnerPartyComplete@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckWinnerPartyComplete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckPartyExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckPartyExist@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckPartyExist, COMDAT
; _this$ = ecx

; 4084 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4085 : 	if ( !gObjIsConnected(iIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 07		 jne	 SHORT $LN5@CheckParty
$LN25@CheckParty:

; 4086 : 		return false;

  00014	32 c0		 xor	 al, al
  00016	5e		 pop	 esi

; 4114 : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN5@CheckParty:

; 4087 : 
; 4088 : 	int iPartyIndex = gObj[iIndex].PartyNumber;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00020	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00026	8b 8c 01 0c 06
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+1548]

; 4089 : 	int iUserIndex;
; 4090 : 
; 4091 : 	if ( !OBJMAX_RANGE(iPartyIndex))

  0002d	85 c9		 test	 ecx, ecx
  0002f	78 e3		 js	 SHORT $LN25@CheckParty
  00031	33 c0		 xor	 eax, eax
  00033	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00039	0f 9e c0	 setle	 al
  0003c	85 c0		 test	 eax, eax
  0003e	74 d4		 je	 SHORT $LN25@CheckParty

; 4092 : 		return false;
; 4093 : 
; 4094 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  00040	8b c1		 mov	 eax, ecx
  00042	33 f6		 xor	 esi, esi
  00044	c1 e0 04	 shl	 eax, 4
  00047	2b c1		 sub	 eax, ecx
  00049	57		 push	 edi
  0004a	53		 push	 ebx
  0004b	8d 3c 85 0c 00
	00 00		 lea	 edi, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
$LL4@CheckParty:

; 4095 : 	{
; 4096 : 		iUserIndex = gParty.m_PartyS[iPartyIndex].Number[iPartyUserIndex];

  00052	8b 1f		 mov	 ebx, DWORD PTR [edi]

; 4097 : 
; 4098 : 		if ( gObjIsConnected(iUserIndex))

  00054	53		 push	 ebx
  00055	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0005a	83 c4 04	 add	 esp, 4
  0005d	85 c0		 test	 eax, eax
  0005f	74 4b		 je	 SHORT $LN2@CheckParty

; 4099 : 		{
; 4100 : 			if ( BC_MAP_RANGE(gObj[iUserIndex].MapNumber) && BC_BRIDGE_RANGE(gObj[iUserIndex].m_cBloodCastleIndex) )

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  0006c	03 c8		 add	 ecx, eax
  0006e	8a 81 23 01 00
	00		 mov	 al, BYTE PTR [ecx+291]
  00074	3c 34		 cmp	 al, 52			; 00000034H
  00076	74 0f		 je	 SHORT $LN26@CheckParty
  00078	3c 0b		 cmp	 al, 11			; 0000000bH
  0007a	72 30		 jb	 SHORT $LN2@CheckParty
  0007c	b2 11		 mov	 dl, 17			; 00000011H
  0007e	3a d0		 cmp	 dl, al
  00080	1b c0		 sbb	 eax, eax
  00082	83 c0 01	 add	 eax, 1
  00085	74 25		 je	 SHORT $LN2@CheckParty
$LN26@CheckParty:
  00087	8a 91 36 12 00
	00		 mov	 dl, BYTE PTR [ecx+4662]
  0008d	84 d2		 test	 dl, dl
  0008f	78 1b		 js	 SHORT $LN2@CheckParty
  00091	33 c0		 xor	 eax, eax
  00093	80 fa 07	 cmp	 dl, 7
  00096	0f 9e c0	 setle	 al
  00099	85 c0		 test	 eax, eax
  0009b	74 0f		 je	 SHORT $LN2@CheckParty

; 4101 : 			{
; 4102 : 				if ( gObj[iUserIndex].Live == 1 )

  0009d	80 79 51 01	 cmp	 BYTE PTR [ecx+81], 1
  000a1	75 09		 jne	 SHORT $LN2@CheckParty

; 4103 : 				{
; 4104 : 					if ( gObj[iUserIndex].m_bBloodCastleComplete == false )

  000a3	80 b9 3c 12 00
	00 00		 cmp	 BYTE PTR [ecx+4668], 0
  000aa	74 12		 je	 SHORT $LN21@CheckParty
$LN2@CheckParty:

; 4092 : 		return false;
; 4093 : 
; 4094 : 	for ( int iPartyUserIndex =0;iPartyUserIndex<MAX_USER_IN_PARTY;iPartyUserIndex++)

  000ac	46		 inc	 esi
  000ad	83 c7 04	 add	 edi, 4
  000b0	83 fe 05	 cmp	 esi, 5
  000b3	7c 9d		 jl	 SHORT $LL4@CheckParty

; 4107 : 					}
; 4108 : 				}
; 4109 : 			}
; 4110 : 		}
; 4111 : 	}
; 4112 : 
; 4113 : 	return false;

  000b5	5b		 pop	 ebx
  000b6	5f		 pop	 edi
  000b7	32 c0		 xor	 al, al
  000b9	5e		 pop	 esi

; 4114 : }

  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
$LN21@CheckParty:
  000be	5b		 pop	 ebx
  000bf	5f		 pop	 edi

; 4105 : 					{
; 4106 : 						return true;

  000c0	b0 01		 mov	 al, 1
  000c2	5e		 pop	 esi

; 4114 : }

  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
?CheckPartyExist@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckPartyExist
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::CheckUserWinnerParty, COMDAT
; _this$ = ecx

; 4062 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4063 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	0f 88 8a 00 00
	00		 js	 $LN11@CheckUserW
  0000e	33 c0		 xor	 eax, eax
  00010	83 fa 07	 cmp	 edx, 7
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 7e		 je	 SHORT $LN11@CheckUserW

; 4065 : 
; 4066 : 	if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) == FALSE )

  0001a	57		 push	 edi
  0001b	69 fa 0c 02 00
	00		 imul	 edi, edx, 524
  00021	03 f9		 add	 edi, ecx
  00023	ff b7 00 02 00
	00		 push	 DWORD PTR [edi+512]
  00029	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	75 07		 jne	 SHORT $LN3@CheckUserW

; 4067 : 		return false;

  00035	32 c0		 xor	 al, al
  00037	5f		 pop	 edi

; 4079 : }

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN3@CheckUserW:
  0003c	56		 push	 esi

; 4068 : 
; 4069 : 	if ( gObjIsConnected(iIndex) == FALSE )

  0003d	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00046	83 c4 04	 add	 esp, 4
  00049	85 c0		 test	 eax, eax
  0004b	74 43		 je	 SHORT $LN5@CheckUserW

; 4070 : 		return false;
; 4071 : 
; 4072 : 	int iPartyIndex1 = gObj[iIndex].PartyNumber;

  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00053	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00059	8b 94 08 0c 06
	00 00		 mov	 edx, DWORD PTR [eax+ecx+1548]

; 4073 : 	int iPartyIndex2 = gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].PartyNumber;

  00060	69 87 00 02 00
	00 40 27 00 00	 imul	 eax, DWORD PTR [edi+512], 10048
  0006a	8b 8c 08 0c 06
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+1548]

; 4074 : 
; 4075 : 	if ( OBJMAX_RANGE(iPartyIndex1) != FALSE && iPartyIndex1 == iPartyIndex2 )

  00071	85 d2		 test	 edx, edx
  00073	78 1b		 js	 SHORT $LN5@CheckUserW
  00075	33 c0		 xor	 eax, eax
  00077	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  0007d	0f 9e c0	 setle	 al
  00080	85 c0		 test	 eax, eax
  00082	74 0c		 je	 SHORT $LN5@CheckUserW
  00084	3b d1		 cmp	 edx, ecx
  00086	75 08		 jne	 SHORT $LN5@CheckUserW

; 4076 : 		return true;

  00088	5e		 pop	 esi
  00089	b0 01		 mov	 al, 1
  0008b	5f		 pop	 edi

; 4079 : }

  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
$LN5@CheckUserW:
  00090	5e		 pop	 esi

; 4077 : 
; 4078 : 	return false;

  00091	32 c0		 xor	 al, al
  00093	5f		 pop	 edi

; 4079 : }

  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
$LN11@CheckUserW:

; 4064 : 		return false;

  00098	32 c0		 xor	 al, al

; 4079 : }

  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
?CheckUserWinnerParty@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::CheckUserWinnerParty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckWinnerValid@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerValid@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckWinnerValid, COMDAT
; _this$ = ecx

; 4014 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4015 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 88 e5 00 00
	00		 js	 $LN15@CheckWinne
  0000f	33 c0		 xor	 eax, eax
  00011	83 fe 07	 cmp	 esi, 7
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	0f 84 d5 00 00
	00		 je	 $LN15@CheckWinne

; 4021 : 	}
; 4022 : 
; 4023 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1 )

  0001f	57		 push	 edi
  00020	69 fe 0c 02 00
	00		 imul	 edi, esi, 524
  00026	03 f9		 add	 edi, ecx
  00028	8b 87 00 02 00
	00		 mov	 eax, DWORD PTR [edi+512]
  0002e	83 f8 ff	 cmp	 eax, -1
  00031	75 1a		 jne	 SHORT $LN3@CheckWinne

; 4024 : 	{
; 4025 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX == -1",

  00033	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0HC@NFIOOIHG@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@

; 4048 : 	{
; 4049 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber)",

  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00042	83 c4 08	 add	 esp, 8

; 4050 : 			iBridgeIndex+1);
; 4051 : 
; 4052 : 		return false;

  00045	32 c0		 xor	 al, al
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 4056 : }

  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN3@CheckWinne:

; 4026 : 			iBridgeIndex+1);
; 4027 : 
; 4028 : 		return false;
; 4029 : 	}
; 4030 : 
; 4031 : 	if ( !gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX) )

  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00053	83 c4 04	 add	 esp, 4
  00056	85 c0		 test	 eax, eax
  00058	75 1a		 jne	 SHORT $LN4@CheckWinne

; 4032 : 	{
; 4033 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !gObjIsConnected(m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX)",

  0005a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0005d	50		 push	 eax
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@GOGOOKAA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@

; 4048 : 	{
; 4049 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber)",

  00063	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00069	83 c4 08	 add	 esp, 8

; 4050 : 			iBridgeIndex+1);
; 4051 : 
; 4052 : 		return false;

  0006c	32 c0		 xor	 al, al
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi

; 4056 : }

  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN4@CheckWinne:

; 4034 : 			iBridgeIndex+1);
; 4035 : 
; 4036 : 		return false;
; 4037 : 	}
; 4038 : 
; 4039 : 	if ( gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleSubIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex != iBridgeIndex )

  00074	69 8f 00 02 00
	00 40 27 00 00	 imul	 ecx, DWORD PTR [edi+512], 10048
  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00083	03 c8		 add	 ecx, eax
  00085	8a 81 36 12 00
	00		 mov	 al, BYTE PTR [ecx+4662]
  0008b	3c ff		 cmp	 al, -1
  0008d	74 4b		 je	 SHORT $LN6@CheckWinne
  0008f	80 b9 37 12 00
	00 ff		 cmp	 BYTE PTR [ecx+4663], -1
  00096	74 42		 je	 SHORT $LN6@CheckWinne
  00098	0f be c0	 movsx	 eax, al
  0009b	3b c6		 cmp	 eax, esi
  0009d	75 3b		 jne	 SHORT $LN6@CheckWinne

; 4042 : 			iBridgeIndex+1);
; 4043 : 
; 4044 : 		return false;
; 4045 : 	}
; 4046 : 
; 4047 : 	if ( !BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber) )

  0009f	8a 81 23 01 00
	00		 mov	 al, BYTE PTR [ecx+291]
  000a5	3c 34		 cmp	 al, 52			; 00000034H
  000a7	74 29		 je	 SHORT $LN7@CheckWinne
  000a9	3c 0b		 cmp	 al, 11			; 0000000bH
  000ab	72 0b		 jb	 SHORT $LN16@CheckWinne
  000ad	b1 11		 mov	 cl, 17			; 00000011H
  000af	3a c8		 cmp	 cl, al
  000b1	1b c0		 sbb	 eax, eax
  000b3	83 c0 01	 add	 eax, 1
  000b6	75 1a		 jne	 SHORT $LN7@CheckWinne
$LN16@CheckWinne:

; 4048 : 	{
; 4049 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber)",

  000b8	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000bb	50		 push	 eax
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0JA@CMOHDFEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c7	83 c4 08	 add	 esp, 8

; 4050 : 			iBridgeIndex+1);
; 4051 : 
; 4052 : 		return false;

  000ca	32 c0		 xor	 al, al
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi

; 4056 : }

  000ce	5d		 pop	 ebp
  000cf	c2 04 00	 ret	 4
$LN7@CheckWinne:
  000d2	5f		 pop	 edi

; 4053 : 	}
; 4054 : 
; 4055 : 	return true;

  000d3	b0 01		 mov	 al, 1
  000d5	5e		 pop	 esi

; 4056 : }

  000d6	5d		 pop	 ebp
  000d7	c2 04 00	 ret	 4
$LN6@CheckWinne:

; 4040 : 	{
; 4041 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - (gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].m_cBloodCastleIndex == -1) ...",

  000da	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000dd	50		 push	 eax
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0JC@KJKEDLHF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@

; 4048 : 	{
; 4049 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_BLOODCASTLE(gObj[m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX].MapNumber)",

  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e9	83 c4 08	 add	 esp, 8

; 4050 : 			iBridgeIndex+1);
; 4051 : 
; 4052 : 		return false;

  000ec	32 c0		 xor	 al, al
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi

; 4056 : }

  000f0	5d		 pop	 ebp
  000f1	c2 04 00	 ret	 4
$LN15@CheckWinne:

; 4016 : 	{
; 4017 : 		LogAddTD("[Blood Castle] (%d) CBloodCastle::CheckWinnerValid() - !CHECK_LIMIT(iBridgeIndex, MAX_BLOODCASTLE_BRIDGE_COUNT)",

  000f4	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000f7	50		 push	 eax
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0HA@BEDGBNCH@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5CBloodCastle@
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00103	83 c4 08	 add	 esp, 8

; 4018 : 			iBridgeIndex+1);
; 4019 : 
; 4020 : 		return false;

  00106	32 c0		 xor	 al, al
  00108	5e		 pop	 esi

; 4056 : }

  00109	5d		 pop	 ebp
  0010a	c2 04 00	 ret	 4
?CheckWinnerValid@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckWinnerValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckWinnerExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckWinnerExist@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckWinnerExist, COMDAT
; _this$ = ecx

; 4001 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4002 : 	if ( !BC_BRIDGE_RANGE(iBridgeIndex))

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 21		 js	 SHORT $LN7@CheckWinne
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 15		 je	 SHORT $LN7@CheckWinne

; 4004 : 
; 4005 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_COMPLETE_USER_INDEX != -1 )

  00016	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0001c	83 bc 08 00 02
	00 00 ff	 cmp	 DWORD PTR [eax+ecx+512], -1
  00024	0f 95 c0	 setne	 al

; 4006 : 		return true;
; 4007 : 
; 4008 : 	return false;
; 4009 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN7@CheckWinne:

; 4003 : 		return false;

  0002b	32 c0		 xor	 al, al

; 4006 : 		return true;
; 4007 : 
; 4008 : 	return false;
; 4009 : }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?CheckWinnerExist@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckWinnerExist
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckUserHaveUlimateWeapon, COMDAT
; _this$ = ecx

; 3971 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3972 : 	if ( OBJMAX_RANGE(iIndex ) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	0f 88 9c 00 00
	00		 js	 $LN18@CheckUserH
  0000e	33 c0		 xor	 eax, eax
  00010	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 89 00 00
	00		 je	 $LN18@CheckUserH

; 3975 : 	}
; 3976 : 
; 3977 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00021	57		 push	 edi
  00022	69 f9 40 27 00
	00		 imul	 edi, ecx, 10048
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	80 7c 0f 50 01	 cmp	 BYTE PTR [edi+ecx+80], 1
  00033	75 6e		 jne	 SHORT $LN7@CheckUserH
  00035	83 7c 0f 04 02	 cmp	 DWORD PTR [edi+ecx+4], 2
  0003a	7e 67		 jle	 SHORT $LN7@CheckUserH

; 3980 : 	}
; 3981 : 
; 3982 : 	bool bRetVal = false;

  0003c	53		 push	 ebx
  0003d	56		 push	 esi
  0003e	32 db		 xor	 bl, bl
  00040	33 f6		 xor	 esi, esi
$LL4@CheckUserH:

; 3985 : 	{
; 3986 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00042	8b 8c 0f c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+4544]
  00049	03 ce		 add	 ecx, esi
  0004b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	83 f8 01	 cmp	 eax, 1
  00059	75 26		 jne	 SHORT $LN2@CheckUserH

; 3987 : 		{
; 3988 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(0,19) || gObj[iIndex].pInventory[x].m_Type == ITEMGET(5,10) || gObj[iIndex].pInventory[x].m_Type == ITEMGET(4,18) )

  0005b	8b 84 0f c0 11
	00 00		 mov	 eax, DWORD PTR [edi+ecx+4544]
  00062	0f b7 44 30 06	 movzx	 eax, WORD PTR [eax+esi+6]
  00067	66 83 f8 13	 cmp	 ax, 19			; 00000013H
  0006b	74 2b		 je	 SHORT $LN10@CheckUserH
  0006d	ba 0a 0a 00 00	 mov	 edx, 2570		; 00000a0aH
  00072	66 3b c2	 cmp	 ax, dx
  00075	74 21		 je	 SHORT $LN10@CheckUserH
  00077	ba 12 08 00 00	 mov	 edx, 2066		; 00000812H
  0007c	66 3b c2	 cmp	 ax, dx
  0007f	74 17		 je	 SHORT $LN10@CheckUserH
$LN2@CheckUserH:

; 3983 : 
; 3984 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  00081	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00087	81 fe 44 c4 00
	00		 cmp	 esi, 50244		; 0000c444H
  0008d	7c b3		 jl	 SHORT $LL4@CheckUserH

; 3991 : 				break;
; 3992 : 			}
; 3993 : 		}
; 3994 : 	}
; 3995 : 
; 3996 : 	return bRetVal;

  0008f	5e		 pop	 esi
  00090	8a c3		 mov	 al, bl
  00092	5b		 pop	 ebx
  00093	5f		 pop	 edi

; 3997 : }

  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
$LN10@CheckUserH:

; 3989 : 			{
; 3990 : 				bRetVal = true;

  00098	b3 01		 mov	 bl, 1
  0009a	5e		 pop	 esi

; 3991 : 				break;
; 3992 : 			}
; 3993 : 		}
; 3994 : 	}
; 3995 : 
; 3996 : 	return bRetVal;

  0009b	8a c3		 mov	 al, bl
  0009d	5b		 pop	 ebx
  0009e	5f		 pop	 edi

; 3997 : }

  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
$LN7@CheckUserH:

; 3978 : 	{
; 3979 : 		return false;

  000a3	32 c0		 xor	 al, al
  000a5	5f		 pop	 edi

; 3997 : }

  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
$LN18@CheckUserH:

; 3973 : 	{
; 3974 : 		return false;

  000aa	32 c0		 xor	 al, al

; 3997 : }

  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
?CheckUserHaveUlimateWeapon@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckUserHaveUlimateWeapon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_lpItem$ = 12						; size = 4
?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z PROC ; CBloodCastle::CheckQuestItemSerial, COMDAT
; _this$ = ecx

; 1626 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1627 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 75		 js	 SHORT $LN13@CheckQuest
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 69		 je	 SHORT $LN13@CheckQuest

; 1630 : 	}
; 1631 : 
; 1632 : 	if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == -1 )

  00016	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0001c	83 bc 08 90 01
	00 00 ff	 cmp	 DWORD PTR [eax+ecx+400], -1
  00024	57		 push	 edi
  00025	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  00028	75 07		 jne	 SHORT $LN3@CheckQuest

; 1633 : 	{
; 1634 : 		return false;

  0002a	32 c0		 xor	 al, al
  0002c	5f		 pop	 edi

; 1655 : 
; 1656 : }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
$LN3@CheckQuest:
  00031	53		 push	 ebx
  00032	56		 push	 esi

; 1635 : 	}
; 1636 : 	
; 1637 : 	if ( lpItem->IsItem() == TRUE )

  00033	8b 75 0c	 mov	 esi, DWORD PTR _lpItem$[ebp]
  00036	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00039	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003e	83 f8 01	 cmp	 eax, 1
  00041	75 33		 jne	 SHORT $LN7@CheckQuest

; 1638 : 	{
; 1639 : 		if ( lpItem->m_Type == ITEMGET(13,19) ) // Absolute Weapon

  00043	b8 13 1a 00 00	 mov	 eax, 6675		; 00001a13H
  00048	66 39 46 0a	 cmp	 WORD PTR [esi+10], ax
  0004c	75 28		 jne	 SHORT $LN7@CheckQuest

; 1640 : 		{
; 1641 : 			int iLEVEL = lpItem->m_Level;

  0004e	0f bf 4e 0c	 movsx	 ecx, WORD PTR [esi+12]

; 1642 : 
; 1643 : 			if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  00052	85 c9		 test	 ecx, ecx
  00054	78 20		 js	 SHORT $LN7@CheckQuest
  00056	33 c0		 xor	 eax, eax
  00058	83 f9 02	 cmp	 ecx, 2
  0005b	0f 9e c0	 setle	 al
  0005e	85 c0		 test	 eax, eax
  00060	74 14		 je	 SHORT $LN7@CheckQuest

; 1644 : 			{
; 1645 : 				if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == lpItem->m_Number )

  00062	8b 87 90 01 00
	00		 mov	 eax, DWORD PTR [edi+400]
  00068	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0006b	75 09		 jne	 SHORT $LN7@CheckQuest

; 1646 : 				{
; 1647 : 					return true;

  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	b0 01		 mov	 al, 1
  00071	5f		 pop	 edi

; 1655 : 
; 1656 : }

  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
$LN7@CheckQuest:
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx

; 1648 : 				}
; 1649 : 			}
; 1650 : 		}
; 1651 : 	}
; 1652 : 	
; 1653 : 
; 1654 : 	return false;

  00078	32 c0		 xor	 al, al
  0007a	5f		 pop	 edi

; 1655 : 
; 1656 : }

  0007b	5d		 pop	 ebp
  0007c	c2 08 00	 ret	 8
$LN13@CheckQuest:

; 1628 : 	{
; 1629 : 		return false;

  0007f	32 c0		 xor	 al, al

; 1655 : 
; 1656 : }

  00081	5d		 pop	 ebp
  00082	c2 08 00	 ret	 8
?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ENDP ; CBloodCastle::CheckQuestItemSerial
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckPlayStart@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckPlayStart@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckPlayStart, COMDAT
; _this$ = ecx

; 1664 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1665 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 1d		 js	 SHORT $LN6@CheckPlayS
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 11		 je	 SHORT $LN6@CheckPlayS

; 1668 : 	}
; 1669 : 
; 1670 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_PLAY_START;

  00016	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0001c	8a 84 08 65 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+357]

; 1671 : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN6@CheckPlayS:

; 1666 : 	{
; 1667 : 		return false;

  00027	32 c0		 xor	 al, al

; 1671 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?CheckPlayStart@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckPlayStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckCanParty@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckCanParty@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckCanParty, COMDAT
; _this$ = ecx

; 1610 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1611 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 1d		 js	 SHORT $LN6@CheckCanPa
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 11		 je	 SHORT $LN6@CheckCanPa

; 1614 : 	}
; 1615 : 
; 1616 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_CAN_PARTY;

  00016	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0001c	8a 84 08 64 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+356]

; 1617 : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN6@CheckCanPa:

; 1612 : 	{
; 1613 : 		return false;

  00027	32 c0		 xor	 al, al

; 1617 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?CheckCanParty@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckCanParty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckCanEnter@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckCanEnter@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckCanEnter, COMDAT
; _this$ = ecx

; 1595 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1596 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 1d		 js	 SHORT $LN6@CheckCanEn
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 11		 je	 SHORT $LN6@CheckCanEn

; 1599 : 	}
; 1600 : 
; 1601 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_CAN_ENTER;

  00016	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0001c	8a 84 08 63 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+355]

; 1602 : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN6@CheckCanEn:

; 1597 : 	{
; 1598 : 		return false;

  00027	32 c0		 xor	 al, al

; 1602 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?CheckCanEnter@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckCanEnter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckWalk@CBloodCastle@@QAE_NHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iMoveX$ = 12						; size = 4
_iMoveY$ = 16						; size = 4
?CheckWalk@CBloodCastle@@QAE_NHHH@Z PROC		; CBloodCastle::CheckWalk, COMDAT
; _this$ = ecx

; 1560 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	78 38		 js	 SHORT $LN16@CheckWalk
  0000d	33 c0		 xor	 eax, eax
  0000f	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00015	0f 9e c0	 setle	 al
  00018	85 c0		 test	 eax, eax
  0001a	74 29		 je	 SHORT $LN16@CheckWalk

; 1562 : 	{
; 1563 : 		return false;
; 1564 : 	}
; 1565 : 	
; 1566 : 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) == FALSE )

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00021	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00027	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  0002a	8a 8a 23 01 00
	00		 mov	 cl, BYTE PTR [edx+291]
  00030	80 f9 34	 cmp	 cl, 52			; 00000034H
  00033	74 17		 je	 SHORT $LN3@CheckWalk
  00035	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00038	72 0b		 jb	 SHORT $LN16@CheckWalk
  0003a	b0 11		 mov	 al, 17			; 00000011H
  0003c	3a c1		 cmp	 al, cl
  0003e	1b c0		 sbb	 eax, eax
  00040	83 c0 01	 add	 eax, 1
  00043	75 07		 jne	 SHORT $LN3@CheckWalk
$LN16@CheckWalk:

; 1567 : 	{
; 1568 : 		return false;

  00045	32 c0		 xor	 al, al
  00047	5f		 pop	 edi

; 1587 : }

  00048	5d		 pop	 ebp
  00049	c2 0c 00	 ret	 12			; 0000000cH
$LN3@CheckWalk:

; 1569 : 	}
; 1570 : 
; 1571 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  0004c	80 7a 50 01	 cmp	 BYTE PTR [edx+80], 1
  00050	75 f3		 jne	 SHORT $LN16@CheckWalk
  00052	83 7a 04 02	 cmp	 DWORD PTR [edx+4], 2
  00056	7e ed		 jle	 SHORT $LN16@CheckWalk

; 1572 : 	{
; 1573 : 		return false;
; 1574 : 	}
; 1575 : 
; 1576 : 	if ( this->GetCurrentState(GetBridgeLevel(gObj[iIndex].MapNumber)) == TRUE )

  00058	56		 push	 esi
  00059	0f b6 f1	 movzx	 esi, cl
  0005c	8b cf		 mov	 ecx, edi
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  00064	50		 push	 eax
  00065	8b cf		 mov	 ecx, edi
  00067	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  0006c	83 f8 01	 cmp	 eax, 1
  0006f	75 23		 jne	 SHORT $LN7@CheckWalk

; 1577 : 	{
; 1578 : 		BYTE btMapAttr = MapC[gObj[iIndex].MapNumber].GetAttr(iMoveX, iMoveY);

  00071	ff 75 10	 push	 DWORD PTR _iMoveY$[ebp]
  00074	69 ce 28 38 05
	00		 imul	 ecx, esi, 342056
  0007a	ff 75 0c	 push	 DWORD PTR _iMoveX$[ebp]
  0007d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00083	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 1579 : 
; 1580 : 		if ( (btMapAttr&1) != 1 )

  00088	a8 01		 test	 al, 1
  0008a	75 08		 jne	 SHORT $LN7@CheckWalk

; 1581 : 		{
; 1582 : 			return true;

  0008c	5e		 pop	 esi
  0008d	b0 01		 mov	 al, 1
  0008f	5f		 pop	 edi

; 1587 : }

  00090	5d		 pop	 ebp
  00091	c2 0c 00	 ret	 12			; 0000000cH
$LN7@CheckWalk:
  00094	5e		 pop	 esi

; 1583 : 		}
; 1584 : 	}
; 1585 : 
; 1586 : 	return false;

  00095	32 c0		 xor	 al, al
  00097	5f		 pop	 edi

; 1587 : }

  00098	5d		 pop	 ebp
  00099	c2 0c 00	 ret	 12			; 0000000cH
?CheckWalk@CBloodCastle@@QAE_NHHH@Z ENDP		; CBloodCastle::CheckWalk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckQuestItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv297 = -4						; size = 4
tv300 = 8						; size = 4
_iIndex$ = 8						; size = 4
?CheckQuestItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckQuestItem, COMDAT
; _this$ = ecx

; 1504 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1505 : 	int iITEM_LEVEL = -1;
; 1506 : 
; 1507 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00004	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	85 d2		 test	 edx, edx
  0000c	0f 88 14 01 00
	00		 js	 $LN27@CheckQuest
  00012	33 c0		 xor	 eax, eax
  00014	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 01 01 00
	00		 je	 $LN27@CheckQuest

; 1510 : 	}
; 1511 : 
; 1512 : 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) == FALSE )

  00025	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  0002b	53		 push	 ebx
  0002c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00032	89 45 08	 mov	 DWORD PTR tv300[ebp], eax
  00035	8a 8c 18 23 01
	00 00		 mov	 cl, BYTE PTR [eax+ebx+291]
  0003c	80 f9 34	 cmp	 cl, 52			; 00000034H
  0003f	74 18		 je	 SHORT $LN6@CheckQuest
  00041	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00044	0f 82 d1 00 00
	00		 jb	 $LN9@CheckQuest
  0004a	b0 11		 mov	 al, 17			; 00000011H
  0004c	3a c1		 cmp	 al, cl
  0004e	1b c0		 sbb	 eax, eax
  00050	83 c0 01	 add	 eax, 1
  00053	0f 84 c2 00 00
	00		 je	 $LN9@CheckQuest
$LN6@CheckQuest:

; 1513 : 	{
; 1514 : 		return -1;
; 1515 : 	}
; 1516 : 
; 1517 : 	int BridgeIndex = GetBridgeLevel(gObj[iIndex].MapNumber);

  00059	0f b6 c1	 movzx	 eax, cl
  0005c	8b ce		 mov	 ecx, esi
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel

; 1518 : 
; 1519 : 	if ( this->m_BridgeData[BridgeIndex].m_nBC_QUESTITEM_SERIAL == -1 )

  00064	69 c0 0c 02 00
	00		 imul	 eax, eax, 524
  0006a	05 90 01 00 00	 add	 eax, 400		; 00000190H
  0006f	03 c6		 add	 eax, esi
  00071	89 45 fc	 mov	 DWORD PTR tv297[ebp], eax
  00074	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00077	0f 84 9e 00 00
	00		 je	 $LN9@CheckQuest

; 1520 : 	{
; 1521 : 		return -1;
; 1522 : 	}
; 1523 : 
; 1524 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  0007d	8b 55 08	 mov	 edx, DWORD PTR tv300[ebp]
  00080	80 7c 1a 50 01	 cmp	 BYTE PTR [edx+ebx+80], 1
  00085	0f 85 90 00 00
	00		 jne	 $LN9@CheckQuest
  0008b	83 7c 1a 04 02	 cmp	 DWORD PTR [edx+ebx+4], 2
  00090	0f 8e 85 00 00
	00		 jle	 $LN9@CheckQuest

; 1527 : 	}
; 1528 : 
; 1529 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  00096	57		 push	 edi
  00097	33 ff		 xor	 edi, edi
  00099	33 f6		 xor	 esi, esi
  0009b	0f 1f 44 00 00	 npad	 5
$LL4@CheckQuest:

; 1530 : 	{
; 1531 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  000a0	8b 8c 1a c0 11
	00 00		 mov	 ecx, DWORD PTR [edx+ebx+4544]
  000a7	03 ce		 add	 ecx, esi
  000a9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ae	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1532 : 		{
; 1533 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) ) // Absolute Weapon of Archangel QUEST ITEM

  000b4	8b 55 08	 mov	 edx, DWORD PTR tv300[ebp]
  000b7	83 f8 01	 cmp	 eax, 1
  000ba	75 1d		 jne	 SHORT $LN2@CheckQuest
  000bc	8b 84 1a c0 11
	00 00		 mov	 eax, DWORD PTR [edx+ebx+4544]
  000c3	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  000c8	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  000cd	75 0a		 jne	 SHORT $LN2@CheckQuest

; 1534 : 			{
; 1535 : 				if ( gObj[iIndex].pInventory[x].m_Number	== this->m_BridgeData[BridgeIndex].m_nBC_QUESTITEM_SERIAL )

  000cf	8b 4d fc	 mov	 ecx, DWORD PTR tv297[ebp]
  000d2	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  000d5	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000d7	74 1b		 je	 SHORT $LN23@CheckQuest
$LN2@CheckQuest:

; 1527 : 	}
; 1528 : 
; 1529 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  000d9	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  000df	47		 inc	 edi
  000e0	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  000e6	7c b8		 jl	 SHORT $LL4@CheckQuest
  000e8	5f		 pop	 edi
  000e9	5b		 pop	 ebx
  000ea	83 c8 ff	 or	 eax, -1
  000ed	5e		 pop	 esi

; 1540 : 					{
; 1541 : 						iITEM_LEVEL = -1;
; 1542 : 						
; 1543 : 					}
; 1544 : 
; 1545 : 					break;
; 1546 : 				}
; 1547 : 			}
; 1548 : 		}
; 1549 : 	}
; 1550 : 
; 1551 : 	return iITEM_LEVEL;
; 1552 : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 04 00	 ret	 4
$LN23@CheckQuest:

; 1536 : 				{
; 1537 : 					iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  000f4	8b 84 1a c0 11
	00 00		 mov	 eax, DWORD PTR [edx+ebx+4544]
  000fb	69 cf d4 00 00
	00		 imul	 ecx, edi, 212
  00101	0f bf 44 08 08	 movsx	 eax, WORD PTR [eax+ecx+8]

; 1538 : 
; 1539 : 					if ( iITEM_LEVEL < 0 || iITEM_LEVEL > 2 )

  00106	85 c0		 test	 eax, eax
  00108	78 05		 js	 SHORT $LN30@CheckQuest
  0010a	83 f8 02	 cmp	 eax, 2
  0010d	7e 03		 jle	 SHORT $LN29@CheckQuest
$LN30@CheckQuest:
  0010f	83 c8 ff	 or	 eax, -1
$LN29@CheckQuest:
  00112	5f		 pop	 edi
  00113	5b		 pop	 ebx
  00114	5e		 pop	 esi

; 1540 : 					{
; 1541 : 						iITEM_LEVEL = -1;
; 1542 : 						
; 1543 : 					}
; 1544 : 
; 1545 : 					break;
; 1546 : 				}
; 1547 : 			}
; 1548 : 		}
; 1549 : 	}
; 1550 : 
; 1551 : 	return iITEM_LEVEL;
; 1552 : }

  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 04 00	 ret	 4
$LN9@CheckQuest:
  0011b	5b		 pop	 ebx

; 1525 : 	{
; 1526 : 		return -1;

  0011c	83 c8 ff	 or	 eax, -1
  0011f	5e		 pop	 esi

; 1540 : 					{
; 1541 : 						iITEM_LEVEL = -1;
; 1542 : 						
; 1543 : 					}
; 1544 : 
; 1545 : 					break;
; 1546 : 				}
; 1547 : 			}
; 1548 : 		}
; 1549 : 	}
; 1550 : 
; 1551 : 	return iITEM_LEVEL;
; 1552 : }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 04 00	 ret	 4
$LN27@CheckQuest:

; 1508 : 	{
; 1509 : 		return -1;

  00126	83 c8 ff	 or	 eax, -1
  00129	5e		 pop	 esi

; 1540 : 					{
; 1541 : 						iITEM_LEVEL = -1;
; 1542 : 						
; 1543 : 					}
; 1544 : 
; 1545 : 					break;
; 1546 : 				}
; 1547 : 			}
; 1548 : 		}
; 1549 : 	}
; 1550 : 
; 1551 : 	return iITEM_LEVEL;
; 1552 : }

  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 04 00	 ret	 4
?CheckQuestItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckQuestItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckEnterItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
tv234 = 8						; size = 4
_iIndex$ = 8						; size = 4
?CheckEnterItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckEnterItem, COMDAT
; _this$ = ecx

; 1454 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1455 : 	int iITEM_LEVEL = 0;
; 1456 : 
; 1457 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	56		 push	 esi
  00007	33 f6		 xor	 esi, esi
  00009	85 c9		 test	 ecx, ecx
  0000b	0f 88 b6 00 00
	00		 js	 $LN7@CheckEnter
  00011	33 c0		 xor	 eax, eax
  00013	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 a3 00 00
	00		 je	 $LN7@CheckEnter

; 1458 : 	{
; 1459 : 		return 0;
; 1460 : 	}
; 1461 : 
; 1462 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00024	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	80 7c 08 50 01	 cmp	 BYTE PTR [eax+ecx+80], 1
  00035	0f 85 8c 00 00
	00		 jne	 $LN7@CheckEnter
  0003b	83 7c 08 04 02	 cmp	 DWORD PTR [eax+ecx+4], 2
  00040	0f 8e 81 00 00
	00		 jle	 $LN7@CheckEnter

; 1465 : 	}
; 1466 : 
; 1467 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  00046	53		 push	 ebx
  00047	57		 push	 edi
  00048	8d 98 c0 11 00
	00		 lea	 ebx, DWORD PTR [eax+4544]
  0004e	c7 45 08 12 1a
	00 00		 mov	 DWORD PTR tv234[ebp], 6674 ; 00001a12H
  00055	33 ff		 xor	 edi, edi
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@CheckEnter:

; 1468 : 	{
; 1469 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00060	8b 0c 0b	 mov	 ecx, DWORD PTR [ebx+ecx]
  00063	03 cf		 add	 ecx, edi
  00065	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00070	83 f8 01	 cmp	 eax, 1
  00073	75 3b		 jne	 SHORT $LN2@CheckEnter

; 1470 : 		{
; 1471 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,18) ) // Invisibility Cloak

  00075	8b 04 0b	 mov	 eax, DWORD PTR [ebx+ecx]
  00078	0f b7 54 38 06	 movzx	 edx, WORD PTR [eax+edi+6]
  0007d	66 3b 55 08	 cmp	 dx, WORD PTR tv234[ebp]
  00081	75 1d		 jne	 SHORT $LN11@CheckEnter

; 1472 : 			{
; 1473 : 				iITEM_LEVEL = gObj[iIndex].pInventory[x].m_Level;

  00083	0f bf 74 38 08	 movsx	 esi, WORD PTR [eax+edi+8]

; 1474 : 
; 1475 : 				if ( CHECK_LIMIT(iITEM_LEVEL, MAX_CLOACK_LEVEL) == FALSE )

  00088	85 f6		 test	 esi, esi
  0008a	78 12		 js	 SHORT $LN24@CheckEnter
  0008c	33 c0		 xor	 eax, eax
  0008e	83 fe 08	 cmp	 esi, 8
  00091	0f 9e c0	 setle	 al
  00094	85 c0		 test	 eax, eax
  00096	74 06		 je	 SHORT $LN24@CheckEnter

; 1478 : 
; 1479 : 				}
; 1480 : 
; 1481 : 				if ( iITEM_LEVEL != 0 )

  00098	85 f6		 test	 esi, esi
  0009a	75 22		 jne	 SHORT $LN25@CheckEnter
  0009c	eb 02		 jmp	 SHORT $LN11@CheckEnter
$LN24@CheckEnter:

; 1476 : 				{
; 1477 : 					iITEM_LEVEL = 0;

  0009e	33 f6		 xor	 esi, esi
$LN11@CheckEnter:

; 1482 : 				{
; 1483 : 					return iITEM_LEVEL;
; 1484 : 				}
; 1485 : 			}
; 1486 : 			
; 1487 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,47) ) // 

  000a0	b8 2f 1a 00 00	 mov	 eax, 6703		; 00001a2fH
  000a5	66 3b d0	 cmp	 dx, ax
  000a8	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  000ad	0f 44 f0	 cmove	 esi, eax
$LN2@CheckEnter:

; 1465 : 	}
; 1466 : 
; 1467 : 	for ( int x=0;x<MAIN_INVENTORY_SIZE;x++)

  000b0	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  000b6	81 ff f0 a8 00
	00		 cmp	 edi, 43248		; 0000a8f0H
  000bc	7c a2		 jl	 SHORT $LL4@CheckEnter
$LN25@CheckEnter:
  000be	5f		 pop	 edi
  000bf	5b		 pop	 ebx

; 1488 : 			{
; 1489 : 				iITEM_LEVEL = 10;
; 1490 : 			}
; 1491 : 		}
; 1492 : 	}
; 1493 : 
; 1494 : 	return iITEM_LEVEL;

  000c0	8b c6		 mov	 eax, esi
  000c2	5e		 pop	 esi

; 1495 : }

  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
$LN7@CheckEnter:

; 1463 : 	{
; 1464 : 		return 0;

  000c7	33 c0		 xor	 eax, eax
  000c9	5e		 pop	 esi

; 1495 : }

  000ca	5d		 pop	 ebp
  000cb	c2 04 00	 ret	 4
?CheckEnterItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckEnterItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckEnterFreeTicket, COMDAT
; _this$ = ecx

; 1129 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1130 : 	if ( !OBJMAX_RANGE(iIndex) )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	0f 88 81 00 00
	00		 js	 $LN18@CheckEnter
  0000e	33 c0		 xor	 eax, eax
  00010	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	74 72		 je	 SHORT $LN18@CheckEnter

; 1132 : 
; 1133 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  0001d	57		 push	 edi
  0001e	69 f9 40 27 00
	00		 imul	 edi, ecx, 10048
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	80 7c 0f 50 01	 cmp	 BYTE PTR [edi+ecx+80], 1
  0002f	75 57		 jne	 SHORT $LN7@CheckEnter
  00031	83 7c 0f 04 02	 cmp	 DWORD PTR [edi+ecx+4], 2
  00036	7e 50		 jle	 SHORT $LN7@CheckEnter

; 1135 : 
; 1136 : 	for (int x=0;x<MAIN_INVENTORY_SIZE;x++)

  00038	53		 push	 ebx
  00039	56		 push	 esi
  0003a	33 f6		 xor	 esi, esi
  0003c	bb 2f 1a 00 00	 mov	 ebx, 6703		; 00001a2fH
$LL4@CheckEnter:

; 1137 : 	{
; 1138 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00041	8b 8c 0f c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+4544]
  00048	03 ce		 add	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	83 f8 01	 cmp	 eax, 1
  00058	75 0e		 jne	 SHORT $LN2@CheckEnter

; 1139 : 		{
; 1140 : 			if ( gObj[iIndex].pInventory [x].m_Type == ITEMGET(13,47) )

  0005a	8b 84 0f c0 11
	00 00		 mov	 eax, DWORD PTR [edi+ecx+4544]
  00061	66 39 5c 30 06	 cmp	 WORD PTR [eax+esi+6], bx
  00066	74 17		 je	 SHORT $LN14@CheckEnter
$LN2@CheckEnter:

; 1135 : 
; 1136 : 	for (int x=0;x<MAIN_INVENTORY_SIZE;x++)

  00068	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  0006e	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  00074	7c cb		 jl	 SHORT $LL4@CheckEnter

; 1143 : 			}
; 1144 : 		}
; 1145 : 	}
; 1146 : 
; 1147 : 	return false;

  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	32 c0		 xor	 al, al
  0007a	5f		 pop	 edi

; 1148 : }

  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
$LN14@CheckEnter:
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx

; 1141 : 			{
; 1142 : 				return true;

  00081	b0 01		 mov	 al, 1
  00083	5f		 pop	 edi

; 1148 : }

  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
$LN7@CheckEnter:

; 1134 : 		return false;

  00088	32 c0		 xor	 al, al
  0008a	5f		 pop	 edi

; 1148 : }

  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
$LN18@CheckEnter:

; 1131 : 		return false;

  0008f	32 c0		 xor	 al, al

; 1148 : }

  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
?CheckEnterFreeTicket@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckEnterFreeTicket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iLevel$ = 12						; size = 4
?CheckEnterLevel@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CheckEnterLevel, COMDAT
; _this$ = ecx

; 1076 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1077 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	0f 88 bb 00 00
	00		 js	 $LN17@CheckEnter
  0000e	33 c0		 xor	 eax, eax
  00010	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 a8 00 00
	00		 je	 $LN17@CheckEnter

; 1080 : 	}
; 1081 : 
; 1082 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  0002c	03 c1		 add	 eax, ecx
  0002e	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  00032	0f 85 91 00 00
	00		 jne	 $LN17@CheckEnter
  00038	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0003c	0f 8e 87 00 00
	00		 jle	 $LN17@CheckEnter

; 1083 : 	{
; 1084 : 		return 2;
; 1085 : 	}
; 1086 : 
; 1087 : 	if ( gObj[iIndex].Class == CLASS_DARKLORD || gObj[iIndex].Class == CLASS_MAGUMSA || gObj[iIndex].Class == CLASS_FIGHTER )

  00042	0f b7 88 90 00
	00 00		 movzx	 ecx, WORD PTR [eax+144]
  00049	83 f9 04	 cmp	 ecx, 4
  0004c	74 3e		 je	 SHORT $LN7@CheckEnter
  0004e	83 f9 03	 cmp	 ecx, 3
  00051	74 39		 je	 SHORT $LN7@CheckEnter
  00053	83 f9 06	 cmp	 ecx, 6
  00056	74 34		 je	 SHORT $LN7@CheckEnter

; 1102 : 		}
; 1103 : 	}
; 1104 : 	else
; 1105 : 	{
; 1106 : 		if ( gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND && gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  00058	0f bf 88 96 00
	00 00		 movsx	 ecx, WORD PTR [eax+150]
  0005f	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00062	c1 e0 04	 shl	 eax, 4
  00065	8b 90 f0 ff ff
	ff		 mov	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax-16]
  0006b	3b ca		 cmp	 ecx, edx
  0006d	7c 46		 jl	 SHORT $LN21@CheckEnter
  0006f	3b 88 f4 ff ff
	ff		 cmp	 ecx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax-12]
  00075	7e 34		 jle	 SHORT $LN23@CheckEnter

; 1107 : 		{
; 1108 : 			return 0;
; 1109 : 		}
; 1110 : 
; 1111 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND )

  00077	3b ca		 cmp	 ecx, edx
  00079	7c 3a		 jl	 SHORT $LN21@CheckEnter

; 1112 : 		{
; 1113 : 			return -1;
; 1114 : 		}
; 1115 : 
; 1116 : 		if ( gObj[iIndex].Level > g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND )

  0007b	3b 88 f4 ff ff
	ff		 cmp	 ecx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax-12]
  00081	7e 46		 jle	 SHORT $LN17@CheckEnter

; 1117 : 		{
; 1118 : 			return 1;

  00083	b8 01 00 00 00	 mov	 eax, 1

; 1119 : 		}
; 1120 : 	}
; 1121 : 
; 1122 : 	return 2;
; 1123 : }

  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
$LN7@CheckEnter:

; 1088 : 	{
; 1089 : 		if ( gObj[iIndex].Level >= g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA && gObj[iIndex].Level <= g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  0008c	0f bf 88 96 00
	00 00		 movsx	 ecx, WORD PTR [eax+150]
  00093	8b 45 0c	 mov	 eax, DWORD PTR _iLevel$[ebp]
  00096	c1 e0 04	 shl	 eax, 4
  00099	8b 90 f8 ff ff
	ff		 mov	 edx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax-8]
  0009f	3b ca		 cmp	 ecx, edx
  000a1	7c 12		 jl	 SHORT $LN21@CheckEnter
  000a3	3b 88 fc ff ff
	ff		 cmp	 ecx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax-4]
  000a9	7f 06		 jg	 SHORT $LN8@CheckEnter
$LN23@CheckEnter:

; 1090 : 		{
; 1091 : 			return 0;

  000ab	33 c0		 xor	 eax, eax

; 1119 : 		}
; 1120 : 	}
; 1121 : 
; 1122 : 	return 2;
; 1123 : }

  000ad	5d		 pop	 ebp
  000ae	c2 08 00	 ret	 8
$LN8@CheckEnter:

; 1092 : 		}
; 1093 : 
; 1094 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[iLevel-1].iLOWER_BOUND_MAGUMSA )

  000b1	3b ca		 cmp	 ecx, edx
  000b3	7d 07		 jge	 SHORT $LN9@CheckEnter
$LN21@CheckEnter:

; 1095 : 		{
; 1096 : 			return -1;

  000b5	83 c8 ff	 or	 eax, -1

; 1119 : 		}
; 1120 : 	}
; 1121 : 
; 1122 : 	return 2;
; 1123 : }

  000b8	5d		 pop	 ebp
  000b9	c2 08 00	 ret	 8
$LN9@CheckEnter:

; 1097 : 		}
; 1098 : 
; 1099 : 		if ( gObj[iIndex].Level > g_sttBLOODCASTLE_LEVEL[iLevel-1].iUPPER_BOUND_MAGUMSA )

  000bc	3b 88 fc ff ff
	ff		 cmp	 ecx, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A[eax-4]

; 1100 : 		{
; 1101 : 			return 1;

  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	7f 05		 jg	 SHORT $LN1@CheckEnter
$LN17@CheckEnter:

; 1078 : 	{
; 1079 : 		return 2;

  000c9	b8 02 00 00 00	 mov	 eax, 2
$LN1@CheckEnter:

; 1119 : 		}
; 1120 : 	}
; 1121 : 
; 1122 : 	return 2;
; 1123 : }

  000ce	5d		 pop	 ebp
  000cf	c2 08 00	 ret	 8
?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CheckEnterLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCurrentRemainSec, COMDAT
; _this$ = ecx

; 1066 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1067 : 	return this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  00003	69 45 08 0c 02
	00 00		 imul	 eax, DWORD PTR _iBridgeIndex$[ebp], 524
  0000a	8b 8c 08 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+340]
  00011	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00016	f7 e9		 imul	 ecx
  00018	c1 fa 06	 sar	 edx, 6
  0001b	8b c2		 mov	 eax, edx
  0001d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00020	03 c2		 add	 eax, edx

; 1068 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?GetCurrentRemainSec@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCurrentRemainSec
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetRemainTime@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_ltime$1 = -28						; size = 8
_today$1$ = -20						; size = 4
_FIRST_TIME$1$ = -16					; size = 4
_this$1$ = -12						; size = 4
_pFirstTime$2$ = -8					; size = 4
_pFirstTime$1$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetRemainTime@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetRemainTime, COMDAT
; _this$ = ecx

; 1679 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx

; 1680 : 	int iREMAIN_MINUTE = 0;
; 1681 : 
; 1682 : 	if ( GetCurrentState(iBridgeIndex) == 1 )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	53		 push	 ebx
  0000e	89 75 f4	 mov	 DWORD PTR _this$1$[ebp], esi
  00011	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00016	83 f8 01	 cmp	 eax, 1
  00019	75 2d		 jne	 SHORT $LN7@GetRemainT

; 1683 : 	{
; 1684 : 		iREMAIN_MINUTE = m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 60000 - m_iBC_TIME_MIN_OPEN + 1;

  0001b	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524
  00021	8b 8c 30 54 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+340]
  00028	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  0002d	f7 e9		 imul	 ecx
  0002f	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00032	8b c2		 mov	 eax, edx
  00034	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00037	03 c2		 add	 eax, edx
  00039	2b 86 68 10 00
	00		 sub	 eax, DWORD PTR [esi+4200]
  0003f	5e		 pop	 esi
  00040	40		 inc	 eax
  00041	5b		 pop	 ebx

; 1770 : 
; 1771 : 	}
; 1772 : 
; 1773 : return iREMAIN_MINUTE;
; 1774 : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN7@GetRemainT:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00048	8d 45 e4	 lea	 eax, DWORD PTR _ltime$1[ebp]
  0004b	57		 push	 edi
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 __time64

; 511  :             return _localtime64(_Time);

  00052	8d 45 e4	 lea	 eax, DWORD PTR _ltime$1[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 __localtime64
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 531  : 		return ((_Nodepref)_Pnode->_Next);

  0005b	8b be 80 10 00
	00		 mov	 edi, DWORD PTR [esi+4224]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 511  :             return _localtime64(_Time);

  00061	83 c4 08	 add	 esp, 8
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 1700 : 		today = localtime(&ltime);

  00064	89 45 ec	 mov	 DWORD PTR _today$1$[ebp], eax

; 1701 : 
; 1702 : 		NOW_TIME = today->tm_hour * 60 + today->tm_min;

  00067	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0006a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006d	c1 e2 04	 shl	 edx, 4
  00070	2b 50 08	 sub	 edx, DWORD PTR [eax+8]
  00073	8d 1c 91	 lea	 ebx, DWORD PTR [ecx+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 43   : 		: _Ptr(_Pnode)

  00076	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 1704 : 		pFirstTime = *m_EventTime.begin();

  00078	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0007b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0007e	89 45 fc	 mov	 DWORD PTR _pFirstTime$1$[ebp], eax
  00081	89 55 f8	 mov	 DWORD PTR _pFirstTime$2$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 296  : 		return (this->_Ptr == _Right._Ptr);

  00084	3b cf		 cmp	 ecx, edi
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 1706 : 		for( Itor_ = m_EventTime.begin() ; Itor_ != m_EventTime.end(); ++Itor_ )

  00086	74 53		 je	 SHORT $LN259@GetRemainT
  00088	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@GetRemainT:

; 1707 : 		{
; 1708 : 			pTime = *Itor_;
; 1709 : 
; 1710 : 			FIRST_TIME = pFirstTime.Hour * 60 + pFirstTime.Min;

  00090	8b 55 f8	 mov	 edx, DWORD PTR _pFirstTime$2$[ebp]
  00093	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00096	c1 e0 04	 shl	 eax, 4
  00099	2b 45 fc	 sub	 eax, DWORD PTR _pFirstTime$1$[ebp]
  0009c	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 1711 : 			CHECK_TIME = pTime.Hour * 60 + pTime.Min;

  0009f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000a2	89 45 f0	 mov	 DWORD PTR _FIRST_TIME$1$[ebp], eax
  000a5	8b c6		 mov	 eax, esi
  000a7	c1 e0 04	 shl	 eax, 4
  000aa	2b c6		 sub	 eax, esi
  000ac	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 1712 : 
; 1713 : 			if( FIRST_TIME == CHECK_TIME )

  000af	8b 55 f0	 mov	 edx, DWORD PTR _FIRST_TIME$1$[ebp]
  000b2	3b d0		 cmp	 edx, eax
  000b4	75 09		 jne	 SHORT $LN9@GetRemainT

; 1714 : 			{
; 1715 : 				if( NOW_TIME < CHECK_TIME )

  000b6	3b d8		 cmp	 ebx, eax
  000b8	72 1e		 jb	 SHORT $LN267@GetRemainT

; 1716 : 				{
; 1717 : 					pTime = *Itor_;
; 1718 : 					break;
; 1719 : 				}
; 1720 : 				continue;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _pFirstTime$1$[ebp]
  000bd	eb 13		 jmp	 SHORT $LN2@GetRemainT
$LN9@GetRemainT:

; 1721 : 			}
; 1722 : 
; 1723 : 			if( NOW_TIME >= FIRST_TIME &&

  000bf	3b da		 cmp	 ebx, edx
  000c1	72 04		 jb	 SHORT $LN11@GetRemainT
  000c3	3b d8		 cmp	 ebx, eax
  000c5	72 11		 jb	 SHORT $LN267@GetRemainT
$LN11@GetRemainT:

; 1724 : 				NOW_TIME < CHECK_TIME )
; 1725 : 			{
; 1726 : 				break;
; 1727 : 			}
; 1728 : 	
; 1729 : 			pFirstTime = *Itor_;

  000c7	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000ca	8b c6		 mov	 eax, esi
  000cc	89 45 fc	 mov	 DWORD PTR _pFirstTime$1$[ebp], eax
  000cf	89 55 f8	 mov	 DWORD PTR _pFirstTime$2$[ebp], edx
$LN2@GetRemainT:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  000d2	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 296  : 		return (this->_Ptr == _Right._Ptr);

  000d4	3b cf		 cmp	 ecx, edi
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 1706 : 		for( Itor_ = m_EventTime.begin() ; Itor_ != m_EventTime.end(); ++Itor_ )

  000d6	75 b8		 jne	 SHORT $LL4@GetRemainT
$LN267@GetRemainT:
  000d8	8b 75 f4	 mov	 esi, DWORD PTR _this$1$[ebp]
$LN259@GetRemainT:

; 1739 : 				pTime = *Itor_;
; 1740 : 			}
; 1741 : 	
; 1742 : 			CHECK_TIME = pTime.Hour * 60 + pTime.Min;
; 1743 : 	
; 1744 : 			if( today->tm_hour <= pTime.Hour &&
; 1745 : 				CHECK_TIME > NOW_TIME )
; 1746 : 			{
; 1747 : 				iREMAIN_MINUTE = (CHECK_TIME -NOW_TIME)*60*1000;
; 1748 : 			}
; 1749 : 			else
; 1750 : 			{
; 1751 : 				iREMAIN_MINUTE = (1440 - NOW_TIME + CHECK_TIME)*60*1000;
; 1752 : 			}
; 1753 : 
; 1754 : 			if( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= m_iBC_TIME_MIN_OPEN*60*1000 )

  000db	69 5d 08 0c 02
	00 00		 imul	 ebx, DWORD PTR _iBridgeIndex$[ebp], 524
  000e2	ba 02 00 00 00	 mov	 edx, 2
  000e7	8b 86 68 10 00
	00		 mov	 eax, DWORD PTR [esi+4200]
  000ed	69 c0 60 ea 00
	00		 imul	 eax, eax, 60000
  000f3	8b b4 33 54 01
	00 00		 mov	 esi, DWORD PTR [ebx+esi+340]
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL5@GetRemainT:

; 1734 : 		while( CHECK_COUNT-- )

  00100	4a		 dec	 edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 296  : 		return (this->_Ptr == _Right._Ptr);

  00101	3b cf		 cmp	 ecx, edi
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 1736 : 			if( Itor_ == m_EventTime.end() )

  00103	75 02		 jne	 SHORT $LN12@GetRemainT

; 1737 : 			{
; 1738 : 				Itor_ = m_EventTime.begin();

  00105	8b 0f		 mov	 ecx, DWORD PTR [edi]
$LN12@GetRemainT:

; 1739 : 				pTime = *Itor_;
; 1740 : 			}
; 1741 : 	
; 1742 : 			CHECK_TIME = pTime.Hour * 60 + pTime.Min;
; 1743 : 	
; 1744 : 			if( today->tm_hour <= pTime.Hour &&
; 1745 : 				CHECK_TIME > NOW_TIME )
; 1746 : 			{
; 1747 : 				iREMAIN_MINUTE = (CHECK_TIME -NOW_TIME)*60*1000;
; 1748 : 			}
; 1749 : 			else
; 1750 : 			{
; 1751 : 				iREMAIN_MINUTE = (1440 - NOW_TIME + CHECK_TIME)*60*1000;
; 1752 : 			}
; 1753 : 
; 1754 : 			if( this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC <= m_iBC_TIME_MIN_OPEN*60*1000 )

  00107	3b f0		 cmp	 esi, eax
  00109	7f 06		 jg	 SHORT $LN15@GetRemainT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  0010b	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp

; 1734 : 		while( CHECK_COUNT-- )

  0010d	85 d2		 test	 edx, edx
  0010f	75 ef		 jne	 SHORT $LL5@GetRemainT
$LN15@GetRemainT:

; 1755 : 			{
; 1756 : 				Itor_++;
; 1757 : 				if( Itor_ != m_EventTime.end() )
; 1758 : 				{
; 1759 : 					pTime = *Itor_;
; 1760 : 				}
; 1761 : 			}
; 1762 : 			else
; 1763 : 			{
; 1764 : 				break;
; 1765 : 			}
; 1766 : 		}
; 1767 : 
; 1768 : 		DWORD Tick = GetTickCount();

  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 1769 : 		iREMAIN_MINUTE = m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC - today->tm_sec*1000;

  00117	8b 45 ec	 mov	 eax, DWORD PTR _today$1$[ebp]
  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	69 08 e8 03 00
	00		 imul	 ecx, DWORD PTR [eax], 1000
  00122	8b 45 f4	 mov	 eax, DWORD PTR _this$1$[ebp]
  00125	8b 84 03 54 01
	00 00		 mov	 eax, DWORD PTR [ebx+eax+340]
  0012c	2b c1		 sub	 eax, ecx
  0012e	5b		 pop	 ebx

; 1770 : 
; 1771 : 	}
; 1772 : 
; 1773 : return iREMAIN_MINUTE;
; 1774 : }

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 04 00	 ret	 4
?GetRemainTime@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetRemainTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetCurrentState@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetCurrentState@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::GetCurrentState, COMDAT
; _this$ = ecx

; 1051 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1052 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 1d		 js	 SHORT $LN6@GetCurrent
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 11		 je	 SHORT $LN6@GetCurrent

; 1055 : 	}
; 1056 : 
; 1057 : 	return this->m_BridgeData[iBridgeIndex].m_iBC_STATE;

  00016	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0001c	8b 84 08 50 01
	00 00		 mov	 eax, DWORD PTR [eax+ecx+336]

; 1058 : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN6@GetCurrent:

; 1053 : 	{
; 1054 : 		return -1;

  00027	83 c8 ff	 or	 eax, -1

; 1058 : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?GetCurrentState@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::GetCurrentState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv314 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::CheckUsersOnConnect, COMDAT
; _this$ = ecx

; 2209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2210 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	78 7f		 js	 SHORT $LN1@CheckUsers
  0000f	33 c0		 xor	 eax, eax
  00011	83 fb 07	 cmp	 ebx, 7
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	74 73		 je	 SHORT $LN1@CheckUsers

; 2211 : 	{
; 2212 : 		return;
; 2213 : 	}
; 2214 : 
; 2215 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  0001b	56		 push	 esi
  0001c	69 f3 0c 02 00
	00		 imul	 esi, ebx, 524
  00022	57		 push	 edi
  00023	03 f1		 add	 esi, ecx
  00025	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00028	50		 push	 eax
  00029	89 45 08	 mov	 DWORD PTR tv314[ebp], eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  00032	83 c6 1c	 add	 esi, 28			; 0000001cH
  00035	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL4@CheckUsers:

; 2218 : 	{
; 2219 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	83 f8 ff	 cmp	 eax, -1
  00045	74 34		 je	 SHORT $LN2@CheckUsers

; 2220 : 		{
; 2221 : 			if ( gObjIsConnected(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex) == FALSE )

  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004d	83 c4 04	 add	 esp, 4
  00050	85 c0		 test	 eax, eax
  00052	74 21		 je	 SHORT $LN17@CheckUsers

; 2222 : 			{
; 2223 : 				this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;
; 2224 : 			}
; 2225 : 			else
; 2226 : 			{
; 2227 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber != GetEventMap(iBridgeIndex) )

  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00057	53		 push	 ebx
  00058	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  0005d	69 16 40 27 00
	00		 imul	 edx, DWORD PTR [esi], 10048
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00069	0f b6 8c 0a 23
	01 00 00	 movzx	 ecx, BYTE PTR [edx+ecx+291]
  00071	3b c8		 cmp	 ecx, eax
  00073	74 06		 je	 SHORT $LN2@CheckUsers
$LN17@CheckUsers:

; 2228 : 				{
; 2229 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = -1;

  00075	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN2@CheckUsers:

; 2216 : 
; 2217 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0007b	83 c6 14	 add	 esi, 20			; 00000014H
  0007e	83 ef 01	 sub	 edi, 1
  00081	75 bd		 jne	 SHORT $LL4@CheckUsers

; 2230 : 				}
; 2231 : 			}
; 2232 : 		}
; 2233 : 	}
; 2234 : 
; 2235 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00083	ff 75 08	 push	 DWORD PTR tv314[ebp]
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
$LN1@CheckUsers:
  0008e	5b		 pop	 ebx

; 2236 : 
; 2237 : }

  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
?CheckUsersOnConnect@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::CheckUsersOnConnect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?LevelUp@CBloodCastle@@QAEHHHH@Z
_TEXT	SEGMENT
_iLEFT_EXP$1$ = -268					; size = 4
tv556 = -264						; size = 4
_szLog$1 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iAddExp$ = 12						; size = 4
_iEventType$ = 16					; size = 4
?LevelUp@CBloodCastle@@QAEHHHH@Z PROC			; CBloodCastle::LevelUp, COMDAT
; _this$ = ecx

; 2098 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 2099 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00017	85 f6		 test	 esi, esi
  00019	0f 88 4e 03 00
	00		 js	 $LN20@LevelUp
  0001f	33 c0		 xor	 eax, eax
  00021	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 3b 03 00
	00		 je	 $LN20@LevelUp

; 2100 : 	{
; 2101 : 		return 0;
; 2102 : 	}
; 2103 : 
; 2104 : 	int iLEFT_EXP = 0;
; 2105 : 
; 2106 : 	if ( g_MasterExp.LevelUp(&gObj[iIndex],iAddExp) )

  00032	53		 push	 ebx
  00033	8b 5d 0c	 mov	 ebx, DWORD PTR _iAddExp$[ebp]
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterExp@@3VCMasterExperience@@A ; g_MasterExp
  0003b	57		 push	 edi
  0003c	8b c3		 mov	 eax, ebx
  0003e	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00044	99		 cdq
  00045	52		 push	 edx
  00046	50		 push	 eax
  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	03 c7		 add	 eax, edi
  0004e	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iLEFT_EXP$1$[ebp], 0
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?LevelUp@CMasterExperience@@QAEHPAUOBJECTSTRUCT@@_J@Z ; CMasterExperience::LevelUp
  0005e	85 c0		 test	 eax, eax
  00060	0f 85 89 00 00
	00		 jne	 $LN24@LevelUp

; 2107 : 	{
; 2108 : 		return 0;
; 2109 : 	}
; 2110 : 
; 2111 : 	::gObjSetExpPetItem(iIndex, iAddExp);

  00066	53		 push	 ebx
  00067	56		 push	 esi
  00068	e8 00 00 00 00	 call	 ?gObjSetExpPetItem@@YAXHH@Z ; gObjSetExpPetItem

; 2112 : 
; 2113 : 	LogAddTD("Experience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex : %d, EventType : %d",

  0006d	ff 75 10	 push	 DWORD PTR _iEventType$[ebp]
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00076	6a 00		 push	 0
  00078	53		 push	 ebx
  00079	ff b4 0f a0 00
	00 00		 push	 DWORD PTR [edi+ecx+160]
  00080	0f bf 84 0f 96
	00 00 00	 movsx	 eax, WORD PTR [edi+ecx+150]
  00088	50		 push	 eax
  00089	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0008c	03 c7		 add	 eax, edi
  0008e	50		 push	 eax
  0008f	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00092	03 c7		 add	 eax, edi
  00094	50		 push	 eax
  00095	0f b6 84 0f 21
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+289]
  0009d	50		 push	 eax
  0009e	0f b6 84 0f 20
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+288]
  000a6	50		 push	 eax
  000a7	0f b6 84 0f 23
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+291]
  000af	50		 push	 eax
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@MCCJHJPM@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CFs@
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2114 : 		gObj[iIndex].MapNumber, gObj[iIndex].X, gObj[iIndex].Y,
; 2115 : 		gObj[iIndex].AccountID,	gObj[iIndex].Name,
; 2116 : 		gObj[iIndex].Level, gObj[iIndex].Experience,
; 2117 : 		iAddExp, 0, iEventType);
; 2118 : 
; 2119 : 	if ( gObj[iIndex].Level >= MAX_CHAR_LEVEL )

  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c0	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  000c5	83 c4 34	 add	 esp, 52			; 00000034H
  000c8	66 39 8c 07 96
	00 00 00	 cmp	 WORD PTR [edi+eax+150], cx
  000d0	7c 32		 jl	 SHORT $LN7@LevelUp

; 2120 : 	{
; 2121 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 112)), gObj[iIndex].m_Index, 1);

  000d2	6a 01		 push	 1
  000d4	ff 34 07	 push	 DWORD PTR [edi+eax]
  000d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000dc	68 70 04 00 00	 push	 1136			; 00000470H
  000e1	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@LevelUp:

; 2122 : 		return 0;

  000ef	5f		 pop	 edi
  000f0	5b		 pop	 ebx
  000f1	33 c0		 xor	 eax, eax
  000f3	5e		 pop	 esi

; 2202 : }

  000f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f7	33 cd		 xor	 ecx, ebp
  000f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 0c 00	 ret	 12			; 0000000cH
$LN7@LevelUp:

; 2123 : 	}
; 2124 : 
; 2125 : 	if ( (gObj[iIndex].Experience + iAddExp) < gObj[iIndex].NextExp )

  00104	8b b4 07 a0 00
	00 00		 mov	 esi, DWORD PTR [edi+eax+160]
  0010b	8b 94 07 a4 00
	00 00		 mov	 edx, DWORD PTR [edi+eax+164]
  00112	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]
  00115	3b ca		 cmp	 ecx, edx
  00117	73 0c		 jae	 SHORT $LN8@LevelUp

; 2126 : 	{
; 2127 : 		gObj[iIndex].Experience += iAddExp;

  00119	89 8c 07 a0 00
	00 00		 mov	 DWORD PTR [edi+eax+160], ecx

; 2128 : 	}
; 2129 : 	else

  00120	e9 18 02 00 00	 jmp	 $LN11@LevelUp
$LN8@LevelUp:

; 2130 : 	{
; 2131 : 		iLEFT_EXP = gObj[iIndex].Experience + iAddExp - gObj[iIndex].NextExp;
; 2132 : 		gObj[iIndex].Experience = gObj[iIndex].NextExp;

  00125	89 94 07 a0 00
	00 00		 mov	 DWORD PTR [edi+eax+160], edx
  0012c	2b f2		 sub	 esi, edx

; 2133 : 		gObj[iIndex].Level++;

  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00133	03 f3		 add	 esi, ebx
  00135	89 b5 f4 fe ff
	ff		 mov	 DWORD PTR _iLEFT_EXP$1$[ebp], esi

; 2134 : #if (ENABLE_CUSTOM_CLASSCALC == 1)
; 2135 : 		gObj[iIndex].LevelUpPoint += g_ClassCalc.GetLevelPoint(&gObj[iIndex], 0, 0);

  0013b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ClassCalc@@3VClassCalc@@A ; g_ClassCalc
  00140	6a 00		 push	 0
  00142	6a 00		 push	 0
  00144	66 ff 84 07 96
	00 00 00	 inc	 WORD PTR [edi+eax+150]
  0014c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00152	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 ?GetLevelPoint@ClassCalc@@QAEGPAUOBJECTSTRUCT@@EE@Z ; ClassCalc::GetLevelPoint
  0015b	0f b7 c0	 movzx	 eax, ax
  0015e	01 84 37 98 00
	00 00		 add	 DWORD PTR [edi+esi+152], eax

; 2136 : #else
; 2137 : 		if( gObj[iIndex].Class == CLASS_DARKLORD )
; 2138 : 		{
; 2139 : 			gObj[iIndex].LevelUpPoint += 7;
; 2140 : 		}
; 2141 : 		else if( gObj[iIndex].Class == CLASS_MAGUMSA )
; 2142 : 		{
; 2143 : 			gObj[iIndex].LevelUpPoint += 7;
; 2144 : 		}
; 2145 : 		else if( gObj[iIndex].Class == CLASS_FIGHTER )
; 2146 : 		{
; 2147 : 			gObj[iIndex].LevelUpPoint += 7;
; 2148 : 		}
; 2149 : 		else
; 2150 : 		{
; 2151 : 			gObj[iIndex].LevelUpPoint += 5;
; 2152 : 		}
; 2153 : #endif
; 2154 : 
; 2155 : 		if( gObj[iIndex].PlusStatQuestClear != false )

  00165	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016b	80 7c 37 7c 00	 cmp	 BYTE PTR [edi+esi+124], 0
  00170	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00173	74 1f		 je	 SHORT $LN10@LevelUp

; 2156 : 		{
; 2157 : #if (ENABLE_CUSTOM_CLASSCALC == 1)
; 2158 : 			gObj[iIndex].LevelUpPoint += g_ClassCalc.GetLevelPoint(&gObj[iIndex], 0, 1);

  00175	6a 01		 push	 1
  00177	6a 00		 push	 0
  00179	50		 push	 eax
  0017a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ClassCalc@@3VClassCalc@@A ; g_ClassCalc
  0017f	e8 00 00 00 00	 call	 ?GetLevelPoint@ClassCalc@@QAEGPAUOBJECTSTRUCT@@EE@Z ; ClassCalc::GetLevelPoint
  00184	0f b7 c0	 movzx	 eax, ax
  00187	01 84 37 98 00
	00 00		 add	 DWORD PTR [edi+esi+152], eax
  0018e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@LevelUp:

; 2159 : #else
; 2160 : 			gObj[iIndex].LevelUpPoint += 1;
; 2161 : 			LogAddTD("[%s][%s] LevelUp PlusStatQuest Clear AddStat %d",
; 2162 : 				gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].LevelUpPoint);
; 2163 : #endif
; 2164 : 		}
; 2165 : 
; 2166 : 		gObj[iIndex].MaxLife += DCInfo.DefClass[gObj[iIndex].Class].LevelLife;

  00194	0f b7 84 37 90
	00 00 00	 movzx	 eax, WORD PTR [edi+esi+144]
  0019c	69 c0 c8 0b 00
	00		 imul	 eax, eax, 3016
  001a2	f3 0f 10 80 10
	00 00 00	 movss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  001aa	f3 0f 58 84 37
	dc 00 00 00	 addss	 xmm0, DWORD PTR [edi+esi+220]
  001b3	f3 0f 11 84 37
	dc 00 00 00	 movss	 DWORD PTR [edi+esi+220], xmm0

; 2167 : 		gObj[iIndex].MaxMana += DCInfo.DefClass[gObj[iIndex].Class].LevelMana;

  001bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c2	0f b7 84 0f 90
	00 00 00	 movzx	 eax, WORD PTR [edi+ecx+144]
  001ca	69 c0 c8 0b 00
	00		 imul	 eax, eax, 3016
  001d0	f3 0f 10 80 1c
	00 00 00	 movss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  001d8	f3 0f 58 84 0f
	f0 00 00 00	 addss	 xmm0, DWORD PTR [edi+ecx+240]
  001e1	f3 0f 11 84 0f
	f0 00 00 00	 movss	 DWORD PTR [edi+ecx+240], xmm0

; 2168 : 		gObj[iIndex].Life = gObj[iIndex].MaxLife;

  001ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f0	8b 84 0f dc 00
	00 00		 mov	 eax, DWORD PTR [edi+ecx+220]
  001f7	89 84 0f d8 00
	00 00		 mov	 DWORD PTR [edi+ecx+216], eax

; 2169 : 		gObj[iIndex].Mana = gObj[iIndex].MaxMana;

  001fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00204	8b 84 0f f0 00
	00 00		 mov	 eax, DWORD PTR [edi+ecx+240]
  0020b	89 84 0f ec 00
	00 00		 mov	 DWORD PTR [edi+ecx+236], eax

; 2170 : 		gObjNextExpCal(&gObj[iIndex]);

  00212	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00217	03 c7		 add	 eax, edi
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAUOBJECTSTRUCT@@@Z ; gObjNextExpCal

; 2171 : 		gObjSetBP(gObj[iIndex].m_Index);

  0021f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00224	ff 34 07	 push	 DWORD PTR [edi+eax]
  00227	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 2172 : 		GCLevelUpMsgSend(gObj[iIndex].m_Index, 1);

  0022c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00231	6a 01		 push	 1
  00233	ff 34 07	 push	 DWORD PTR [edi+eax]
  00236	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHH@Z ; GCLevelUpMsgSend

; 2173 : 		LogAddTD(lMsg.Get(MSGGET(2, 8)), gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].Level);

  0023b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00241	83 c4 10	 add	 esp, 16			; 00000010H
  00244	0f bf 84 0f 96
	00 00 00	 movsx	 eax, WORD PTR [edi+ecx+150]
  0024c	50		 push	 eax
  0024d	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00250	03 c7		 add	 eax, edi
  00252	50		 push	 eax
  00253	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00256	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0025b	03 c7		 add	 eax, edi
  0025d	50		 push	 eax
  0025e	68 08 02 00 00	 push	 520			; 00000208H
  00263	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00268	50		 push	 eax
  00269	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2174 : 
; 2175 : 		if( gObj[iIndex].Level == 400 && gObj[iIndex].PartyNumber >= 0)

  0026f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00275	b8 90 01 00 00	 mov	 eax, 400		; 00000190H
  0027a	83 c4 10	 add	 esp, 16			; 00000010H
  0027d	66 39 84 0f 96
	00 00 00	 cmp	 WORD PTR [edi+ecx+150], ax
  00285	0f 85 b2 00 00
	00		 jne	 $LN11@LevelUp
  0028b	8b b4 0f 0c 06
	00 00		 mov	 esi, DWORD PTR [edi+ecx+1548]
  00292	85 f6		 test	 esi, esi
  00294	0f 88 a3 00 00
	00		 js	 $LN11@LevelUp

; 2176 : 		{
; 2177 : 			int PartyNumber = gObj[iIndex].PartyNumber;
; 2178 : 			char szLog[256];
; 2179 : 
; 2180 : 			sprintf(szLog,"400 LevelUp (%s)(%s) Party ",gObj[iIndex].AccountID,gObj[iIndex].Name);

  0029a	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0029d	03 c7		 add	 eax, edi
  0029f	50		 push	 eax
  002a0	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  002a3	03 c7		 add	 eax, edi
  002a5	50		 push	 eax
  002a6	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szLog$1[ebp]
  002ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DJAOLMAF@400?5LevelUp?5?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Party?5?$AA@
  002b1	50		 push	 eax
  002b2	e8 00 00 00 00	 call	 _sprintf
  002b7	8b c6		 mov	 eax, esi
  002b9	83 c4 10	 add	 esp, 16			; 00000010H
  002bc	c1 e0 04	 shl	 eax, 4
  002bf	2b c6		 sub	 eax, esi
  002c1	8d 1c 85 0c 00
	00 00		 lea	 ebx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  002c8	b8 05 00 00 00	 mov	 eax, 5
  002cd	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv556[ebp], eax
$LL4@LevelUp:

; 2185 : 			{
; 2186 : 				tObjNum = gParty.m_PartyS[PartyNumber].Number[i];

  002d3	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 2187 : 
; 2188 : 				if( tObjNum >= 0 )

  002d5	85 c9		 test	 ecx, ecx
  002d7	78 46		 js	 SHORT $LN2@LevelUp

; 2189 : 				{
; 2190 : 					int Len = strlen(szLog);

  002d9	8d b5 fc fe ff
	ff		 lea	 esi, DWORD PTR _szLog$1[ebp]
  002df	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
$LL21@LevelUp:
  002e2	8a 06		 mov	 al, BYTE PTR [esi]
  002e4	46		 inc	 esi
  002e5	84 c0		 test	 al, al
  002e7	75 f9		 jne	 SHORT $LL21@LevelUp
  002e9	2b f2		 sub	 esi, edx

; 2191 : 					sprintf(&szLog[Len],",(%s)(%s) ",gObj[tObjNum].AccountID,gObj[tObjNum].Name);

  002eb	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  002f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f7	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002fa	03 c2		 add	 eax, edx
  002fc	50		 push	 eax
  002fd	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00300	03 c2		 add	 eax, edx
  00302	50		 push	 eax
  00303	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szLog$1[ebp]
  00309	03 c6		 add	 eax, esi
  0030b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MNKEEMGH@?0?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5?$AA@
  00310	50		 push	 eax
  00311	e8 00 00 00 00	 call	 _sprintf
  00316	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv556[ebp]
  0031c	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@LevelUp:

; 2181 : 
; 2182 : 			int tObjNum;
; 2183 : 
; 2184 : 			for(int i = 0; i < MAX_USER_IN_PARTY; i++)

  0031f	83 c3 04	 add	 ebx, 4
  00322	83 e8 01	 sub	 eax, 1
  00325	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv556[ebp], eax
  0032b	75 a6		 jne	 SHORT $LL4@LevelUp

; 2192 : 				}
; 2193 : 			}
; 2194 : 
; 2195 : 			LogAddTD(szLog);

  0032d	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szLog$1[ebp]
  00333	50		 push	 eax
  00334	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0033a	83 c4 04	 add	 esp, 4
$LN11@LevelUp:

; 2196 : 		}
; 2197 : 	}
; 2198 : 
; 2199 : 	GJSetCharacterInfo(&gObj[iIndex], gObj[iIndex].m_Index, 0);

  0033d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00343	03 cf		 add	 ecx, edi
  00345	6a 01		 push	 1
  00347	6a 00		 push	 0
  00349	ff 31		 push	 DWORD PTR [ecx]
  0034b	51		 push	 ecx
  0034c	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z ; GJSetCharacterInfo

; 2200 : 	
; 2201 : 	return iLEFT_EXP;

  00351	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _iLEFT_EXP$1$[ebp]
  00357	83 c4 10	 add	 esp, 16			; 00000010H
  0035a	5f		 pop	 edi
  0035b	5b		 pop	 ebx
  0035c	5e		 pop	 esi

; 2202 : }

  0035d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00360	33 cd		 xor	 ecx, ebp
  00362	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00367	8b e5		 mov	 esp, ebp
  00369	5d		 pop	 ebp
  0036a	c2 0c 00	 ret	 12			; 0000000cH
$LN20@LevelUp:
  0036d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00370	33 c0		 xor	 eax, eax
  00372	33 cd		 xor	 ecx, ebp
  00374	5e		 pop	 esi
  00375	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037a	8b e5		 mov	 esp, ebp
  0037c	5d		 pop	 ebp
  0037d	c2 0c 00	 ret	 12			; 0000000cH
?LevelUp@CBloodCastle@@QAEHHHH@Z ENDP			; CBloodCastle::LevelUp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?EnterUserBridge@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
tv262 = -4						; size = 4
tv264 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iUserIndex$ = 12					; size = 4
?EnterUserBridge@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::EnterUserBridge, COMDAT
; _this$ = ecx

; 2054 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2055 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 d2		 test	 edx, edx
  0000c	0f 88 bd 00 00
	00		 js	 $LN18@EnterUserB
  00012	33 c0		 xor	 eax, eax
  00014	83 fa 07	 cmp	 edx, 7
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 ad 00 00
	00		 je	 $LN18@EnterUserB

; 2058 : 	}
; 2059 : 
; 2060 : 	int iRET_VAL = -1;
; 2061 : 
; 2062 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00022	56		 push	 esi
  00023	69 f2 0c 02 00
	00		 imul	 esi, edx, 524
  00029	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0002c	57		 push	 edi
  0002d	83 cf ff	 or	 edi, -1
  00030	03 c6		 add	 eax, esi
  00032	89 75 08	 mov	 DWORD PTR tv264[ebp], esi
  00035	50		 push	 eax
  00036	89 45 fc	 mov	 DWORD PTR tv262[ebp], eax
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
  0003f	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]

; 2063 : 
; 2064 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00042	33 c0		 xor	 eax, eax
  00044	8b 75 0c	 mov	 esi, DWORD PTR _iUserIndex$[ebp]
  00047	03 cb		 add	 ecx, ebx
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@EnterUserB:

; 2065 : 	{
; 2066 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00050	8b 11		 mov	 edx, DWORD PTR [ecx]
  00052	83 fa ff	 cmp	 edx, -1
  00055	74 21		 je	 SHORT $LN14@EnterUserB

; 2067 : 		{
; 2068 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iUserIndex )

  00057	3b d6		 cmp	 edx, esi
  00059	74 5e		 je	 SHORT $LN13@EnterUserB

; 2063 : 
; 2064 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0005b	40		 inc	 eax
  0005c	83 c1 14	 add	 ecx, 20			; 00000014H
  0005f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00062	7c ec		 jl	 SHORT $LL4@EnterUserB

; 2083 : 			break;
; 2084 : 		}
; 2085 : 	}
; 2086 : 
; 2087 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00064	ff 75 fc	 push	 DWORD PTR tv262[ebp]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 2088 : 
; 2089 : 	return iRET_VAL;

  0006d	8b c7		 mov	 eax, edi
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 2090 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8
$LN14@EnterUserB:

; 2069 : 			{
; 2070 : 				iRET_VAL = i;
; 2071 : 				break;
; 2072 : 			}
; 2073 : 		}
; 2074 : 
; 2075 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )
; 2076 : 		{
; 2077 : 			iRET_VAL = i;
; 2078 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex = iUserIndex;

  00078	8b 55 08	 mov	 edx, DWORD PTR tv264[ebp]
  0007b	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0007e	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  00081	89 74 19 1c	 mov	 DWORD PTR [ecx+ebx+28], esi

; 2079 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP = 0;

  00085	c7 44 19 20 00
	00 00 00	 mov	 DWORD PTR [ecx+ebx+32], 0

; 2080 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iScore = 0;

  0008d	c7 44 19 24 00
	00 00 00	 mov	 DWORD PTR [ecx+ebx+36], 0

; 2081 : 			this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 0;

  00095	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  00098	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  0009b	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]

; 2082 : 			gObj[iUserIndex].m_bBloodCastleComplete = false;

  0009e	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  000a4	c7 04 19 00 00
	00 00		 mov	 DWORD PTR [ecx+ebx], 0
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b1	c6 84 0a 3c 12
	00 00 00	 mov	 BYTE PTR [edx+ecx+4668], 0
$LN13@EnterUserB:

; 2083 : 			break;
; 2084 : 		}
; 2085 : 	}
; 2086 : 
; 2087 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  000b9	ff 75 fc	 push	 DWORD PTR tv262[ebp]
  000bc	8b f8		 mov	 edi, eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 2088 : 
; 2089 : 	return iRET_VAL;

  000c4	8b c7		 mov	 eax, edi
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx

; 2090 : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 08 00	 ret	 8
$LN18@EnterUserB:

; 2056 : 	{
; 2057 : 		return -1;

  000cf	83 c8 ff	 or	 eax, -1
  000d2	5b		 pop	 ebx

; 2090 : }

  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 08 00	 ret	 8
?EnterUserBridge@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::EnterUserBridge
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z
_TEXT	SEGMENT
tv208 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
_iBridgeSubIndex$ = 12					; size = 4
_iUserIndex$ = 16					; size = 4
?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z PROC		; CBloodCastle::LeaveUserBridge, COMDAT
; _this$ = ecx

; 2019 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2020 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	0f 88 97 00 00
	00		 js	 $LN10@LeaveUserB
  00011	33 c0		 xor	 eax, eax
  00013	83 fa 07	 cmp	 edx, 7
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 87 00 00
	00		 je	 $LN10@LeaveUserB

; 2023 : 	}
; 2024 : 
; 2025 : 	if ( BC_SUB_BRIDGE_RANGE(iBridgeSubIndex) == FALSE )

  00021	56		 push	 esi
  00022	8b 75 0c	 mov	 esi, DWORD PTR _iBridgeSubIndex$[ebp]
  00025	85 f6		 test	 esi, esi
  00027	78 76		 js	 SHORT $LN11@LeaveUserB
  00029	33 c0		 xor	 eax, eax
  0002b	83 fe 09	 cmp	 esi, 9
  0002e	0f 9e c0	 setle	 al
  00031	85 c0		 test	 eax, eax
  00033	74 6a		 je	 SHORT $LN11@LeaveUserB

; 2028 : 	}
; 2029 : 
; 2030 : 	int iRET_VAL = -1;
; 2031 : 
; 2032 : 	::EnterCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  00035	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0003b	53		 push	 ebx
  0003c	83 cb ff	 or	 ebx, -1
  0003f	89 45 08	 mov	 DWORD PTR tv208[ebp], eax
  00042	83 c0 04	 add	 eax, 4
  00045	03 c7		 add	 eax, edi
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 2033 : 
; 2034 : 	if ( this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iIndex == iUserIndex )

  0004e	8b 55 08	 mov	 edx, DWORD PTR tv208[ebp]
  00051	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _iUserIndex$[ebp]
  00057	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  0005a	39 4c 38 1c	 cmp	 DWORD PTR [eax+edi+28], ecx
  0005e	75 2a		 jne	 SHORT $LN4@LeaveUserB

; 2035 : 	{
; 2036 : 		iRET_VAL = iUserIndex;

  00060	8b d9		 mov	 ebx, ecx

; 2037 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iIndex = -1;

  00062	c7 44 38 1c ff
	ff ff ff	 mov	 DWORD PTR [eax+edi+28], -1

; 2038 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iEXP = 0;
; 2039 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iScore = 0;
; 2040 : 		this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 0;

  0006a	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
  0006d	c7 44 38 20 00
	00 00 00	 mov	 DWORD PTR [eax+edi+32], 0
  00075	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  00078	c7 44 38 24 00
	00 00 00	 mov	 DWORD PTR [eax+edi+36], 0
  00080	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  00083	c7 04 39 00 00
	00 00		 mov	 DWORD PTR [ecx+edi], 0
$LN4@LeaveUserB:

; 2041 : 	}
; 2042 : 
; 2043 : 	::LeaveCriticalSection(&this->m_BridgeData[iBridgeIndex].m_critUserData);

  0008a	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  0008d	03 c7		 add	 eax, edi
  0008f	50		 push	 eax
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 2044 : 
; 2045 : 	return iRET_VAL;

  00096	8b c3		 mov	 eax, ebx
  00098	5b		 pop	 ebx
  00099	5e		 pop	 esi
  0009a	5f		 pop	 edi

; 2046 : }

  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
$LN11@LeaveUserB:
  0009f	5e		 pop	 esi

; 2026 : 	{
; 2027 : 		return -1;

  000a0	83 c8 ff	 or	 eax, -1
  000a3	5f		 pop	 edi

; 2046 : }

  000a4	5d		 pop	 ebp
  000a5	c2 0c 00	 ret	 12			; 0000000cH
$LN10@LeaveUserB:

; 2021 : 	{
; 2022 : 		return -1;

  000a8	83 c8 ff	 or	 eax, -1
  000ab	5f		 pop	 edi

; 2046 : }

  000ac	5d		 pop	 ebp
  000ad	c2 0c 00	 ret	 12			; 0000000cH
?LeaveUserBridge@CBloodCastle@@QAEHHHH@Z ENDP		; CBloodCastle::LeaveUserBridge
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetSaintStatue@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
tv281 = -4						; size = 4
_btMonsterType$1$ = 8					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetSaintStatue@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetSaintStatue, COMDAT
; _this$ = ecx

; 1970 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 1971 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00007	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  0000a	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000d	85 ff		 test	 edi, edi
  0000f	0f 88 99 01 00
	00		 js	 $LN5@SetSaintSt
  00015	33 c0		 xor	 eax, eax
  00017	83 ff 07	 cmp	 edi, 7
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 89 01 00
	00		 je	 $LN5@SetSaintSt

; 1972 : 	{
; 1973 : 		return;
; 1974 : 	}
; 1975 : 
; 1976 : 	int nSaintStatuePosNum = this->m_BridgeData[iBridgeIndex].m_nSaintStatuePosNum;

  00025	69 c7 0c 02 00
	00		 imul	 eax, edi, 524
  0002b	53		 push	 ebx
  0002c	56		 push	 esi
  0002d	8b 9c 08 34 01
	00 00		 mov	 ebx, DWORD PTR [eax+ecx+308]

; 1977 : 	WORD btMonsterType = gMSetBase.m_Mp[nSaintStatuePosNum].m_Type;

  00034	8d 04 9b	 lea	 eax, DWORD PTR [ebx+ebx*4]
  00037	0f b7 14 85 06
	00 00 00	 movzx	 edx, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax*4+6]

; 1978 : 	BYTE btMapNumber = gMSetBase.m_Mp[nSaintStatuePosNum].m_MapNumber;

  0003f	8a 04 85 08 00
	00 00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax*4+8]

; 1979 : 	BYTE btBloodCastleIndex = GetBridgeLevel(btMapNumber);

  00046	0f b6 f0	 movzx	 esi, al
  00049	56		 push	 esi
  0004a	89 55 08	 mov	 DWORD PTR _btMonsterType$1$[ebp], edx
  0004d	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  00052	89 45 fc	 mov	 DWORD PTR tv281[ebp], eax

; 1980 : 
; 1981 : 	if ( nSaintStatuePosNum != -1 )

  00055	83 fb ff	 cmp	 ebx, -1
  00058	0f 84 4e 01 00
	00		 je	 $LN13@SetSaintSt

; 1982 : 	{
; 1983 : 		if ( BC_STATUE_RANGE(btMonsterType-132) != FALSE )

  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _btMonsterType$1$[ebp]
  00061	0f b7 c9	 movzx	 ecx, cx
  00064	8d 91 7c ff ff
	ff		 lea	 edx, DWORD PTR [ecx-132]
  0006a	85 d2		 test	 edx, edx
  0006c	0f 88 25 01 00
	00		 js	 $LN4@SetSaintSt
  00072	33 c0		 xor	 eax, eax
  00074	83 fa 02	 cmp	 edx, 2
  00077	0f 9e c0	 setle	 al
  0007a	85 c0		 test	 eax, eax
  0007c	0f 84 12 01 00
	00		 je	 $LN12@SetSaintSt

; 1984 : 		{
; 1985 : 			int result = gObjAddMonster(btMapNumber);

  00082	56		 push	 esi
  00083	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00088	0f bf f0	 movsx	 esi, ax
  0008b	83 c4 04	 add	 esp, 4

; 1986 : 
; 1987 : 			if ( result >= 0 )

  0008e	85 f6		 test	 esi, esi
  00090	0f 88 16 01 00
	00		 js	 $LN13@SetSaintSt

; 1988 : 			{
; 1989 : 				::gObjSetPosMonster(result, nSaintStatuePosNum);

  00096	53		 push	 ebx
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 1990 : 				::gObjSetMonster(result, btMonsterType);

  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _btMonsterType$1$[ebp]
  000a0	0f b7 c1	 movzx	 eax, cx
  000a3	50		 push	 eax
  000a4	56		 push	 esi
  000a5	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1991 : 				gObj[result].Class = rand() % 3 + 132;

  000aa	69 f6 40 27 00
	00		 imul	 esi, esi, 10048
  000b0	e8 00 00 00 00	 call	 _rand
  000b5	99		 cdq
  000b6	b9 03 00 00 00	 mov	 ecx, 3
  000bb	f7 f9		 idiv	 ecx
  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1992 : 				gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;
; 1993 : 				gObj[result].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  000c2	8b 5d f8	 mov	 ebx, DWORD PTR _this$1$[ebp]
  000c5	81 c2 84 00 00
	00		 add	 edx, 132		; 00000084H
  000cb	66 89 94 06 90
	00 00 00	 mov	 WORD PTR [esi+eax+144], dx
  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d8	8b 55 fc	 mov	 edx, DWORD PTR tv281[ebp]
  000db	88 94 06 36 12
	00 00		 mov	 BYTE PTR [esi+eax+4662], dl
  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e7	66 8b 8b 74 10
	00 00		 mov	 cx, WORD PTR [ebx+4212]
  000ee	66 89 8c 06 98
	06 00 00	 mov	 WORD PTR [esi+eax+1688], cx

; 1994 : 				gObj[result].Dir = 1;
; 1995 : 				gObj[result].m_PosNum = -1;

  000f6	83 c9 ff	 or	 ecx, -1
  000f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fe	c6 84 06 22 01
	00 00 01	 mov	 BYTE PTR [esi+eax+290], 1
  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010b	66 89 8c 06 98
	05 00 00	 mov	 WORD PTR [esi+eax+1432], cx

; 1996 : 				gObj[result].Live = TRUE;

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00118	c6 44 06 51 01	 mov	 BYTE PTR [esi+eax+81], 1

; 1997 : 				gObj[result].DieRegen = 0;

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00122	c6 84 06 8a 05
	00 00 00	 mov	 BYTE PTR [esi+eax+1418], 0

; 1998 : 				gObj[result].m_State = 1;

  0012a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0012f	c7 84 06 d0 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+464], 1

; 1999 : 				gObj[result].MaxRegenTime = 0;

  0013a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013f	c7 84 06 94 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+1428], 0

; 2000 : 				gObj[result].MaxLife = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;// Maybe here Deathway Fix

  0014a	0f b6 c2	 movzx	 eax, dl
  0014d	69 d0 0c 02 00
	00		 imul	 edx, eax, 524
  00153	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00158	8b 8c 1a 6c 01
	00 00		 mov	 ecx, DWORD PTR [edx+ebx+364]
  0015f	89 8c 06 dc 00
	00 00		 mov	 DWORD PTR [esi+eax+220], ecx

; 2001 : 				gObj[result].Life = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth; // Maybe here Deathway Fix

  00166	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016b	8b 8c 1a 6c 01
	00 00		 mov	 ecx, DWORD PTR [edx+ebx+364]
  00172	89 8c 06 d8 00
	00 00		 mov	 DWORD PTR [esi+eax+216], ecx

; 2002 : 				LogAddTD("[Blood Castle] (%d) Saint Status be created.",iBridgeIndex+1);

  00179	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0017c	50		 push	 eax
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@LLNIHOPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Saint?5Status@
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00188	83 c4 18	 add	 esp, 24			; 00000018H
  0018b	5e		 pop	 esi
  0018c	5b		 pop	 ebx
  0018d	5f		 pop	 edi

; 2008 : 				iBridgeIndex+1, btMapNumber, GetBridgeLevel(btMapNumber), btMonsterType);
; 2009 : 		}
; 2010 : 	}
; 2011 : 
; 2012 : }

  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c2 04 00	 ret	 4
$LN12@SetSaintSt:
  00194	8b 45 fc	 mov	 eax, DWORD PTR tv281[ebp]
$LN4@SetSaintSt:

; 2003 : 			}
; 2004 : 		}
; 2005 : 		else
; 2006 : 		{
; 2007 : 			LogAddTD("[Blood Castle][Bug Tracer] (%d) It's not Saint Statue( Map:%d, BloodCastleIndex:%d, Type:%d )",

  00197	51		 push	 ecx
  00198	50		 push	 eax
  00199	56		 push	 esi
  0019a	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0019d	50		 push	 eax
  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@DLJLMMJB@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001a9	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@SetSaintSt:
  001ac	5e		 pop	 esi
  001ad	5b		 pop	 ebx
$LN5@SetSaintSt:
  001ae	5f		 pop	 edi

; 2008 : 				iBridgeIndex+1, btMapNumber, GetBridgeLevel(btMapNumber), btMonsterType);
; 2009 : 		}
; 2010 : 	}
; 2011 : 
; 2012 : }

  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c2 04 00	 ret	 4
?SetSaintStatue@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetSaintStatue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetBossMonster@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv303 = -16						; size = 4
_result$1$ = -16					; size = 4
tv305 = -12						; size = 4
_this$1$ = -8						; size = 4
_btBloodCastleIndex$1$ = -1				; size = 1
_iBridgeIndex$ = 8					; size = 4
?SetBossMonster@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetBossMonster, COMDAT
; _this$ = ecx

; 1925 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	8b d1		 mov	 edx, ecx

; 1926 : 	int result;
; 1927 : 
; 1928 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0000b	89 55 f8	 mov	 DWORD PTR _this$1$[ebp], edx
  0000e	85 c9		 test	 ecx, ecx
  00010	0f 88 35 01 00
	00		 js	 $LN3@SetBossMon
  00016	33 c0		 xor	 eax, eax
  00018	83 f9 07	 cmp	 ecx, 7
  0001b	0f 9e c0	 setle	 al
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 25 01 00
	00		 je	 $LN3@SetBossMon

; 1929 : 	{
; 1930 : 		return;
; 1931 : 	}
; 1932 : 
; 1933 : 	for ( int x=0;x<MAX_BLOOD_CASTLE_BOSS_MONSTER;x++)

  00026	53		 push	 ebx
  00027	69 c1 0c 02 00
	00		 imul	 eax, ecx, 524
  0002d	56		 push	 esi
  0002e	57		 push	 edi
  0002f	8d ba e4 00 00
	00		 lea	 edi, DWORD PTR [edx+228]
  00035	c7 45 f4 14 00
	00 00		 mov	 DWORD PTR tv305[ebp], 20 ; 00000014H
  0003c	03 f8		 add	 edi, eax
  0003e	66 90		 npad	 2
$LL4@SetBossMon:

; 1934 : 	{
; 1935 : 		if ( this->m_BridgeData[iBridgeIndex].m_nBossMonsterPosNum[x] != -1 )

  00040	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00042	83 fb ff	 cmp	 ebx, -1
  00045	0f 84 f0 00 00
	00		 je	 $LN2@SetBossMon

; 1936 : 		{
; 1937 : 			int nBossMonsterPosNum = this->m_BridgeData[iBridgeIndex].m_nBossMonsterPosNum[x];
; 1938 : 			WORD btMonsterType = gMSetBase.m_Mp[nBossMonsterPosNum].m_Type;

  0004b	8d 04 9b	 lea	 eax, DWORD PTR [ebx+ebx*4]

; 1939 : 			BYTE btMapNumber = gMSetBase.m_Mp[nBossMonsterPosNum].m_MapNumber;
; 1940 : 			BYTE btBloodCastleIndex = GetBridgeLevel(btMapNumber);

  0004e	8b ca		 mov	 ecx, edx
  00050	0f b7 34 85 06
	00 00 00	 movzx	 esi, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax*4+6]
  00058	8a 04 85 08 00
	00 00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax*4+8]
  0005f	0f b6 c0	 movzx	 eax, al
  00062	50		 push	 eax
  00063	89 45 f0	 mov	 DWORD PTR tv303[ebp], eax
  00066	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel

; 1941 : 
; 1942 : 			if ( btBloodCastleIndex != iBridgeIndex )

  0006b	0f b6 c8	 movzx	 ecx, al
  0006e	88 45 ff	 mov	 BYTE PTR _btBloodCastleIndex$1$[ebp], al
  00071	3b 4d 08	 cmp	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  00074	0f 85 be 00 00
	00		 jne	 $LN20@SetBossMon

; 1943 : 			{
; 1944 : 				continue;
; 1945 : 			}
; 1946 : 
; 1947 : 			if ( btMonsterType == 89 || btMonsterType == 95 || btMonsterType == 112 || btMonsterType == 118 || btMonsterType == 124 || btMonsterType == 130 || btMonsterType == 143 || btMonsterType == 433 )

  0007a	83 fe 59	 cmp	 esi, 89			; 00000059H
  0007d	74 36		 je	 SHORT $LN9@SetBossMon
  0007f	83 fe 5f	 cmp	 esi, 95			; 0000005fH
  00082	74 31		 je	 SHORT $LN9@SetBossMon
  00084	83 fe 70	 cmp	 esi, 112		; 00000070H
  00087	74 2c		 je	 SHORT $LN9@SetBossMon
  00089	83 fe 76	 cmp	 esi, 118		; 00000076H
  0008c	74 27		 je	 SHORT $LN9@SetBossMon
  0008e	83 fe 7c	 cmp	 esi, 124		; 0000007cH
  00091	74 22		 je	 SHORT $LN9@SetBossMon
  00093	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  00098	66 3b f0	 cmp	 si, ax
  0009b	74 18		 je	 SHORT $LN9@SetBossMon
  0009d	b8 8f 00 00 00	 mov	 eax, 143		; 0000008fH
  000a2	66 3b f0	 cmp	 si, ax
  000a5	74 0e		 je	 SHORT $LN9@SetBossMon
  000a7	b8 b1 01 00 00	 mov	 eax, 433		; 000001b1H
  000ac	66 3b f0	 cmp	 si, ax
  000af	0f 85 83 00 00
	00		 jne	 $LN20@SetBossMon
$LN9@SetBossMon:

; 1948 : 			{
; 1949 : 				result = ::gObjAddMonster(btMapNumber);

  000b5	ff 75 f0	 push	 DWORD PTR tv303[ebp]
  000b8	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  000bd	98		 cwde
  000be	83 c4 04	 add	 esp, 4
  000c1	89 45 f0	 mov	 DWORD PTR _result$1$[ebp], eax

; 1950 : 
; 1951 : 				if ( result >= 0 )

  000c4	85 c0		 test	 eax, eax
  000c6	78 70		 js	 SHORT $LN20@SetBossMon

; 1952 : 				{
; 1953 : 					::gObjSetPosMonster(result, nBossMonsterPosNum);

  000c8	53		 push	 ebx
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 1954 : 					::gObjSetMonster(result, btMonsterType);

  000cf	56		 push	 esi
  000d0	8b 75 f0	 mov	 esi, DWORD PTR _result$1$[ebp]
  000d3	56		 push	 esi
  000d4	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1955 : 					gObj[result].MaxRegenTime = this->m_iBC_MONSTER_REGEN;

  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000de	83 c4 10	 add	 esp, 16			; 00000010H
  000e1	8b 55 f8	 mov	 edx, DWORD PTR _this$1$[ebp]
  000e4	69 f6 40 27 00
	00		 imul	 esi, esi, 10048
  000ea	8b 8a 7c 10 00
	00		 mov	 ecx, DWORD PTR [edx+4220]
  000f0	89 8c 06 94 05
	00 00		 mov	 DWORD PTR [esi+eax+1428], ecx

; 1956 : 					gObj[result].m_cBloodCastleIndex = btBloodCastleIndex;

  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fc	8a 4d ff	 mov	 cl, BYTE PTR _btBloodCastleIndex$1$[ebp]
  000ff	88 8c 06 36 12
	00 00		 mov	 BYTE PTR [esi+eax+4662], cl

; 1957 : 					gObj[result].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;

  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010b	66 8b 8a 74 10
	00 00		 mov	 cx, WORD PTR [edx+4212]
  00112	66 89 8c 06 98
	06 00 00	 mov	 WORD PTR [esi+eax+1688], cx

; 1958 : 					gObj[result].Dir = rand() % 8;

  0011a	e8 00 00 00 00	 call	 _rand
  0011f	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00124	79 05		 jns	 SHORT $LN21@SetBossMon
  00126	48		 dec	 eax
  00127	83 c8 f8	 or	 eax, -8			; fffffff8H
  0012a	40		 inc	 eax
$LN21@SetBossMon:
  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00131	88 84 0e 22 01
	00 00		 mov	 BYTE PTR [esi+ecx+290], al
$LN20@SetBossMon:
  00138	8b 55 f8	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN2@SetBossMon:

; 1929 : 	{
; 1930 : 		return;
; 1931 : 	}
; 1932 : 
; 1933 : 	for ( int x=0;x<MAX_BLOOD_CASTLE_BOSS_MONSTER;x++)

  0013b	83 c7 04	 add	 edi, 4
  0013e	83 6d f4 01	 sub	 DWORD PTR tv305[ebp], 1
  00142	0f 85 f8 fe ff
	ff		 jne	 $LL4@SetBossMon
  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	5b		 pop	 ebx
$LN3@SetBossMon:

; 1959 : 				}
; 1960 : 			}
; 1961 : 		}
; 1962 : 	}
; 1963 : }

  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c2 04 00	 ret	 4
?SetBossMonster@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetBossMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetMonster@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv665 = -16						; size = 4
_this$1$ = -12						; size = 4
_btMonsterType$1$ = -8					; size = 4
_n$1$ = -8						; size = 4
_iIndex$1$ = -8						; size = 4
_btBridgeIndex$1$ = -1					; size = 1
_btBloodCastleIndex$1$ = -1				; size = 1
_iBridgeIndex$ = 8					; size = 4
?SetMonster@CBloodCastle@@QAEXH@Z PROC			; CBloodCastle::SetMonster, COMDAT
; _this$ = ecx

; 1813 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1814 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00008	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	89 5d f4	 mov	 DWORD PTR _this$1$[ebp], ebx
  00010	85 f6		 test	 esi, esi
  00012	0f 88 9a 03 00
	00		 js	 $LN3@SetMonster
  00018	33 c0		 xor	 eax, eax
  0001a	83 fe 07	 cmp	 esi, 7
  0001d	0f 9e c0	 setle	 al
  00020	85 c0		 test	 eax, eax
  00022	0f 84 8a 03 00
	00		 je	 $LN3@SetMonster

; 1815 : 	{
; 1816 : 		return;
; 1817 : 	}
; 1818 : 
; 1819 : 	this->SetMonsterKillCount(iBridgeIndex);

  00028	57		 push	 edi
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?SetMonsterKillCount@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetMonsterKillCount

; 1820 : 	int nCastleDoorPosNum = this->m_BridgeData[iBridgeIndex].m_nCastleDoorPosNum;

  0002f	69 c6 0c 02 00
	00		 imul	 eax, esi, 524
  00035	8b bc 18 38 01
	00 00		 mov	 edi, DWORD PTR [eax+ebx+312]

; 1821 : 	WORD btMonsterType = gMSetBase.m_Mp[nCastleDoorPosNum].m_Type;

  0003c	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  0003f	0f b7 0c 85 06
	00 00 00	 movzx	 ecx, WORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax*4+6]

; 1822 : 	BYTE btMapNumber = gMSetBase.m_Mp[nCastleDoorPosNum].m_MapNumber;

  00047	8a 04 85 08 00
	00 00		 mov	 al, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax*4+8]

; 1823 : 	BYTE btBloodCastleIndex = GetBridgeLevel(btMapNumber);

  0004e	0f b6 f0	 movzx	 esi, al
  00051	89 4d f8	 mov	 DWORD PTR _btMonsterType$1$[ebp], ecx
  00054	8b cb		 mov	 ecx, ebx
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  0005c	88 45 ff	 mov	 BYTE PTR _btBloodCastleIndex$1$[ebp], al

; 1824 : 
; 1825 : 	if ( nCastleDoorPosNum != -1 )

  0005f	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00064	83 ff ff	 cmp	 edi, -1
  00067	0f 84 1e 01 00
	00		 je	 $LN8@SetMonster

; 1826 : 	{
; 1827 : 		if ( btMonsterType == 131 )

  0006d	66 39 4d f8	 cmp	 WORD PTR _btMonsterType$1$[ebp], cx
  00071	0f 85 01 01 00
	00		 jne	 $LN7@SetMonster

; 1828 : 		{
; 1829 : 			int iIndex = ::gObjAddMonster(btMapNumber);

  00077	56		 push	 esi
  00078	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  0007d	0f bf f0	 movsx	 esi, ax
  00080	83 c4 04	 add	 esp, 4
  00083	89 75 f8	 mov	 DWORD PTR _iIndex$1$[ebp], esi

; 1830 : 
; 1831 : 			if ( iIndex >= 0 )

  00086	85 f6		 test	 esi, esi
  00088	0f 88 dd 00 00
	00		 js	 $LN9@SetMonster

; 1832 : 			{
; 1833 : 				::gObjSetPosMonster(iIndex, nCastleDoorPosNum);

  0008e	57		 push	 edi
  0008f	56		 push	 esi
  00090	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 1834 : 				::gObjSetMonster(iIndex, btMonsterType);

  00095	68 83 00 00 00	 push	 131			; 00000083H
  0009a	56		 push	 esi
  0009b	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1835 : 
; 1836 : 				gObj[iIndex].m_cBloodCastleIndex = btBloodCastleIndex;

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a5	8a 55 ff	 mov	 dl, BYTE PTR _btBloodCastleIndex$1$[ebp]
  000a8	69 fe 40 27 00
	00		 imul	 edi, esi, 10048

; 1837 : 				gObj[iIndex].m_ItemRate = this->m_iBC_NORMAL_ITEM_DROP;
; 1838 : 				gObj[iIndex].Dir = 1;
; 1839 : 				gObj[iIndex].m_PosNum = -1;
; 1840 : 				gObj[iIndex].Live = TRUE;
; 1841 : 				gObj[iIndex].DieRegen = FALSE;
; 1842 : 				gObj[iIndex].m_State = 1;
; 1843 : 				gObj[iIndex].MaxRegenTime = 0;
; 1844 : 				gObj[iIndex].MaxLife = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  000ae	0f b6 f2	 movzx	 esi, dl
  000b1	88 94 07 36 12
	00 00		 mov	 BYTE PTR [edi+eax+4662], dl
  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bd	66 8b 8b 74 10
	00 00		 mov	 cx, WORD PTR [ebx+4212]
  000c4	69 d6 0c 02 00
	00		 imul	 edx, esi, 524
  000ca	66 89 8c 07 98
	06 00 00	 mov	 WORD PTR [edi+eax+1688], cx
  000d2	83 c9 ff	 or	 ecx, -1
  000d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000da	c6 84 07 22 01
	00 00 01	 mov	 BYTE PTR [edi+eax+290], 1
  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e7	66 89 8c 07 98
	05 00 00	 mov	 WORD PTR [edi+eax+1432], cx
  000ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f4	c6 44 07 51 01	 mov	 BYTE PTR [edi+eax+81], 1
  000f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fe	c6 84 07 8a 05
	00 00 00	 mov	 BYTE PTR [edi+eax+1418], 0
  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010b	c7 84 07 d0 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [edi+eax+464], 1
  00116	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011b	c7 84 07 94 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax+1428], 0
  00126	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0012b	8b 8c 1a 6c 01
	00 00		 mov	 ecx, DWORD PTR [edx+ebx+364]
  00132	89 8c 07 dc 00
	00 00		 mov	 DWORD PTR [edi+eax+220], ecx

; 1845 : 				gObj[iIndex].Life = this->m_BridgeData[btBloodCastleIndex].m_iCastleStatueHealth;

  00139	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013e	8b 8c 1a 6c 01
	00 00		 mov	 ecx, DWORD PTR [edx+ebx+364]
  00145	89 8c 07 d8 00
	00 00		 mov	 DWORD PTR [edi+eax+216], ecx

; 1846 : 				this->m_BridgeData[btBloodCastleIndex].m_iBC_DOOR_SUBSIST_INDEX = iIndex;

  0014c	8b 45 f8	 mov	 eax, DWORD PTR _iIndex$1$[ebp]

; 1847 : 				LogAddTD("[Blood Castle] (%d) Create Door Successfuly : Index(%d)",btBloodCastleIndex+1,iIndex);

  0014f	50		 push	 eax
  00150	89 84 1a 04 02
	00 00		 mov	 DWORD PTR [edx+ebx+516], eax
  00157	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0015a	50		 push	 eax
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@KKDEDDLA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00166	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1848 : 			}
; 1849 : 			else

  00169	eb 20		 jmp	 SHORT $LN8@SetMonster
$LN9@SetMonster:

; 1850 : 			{
; 1851 : 				LogAddTD("[Blood Castle] (%d) Create Door Fail",btBloodCastleIndex+1);

  0016b	0f b6 45 ff	 movzx	 eax, BYTE PTR _btBloodCastleIndex$1$[ebp]
  0016f	40		 inc	 eax
  00170	50		 push	 eax
  00171	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PEIIJNGA@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Create?5Door?5@

; 1852 : 			}
; 1853 : 		}
; 1854 : 		else

  00176	eb 0a		 jmp	 SHORT $LN35@SetMonster
$LN7@SetMonster:

; 1855 : 		{
; 1856 : 			LogAddTD("[Blood Castle] (%d) Door monster type Error",btBloodCastleIndex+1);

  00178	0f b6 c0	 movzx	 eax, al
  0017b	40		 inc	 eax
  0017c	50		 push	 eax
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@LMONCAJK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5monster@
$LN35@SetMonster:
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00188	83 c4 08	 add	 esp, 8
$LN8@SetMonster:

; 1857 : 		}
; 1858 : 	}
; 1859 : 
; 1860 : 	int result;
; 1861 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  0018b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1$[ebp], 0
  00192	bf 08 00 00 00	 mov	 edi, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+8
$LL4@SetMonster:

; 1862 : 	{
; 1863 : 		if ( BC_MAP_RANGE(gMSetBase.m_Mp[n].m_MapNumber) != FALSE  )

  00197	8a 0f		 mov	 cl, BYTE PTR [edi]
  00199	80 f9 34	 cmp	 cl, 52			; 00000034H
  0019c	74 1b		 je	 SHORT $LN32@SetMonster
  0019e	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  001a1	0f 82 f8 01 00
	00		 jb	 $LN2@SetMonster
  001a7	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  001ac	3a c1		 cmp	 al, cl
  001ae	1b c0		 sbb	 eax, eax
  001b0	83 c0 01	 add	 eax, 1
  001b3	0f 84 e6 01 00
	00		 je	 $LN2@SetMonster
$LN32@SetMonster:

; 1864 : 		{
; 1865 : 			WORD btIndex = gMSetBase.m_Mp[n].m_Type;

  001b9	0f b7 77 fe	 movzx	 esi, WORD PTR [edi-2]

; 1866 : 			BYTE btMap   = gMSetBase.m_Mp[n].m_MapNumber;
; 1867 : 			BYTE btBridgeIndex = GetBridgeLevel(btMap);

  001bd	0f b6 d9	 movzx	 ebx, cl
  001c0	8b 4d f4	 mov	 ecx, DWORD PTR _this$1$[ebp]
  001c3	53		 push	 ebx
  001c4	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel

; 1868 : 			
; 1869 : 			if ( btBridgeIndex != iBridgeIndex )

  001c9	0f b6 c8	 movzx	 ecx, al
  001cc	88 45 ff	 mov	 BYTE PTR _btBridgeIndex$1$[ebp], al
  001cf	3b 4d 08	 cmp	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  001d2	0f 85 c7 01 00
	00		 jne	 $LN2@SetMonster

; 1870 : 			{
; 1871 : 				continue;
; 1872 : 			}
; 1873 : 
; 1874 : 			if ( btIndex == 232 )

  001d8	b8 e8 00 00 00	 mov	 eax, 232		; 000000e8H
  001dd	66 3b f0	 cmp	 si, ax
  001e0	0f 84 b9 01 00
	00		 je	 $LN2@SetMonster

; 1875 : 			{
; 1876 : 				continue;
; 1877 : 			}
; 1878 : 
; 1879 : 			if ( btIndex == 131 )

  001e6	b8 83 00 00 00	 mov	 eax, 131		; 00000083H
  001eb	66 3b f0	 cmp	 si, ax
  001ee	0f 84 ab 01 00
	00		 je	 $LN2@SetMonster

; 1880 : 			{
; 1881 : 				continue;
; 1882 : 			}
; 1883 : 
; 1884 : 			if ( btIndex == 89 || btIndex == 95 || btIndex == 112  || btIndex == 118 || btIndex == 124 || btIndex == 130 || btIndex == 143 || btIndex == 433 )

  001f4	83 fe 59	 cmp	 esi, 89			; 00000059H
  001f7	0f 84 a2 01 00
	00		 je	 $LN2@SetMonster
  001fd	83 fe 5f	 cmp	 esi, 95			; 0000005fH
  00200	0f 84 99 01 00
	00		 je	 $LN2@SetMonster
  00206	83 fe 70	 cmp	 esi, 112		; 00000070H
  00209	0f 84 90 01 00
	00		 je	 $LN2@SetMonster
  0020f	83 fe 76	 cmp	 esi, 118		; 00000076H
  00212	0f 84 87 01 00
	00		 je	 $LN2@SetMonster
  00218	83 fe 7c	 cmp	 esi, 124		; 0000007cH
  0021b	0f 84 7e 01 00
	00		 je	 $LN2@SetMonster
  00221	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  00226	66 3b f0	 cmp	 si, ax
  00229	0f 84 70 01 00
	00		 je	 $LN2@SetMonster
  0022f	b8 8f 00 00 00	 mov	 eax, 143		; 0000008fH
  00234	66 3b f0	 cmp	 si, ax
  00237	0f 84 62 01 00
	00		 je	 $LN2@SetMonster
  0023d	b8 b1 01 00 00	 mov	 eax, 433		; 000001b1H
  00242	66 3b f0	 cmp	 si, ax
  00245	0f 84 54 01 00
	00		 je	 $LN2@SetMonster

; 1885 : 			{
; 1886 : 				continue;
; 1887 : 			}
; 1888 : 
; 1889 : 			if ( BC_STATUE_RANGE(btIndex-132) != FALSE )

  0024b	8b c6		 mov	 eax, esi
  0024d	89 45 f0	 mov	 DWORD PTR tv665[ebp], eax
  00250	8d 88 7c ff ff
	ff		 lea	 ecx, DWORD PTR [eax-132]
  00256	85 c9		 test	 ecx, ecx
  00258	78 10		 js	 SHORT $LN33@SetMonster
  0025a	33 c0		 xor	 eax, eax
  0025c	83 f9 02	 cmp	 ecx, 2
  0025f	0f 9e c0	 setle	 al
  00262	85 c0		 test	 eax, eax
  00264	0f 85 35 01 00
	00		 jne	 $LN2@SetMonster
$LN33@SetMonster:

; 1890 : 			{
; 1891 : 				continue;
; 1892 : 			}
; 1893 : 
; 1894 : 			result = gObjAddMonster(gMSetBase.m_Mp[n].m_MapNumber);

  0026a	53		 push	 ebx
  0026b	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00270	0f bf d0	 movsx	 edx, ax
  00273	83 c4 04	 add	 esp, 4

; 1895 : 
; 1896 : 			if ( result >= 0 )

  00276	85 d2		 test	 edx, edx
  00278	0f 88 21 01 00
	00		 js	 $LN2@SetMonster

; 1897 : 			{
; 1898 : 				gObj[result].m_PosNum = n;

  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00283	8b 4d f8	 mov	 ecx, DWORD PTR _n$1$[ebp]
  00286	69 f2 40 27 00
	00		 imul	 esi, edx, 10048

; 1899 : 				gObj[result].X = gMSetBase.m_Mp[n].m_X;
; 1900 : 				gObj[result].Y = gMSetBase.m_Mp[n].m_Y;
; 1901 : 				gObj[result].MapNumber = gMSetBase.m_Mp[n].m_MapNumber;
; 1902 : 				gObj[result].TX = gObj[result].X;
; 1903 : 				gObj[result].TY = gObj[result].Y;
; 1904 : 				gObj[result].m_OldX = gObj[result].X;
; 1905 : 				gObj[result].m_OldY = gObj[result].Y;
; 1906 : 				gObj[result].Dir = gMSetBase.m_Mp[n].m_Dir;
; 1907 : 				gObj[result].StartX = gObj[result].X;
; 1908 : 				gObj[result].StartY = gObj[result].Y;
; 1909 : 				gObjSetMonster(result, btIndex);

  0028c	ff 75 f0	 push	 DWORD PTR tv665[ebp]
  0028f	52		 push	 edx
  00290	66 89 8c 06 98
	05 00 00	 mov	 WORD PTR [esi+eax+1432], cx
  00298	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029d	0f b6 4f 02	 movzx	 ecx, BYTE PTR [edi+2]
  002a1	88 8c 06 20 01
	00 00		 mov	 BYTE PTR [esi+eax+288], cl
  002a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ad	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  002b1	88 8c 06 21 01
	00 00		 mov	 BYTE PTR [esi+eax+289], cl
  002b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002bd	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  002c0	88 8c 06 23 01
	00 00		 mov	 BYTE PTR [esi+eax+291], cl
  002c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002cd	0f b6 84 0e 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+288]
  002d5	88 84 0e 52 01
	00 00		 mov	 BYTE PTR [esi+ecx+338], al
  002dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e2	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  002ea	88 84 0e 53 01
	00 00		 mov	 BYTE PTR [esi+ecx+339], al
  002f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f7	0f b6 84 0e 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+288]
  002ff	88 84 0e 50 01
	00 00		 mov	 BYTE PTR [esi+ecx+336], al
  00306	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0030c	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  00314	88 84 0e 51 01
	00 00		 mov	 BYTE PTR [esi+ecx+337], al
  0031b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00320	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  00324	88 8c 06 22 01
	00 00		 mov	 BYTE PTR [esi+eax+290], cl
  0032b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00331	0f b6 84 0e 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+288]
  00339	88 84 0e 4e 01
	00 00		 mov	 BYTE PTR [esi+ecx+334], al
  00340	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00346	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  0034e	88 84 0e 4f 01
	00 00		 mov	 BYTE PTR [esi+ecx+335], al
  00355	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 1910 : 				gObj[result].MaxRegenTime = this->m_iBC_MONSTER_REGEN;

  0035a	8b 45 f4	 mov	 eax, DWORD PTR _this$1$[ebp]
  0035d	83 c4 08	 add	 esp, 8
  00360	8b 88 7c 10 00
	00		 mov	 ecx, DWORD PTR [eax+4220]
  00366	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0036b	89 8c 06 94 05
	00 00		 mov	 DWORD PTR [esi+eax+1428], ecx

; 1911 : 				gObj[result].m_cBloodCastleIndex = btBridgeIndex;

  00372	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00377	8a 4d ff	 mov	 cl, BYTE PTR _btBridgeIndex$1$[ebp]
  0037a	88 8c 06 36 12
	00 00		 mov	 BYTE PTR [esi+eax+4662], cl

; 1912 : 				gObj[result].Dir = rand() % 8;

  00381	e8 00 00 00 00	 call	 _rand
  00386	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0038b	79 05		 jns	 SHORT $LN34@SetMonster
  0038d	48		 dec	 eax
  0038e	83 c8 f8	 or	 eax, -8			; fffffff8H
  00391	40		 inc	 eax
$LN34@SetMonster:
  00392	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00398	88 84 0e 22 01
	00 00		 mov	 BYTE PTR [esi+ecx+290], al
$LN2@SetMonster:

; 1857 : 		}
; 1858 : 	}
; 1859 : 
; 1860 : 	int result;
; 1861 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  0039f	ff 45 f8	 inc	 DWORD PTR _n$1$[ebp]
  003a2	83 c7 14	 add	 edi, 20			; 00000014H
  003a5	81 ff 58 34 03
	00		 cmp	 edi, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A+210008
  003ab	0f 8c e6 fd ff
	ff		 jl	 $LL4@SetMonster
  003b1	5f		 pop	 edi
$LN3@SetMonster:
  003b2	5e		 pop	 esi
  003b3	5b		 pop	 ebx

; 1913 : 			}
; 1914 : 		}
; 1915 : 	}
; 1916 : 	
; 1917 : }

  003b4	8b e5		 mov	 esp, ebp
  003b6	5d		 pop	 ebp
  003b7	c2 04 00	 ret	 4
?SetMonster@CBloodCastle@@QAEXH@Z ENDP			; CBloodCastle::SetMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ClearMonster@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
tv207 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
_bClearCastleDoor$ = 12					; size = 1
?ClearMonster@CBloodCastle@@QAEXH_N@Z PROC		; CBloodCastle::ClearMonster, COMDAT
; _this$ = ecx

; 1782 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1783 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 78		 js	 SHORT $LN3@ClearMonst
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 6c		 je	 SHORT $LN3@ClearMonst

; 1789 : 	{
; 1790 : 		if ( gObj[n].MapNumber == GetEventMap(iBridgeIndex) )

  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	52		 push	 edx
  0001a	33 ff		 xor	 edi, edi
  0001c	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00021	8a 5d 0c	 mov	 bl, BYTE PTR _bClearCastleDoor$[ebp]
  00024	8b d0		 mov	 edx, eax
  00026	89 55 08	 mov	 DWORD PTR tv207[ebp], edx
  00029	33 f6		 xor	 esi, esi
  0002b	0f 1f 44 00 00	 npad	 5
$LL4@ClearMonst:
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	0f b6 84 0e 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+291]
  0003e	3b c2		 cmp	 eax, edx
  00040	75 2e		 jne	 SHORT $LN2@ClearMonst

; 1791 : 		{
; 1792 : 			if ( bClearCastleDoor == false && gObj[n].Class == 131)

  00042	84 db		 test	 bl, bl
  00044	75 0f		 jne	 SHORT $LN7@ClearMonst
  00046	b8 83 00 00 00	 mov	 eax, 131		; 00000083H
  0004b	66 39 84 0e 90
	00 00 00	 cmp	 WORD PTR [esi+ecx+144], ax
  00053	74 1b		 je	 SHORT $LN2@ClearMonst
$LN7@ClearMonst:

; 1793 : 			{
; 1794 : 				continue;
; 1795 : 			}
; 1796 : 
; 1797 : 			if ( gObj[n].Class == 232 )

  00055	b8 e8 00 00 00	 mov	 eax, 232		; 000000e8H
  0005a	66 39 84 0e 90
	00 00 00	 cmp	 WORD PTR [esi+ecx+144], ax
  00062	74 0c		 je	 SHORT $LN2@ClearMonst

; 1798 : 			{
; 1799 : 				continue;
; 1800 : 			}
; 1801 : 
; 1802 : 			gObjDel(n);

  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0006a	8b 55 08	 mov	 edx, DWORD PTR tv207[ebp]
  0006d	83 c4 04	 add	 esp, 4
$LN2@ClearMonst:

; 1784 : 	{
; 1785 : 		return;
; 1786 : 	}
; 1787 : 
; 1788 : 	for ( int n=0;n<OBJ_MAXMONSTER;n++)

  00070	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00076	47		 inc	 edi
  00077	81 fe 00 dd 49
	06		 cmp	 esi, 105504000		; 0649dd00H
  0007d	7c b1		 jl	 SHORT $LL4@ClearMonst
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
$LN3@ClearMonst:

; 1803 : 		}
; 1804 : 	}
; 1805 : }

  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
?ClearMonster@CBloodCastle@@QAEXH_N@Z ENDP		; CBloodCastle::ClearMonster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z
_TEXT	SEGMENT
_s_num$1$ = -172					; size = 4
_map_num$1$ = -168					; size = 4
_type$1$ = -164						; size = 4
_NOption$ = -160					; size = 1
_PetLevel$1$ = -156					; size = 4
_iIndex$GSCopy$1$ = -152				; size = 4
_level$1$ = -148					; size = 4
_Option1$ = -144					; size = 1
_Option2$ = -140					; size = 1
_Option3$ = -136					; size = 1
_dur$1$ = -132						; size = 4
_SOption$ = -128					; size = 1
_ItemEffectEx$ = -124					; size = 1
_SocketBonus$ = -120					; size = 1
tv610 = -116						; size = 4
_iItemPos$GSCopy$1$ = -112				; size = 4
tv603 = -108						; size = 4
_pResult$ = -104					; size = 5
_ItemExOption$1$ = -94					; size = 1
_ItemExLevel$1$ = -93					; size = 1
_pMsg$1 = -92						; size = 17
_szItemName$ = -72					; size = 50
_NewOption$ = -20					; size = 8
_SocketOption$ = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
_iItemType$ = 16					; size = 4
_iItemPos$ = 20						; size = 4
?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z PROC		; CBloodCastle::DropItemDirectly, COMDAT
; _this$ = ecx

; 3874 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 14	 mov	 ebx, DWORD PTR _iItemPos$[ebp]
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0001b	57		 push	 edi

; 3875 : 	if ( BC_MAP_RANGE(GetEventMap(iBridgeIndex)) == FALSE )

  0001c	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  0001f	57		 push	 edi
  00020	89 b5 68 ff ff
	ff		 mov	 DWORD PTR _iIndex$GSCopy$1$[ebp], esi
  00026	89 5d 90	 mov	 DWORD PTR _iItemPos$GSCopy$1$[ebp], ebx
  00029	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  0002e	83 f8 34	 cmp	 eax, 52			; 00000034H
  00031	74 4d		 je	 SHORT $LN2@DropItemDi
  00033	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00036	7c 0c		 jl	 SHORT $LN14@DropItemDi
  00038	33 c9		 xor	 ecx, ecx
  0003a	83 f8 11	 cmp	 eax, 17			; 00000011H
  0003d	0f 9e c1	 setle	 cl
  00040	85 c9		 test	 ecx, ecx
  00042	75 3c		 jne	 SHORT $LN2@DropItemDi
$LN14@DropItemDi:

; 3876 : 	{
; 3877 : 		LogAddTD("[Blood Castle] [%s][%s] DropItemDirectly() failed (iBridgeIndex wrong - %d)",

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004a	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  00050	57		 push	 edi
  00051	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00054	03 c2		 add	 eax, edx
  00056	50		 push	 eax
  00057	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0005a	03 c2		 add	 eax, edx
  0005c	50		 push	 eax
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CLFOPJPH@?$FLBlood?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5DropItem@
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00068	83 c4 10	 add	 esp, 16			; 00000010H

; 3878 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iBridgeIndex);
; 3879 : 
; 3880 : 		return false;

  0006b	33 c0		 xor	 eax, eax

; 3964 : }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	33 cd		 xor	 ecx, ebp
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 10 00	 ret	 16			; 00000010H
$LN2@DropItemDi:

; 3881 : 	}
; 3882 : 
; 3883 : 	PMSG_ITEMTHROW_RESULT pResult;
; 3884 : 
; 3885 : 	PHeadSetB((LPBYTE)&pResult, 0x23, sizeof(pResult));

  00080	6a 05		 push	 5
  00082	8d 45 98	 lea	 eax, DWORD PTR _pResult$[ebp]
  00085	6a 23		 push	 35			; 00000023H
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3886 : 	pResult.Result = TRUE;
; 3887 : 	pResult.Ipos = iItemPos;
; 3888 : 	int map_num = gObj[iIndex].MapNumber;

  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
  00095	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  0009b	88 5d 9c	 mov	 BYTE PTR _pResult$[ebp+4], bl
  0009e	c6 45 9b 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 3889 : 	int type = gObj[iIndex].pInventory[iItemPos].m_Type;

  000a2	69 db d4 00 00
	00		 imul	 ebx, ebx, 212
  000a8	89 7d 8c	 mov	 DWORD PTR tv610[ebp], edi
  000ab	0f b6 8c 07 23
	01 00 00	 movzx	 ecx, BYTE PTR [edi+eax+291]
  000b3	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _map_num$1$[ebp], ecx
  000b9	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  000c0	0f bf 44 19 06	 movsx	 eax, WORD PTR [ecx+ebx+6]
  000c5	03 cb		 add	 ecx, ebx
  000c7	89 85 5c ff ff
	ff		 mov	 DWORD PTR _type$1$[ebp], eax
  000cd	89 5d 94	 mov	 DWORD PTR tv603[ebp], ebx

; 3890 : 	int level = gObj[iIndex].pInventory[iItemPos].m_Level;

  000d0	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]

; 3891 : 	float dur = gObj[iIndex].pInventory[iItemPos].m_Durability;

  000d4	f3 0f 10 41 24	 movss	 xmm0, DWORD PTR [ecx+36]
  000d9	89 85 6c ff ff
	ff		 mov	 DWORD PTR _level$1$[ebp], eax
  000df	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _dur$1$[ebp], xmm0

; 3892 : 	BOOL ret = gObj[iIndex].pInventory[iItemPos].IsItem();

  000e7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 3893 : 	BYTE Option1 = gObj[iIndex].pInventory[iItemPos].m_Option1;

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f1	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  000f8	8a 84 19 90 00
	00 00		 mov	 al, BYTE PTR [ecx+ebx+144]
  000ff	03 cb		 add	 ecx, ebx
  00101	88 85 70 ff ff
	ff		 mov	 BYTE PTR _Option1$[ebp], al

; 3894 : 	BYTE Option2 = gObj[iIndex].pInventory[iItemPos].m_Option2;
; 3895 : 	BYTE Option3 = gObj[iIndex].pInventory[iItemPos].m_Option3;
; 3896 : 	BYTE NOption = gObj[iIndex].pInventory[iItemPos].m_NewOption;
; 3897 : 	DWORD s_num = gObj[iIndex].pInventory[iItemPos].m_Number;
; 3898 : 	BYTE ItemExOption = g_kJewelOfHarmonySystem.GetItemStrengthenOption(&gObj[iIndex].pInventory[iItemPos]);

  00107	51		 push	 ecx
  00108	8a 81 91 00 00
	00		 mov	 al, BYTE PTR [ecx+145]
  0010e	88 85 74 ff ff
	ff		 mov	 BYTE PTR _Option2$[ebp], al
  00114	8a 81 92 00 00
	00		 mov	 al, BYTE PTR [ecx+146]
  0011a	88 85 78 ff ff
	ff		 mov	 BYTE PTR _Option3$[ebp], al
  00120	8a 81 93 00 00
	00		 mov	 al, BYTE PTR [ecx+147]
  00126	88 85 60 ff ff
	ff		 mov	 BYTE PTR _NOption$[ebp], al
  0012c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0012e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00133	89 85 54 ff ff
	ff		 mov	 DWORD PTR _s_num$1$[ebp], eax
  00139	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption

; 3899 : 	BYTE ItemExLevel = g_kJewelOfHarmonySystem.GetItemOptionLevel(&gObj[iIndex].pInventory[iItemPos]);

  0013e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00144	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00149	88 45 a2	 mov	 BYTE PTR _ItemExOption$1$[ebp], al
  0014c	8b 94 17 c0 11
	00 00		 mov	 edx, DWORD PTR [edi+edx+4544]
  00153	03 d3		 add	 edx, ebx
  00155	52		 push	 edx
  00156	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel

; 3900 : 
; 3901 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 3902 : 	::ItemIsBufExOption(NewOption, &gObj[iIndex].pInventory[iItemPos]);

  0015b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00161	88 45 a3	 mov	 BYTE PTR _ItemExLevel$1$[ebp], al
  00164	8d 45 ec	 lea	 eax, DWORD PTR _NewOption$[ebp]
  00167	8b 8c 0f c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+ecx+4544]
  0016e	03 cb		 add	 ecx, ebx
  00170	51		 push	 ecx
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 3903 : 	int PetLevel = gObj[iIndex].pInventory[iItemPos].m_PetItem_Level;

  00177	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3904 : 	int PetExp = gObj[iIndex].pInventory[iItemPos].m_PetItem_Exp;
; 3905 : 	BYTE SOption = gObj[iIndex].pInventory[iItemPos].m_SetOption;
; 3906 : 	BYTE ItemEffectEx = gObj[iIndex].pInventory[iItemPos].m_ItemOptionEx;
; 3907 : 	int item_number = gObj[iIndex].pInventory[iItemPos].m_Number;
; 3908 : 	char szItemName[50] = "Item";

  0017d	6a 2d		 push	 45			; 0000002dH
  0017f	6a 00		 push	 0
  00181	8b 84 37 c0 11
	00 00		 mov	 eax, DWORD PTR [edi+esi+4544]
  00188	8b 8c 03 b8 00
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+184]
  0018f	8b 9c 03 bc 00
	00 00		 mov	 ebx, DWORD PTR [ebx+eax+188]
  00196	89 8d 64 ff ff
	ff		 mov	 DWORD PTR _PetLevel$1$[ebp], ecx
  0019c	8b 4d 94	 mov	 ecx, DWORD PTR tv603[ebp]
  0019f	8a 94 01 aa 00
	00 00		 mov	 dl, BYTE PTR [ecx+eax+170]
  001a6	8b 3c 01	 mov	 edi, DWORD PTR [ecx+eax]
  001a9	88 55 80	 mov	 BYTE PTR _SOption$[ebp], dl
  001ac	8a 94 01 c6 00
	00 00		 mov	 dl, BYTE PTR [ecx+eax+198]
  001b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04BGCMBJDA@Item?$AA@
  001b8	89 45 b8	 mov	 DWORD PTR _szItemName$[ebp], eax
  001bb	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_04BGCMBJDA@Item?$AA@+4
  001c0	88 45 bc	 mov	 BYTE PTR _szItemName$[ebp+4], al
  001c3	8d 45 bd	 lea	 eax, DWORD PTR _szItemName$[ebp+5]
  001c6	50		 push	 eax
  001c7	88 55 84	 mov	 BYTE PTR _ItemEffectEx$[ebp], dl
  001ca	e8 00 00 00 00	 call	 _memset
  001cf	83 c4 14	 add	 esp, 20			; 00000014H

; 3909 : 	int aAntiLootIndex = -1;
; 3910 : 	
; 3911 : 	BYTE SocketOption[MAX_SOCKET_COUNT];
; 3912 : 	SocketOption[0] = 0xFF;

  001d2	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _SocketOption$[ebp], -1

; 3913 : 	SocketOption[1] = 0xFF;
; 3914 : 	SocketOption[2] = 0xFF;
; 3915 : 	SocketOption[3] = 0xFF;
; 3916 : 	SocketOption[4] = 0xFF;
; 3917 : 	BYTE SocketBonus = 0;
; 3918 : 
; 3919 : 	g_SocketItem.GetItemOptions(&gObj[iIndex].pInventory[iItemPos],&SocketOption[0],&SocketBonus);

  001d9	8d 45 88	 lea	 eax, DWORD PTR _SocketBonus$[ebp]
  001dc	c6 45 f8 ff	 mov	 BYTE PTR _SocketOption$[ebp+4], 255 ; 000000ffH
  001e0	c6 45 88 00	 mov	 BYTE PTR _SocketBonus$[ebp], 0
  001e4	50		 push	 eax
  001e5	8b 4d 8c	 mov	 ecx, DWORD PTR tv610[ebp]
  001e8	8d 45 f4	 lea	 eax, DWORD PTR _SocketOption$[ebp]
  001eb	50		 push	 eax
  001ec	8b 84 31 c0 11
	00 00		 mov	 eax, DWORD PTR [ecx+esi+4544]
  001f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketItem@@3VCSocketItems@@A ; g_SocketItem
  001f8	03 45 94	 add	 eax, DWORD PTR tv603[ebp]
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 ?GetItemOptions@CSocketItems@@QAEXPAVCItem@@PAE1@Z ; CSocketItems::GetItemOptions

; 3920 : 
; 3921 : 	if ( MapC[map_num].ItemDrop(type, level, dur, gObj[iIndex].X, gObj[iIndex].Y,Option1, Option2, Option3, NOption, SOption, item_number, aAntiLootIndex, PetLevel, PetExp, ItemEffectEx, SocketOption,SocketBonus) == TRUE )

  00201	ff 75 88	 push	 DWORD PTR _SocketBonus$[ebp]
  00204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020a	8d 45 f4	 lea	 eax, DWORD PTR _SocketOption$[ebp]
  0020d	50		 push	 eax
  0020e	ff 75 84	 push	 DWORD PTR _ItemEffectEx$[ebp]
  00211	8b 75 8c	 mov	 esi, DWORD PTR tv610[ebp]
  00214	53		 push	 ebx
  00215	ff b5 64 ff ff
	ff		 push	 DWORD PTR _PetLevel$1$[ebp]
  0021b	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _dur$1$[ebp]
  00223	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  0022b	6a ff		 push	 -1
  0022d	57		 push	 edi
  0022e	ff 75 80	 push	 DWORD PTR _SOption$[ebp]
  00231	8b bd 5c ff ff
	ff		 mov	 edi, DWORD PTR _type$1$[ebp]
  00237	ff b5 60 ff ff
	ff		 push	 DWORD PTR _NOption$[ebp]
  0023d	ff b5 78 ff ff
	ff		 push	 DWORD PTR _Option3$[ebp]
  00243	ff b5 74 ff ff
	ff		 push	 DWORD PTR _Option2$[ebp]
  00249	ff b5 70 ff ff
	ff		 push	 DWORD PTR _Option1$[ebp]
  0024f	50		 push	 eax
  00250	0f b6 84 0e 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+288]
  00258	50		 push	 eax
  00259	51		 push	 ecx
  0025a	69 8d 58 ff ff
	ff 28 38 05 00	 imul	 ecx, DWORD PTR _map_num$1$[ebp], 342056
  00264	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00269	ff b5 6c ff ff
	ff		 push	 DWORD PTR _level$1$[ebp]
  0026f	57		 push	 edi
  00270	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00276	e8 00 00 00 00	 call	 ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEPAEE@Z ; MapClass::ItemDrop

; 3922 : 	{
; 3923 : 		::gObjInventoryDeleteItem(iIndex, iItemPos);

  0027b	8b 9d 68 ff ff
	ff		 mov	 ebx, DWORD PTR _iIndex$GSCopy$1$[ebp]
  00281	83 f8 01	 cmp	 eax, 1
  00284	0f 85 c5 00 00
	00		 jne	 $LN3@DropItemDi
  0028a	8b 4d 90	 mov	 ecx, DWORD PTR _iItemPos$GSCopy$1$[ebp]
  0028d	51		 push	 ecx
  0028e	53		 push	 ebx
  0028f	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 3924 : 		pResult.Result = TRUE;
; 3925 : 
; 3926 : 		LogAddTD(lMsg.Get(MSGGET(1, 223)), gObj[iIndex].AccountID, gObj[iIndex].Name, gObj[iIndex].MapNumber,

  00294	0f b6 45 a3	 movzx	 eax, BYTE PTR _ItemExLevel$1$[ebp]
  00298	83 c4 08	 add	 esp, 8
  0029b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a1	c6 45 9b 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  002a5	50		 push	 eax
  002a6	0f b6 45 a2	 movzx	 eax, BYTE PTR _ItemExOption$1$[ebp]
  002aa	50		 push	 eax
  002ab	0f b6 45 84	 movzx	 eax, BYTE PTR _ItemEffectEx$[ebp]
  002af	c1 e8 07	 shr	 eax, 7
  002b2	50		 push	 eax
  002b3	0f b6 45 80	 movzx	 eax, BYTE PTR _SOption$[ebp]
  002b7	50		 push	 eax
  002b8	0f b6 45 f2	 movzx	 eax, BYTE PTR _NewOption$[ebp+6]
  002bc	50		 push	 eax
  002bd	0f b6 45 f1	 movzx	 eax, BYTE PTR _NewOption$[ebp+5]
  002c1	50		 push	 eax
  002c2	0f b6 45 f0	 movzx	 eax, BYTE PTR _NewOption$[ebp+4]
  002c6	50		 push	 eax
  002c7	0f b6 45 ef	 movzx	 eax, BYTE PTR _NewOption$[ebp+3]
  002cb	50		 push	 eax
  002cc	0f b6 45 ee	 movzx	 eax, BYTE PTR _NewOption$[ebp+2]
  002d0	50		 push	 eax
  002d1	0f b6 45 ed	 movzx	 eax, BYTE PTR _NewOption$[ebp+1]
  002d5	50		 push	 eax
  002d6	0f b6 45 ec	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  002da	50		 push	 eax
  002db	f3 0f 2c 85 7c
	ff ff ff	 cvttss2si eax, DWORD PTR _dur$1$[ebp]
  002e3	50		 push	 eax
  002e4	0f b6 85 78 ff
	ff ff		 movzx	 eax, BYTE PTR _Option3$[ebp]
  002eb	50		 push	 eax
  002ec	0f b6 85 74 ff
	ff ff		 movzx	 eax, BYTE PTR _Option2$[ebp]
  002f3	50		 push	 eax
  002f4	0f b6 85 70 ff
	ff ff		 movzx	 eax, BYTE PTR _Option1$[ebp]
  002fb	50		 push	 eax
  002fc	ff b5 6c ff ff
	ff		 push	 DWORD PTR _level$1$[ebp]
  00302	8d 45 b8	 lea	 eax, DWORD PTR _szItemName$[ebp]
  00305	57		 push	 edi
  00306	50		 push	 eax
  00307	ff b5 54 ff ff
	ff		 push	 DWORD PTR _s_num$1$[ebp]
  0030d	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  00315	50		 push	 eax
  00316	0f b6 84 0e 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+288]
  0031e	50		 push	 eax
  0031f	0f b6 84 0e 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+291]
  00327	50		 push	 eax
  00328	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0032b	03 c6		 add	 eax, esi
  0032d	50		 push	 eax
  0032e	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00331	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00336	03 c6		 add	 eax, esi
  00338	50		 push	 eax
  00339	68 df 01 00 00	 push	 479			; 000001dfH
  0033e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00343	50		 push	 eax
  00344	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0034a	83 c4 64	 add	 esp, 100		; 00000064H

; 3927 : 			gObj[iIndex].X, gObj[iIndex].Y, s_num, szItemName, type, level, Option1, Option2, Option3, (int)dur, NewOption[0],
; 3928 : 			NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], SOption,
; 3929 : 			ItemEffectEx>>7, ItemExOption, ItemExLevel);
; 3930 : 	}
; 3931 : 	else

  0034d	eb 04		 jmp	 SHORT $LN4@DropItemDi
$LN3@DropItemDi:

; 3932 : 	{
; 3933 : 		pResult.Result = FALSE;

  0034f	c6 45 9b 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN4@DropItemDi:

; 3934 : 	}
; 3935 : 
; 3936 : 	DataSend(iIndex, (UCHAR*)&pResult, pResult.h.size);

  00353	0f b6 45 99	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00357	50		 push	 eax
  00358	8d 45 98	 lea	 eax, DWORD PTR _pResult$[ebp]
  0035b	50		 push	 eax
  0035c	53		 push	 ebx
  0035d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3937 : 
; 3938 : 	if ( pResult.Result == TRUE )

  00362	8a 4d 9b	 mov	 cl, BYTE PTR _pResult$[ebp+3]
  00365	83 c4 0c	 add	 esp, 12			; 0000000cH
  00368	80 f9 01	 cmp	 cl, 1
  0036b	0f 85 b1 00 00
	00		 jne	 $LN6@DropItemDi

; 3939 : 	{
; 3940 : 		if ( iItemPos < INVENTORY_BAG_START )

  00371	8b 45 90	 mov	 eax, DWORD PTR _iItemPos$GSCopy$1$[ebp]
  00374	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00377	0f 8d a5 00 00
	00		 jge	 $LN6@DropItemDi

; 3941 : 		{
; 3942 : 			if ( iItemPos== 10 || iItemPos == 11 )

  0037d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00380	74 05		 je	 SHORT $LN8@DropItemDi
  00382	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00385	75 0b		 jne	 SHORT $LN7@DropItemDi
$LN8@DropItemDi:

; 3943 : 			{
; 3944 : 				gObjUseSkill.SkillChangeUse(iIndex);

  00387	53		 push	 ebx
  00388	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0038d	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN7@DropItemDi:

; 3945 : 			}
; 3946 : 
; 3947 : 			::gObjMakePreviewCharSet(iIndex);

  00392	53		 push	 ebx
  00393	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 3948 : 
; 3949 : 			PMSG_USEREQUIPMENTCHANGED pMsg;
; 3950 : 
; 3951 : 			PHeadSetB((LPBYTE)&pMsg, 0x25, sizeof(PMSG_USEREQUIPMENTCHANGED));

  00398	6a 11		 push	 17			; 00000011H
  0039a	8d 45 a4	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0039d	6a 25		 push	 37			; 00000025H
  0039f	50		 push	 eax
  003a0	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3952 : 			pMsg.NumberH = SET_NUMBERH(iIndex);

  003a5	8b c3		 mov	 eax, ebx

; 3953 : 			pMsg.NumberL = SET_NUMBERL(iIndex);

  003a7	88 5d a8	 mov	 BYTE PTR _pMsg$1[ebp+4], bl
  003aa	c1 e8 08	 shr	 eax, 8

; 3954 : 			ItemByteConvert(pMsg.ItemInfo, gObj[iIndex].pInventory[iItemPos]);

  003ad	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  003b3	88 45 a7	 mov	 BYTE PTR _pMsg$1[ebp+3], al
  003b6	8b fc		 mov	 edi, esp
  003b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003bd	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  003c2	8b b4 06 c0 11
	00 00		 mov	 esi, DWORD PTR [esi+eax+4544]
  003c9	8d 45 a9	 lea	 eax, DWORD PTR _pMsg$1[ebp+5]
  003cc	03 75 94	 add	 esi, DWORD PTR tv603[ebp]
  003cf	f3 a5		 rep movsd
  003d1	50		 push	 eax
  003d2	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 3955 : 			pMsg.ItemInfo[I_OPTION] = iItemPos * 16; // iItemPos << 16;

  003d7	8b 4d 90	 mov	 ecx, DWORD PTR _iItemPos$GSCopy$1$[ebp]
  003da	8a c1		 mov	 al, cl

; 3956 : 			pMsg.ItemInfo[I_OPTION] |= LevelSmallConvert(iIndex, iItemPos) & 0x0F;

  003dc	51		 push	 ecx
  003dd	c0 e0 04	 shl	 al, 4
  003e0	53		 push	 ebx
  003e1	88 45 aa	 mov	 BYTE PTR _pMsg$1[ebp+6], al
  003e4	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  003e9	24 0f		 and	 al, 15			; 0000000fH
  003eb	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  003f1	08 45 aa	 or	 BYTE PTR _pMsg$1[ebp+6], al

; 3957 : 
; 3958 : 			DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  003f4	0f b6 45 a5	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  003f8	50		 push	 eax
  003f9	8d 45 a4	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  003fc	50		 push	 eax
  003fd	53		 push	 ebx
  003fe	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3959 : 			MsgSendV2(&gObj[iIndex], (UCHAR*)&pMsg, pMsg.h.size);

  00403	0f b6 45 a5	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00407	8b 4d 8c	 mov	 ecx, DWORD PTR tv610[ebp]
  0040a	50		 push	 eax
  0040b	8d 45 a4	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0040e	50		 push	 eax
  0040f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00414	03 c1		 add	 eax, ecx
  00416	50		 push	 eax
  00417	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0041c	8a 4d 9b	 mov	 cl, BYTE PTR _pResult$[ebp+3]
  0041f	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@DropItemDi:

; 3960 : 		}
; 3961 : 	}
; 3962 : 
; 3963 : 	return (pResult.Result);

  00422	0f b6 c1	 movzx	 eax, cl

; 3964 : }

  00425	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00428	5f		 pop	 edi
  00429	5e		 pop	 esi
  0042a	33 cd		 xor	 ecx, ebp
  0042c	5b		 pop	 ebx
  0042d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00432	8b e5		 mov	 esp, ebp
  00434	5d		 pop	 ebp
  00435	c2 10 00	 ret	 16			; 00000010H
?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ENDP		; CBloodCastle::DropItemDirectly
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetCurrentLiveUserCount, COMDAT
; _this$ = ecx

; 3833 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3834 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 7b		 js	 SHORT $LN23@GetCurrent
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 6f		 je	 SHORT $LN23@GetCurrent

; 3837 : 	}
; 3838 : 
; 3839 : 	int iRetLiveUserCount = 0;

  00016	53		 push	 ebx
  00017	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001d	56		 push	 esi
  0001e	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  00024	33 f6		 xor	 esi, esi
  00026	8d 51 1c	 lea	 edx, DWORD PTR [ecx+28]
  00029	57		 push	 edi
  0002a	8d 7e 0a	 lea	 edi, DWORD PTR [esi+10]
  0002d	03 d0		 add	 edx, eax
  0002f	90		 npad	 1
$LL4@GetCurrent:

; 3842 : 	{
; 3843 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00030	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 3844 : 
; 3845 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00032	85 c9		 test	 ecx, ecx
  00034	78 3e		 js	 SHORT $LN2@GetCurrent
  00036	33 c0		 xor	 eax, eax
  00038	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0003e	0f 9e c0	 setle	 al
  00041	85 c0		 test	 eax, eax
  00043	74 2f		 je	 SHORT $LN2@GetCurrent

; 3846 : 		{
; 3847 : 			continue;
; 3848 : 		}
; 3849 : 
; 3850 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  00045	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  0004b	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  0004e	8a 81 23 01 00
	00		 mov	 al, BYTE PTR [ecx+291]
  00054	3c 34		 cmp	 al, 52			; 00000034H
  00056	74 0f		 je	 SHORT $LN24@GetCurrent
  00058	3c 0b		 cmp	 al, 11			; 0000000bH
  0005a	72 18		 jb	 SHORT $LN2@GetCurrent
  0005c	b4 11		 mov	 ah, 17			; 00000011H
  0005e	3a e0		 cmp	 ah, al
  00060	1b c0		 sbb	 eax, eax
  00062	83 c0 01	 add	 eax, 1
  00065	74 0d		 je	 SHORT $LN2@GetCurrent
$LN24@GetCurrent:

; 3851 : 		{
; 3852 : 			continue;
; 3853 : 		}
; 3854 : 
; 3855 : 		if( gObj[iIndex].Type != OBJ_USER  )

  00067	80 79 50 01	 cmp	 BYTE PTR [ecx+80], 1
  0006b	75 07		 jne	 SHORT $LN2@GetCurrent

; 3856 : 		{
; 3857 : 			continue;
; 3858 : 		}
; 3859 : 
; 3860 : 		if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  0006d	83 79 04 02	 cmp	 DWORD PTR [ecx+4], 2
  00071	7e 01		 jle	 SHORT $LN2@GetCurrent

; 3861 : 		{
; 3862 : 			iRetLiveUserCount++;

  00073	46		 inc	 esi
$LN2@GetCurrent:

; 3840 : 
; 3841 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00074	83 c2 14	 add	 edx, 20			; 00000014H
  00077	83 ef 01	 sub	 edi, 1
  0007a	75 b4		 jne	 SHORT $LL4@GetCurrent

; 3863 : 		}
; 3864 : 	}
; 3865 : 
; 3866 : 	return iRetLiveUserCount;

  0007c	5f		 pop	 edi
  0007d	8b c6		 mov	 eax, esi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx

; 3867 : }

  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
$LN23@GetCurrent:

; 3835 : 	{
; 3836 : 		return -1;

  00085	83 c8 ff	 or	 eax, -1

; 3867 : }

  00088	5d		 pop	 ebp
  00089	c2 04 00	 ret	 4
?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetCurrentLiveUserCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_iIndex$1$ = -16					; size = 4
tv406 = -12						; size = 4
tv402 = -8						; size = 4
_iBridgeUserIndex$1$ = -4				; size = 4
tv411 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z PROC	; CBloodCastle::GetWhoGotUltimateWeapon, COMDAT
; _this$ = ecx

; 3772 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3773 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	85 d2		 test	 edx, edx
  0000b	0f 88 27 01 00
	00		 js	 $LN38@GetWhoGotU
  00011	33 c0		 xor	 eax, eax
  00013	83 fa 07	 cmp	 edx, 7
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 17 01 00
	00		 je	 $LN38@GetWhoGotU

; 3776 : 	}
; 3777 : 
; 3778 : 	int iBridgeUserIndex = -1;

  00021	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  00027	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  0002c	53		 push	 ebx
  0002d	83 cb ff	 or	 ebx, -1
  00030	89 55 08	 mov	 DWORD PTR tv411[ebp], edx
  00033	56		 push	 esi
  00034	57		 push	 edi
  00035	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	03 c1		 add	 eax, ecx
  0003d	89 5d fc	 mov	 DWORD PTR _iBridgeUserIndex$1$[ebp], ebx
  00040	89 45 f4	 mov	 DWORD PTR tv406[ebp], eax
  00043	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  00046	89 4d f8	 mov	 DWORD PTR tv402[ebp], ecx
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@GetWhoGotU:

; 3781 : 	{
; 3782 : 		int iIndex = this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex;

  00050	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00052	89 4d f0	 mov	 DWORD PTR _iIndex$1$[ebp], ecx

; 3783 : 
; 3784 : 		if ( OBJMAX_RANGE(iIndex) == FALSE )

  00055	85 c9		 test	 ecx, ecx
  00057	0f 88 b3 00 00
	00		 js	 $LN2@GetWhoGotU
  0005d	33 c0		 xor	 eax, eax
  0005f	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00065	0f 9e c0	 setle	 al
  00068	85 c0		 test	 eax, eax
  0006a	0f 84 a0 00 00
	00		 je	 $LN2@GetWhoGotU

; 3785 : 		{
; 3786 : 			continue;
; 3787 : 		}
; 3788 : 
; 3789 : 		if( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00070	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  00076	80 7c 39 50 01	 cmp	 BYTE PTR [ecx+edi+80], 1
  0007b	0f 85 8f 00 00
	00		 jne	 $LN2@GetWhoGotU
  00081	83 7c 39 04 02	 cmp	 DWORD PTR [ecx+edi+4], 2
  00086	0f 8e 84 00 00
	00		 jle	 $LN2@GetWhoGotU

; 3790 : 		{
; 3791 : 			continue;
; 3792 : 		}
; 3793 : 
; 3794 : 		if ( BC_MAP_RANGE( gObj[iIndex].MapNumber ) == FALSE )

  0008c	8a 84 39 23 01
	00 00		 mov	 al, BYTE PTR [ecx+edi+291]
  00093	3c 34		 cmp	 al, 52			; 00000034H
  00095	74 0f		 je	 SHORT $LN39@GetWhoGotU
  00097	3c 0b		 cmp	 al, 11			; 0000000bH
  00099	72 75		 jb	 SHORT $LN2@GetWhoGotU
  0009b	b4 11		 mov	 ah, 17			; 00000011H
  0009d	3a e0		 cmp	 ah, al
  0009f	1b c0		 sbb	 eax, eax
  000a1	83 c0 01	 add	 eax, 1
  000a4	74 6a		 je	 SHORT $LN2@GetWhoGotU
$LN39@GetWhoGotU:
  000a6	8d 99 c0 11 00
	00		 lea	 ebx, DWORD PTR [ecx+4544]

; 3795 : 		{
; 3796 : 			continue;
; 3797 : 		}
; 3798 : 
; 3799 : 		for ( int x=0;x<INVENTORY_SIZE;x++)

  000ac	33 f6		 xor	 esi, esi
  000ae	66 90		 npad	 2
$LL7@GetWhoGotU:

; 3800 : 		{
; 3801 : 			if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  000b0	8b 0c 3b	 mov	 ecx, DWORD PTR [ebx+edi]
  000b3	03 ce		 add	 ecx, esi
  000b5	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ba	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c0	83 f8 01	 cmp	 eax, 1
  000c3	75 37		 jne	 SHORT $LN5@GetWhoGotU

; 3802 : 			{
; 3803 : 				if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  000c5	8b 0c 3b	 mov	 ecx, DWORD PTR [ebx+edi]
  000c8	b8 13 1a 00 00	 mov	 eax, 6675		; 00001a13H
  000cd	66 39 44 31 06	 cmp	 WORD PTR [ecx+esi+6], ax
  000d2	75 28		 jne	 SHORT $LN5@GetWhoGotU

; 3804 : 				{
; 3805 : 					int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  000d4	0f bf 54 31 08	 movsx	 edx, WORD PTR [ecx+esi+8]

; 3806 : 
; 3807 : 					if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  000d9	85 d2		 test	 edx, edx
  000db	78 1f		 js	 SHORT $LN5@GetWhoGotU
  000dd	33 c0		 xor	 eax, eax
  000df	83 fa 02	 cmp	 edx, 2
  000e2	0f 9e c0	 setle	 al
  000e5	85 c0		 test	 eax, eax
  000e7	74 13		 je	 SHORT $LN5@GetWhoGotU

; 3808 : 					{
; 3809 : 						if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL != -1 )

  000e9	8b 45 f4	 mov	 eax, DWORD PTR tv406[ebp]
  000ec	8b 80 90 01 00
	00		 mov	 eax, DWORD PTR [eax+400]
  000f2	83 f8 ff	 cmp	 eax, -1
  000f5	74 05		 je	 SHORT $LN5@GetWhoGotU

; 3810 : 						{
; 3811 : 							if ( this->m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number )

  000f7	3b 04 31	 cmp	 eax, DWORD PTR [ecx+esi]
  000fa	74 34		 je	 SHORT $LN31@GetWhoGotU
$LN5@GetWhoGotU:

; 3795 : 		{
; 3796 : 			continue;
; 3797 : 		}
; 3798 : 
; 3799 : 		for ( int x=0;x<INVENTORY_SIZE;x++)

  000fc	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00102	81 fe 44 c4 00
	00		 cmp	 esi, 50244		; 0000c444H
  00108	7c a6		 jl	 SHORT $LL7@GetWhoGotU
  0010a	8b 5d fc	 mov	 ebx, DWORD PTR _iBridgeUserIndex$1$[ebp]
$LN42@GetWhoGotU:
  0010d	8b 55 08	 mov	 edx, DWORD PTR tv411[ebp]
$LN2@GetWhoGotU:

; 3779 : 
; 3780 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00110	8b 4d f8	 mov	 ecx, DWORD PTR tv402[ebp]
  00113	83 c1 14	 add	 ecx, 20			; 00000014H
  00116	83 ea 01	 sub	 edx, 1
  00119	89 4d f8	 mov	 DWORD PTR tv402[ebp], ecx
  0011c	89 55 08	 mov	 DWORD PTR tv411[ebp], edx
  0011f	0f 85 2b ff ff
	ff		 jne	 $LL4@GetWhoGotU

; 3814 : 								break;
; 3815 : 							}
; 3816 : 						}
; 3817 : 					}
; 3818 : 				}
; 3819 : 			}
; 3820 : 		}
; 3821 : 
; 3822 : 	}
; 3823 : 
; 3824 : 	return iBridgeUserIndex;

  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	8b c3		 mov	 eax, ebx
  00129	5b		 pop	 ebx

; 3825 : }

  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 04 00	 ret	 4
$LN31@GetWhoGotU:

; 3812 : 							{
; 3813 : 								iBridgeUserIndex = iIndex;

  00130	8b 5d f0	 mov	 ebx, DWORD PTR _iIndex$1$[ebp]
  00133	89 5d fc	 mov	 DWORD PTR _iBridgeUserIndex$1$[ebp], ebx
  00136	eb d5		 jmp	 SHORT $LN42@GetWhoGotU
$LN38@GetWhoGotU:

; 3774 : 	{
; 3775 : 		return -1;

  00138	83 c8 ff	 or	 eax, -1

; 3825 : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 04 00	 ret	 4
?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z ENDP	; CBloodCastle::GetWhoGotUltimateWeapon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv361 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckAngelKingExist, COMDAT
; _this$ = ecx

; 3712 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3713 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000b	85 db		 test	 ebx, ebx
  0000d	78 33		 js	 SHORT $LN21@CheckAngel
  0000f	33 c0		 xor	 eax, eax
  00011	83 fb 07	 cmp	 ebx, 7
  00014	0f 9e c0	 setle	 al
  00017	85 c0		 test	 eax, eax
  00019	74 27		 je	 SHORT $LN21@CheckAngel

; 3714 : 	{
; 3715 : 		return false;
; 3716 : 	}
; 3717 : 
; 3718 : 	bool bRET_VAL = false;
; 3719 : 
; 3720 : 	if ( this->m_BridgeData[iBridgeIndex].m_iAngelKingPosNum == -1 )

  0001b	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524
  00021	05 9c 01 00 00	 add	 eax, 412		; 0000019cH
  00026	03 c1		 add	 eax, ecx
  00028	89 45 08	 mov	 DWORD PTR tv361[ebp], eax
  0002b	83 38 ff	 cmp	 DWORD PTR [eax], -1
  0002e	75 1b		 jne	 SHORT $LN6@CheckAngel

; 3721 : 	{
; 3722 : 		LogAddTD("[Blood Castle] (%d) Angel King's Monster Position Doesn't Exist",

  00030	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00033	50		 push	 eax
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@LFJOCLMK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?8s@
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003f	83 c4 08	 add	 esp, 8
$LN21@CheckAngel:

; 3723 : 			iBridgeIndex+1);
; 3724 : 
; 3725 : 		return false;

  00042	32 c0		 xor	 al, al
  00044	5b		 pop	 ebx

; 3764 : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN6@CheckAngel:
  0004b	56		 push	 esi

; 3726 : 	}
; 3727 : 
; 3728 : 	for ( int i=0;i<OBJ_STARTUSERINDEX;i++)

  0004c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	b8 e8 00 00 00	 mov	 eax, 232		; 000000e8H
  00057	57		 push	 edi
  00058	33 ff		 xor	 edi, edi
  0005a	83 c6 50	 add	 esi, 80			; 00000050H
  0005d	0f 1f 00	 npad	 3
$LL4@CheckAngel:

; 3729 : 	{
; 3730 : 		if ( gObj[i].Connected == PLAYER_PLAYING && gObj[i].Type == OBJ_NPC )

  00060	83 7e b4 03	 cmp	 DWORD PTR [esi-76], 3
  00064	75 24		 jne	 SHORT $LN2@CheckAngel
  00066	80 3e 03	 cmp	 BYTE PTR [esi], 3
  00069	75 1f		 jne	 SHORT $LN2@CheckAngel

; 3731 : 		{
; 3732 : 			if ( gObj[i].Class == 232 )

  0006b	66 39 46 40	 cmp	 WORD PTR [esi+64], ax
  0006f	75 19		 jne	 SHORT $LN2@CheckAngel

; 3733 : 			{
; 3734 : 				if (gObj[i].MapNumber == GetEventMap(iBridgeIndex) )

  00071	53		 push	 ebx
  00072	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00077	0f b6 8e d3 00
	00 00		 movzx	 ecx, BYTE PTR [esi+211]
  0007e	3b c8		 cmp	 ecx, eax
  00080	74 68		 je	 SHORT $LN12@CheckAngel
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00085	b8 e8 00 00 00	 mov	 eax, 232		; 000000e8H
$LN2@CheckAngel:

; 3726 : 	}
; 3727 : 
; 3728 : 	for ( int i=0;i<OBJ_STARTUSERINDEX;i++)

  0008a	47		 inc	 edi
  0008b	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00091	81 ff 04 29 00
	00		 cmp	 edi, 10500		; 00002904H
  00097	7c c7		 jl	 SHORT $LL4@CheckAngel

; 3735 : 				{
; 3736 : 					bRET_VAL = true;
; 3737 : 					break;
; 3738 : 				}
; 3739 : 			}
; 3740 : 		}
; 3741 : 	}
; 3742 : 
; 3743 : 	if ( bRET_VAL == false )
; 3744 : 	{
; 3745 : 		int result = gObjAddMonster(GetEventMap(iBridgeIndex));

  00099	53		 push	 ebx
  0009a	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  000a5	0f bf f0	 movsx	 esi, ax
  000a8	83 c4 04	 add	 esp, 4

; 3746 : 
; 3747 : 		if ( result >= 0 )

  000ab	85 f6		 test	 esi, esi
  000ad	78 46		 js	 SHORT $LN11@CheckAngel

; 3748 : 		{
; 3749 : 			gObjSetPosMonster(result, this->m_BridgeData[iBridgeIndex].m_iAngelKingPosNum);

  000af	8b 45 08	 mov	 eax, DWORD PTR tv361[ebp]
  000b2	ff 30		 push	 DWORD PTR [eax]
  000b4	56		 push	 esi
  000b5	e8 00 00 00 00	 call	 ?gObjSetPosMonster@@YAHHH@Z ; gObjSetPosMonster

; 3750 : 			gObjSetMonster(result, 232);

  000ba	68 e8 00 00 00	 push	 232			; 000000e8H
  000bf	56		 push	 esi
  000c0	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster

; 3751 : 			gObj[result].m_cBloodCastleIndex = GetBridgeLevel(gObj[result].MapNumber);

  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000c8	83 c4 10	 add	 esp, 16			; 00000010H
  000cb	69 f6 40 27 00
	00		 imul	 esi, esi, 10048
  000d1	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d7	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  000e4	88 86 36 12 00
	00		 mov	 BYTE PTR [esi+4662], al
$LN12@CheckAngel:

; 3760 : 		}
; 3761 : 	}
; 3762 : 
; 3763 : 	return bRET_VAL;

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	b0 01		 mov	 al, 1
  000ee	5b		 pop	 ebx

; 3764 : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 04 00	 ret	 4
$LN11@CheckAngel:

; 3752 : 			bRET_VAL = true;
; 3753 : 		}
; 3754 : 		else
; 3755 : 		{
; 3756 : 			LogAddTD("[Blood Castle] (%d) Angel King - gObjAdd() failed (no space to add monster, result:%d)",

  000f5	56		 push	 esi
  000f6	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000f9	50		 push	 eax
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@CEGPGOIB@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Angel?5King?5?9@
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3757 : 				iBridgeIndex+1, result);
; 3758 : 
; 3759 : 			return false;

  00108	32 c0		 xor	 al, al
  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5b		 pop	 ebx

; 3764 : }

  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 04 00	 ret	 4
?CheckAngelKingExist@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckAngelKingExist
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
tv464 = -36						; size = 4
_this$GSCopy$1$ = -32					; size = 4
_iBridgeIndex$GSCopy$1$ = -28				; size = 4
_bRET_VAL$1$ = -21					; size = 1
_pMsg$1 = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckEveryUserDie, COMDAT
; _this$ = ecx

; 3651 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00013	89 4d e0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00016	89 55 e4	 mov	 DWORD PTR _iBridgeIndex$GSCopy$1$[ebp], edx

; 3652 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00019	85 d2		 test	 edx, edx
  0001b	0f 88 0a 01 00
	00		 js	 $LN22@CheckEvery
  00021	33 c0		 xor	 eax, eax
  00023	83 fa 07	 cmp	 edx, 7
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	0f 84 fa 00 00
	00		 je	 $LN22@CheckEvery

; 3653 : 	{
; 3654 : 		return false;
; 3655 : 	}
; 3656 : 
; 3657 : 	bool bRET_VAL = true;

  00031	53		 push	 ebx
  00032	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  00038	8d 59 1c	 lea	 ebx, DWORD PTR [ecx+28]
  0003b	56		 push	 esi
  0003c	57		 push	 edi

; 3658 : 
; 3659 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0003d	33 ff		 xor	 edi, edi
  0003f	c6 45 eb 01	 mov	 BYTE PTR _bRET_VAL$1$[ebp], 1
  00043	03 d8		 add	 ebx, eax
$LL4@CheckEvery:

; 3660 : 	{
; 3661 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00045	8b 33		 mov	 esi, DWORD PTR [ebx]
  00047	83 fe ff	 cmp	 esi, -1
  0004a	0f 84 b6 00 00
	00		 je	 $LN25@CheckEvery

; 3662 : 		{
; 3663 : 			if ( OBJMAX_RANGE(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex) == FALSE )

  00050	85 f6		 test	 esi, esi
  00052	0f 88 97 00 00
	00		 js	 $LN23@CheckEvery
  00058	33 c0		 xor	 eax, eax
  0005a	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00060	0f 9e c0	 setle	 al
  00063	85 c0		 test	 eax, eax
  00065	0f 84 84 00 00
	00		 je	 $LN23@CheckEvery

; 3666 : 					iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, i);
; 3667 : 				
; 3668 : 				continue;
; 3669 : 			}
; 3670 : 
; 3671 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber == GetEventMap(iBridgeIndex) )

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00070	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00076	52		 push	 edx
  00077	03 c1		 add	 eax, ecx
  00079	8b 4d e0	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0007c	89 45 dc	 mov	 DWORD PTR tv464[ebp], eax
  0007f	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00084	8b 55 dc	 mov	 edx, DWORD PTR tv464[ebp]
  00087	0f b6 8a 23 01
	00 00		 movzx	 ecx, BYTE PTR [edx+291]
  0008e	3b c8		 cmp	 ecx, eax
  00090	75 1e		 jne	 SHORT $LN8@CheckEvery

; 3672 : 			{
; 3673 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00092	83 7a 04 02	 cmp	 DWORD PTR [edx+4], 2
  00096	7e 0a		 jle	 SHORT $LN10@CheckEvery

; 3674 : 				{
; 3675 : 					bRET_VAL = false;
; 3676 : 				}
; 3677 : 				else

  00098	8b 55 e4	 mov	 edx, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  0009b	32 c9		 xor	 cl, cl
  0009d	88 4d eb	 mov	 BYTE PTR _bRET_VAL$1$[ebp], cl
  000a0	eb 67		 jmp	 SHORT $LN2@CheckEvery
$LN10@CheckEvery:

; 3678 : 				{
; 3679 : 					LogAddTD("error-L3 : [Blood Castle] (%d) Connection Closed UserIndex:%d, SubIndex:%d",

  000a2	8b 45 e4	 mov	 eax, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  000a5	57		 push	 edi
  000a6	56		 push	 esi
  000a7	40		 inc	 eax
  000a8	50		 push	 eax
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@LDIFKEKC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5C@

; 3680 : 						iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, i);
; 3681 : 				}
; 3682 : 			}
; 3683 : 			else

  000ae	eb 4a		 jmp	 SHORT $LN26@CheckEvery
$LN8@CheckEvery:

; 3684 : 			{
; 3685 : 				if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg == false )

  000b0	80 7b 10 00	 cmp	 BYTE PTR [ebx+16], 0
  000b4	75 4d		 jne	 SHORT $LN24@CheckEvery

; 3686 : 				{
; 3687 : 					this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bSendQuitMsg = true;
; 3688 : 
; 3689 : 					PMSG_STATEBLOODCASTLE pMsg;
; 3690 : 
; 3691 : 					PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  000b6	6a 0e		 push	 14			; 0000000eH
  000b8	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  000bb	c6 43 10 01	 mov	 BYTE PTR [ebx+16], 1
  000bf	68 9b 00 00 00	 push	 155			; 0000009bH
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3692 : 					pMsg.btPlayState = 2;
; 3693 : 					pMsg.wRemainSec = 0;

  000ca	33 c0		 xor	 eax, eax
  000cc	c6 45 ef 02	 mov	 BYTE PTR _pMsg$1[ebp+3], 2
  000d0	89 45 f0	 mov	 DWORD PTR _pMsg$1[ebp+4], eax

; 3694 : 					pMsg.wMaxKillMonster = 0;
; 3695 : 					pMsg.wCurKillMonster = 0;

  000d3	89 45 f4	 mov	 DWORD PTR _pMsg$1[ebp+8], eax

; 3696 : 					pMsg.wUserHaveWeapon = 0;
; 3697 : 					pMsg.btWeaponNum = -1;
; 3698 : 
; 3699 : 					DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  000d6	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  000da	50		 push	 eax
  000db	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  000de	c6 45 f8 ff	 mov	 BYTE PTR _pMsg$1[ebp+12], 255 ; 000000ffH
  000e2	50		 push	 eax
  000e3	ff 33		 push	 DWORD PTR [ebx]
  000e5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ea	83 c4 18	 add	 esp, 24			; 00000018H
  000ed	eb 14		 jmp	 SHORT $LN24@CheckEvery
$LN23@CheckEvery:

; 3664 : 			{
; 3665 : 				LogAddTD("error-L3 : [Blood Castle] (%d) User Out of Bound UserIndex:%d, SubIndex:%d",

  000ef	57		 push	 edi
  000f0	56		 push	 esi
  000f1	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  000f4	50		 push	 eax
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@NNMPGAAC@error?9L3?5?3?5?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5U@
$LN26@CheckEvery:
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00100	83 c4 10	 add	 esp, 16			; 00000010H
$LN24@CheckEvery:
  00103	8b 55 e4	 mov	 edx, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
$LN25@CheckEvery:
  00106	8a 4d eb	 mov	 cl, BYTE PTR _bRET_VAL$1$[ebp]
$LN2@CheckEvery:

; 3658 : 
; 3659 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00109	47		 inc	 edi
  0010a	83 c3 14	 add	 ebx, 20			; 00000014H
  0010d	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  00110	0f 8c 2f ff ff
	ff		 jl	 $LL4@CheckEvery

; 3700 : 				}
; 3701 : 			}
; 3702 : 		}
; 3703 : 	}
; 3704 : 
; 3705 : 	return bRET_VAL;

  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	8a c1		 mov	 al, cl
  0011a	5b		 pop	 ebx

; 3706 : }

  0011b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011e	33 cd		 xor	 ecx, ebp
  00120	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c2 04 00	 ret	 4
$LN22@CheckEvery:
  0012b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012e	32 c0		 xor	 al, al
  00130	33 cd		 xor	 ecx, ebp
  00132	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c2 04 00	 ret	 4
?CheckEveryUserDie@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckEveryUserDie
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckBossKillSuccess, COMDAT
; _this$ = ecx

; 3637 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3638 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 1d		 js	 SHORT $LN6@CheckBossK
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 11		 je	 SHORT $LN6@CheckBossK

; 3641 : 	}
; 3642 : 
; 3643 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_BOSS_MONSTER_KILL_COMPLETE;

  00016	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0001c	8a 84 08 61 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+353]

; 3644 : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN6@CheckBossK:

; 3639 : 	{
; 3640 : 		return false;

  00027	32 c0		 xor	 al, al

; 3644 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckBossKillSuccess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckBossKillCount@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckBossKillCount@CBloodCastle@@QAE_NH@Z PROC		; CBloodCastle::CheckBossKillCount, COMDAT
; _this$ = ecx

; 3614 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3615 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	78 3f		 js	 SHORT $LN7@CheckBossK
  0000d	33 c0		 xor	 eax, eax
  0000f	83 fa 07	 cmp	 edx, 7
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 33		 je	 SHORT $LN7@CheckBossK

; 3618 : 	}
; 3619 : 
; 3620 : 	if ( this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT >= this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT )

  00019	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0001f	8b 8c 30 88 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+392]
  00026	8b 84 30 84 01
	00 00		 mov	 eax, DWORD PTR [eax+esi+388]
  0002d	3b c8		 cmp	 ecx, eax
  0002f	7c 1b		 jl	 SHORT $LN7@CheckBossK

; 3621 : 	{
; 3622 : 		LogAddTD("[Blood Castle][Bug Tracer] (%d) All Boss Monster Kill Success(Max Boss Kill Count:%d / Boss Kill Count:%d)",

  00031	51		 push	 ecx
  00032	50		 push	 eax
  00033	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@DCFNJCHO@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 3623 : 			iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT,
; 3624 : 			this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT);
; 3625 : 
; 3626 : 		return true;

  00045	b0 01		 mov	 al, 1
  00047	5e		 pop	 esi

; 3627 : 	}
; 3628 : 
; 3629 : 	return false;
; 3630 : }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN7@CheckBossK:

; 3616 : 	{
; 3617 : 		return false;

  0004c	32 c0		 xor	 al, al
  0004e	5e		 pop	 esi

; 3627 : 	}
; 3628 : 
; 3629 : 	return false;
; 3630 : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?CheckBossKillCount@CBloodCastle@@QAE_NH@Z ENDP		; CBloodCastle::CheckBossKillCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckMonsterKillSuccess, COMDAT
; _this$ = ecx

; 3601 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3602 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 1d		 js	 SHORT $LN6@CheckMonst
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 11		 je	 SHORT $LN6@CheckMonst

; 3605 : 	}
; 3606 : 
; 3607 : 	return this->m_BridgeData[iBridgeIndex].m_bBC_MONSTER_KILL_COMPLETE;

  00016	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0001c	8a 84 08 60 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+352]

; 3608 : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN6@CheckMonst:

; 3603 : 	{
; 3604 : 		return false;

  00027	32 c0		 xor	 al, al

; 3608 : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckMonsterKillSuccess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z PROC	; CBloodCastle::CheckMonsterKillCount, COMDAT
; _this$ = ecx

; 3578 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3579 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	78 3f		 js	 SHORT $LN7@CheckMonst
  0000d	33 c0		 xor	 eax, eax
  0000f	83 fa 07	 cmp	 edx, 7
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 33		 je	 SHORT $LN7@CheckMonst

; 3582 : 	}
; 3583 : 
; 3584 : 	if( this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT >= this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT )

  00019	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  0001f	8b 8c 30 78 01
	00 00		 mov	 ecx, DWORD PTR [eax+esi+376]
  00026	8b 84 30 74 01
	00 00		 mov	 eax, DWORD PTR [eax+esi+372]
  0002d	3b c8		 cmp	 ecx, eax
  0002f	7c 1b		 jl	 SHORT $LN7@CheckMonst

; 3585 : 	{
; 3586 : 		LogAddTD("[Blood Castle][Bug Tracer] (%d) All Monster Kill Success(Max Kill Count:%d / Kill Count:%d)",

  00031	51		 push	 ecx
  00032	50		 push	 eax
  00033	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@GIGMADKF@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5?$CI?$CFd?$CJ?5@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 3587 : 			iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT,
; 3588 : 			this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT);
; 3589 : 
; 3590 : 		return true;

  00045	b0 01		 mov	 al, 1
  00047	5e		 pop	 esi

; 3591 : 	}
; 3592 : 
; 3593 : 	return false;
; 3594 : }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN7@CheckMonst:

; 3580 : 	{
; 3581 : 		return false;

  0004c	32 c0		 xor	 al, al
  0004e	5e		 pop	 esi

; 3591 : 	}
; 3592 : 
; 3593 : 	return false;
; 3594 : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z ENDP	; CBloodCastle::CheckMonsterKillCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetMonsterKillCount@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv437 = -8						; size = 4
_iTOT_USER_COUNT$1$ = -4				; size = 4
_iBridgeIndex$ = 8					; size = 4
?SetMonsterKillCount@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SetMonsterKillCount, COMDAT
; _this$ = ecx

; 3527 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b d1		 mov	 edx, ecx
  00008	53		 push	 ebx

; 3528 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00009	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  0000c	85 db		 test	 ebx, ebx
  0000e	0f 88 a2 00 00
	00		 js	 $LN1@SetMonster
  00014	33 c0		 xor	 eax, eax
  00016	83 fb 07	 cmp	 ebx, 7
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 92 00 00
	00		 je	 $LN1@SetMonster

; 3529 : 	{
; 3530 : 		return;
; 3531 : 	}
; 3532 : 
; 3533 : 	int iTOT_USER_COUNT = 0;

  00024	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524

; 3534 : 	int iLIVE_USER_COUNT = 0;
; 3535 : 	int iKILL_USER_COUNT = 0;

  0002a	33 c9		 xor	 ecx, ecx
  0002c	56		 push	 esi
  0002d	57		 push	 edi
  0002e	33 ff		 xor	 edi, edi
  00030	33 f6		 xor	 esi, esi
  00032	03 c2		 add	 eax, edx
  00034	89 45 f8	 mov	 DWORD PTR tv437[ebp], eax
  00037	8d 5f 0a	 lea	 ebx, DWORD PTR [edi+10]
  0003a	8d 50 1c	 lea	 edx, DWORD PTR [eax+28]
  0003d	0f 1f 00	 npad	 3
$LL4@SetMonster:

; 3538 : 	{
; 3539 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	83 f8 ff	 cmp	 eax, -1
  00045	74 38		 je	 SHORT $LN2@SetMonster

; 3540 : 		{
; 3541 : 			iTOT_USER_COUNT++;

  00047	47		 inc	 edi

; 3542 : 
; 3543 : 			if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber) != FALSE )

  00048	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0004e	89 7d fc	 mov	 DWORD PTR _iTOT_USER_COUNT$1$[ebp], edi
  00051	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00057	03 f8		 add	 edi, eax
  00059	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  0005f	3c 34		 cmp	 al, 52			; 00000034H
  00061	74 0f		 je	 SHORT $LN22@SetMonster
  00063	3c 0b		 cmp	 al, 11			; 0000000bH
  00065	72 14		 jb	 SHORT $LN9@SetMonster
  00067	b4 11		 mov	 ah, 17			; 00000011H
  00069	3a e0		 cmp	 ah, al
  0006b	1b c0		 sbb	 eax, eax
  0006d	83 c0 01	 add	 eax, 1
  00070	74 09		 je	 SHORT $LN9@SetMonster
$LN22@SetMonster:

; 3544 : 			{
; 3545 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00072	83 7f 04 02	 cmp	 DWORD PTR [edi+4], 2
  00076	7e 03		 jle	 SHORT $LN9@SetMonster

; 3546 : 				{
; 3547 : 					iLIVE_USER_COUNT++;

  00078	46		 inc	 esi

; 3548 : 				}
; 3549 : 				else

  00079	eb 01		 jmp	 SHORT $LN23@SetMonster
$LN9@SetMonster:

; 3550 : 				{
; 3551 : 					iKILL_USER_COUNT++;

  0007b	41		 inc	 ecx
$LN23@SetMonster:
  0007c	8b 7d fc	 mov	 edi, DWORD PTR _iTOT_USER_COUNT$1$[ebp]
$LN2@SetMonster:

; 3536 : 
; 3537 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0007f	83 c2 14	 add	 edx, 20			; 00000014H
  00082	83 eb 01	 sub	 ebx, 1
  00085	75 b9		 jne	 SHORT $LL4@SetMonster

; 3552 : 				}
; 3553 : 			}
; 3554 : 			else
; 3555 : 			{
; 3556 : 				iKILL_USER_COUNT++;
; 3557 : 			}
; 3558 : 
; 3559 : 		}
; 3560 : 	}
; 3561 : 
; 3562 : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT = iLIVE_USER_COUNT * 40;

  00087	8b 55 f8	 mov	 edx, DWORD PTR tv437[ebp]
  0008a	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]

; 3563 : 	this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT = 0;
; 3564 : 
; 3565 : 	LogAddTD("[Blood Castle] (%d) Monster Kill Count Set - Monster:%d, Current Monster:%d, USER TOT:%d, LIVE:%d, DEAD:%d",

  0008d	51		 push	 ecx
  0008e	56		 push	 esi
  0008f	57		 push	 edi
  00090	c1 e0 03	 shl	 eax, 3
  00093	53		 push	 ebx
  00094	50		 push	 eax
  00095	89 82 74 01 00
	00		 mov	 DWORD PTR [edx+372], eax
  0009b	8b 45 08	 mov	 eax, DWORD PTR _iBridgeIndex$[ebp]
  0009e	40		 inc	 eax
  0009f	89 9a 78 01 00
	00		 mov	 DWORD PTR [edx+376], ebx
  000a5	50		 push	 eax
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@KHMMCCLP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Monster?5Kill@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b1	83 c4 1c	 add	 esp, 28			; 0000001cH
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
$LN1@SetMonster:
  000b6	5b		 pop	 ebx

; 3566 : 		iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT,
; 3567 : 		this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT, 
; 3568 : 		iTOT_USER_COUNT, iLIVE_USER_COUNT, iKILL_USER_COUNT);
; 3569 : }

  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 04 00	 ret	 4
?SetMonsterKillCount@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SetMonsterKillCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv457 = -12						; size = 4
_this$1$ = -8						; size = 4
tv458 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::ReleaseCastleDoor, COMDAT
; _this$ = ecx

; 2390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx

; 2391 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	0f 88 89 00 00
	00		 js	 $LN3@ReleaseCas
  00014	33 c0		 xor	 eax, eax
  00016	83 f9 07	 cmp	 ecx, 7
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	74 7d		 je	 SHORT $LN3@ReleaseCas

; 2392 : 	{
; 2393 : 		return;
; 2394 : 	}
; 2395 : 
; 2396 : 	for ( int x=0;x<3;x++)

  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00025	ba 03 00 00 00	 mov	 edx, 3
  0002a	57		 push	 edi
  0002b	8d 3c 85 03 00
	00 00		 lea	 edi, DWORD PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[eax*4+3]
  00032	89 55 fc	 mov	 DWORD PTR tv458[ebp], edx
$LL4@ReleaseCas:

; 2397 : 	{
; 2398 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  00035	0f b6 5f fd	 movzx	 ebx, BYTE PTR [edi-3]
  00039	0f b6 47 ff	 movzx	 eax, BYTE PTR [edi-1]
  0003d	3b d8		 cmp	 ebx, eax
  0003f	7f 4e		 jg	 SHORT $LN2@ReleaseCas
  00041	0f b6 17	 movzx	 edx, BYTE PTR [edi]
$LL7@ReleaseCas:

; 2399 : 		{
; 2400 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  00044	0f b6 77 fe	 movzx	 esi, BYTE PTR [edi-2]
  00048	3b f2		 cmp	 esi, edx
  0004a	7f 37		 jg	 SHORT $LN5@ReleaseCas

; 2401 : 			{
; 2402 : 				int MapNumber = GetEventMap(iBridgeIndex);

  0004c	51		 push	 ecx
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00050	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00055	69 c0 28 38 05
	00		 imul	 eax, eax, 342056
  0005b	8b ce		 mov	 ecx, esi
  0005d	c1 e1 08	 shl	 ecx, 8
  00060	89 45 f4	 mov	 DWORD PTR tv457[ebp], eax
$LL10@ReleaseCas:

; 2403 : 				MapC[MapNumber].m_attrbuf[z * 256 + y] &= ~4;

  00063	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00069	46		 inc	 esi
  0006a	03 c1		 add	 eax, ecx
  0006c	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00072	80 24 18 fb	 and	 BYTE PTR [eax+ebx], 251	; 000000fbH
  00076	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00079	8b 45 f4	 mov	 eax, DWORD PTR tv457[ebp]
  0007c	3b f2		 cmp	 esi, edx
  0007e	7e e3		 jle	 SHORT $LL10@ReleaseCas
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
$LN5@ReleaseCas:

; 2397 : 	{
; 2398 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  00083	0f b6 47 ff	 movzx	 eax, BYTE PTR [edi-1]
  00087	43		 inc	 ebx
  00088	3b d8		 cmp	 ebx, eax
  0008a	7e b8		 jle	 SHORT $LL7@ReleaseCas
  0008c	8b 55 fc	 mov	 edx, DWORD PTR tv458[ebp]
$LN2@ReleaseCas:

; 2392 : 	{
; 2393 : 		return;
; 2394 : 	}
; 2395 : 
; 2396 : 	for ( int x=0;x<3;x++)

  0008f	83 c7 04	 add	 edi, 4
  00092	83 ea 01	 sub	 edx, 1
  00095	89 55 fc	 mov	 DWORD PTR tv458[ebp], edx
  00098	75 9b		 jne	 SHORT $LL4@ReleaseCas
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
$LN3@ReleaseCas:

; 2404 : 			}
; 2405 : 		}
; 2406 : 	}
; 2407 : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::ReleaseCastleDoor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?BlockCastleDoor@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv459 = -12						; size = 4
_this$1$ = -8						; size = 4
tv460 = -4						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleDoor@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleDoor, COMDAT
; _this$ = ecx

; 2365 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx

; 2366 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
  0000c	85 c9		 test	 ecx, ecx
  0000e	0f 88 89 00 00
	00		 js	 $LN3@BlockCastl
  00014	33 c0		 xor	 eax, eax
  00016	83 f9 07	 cmp	 ecx, 7
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	74 7d		 je	 SHORT $LN3@BlockCastl

; 2367 : 	{
; 2368 : 		return;
; 2369 : 	}
; 2370 : 
; 2371 : 	for ( int x=0;x<3;x++)

  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00025	ba 03 00 00 00	 mov	 edx, 3
  0002a	57		 push	 edi
  0002b	8d 3c 85 03 00
	00 00		 lea	 edi, DWORD PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[eax*4+3]
  00032	89 55 fc	 mov	 DWORD PTR tv460[ebp], edx
$LL4@BlockCastl:

; 2372 : 	{
; 2373 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  00035	0f b6 5f fd	 movzx	 ebx, BYTE PTR [edi-3]
  00039	0f b6 47 ff	 movzx	 eax, BYTE PTR [edi-1]
  0003d	3b d8		 cmp	 ebx, eax
  0003f	7f 4e		 jg	 SHORT $LN2@BlockCastl
  00041	0f b6 17	 movzx	 edx, BYTE PTR [edi]
$LL7@BlockCastl:

; 2374 : 		{
; 2375 : 			for ( int z = ::g_btCastleDoorMapXY[iBridgeIndex][x].btStartY; z <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndY ; z++)

  00044	0f b6 77 fe	 movzx	 esi, BYTE PTR [edi-2]
  00048	3b f2		 cmp	 esi, edx
  0004a	7f 37		 jg	 SHORT $LN5@BlockCastl

; 2376 : 			{
; 2377 : 				int MapNumber = GetEventMap(iBridgeIndex);

  0004c	51		 push	 ecx
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00050	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00055	69 c0 28 38 05
	00		 imul	 eax, eax, 342056
  0005b	8b ce		 mov	 ecx, esi
  0005d	c1 e1 08	 shl	 ecx, 8
  00060	89 45 f4	 mov	 DWORD PTR tv459[ebp], eax
$LL10@BlockCastl:

; 2378 : 				MapC[MapNumber].m_attrbuf[z * 256 + y] |= 4;

  00063	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00069	46		 inc	 esi
  0006a	03 c1		 add	 eax, ecx
  0006c	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
  00072	80 0c 18 04	 or	 BYTE PTR [eax+ebx], 4
  00076	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00079	8b 45 f4	 mov	 eax, DWORD PTR tv459[ebp]
  0007c	3b f2		 cmp	 esi, edx
  0007e	7e e3		 jle	 SHORT $LL10@BlockCastl
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _iBridgeIndex$[ebp]
$LN5@BlockCastl:

; 2372 : 	{
; 2373 : 		for ( int y=::g_btCastleDoorMapXY[iBridgeIndex][x].btStartX; y <= ::g_btCastleDoorMapXY[iBridgeIndex][x].btEndX ;y++)

  00083	0f b6 47 ff	 movzx	 eax, BYTE PTR [edi-1]
  00087	43		 inc	 ebx
  00088	3b d8		 cmp	 ebx, eax
  0008a	7e b8		 jle	 SHORT $LL7@BlockCastl
  0008c	8b 55 fc	 mov	 edx, DWORD PTR tv460[ebp]
$LN2@BlockCastl:

; 2367 : 	{
; 2368 : 		return;
; 2369 : 	}
; 2370 : 
; 2371 : 	for ( int x=0;x<3;x++)

  0008f	83 c7 04	 add	 edi, 4
  00092	83 ea 01	 sub	 edx, 1
  00095	89 55 fc	 mov	 DWORD PTR tv460[ebp], edx
  00098	75 9b		 jne	 SHORT $LL4@BlockCastl
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
$LN3@BlockCastl:

; 2379 : 			}
; 2380 : 		}
; 2381 : 	}
; 2382 : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
?BlockCastleDoor@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleDoor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv243 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::ReleaseCastleBridge, COMDAT
; _this$ = ecx

; 2341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 2342 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00008	8b d1		 mov	 edx, ecx
  0000a	89 55 fc	 mov	 DWORD PTR _this$1$[ebp], edx
  0000d	85 ff		 test	 edi, edi
  0000f	0f 88 a3 00 00
	00		 js	 $LN1@ReleaseCas
  00015	33 c0		 xor	 eax, eax
  00017	83 ff 07	 cmp	 edi, 7
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 93 00 00
	00		 je	 $LN1@ReleaseCas

; 2343 : 	{
; 2344 : 		return;
; 2345 : 	}
; 2346 : 
; 2347 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  00025	0f b6 04 bd 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4+2]
  0002d	53		 push	 ebx
  0002e	0f b6 1c bd 00
	00 00 00	 movzx	 ebx, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4]
  00036	56		 push	 esi
  00037	3b d8		 cmp	 ebx, eax
  00039	7f 5d		 jg	 SHORT $LN3@ReleaseCas
  0003b	0f b6 0c bd 03
	00 00 00	 movzx	 ecx, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4+3]
$LL4@ReleaseCas:

; 2348 : 	{
; 2349 : 		for ( int j= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndY;j++)

  00043	0f b6 34 bd 01
	00 00 00	 movzx	 esi, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4+1]
  0004b	3b f1		 cmp	 esi, ecx
  0004d	7f 3c		 jg	 SHORT $LN2@ReleaseCas

; 2350 : 		{
; 2351 : 			int MapNumber = GetEventMap(iBridgeIndex);

  0004f	57		 push	 edi
  00050	8b ca		 mov	 ecx, edx
  00052	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00057	69 c0 28 38 05
	00		 imul	 eax, eax, 342056
  0005d	8b d6		 mov	 edx, esi
  0005f	c1 e2 08	 shl	 edx, 8
  00062	89 45 08	 mov	 DWORD PTR tv243[ebp], eax
$LL7@ReleaseCas:

; 2352 : 			MapC[MapNumber].m_attrbuf[j * 256 + i] &= ~8;

  00065	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  0006b	8d 0c 1a	 lea	 ecx, DWORD PTR [edx+ebx]
  0006e	46		 inc	 esi
  0006f	8d 92 00 01 00
	00		 lea	 edx, DWORD PTR [edx+256]
  00075	80 24 01 f7	 and	 BYTE PTR [ecx+eax], 247	; 000000f7H
  00079	0f b6 0c bd 03
	00 00 00	 movzx	 ecx, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4+3]
  00081	8b 45 08	 mov	 eax, DWORD PTR tv243[ebp]
  00084	3b f1		 cmp	 esi, ecx
  00086	7e dd		 jle	 SHORT $LL7@ReleaseCas
  00088	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN2@ReleaseCas:

; 2343 : 	{
; 2344 : 		return;
; 2345 : 	}
; 2346 : 
; 2347 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  0008b	0f b6 04 bd 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4+2]
  00093	43		 inc	 ebx
  00094	3b d8		 cmp	 ebx, eax
  00096	7e ab		 jle	 SHORT $LL4@ReleaseCas
$LN3@ReleaseCas:

; 2353 : 		}
; 2354 : 	}
; 2355 : 
; 2356 : 	LogAddTD("[Blood Castle] (%d) Castle Door Subsist",iBridgeIndex+1);

  00098	8d 77 01	 lea	 esi, DWORD PTR [edi+1]
  0009b	56		 push	 esi
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PNCMBIPP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Castle?5Door?5@
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2357 : 	LogAddTD("[Blood Castle][Bug Tracer] ReleaseCastleBridge-> %d", iBridgeIndex+1);

  000a7	56		 push	 esi
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@LNBDIFNP@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5Relea@
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b3	83 c4 10	 add	 esp, 16			; 00000010H
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
$LN1@ReleaseCas:
  000b8	5f		 pop	 edi

; 2358 : }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 04 00	 ret	 4
?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::ReleaseCastleBridge
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?BlockCastleBridge@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv244 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleBridge@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleBridge, COMDAT
; _this$ = ecx

; 2321 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 2322 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00008	8b d1		 mov	 edx, ecx
  0000a	89 55 fc	 mov	 DWORD PTR _this$1$[ebp], edx
  0000d	85 ff		 test	 edi, edi
  0000f	0f 88 82 00 00
	00		 js	 $LN3@BlockCastl
  00015	33 c0		 xor	 eax, eax
  00017	83 ff 07	 cmp	 edi, 7
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	74 76		 je	 SHORT $LN3@BlockCastl

; 2323 : 	{
; 2324 : 		return;
; 2325 : 	}
; 2326 : 
; 2327 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  00021	0f b6 04 bd 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4+2]
  00029	53		 push	 ebx
  0002a	0f b6 1c bd 00
	00 00 00	 movzx	 ebx, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4]
  00032	3b d8		 cmp	 ebx, eax
  00034	7f 60		 jg	 SHORT $LN20@BlockCastl
  00036	0f b6 0c bd 03
	00 00 00	 movzx	 ecx, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4+3]
  0003e	56		 push	 esi
  0003f	90		 npad	 1
$LL4@BlockCastl:

; 2328 : 	{
; 2329 : 		for ( int j= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndY;j++)

  00040	0f b6 34 bd 01
	00 00 00	 movzx	 esi, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4+1]
  00048	3b f1		 cmp	 esi, ecx
  0004a	7f 3c		 jg	 SHORT $LN2@BlockCastl

; 2330 : 		{
; 2331 : 			int MapNumber = GetEventMap(iBridgeIndex);

  0004c	57		 push	 edi
  0004d	8b ca		 mov	 ecx, edx
  0004f	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00054	69 c0 28 38 05
	00		 imul	 eax, eax, 342056
  0005a	8b d6		 mov	 edx, esi
  0005c	c1 e2 08	 shl	 edx, 8
  0005f	89 45 08	 mov	 DWORD PTR tv244[ebp], eax
$LL7@BlockCastl:

; 2332 : 			MapC[MapNumber].m_attrbuf[j * 256 + i] |= 8;

  00062	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00068	8d 0c 1a	 lea	 ecx, DWORD PTR [edx+ebx]
  0006b	46		 inc	 esi
  0006c	8d 92 00 01 00
	00		 lea	 edx, DWORD PTR [edx+256]
  00072	80 0c 01 08	 or	 BYTE PTR [ecx+eax], 8
  00076	0f b6 0c bd 03
	00 00 00	 movzx	 ecx, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4+3]
  0007e	8b 45 08	 mov	 eax, DWORD PTR tv244[ebp]
  00081	3b f1		 cmp	 esi, ecx
  00083	7e dd		 jle	 SHORT $LL7@BlockCastl
  00085	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN2@BlockCastl:

; 2323 : 	{
; 2324 : 		return;
; 2325 : 	}
; 2326 : 
; 2327 : 	for ( int i= ::g_btCastleBridgeMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleBridgeMapXY[iBridgeIndex].btEndX;i++)

  00088	0f b6 04 bd 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleBridgeMapXY@@3QBUBLOOD_ZONE@@B[edi*4+2]
  00090	43		 inc	 ebx
  00091	3b d8		 cmp	 ebx, eax
  00093	7e ab		 jle	 SHORT $LL4@BlockCastl
  00095	5e		 pop	 esi
$LN20@BlockCastl:
  00096	5b		 pop	 ebx
$LN3@BlockCastl:
  00097	5f		 pop	 edi

; 2333 : 		}
; 2334 : 	}
; 2335 : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
?BlockCastleBridge@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleBridge
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv242 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::ReleaseCastleEntrance, COMDAT
; _this$ = ecx

; 2298 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 2299 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00008	8b d1		 mov	 edx, ecx
  0000a	89 55 fc	 mov	 DWORD PTR _this$1$[ebp], edx
  0000d	85 ff		 test	 edi, edi
  0000f	0f 88 82 00 00
	00		 js	 $LN3@ReleaseCas
  00015	33 c0		 xor	 eax, eax
  00017	83 ff 07	 cmp	 edi, 7
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	74 76		 je	 SHORT $LN3@ReleaseCas

; 2300 : 	{
; 2301 : 		return;
; 2302 : 	}
; 2303 : 
; 2304 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  00021	0f b6 04 bd 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4+2]
  00029	53		 push	 ebx
  0002a	0f b6 1c bd 00
	00 00 00	 movzx	 ebx, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4]
  00032	3b d8		 cmp	 ebx, eax
  00034	7f 60		 jg	 SHORT $LN20@ReleaseCas
  00036	0f b6 0c bd 03
	00 00 00	 movzx	 ecx, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4+3]
  0003e	56		 push	 esi
  0003f	90		 npad	 1
$LL4@ReleaseCas:

; 2305 : 	{
; 2306 : 		for ( int j= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;j++)

  00040	0f b6 34 bd 01
	00 00 00	 movzx	 esi, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4+1]
  00048	3b f1		 cmp	 esi, ecx
  0004a	7f 3c		 jg	 SHORT $LN2@ReleaseCas

; 2307 : 		{
; 2308 : 			int MapNumber = GetEventMap(iBridgeIndex);

  0004c	57		 push	 edi
  0004d	8b ca		 mov	 ecx, edx
  0004f	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00054	69 c0 28 38 05
	00		 imul	 eax, eax, 342056
  0005a	8b d6		 mov	 edx, esi
  0005c	c1 e2 08	 shl	 edx, 8
  0005f	89 45 08	 mov	 DWORD PTR tv242[ebp], eax
$LL7@ReleaseCas:

; 2309 : 			MapC[MapNumber].m_attrbuf[j * 256 + i] &= ~4;

  00062	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00068	8d 0c 1a	 lea	 ecx, DWORD PTR [edx+ebx]
  0006b	46		 inc	 esi
  0006c	8d 92 00 01 00
	00		 lea	 edx, DWORD PTR [edx+256]
  00072	80 24 01 fb	 and	 BYTE PTR [ecx+eax], 251	; 000000fbH
  00076	0f b6 0c bd 03
	00 00 00	 movzx	 ecx, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4+3]
  0007e	8b 45 08	 mov	 eax, DWORD PTR tv242[ebp]
  00081	3b f1		 cmp	 esi, ecx
  00083	7e dd		 jle	 SHORT $LL7@ReleaseCas
  00085	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN2@ReleaseCas:

; 2300 : 	{
; 2301 : 		return;
; 2302 : 	}
; 2303 : 
; 2304 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  00088	0f b6 04 bd 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4+2]
  00090	43		 inc	 ebx
  00091	3b d8		 cmp	 ebx, eax
  00093	7e ab		 jle	 SHORT $LL4@ReleaseCas
  00095	5e		 pop	 esi
$LN20@ReleaseCas:
  00096	5b		 pop	 ebx
$LN3@ReleaseCas:
  00097	5f		 pop	 edi

; 2310 : 		}
; 2311 : 	}
; 2312 : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
?ReleaseCastleEntrance@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::ReleaseCastleEntrance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?BlockCastleEntrance@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
tv244 = 8						; size = 4
_iBridgeIndex$ = 8					; size = 4
?BlockCastleEntrance@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::BlockCastleEntrance, COMDAT
; _this$ = ecx

; 2276 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 2277 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]
  00008	8b d1		 mov	 edx, ecx
  0000a	89 55 fc	 mov	 DWORD PTR _this$1$[ebp], edx
  0000d	85 ff		 test	 edi, edi
  0000f	0f 88 82 00 00
	00		 js	 $LN3@BlockCastl
  00015	33 c0		 xor	 eax, eax
  00017	83 ff 07	 cmp	 edi, 7
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	74 76		 je	 SHORT $LN3@BlockCastl

; 2278 : 	{
; 2279 : 		return;
; 2280 : 	}
; 2281 : 
; 2282 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  00021	0f b6 04 bd 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4+2]
  00029	53		 push	 ebx
  0002a	0f b6 1c bd 00
	00 00 00	 movzx	 ebx, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4]
  00032	3b d8		 cmp	 ebx, eax
  00034	7f 60		 jg	 SHORT $LN20@BlockCastl
  00036	0f b6 0c bd 03
	00 00 00	 movzx	 ecx, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4+3]
  0003e	56		 push	 esi
  0003f	90		 npad	 1
$LL4@BlockCastl:

; 2283 : 	{
; 2284 : 		for ( int j= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;j<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;j++)

  00040	0f b6 34 bd 01
	00 00 00	 movzx	 esi, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4+1]
  00048	3b f1		 cmp	 esi, ecx
  0004a	7f 3c		 jg	 SHORT $LN2@BlockCastl

; 2285 : 		{
; 2286 : 			int MapNumber = GetEventMap(iBridgeIndex);

  0004c	57		 push	 edi
  0004d	8b ca		 mov	 ecx, edx
  0004f	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00054	69 c0 28 38 05
	00		 imul	 eax, eax, 342056
  0005a	8b d6		 mov	 edx, esi
  0005c	c1 e2 08	 shl	 edx, 8
  0005f	89 45 08	 mov	 DWORD PTR tv244[ebp], eax
$LL7@BlockCastl:

; 2287 : 			MapC[MapNumber].m_attrbuf[j * 256 + i] |= 4;

  00062	8b 80 10 00 00
	00		 mov	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[eax+16]
  00068	8d 0c 1a	 lea	 ecx, DWORD PTR [edx+ebx]
  0006b	46		 inc	 esi
  0006c	8d 92 00 01 00
	00		 lea	 edx, DWORD PTR [edx+256]
  00072	80 0c 01 04	 or	 BYTE PTR [ecx+eax], 4
  00076	0f b6 0c bd 03
	00 00 00	 movzx	 ecx, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4+3]
  0007e	8b 45 08	 mov	 eax, DWORD PTR tv244[ebp]
  00081	3b f1		 cmp	 esi, ecx
  00083	7e dd		 jle	 SHORT $LL7@BlockCastl
  00085	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN2@BlockCastl:

; 2278 : 	{
; 2279 : 		return;
; 2280 : 	}
; 2281 : 
; 2282 : 	for ( int i= ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;i<= ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;i++)

  00088	0f b6 04 bd 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[edi*4+2]
  00090	43		 inc	 ebx
  00091	3b d8		 cmp	 ebx, eax
  00093	7e ab		 jle	 SHORT $LL4@BlockCastl
  00095	5e		 pop	 esi
$LN20@BlockCastl:
  00096	5b		 pop	 ebx
$LN3@BlockCastl:
  00097	5f		 pop	 edi

; 2288 : 		}
; 2289 : 	}
; 2290 : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
?BlockCastleEntrance@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::BlockCastleEntrance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iBridgeIndex$ = 8					; size = 4
_iIndex$ = 12						; size = 4
?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::CheckUserBridgeMember, COMDAT
; _this$ = ecx

; 2711 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2712 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	85 f6		 test	 esi, esi
  0000c	78 3f		 js	 SHORT $LN18@CheckUserB
  0000e	33 c0		 xor	 eax, eax
  00010	83 fe 07	 cmp	 esi, 7
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 33		 je	 SHORT $LN18@CheckUserB

; 2715 : 	}
; 2716 : 
; 2717 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  0001a	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0001d	85 d2		 test	 edx, edx
  0001f	78 2c		 js	 SHORT $LN18@CheckUserB
  00021	33 c0		 xor	 eax, eax
  00023	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00029	0f 9e c0	 setle	 al
  0002c	85 c0		 test	 eax, eax
  0002e	74 1d		 je	 SHORT $LN18@CheckUserB

; 2718 : 	{
; 2719 : 		return false;
; 2720 : 	}
; 2721 : 
; 2722 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00030	69 c6 0c 02 00
	00		 imul	 eax, esi, 524
  00036	33 c9		 xor	 ecx, ecx
  00038	83 c0 1c	 add	 eax, 28			; 0000001cH
  0003b	03 c7		 add	 eax, edi
  0003d	0f 1f 00	 npad	 3
$LL4@CheckUserB:

; 2723 : 	{
; 2724 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == iIndex )

  00040	39 10		 cmp	 DWORD PTR [eax], edx
  00042	74 11		 je	 SHORT $LN14@CheckUserB

; 2718 : 	{
; 2719 : 		return false;
; 2720 : 	}
; 2721 : 
; 2722 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00044	41		 inc	 ecx
  00045	83 c0 14	 add	 eax, 20			; 00000014H
  00048	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0004b	7c f3		 jl	 SHORT $LL4@CheckUserB
$LN18@CheckUserB:
  0004d	5f		 pop	 edi

; 2713 : 	{
; 2714 : 		return false;

  0004e	32 c0		 xor	 al, al
  00050	5e		 pop	 esi

; 2727 : 		}
; 2728 : 	}
; 2729 : 
; 2730 : 	return false;
; 2731 : }

  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
$LN14@CheckUserB:
  00055	5f		 pop	 edi

; 2725 : 		{
; 2726 : 			return true;

  00056	b0 01		 mov	 al, 1
  00058	5e		 pop	 esi

; 2727 : 		}
; 2728 : 	}
; 2729 : 
; 2730 : 	return false;
; 2731 : }

  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
?CheckUserBridgeMember@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::CheckUserBridgeMember
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SendNoticeState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_iPlayState$ = 12					; size = 4
?SendNoticeState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::SendNoticeState, COMDAT
; _this$ = ecx

; 2659 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx

; 2660 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00017	85 f6		 test	 esi, esi
  00019	0f 88 de 00 00
	00		 js	 $LN3@SendNotice
  0001f	33 c0		 xor	 eax, eax
  00021	83 fe 07	 cmp	 esi, 7
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 ce 00 00
	00		 je	 $LN3@SendNotice

; 2661 : 	{
; 2662 : 		return;
; 2663 : 	}
; 2664 : 
; 2665 : 	PMSG_STATEBLOODCASTLE pMsg;
; 2666 : 
; 2667 : 	PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  0002f	6a 0e		 push	 14			; 0000000eH
  00031	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00034	68 9b 00 00 00	 push	 155			; 0000009bH
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2668 : 	pMsg.btPlayState = iPlayState;

  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _iPlayState$[ebp]

; 2669 : 	pMsg.wRemainSec = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;

  00042	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00047	69 f6 0c 02 00
	00		 imul	 esi, esi, 524
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	03 f7		 add	 esi, edi
  00052	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  00055	f7 ae 54 01 00
	00		 imul	 DWORD PTR [esi+340]
  0005b	c1 fa 06	 sar	 edx, 6
  0005e	8b c2		 mov	 eax, edx
  00060	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00063	03 c2		 add	 eax, edx
  00065	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 2670 : 
; 2671 : 	if ( iPlayState == 4 )

  00069	83 f9 04	 cmp	 ecx, 4
  0006c	75 14		 jne	 SHORT $LN6@SendNotice

; 2672 : 	{
; 2673 : 		pMsg.wMaxKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT;

  0006e	0f b7 86 84 01
	00 00		 movzx	 eax, WORD PTR [esi+388]
  00075	66 89 45 f2	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 2674 : 		pMsg.wCurKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT;

  00079	0f b7 86 88 01
	00 00		 movzx	 eax, WORD PTR [esi+392]

; 2675 : 	}
; 2676 : 	else

  00080	eb 12		 jmp	 SHORT $LN19@SendNotice
$LN6@SendNotice:

; 2677 : 	{
; 2678 : 		pMsg.wMaxKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_MAX_COUNT;

  00082	0f b7 86 74 01
	00 00		 movzx	 eax, WORD PTR [esi+372]
  00089	66 89 45 f2	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 2679 : 		pMsg.wCurKillMonster = this->m_BridgeData[iBridgeIndex].m_iBC_MONSTER_KILL_COUNT;

  0008d	0f b7 86 78 01
	00 00		 movzx	 eax, WORD PTR [esi+376]
$LN19@SendNotice:
  00094	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+8], ax

; 2680 : 	}
; 2681 : 
; 2682 : 	pMsg.wUserHaveWeapon = this->m_BridgeData[iBridgeIndex].m_iBC_QUEST_ITEM_USER_INDEX;

  00098	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  0009d	66 8b 86 94 01
	00 00		 mov	 ax, WORD PTR [esi+404]
  000a4	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+10], ax

; 2683 : 	pMsg.btWeaponNum = this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER + 1;

  000a8	8a 86 98 01 00
	00		 mov	 al, BYTE PTR [esi+408]
  000ae	fe c0		 inc	 al
  000b0	83 c6 1c	 add	 esi, 28			; 0000001cH
  000b3	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
$LL4@SendNotice:

; 2686 : 	{
; 2687 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  000b6	8b 16		 mov	 edx, DWORD PTR [esi]
  000b8	83 fa ff	 cmp	 edx, -1
  000bb	74 38		 je	 SHORT $LN2@SendNotice

; 2688 : 		{
; 2689 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c2	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  000c8	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  000cd	7e 26		 jle	 SHORT $LN2@SendNotice

; 2690 : 			{
; 2691 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  000cf	80 bc 01 36 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4662], -1
  000d7	74 1c		 je	 SHORT $LN2@SendNotice

; 2692 : 				{
; 2693 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  000d9	80 bc 01 37 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4663], -1
  000e1	74 12		 je	 SHORT $LN2@SendNotice

; 2694 : 					{
; 2695 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR *)&pMsg, pMsg.h.size);

  000e3	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000e7	50		 push	 eax
  000e8	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000eb	50		 push	 eax
  000ec	52		 push	 edx
  000ed	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendNotice:

; 2684 : 
; 2685 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000f5	83 c6 14	 add	 esi, 20			; 00000014H
  000f8	83 ef 01	 sub	 edi, 1
  000fb	75 b9		 jne	 SHORT $LL4@SendNotice
$LN3@SendNotice:

; 2696 : 					}
; 2697 : 				}
; 2698 : 			}
; 2699 : 		}
; 2700 : 	}
; 2701 : }

  000fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00100	5f		 pop	 edi
  00101	33 cd		 xor	 ecx, ebp
  00103	5e		 pop	 esi
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 08 00	 ret	 8
?SendNoticeState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::SendNoticeState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SendNoticeScore@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?SendNoticeScore@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::SendNoticeScore, COMDAT
; _this$ = ecx

; 2626 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]

; 2627 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00017	85 db		 test	 ebx, ebx
  00019	0f 88 9e 00 00
	00		 js	 $LN3@SendNotice
  0001f	33 c0		 xor	 eax, eax
  00021	83 fb 07	 cmp	 ebx, 7
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 8e 00 00
	00		 je	 $LN3@SendNotice

; 2628 : 	{
; 2629 : 		return;
; 2630 : 	}
; 2631 : 
; 2632 : 	PMSG_NOTICE pNotice;
; 2633 : 	pNotice.type = 0;

  0002f	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524
  00035	56		 push	 esi
  00036	8d 71 1c	 lea	 esi, DWORD PTR [ecx+28]
  00039	c6 85 ef fe ff
	ff 00		 mov	 BYTE PTR _pNotice$[ebp+3], 0
  00040	57		 push	 edi
  00041	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  00046	03 f0		 add	 esi, eax
$LL4@SendNotice:

; 2636 : 	{
; 2637 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00048	8b 06		 mov	 eax, DWORD PTR [esi]
  0004a	83 f8 ff	 cmp	 eax, -1
  0004d	74 64		 je	 SHORT $LN2@SendNotice

; 2638 : 		{
; 2639 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  0004f	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005a	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0005f	7e 52		 jle	 SHORT $LN2@SendNotice

; 2640 : 			{
; 2641 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  00061	80 bc 01 36 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4662], -1
  00069	74 48		 je	 SHORT $LN2@SendNotice

; 2642 : 				{
; 2643 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  0006b	80 bc 01 37 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4663], -1
  00073	74 3e		 je	 SHORT $LN2@SendNotice

; 2644 : 					{
; 2645 : 						TNotice::MakeNoticeMsgEx(&pNotice, 0, lMsg.Get(MSGGET(4, 140)), iBridgeIndex+1, this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iEXP);

  00075	ff 76 04	 push	 DWORD PTR [esi+4]
  00078	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0007b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00080	50		 push	 eax
  00081	68 8c 04 00 00	 push	 1164			; 0000048cH
  00086	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0008b	50		 push	 eax
  0008c	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00092	6a 00		 push	 0
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 2646 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR*)&pNotice, pNotice.h.size);

  0009a	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  000a1	50		 push	 eax
  000a2	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  000a8	50		 push	 eax
  000a9	ff 36		 push	 DWORD PTR [esi]
  000ab	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000b0	83 c4 20	 add	 esp, 32			; 00000020H
$LN2@SendNotice:

; 2634 : 
; 2635 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000b3	83 c6 14	 add	 esi, 20			; 00000014H
  000b6	83 ef 01	 sub	 edi, 1
  000b9	75 8d		 jne	 SHORT $LL4@SendNotice
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
$LN3@SendNotice:

; 2647 : 					}
; 2648 : 				}
; 2649 : 			}
; 2650 : 		}
; 2651 : 	}
; 2652 : }

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c0	33 cd		 xor	 ecx, ebp
  000c2	5b		 pop	 ebx
  000c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 04 00	 ret	 4
?SendNoticeScore@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::SendNoticeScore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_lpszMSG$ = 12						; size = 4
?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z PROC	; CBloodCastle::SendNoticeMessage, COMDAT
; _this$ = ecx

; 2593 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00017	57		 push	 edi
  00018	8b f9		 mov	 edi, ecx
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpszMSG$[ebp]

; 2594 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0001d	85 f6		 test	 esi, esi
  0001f	78 7c		 js	 SHORT $LN3@SendNotice
  00021	33 c0		 xor	 eax, eax
  00023	83 fe 07	 cmp	 esi, 7
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 70		 je	 SHORT $LN3@SendNotice

; 2595 : 	{
; 2596 : 		return;
; 2597 : 	}
; 2598 : 
; 2599 : 	PMSG_NOTICE pNotice;
; 2600 : 
; 2601 : 	TNotice::MakeNoticeMsg( &pNotice, 0, lpszMSG);

  0002d	51		 push	 ecx
  0002e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00034	6a 00		 push	 0
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  0003c	69 c6 0c 02 00
	00		 imul	 eax, esi, 524
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	8d 77 1c	 lea	 esi, DWORD PTR [edi+28]
  00048	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  0004d	03 f0		 add	 esi, eax
  0004f	90		 npad	 1
$LL4@SendNotice:

; 2604 : 	{
; 2605 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00050	8b 16		 mov	 edx, DWORD PTR [esi]
  00052	83 fa ff	 cmp	 edx, -1
  00055	74 3e		 je	 SHORT $LN2@SendNotice

; 2606 : 		{
; 2607 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Connected > PLAYER_LOGGED )

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005c	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00062	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00067	7e 2c		 jle	 SHORT $LN2@SendNotice

; 2608 : 			{
; 2609 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 )

  00069	80 bc 01 36 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4662], -1
  00071	74 22		 je	 SHORT $LN2@SendNotice

; 2610 : 				{
; 2611 : 					if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  00073	80 bc 01 37 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4663], -1
  0007b	74 18		 je	 SHORT $LN2@SendNotice

; 2612 : 					{
; 2613 : 						DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR*)&pNotice, pNotice.h.size);

  0007d	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  00084	50		 push	 eax
  00085	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  0008b	50		 push	 eax
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendNotice:

; 2602 : 
; 2603 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00095	83 c6 14	 add	 esi, 20			; 00000014H
  00098	83 ef 01	 sub	 edi, 1
  0009b	75 b3		 jne	 SHORT $LL4@SendNotice
$LN3@SendNotice:

; 2614 : 					}
; 2615 : 				}
; 2616 : 			}
; 2617 : 		}
; 2618 : 	}
; 2619 : }

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	5f		 pop	 edi
  000a1	33 cd		 xor	 ecx, ebp
  000a3	5e		 pop	 esi
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 08 00	 ret	 8
?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ENDP	; CBloodCastle::SendNoticeMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
_iBridgeIndex$ = 16					; size = 4
?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z PROC	; CBloodCastle::SendBridgeAnyMsg, COMDAT
; _this$ = ecx

; 3481 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3482 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00003	8b 55 10	 mov	 edx, DWORD PTR _iBridgeIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 6b		 js	 SHORT $LN3@SendBridge
  0000a	33 c0		 xor	 eax, eax
  0000c	83 fa 07	 cmp	 edx, 7
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 5f		 je	 SHORT $LN3@SendBridge

; 3483 : 	{
; 3484 : 		return;
; 3485 : 	}
; 3486 : 
; 3487 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  0001a	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  00020	56		 push	 esi
  00021	8d 71 1c	 lea	 esi, DWORD PTR [ecx+28]
  00024	57		 push	 edi
  00025	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  0002a	03 f0		 add	 esi, eax
  0002c	0f 1f 40 00	 npad	 4
$LL4@SendBridge:

; 3488 : 	{
; 3489 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex != -1 )

  00030	8b 16		 mov	 edx, DWORD PTR [esi]
  00032	83 fa ff	 cmp	 edx, -1
  00035	74 33		 je	 SHORT $LN2@SendBridge

; 3490 : 		{
; 3491 : 			if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected == PLAYER_PLAYING )

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003c	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00042	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00047	75 21		 jne	 SHORT $LN2@SendBridge

; 3492 : 			{
; 3493 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  00049	80 bc 01 36 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4662], -1
  00051	74 17		 je	 SHORT $LN2@SendBridge
  00053	80 bc 01 37 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4663], -1
  0005b	74 0d		 je	 SHORT $LN2@SendBridge

; 3494 : 				{
; 3495 : 					DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, lpMsg, iSize);

  0005d	53		 push	 ebx
  0005e	ff 75 08	 push	 DWORD PTR _lpMsg$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendBridge:

; 3483 : 	{
; 3484 : 		return;
; 3485 : 	}
; 3486 : 
; 3487 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0006a	83 c6 14	 add	 esi, 20			; 00000014H
  0006d	83 ef 01	 sub	 edi, 1
  00070	75 be		 jne	 SHORT $LL4@SendBridge
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
$LN3@SendBridge:

; 3496 : 				}
; 3497 : 			}
; 3498 : 		}
; 3499 : 	}
; 3500 : 
; 3501 : }

  00075	5d		 pop	 ebp
  00076	c2 0c 00	 ret	 12			; 0000000cH
?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ENDP	; CBloodCastle::SendBridgeAnyMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iSize$ = 12						; size = 4
?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z PROC	; CBloodCastle::SendAllUserAnyMsg, COMDAT
; _this$ = ecx

; 3508 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3509 : 	for ( int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  0000e	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL4@SendAllUse:

; 3510 : 	{
; 3511 : 		if ( gObj[i].Connected == PLAYER_PLAYING )

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0001d	75 14		 jne	 SHORT $LN2@SendAllUse

; 3512 : 		{
; 3513 : 			if ( gObj[i].Type == OBJ_USER )

  0001f	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00024	75 0d		 jne	 SHORT $LN2@SendAllUse

; 3514 : 			{
; 3515 : 				DataSend(i, lpMsg, iSize);

  00026	53		 push	 ebx
  00027	ff 75 08	 push	 DWORD PTR _lpMsg$[ebp]
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendAllUse:

; 3509 : 	for ( int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  00033	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00039	47		 inc	 edi
  0003a	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00040	7c d1		 jl	 SHORT $LL4@SendAllUse
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 3516 : 			}
; 3517 : 		}
; 3518 : 	}
; 3519 : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
?SendAllUserAnyMsg@CBloodCastle@@QAEXPAEH@Z ENDP	; CBloodCastle::SendAllUserAnyMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z PROC	; CBloodCastle::SendCastleDoorBlockInfo, COMDAT
; _this$ = ecx

; 2544 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi

; 2545 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00015	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00018	8b d9		 mov	 ebx, ecx
  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 3f 01 00
	00		 js	 $LN3@SendCastle
  00022	33 c0		 xor	 eax, eax
  00024	83 fe 07	 cmp	 esi, 7
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 2f 01 00
	00		 je	 $LN3@SendCastle

; 2546 : 	{
; 2547 : 		return;
; 2548 : 	}
; 2549 : 
; 2550 : 	char cTEMP_BUF[256];
; 2551 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2552 : 
; 2553 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  00032	57		 push	 edi
  00033	6a 13		 push	 19			; 00000013H
  00035	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0003b	6a 46		 push	 70			; 00000046H
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2554 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2555 : 	lpMsg->btType = 0;
; 2556 : 	lpMsg->btCount = 3;
; 2557 : 	lpMsg->btMapAttr = 4;
; 2558 : 	(bLive)?lpMsg->btMapSetType=0:lpMsg->btMapSetType=1;
; 2559 : 
; 2560 : 	lpMsgBody[0].btX = ::g_btCastleDoorMapXY[iBridgeIndex][0].btStartX;

  00043	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00046	66 c7 85 ff fe
	ff ff 00 04	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 1024 ; 00000400H
  0004f	0f b6 04 8d 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4]
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	88 85 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], al

; 2561 : 	lpMsgBody[0].btY = ::g_btCastleDoorMapXY[iBridgeIndex][0].btStartY;
; 2562 : 	lpMsgBody[1].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][0].btEndX;
; 2563 : 	lpMsgBody[1].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][0].btEndY;
; 2564 : 
; 2565 : 	lpMsgBody[2].btX = ::g_btCastleDoorMapXY[iBridgeIndex][1].btStartX;
; 2566 : 	lpMsgBody[2].btY = ::g_btCastleDoorMapXY[iBridgeIndex][1].btStartY;
; 2567 : 	lpMsgBody[3].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][1].btEndX;
; 2568 : 	lpMsgBody[3].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][1].btEndY;
; 2569 : 
; 2570 : 	lpMsgBody[4].btX = ::g_btCastleDoorMapXY[iBridgeIndex][2].btStartX;
; 2571 : 	lpMsgBody[4].btY = ::g_btCastleDoorMapXY[iBridgeIndex][2].btStartY;
; 2572 : 	lpMsgBody[5].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][2].btEndX;
; 2573 : 	lpMsgBody[5].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][2].btEndY;
; 2574 : 
; 2575 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  00060	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  00065	0f b6 04 8d 01
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+1]
  0006d	88 85 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], al
  00073	0f b6 04 8d 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+2]
  0007b	80 7d 0c 00	 cmp	 BYTE PTR _bLive$[ebp], 0
  0007f	88 85 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], al
  00085	0f b6 04 8d 03
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+3]
  0008d	0f 94 85 01 ff
	ff ff		 sete	 BYTE PTR _cTEMP_BUF$[ebp+5]
  00094	88 85 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], al
  0009a	0f b6 04 8d 04
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+4]
  000a2	88 85 07 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+11], al
  000a8	0f b6 04 8d 05
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+5]
  000b0	88 85 08 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+12], al
  000b6	0f b6 04 8d 06
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+6]
  000be	88 85 09 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+13], al
  000c4	0f b6 04 8d 07
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+7]
  000cc	88 85 0a ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+14], al
  000d2	0f b6 04 8d 08
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+8]
  000da	88 85 0b ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+15], al
  000e0	0f b6 04 8d 09
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+9]
  000e8	88 85 0c ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+16], al
  000ee	0f b6 04 8d 0a
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+10]
  000f6	88 85 0d ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+17], al
  000fc	0f b6 04 8d 0b
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleDoorMapXY@@3QAY02$$CBUBLOOD_ZONE@@A[ecx*4+11]

; 2576 : 	{
; 2577 : 		int MapNumber = GetEventMap(iBridgeIndex);

  00104	8b cb		 mov	 ecx, ebx
  00106	56		 push	 esi
  00107	c6 85 02 ff ff
	ff 03		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 3
  0010e	88 85 0e ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+18], al
  00114	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  00119	8b d8		 mov	 ebx, eax
  0011b	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL4@SendCastle:

; 2578 : 		if ( gObj[i].MapNumber == MapNumber )

  00120	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00126	0f b6 8c 32 23
	01 00 00	 movzx	 ecx, BYTE PTR [edx+esi+291]
  0012e	3b cb		 cmp	 ecx, ebx
  00130	75 1f		 jne	 SHORT $LN2@SendCastle

; 2579 : 		{
; 2580 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  00132	83 7c 32 04 02	 cmp	 DWORD PTR [edx+esi+4], 2
  00137	7e 18		 jle	 SHORT $LN2@SendCastle

; 2581 : 			{
; 2582 : 				DataSend(i, (UCHAR *)lpMsg, lpMsg->h.size);

  00139	0f b6 85 fd fe
	ff ff		 movzx	 eax, BYTE PTR _cTEMP_BUF$[ebp+1]
  00140	50		 push	 eax
  00141	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  00147	50		 push	 eax
  00148	57		 push	 edi
  00149	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0014e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendCastle:

; 2561 : 	lpMsgBody[0].btY = ::g_btCastleDoorMapXY[iBridgeIndex][0].btStartY;
; 2562 : 	lpMsgBody[1].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][0].btEndX;
; 2563 : 	lpMsgBody[1].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][0].btEndY;
; 2564 : 
; 2565 : 	lpMsgBody[2].btX = ::g_btCastleDoorMapXY[iBridgeIndex][1].btStartX;
; 2566 : 	lpMsgBody[2].btY = ::g_btCastleDoorMapXY[iBridgeIndex][1].btStartY;
; 2567 : 	lpMsgBody[3].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][1].btEndX;
; 2568 : 	lpMsgBody[3].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][1].btEndY;
; 2569 : 
; 2570 : 	lpMsgBody[4].btX = ::g_btCastleDoorMapXY[iBridgeIndex][2].btStartX;
; 2571 : 	lpMsgBody[4].btY = ::g_btCastleDoorMapXY[iBridgeIndex][2].btStartY;
; 2572 : 	lpMsgBody[5].btX   = ::g_btCastleDoorMapXY[iBridgeIndex][2].btEndX;
; 2573 : 	lpMsgBody[5].btY   = ::g_btCastleDoorMapXY[iBridgeIndex][2].btEndY;
; 2574 : 
; 2575 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  00151	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00157	47		 inc	 edi
  00158	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  0015e	7c c0		 jl	 SHORT $LL4@SendCastle
  00160	5f		 pop	 edi
$LN3@SendCastle:

; 2583 : 			}
; 2584 : 		}
; 2585 : 	}
; 2586 : }

  00161	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00164	5e		 pop	 esi
  00165	33 cd		 xor	 ecx, ebp
  00167	5b		 pop	 ebx
  00168	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c2 08 00	 ret	 8
?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP	; CBloodCastle::SendCastleDoorBlockInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
tv330 = -264						; size = 4
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z PROC	; CBloodCastle::SendCastleBridgeBlockInfo, COMDAT
; _this$ = ecx

; 2502 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx

; 2503 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0001a	85 db		 test	 ebx, ebx
  0001c	0f 88 19 01 00
	00		 js	 $LN3@SendCastle
  00022	33 c0		 xor	 eax, eax
  00024	83 fb 07	 cmp	 ebx, 7
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 09 01 00
	00		 je	 $LN3@SendCastle

; 2504 : 	{
; 2505 : 		return;
; 2506 : 	}
; 2507 : 
; 2508 : 	char cTEMP_BUF[256];
; 2509 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2510 : 
; 2511 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  00032	57		 push	 edi
  00033	6a 13		 push	 19			; 00000013H
  00035	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0003b	6a 46		 push	 70			; 00000046H
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2512 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2513 : 	lpMsg->btType = 0;
; 2514 : 	lpMsg->btCount = 1;
; 2515 : 	lpMsg->btMapAttr = 8;
; 2516 : 	(bLive)?lpMsg->btMapSetType=0:lpMsg->btMapSetType=1;
; 2517 : 
; 2518 : 	lpMsgBody[0].btX = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;

  00043	0f b6 04 9d 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[ebx*4]
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	80 7d 0c 00	 cmp	 BYTE PTR _bLive$[ebp], 0

; 2524 : 	{
; 2525 : 		int MapNumber = GetEventMap(iBridgeIndex);

  00052	8b ce		 mov	 ecx, esi
  00054	88 85 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], al
  0005a	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  0005f	0f b6 04 9d 01
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[ebx*4+1]
  00067	0f 94 85 01 ff
	ff ff		 sete	 BYTE PTR _cTEMP_BUF$[ebp+5]
  0006e	88 85 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], al
  00074	0f b6 04 9d 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[ebx*4+2]
  0007c	88 85 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], al
  00082	0f b6 04 9d 03
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[ebx*4+3]
  0008a	53		 push	 ebx
  0008b	66 c7 85 ff fe
	ff ff 00 08	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 2048 ; 00000800H
  00094	c6 85 02 ff ff
	ff 01		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 1
  0009b	88 85 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], al
  000a1	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  000a6	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv330[ebp], eax
  000ac	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
  000b1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL4@SendCastle:

; 2526 : 		if ( gObj[i].MapNumber == MapNumber )

  000c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c6	0f b6 8c 32 23
	01 00 00	 movzx	 ecx, BYTE PTR [edx+esi+291]
  000ce	3b c8		 cmp	 ecx, eax
  000d0	75 59		 jne	 SHORT $LN2@SendCastle

; 2527 : 		{
; 2528 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  000d2	83 7c 32 04 02	 cmp	 DWORD PTR [edx+esi+4], 2
  000d7	7e 52		 jle	 SHORT $LN2@SendCastle

; 2529 : 			{
; 2530 : 				DataSend(i, (UCHAR *)lpMsg, lpMsg->h.size);

  000d9	0f b6 85 fd fe
	ff ff		 movzx	 eax, BYTE PTR _cTEMP_BUF$[ebp+1]
  000e0	50		 push	 eax
  000e1	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  000e7	50		 push	 eax
  000e8	57		 push	 edi
  000e9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2531 : 
; 2532 : 				LogAddTD("[Blood Castle][Bug Tracer] SendCastleBridgeBlockInfo-> Bridge:%d/Live:%d, (%d,%d,%d,%d)",

  000ee	0f b6 85 06 ff
	ff ff		 movzx	 eax, BYTE PTR _cTEMP_BUF$[ebp+10]
  000f5	50		 push	 eax
  000f6	0f b6 85 05 ff
	ff ff		 movzx	 eax, BYTE PTR _cTEMP_BUF$[ebp+9]
  000fd	50		 push	 eax
  000fe	0f b6 85 04 ff
	ff ff		 movzx	 eax, BYTE PTR _cTEMP_BUF$[ebp+8]
  00105	50		 push	 eax
  00106	0f b6 85 03 ff
	ff ff		 movzx	 eax, BYTE PTR _cTEMP_BUF$[ebp+7]
  0010d	50		 push	 eax
  0010e	0f b6 45 0c	 movzx	 eax, BYTE PTR _bLive$[ebp]
  00112	50		 push	 eax
  00113	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00116	50		 push	 eax
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@NGHAEIOD@?$FLBlood?5Castle?$FN?$FLBug?5Tracer?$FN?5SendC@
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00122	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv330[ebp]
  00128	83 c4 28	 add	 esp, 40			; 00000028H
$LN2@SendCastle:

; 2519 : 	lpMsgBody[0].btY = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;
; 2520 : 	lpMsgBody[1].btX   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;
; 2521 : 	lpMsgBody[1].btY   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;
; 2522 : 
; 2523 : 	for ( int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  0012b	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00131	47		 inc	 edi
  00132	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00138	7c 86		 jl	 SHORT $LL4@SendCastle
  0013a	5f		 pop	 edi
$LN3@SendCastle:

; 2533 : 					iBridgeIndex+1, bLive, lpMsgBody[0].btX, lpMsgBody[0].btY, lpMsgBody[1].btX, lpMsgBody[1].btY);
; 2534 : 			}
; 2535 : 		}
; 2536 : 	}
; 2537 : }

  0013b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013e	5e		 pop	 esi
  0013f	33 cd		 xor	 ecx, ebp
  00141	5b		 pop	 ebx
  00142	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 08 00	 ret	 8
?SendCastleBridgeBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP	; CBloodCastle::SendCastleBridgeBlockInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
_bLive$ = 12						; size = 1
?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z PROC ; CBloodCastle::SendCastleEntranceBlockInfo, COMDAT
; _this$ = ecx

; 2461 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi

; 2462 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  00015	8b 75 08	 mov	 esi, DWORD PTR _iBridgeIndex$[ebp]
  00018	8b d9		 mov	 ebx, ecx
  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 cf 00 00
	00		 js	 $LN3@SendCastle
  00022	33 c0		 xor	 eax, eax
  00024	83 fe 07	 cmp	 esi, 7
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 bf 00 00
	00		 je	 $LN3@SendCastle

; 2463 : 	{
; 2464 : 		return;
; 2465 : 	}
; 2466 : 
; 2467 : 	char cTEMP_BUF[256];
; 2468 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 2469 : 
; 2470 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  00032	57		 push	 edi
  00033	6a 13		 push	 19			; 00000013H
  00035	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  0003b	6a 46		 push	 70			; 00000046H
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2471 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 2472 : 	lpMsg->btType = 0;
; 2473 : 	lpMsg->btCount = 1;
; 2474 : 	lpMsg->btMapAttr = 4;
; 2475 : 	(bLive)?(lpMsg->btMapSetType=0) :( lpMsg->btMapSetType=1);
; 2476 : 
; 2477 : 	lpMsgBody[0].btX = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartX;

  00043	0f b6 04 b5 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[esi*4]
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	80 7d 0c 00	 cmp	 BYTE PTR _bLive$[ebp], 0

; 2483 : 	{
; 2484 : 		int MapNumber = GetEventMap(iBridgeIndex);

  00052	8b cb		 mov	 ecx, ebx
  00054	88 85 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], al
  0005a	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  0005f	0f b6 04 b5 01
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[esi*4+1]
  00067	0f 94 85 01 ff
	ff ff		 sete	 BYTE PTR _cTEMP_BUF$[ebp+5]
  0006e	88 85 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], al
  00074	0f b6 04 b5 02
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[esi*4+2]
  0007c	88 85 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], al
  00082	0f b6 04 b5 03
	00 00 00	 movzx	 eax, BYTE PTR ?g_btCastleEntranceMapXY@@3QBUBLOOD_ZONE@@B[esi*4+3]
  0008a	56		 push	 esi
  0008b	66 c7 85 ff fe
	ff ff 00 04	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 1024 ; 00000400H
  00094	c6 85 02 ff ff
	ff 01		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 1
  0009b	88 85 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], al
  000a1	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap
  000a6	8b d8		 mov	 ebx, eax
  000a8	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
  000ad	0f 1f 00	 npad	 3
$LL4@SendCastle:

; 2485 : 		if ( gObj[i].MapNumber == MapNumber )

  000b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b6	0f b6 8c 32 23
	01 00 00	 movzx	 ecx, BYTE PTR [edx+esi+291]
  000be	3b cb		 cmp	 ecx, ebx
  000c0	75 1f		 jne	 SHORT $LN2@SendCastle

; 2486 : 		{
; 2487 : 			if ( gObj[i].Connected > PLAYER_LOGGED )

  000c2	83 7c 32 04 02	 cmp	 DWORD PTR [edx+esi+4], 2
  000c7	7e 18		 jle	 SHORT $LN2@SendCastle

; 2488 : 			{
; 2489 : 				DataSend(i, (unsigned char *)lpMsg, lpMsg->h.size);

  000c9	0f b6 85 fd fe
	ff ff		 movzx	 eax, BYTE PTR _cTEMP_BUF$[ebp+1]
  000d0	50		 push	 eax
  000d1	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp]
  000d7	50		 push	 eax
  000d8	57		 push	 edi
  000d9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SendCastle:

; 2478 : 	lpMsgBody[0].btY = ::g_btCastleEntranceMapXY[iBridgeIndex].btStartY;
; 2479 : 	lpMsgBody[1].btX   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndX;
; 2480 : 	lpMsgBody[1].btY   = ::g_btCastleEntranceMapXY[iBridgeIndex].btEndY;
; 2481 : 
; 2482 : 	for (int i=OBJ_MAXMONSTER;i<OBJMAX;i++)

  000e1	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  000e7	47		 inc	 edi
  000e8	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  000ee	7c c0		 jl	 SHORT $LL4@SendCastle
  000f0	5f		 pop	 edi
$LN3@SendCastle:

; 2490 : 			}
; 2491 : 		}
; 2492 : 	}
; 2493 : 
; 2494 : }

  000f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f4	5e		 pop	 esi
  000f5	33 cd		 xor	 ecx, ebp
  000f7	5b		 pop	 ebx
  000f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 08 00	 ret	 8
?SendCastleEntranceBlockInfo@CBloodCastle@@QAEXH_N@Z ENDP ; CBloodCastle::SendCastleEntranceBlockInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SetUserState@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv450 = -8						; size = 4
_iBridgeIndex$1$ = -4					; size = 4
_iBridgeSubIndex$1$ = 8					; size = 4
_iIndex$ = 8						; size = 4
tv443 = 12						; size = 4
_iState$ = 12						; size = 4
?SetUserState@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::SetUserState, COMDAT
; _this$ = ecx

; 2863 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx
  00005	83 ec 08	 sub	 esp, 8

; 2864 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  0000b	85 c9		 test	 ecx, ecx
  0000d	0f 88 b2 01 00
	00		 js	 $LN2@SetUserSta
  00013	33 c0		 xor	 eax, eax
  00015	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0001b	0f 9e c0	 setle	 al
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 9f 01 00
	00		 je	 $LN2@SetUserSta

; 2865 : 	{
; 2866 : 		return;
; 2867 : 	}
; 2868 : 
; 2869 : 	int iBridgeIndex = gObj[iIndex].m_cBloodCastleIndex;

  00026	53		 push	 ebx
  00027	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  0002d	56		 push	 esi
  0002e	57		 push	 edi
  0002f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	89 4d f8	 mov	 DWORD PTR tv450[ebp], ecx
  00038	0f be 9c 39 36
	12 00 00	 movsx	 ebx, BYTE PTR [ecx+edi+4662]

; 2870 : 	int iBridgeSubIndex = gObj[iIndex].m_cBloodCastleSubIndex;

  00040	0f be b4 39 37
	12 00 00	 movsx	 esi, BYTE PTR [ecx+edi+4663]
  00048	89 5d fc	 mov	 DWORD PTR _iBridgeIndex$1$[ebp], ebx
  0004b	89 75 08	 mov	 DWORD PTR _iBridgeSubIndex$1$[ebp], esi

; 2871 : 
; 2872 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0004e	85 db		 test	 ebx, ebx
  00050	0f 88 6c 01 00
	00		 js	 $LN39@SetUserSta
  00056	33 c0		 xor	 eax, eax
  00058	83 fb 07	 cmp	 ebx, 7
  0005b	0f 9e c0	 setle	 al
  0005e	85 c0		 test	 eax, eax
  00060	0f 84 5c 01 00
	00		 je	 $LN39@SetUserSta

; 2873 : 	{
; 2874 : 		return;
; 2875 : 	}
; 2876 : 
; 2877 : 	if ( BC_SUB_BRIDGE_RANGE(iBridgeSubIndex) == FALSE )

  00066	85 f6		 test	 esi, esi
  00068	0f 88 54 01 00
	00		 js	 $LN39@SetUserSta
  0006e	33 c0		 xor	 eax, eax
  00070	83 fe 09	 cmp	 esi, 9
  00073	0f 9e c0	 setle	 al
  00076	85 c0		 test	 eax, eax
  00078	0f 84 44 01 00
	00		 je	 $LN39@SetUserSta

; 2878 : 	{
; 2879 : 		return;
; 2880 : 	}
; 2881 : 
; 2882 : 	switch ( iState )

  0007e	8b 45 0c	 mov	 eax, DWORD PTR _iState$[ebp]
  00081	83 f8 04	 cmp	 eax, 4
  00084	0f 87 38 01 00
	00		 ja	 $LN39@SetUserSta
  0008a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN44@SetUserSta[eax*4]
$LN10@SetUserSta:

; 2883 : 	{
; 2884 : 		case 0:
; 2885 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 0;

  00091	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524
  00097	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	03 c2		 add	 eax, edx
  0009f	c7 44 88 28 00
	00 00 00	 mov	 DWORD PTR [eax+ecx*4+40], 0

; 2931 : 			break;
; 2932 : 	}
; 2933 : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 08 00	 ret	 8
$LN11@SetUserSta:

; 2886 : 			break;
; 2887 : 
; 2888 : 		case 1:
; 2889 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 1;

  000ad	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524
  000b3	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	03 c2		 add	 eax, edx
  000bb	c7 44 88 28 01
	00 00 00	 mov	 DWORD PTR [eax+ecx*4+40], 1

; 2931 : 			break;
; 2932 : 	}
; 2933 : }

  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c2 08 00	 ret	 8
$LN12@SetUserSta:

; 2890 : 			break;
; 2891 : 
; 2892 : 		case 2:
; 2893 : 			if ( gObj[iIndex].PartyNumber >= 0 )

  000c9	83 bc 39 0c 06
	00 00 00	 cmp	 DWORD PTR [ecx+edi+1548], 0
  000d1	0f 8c 96 00 00
	00		 jl	 $LN5@SetUserSta

; 2894 : 			{
; 2895 : 				for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  000d7	33 db		 xor	 ebx, ebx
  000d9	33 c9		 xor	 ecx, ecx
  000db	0f 1f 44 00 00	 npad	 5
$LL6@SetUserSta:

; 2896 : 				{
; 2897 : 					if ( i == iBridgeSubIndex )

  000e0	3b de		 cmp	 ebx, esi
  000e2	74 76		 je	 SHORT $LN4@SetUserSta

; 2898 : 					{
; 2899 : 						continue;
; 2900 : 					}
; 2901 : 
; 2902 : 					if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  000e4	69 75 fc 0c 02
	00 00		 imul	 esi, DWORD PTR _iBridgeIndex$1$[ebp], 524
  000eb	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  000ee	8b 44 10 1c	 mov	 eax, DWORD PTR [eax+edx+28]
  000f2	83 f8 ff	 cmp	 eax, -1
  000f5	74 60		 je	 SHORT $LN38@SetUserSta

; 2903 : 					{
; 2904 : 						continue;
; 2905 : 					}
; 2906 : 
; 2907 : 					if ( gObj[iIndex].PartyNumber == gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber )

  000f7	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000fd	03 c7		 add	 eax, edi
  000ff	89 45 0c	 mov	 DWORD PTR tv443[ebp], eax
  00102	8b 45 f8	 mov	 eax, DWORD PTR tv450[ebp]
  00105	8b 84 38 0c 06
	00 00		 mov	 eax, DWORD PTR [eax+edi+1548]
  0010c	8b 7d 0c	 mov	 edi, DWORD PTR tv443[ebp]
  0010f	3b 87 0c 06 00
	00		 cmp	 eax, DWORD PTR [edi+1548]
  00115	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011b	75 3a		 jne	 SHORT $LN38@SetUserSta

; 2908 : 					{
; 2909 : 						if ( BC_MAP_RANGE( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].MapNumber ) != FALSE )

  0011d	8b 45 0c	 mov	 eax, DWORD PTR tv443[ebp]
  00120	8a 80 23 01 00
	00		 mov	 al, BYTE PTR [eax+291]
  00126	3c 34		 cmp	 al, 52			; 00000034H
  00128	74 1c		 je	 SHORT $LN36@SetUserSta
  0012a	3c 0b		 cmp	 al, 11			; 0000000bH
  0012c	72 0b		 jb	 SHORT $LN17@SetUserSta
  0012e	b4 11		 mov	 ah, 17			; 00000011H
  00130	3a e0		 cmp	 ah, al
  00132	1b c0		 sbb	 eax, eax
  00134	83 c0 01	 add	 eax, 1
  00137	75 0d		 jne	 SHORT $LN36@SetUserSta
$LN17@SetUserSta:

; 2912 : 						}
; 2913 : 						else
; 2914 : 						{
; 2915 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 4;

  00139	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  0013c	c7 44 10 28 04
	00 00 00	 mov	 DWORD PTR [eax+edx+40], 4
  00144	eb 0b		 jmp	 SHORT $LN42@SetUserSta
$LN36@SetUserSta:

; 2910 : 						{
; 2911 : 							this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState = 3;

  00146	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  00149	c7 44 10 28 03
	00 00 00	 mov	 DWORD PTR [eax+edx+40], 3
$LN42@SetUserSta:
  00151	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN38@SetUserSta:
  00157	8b 75 08	 mov	 esi, DWORD PTR _iBridgeSubIndex$1$[ebp]
$LN4@SetUserSta:

; 2894 : 			{
; 2895 : 				for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0015a	83 c1 14	 add	 ecx, 20			; 00000014H
  0015d	43		 inc	 ebx
  0015e	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  00164	0f 8c 76 ff ff
	ff		 jl	 $LL6@SetUserSta
  0016a	8b 5d fc	 mov	 ebx, DWORD PTR _iBridgeIndex$1$[ebp]
$LN5@SetUserSta:

; 2916 : 						}
; 2917 : 					}
; 2918 : 				}
; 2919 : 			}
; 2920 : 
; 2921 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 2;

  0016d	69 cb 0c 02 00
	00		 imul	 ecx, ebx, 524
  00173	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00176	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00179	5f		 pop	 edi
  0017a	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0017d	c7 04 10 02 00
	00 00		 mov	 DWORD PTR [eax+edx], 2

; 2922 : 			this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS = iBridgeSubIndex;

  00184	89 b4 11 48 01
	00 00		 mov	 DWORD PTR [ecx+edx+328], esi
  0018b	5e		 pop	 esi
  0018c	5b		 pop	 ebx

; 2931 : 			break;
; 2932 : 	}
; 2933 : }

  0018d	8b e5		 mov	 esp, ebp
  0018f	5d		 pop	 ebp
  00190	c2 08 00	 ret	 8
$LN19@SetUserSta:

; 2923 : 			break;
; 2924 : 
; 2925 : 		case 3:
; 2926 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 3;

  00193	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524
  00199	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi
  0019e	5b		 pop	 ebx
  0019f	03 c2		 add	 eax, edx
  001a1	c7 44 88 28 03
	00 00 00	 mov	 DWORD PTR [eax+ecx*4+40], 3

; 2931 : 			break;
; 2932 : 	}
; 2933 : }

  001a9	8b e5		 mov	 esp, ebp
  001ab	5d		 pop	 ebp
  001ac	c2 08 00	 ret	 8
$LN20@SetUserSta:

; 2927 : 			break;
; 2928 : 
; 2929 : 		case 4:
; 2930 : 			this->m_BridgeData[iBridgeIndex].m_UserData[iBridgeSubIndex].m_iUserState = 4;

  001af	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524
  001b5	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  001b8	03 c2		 add	 eax, edx
  001ba	c7 44 88 28 04
	00 00 00	 mov	 DWORD PTR [eax+ecx*4+40], 4
$LN39@SetUserSta:
  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi
  001c4	5b		 pop	 ebx
$LN2@SetUserSta:

; 2931 : 			break;
; 2932 : 	}
; 2933 : }

  001c5	8b e5		 mov	 esp, ebp
  001c7	5d		 pop	 ebp
  001c8	c2 08 00	 ret	 8
  001cb	90		 npad	 1
$LN44@SetUserSta:
  001cc	00 00 00 00	 DD	 $LN10@SetUserSta
  001d0	00 00 00 00	 DD	 $LN11@SetUserSta
  001d4	00 00 00 00	 DD	 $LN12@SetUserSta
  001d8	00 00 00 00	 DD	 $LN19@SetUserSta
  001dc	00 00 00 00	 DD	 $LN20@SetUserSta
?SetUserState@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::SetUserState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_iLEVEL$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
_x$1$ = 8						; size = 4
_iIndex$ = 8						; size = 4
?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::SearchUserDropQuestItem, COMDAT
; _this$ = ecx

; 2798 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2799 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00006	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00009	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000c	85 d2		 test	 edx, edx
  0000e	0f 88 b9 01 00
	00		 js	 $LN7@SearchUser
  00014	33 c0		 xor	 eax, eax
  00016	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  0001c	0f 9e c0	 setle	 al
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 a6 01 00
	00		 je	 $LN7@SearchUser

; 2800 : 	{
; 2801 : 		return;
; 2802 : 	}
; 2803 : 
; 2804 : 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002d	53		 push	 ebx
  0002e	69 da 40 27 00
	00		 imul	 ebx, edx, 10048
  00034	80 7c 0b 50 01	 cmp	 BYTE PTR [ebx+ecx+80], 1
  00039	0f 85 8d 01 00
	00		 jne	 $LN30@SearchUser
  0003f	83 7c 0b 04 02	 cmp	 DWORD PTR [ebx+ecx+4], 2
  00044	0f 8e 82 01 00
	00		 jle	 $LN30@SearchUser

; 2805 : 	{
; 2806 : 		return;
; 2807 : 	}
; 2808 : 
; 2809 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  0004a	56		 push	 esi
  0004b	57		 push	 edi
  0004c	33 ff		 xor	 edi, edi
  0004e	33 f6		 xor	 esi, esi
  00050	89 7d 08	 mov	 DWORD PTR _x$1$[ebp], edi
  00053	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL4@SearchUser:

; 2810 : 	{
; 2811 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00060	8b 8c 0b c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+ecx+4544]
  00067	03 ce		 add	 ecx, esi
  00069	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 2812 : 		{
; 2813 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00074	83 f8 01	 cmp	 eax, 1
  00077	0f 85 37 01 00
	00		 jne	 $LN2@SearchUser
  0007d	8b 84 0b c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+4544]
  00084	ba 13 1a 00 00	 mov	 edx, 6675		; 00001a13H
  00089	66 39 54 30 06	 cmp	 WORD PTR [eax+esi+6], dx
  0008e	0f 85 20 01 00
	00		 jne	 $LN2@SearchUser

; 2814 : 			{
; 2815 : 				int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  00094	0f bf 54 30 08	 movsx	 edx, WORD PTR [eax+esi+8]
  00099	89 55 f8	 mov	 DWORD PTR _iLEVEL$1$[ebp], edx

; 2816 : 
; 2817 : 				if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  0009c	85 d2		 test	 edx, edx
  0009e	0f 88 10 01 00
	00		 js	 $LN2@SearchUser
  000a4	33 c0		 xor	 eax, eax
  000a6	83 fa 02	 cmp	 edx, 2
  000a9	0f 9e c0	 setle	 al
  000ac	85 c0		 test	 eax, eax
  000ae	0f 84 00 01 00
	00		 je	 $LN2@SearchUser

; 2818 : 				{
; 2819 : 					BYTE pMsg[6];
; 2820 : 					pMsg[5] = x;
; 2821 : 					pMsg[3] = gObj[iIndex].X;
; 2822 : 					pMsg[4] = gObj[iIndex].Y;
; 2823 : 
; 2824 : 					int iBridgeIndex = GetBridgeLevel(gObj[iIndex].MapNumber);

  000b4	0f b6 84 0b 23
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+291]

; 2825 : 
; 2826 : 					this->DropItemDirectly(iBridgeIndex,gObj[iIndex].m_Index, ITEMGET(13, 19), x);

  000bc	57		 push	 edi
  000bd	68 13 1a 00 00	 push	 6675			; 00001a13H
  000c2	ff 34 0b	 push	 DWORD PTR [ebx+ecx]
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  000ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ; CBloodCastle::DropItemDirectly

; 2827 : 					this->DropItemDirectly(gObj[iIndex].MapNumber - MAP_INDEX_BLOODCASTLE1,gObj[iIndex].m_Index, ITEMGET(13, 19), x);

  000d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000df	57		 push	 edi
  000e0	68 13 1a 00 00	 push	 6675			; 00001a13H
  000e5	ff 34 03	 push	 DWORD PTR [ebx+eax]
  000e8	0f b6 84 03 23
	01 00 00	 movzx	 eax, BYTE PTR [ebx+eax+291]
  000f0	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ?DropItemDirectly@CBloodCastle@@QAEHHHHH@Z ; CBloodCastle::DropItemDirectly

; 2828 : 
; 2829 : 					if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) != FALSE )

  000f9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ff	8a 8c 3b 23 01
	00 00		 mov	 cl, BYTE PTR [ebx+edi+291]
  00106	80 f9 34	 cmp	 cl, 52			; 00000034H
  00109	74 3c		 je	 SHORT $LN28@SearchUser
  0010b	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0010e	72 0e		 jb	 SHORT $LN11@SearchUser
  00110	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00115	3a c1		 cmp	 al, cl
  00117	1b c0		 sbb	 eax, eax
  00119	83 c0 01	 add	 eax, 1
  0011c	75 29		 jne	 SHORT $LN28@SearchUser
$LN11@SearchUser:

; 2842 : 							gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL, this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL,
; 2843 : 							gObj[iIndex].pInventory[x].m_Number);
; 2844 : 
; 2845 : 					}
; 2846 : 					else
; 2847 : 					{
; 2848 : 						LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%d]",

  0011e	8b 84 3b c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+edi+4544]
  00125	ff 34 30	 push	 DWORD PTR [eax+esi]
  00128	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0012b	ff 75 f8	 push	 DWORD PTR _iLEVEL$1$[ebp]
  0012e	03 c3		 add	 eax, ebx
  00130	50		 push	 eax
  00131	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00134	03 c3		 add	 eax, ebx
  00136	50		 push	 eax
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@OICDBHD@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00142	83 c4 14	 add	 esp, 20			; 00000014H
  00145	eb 64		 jmp	 SHORT $LN32@SearchUser
$LN28@SearchUser:

; 2830 : 					{
; 2831 : 						int iBC_INDEX = GetBridgeLevel(gObj[iIndex].MapNumber);

  00147	0f b6 c1	 movzx	 eax, cl
  0014a	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel

; 2832 : 
; 2833 : 						if ( this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL != -1 )

  00153	69 d0 0c 02 00
	00		 imul	 edx, eax, 524
  00159	03 55 fc	 add	 edx, DWORD PTR _this$1$[ebp]
  0015c	8b 8a 90 01 00
	00		 mov	 ecx, DWORD PTR [edx+400]
  00162	83 f9 ff	 cmp	 ecx, -1
  00165	74 1c		 je	 SHORT $LN14@SearchUser

; 2834 : 						{
; 2835 : 							if ( this->m_BridgeData[iBC_INDEX].m_nBC_QUESTITEM_SERIAL == gObj[iIndex].pInventory[x].m_Number )

  00167	8b 84 3b c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+edi+4544]
  0016e	3b 0c 06	 cmp	 ecx, DWORD PTR [esi+eax]
  00171	75 10		 jne	 SHORT $LN14@SearchUser

; 2836 : 							{
; 2837 : 								this->m_BridgeData[iBC_INDEX].m_iBC_QUEST_ITEM_USER_INDEX = -1;

  00173	c7 82 94 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+404], -1
  0017d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN14@SearchUser:

; 2838 : 							}
; 2839 : 						}
; 2840 : 
; 2841 : 						LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Drop Angel King's Weapon (%d) [Serial:%d-%d]",

  00183	8b 84 3b c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+edi+4544]
  0018a	ff 34 30	 push	 DWORD PTR [eax+esi]
  0018d	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00190	51		 push	 ecx
  00191	ff 75 f8	 push	 DWORD PTR _iLEVEL$1$[ebp]
  00194	03 c7		 add	 eax, edi
  00196	50		 push	 eax
  00197	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  0019a	03 c7		 add	 eax, edi
  0019c	50		 push	 eax
  0019d	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@LNKJMMJP@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001a8	83 c4 18	 add	 esp, 24			; 00000018H
$LN32@SearchUser:
  001ab	8b 7d 08	 mov	 edi, DWORD PTR _x$1$[ebp]
  001ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN2@SearchUser:

; 2805 : 	{
; 2806 : 		return;
; 2807 : 	}
; 2808 : 
; 2809 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  001b4	47		 inc	 edi
  001b5	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  001bb	89 7d 08	 mov	 DWORD PTR _x$1$[ebp], edi
  001be	81 fe 44 c4 00
	00		 cmp	 esi, 50244		; 0000c444H
  001c4	0f 8c 96 fe ff
	ff		 jl	 $LL4@SearchUser
  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi
$LN30@SearchUser:
  001cc	5b		 pop	 ebx
$LN7@SearchUser:

; 2849 : 							gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL,
; 2850 : 							gObj[iIndex].pInventory[x].m_Number);
; 2851 : 					}
; 2852 : 				}
; 2853 : 			}
; 2854 : 		}
; 2855 : 	}
; 2856 : }

  001cd	8b e5		 mov	 esp, ebp
  001cf	5d		 pop	 ebp
  001d0	c2 04 00	 ret	 4
?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::SearchUserDropQuestItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv246 = -4						; size = 4
_iIndex$ = 8						; size = 4
?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z PROC	; CBloodCastle::SearchUserDeleteQuestItem, COMDAT
; _this$ = ecx

; 2766 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2767 : 	if ( gObjIsConnected(iIndex) == FALSE )

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00008	53		 push	 ebx
  00009	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	0f 84 cd 00 00
	00		 je	 $LN3@SearchUser

; 2768 : 	{
; 2769 : 		return;
; 2770 : 	}
; 2771 : 
; 2772 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  00019	69 db 40 27 00
	00		 imul	 ebx, ebx, 10048
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	33 ff		 xor	 edi, edi
  00023	33 f6		 xor	 esi, esi
  00025	89 5d fc	 mov	 DWORD PTR tv246[ebp], ebx
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@SearchUser:

; 2773 : 	{
; 2774 : 		if ( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	8b 8c 03 c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4544]
  0003c	03 ce		 add	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00043	83 f8 01	 cmp	 eax, 1
  00046	0f 85 85 00 00
	00		 jne	 $LN2@SearchUser

; 2775 : 		{
; 2776 : 			if ( gObj[iIndex].pInventory[x].m_Type == ITEMGET(13,19) )

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00051	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  00056	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  0005d	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  00062	75 6d		 jne	 SHORT $LN2@SearchUser

; 2777 : 			{
; 2778 : 				int iLEVEL = gObj[iIndex].pInventory[x].m_Level;

  00064	0f bf 5c 30 08	 movsx	 ebx, WORD PTR [eax+esi+8]

; 2779 : 
; 2780 : 				if ( BC_WEAPON_LEVEL_RANGE(iLEVEL) != FALSE )

  00069	85 db		 test	 ebx, ebx
  0006b	78 61		 js	 SHORT $LN18@SearchUser
  0006d	33 c0		 xor	 eax, eax
  0006f	83 fb 02	 cmp	 ebx, 2
  00072	0f 9e c0	 setle	 al
  00075	85 c0		 test	 eax, eax
  00077	74 55		 je	 SHORT $LN18@SearchUser

; 2781 : 				{
; 2782 : 					::gObjInventoryItemSet(iIndex, x, -1);

  00079	68 ff 00 00 00	 push	 255			; 000000ffH
  0007e	57		 push	 edi
  0007f	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00082	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 2783 : 					::gObjInventoryDeleteItem(iIndex, x);

  00087	57		 push	 edi
  00088	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  0008b	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 2784 : 					::GCInventoryItemDeleteSend(iIndex, x, TRUE);

  00090	6a 01		 push	 1
  00092	57		 push	 edi
  00093	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00096	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 2785 : 
; 2786 : 					LogAddTD("[Blood Castle] Force (Account:%s, Name:%s) to Delete Angel King's Weapon (%d) [Serial:%d]",

  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a1	8b 45 fc	 mov	 eax, DWORD PTR tv246[ebp]
  000a4	8b 84 08 c0 11
	00 00		 mov	 eax, DWORD PTR [eax+ecx+4544]
  000ab	ff 34 30	 push	 DWORD PTR [eax+esi]
  000ae	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000b1	53		 push	 ebx
  000b2	8b 5d fc	 mov	 ebx, DWORD PTR tv246[ebp]
  000b5	03 c3		 add	 eax, ebx
  000b7	50		 push	 eax
  000b8	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000bb	03 c3		 add	 eax, ebx
  000bd	50		 push	 eax
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@LLMALHHB@?$FLBlood?5Castle?$FN?5Force?5?$CIAccount?3?$CFs@
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c9	83 c4 34	 add	 esp, 52			; 00000034H
  000cc	eb 03		 jmp	 SHORT $LN2@SearchUser
$LN18@SearchUser:
  000ce	8b 5d fc	 mov	 ebx, DWORD PTR tv246[ebp]
$LN2@SearchUser:

; 2768 : 	{
; 2769 : 		return;
; 2770 : 	}
; 2771 : 
; 2772 : 	for ( int x=0;x<INVENTORY_SIZE;x++)

  000d1	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  000d7	47		 inc	 edi
  000d8	81 fe 44 c4 00
	00		 cmp	 esi, 50244		; 0000c444H
  000de	0f 8c 4c ff ff
	ff		 jl	 $LL4@SearchUser
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
$LN3@SearchUser:
  000e6	5b		 pop	 ebx

; 2787 : 						gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL, gObj[iIndex].pInventory[x].m_Number);
; 2788 : 				}
; 2789 : 			}
; 2790 : 		}
; 2791 : 	}
; 2792 : }

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 04 00	 ret	 4
?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ENDP	; CBloodCastle::SearchUserDeleteQuestItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GiveReward_Fail@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
tv1091 = -292						; size = 4
_this$GSCopy$1$ = -288					; size = 4
tv1090 = -284						; size = 4
_iBridgeIndex$GSCopy$1$ = -280				; size = 4
_pMsg$1 = -276						; size = 269
__$ArrayPad$ = -4					; size = 4
_iBridgeIndex$ = 8					; size = 4
?GiveReward_Fail@CBloodCastle@@QAEXH@Z PROC		; CBloodCastle::GiveReward_Fail, COMDAT
; _this$ = ecx

; 3178 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _iBridgeIndex$[ebp]
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	89 9d e8 fe ff
	ff		 mov	 DWORD PTR _iBridgeIndex$GSCopy$1$[ebp], ebx

; 3179 : 	this->FixUsersPlayStateFail(iBridgeIndex);

  00020	53		 push	 ebx
  00021	89 b5 e0 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00027	e8 00 00 00 00	 call	 ?FixUsersPlayStateFail@CBloodCastle@@QAEXH@Z ; CBloodCastle::FixUsersPlayStateFail

; 3180 : 
; 3181 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  0002c	85 db		 test	 ebx, ebx
  0002e	0f 88 76 02 00
	00		 js	 $LN3@GiveReward
  00034	33 c0		 xor	 eax, eax
  00036	83 fb 07	 cmp	 ebx, 7
  00039	0f 9e c0	 setle	 al
  0003c	85 c0		 test	 eax, eax
  0003e	0f 84 66 02 00
	00		 je	 $LN3@GiveReward

; 3182 : 	{
; 3183 : 		return;
; 3184 : 	}
; 3185 : 
; 3186 : 	int iUserWhoGotUltimateWeapon = -1;
; 3187 : 	iUserWhoGotUltimateWeapon = this->GetWhoGotUltimateWeapon(iBridgeIndex);

  00044	53		 push	 ebx
  00045	8b ce		 mov	 ecx, esi
  00047	e8 00 00 00 00	 call	 ?GetWhoGotUltimateWeapon@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWhoGotUltimateWeapon

; 3188 : 
; 3189 : 	if ( iUserWhoGotUltimateWeapon != -1 )

  0004c	83 f8 ff	 cmp	 eax, -1
  0004f	74 47		 je	 SHORT $LN7@GiveReward

; 3190 : 	{
; 3191 : 		if ( OBJMAX_RANGE(iUserWhoGotUltimateWeapon) != FALSE )

  00051	85 c0		 test	 eax, eax
  00053	78 43		 js	 SHORT $LN7@GiveReward
  00055	33 c9		 xor	 ecx, ecx
  00057	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0005c	0f 9e c1	 setle	 cl
  0005f	85 c9		 test	 ecx, ecx
  00061	74 35		 je	 SHORT $LN7@GiveReward

; 3192 : 		{
; 3193 : 			LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) got Ultimate Weapon (%d) but Failed - Time Out",

  00063	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00069	69 c3 0c 02 00
	00		 imul	 eax, ebx, 524
  0006f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00075	0f b6 84 30 98
	01 00 00	 movzx	 eax, BYTE PTR [eax+esi+408]
  0007d	50		 push	 eax
  0007e	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00081	50		 push	 eax
  00082	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00085	50		 push	 eax
  00086	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00089	50		 push	 eax
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@DAACGPGK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00095	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@GiveReward:

; 3194 : 				iBridgeIndex+1, gObj[iUserWhoGotUltimateWeapon].AccountID, gObj[iUserWhoGotUltimateWeapon].Name,
; 3195 : 				this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER);
; 3196 : 		}
; 3197 : 	}
; 3198 : 
; 3199 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00098	8b d3		 mov	 edx, ebx
  0009a	c7 85 dc fe ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv1091[ebp], 10 ; 0000000aH
  000a4	69 c2 0c 02 00
	00		 imul	 eax, edx, 524
  000aa	57		 push	 edi
  000ab	8d 7e 1c	 lea	 edi, DWORD PTR [esi+28]
  000ae	03 f8		 add	 edi, eax
  000b0	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  000b3	89 8d e4 fe ff
	ff		 mov	 DWORD PTR tv1090[ebp], ecx
  000b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@GiveReward:

; 3200 : 	{
; 3201 : 		if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  000c0	8b 1f		 mov	 ebx, DWORD PTR [edi]
  000c2	83 fb ff	 cmp	 ebx, -1
  000c5	0f 84 ce 01 00
	00		 je	 $LN2@GiveReward

; 3202 : 		{
; 3203 : 			continue;
; 3204 : 		}
; 3205 : 
; 3206 : 		if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected < PLAYER_PLAYING )

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d0	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  000d6	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  000db	0f 8c b8 01 00
	00		 jl	 $LN2@GiveReward

; 3207 : 		{
; 3208 : 			continue;
; 3209 : 		}
; 3210 : 
; 3211 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 )

  000e1	80 bc 01 36 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4662], -1
  000e9	0f 84 aa 01 00
	00		 je	 $LN2@GiveReward
  000ef	80 bc 01 37 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4663], -1
  000f7	0f 84 9c 01 00
	00		 je	 $LN2@GiveReward

; 3212 : 		{
; 3213 : 			continue;
; 3214 : 		}	
; 3215 : 
; 3216 : 		int iADD_EXP = 0;
; 3217 : 
; 3218 : 		if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index)

  000fd	8b 8c 01 0c 06
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+1548]
  00104	33 f6		 xor	 esi, esi
  00106	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR tv1090[ebp]
  0010c	83 f9 ff	 cmp	 ecx, -1
  0010f	74 08		 je	 SHORT $LN15@GiveReward
  00111	3b 88 a0 01 00
	00		 cmp	 ecx, DWORD PTR [eax+416]
  00117	74 08		 je	 SHORT $LN14@GiveReward
$LN15@GiveReward:
  00119	3b 98 a4 01 00
	00		 cmp	 ebx, DWORD PTR [eax+420]
  0011f	75 0d		 jne	 SHORT $LN12@GiveReward
$LN14@GiveReward:

; 3219 : 		{
; 3220 : 			iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0;

  00121	8b f2		 mov	 esi, edx
  00123	c1 e6 04	 shl	 esi, 4
  00126	8b b6 00 00 00
	00		 mov	 esi, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[esi]

; 3221 : 		}
; 3222 : 		else

  0012c	eb 29		 jmp	 SHORT $LN17@GiveReward
$LN12@GiveReward:

; 3223 : 		{
; 3224 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 )

  0012e	83 f9 ff	 cmp	 ecx, -1
  00131	74 31		 je	 SHORT $LN20@GiveReward

; 3225 : 			{
; 3226 : 				if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak != false )

  00133	80 7f 11 00	 cmp	 BYTE PTR [edi+17], 0
  00137	74 1e		 je	 SHORT $LN17@GiveReward

; 3227 : 				{
; 3228 : 					iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0 / 2;

  00139	8b c2		 mov	 eax, edx
  0013b	c1 e0 04	 shl	 eax, 4
  0013e	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[eax]
  00144	99		 cdq
  00145	2b c2		 sub	 eax, edx
  00147	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  0014d	8b f0		 mov	 esi, eax
  0014f	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR tv1090[ebp]
  00155	d1 fe		 sar	 esi, 1
$LN17@GiveReward:

; 3229 : 				}
; 3230 : 			}
; 3231 : 		}
; 3232 : 
; 3233 : 		if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index)

  00157	83 f9 ff	 cmp	 ecx, -1
  0015a	74 08		 je	 SHORT $LN20@GiveReward
  0015c	3b 88 c0 01 00
	00		 cmp	 ecx, DWORD PTR [eax+448]
  00162	74 08		 je	 SHORT $LN19@GiveReward
$LN20@GiveReward:
  00164	3b 98 c4 01 00
	00		 cmp	 ebx, DWORD PTR [eax+452]
  0016a	75 0b		 jne	 SHORT $LN18@GiveReward
$LN19@GiveReward:

; 3234 : 		{
; 3235 : 			iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk4;

  0016c	8b c2		 mov	 eax, edx
  0016e	c1 e0 04	 shl	 eax, 4
  00171	03 b0 04 00 00
	00		 add	 esi, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[eax+4]
$LN18@GiveReward:

; 3236 : 		}
; 3237 : 
; 3238 : 		this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  00177	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0017d	56		 push	 esi
  0017e	53		 push	 ebx
  0017f	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 3239 : 		this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iBC_EventScore_Fail[iBridgeIndex], 0, 0);

  00184	8b 9d e8 fe ff
	ff		 mov	 ebx, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  0018a	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	ff 34 9d 00 00
	00 00		 push	 DWORD PTR ?g_iBC_EventScore_Fail@@3QBHB[ebx*4]
  0019b	ff 37		 push	 DWORD PTR [edi]
  0019d	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3240 : 
; 3241 : 		LogAddTD("[Blood Castle] (%d) Quest Fail Rewarded (Account:%s, Name:%s, Score:%d, ExtEXP:%d, LeftTime:%d)",

  001a2	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  001a8	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  001ab	6a 00		 push	 0
  001ad	56		 push	 esi
  001ae	ff 34 9d 00 00
	00 00		 push	 DWORD PTR ?g_iBC_EventScore_Fail@@3QBHB[ebx*4]
  001b5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001bb	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001be	50		 push	 eax
  001bf	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001c2	50		 push	 eax
  001c3	52		 push	 edx
  001c4	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@HCBPNCII@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Fail?5R@
  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3242 : 			iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3243 : 			gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3244 : 			::g_iBC_EventScore_Fail[iBridgeIndex], iADD_EXP, 0);
; 3245 : 
; 3246 : 		GCS_BC_GIVE_REWARD pMsg;
; 3247 : 
; 3248 : 		pMsg.bWinner = false;
; 3249 : 		pMsg.btType = -1;
; 3250 : 		memcpy(pMsg.m_stBCCharScore[0].CharName, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, MAX_ACCOUNT_LEN);

  001cf	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  001d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001da	66 c7 85 ef fe
	ff ff 00 ff	 mov	 WORD PTR _pMsg$1[ebp+3], 65280 ; 0000ff00H

; 3251 : 		pMsg.m_stBCCharScore[0].iEXP = iADD_EXP;
; 3252 : 		pMsg.m_stBCCharScore[0].iZEN = 0;
; 3253 : 		pMsg.m_stBCCharScore[0].iSCORE = g_iBC_EventScore_Fail[iBridgeIndex];
; 3254 : 		PHeadSetB((LPBYTE)&pMsg.PHeader, 0x93, sizeof(GCS_BC_GIVE_REWARD) - (sizeof(ST_BC_SCORE) * (MAX_BLOOD_CASTLE_SUB_BRIDGE -1)) );

  001e3	6a 35		 push	 53			; 00000035H
  001e5	68 93 00 00 00	 push	 147			; 00000093H
  001ea	f3 0f 7e 44 01
	5d		 movq	 xmm0, QWORD PTR [ecx+eax+93]
  001f0	66 0f d6 85 f1
	fe ff ff	 movq	 QWORD PTR _pMsg$1[ebp+5], xmm0
  001f8	66 8b 44 01 65	 mov	 ax, WORD PTR [ecx+eax+101]
  001fd	66 89 85 f9 fe
	ff ff		 mov	 WORD PTR _pMsg$1[ebp+13], ax
  00204	8b 04 9d 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_EventScore_Fail@@3QBHB[ebx*4]
  0020b	89 85 fd fe ff
	ff		 mov	 DWORD PTR _pMsg$1[ebp+17], eax
  00211	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00217	50		 push	 eax
  00218	89 b5 01 ff ff
	ff		 mov	 DWORD PTR _pMsg$1[ebp+21], esi
  0021e	c7 85 05 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pMsg$1[ebp+25], 0
  00228	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3255 : 
; 3256 : 		if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex != -1 )

  0022d	8b 17		 mov	 edx, DWORD PTR [edi]
  0022f	83 c4 28	 add	 esp, 40			; 00000028H
  00232	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00237	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  0023d	80 bc 01 36 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4662], -1
  00245	74 50		 je	 SHORT $LN32@GiveReward
  00247	80 bc 01 37 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4663], -1
  0024f	74 46		 je	 SHORT $LN32@GiveReward

; 3257 : 		{
; 3258 : 			DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR*)&pMsg, pMsg.PHeader.uSize);			

  00251	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00258	50		 push	 eax
  00259	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0025f	50		 push	 eax
  00260	52		 push	 edx
  00261	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3259 : 
; 3260 : 			LogAddTD("[Blood Castle] (%d) Send User Quest Fail Message (Account:%s, Name:%s [State:%d], MapNumber:%d)",

  00266	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  0026c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00272	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  00279	50		 push	 eax
  0027a	ff 77 0c	 push	 DWORD PTR [edi+12]
  0027d	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00280	50		 push	 eax
  00281	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00284	50		 push	 eax
  00285	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00288	50		 push	 eax
  00289	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JIFFPAHP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Send?5User?5Qu@
  0028e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00294	83 c4 24	 add	 esp, 36			; 00000024H
$LN32@GiveReward:
  00297	8b d3		 mov	 edx, ebx
$LN2@GiveReward:

; 3194 : 				iBridgeIndex+1, gObj[iUserWhoGotUltimateWeapon].AccountID, gObj[iUserWhoGotUltimateWeapon].Name,
; 3195 : 				this->m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER);
; 3196 : 		}
; 3197 : 	}
; 3198 : 
; 3199 : 	for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  00299	83 c7 14	 add	 edi, 20			; 00000014H
  0029c	83 ad dc fe ff
	ff 01		 sub	 DWORD PTR tv1091[ebp], 1
  002a3	0f 85 17 fe ff
	ff		 jne	 $LL4@GiveReward
  002a9	5f		 pop	 edi
$LN3@GiveReward:

; 3261 : 				iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3262 : 				gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, 
; 3263 : 				this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState,
; 3264 : 				gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);
; 3265 : 		}	
; 3266 : 	}
; 3267 : }

  002aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ad	5e		 pop	 esi
  002ae	33 cd		 xor	 ecx, ebp
  002b0	5b		 pop	 ebx
  002b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b6	8b e5		 mov	 esp, ebp
  002b8	5d		 pop	 ebp
  002b9	c2 04 00	 ret	 4
?GiveReward_Fail@CBloodCastle@@QAEXH@Z ENDP		; CBloodCastle::GiveReward_Fail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?GiveReward_Win@CBloodCastle@@QAEXHH@Z
_TEXT	SEGMENT
tv2360 = -840						; size = 4
_iADD_PARTYPOINT$1$ = -836				; size = 4
_iALIVE_PARTYCOUNT$1$ = -832				; size = 4
_iLEFT_TIME$1$ = -828					; size = 4
_iREWARD_ZEN$1$ = -824					; size = 4
_iREWARD_EXP$1$ = -820					; size = 4
_iBridgeIndex$GSCopy$1$ = -816				; size = 4
_iREWARD_SCR$1$ = -812					; size = 4
_this$GSCopy$1$ = -808					; size = 4
_pNotice$1 = -804					; size = 272
_pMsg$2 = -532						; size = 269
_szNOTIFY_MSG$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iBridgeIndex$ = 12					; size = 4
?GiveReward_Win@CBloodCastle@@QAEXHH@Z PROC		; CBloodCastle::GiveReward_Win, COMDAT
; _this$ = ecx

; 2965 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 03 00
	00		 sub	 esp, 840		; 00000348H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00018	8b d9		 mov	 ebx, ecx
  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _iBridgeIndex$[ebp]

; 2966 : 	this->FixUsersPlayStateWin(iBridgeIndex);

  0001e	57		 push	 edi
  0001f	89 9d d8 fc ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx
  00025	89 bd d0 fc ff
	ff		 mov	 DWORD PTR _iBridgeIndex$GSCopy$1$[ebp], edi
  0002b	e8 00 00 00 00	 call	 ?FixUsersPlayStateWin@CBloodCastle@@QAEXH@Z ; CBloodCastle::FixUsersPlayStateWin

; 2967 : 	char szNOTIFY_MSG[256];
; 2968 : 	int iREWARD_EXP = 0;
; 2969 : 	int iREWARD_ZEN = 0;
; 2970 : 	int iREWARD_SCR = 0;
; 2971 : 	int iLEFT_TIME = this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000;
; 2972 : 	int iALIVE_PARTYCOUNT = this->GetWinnerPartyCompleteCount(iBridgeIndex);

  00030	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00036	69 c7 0c 02 00
	00		 imul	 eax, edi, 524
  0003c	57		 push	 edi
  0003d	c7 85 cc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _iREWARD_EXP$1$[ebp], 0
  00047	c7 85 c8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _iREWARD_ZEN$1$[ebp], 0
  00051	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _iREWARD_SCR$1$[ebp], 0
  0005b	03 d8		 add	 ebx, eax
  0005d	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00062	f7 ab 54 01 00
	00		 imul	 DWORD PTR [ebx+340]
  00068	c1 fa 06	 sar	 edx, 6
  0006b	8b c2		 mov	 eax, edx
  0006d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00070	03 c2		 add	 eax, edx
  00072	89 85 c4 fc ff
	ff		 mov	 DWORD PTR _iLEFT_TIME$1$[ebp], eax
  00078	e8 00 00 00 00	 call	 ?GetWinnerPartyCompleteCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompleteCount

; 2973 : 	int iADD_PARTYPOINT = this->GetWinnerPartyCompletePoint(iBridgeIndex);

  0007d	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00083	57		 push	 edi
  00084	89 85 c0 fc ff
	ff		 mov	 DWORD PTR _iALIVE_PARTYCOUNT$1$[ebp], eax
  0008a	e8 00 00 00 00	 call	 ?GetWinnerPartyCompletePoint@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetWinnerPartyCompletePoint
  0008f	8b c8		 mov	 ecx, eax

; 2974 : 
; 2975 : 	LogAddTD("[Blood Castle] (%d) Winner Party Point - Alive Party Member : %d, Alive Party Point : %d",

  00091	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00094	51		 push	 ecx
  00095	ff b5 c0 fc ff
	ff		 push	 DWORD PTR _iALIVE_PARTYCOUNT$1$[ebp]
  0009b	89 8d bc fc ff
	ff		 mov	 DWORD PTR _iADD_PARTYPOINT$1$[ebp], ecx
  000a1	50		 push	 eax
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@GOGDCKAK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Winner?5Party@
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ad	83 c4 10	 add	 esp, 16			; 00000010H

; 2976 : 		iBridgeIndex+1, iALIVE_PARTYCOUNT, iADD_PARTYPOINT);
; 2977 : 
; 2978 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  000b0	85 f6		 test	 esi, esi
  000b2	0f 88 ed 06 00
	00		 js	 $LN12@GiveReward
  000b8	33 c0		 xor	 eax, eax
  000ba	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  000c0	0f 9e c0	 setle	 al
  000c3	85 c0		 test	 eax, eax
  000c5	0f 84 da 06 00
	00		 je	 $LN12@GiveReward

; 2979 : 	{
; 2980 : 		return;
; 2981 : 	}
; 2982 : 
; 2983 : 	if ( BC_BRIDGE_RANGE(iBridgeIndex) == FALSE )

  000cb	85 ff		 test	 edi, edi
  000cd	0f 88 d2 06 00
	00		 js	 $LN12@GiveReward
  000d3	33 c0		 xor	 eax, eax
  000d5	83 ff 07	 cmp	 edi, 7
  000d8	0f 9e c0	 setle	 al
  000db	85 c0		 test	 eax, eax
  000dd	0f 84 c2 06 00
	00		 je	 $LN12@GiveReward

; 2984 : 	{
; 2985 : 		return;
; 2986 : 	}
; 2987 : 	
; 2988 : 	if ( this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED != false )

  000e3	80 bb 66 01 00
	00 00		 cmp	 BYTE PTR [ebx+358], 0
  000ea	0f 85 b5 06 00
	00		 jne	 $LN12@GiveReward

; 2989 : 	{
; 2990 : 		return;
; 2991 : 	}
; 2992 : 
; 2993 : 	if ( gObj[iIndex].Connected > PLAYER_LOGGED )

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f5	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  000fb	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  00100	7e 32		 jle	 SHORT $LN10@GiveReward

; 2994 : 	{
; 2995 : 		gObj[iIndex].Name[MAX_ACCOUNT_LEN] = 0;

  00102	c6 44 01 67 00	 mov	 BYTE PTR [ecx+eax+103], 0

; 2996 : 		wsprintf(szNOTIFY_MSG, lMsg.Get(MSGGET(4, 141)), gObj[iIndex].Name);

  00107	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010c	83 c0 5d	 add	 eax, 93			; 0000005dH
  0010f	03 c1		 add	 eax, ecx
  00111	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00116	50		 push	 eax
  00117	68 8d 04 00 00	 push	 1165			; 0000048dH
  0011c	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00121	50		 push	 eax
  00122	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szNOTIFY_MSG$[ebp]
  00128	50		 push	 eax
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0012f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2997 : 	}
; 2998 : 	else

  00132	eb 20		 jmp	 SHORT $LN11@GiveReward
$LN10@GiveReward:

; 2999 : 	{
; 3000 : 		wsprintf(szNOTIFY_MSG, lMsg.Get(MSGGET(4, 142)));

  00134	68 8e 04 00 00	 push	 1166			; 0000048eH
  00139	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0013e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00143	50		 push	 eax
  00144	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szNOTIFY_MSG$[ebp]
  0014a	50		 push	 eax
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00151	83 c4 08	 add	 esp, 8
$LN11@GiveReward:

; 3001 : 	}
; 3002 : 
; 3003 : 	if ( this->m_BridgeData[iBridgeIndex].m_iMISSION_SUCCESS != -1 )

  00154	83 bb 48 01 00
	00 ff		 cmp	 DWORD PTR [ebx+328], -1
  0015b	0f 84 44 06 00
	00		 je	 $LN12@GiveReward

; 3004 : 	{
; 3005 : 		int iTOTAL_EXP = this->GetAliveUserTotalEXP(iBridgeIndex);

  00161	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00167	57		 push	 edi
  00168	e8 00 00 00 00	 call	 ?GetAliveUserTotalEXP@CBloodCastle@@IAEHH@Z ; CBloodCastle::GetAliveUserTotalEXP

; 3006 : 		LogAddTD("[Blood Castle] (%d) Quest Complete - All Alive User's Total EXP:%d",

  0016d	50		 push	 eax
  0016e	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00171	50		 push	 eax
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@MHPNGBMF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0017d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00180	c7 85 b8 fc ff
	ff 0a 00 00 00	 mov	 DWORD PTR tv2360[ebp], 10 ; 0000000aH
  0018a	8d 73 1c	 lea	 esi, DWORD PTR [ebx+28]
  0018d	0f 1f 00	 npad	 3
$LL4@GiveReward:

; 3010 : 		{
; 3011 : 			if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == -1 )

  00190	8b 06		 mov	 eax, DWORD PTR [esi]
  00192	83 f8 ff	 cmp	 eax, -1
  00195	0f 84 f3 05 00
	00		 je	 $LN2@GiveReward

; 3012 : 			{
; 3013 : 				continue;
; 3014 : 			}
; 3015 : 
; 3016 : 			if ( gObj[ this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex ].Connected < PLAYER_PLAYING )

  0019b	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  001a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a6	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  001ab	0f 8c dd 05 00
	00		 jl	 $LN2@GiveReward

; 3017 : 			{
; 3018 : 				continue;
; 3019 : 			}
; 3020 : 
; 3021 : 			if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex == -1 || gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleSubIndex == -1 ||  gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_cBloodCastleIndex != iBridgeIndex )

  001b1	8a 94 01 36 12
	00 00		 mov	 dl, BYTE PTR [ecx+eax+4662]
  001b8	80 fa ff	 cmp	 dl, -1
  001bb	0f 84 cd 05 00
	00		 je	 $LN2@GiveReward
  001c1	80 bc 01 37 12
	00 00 ff	 cmp	 BYTE PTR [ecx+eax+4663], -1
  001c9	0f 84 bf 05 00
	00		 je	 $LN2@GiveReward
  001cf	0f be c2	 movsx	 eax, dl
  001d2	3b c7		 cmp	 eax, edi
  001d4	0f 85 b4 05 00
	00		 jne	 $LN2@GiveReward

; 3022 : 			{
; 3023 : 				continue;
; 3024 : 			}
; 3025 : 
; 3026 : 			PMSG_NOTICE pNotice;
; 3027 : 			TNotice::MakeNoticeMsg(&pNotice, 10, szNOTIFY_MSG);

  001da	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szNOTIFY_MSG$[ebp]
  001e0	50		 push	 eax
  001e1	8d 85 dc fc ff
	ff		 lea	 eax, DWORD PTR _pNotice$1[ebp]
  001e7	6a 0a		 push	 10			; 0000000aH
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 3028 : 			TNotice::SetNoticeProperty(&pNotice, 10, _ARGB(255, 128, 149, 196), 1, 0, 20);

  001ef	6a 14		 push	 20			; 00000014H
  001f1	6a 00		 push	 0
  001f3	6a 01		 push	 1
  001f5	68 80 95 c4 ff	 push	 -3893888		; ffc49580H
  001fa	8d 85 dc fc ff
	ff		 lea	 eax, DWORD PTR _pNotice$1[ebp]
  00200	6a 0a		 push	 10			; 0000000aH
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty

; 3029 : 			TNotice::SendNoticeToUser(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (TNotice*)&pNotice);

  00208	8d 85 dc fc ff
	ff		 lea	 eax, DWORD PTR _pNotice$1[ebp]
  0020e	50		 push	 eax
  0020f	ff 36		 push	 DWORD PTR [esi]
  00211	e8 00 00 00 00	 call	 ?SendNoticeToUser@TNotice@@SAXHPAX@Z ; TNotice::SendNoticeToUser

; 3030 : 
; 3031 : 			int iADD_EXP = 0;
; 3032 : 
; 3033 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Door_Index)

  00216	8b 16		 mov	 edx, DWORD PTR [esi]
  00218	83 c4 2c	 add	 esp, 44			; 0000002cH
  0021b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00220	33 ff		 xor	 edi, edi
  00222	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00228	8b 8c 01 0c 06
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+1548]
  0022f	83 f9 ff	 cmp	 ecx, -1
  00232	74 08		 je	 SHORT $LN20@GiveReward
  00234	3b 8b a0 01 00
	00		 cmp	 ecx, DWORD PTR [ebx+416]
  0023a	74 08		 je	 SHORT $LN19@GiveReward
$LN20@GiveReward:
  0023c	3b 93 a4 01 00
	00		 cmp	 edx, DWORD PTR [ebx+420]
  00242	75 13		 jne	 SHORT $LN17@GiveReward
$LN19@GiveReward:

; 3034 : 			{
; 3035 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0;

  00244	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  0024a	8b c2		 mov	 eax, edx
  0024c	c1 e0 04	 shl	 eax, 4
  0024f	8b b8 00 00 00
	00		 mov	 edi, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[eax]

; 3036 : 			}
; 3037 : 			else

  00255	eb 27		 jmp	 SHORT $LN22@GiveReward
$LN17@GiveReward:

; 3038 : 			{
; 3039 : 				if ( gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 )

  00257	83 f9 ff	 cmp	 ecx, -1
  0025a	74 1c		 je	 SHORT $LN58@GiveReward

; 3040 : 				{
; 3041 : 					if ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_bLiveWhenDoorBreak != false )

  0025c	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00260	74 16		 je	 SHORT $LN58@GiveReward

; 3042 : 					{
; 3043 : 						iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk0 / 2;

  00262	8b 85 d0 fc ff
	ff		 mov	 eax, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  00268	c1 e0 04	 shl	 eax, 4
  0026b	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[eax]
  00271	99		 cdq
  00272	2b c2		 sub	 eax, edx
  00274	8b f8		 mov	 edi, eax
  00276	d1 ff		 sar	 edi, 1
$LN58@GiveReward:
  00278	8b 95 d0 fc ff
	ff		 mov	 edx, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
$LN22@GiveReward:

; 3044 : 					}
; 3045 : 				}
; 3046 : 			}
; 3047 : 
; 3048 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Kill_Statue_Index)

  0027e	83 f9 ff	 cmp	 ecx, -1
  00281	74 08		 je	 SHORT $LN25@GiveReward
  00283	3b 8b c0 01 00
	00		 cmp	 ecx, DWORD PTR [ebx+448]
  00289	74 0a		 je	 SHORT $LN24@GiveReward
$LN25@GiveReward:
  0028b	8b 06		 mov	 eax, DWORD PTR [esi]
  0028d	3b 83 c4 01 00
	00		 cmp	 eax, DWORD PTR [ebx+452]
  00293	75 0d		 jne	 SHORT $LN23@GiveReward
$LN24@GiveReward:

; 3049 : 			{
; 3050 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk4;

  00295	8b c2		 mov	 eax, edx
  00297	c1 e0 04	 shl	 eax, 4
  0029a	03 b8 04 00 00
	00		 add	 edi, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[eax+4]
  002a0	8b 06		 mov	 eax, DWORD PTR [esi]
$LN23@GiveReward:

; 3051 : 			}
; 3052 : 
; 3053 : 			if ( (gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber != -1 && gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].PartyNumber == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Party) || this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex == this->m_BridgeData[iBridgeIndex].m_iExtraEXP_Win_Quest_Index)

  002a2	83 f9 ff	 cmp	 ecx, -1
  002a5	74 08		 je	 SHORT $LN28@GiveReward
  002a7	3b 8b e0 01 00
	00		 cmp	 ecx, DWORD PTR [ebx+480]
  002ad	74 08		 je	 SHORT $LN27@GiveReward
$LN28@GiveReward:
  002af	3b 83 e4 01 00
	00		 cmp	 eax, DWORD PTR [ebx+484]
  002b5	75 0b		 jne	 SHORT $LN26@GiveReward
$LN27@GiveReward:

; 3054 : 			{
; 3055 : 				iADD_EXP += ::g_iBC_Add_Exp[iBridgeIndex].unk8;

  002b7	8b c2		 mov	 eax, edx
  002b9	c1 e0 04	 shl	 eax, 4
  002bc	03 b8 08 00 00
	00		 add	 edi, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[eax+8]
$LN26@GiveReward:

; 3056 : 			}
; 3057 : 
; 3058 : 			switch ( this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iUserState  )

  002c2	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  002c5	83 f8 04	 cmp	 eax, 4
  002c8	0f 87 3c 04 00
	00		 ja	 $LN60@GiveReward
  002ce	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN63@GiveReward[eax*4]
$LN29@GiveReward:

; 3059 : 			{
; 3060 : 				case 0:
; 3061 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  002d5	8b ca		 mov	 ecx, edx
  002d7	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  002dc	f7 ab 54 01 00
	00		 imul	 DWORD PTR [ebx+340]
  002e2	c1 e1 04	 shl	 ecx, 4
  002e5	c1 fa 06	 sar	 edx, 6
  002e8	8b c2		 mov	 eax, edx
  002ea	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002ed	03 c2		 add	 eax, edx
  002ef	0f af 81 0c 00
	00 00		 imul	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[ecx+12]

; 3062 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  002f6	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  002fc	03 f8		 add	 edi, eax
  002fe	8b 06		 mov	 eax, DWORD PTR [esi]
  00300	57		 push	 edi
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 3063 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].SpecialCharacter);

  00307	8b bd d0 fc ff
	ff		 mov	 edi, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  0030d	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00313	89 85 cc fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$1$[ebp], eax
  00319	ff 34 fd 04 00
	00 00		 push	 DWORD PTR ?g_iQuestWinExpendZEN@@3QBUST_REWARD_ZEN@@B[edi*8+4]
  00320	ff 36		 push	 DWORD PTR [esi]
  00322	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 3064 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk0;
; 3065 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, 0);

  00327	6a 00		 push	 0
  00329	ff b5 c4 fc ff
	ff		 push	 DWORD PTR _iLEFT_TIME$1$[ebp]
  0032f	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  00332	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$1$[ebp], eax
  00338	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_EventScore@@3QBUST_BC_EVENT_SCORE@@B[ecx*4]
  0033f	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00345	50		 push	 eax
  00346	ff 36		 push	 DWORD PTR [esi]
  00348	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$1$[ebp], eax
  0034e	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3066 : 
; 3067 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)",

  00353	69 0e 40 27 00
	00		 imul	 ecx, DWORD PTR [esi], 10048
  00359	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0035f	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  00366	50		 push	 eax
  00367	ff b5 c4 fc ff
	ff		 push	 DWORD PTR _iLEFT_TIME$1$[ebp]
  0036d	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _iREWARD_SCR$1$[ebp]
  00373	ff b5 c8 fc ff
	ff		 push	 DWORD PTR _iREWARD_ZEN$1$[ebp]
  00379	ff b5 cc fc ff
	ff		 push	 DWORD PTR _iREWARD_EXP$1$[ebp]
  0037f	ff b1 38 12 00
	00		 push	 DWORD PTR [ecx+4664]
  00385	6a 00		 push	 0
$LN61@GiveReward:
  00387	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0038a	50		 push	 eax
  0038b	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0038e	50		 push	 eax
  0038f	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00392	50		 push	 eax
  00393	68 00 00 00 00	 push	 OFFSET ??_C@_0IN@OCADDENK@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Quest?5Comple@
  00398	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0039e	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3068 : 						iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3069 : 						gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3070 : 						0, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3071 : 						iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);
; 3072 : 					break;

  003a1	e9 6a 03 00 00	 jmp	 $LN5@GiveReward
$LN30@GiveReward:

; 3073 : 
; 3074 : 				case 1:
; 3075 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  003a6	8b ca		 mov	 ecx, edx
  003a8	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  003ad	f7 ab 54 01 00
	00		 imul	 DWORD PTR [ebx+340]
  003b3	c1 e1 04	 shl	 ecx, 4
  003b6	c1 fa 06	 sar	 edx, 6
  003b9	8b c2		 mov	 eax, edx
  003bb	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003be	03 c2		 add	 eax, edx
  003c0	0f af 81 0c 00
	00 00		 imul	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[ecx+12]

; 3076 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  003c7	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  003cd	03 f8		 add	 edi, eax
  003cf	8b 06		 mov	 eax, DWORD PTR [esi]
  003d1	57		 push	 edi
  003d2	50		 push	 eax
  003d3	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 3077 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].SpecialCharacter);

  003d8	8b bd d0 fc ff
	ff		 mov	 edi, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  003de	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  003e4	89 85 cc fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$1$[ebp], eax
  003ea	ff 34 fd 04 00
	00 00		 push	 DWORD PTR ?g_iQuestWinExpendZEN@@3QBUST_REWARD_ZEN@@B[edi*8+4]
  003f1	ff 36		 push	 DWORD PTR [esi]
  003f3	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 3078 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk4;
; 3079 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, 0);

  003f8	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  003fe	6a 00		 push	 0
  00400	ff b5 c4 fc ff
	ff		 push	 DWORD PTR _iLEFT_TIME$1$[ebp]
  00406	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$1$[ebp], eax
  0040c	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  0040f	8b 04 85 04 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_EventScore@@3QBUST_BC_EVENT_SCORE@@B[eax*4+4]
  00416	50		 push	 eax
  00417	ff 36		 push	 DWORD PTR [esi]
  00419	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$1$[ebp], eax
  0041f	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3080 : 
; 3081 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)",

  00424	69 0e 40 27 00
	00		 imul	 ecx, DWORD PTR [esi], 10048
  0042a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00430	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  00437	50		 push	 eax
  00438	ff b5 c4 fc ff
	ff		 push	 DWORD PTR _iLEFT_TIME$1$[ebp]
  0043e	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _iREWARD_SCR$1$[ebp]
  00444	ff b5 c8 fc ff
	ff		 push	 DWORD PTR _iREWARD_ZEN$1$[ebp]
  0044a	ff b5 cc fc ff
	ff		 push	 DWORD PTR _iREWARD_EXP$1$[ebp]
  00450	ff b1 38 12 00
	00		 push	 DWORD PTR [ecx+4664]
  00456	6a 01		 push	 1

; 3082 : 						iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3083 : 						gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3084 : 						1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3085 : 						iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);
; 3086 : 					break;

  00458	e9 2a ff ff ff	 jmp	 $LN61@GiveReward
$LN31@GiveReward:

; 3087 : 
; 3088 : 				case 2:
; 3089 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  0045d	8b ca		 mov	 ecx, edx
  0045f	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00464	f7 ab 54 01 00
	00		 imul	 DWORD PTR [ebx+340]
  0046a	c1 e1 04	 shl	 ecx, 4
  0046d	c1 fa 06	 sar	 edx, 6
  00470	8b c2		 mov	 eax, edx
  00472	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00475	03 c2		 add	 eax, edx
  00477	0f af 81 0c 00
	00 00		 imul	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[ecx+12]

; 3090 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  0047e	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00484	03 f8		 add	 edi, eax
  00486	8b 06		 mov	 eax, DWORD PTR [esi]
  00488	57		 push	 edi
  00489	50		 push	 eax
  0048a	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 3091 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  0048f	8b bd d0 fc ff
	ff		 mov	 edi, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  00495	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0049b	89 85 cc fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$1$[ebp], eax
  004a1	ff 34 fd 00 00
	00 00		 push	 DWORD PTR ?g_iQuestWinExpendZEN@@3QBUST_REWARD_ZEN@@B[edi*8]
  004a8	ff 36		 push	 DWORD PTR [esi]
  004aa	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 3092 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk8;
; 3093 : 					iREWARD_SCR += iADD_PARTYPOINT;
; 3094 : 
; 3095 : 					if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber ) != FALSE )

  004af	8b 16		 mov	 edx, DWORD PTR [esi]
  004b1	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$1$[ebp], eax
  004b7	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  004ba	8b 04 85 08 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_EventScore@@3QBUST_BC_EVENT_SCORE@@B[eax*4+8]
  004c1	03 85 bc fc ff
	ff		 add	 eax, DWORD PTR _iADD_PARTYPOINT$1$[ebp]
  004c7	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  004cd	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$1$[ebp], eax
  004d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004d8	8a 84 01 23 01
	00 00		 mov	 al, BYTE PTR [ecx+eax+291]
  004df	3c 34		 cmp	 al, 52			; 00000034H
  004e1	74 0f		 je	 SHORT $LN55@GiveReward
  004e3	3c 0b		 cmp	 al, 11			; 0000000bH
  004e5	72 17		 jb	 SHORT $LN32@GiveReward
  004e7	b1 11		 mov	 cl, 17			; 00000011H
  004e9	3a c8		 cmp	 cl, al
  004eb	1b c0		 sbb	 eax, eax
  004ed	83 c0 01	 add	 eax, 1
  004f0	74 0c		 je	 SHORT $LN32@GiveReward
$LN55@GiveReward:

; 3096 : 					{
; 3097 : 						this->DropReward(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex);

  004f2	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  004f8	52		 push	 edx
  004f9	e8 00 00 00 00	 call	 ?DropReward@CBloodCastle@@QAEXH@Z ; CBloodCastle::DropReward
$LN32@GiveReward:

; 3098 : 					}
; 3099 : 
; 3100 : 
; 3101 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  004fe	ff b5 c0 fc ff
	ff		 push	 DWORD PTR _iALIVE_PARTYCOUNT$1$[ebp]
  00504	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0050a	ff b5 c4 fc ff
	ff		 push	 DWORD PTR _iLEFT_TIME$1$[ebp]
  00510	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _iREWARD_SCR$1$[ebp]
  00516	ff 36		 push	 DWORD PTR [esi]
  00518	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3102 : 
; 3103 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)",

  0051d	69 0e 40 27 00
	00		 imul	 ecx, DWORD PTR [esi], 10048
  00523	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00529	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  00530	50		 push	 eax
  00531	ff b5 c4 fc ff
	ff		 push	 DWORD PTR _iLEFT_TIME$1$[ebp]
  00537	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _iREWARD_SCR$1$[ebp]
  0053d	ff b5 c8 fc ff
	ff		 push	 DWORD PTR _iREWARD_ZEN$1$[ebp]
  00543	ff b5 cc fc ff
	ff		 push	 DWORD PTR _iREWARD_EXP$1$[ebp]
  00549	ff b1 38 12 00
	00		 push	 DWORD PTR [ecx+4664]
  0054f	6a 02		 push	 2

; 3104 : 						iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3105 : 						gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3106 : 						2, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3107 : 						iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);
; 3108 : 					break;

  00551	e9 31 fe ff ff	 jmp	 $LN61@GiveReward
$LN33@GiveReward:

; 3109 : 
; 3110 : 				case 3:
; 3111 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  00556	8b ca		 mov	 ecx, edx
  00558	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0055d	f7 ab 54 01 00
	00		 imul	 DWORD PTR [ebx+340]
  00563	c1 e1 04	 shl	 ecx, 4
  00566	c1 fa 06	 sar	 edx, 6
  00569	8b c2		 mov	 eax, edx
  0056b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0056e	03 c2		 add	 eax, edx
  00570	0f af 81 0c 00
	00 00		 imul	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[ecx+12]

; 3112 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  00577	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0057d	03 f8		 add	 edi, eax
  0057f	8b 06		 mov	 eax, DWORD PTR [esi]
  00581	57		 push	 edi
  00582	50		 push	 eax
  00583	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 3113 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  00588	8b bd d0 fc ff
	ff		 mov	 edi, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  0058e	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00594	89 85 cc fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$1$[ebp], eax
  0059a	ff 34 fd 00 00
	00 00		 push	 DWORD PTR ?g_iQuestWinExpendZEN@@3QBUST_REWARD_ZEN@@B[edi*8]
  005a1	ff 36		 push	 DWORD PTR [esi]
  005a3	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 3114 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unkC;
; 3115 : 					iREWARD_SCR += iADD_PARTYPOINT;
; 3116 : 
; 3117 : 					if ( BC_MAP_RANGE(gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber ) != FALSE )

  005a8	8b 16		 mov	 edx, DWORD PTR [esi]
  005aa	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$1$[ebp], eax
  005b0	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  005b3	8b 04 85 0c 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_EventScore@@3QBUST_BC_EVENT_SCORE@@B[eax*4+12]
  005ba	03 85 bc fc ff
	ff		 add	 eax, DWORD PTR _iADD_PARTYPOINT$1$[ebp]
  005c0	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  005c6	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$1$[ebp], eax
  005cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005d1	8a 84 01 23 01
	00 00		 mov	 al, BYTE PTR [ecx+eax+291]
  005d8	3c 34		 cmp	 al, 52			; 00000034H
  005da	74 0f		 je	 SHORT $LN56@GiveReward
  005dc	3c 0b		 cmp	 al, 11			; 0000000bH
  005de	72 17		 jb	 SHORT $LN34@GiveReward
  005e0	b1 11		 mov	 cl, 17			; 00000011H
  005e2	3a c8		 cmp	 cl, al
  005e4	1b c0		 sbb	 eax, eax
  005e6	83 c0 01	 add	 eax, 1
  005e9	74 0c		 je	 SHORT $LN34@GiveReward
$LN56@GiveReward:

; 3118 : 					{
; 3119 : 						this->DropReward(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex);

  005eb	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  005f1	52		 push	 edx
  005f2	e8 00 00 00 00	 call	 ?DropReward@CBloodCastle@@QAEXH@Z ; CBloodCastle::DropReward
$LN34@GiveReward:

; 3120 : 					}
; 3121 : 
; 3122 : 
; 3123 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  005f7	ff b5 c0 fc ff
	ff		 push	 DWORD PTR _iALIVE_PARTYCOUNT$1$[ebp]
  005fd	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00603	ff b5 c4 fc ff
	ff		 push	 DWORD PTR _iLEFT_TIME$1$[ebp]
  00609	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _iREWARD_SCR$1$[ebp]
  0060f	ff 36		 push	 DWORD PTR [esi]
  00611	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3124 : 
; 3125 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)",

  00616	69 0e 40 27 00
	00		 imul	 ecx, DWORD PTR [esi], 10048
  0061c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00622	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  00629	50		 push	 eax
  0062a	ff b5 c4 fc ff
	ff		 push	 DWORD PTR _iLEFT_TIME$1$[ebp]
  00630	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _iREWARD_SCR$1$[ebp]
  00636	ff b5 c8 fc ff
	ff		 push	 DWORD PTR _iREWARD_ZEN$1$[ebp]
  0063c	ff b5 cc fc ff
	ff		 push	 DWORD PTR _iREWARD_EXP$1$[ebp]
  00642	ff b1 38 12 00
	00		 push	 DWORD PTR [ecx+4664]
  00648	6a 03		 push	 3

; 3126 : 						iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3127 : 						gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3128 : 						3, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3129 : 						iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);
; 3130 : 					break;

  0064a	e9 38 fd ff ff	 jmp	 $LN61@GiveReward
$LN35@GiveReward:

; 3131 : 
; 3132 : 				case 4:
; 3133 : 					iADD_EXP += this->m_BridgeData[iBridgeIndex].m_iBC_REMAIN_MSEC / 1000 * ::g_iBC_Add_Exp[iBridgeIndex].unkC;

  0064f	8b ca		 mov	 ecx, edx
  00651	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00656	f7 ab 54 01 00
	00		 imul	 DWORD PTR [ebx+340]
  0065c	c1 e1 04	 shl	 ecx, 4
  0065f	c1 fa 06	 sar	 edx, 6
  00662	8b c2		 mov	 eax, edx
  00664	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00667	03 c2		 add	 eax, edx
  00669	0f af 81 0c 00
	00 00		 imul	 eax, DWORD PTR ?g_iBC_Add_Exp@@3QBUST_BC_ADD_EXP@@B[ecx+12]

; 3134 : 					iREWARD_EXP = this->CalcSendRewardEXP(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iADD_EXP);

  00670	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00676	03 f8		 add	 edi, eax
  00678	8b 06		 mov	 eax, DWORD PTR [esi]
  0067a	57		 push	 edi
  0067b	50		 push	 eax
  0067c	e8 00 00 00 00	 call	 ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardEXP

; 3135 : 					iREWARD_ZEN = this->CalcSendRewardZEN(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ::g_iQuestWinExpendZEN[iBridgeIndex].NormalCharacter);

  00681	8b bd d0 fc ff
	ff		 mov	 edi, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
  00687	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0068d	89 85 cc fc ff
	ff		 mov	 DWORD PTR _iREWARD_EXP$1$[ebp], eax
  00693	ff 34 fd 00 00
	00 00		 push	 DWORD PTR ?g_iQuestWinExpendZEN@@3QBUST_REWARD_ZEN@@B[edi*8]
  0069a	ff 36		 push	 DWORD PTR [esi]
  0069c	e8 00 00 00 00	 call	 ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CalcSendRewardZEN

; 3136 : 					iREWARD_SCR = ::g_iBC_EventScore[iBridgeIndex].unk10;
; 3137 : 					this->SendRewardScore(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, iREWARD_SCR, iLEFT_TIME, iALIVE_PARTYCOUNT);

  006a1	ff b5 c0 fc ff
	ff		 push	 DWORD PTR _iALIVE_PARTYCOUNT$1$[ebp]
  006a7	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  006ad	ff b5 c4 fc ff
	ff		 push	 DWORD PTR _iLEFT_TIME$1$[ebp]
  006b3	89 85 c8 fc ff
	ff		 mov	 DWORD PTR _iREWARD_ZEN$1$[ebp], eax
  006b9	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  006bc	8b 04 85 10 00
	00 00		 mov	 eax, DWORD PTR ?g_iBC_EventScore@@3QBUST_BC_EVENT_SCORE@@B[eax*4+16]
  006c3	50		 push	 eax
  006c4	ff 36		 push	 DWORD PTR [esi]
  006c6	89 85 d4 fc ff
	ff		 mov	 DWORD PTR _iREWARD_SCR$1$[ebp], eax
  006cc	e8 00 00 00 00	 call	 ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ; CBloodCastle::SendRewardScore

; 3138 : 
; 3139 : 					LogAddTD("[Blood Castle] (%d) Quest Complete Rewarded (Account:%s, Name:%s [State:%d], Exp:%d, ExtExp:%d, Zen:%d, Score:%d, LeftTime:%d, MapNumber:%d)",

  006d1	69 0e 40 27 00
	00		 imul	 ecx, DWORD PTR [esi], 10048
  006d7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006dd	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  006e4	50		 push	 eax
  006e5	ff b5 c4 fc ff
	ff		 push	 DWORD PTR _iLEFT_TIME$1$[ebp]
  006eb	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _iREWARD_SCR$1$[ebp]
  006f1	ff b5 c8 fc ff
	ff		 push	 DWORD PTR _iREWARD_ZEN$1$[ebp]
  006f7	ff b5 cc fc ff
	ff		 push	 DWORD PTR _iREWARD_EXP$1$[ebp]
  006fd	ff b1 38 12 00
	00		 push	 DWORD PTR [ecx+4664]
  00703	6a 04		 push	 4
  00705	e9 7d fc ff ff	 jmp	 $LN61@GiveReward
$LN60@GiveReward:
  0070a	8b bd d0 fc ff
	ff		 mov	 edi, DWORD PTR _iBridgeIndex$GSCopy$1$[ebp]
$LN5@GiveReward:

; 3140 : 						iBridgeIndex+1, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].AccountID,
; 3141 : 						gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name,
; 3142 : 						4, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3143 : 						iREWARD_EXP, iREWARD_ZEN, iREWARD_SCR, iLEFT_TIME, gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].MapNumber);
; 3144 : 					break;
; 3145 : 			}
; 3146 : 
; 3147 : 			GCS_BC_GIVE_REWARD pMsg;
; 3148 : 
; 3149 : 			pMsg.bWinner = true;
; 3150 : 			pMsg.btType = -1;
; 3151 : 			memcpy(pMsg.m_stBCCharScore[0].CharName , gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].Name, MAX_ACCOUNT_LEN);

  00710	69 0e 40 27 00
	00		 imul	 ecx, DWORD PTR [esi], 10048
  00716	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0071b	66 c7 85 ef fd
	ff ff 01 ff	 mov	 WORD PTR _pMsg$2[ebp+3], 65281 ; 0000ff01H

; 3152 : 			pMsg.m_stBCCharScore[0].iEXP = iREWARD_EXP;
; 3153 : 			pMsg.m_stBCCharScore[0].iZEN = iREWARD_ZEN;
; 3154 : 			pMsg.m_stBCCharScore[0].iSCORE = iREWARD_SCR;
; 3155 : 			PHeadSetB((LPBYTE)&pMsg.PHeader, 0x93, sizeof(GCS_BC_GIVE_REWARD) - (sizeof(ST_BC_SCORE) * (MAX_BLOOD_CASTLE_SUB_BRIDGE -1)) );

  00724	6a 35		 push	 53			; 00000035H
  00726	68 93 00 00 00	 push	 147			; 00000093H
  0072b	f3 0f 7e 44 01
	5d		 movq	 xmm0, QWORD PTR [ecx+eax+93]
  00731	66 0f d6 85 f1
	fd ff ff	 movq	 QWORD PTR _pMsg$2[ebp+5], xmm0
  00739	66 8b 44 01 65	 mov	 ax, WORD PTR [ecx+eax+101]
  0073e	66 89 85 f9 fd
	ff ff		 mov	 WORD PTR _pMsg$2[ebp+13], ax
  00745	8b 85 cc fc ff
	ff		 mov	 eax, DWORD PTR _iREWARD_EXP$1$[ebp]
  0074b	89 85 01 fe ff
	ff		 mov	 DWORD PTR _pMsg$2[ebp+21], eax
  00751	8b 85 c8 fc ff
	ff		 mov	 eax, DWORD PTR _iREWARD_ZEN$1$[ebp]
  00757	89 85 05 fe ff
	ff		 mov	 DWORD PTR _pMsg$2[ebp+25], eax
  0075d	8b 85 d4 fc ff
	ff		 mov	 eax, DWORD PTR _iREWARD_SCR$1$[ebp]
  00763	89 85 fd fd ff
	ff		 mov	 DWORD PTR _pMsg$2[ebp+17], eax
  00769	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$2[ebp]
  0076f	50		 push	 eax
  00770	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3156 : 
; 3157 : 			DataSend(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, (UCHAR*)&pMsg, pMsg.PHeader.uSize);

  00775	0f b6 85 ed fd
	ff ff		 movzx	 eax, BYTE PTR _pMsg$2[ebp+1]
  0077c	50		 push	 eax
  0077d	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$2[ebp]
  00783	50		 push	 eax
  00784	ff 36		 push	 DWORD PTR [esi]
  00786	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0078b	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@GiveReward:

; 3007 : 			iBridgeIndex+1, iTOTAL_EXP);
; 3008 : 
; 3009 : 		for ( int i=0;i<MAX_BLOOD_CASTLE_SUB_BRIDGE;i++)

  0078e	83 c6 14	 add	 esi, 20			; 00000014H
  00791	83 ad b8 fc ff
	ff 01		 sub	 DWORD PTR tv2360[ebp], 1
  00798	0f 85 f2 f9 ff
	ff		 jne	 $LL4@GiveReward

; 3158 : 
; 3159 : #ifdef POINTEX
; 3160 : 			g_ShopPointEx.AddEventBonus(this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex, ShopPointExEvent::BC);
; 3161 : #endif
; 3162 : 
; 3163 : #if( __4GAMERS__ == 1 )	
; 3164 : 			g_Achievements.GD_UpdateEventDataBC(&gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex], 
; 3165 : 				gObj[this->m_BridgeData[iBridgeIndex].m_UserData[i].m_iIndex].m_iBloodCastleEXP,
; 3166 : 				iREWARD_EXP, iREWARD_SCR);
; 3167 : #endif
; 3168 : 		}
; 3169 : 
; 3170 : 		this->m_BridgeData[iBridgeIndex].m_bBC_REWARDED = true;

  0079e	c6 83 66 01 00
	00 01		 mov	 BYTE PTR [ebx+358], 1
$LN12@GiveReward:

; 3171 : 	}
; 3172 : }

  007a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007a8	5f		 pop	 edi
  007a9	5e		 pop	 esi
  007aa	33 cd		 xor	 ecx, ebp
  007ac	5b		 pop	 ebx
  007ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007b2	8b e5		 mov	 esp, ebp
  007b4	5d		 pop	 ebp
  007b5	c2 08 00	 ret	 8
$LN63@GiveReward:
  007b8	00 00 00 00	 DD	 $LN29@GiveReward
  007bc	00 00 00 00	 DD	 $LN30@GiveReward
  007c0	00 00 00 00	 DD	 $LN31@GiveReward
  007c4	00 00 00 00	 DD	 $LN33@GiveReward
  007c8	00 00 00 00	 DD	 $LN35@GiveReward
?GiveReward_Win@CBloodCastle@@QAEXHH@Z ENDP		; CBloodCastle::GiveReward_Win
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?SendRewardScore@CBloodCastle@@QAEXHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iSCORE$ = 12						; size = 4
_iLeftTime$ = 16					; size = 4
_iAlivePartyCount$ = 20					; size = 4
?SendRewardScore@CBloodCastle@@QAEXHHHH@Z PROC		; CBloodCastle::SendRewardScore, COMDAT
; _this$ = ecx

; 3433 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]

; 3434 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00013	85 c9		 test	 ecx, ecx
  00015	0f 88 ec 00 00
	00		 js	 $LN5@SendReward
  0001b	33 c0		 xor	 eax, eax
  0001d	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00023	0f 9e c0	 setle	 al
  00026	85 c0		 test	 eax, eax
  00028	0f 84 d9 00 00
	00		 je	 $LN5@SendReward

; 3435 : 	{
; 3436 : 		return;
; 3437 : 	}
; 3438 : 
; 3439 : 	PMSG_ANS_BLOODCASTLESCORE_5TH pMsg;
; 3440 : 
; 3441 : 	pMsg.h.c = 0xC1;
; 3442 : 	pMsg.h.headcode = 0x0D;
; 3443 : 	pMsg.h.size = sizeof(pMsg);
; 3444 : 	pMsg.Score = iSCORE;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _iSCORE$[ebp]
  00031	b2 30		 mov	 dl, 48			; 00000030H

; 3445 : 	pMsg.BridgeNum = gObj[iIndex].m_cBloodCastleIndex;

  00033	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  00039	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+28], eax
  0003c	66 c7 45 cc c1
	30		 mov	 WORD PTR _pMsg$[ebp], 12481 ; 000030c1H
  00042	c6 45 ce 0d	 mov	 BYTE PTR _pMsg$[ebp+2], 13 ; 0000000dH
  00046	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3446 : 	pMsg.Class = gObj[iIndex].Class;
; 3447 : 	pMsg.ServerCode = gGameServerCode;
; 3448 : 	pMsg.iLeftTime = iLeftTime;
; 3449 : 	memcpy(pMsg.AccountID, gObj[iIndex].AccountID, MAX_ACCOUNT_LEN);
; 3450 : 	memcpy(pMsg.GameID, gObj[iIndex].Name, MAX_ACCOUNT_LEN);
; 3451 : 	pMsg.iAlivePartyCount = iAlivePartyCount;
; 3452 : 
; 3453 : 	if( ::IsDevilSquareEventConnected == FALSE )

  0004c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 0 ; IsDevilSquareEventConnected
  00053	0f be 81 36 12
	00 00		 movsx	 eax, BYTE PTR [ecx+4662]
  0005a	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+36], eax
  0005d	0f b7 81 90 00
	00 00		 movzx	 eax, WORD PTR [ecx+144]
  00064	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+32], eax
  00067	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  0006e	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  00071	8b 45 10	 mov	 eax, DWORD PTR _iLeftTime$[ebp]
  00074	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+40], eax
  00077	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  0007c	66 0f d6 45 cf	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  00081	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  00085	66 89 45 d7	 mov	 WORD PTR _pMsg$[ebp+11], ax
  00089	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  0008e	66 0f d6 45 d9	 movq	 QWORD PTR _pMsg$[ebp+13], xmm0
  00093	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]
  00097	66 89 45 e1	 mov	 WORD PTR _pMsg$[ebp+21], ax
  0009b	8b 45 14	 mov	 eax, DWORD PTR _iAlivePartyCount$[ebp]
  0009e	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+44], eax
  000a1	75 52		 jne	 SHORT $LN9@SendReward

; 3454 : 	{
; 3455 : 		wsRServerCli.Close();

  000a3	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000a8	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 3456 : 		wsRServerCli.CreateSocket(ghWnd);

  000ad	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  000b3	b9 04 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A+4
  000b8	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket

; 3457 : 
; 3458 : 		if ( GMRankingServerConnect(RankingServerIP, WM_GM_RANKING_CLIENT_MSG_PROC) == FALSE )

  000bd	68 0c 04 00 00	 push	 1036			; 0000040cH
  000c2	68 00 00 00 00	 push	 OFFSET ?RankingServerIP@@3PADA ; RankingServerIP
  000c7	e8 00 00 00 00	 call	 ?GMRankingServerConnect@@YAHPADK@Z ; GMRankingServerConnect
  000cc	83 c4 08	 add	 esp, 8
  000cf	85 c0		 test	 eax, eax
  000d1	75 15		 jne	 SHORT $LN4@SendReward

; 3459 : 		{
; 3460 : 			::IsDevilSquareEventConnected = FALSE;

  000d3	a3 00 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, eax ; IsDevilSquareEventConnected

; 3472 : 	}
; 3473 : }

  000d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 10 00	 ret	 16			; 00000010H
$LN4@SendReward:

; 3461 : //			LogAddTD("Can not connect Ranking Server");
; 3462 : 
; 3463 : 			return;
; 3464 : 		}
; 3465 : 
; 3466 : 		::IsDevilSquareEventConnected = TRUE;

  000e8	8a 55 cd	 mov	 dl, BYTE PTR _pMsg$[ebp+1]
  000eb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?IsDevilSquareEventConnected@@3HA, 1 ; IsDevilSquareEventConnected
$LN9@SendReward:

; 3467 : 	}
; 3468 : 
; 3469 : 	if ( ::IsDevilSquareEventConnected != FALSE )
; 3470 : 	{
; 3471 : 		wsRServerCli.DataSend((char *)&pMsg, pMsg.h.size);

  000f5	0f b6 c2	 movzx	 eax, dl
  000f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsRServerCli@@3VwsJoinServerCli@@A ; wsRServerCli
  000fd	50		 push	 eax
  000fe	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend
$LN5@SendReward:

; 3472 : 	}
; 3473 : }

  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	33 cd		 xor	 ecx, ebp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c2 10 00	 ret	 16			; 00000010H
?SendRewardScore@CBloodCastle@@QAEXHHHH@Z ENDP		; CBloodCastle::SendRewardScore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?DropReward@CBloodCastle@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?DropReward@CBloodCastle@@QAEXH@Z PROC			; CBloodCastle::DropReward, COMDAT
; _this$ = ecx

; 3361 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3362 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00004	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 88 ac 01 00
	00		 js	 $LN4@DropReward
  0000f	33 c0		 xor	 eax, eax
  00011	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00017	0f 9e c0	 setle	 al
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 99 01 00
	00		 je	 $LN4@DropReward

; 3363 : 	{
; 3364 : 		return;
; 3365 : 	}
; 3366 : 
; 3367 : 	int iMaxHitUser = iIndex;
; 3368 : 	int DropIndex = -1;
; 3369 : 
; 3370 : 	switch( gObj[iIndex].MapNumber )

  00022	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00028	83 ca ff	 or	 edx, -1
  0002b	57		 push	 edi
  0002c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00032	0f b6 b9 23 01
	00 00		 movzx	 edi, BYTE PTR [ecx+291]
  00039	83 c7 f5	 add	 edi, -11		; fffffff5H
  0003c	83 ff 29	 cmp	 edi, 41			; 00000029H
  0003f	0f 87 75 01 00
	00		 ja	 $LN28@DropReward
  00045	0f b6 87 00 00
	00 00		 movzx	 eax, BYTE PTR $LN26@DropReward[edi]
  0004c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN32@DropReward[eax*4]
$LN7@DropReward:

; 3371 : 	{
; 3372 : 	case 11:	DropIndex = 238;	break;

  00053	ba ee 00 00 00	 mov	 edx, 238		; 000000eeH
  00058	eb 2f		 jmp	 SHORT $LN2@DropReward
$LN8@DropReward:

; 3373 : 	case 12:	DropIndex = 239;	break;

  0005a	ba ef 00 00 00	 mov	 edx, 239		; 000000efH
  0005f	eb 28		 jmp	 SHORT $LN2@DropReward
$LN9@DropReward:

; 3374 : 	case 13:	DropIndex = 240;	break;

  00061	ba f0 00 00 00	 mov	 edx, 240		; 000000f0H
  00066	eb 21		 jmp	 SHORT $LN2@DropReward
$LN10@DropReward:

; 3375 : 	case 14:	DropIndex = 241;	break;

  00068	ba f1 00 00 00	 mov	 edx, 241		; 000000f1H
  0006d	eb 1a		 jmp	 SHORT $LN2@DropReward
$LN11@DropReward:

; 3376 : 	case 15:	DropIndex = 242;	break;

  0006f	ba f2 00 00 00	 mov	 edx, 242		; 000000f2H
  00074	eb 13		 jmp	 SHORT $LN2@DropReward
$LN12@DropReward:

; 3377 : 	case 16:	DropIndex = 243;	break;

  00076	ba f3 00 00 00	 mov	 edx, 243		; 000000f3H
  0007b	eb 0c		 jmp	 SHORT $LN2@DropReward
$LN13@DropReward:

; 3378 : 	case 17:	DropIndex = 244;	break;

  0007d	ba f4 00 00 00	 mov	 edx, 244		; 000000f4H
  00082	eb 05		 jmp	 SHORT $LN2@DropReward
$LN14@DropReward:

; 3379 : 	case 52:	DropIndex = 245;	break;

  00084	ba f5 00 00 00	 mov	 edx, 245		; 000000f5H
$LN2@DropReward:

; 3380 : 	}
; 3381 : 
; 3382 : 	switch( gObj[iIndex].MapNumber )

  00089	83 ff 29	 cmp	 edi, 41			; 00000029H
  0008c	0f 87 28 01 00
	00		 ja	 $LN28@DropReward
  00092	0f b6 87 00 00
	00 00		 movzx	 eax, BYTE PTR $LN27@DropReward[edi]
  00099	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN33@DropReward[eax*4]
$LN15@DropReward:

; 3383 : 	{
; 3384 : 	case 11:
; 3385 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle1, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  000a0	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  000a7	50		 push	 eax
  000a8	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]

; 3404 : 		break;
; 3405 : 	case 52:	
; 3406 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle8, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  000af	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  000b4	50		 push	 eax
  000b5	52		 push	 edx
  000b6	56		 push	 esi
  000b7	6a 01		 push	 1
  000b9	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi

; 3407 : 		break;
; 3408 : 	}
; 3409 : }

  000c0	5d		 pop	 ebp
  000c1	c2 04 00	 ret	 4
$LN16@DropReward:

; 3386 : 		break;
; 3387 : 	case 12:	
; 3388 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle2, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  000c4	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  000cb	50		 push	 eax
  000cc	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]

; 3404 : 		break;
; 3405 : 	case 52:	
; 3406 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle8, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  000d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  000d8	50		 push	 eax
  000d9	52		 push	 edx
  000da	56		 push	 esi
  000db	6a 02		 push	 2
  000dd	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi

; 3407 : 		break;
; 3408 : 	}
; 3409 : }

  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
$LN17@DropReward:

; 3389 : 		break;
; 3390 : 	case 13:	
; 3391 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle3, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  000e8	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  000ef	50		 push	 eax
  000f0	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]

; 3404 : 		break;
; 3405 : 	case 52:	
; 3406 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle8, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  000f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  000fc	50		 push	 eax
  000fd	52		 push	 edx
  000fe	56		 push	 esi
  000ff	6a 03		 push	 3
  00101	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi

; 3407 : 		break;
; 3408 : 	}
; 3409 : }

  00108	5d		 pop	 ebp
  00109	c2 04 00	 ret	 4
$LN18@DropReward:

; 3392 : 		break;
; 3393 : 	case 14:	
; 3394 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle4, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  0010c	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  00113	50		 push	 eax
  00114	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]

; 3404 : 		break;
; 3405 : 	case 52:	
; 3406 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle8, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  0011b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  00120	50		 push	 eax
  00121	52		 push	 edx
  00122	56		 push	 esi
  00123	6a 04		 push	 4
  00125	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi

; 3407 : 		break;
; 3408 : 	}
; 3409 : }

  0012c	5d		 pop	 ebp
  0012d	c2 04 00	 ret	 4
$LN19@DropReward:

; 3395 : 		break;
; 3396 : 	case 15:	
; 3397 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle5, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  00130	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  00137	50		 push	 eax
  00138	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]

; 3404 : 		break;
; 3405 : 	case 52:	
; 3406 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle8, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  0013f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  00144	50		 push	 eax
  00145	52		 push	 edx
  00146	56		 push	 esi
  00147	6a 05		 push	 5
  00149	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial
  0014e	5f		 pop	 edi
  0014f	5e		 pop	 esi

; 3407 : 		break;
; 3408 : 	}
; 3409 : }

  00150	5d		 pop	 ebp
  00151	c2 04 00	 ret	 4
$LN20@DropReward:

; 3398 : 		break;
; 3399 : 	case 16:	
; 3400 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle6, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  00154	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  0015b	50		 push	 eax
  0015c	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]

; 3404 : 		break;
; 3405 : 	case 52:	
; 3406 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle8, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  00163	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  00168	50		 push	 eax
  00169	52		 push	 edx
  0016a	56		 push	 esi
  0016b	6a 06		 push	 6
  0016d	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial
  00172	5f		 pop	 edi
  00173	5e		 pop	 esi

; 3407 : 		break;
; 3408 : 	}
; 3409 : }

  00174	5d		 pop	 ebp
  00175	c2 04 00	 ret	 4
$LN21@DropReward:

; 3401 : 		break;
; 3402 : 	case 17:	
; 3403 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle7, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  00178	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  0017f	50		 push	 eax
  00180	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]

; 3404 : 		break;
; 3405 : 	case 52:	
; 3406 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle8, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  00187	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  0018c	50		 push	 eax
  0018d	52		 push	 edx
  0018e	56		 push	 esi
  0018f	6a 07		 push	 7
  00191	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial
  00196	5f		 pop	 edi
  00197	5e		 pop	 esi

; 3407 : 		break;
; 3408 : 	}
; 3409 : }

  00198	5d		 pop	 ebp
  00199	c2 04 00	 ret	 4
$LN22@DropReward:

; 3404 : 		break;
; 3405 : 	case 52:	
; 3406 : 		g_EventItemBagManager.OpenSpecial(EventBagSpecial::BloodCastle8, iIndex, DropIndex, gObj[iIndex].X, gObj[iIndex].Y);

  0019c	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  001a3	50		 push	 eax
  001a4	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  001ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  001b0	50		 push	 eax
  001b1	52		 push	 edx
  001b2	56		 push	 esi
  001b3	6a 08		 push	 8
  001b5	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial
$LN28@DropReward:
  001ba	5f		 pop	 edi
$LN4@DropReward:
  001bb	5e		 pop	 esi

; 3407 : 		break;
; 3408 : 	}
; 3409 : }

  001bc	5d		 pop	 ebp
  001bd	c2 04 00	 ret	 4
$LN32@DropReward:
  001c0	00 00 00 00	 DD	 $LN7@DropReward
  001c4	00 00 00 00	 DD	 $LN8@DropReward
  001c8	00 00 00 00	 DD	 $LN9@DropReward
  001cc	00 00 00 00	 DD	 $LN10@DropReward
  001d0	00 00 00 00	 DD	 $LN11@DropReward
  001d4	00 00 00 00	 DD	 $LN12@DropReward
  001d8	00 00 00 00	 DD	 $LN13@DropReward
  001dc	00 00 00 00	 DD	 $LN14@DropReward
  001e0	00 00 00 00	 DD	 $LN2@DropReward
$LN26@DropReward:
  001e4	00		 DB	 0
  001e5	01		 DB	 1
  001e6	02		 DB	 2
  001e7	03		 DB	 3
  001e8	04		 DB	 4
  001e9	05		 DB	 5
  001ea	06		 DB	 6
  001eb	08		 DB	 8
  001ec	08		 DB	 8
  001ed	08		 DB	 8
  001ee	08		 DB	 8
  001ef	08		 DB	 8
  001f0	08		 DB	 8
  001f1	08		 DB	 8
  001f2	08		 DB	 8
  001f3	08		 DB	 8
  001f4	08		 DB	 8
  001f5	08		 DB	 8
  001f6	08		 DB	 8
  001f7	08		 DB	 8
  001f8	08		 DB	 8
  001f9	08		 DB	 8
  001fa	08		 DB	 8
  001fb	08		 DB	 8
  001fc	08		 DB	 8
  001fd	08		 DB	 8
  001fe	08		 DB	 8
  001ff	08		 DB	 8
  00200	08		 DB	 8
  00201	08		 DB	 8
  00202	08		 DB	 8
  00203	08		 DB	 8
  00204	08		 DB	 8
  00205	08		 DB	 8
  00206	08		 DB	 8
  00207	08		 DB	 8
  00208	08		 DB	 8
  00209	08		 DB	 8
  0020a	08		 DB	 8
  0020b	08		 DB	 8
  0020c	08		 DB	 8
  0020d	07		 DB	 7
  0020e	66 90		 npad	 2
$LN33@DropReward:
  00210	00 00 00 00	 DD	 $LN15@DropReward
  00214	00 00 00 00	 DD	 $LN16@DropReward
  00218	00 00 00 00	 DD	 $LN17@DropReward
  0021c	00 00 00 00	 DD	 $LN18@DropReward
  00220	00 00 00 00	 DD	 $LN19@DropReward
  00224	00 00 00 00	 DD	 $LN20@DropReward
  00228	00 00 00 00	 DD	 $LN21@DropReward
  0022c	00 00 00 00	 DD	 $LN22@DropReward
  00230	00 00 00 00	 DD	 $LN28@DropReward
$LN27@DropReward:
  00234	00		 DB	 0
  00235	01		 DB	 1
  00236	02		 DB	 2
  00237	03		 DB	 3
  00238	04		 DB	 4
  00239	05		 DB	 5
  0023a	06		 DB	 6
  0023b	08		 DB	 8
  0023c	08		 DB	 8
  0023d	08		 DB	 8
  0023e	08		 DB	 8
  0023f	08		 DB	 8
  00240	08		 DB	 8
  00241	08		 DB	 8
  00242	08		 DB	 8
  00243	08		 DB	 8
  00244	08		 DB	 8
  00245	08		 DB	 8
  00246	08		 DB	 8
  00247	08		 DB	 8
  00248	08		 DB	 8
  00249	08		 DB	 8
  0024a	08		 DB	 8
  0024b	08		 DB	 8
  0024c	08		 DB	 8
  0024d	08		 DB	 8
  0024e	08		 DB	 8
  0024f	08		 DB	 8
  00250	08		 DB	 8
  00251	08		 DB	 8
  00252	08		 DB	 8
  00253	08		 DB	 8
  00254	08		 DB	 8
  00255	08		 DB	 8
  00256	08		 DB	 8
  00257	08		 DB	 8
  00258	08		 DB	 8
  00259	08		 DB	 8
  0025a	08		 DB	 8
  0025b	08		 DB	 8
  0025c	08		 DB	 8
  0025d	07		 DB	 7
?DropReward@CBloodCastle@@QAEXH@Z ENDP			; CBloodCastle::DropReward
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iZEN$ = 12						; size = 4
?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CalcSendRewardZEN, COMDAT
; _this$ = ecx

; 3322 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 3323 : 	if ( iZEN <= 0 )

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _iZEN$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	7f 07		 jg	 SHORT $LN2@CalcSendRe

; 3324 : 	{
; 3325 : 		return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	5f		 pop	 edi

; 3354 : }

  0000e	5d		 pop	 ebp
  0000f	c2 08 00	 ret	 8
$LN2@CalcSendRe:
  00012	56		 push	 esi

; 3326 : 	}
; 3327 : 
; 3328 : 	int iRET_ZEN = 0;
; 3329 : 
; 3330 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00013	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00016	85 f6		 test	 esi, esi
  00018	0f 88 8b 00 00
	00		 js	 $LN9@CalcSendRe
  0001e	33 c0		 xor	 eax, eax
  00020	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 7c		 je	 SHORT $LN9@CalcSendRe

; 3333 : 	}
; 3334 : 
; 3335 : 	if ( gObj[iIndex].Connected < PLAYER_PLAYING )

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00032	53		 push	 ebx
  00033	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00039	83 7c 03 04 03	 cmp	 DWORD PTR [ebx+eax+4], 3
  0003e	7d 09		 jge	 SHORT $LN4@CalcSendRe

; 3336 : 	{
; 3337 : 		return 0;

  00040	5b		 pop	 ebx
  00041	5e		 pop	 esi
  00042	33 c0		 xor	 eax, eax
  00044	5f		 pop	 edi

; 3354 : }

  00045	5d		 pop	 ebp
  00046	c2 08 00	 ret	 8
$LN4@CalcSendRe:

; 3338 : 	}
; 3339 : 
; 3340 : 	if ( gObjCheckMaxZen(iIndex, iZEN) == FALSE )

  00049	57		 push	 edi
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  00050	83 c4 08	 add	 esp, 8
  00053	85 c0		 test	 eax, eax
  00055	75 26		 jne	 SHORT $LN5@CalcSendRe

; 3341 : 	{
; 3342 : 		iRET_ZEN = MAX_ZEN - gObj[iIndex].Money;

  00057	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005d	b9 00 94 35 77	 mov	 ecx, 2000000000		; 77359400H
  00062	8b 84 1a cc 00
	00 00		 mov	 eax, DWORD PTR [edx+ebx+204]
  00069	2b c8		 sub	 ecx, eax

; 3343 : 		gObj[iIndex].Money += iRET_ZEN;

  0006b	03 c1		 add	 eax, ecx
  0006d	89 84 1a cc 00
	00 00		 mov	 DWORD PTR [edx+ebx+204], eax

; 3344 : 
; 3345 : 		return iRET_ZEN;

  00074	8b c1		 mov	 eax, ecx
  00076	5b		 pop	 ebx
  00077	5e		 pop	 esi
  00078	5f		 pop	 edi

; 3354 : }

  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
$LN5@CalcSendRe:

; 3346 : 	}
; 3347 : 
; 3348 : 	gObj[iIndex].Money += iZEN;

  0007d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00083	01 bc 0b cc 00
	00 00		 add	 DWORD PTR [ebx+ecx+204], edi

; 3349 : 	iRET_ZEN = iZEN;
; 3350 : 	GCMoneySend(iIndex, gObj[iIndex].Money);

  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00090	ff b4 0b cc 00
	00 00		 push	 DWORD PTR [ebx+ecx+204]
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0009d	83 c4 08	 add	 esp, 8

; 3351 : 
; 3352 : 
; 3353 : 	return iRET_ZEN;

  000a0	8b c7		 mov	 eax, edi
  000a2	5b		 pop	 ebx
  000a3	5e		 pop	 esi
  000a4	5f		 pop	 edi

; 3354 : }

  000a5	5d		 pop	 ebp
  000a6	c2 08 00	 ret	 8
$LN9@CalcSendRe:
  000a9	5e		 pop	 esi

; 3331 : 	{
; 3332 : 		return 0;

  000aa	33 c0		 xor	 eax, eax
  000ac	5f		 pop	 edi

; 3354 : }

  000ad	5d		 pop	 ebp
  000ae	c2 08 00	 ret	 8
?CalcSendRewardZEN@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CalcSendRewardZEN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z
_TEXT	SEGMENT
_iCAL_EXP$ = -12					; size = 8
_this$1$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_iRET_EXP$2$ = 12					; size = 4
_iEXP$ = 12						; size = 4
?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z PROC		; CBloodCastle::CalcSendRewardEXP, COMDAT
; _this$ = ecx

; 3273 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 3274 : 	if ( iEXP <= 0 )

  00006	8b 45 0c	 mov	 eax, DWORD PTR _iEXP$[ebp]
  00009	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000c	85 c0		 test	 eax, eax
  0000e	7f 08		 jg	 SHORT $LN4@CalcSendRe

; 3275 : 	{
; 3276 : 		return 0;

  00010	33 c0		 xor	 eax, eax

; 3317 : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN4@CalcSendRe:

; 3277 : 	}
; 3278 : 
; 3279 : 	__int64 iRET_EXP = 0;
; 3280 : 	__int64 iCAL_EXP = iEXP;

  00018	99		 cdq

; 3281 : 
; 3282 : 	if ( g_CrywolfSync.GetOccupationState() == 1 && g_iCrywolfApplyMvpPenalty )

  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0001e	89 45 f4	 mov	 DWORD PTR _iCAL_EXP$[ebp], eax
  00021	89 55 f8	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
  00024	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  00029	83 f8 01	 cmp	 eax, 1
  0002c	75 36		 jne	 SHORT $LN24@CalcSendRe
  0002e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpPenalty@@3HA, 0 ; g_iCrywolfApplyMvpPenalty
  00035	74 2d		 je	 SHORT $LN24@CalcSendRe

; 3283 : 		iCAL_EXP =iCAL_EXP * g_CrywolfSync.GetGettingExpPenaltyRate() / 100;

  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0003c	e8 00 00 00 00	 call	 ?GetGettingExpPenaltyRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetGettingExpPenaltyRate
  00041	ff 75 f8	 push	 DWORD PTR _iCAL_EXP$[ebp+4]
  00044	99		 cdq
  00045	ff 75 f4	 push	 DWORD PTR _iCAL_EXP$[ebp]
  00048	52		 push	 edx
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 __allmul
  0004f	6a 00		 push	 0
  00051	6a 64		 push	 100			; 00000064H
  00053	52		 push	 edx
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 __alldiv
  0005a	8b c8		 mov	 ecx, eax
  0005c	89 55 f8	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
  0005f	89 4d f4	 mov	 DWORD PTR _iCAL_EXP$[ebp], ecx
  00062	eb 06		 jmp	 SHORT $LN5@CalcSendRe
$LN24@CalcSendRe:
  00064	8b 55 f8	 mov	 edx, DWORD PTR _iCAL_EXP$[ebp+4]
  00067	8b 4d f4	 mov	 ecx, DWORD PTR _iCAL_EXP$[ebp]
$LN5@CalcSendRe:

; 3284 : 
; 3285 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  0006a	57		 push	 edi
  0006b	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0006e	85 ff		 test	 edi, edi
  00070	0f 88 1c 01 00
	00		 js	 $LN18@CalcSendRe
  00076	33 c0		 xor	 eax, eax
  00078	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0007e	0f 9e c0	 setle	 al
  00081	85 c0		 test	 eax, eax
  00083	0f 84 09 01 00
	00		 je	 $LN18@CalcSendRe

; 3288 : 	}
; 3289 : 
; 3290 : 	if ( gObj[iIndex].Connected < PLAYER_PLAYING )

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008e	53		 push	 ebx
  0008f	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  00095	83 7c 03 04 03	 cmp	 DWORD PTR [ebx+eax+4], 3
  0009a	7d 0a		 jge	 SHORT $LN7@CalcSendRe

; 3291 : 	{
; 3292 : 		return 0;

  0009c	5b		 pop	 ebx
  0009d	33 c0		 xor	 eax, eax
  0009f	5f		 pop	 edi

; 3317 : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 08 00	 ret	 8
$LN7@CalcSendRe:

; 3293 : 	}
; 3294 : 
; 3295 : 	iRET_EXP = iCAL_EXP;
; 3296 : 
; 3297 : 	if ( gObj[iIndex].Type == OBJ_USER )

  000a6	80 7c 03 50 01	 cmp	 BYTE PTR [ebx+eax+80], 1
  000ab	56		 push	 esi
  000ac	8b f1		 mov	 esi, ecx
  000ae	89 55 0c	 mov	 DWORD PTR _iRET_EXP$2$[ebp], edx
  000b1	0f 85 d0 00 00
	00		 jne	 $LN10@CalcSendRe

; 3298 : 	{
; 3299 : 		while ( iCAL_EXP > 0 )

  000b7	85 d2		 test	 edx, edx
  000b9	0f 8c a3 00 00
	00		 jl	 $LN21@CalcSendRe
  000bf	7f 21		 jg	 SHORT $LN20@CalcSendRe
  000c1	85 c9		 test	 ecx, ecx
  000c3	0f 84 99 00 00
	00		 je	 $LN21@CalcSendRe
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@CalcSendRe:

; 3300 : 		{
; 3301 : 			if ( iCAL_EXP > 0 )

  000d0	85 d2		 test	 edx, edx
  000d2	0f 8c 8a 00 00
	00		 jl	 $LN21@CalcSendRe
  000d8	7f 08		 jg	 SHORT $LN20@CalcSendRe
  000da	85 c9		 test	 ecx, ecx
  000dc	0f 84 80 00 00
	00		 je	 $LN21@CalcSendRe
$LN20@CalcSendRe:

; 3302 : 			{
; 3303 : 				CheckItemOptForGetExpEx(&gObj[iIndex],iCAL_EXP,1);

  000e2	6a 01		 push	 1
  000e4	8d 4d f4	 lea	 ecx, DWORD PTR _iCAL_EXP$[ebp]
  000e7	03 c3		 add	 eax, ebx
  000e9	51		 push	 ecx
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 ?CheckItemOptForGetExpEx@@YAXPAUOBJECTSTRUCT@@AA_JH@Z ; CheckItemOptForGetExpEx

; 3304 : 				iCAL_EXP = __int64(iCAL_EXP*m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_iBC_REWARD_MULTIPLY);

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f8	8b 55 f8	 mov	 edx, DWORD PTR _iCAL_EXP$[ebp+4]
  000fb	8b 4d f4	 mov	 ecx, DWORD PTR _iCAL_EXP$[ebp]
  000fe	0f be 84 03 36
	12 00 00	 movsx	 eax, BYTE PTR [ebx+eax+4662]
  00106	69 f0 0c 02 00
	00		 imul	 esi, eax, 524
  0010c	e8 00 00 00 00	 call	 __ltod3
  00111	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00114	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00118	f3 0f 59 84 06
	08 02 00 00	 mulss	 xmm0, DWORD PTR [esi+eax+520]
  00121	e8 00 00 00 00	 call	 __ftol3
  00126	8b c8		 mov	 ecx, eax
  00128	89 55 f8	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx

; 3305 : 				iRET_EXP = int(iCAL_EXP);
; 3306 : 				iCAL_EXP = this->LevelUp(iIndex, (int)iCAL_EXP, 4);

  0012b	6a 04		 push	 4
  0012d	51		 push	 ecx
  0012e	99		 cdq
  0012f	89 4d f4	 mov	 DWORD PTR _iCAL_EXP$[ebp], ecx
  00132	8b f0		 mov	 esi, eax
  00134	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00137	57		 push	 edi
  00138	89 55 0c	 mov	 DWORD PTR _iRET_EXP$2$[ebp], edx
  0013b	e8 00 00 00 00	 call	 ?LevelUp@CBloodCastle@@QAEHHHH@Z ; CBloodCastle::LevelUp
  00140	99		 cdq
  00141	89 55 f8	 mov	 DWORD PTR _iCAL_EXP$[ebp+4], edx
  00144	8b c8		 mov	 ecx, eax
  00146	89 4d f4	 mov	 DWORD PTR _iCAL_EXP$[ebp], ecx
  00149	85 d2		 test	 edx, edx
  0014b	7f 06		 jg	 SHORT $LL25@CalcSendRe

; 3298 : 	{
; 3299 : 		while ( iCAL_EXP > 0 )

  0014d	7c 0e		 jl	 SHORT $LN29@CalcSendRe
  0014f	85 c9		 test	 ecx, ecx
  00151	74 0a		 je	 SHORT $LN29@CalcSendRe
$LL25@CalcSendRe:
  00153	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00158	e9 73 ff ff ff	 jmp	 $LL2@CalcSendRe
$LN29@CalcSendRe:
  0015d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN21@CalcSendRe:

; 3307 : 			}
; 3308 : 		}
; 3309 : 
; 3310 : 		if( g_MasterExp.IsEnabled(&gObj[iIndex]) == FALSE )

  00162	03 c3		 add	 eax, ebx
  00164	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterExp@@3VCMasterExperience@@A ; g_MasterExp
  00169	50		 push	 eax
  0016a	e8 00 00 00 00	 call	 ?IsEnabled@CMasterExperience@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterExperience::IsEnabled
  0016f	85 c0		 test	 eax, eax
  00171	75 14		 jne	 SHORT $LN10@CalcSendRe

; 3311 : 		{
; 3312 : 			GCSendExp(iIndex,(WORD)-1,iRET_EXP,0,0);

  00173	50		 push	 eax
  00174	50		 push	 eax
  00175	ff 75 0c	 push	 DWORD PTR _iRET_EXP$2$[ebp]
  00178	56		 push	 esi
  00179	68 ff ff 00 00	 push	 65535			; 0000ffffH
  0017e	57		 push	 edi
  0017f	e8 00 00 00 00	 call	 ?GCSendExp@@YAXHH_JHH@Z	; GCSendExp
  00184	83 c4 18	 add	 esp, 24			; 00000018H
$LN10@CalcSendRe:

; 3313 : 		}
; 3314 : 	}
; 3315 : 
; 3316 : 	return (int)iRET_EXP;

  00187	8b c6		 mov	 eax, esi
  00189	5e		 pop	 esi
  0018a	5b		 pop	 ebx
  0018b	5f		 pop	 edi

; 3317 : }

  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c2 08 00	 ret	 8
$LN18@CalcSendRe:

; 3286 : 	{
; 3287 : 		return 0;

  00192	33 c0		 xor	 eax, eax
  00194	5f		 pop	 edi

; 3317 : }

  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c2 08 00	 ret	 8
?CalcSendRewardEXP@CBloodCastle@@QAEHHH@Z ENDP		; CBloodCastle::CalcSendRewardEXP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?AddExperience@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iEXP$ = 12						; size = 4
?AddExperience@CBloodCastle@@QAE_NHH@Z PROC		; CBloodCastle::AddExperience, COMDAT
; _this$ = ecx

; 2246 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2247 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	85 d2		 test	 edx, edx
  0000b	0f 88 85 00 00
	00		 js	 $LN13@AddExperie
  00011	33 c0		 xor	 eax, eax
  00013	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	74 76		 je	 SHORT $LN13@AddExperie

; 2250 : 	}
; 2251 : 
; 2252 : 	if ( BC_BRIDGE_RANGE(gObj[iIndex].m_cBloodCastleIndex) == FALSE )

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00025	57		 push	 edi
  00026	69 fa 40 27 00
	00		 imul	 edi, edx, 10048
  0002c	8a 8c 07 36 12
	00 00		 mov	 cl, BYTE PTR [edi+eax+4662]
  00033	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  00036	84 c9		 test	 cl, cl
  00038	78 54		 js	 SHORT $LN14@AddExperie
  0003a	33 c0		 xor	 eax, eax
  0003c	80 f9 07	 cmp	 cl, 7
  0003f	0f 9e c0	 setle	 al
  00042	85 c0		 test	 eax, eax
  00044	74 48		 je	 SHORT $LN14@AddExperie

; 2255 : 	}
; 2256 : 
; 2257 : 	if ( BC_SUB_BRIDGE_RANGE(gObj[iIndex].m_cBloodCastleSubIndex) == FALSE )

  00046	8a 92 37 12 00
	00		 mov	 dl, BYTE PTR [edx+4663]
  0004c	84 d2		 test	 dl, dl
  0004e	78 3e		 js	 SHORT $LN14@AddExperie
  00050	33 c0		 xor	 eax, eax
  00052	80 fa 09	 cmp	 dl, 9
  00055	0f 9e c0	 setle	 al
  00058	85 c0		 test	 eax, eax
  0005a	74 32		 je	 SHORT $LN14@AddExperie

; 2258 : 	{
; 2259 : 		return false;
; 2260 : 	}
; 2261 : 
; 2262 : 	if ( iEXP > 0 )

  0005c	56		 push	 esi
  0005d	8b 75 0c	 mov	 esi, DWORD PTR _iEXP$[ebp]
  00060	85 f6		 test	 esi, esi
  00062	7e 21		 jle	 SHORT $LN5@AddExperie

; 2263 : 	{
; 2264 : 		this->m_BridgeData[gObj[iIndex].m_cBloodCastleIndex].m_UserData[gObj[iIndex].m_cBloodCastleSubIndex].m_iEXP += iEXP;

  00064	0f be c1	 movsx	 eax, cl
  00067	69 c8 0c 02 00
	00		 imul	 ecx, eax, 524
  0006d	0f be c2	 movsx	 eax, dl
  00070	03 cb		 add	 ecx, ebx
  00072	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00075	01 74 81 20	 add	 DWORD PTR [ecx+eax*4+32], esi

; 2265 : 		gObj[iIndex].m_iBloodCastleEXP += iEXP;

  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007e	01 b4 07 38 12
	00 00		 add	 DWORD PTR [edi+eax+4664], esi
$LN5@AddExperie:

; 2266 : 	}
; 2267 : 
; 2268 : 	return true;

  00085	5e		 pop	 esi
  00086	5f		 pop	 edi
  00087	b0 01		 mov	 al, 1
  00089	5b		 pop	 ebx

; 2269 : }

  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
$LN14@AddExperie:
  0008e	5f		 pop	 edi

; 2253 : 	{
; 2254 : 		return false;

  0008f	32 c0		 xor	 al, al
  00091	5b		 pop	 ebx

; 2269 : }

  00092	5d		 pop	 ebp
  00093	c2 08 00	 ret	 8
$LN13@AddExperie:

; 2248 : 	{
; 2249 : 		return false;

  00096	32 c0		 xor	 al, al
  00098	5b		 pop	 ebx

; 2269 : }

  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
?AddExperience@CBloodCastle@@QAE_NHH@Z ENDP		; CBloodCastle::AddExperience
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z
_TEXT	SEGMENT
_iChaosTaxMoney$2$ = -52				; size = 4
_iLEVEL$GSCopy$1$ = -48					; size = 4
_iMIX_NEED_MONEY$1$ = -44				; size = 4
_pMsg$ = -40						; size = 16
_szTmp$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iLEVEL$ = 12						; size = 4
?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z PROC	; CBloodCastle::BloodCastleChaosMix, COMDAT
; _this$ = ecx

; 1151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _iLEVEL$[ebp]
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00018	89 5d d0	 mov	 DWORD PTR _iLEVEL$GSCopy$1$[ebp], ebx

; 1152 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  0001b	85 f6		 test	 esi, esi
  0001d	78 2e		 js	 SHORT $LN22@BloodCastl
  0001f	33 c0		 xor	 eax, eax
  00021	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	74 1f		 je	 SHORT $LN22@BloodCastl

; 1153 : 	{
; 1154 : 		return false;
; 1155 : 	}
; 1156 : 
; 1157 : 	int MapNumber = GetEventMap(iLEVEL-1);

  0002e	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ?GetEventMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetEventMap

; 1158 : 
; 1159 : 	if ( BC_MAP_RANGE( (MapNumber) )  == FALSE )

  00037	83 f8 34	 cmp	 eax, 52			; 00000034H
  0003a	74 25		 je	 SHORT $LN3@BloodCastl
  0003c	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0003f	7c 0c		 jl	 SHORT $LN22@BloodCastl
  00041	33 c9		 xor	 ecx, ecx
  00043	83 f8 11	 cmp	 eax, 17			; 00000011H
  00046	0f 9e c1	 setle	 cl
  00049	85 c9		 test	 ecx, ecx
  0004b	75 14		 jne	 SHORT $LN3@BloodCastl
$LN22@BloodCastl:
  0004d	5e		 pop	 esi

; 1160 : 	{
; 1161 : 		return false;

  0004e	32 c0		 xor	 al, al
  00050	5b		 pop	 ebx

; 1270 : }

  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 08 00	 ret	 8
$LN3@BloodCastl:
  00061	57		 push	 edi

; 1162 : 	}
; 1163 : 
; 1164 : 	BOOL bMIX_RESULT = FALSE;
; 1165 : 
; 1166 : 	PMSG_CHAOSMIXRESULT pMsg;
; 1167 : 
; 1168 : 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  00062	6a 10		 push	 16			; 00000010H
  00064	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00067	68 86 00 00 00	 push	 134			; 00000086H
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1169 : 	pMsg.Result = CB_ERROR;
; 1170 : 	gObj[iIndex].ChaosLock = TRUE;

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00077	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  0007d	c6 45 db 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0

; 1171 : 
; 1172 : 	LogAddTD("[Blood Castle]  Mix Chaos Mix Start (Account:%s, Name:%s, Level:%d)",

  00081	53		 push	 ebx
  00082	c7 84 07 20 12
	00 00 01 00 00
	00		 mov	 DWORD PTR [edi+eax+4640], 1
  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00093	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00096	03 c7		 add	 eax, edi
  00098	50		 push	 eax
  00099	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0009c	03 c7		 add	 eax, edi
  0009e	50		 push	 eax
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CDAILJHC@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1173 : 		gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);
; 1174 : 
; 1175 : 	char szTmp[20];
; 1176 : 
; 1177 : 	wsprintf(szTmp,"BloodCastle Mix %d",iLEVEL);

  000aa	53		 push	 ebx
  000ab	8d 45 e8	 lea	 eax, DWORD PTR _szTmp$[ebp]
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KGJMEGIB@BloodCastle?5Mix?5?$CFd?$AA@
  000b3	50		 push	 eax
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000ba	83 c4 28	 add	 esp, 40			; 00000028H

; 1178 : 	g_ChaosBox.LogChaosItem(&gObj[iIndex], szTmp);

  000bd	8d 45 e8	 lea	 eax, DWORD PTR _szTmp$[ebp]
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  000c5	50		 push	 eax
  000c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cb	03 c7		 add	 eax, edi
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?LogChaosItem@CChaosBox@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CChaosBox::LogChaosItem

; 1179 : 
; 1180 : 	int iMIX_SUCCESS_RATE = g_iBC_ChoasMixSuccessRate[iLEVEL - 1];

  000d3	8b 1c 9d fc ff
	ff ff		 mov	 ebx, DWORD PTR ?g_iBC_ChoasMixSuccessRate@@3PAHA[ebx*4-4]

; 1181 : 
; 1182 : 	if ( iMIX_SUCCESS_RATE < 0 || iMIX_SUCCESS_RATE > 100 )

  000da	83 fb 64	 cmp	 ebx, 100		; 00000064H
  000dd	0f 87 25 02 00
	00		 ja	 $LN5@BloodCastl

; 1186 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);
; 1187 : 
; 1188 : 		return false;
; 1189 : 	}
; 1190 : 
; 1191 : 	if ( g_CrywolfSync.GetOccupationState() == 0 && g_iCrywolfApplyMvpBenefit )

  000e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  000e8	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  000ed	85 c0		 test	 eax, eax
  000ef	75 14		 jne	 SHORT $LN6@BloodCastl
  000f1	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_iCrywolfApplyMvpBenefit@@3HA, eax ; g_iCrywolfApplyMvpBenefit
  000f7	74 0c		 je	 SHORT $LN6@BloodCastl

; 1192 : 	{
; 1193 : 		iMIX_SUCCESS_RATE += g_CrywolfSync.GetPlusChaosRate();

  000f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  000fe	e8 00 00 00 00	 call	 ?GetPlusChaosRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetPlusChaosRate
  00103	03 d8		 add	 ebx, eax
$LN6@BloodCastl:

; 1194 : 	}
; 1195 : 
; 1196 : 	if ( iMIX_SUCCESS_RATE > 80 )

  00105	b8 50 00 00 00	 mov	 eax, 80			; 00000050H
  0010a	3b d8		 cmp	 ebx, eax
  0010c	0f 4f d8	 cmovg	 ebx, eax

; 1197 : 	{
; 1198 : 		iMIX_SUCCESS_RATE = 80;
; 1199 : 	}
; 1200 : 
; 1201 : 	if ( gObj[iIndex].ChaosSuccessRate > 10 )

  0010f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00114	83 bc 07 1c 12
	00 00 0a	 cmp	 DWORD PTR [edi+eax+4636], 10 ; 0000000aH
  0011c	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0011f	7e 25		 jle	 SHORT $LN8@BloodCastl

; 1202 : 	{
; 1203 : 		pMsg.Result = 0xF0;

  00121	c6 45 db f0	 mov	 BYTE PTR _pMsg$[ebp+3], 240 ; 000000f0H

; 1204 : 		gObj[iIndex].ChaosLock = FALSE;

  00125	c7 81 20 12 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+4640], 0

; 1205 : 
; 1206 : 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0012f	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00133	50		 push	 eax
  00134	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00137	50		 push	 eax
  00138	56		 push	 esi
  00139	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0013e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00143	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@BloodCastl:

; 1207 : 	}
; 1208 : 
; 1209 : 	iMIX_SUCCESS_RATE += gObj[iIndex].ChaosSuccessRate;

  00146	03 9c 07 1c 12
	00 00		 add	 ebx, DWORD PTR [edi+eax+4636]

; 1210 : 	int iMIX_NEED_MONEY = g_iBC_ChoasMixMoney[iLEVEL - 1];
; 1211 : 	int iChaosTaxMoney = (int)((__int64)(iMIX_NEED_MONEY) * (__int64)(g_CastleSiegeSync.GetTaxRateChaos(iIndex)) / (__int64)100);

  0014d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00152	8b 45 d0	 mov	 eax, DWORD PTR _iLEVEL$GSCopy$1$[ebp]
  00155	56		 push	 esi
  00156	8b 04 85 fc ff
	ff ff		 mov	 eax, DWORD PTR ?g_iBC_ChoasMixMoney@@3PAHA[eax*4-4]
  0015d	89 45 d4	 mov	 DWORD PTR _iMIX_NEED_MONEY$1$[ebp], eax
  00160	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  00165	8b c8		 mov	 ecx, eax
  00167	8b 45 d4	 mov	 eax, DWORD PTR _iMIX_NEED_MONEY$1$[ebp]
  0016a	f7 e9		 imul	 ecx
  0016c	6a 00		 push	 0
  0016e	6a 64		 push	 100			; 00000064H
  00170	52		 push	 edx
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 __alldiv

; 1212 : 
; 1213 : 	if ( iChaosTaxMoney < 0 )

  00177	33 c9		 xor	 ecx, ecx
  00179	85 c0		 test	 eax, eax
  0017b	0f 48 c1	 cmovs	 eax, ecx

; 1214 : 	{
; 1215 : 		iChaosTaxMoney = 0;
; 1216 : 	}
; 1217 : 
; 1218 : 	iMIX_NEED_MONEY += iChaosTaxMoney;

  0017e	8b 4d d4	 mov	 ecx, DWORD PTR _iMIX_NEED_MONEY$1$[ebp]
  00181	03 c8		 add	 ecx, eax
  00183	89 45 cc	 mov	 DWORD PTR _iChaosTaxMoney$2$[ebp], eax
  00186	89 4d d4	 mov	 DWORD PTR _iMIX_NEED_MONEY$1$[ebp], ecx

; 1219 : 
; 1220 : 	if ( iMIX_NEED_MONEY <  0 )

  00189	79 2e		 jns	 SHORT $LN10@BloodCastl

; 1221 : 	{
; 1222 : 		DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0018b	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0018f	50		 push	 eax
  00190	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00193	50		 push	 eax
  00194	56		 push	 esi
  00195	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1223 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - MixMoney < 0 (Account:%s, Name:%s, Level:%d)",

  0019a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a0	ff 75 d0	 push	 DWORD PTR _iLEVEL$GSCopy$1$[ebp]
  001a3	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001a6	03 c7		 add	 eax, edi
  001a8	50		 push	 eax
  001a9	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001ac	03 c7		 add	 eax, edi
  001ae	50		 push	 eax
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@MNNOPKAN@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@

; 1224 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);
; 1225 : 
; 1226 : 		return false;

  001b4	e9 78 01 00 00	 jmp	 $LN25@BloodCastl
$LN10@BloodCastl:

; 1227 : 	}
; 1228 : 
; 1229 : 	if ( (gObj[iIndex].Money - iMIX_NEED_MONEY) < 0 )	// Not enoght zen

  001b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001bf	8b 84 3a cc 00
	00 00		 mov	 eax, DWORD PTR [edx+edi+204]
  001c6	2b c1		 sub	 eax, ecx
  001c8	79 32		 jns	 SHORT $LN11@BloodCastl

; 1230 : 	{
; 1231 : 		pMsg.Result = CB_BC_NOT_ENOUGH_ZEN;
; 1232 : 		DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  001ca	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001ce	50		 push	 eax
  001cf	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001d2	c6 45 db 0b	 mov	 BYTE PTR _pMsg$[ebp+3], 11 ; 0000000bH
  001d6	50		 push	 eax
  001d7	56		 push	 esi
  001d8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1233 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - Not Enough Money (Account:%s, Name:%s, Level:%d)",

  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001e3	ff 75 d0	 push	 DWORD PTR _iLEVEL$GSCopy$1$[ebp]
  001e6	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001e9	03 c7		 add	 eax, edi
  001eb	50		 push	 eax
  001ec	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001ef	03 c7		 add	 eax, edi
  001f1	50		 push	 eax
  001f2	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@CFALPHEA@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@

; 1234 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iLEVEL);
; 1235 : 
; 1236 : 		return false;

  001f7	e9 35 01 00 00	 jmp	 $LN25@BloodCastl
$LN11@BloodCastl:

; 1237 : 	}
; 1238 : 
; 1239 : 	gObj[iIndex].Money -= iMIX_NEED_MONEY;
; 1240 : 	g_CastleSiegeSync.AddTributeMoney(iChaosTaxMoney);

  001fc	ff 75 cc	 push	 DWORD PTR _iChaosTaxMoney$2$[ebp]
  001ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00204	89 84 3a cc 00
	00 00		 mov	 DWORD PTR [edx+edi+204], eax
  0020b	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 1241 : 	GCMoneySend(iIndex, gObj[iIndex].Money);

  00210	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00215	ff b4 07 cc 00
	00 00		 push	 DWORD PTR [edi+eax+204]
  0021c	56		 push	 esi
  0021d	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00222	83 c4 08	 add	 esp, 8

; 1242 : 
; 1243 : 	if ( (rand()%100) < iMIX_SUCCESS_RATE )	// Siccess

  00225	e8 00 00 00 00	 call	 _rand
  0022a	99		 cdq
  0022b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00230	f7 f9		 idiv	 ecx
  00232	3b d3		 cmp	 edx, ebx
  00234	7d 75		 jge	 SHORT $LN12@BloodCastl

; 1244 : 	{
; 1245 : 		int item_num = ITEMGET(13,18);	// Invisibility Cloak
; 1246 : 		ItemSerialCreateSend(iIndex, -1, 0, 0, item_num, iLEVEL, 255, 0, 0, 0, -1, 0, 0);

  00236	6a 00		 push	 0
  00238	6a 00		 push	 0
  0023a	6a 00		 push	 0
  0023c	6a 00		 push	 0
  0023e	6a ff		 push	 -1
  00240	6a 00		 push	 0
  00242	6a 00		 push	 0
  00244	6a 00		 push	 0
  00246	68 ff 00 00 00	 push	 255			; 000000ffH
  0024b	ff 75 d0	 push	 DWORD PTR _iLEVEL$GSCopy$1$[ebp]
  0024e	68 12 1a 00 00	 push	 6674			; 00001a12H
  00253	6a 00		 push	 0
  00255	6a 00		 push	 0
  00257	68 ff 00 00 00	 push	 255			; 000000ffH
  0025c	56		 push	 esi
  0025d	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 1247 : 		LogAddTD("[BloodCastle] [%s][%s] CBMix Success %d Money : %d-%d",

  00262	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00268	ff 75 d4	 push	 DWORD PTR _iMIX_NEED_MONEY$1$[ebp]
  0026b	ff b4 39 cc 00
	00 00		 push	 DWORD PTR [ecx+edi+204]
  00272	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00275	03 c7		 add	 eax, edi
  00277	53		 push	 ebx
  00278	50		 push	 eax
  00279	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0027c	03 c7		 add	 eax, edi
  0027e	50		 push	 eax
  0027f	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MNKNGIBB@?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Suc@
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0028a	83 c4 54	 add	 esp, 84			; 00000054H

; 1265 : 	}
; 1266 : 
; 1267 : 	::gObjInventoryCommit(iIndex);

  0028d	56		 push	 esi
  0028e	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  00293	83 c4 04	 add	 esp, 4

; 1268 : 
; 1269 : 	return true;

  00296	b0 01		 mov	 al, 1
  00298	5f		 pop	 edi
  00299	5e		 pop	 esi
  0029a	5b		 pop	 ebx

; 1270 : }

  0029b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029e	33 cd		 xor	 ecx, ebp
  002a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a5	8b e5		 mov	 esp, ebp
  002a7	5d		 pop	 ebp
  002a8	c2 08 00	 ret	 8
$LN12@BloodCastl:

; 1248 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iMIX_SUCCESS_RATE, gObj[iIndex].Money, iMIX_NEED_MONEY);
; 1249 : #if( __4GAMERS__ == 1 )
; 1250 : 		g_Achievements.GD_UpdateMixData(&gObj[iIndex], true);
; 1251 : #endif
; 1252 : 	}
; 1253 : 	else	// Failure
; 1254 : 	{
; 1255 : #if( __4GAMERS__ == 1 )
; 1256 : 		g_Achievements.GD_UpdateMixData(&gObj[iIndex], false);
; 1257 : #endif
; 1258 : 		g_ChaosBox.ChaosBoxInit(&gObj[iIndex]);

  002ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  002b5	03 c7		 add	 eax, edi
  002b7	50		 push	 eax
  002b8	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 1259 : 		GCUserChaosBoxSend(&gObj[iIndex], 0);

  002bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c2	03 c7		 add	 eax, edi
  002c4	6a 00		 push	 0
  002c6	50		 push	 eax
  002c7	e8 00 00 00 00	 call	 ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCUserChaosBoxSend

; 1260 : 		DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  002cc	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  002d0	50		 push	 eax
  002d1	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  002d4	50		 push	 eax
  002d5	56		 push	 esi
  002d6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1261 : 		LogAddTD("[BloodCastle] [%s][%s] CBMix Fail %d Money : %d-%d",

  002db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e1	ff 75 d4	 push	 DWORD PTR _iMIX_NEED_MONEY$1$[ebp]
  002e4	ff b4 39 cc 00
	00 00		 push	 DWORD PTR [ecx+edi+204]
  002eb	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002ee	03 c7		 add	 eax, edi
  002f0	53		 push	 ebx
  002f1	50		 push	 eax
  002f2	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  002f5	03 c7		 add	 eax, edi
  002f7	50		 push	 eax
  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@NPKINPCN@?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Fai@
  002fd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00303	83 c4 2c	 add	 esp, 44			; 0000002cH

; 1262 : 			gObj[iIndex].AccountID, gObj[iIndex].Name, iMIX_SUCCESS_RATE, gObj[iIndex].Money, iMIX_NEED_MONEY);
; 1263 : 
; 1264 : 		return false;

  00306	eb 32		 jmp	 SHORT $LN24@BloodCastl
$LN5@BloodCastl:

; 1183 : 	{
; 1184 : 		DataSend(iIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00308	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0030c	50		 push	 eax
  0030d	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00310	50		 push	 eax
  00311	56		 push	 esi
  00312	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1185 : 		LogAddTD("[Blood Castle]  Mix Chaos Mix Failed - MixRate Out of Bound (Account:%s, Name:%s, Level:%d)",

  00317	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0031d	ff 75 d0	 push	 DWORD PTR _iLEVEL$GSCopy$1$[ebp]
  00320	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00323	03 c7		 add	 eax, edi
  00325	50		 push	 eax
  00326	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00329	03 c7		 add	 eax, edi
  0032b	50		 push	 eax
  0032c	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@IPBOHNGB@?$FLBlood?5Castle?$FN?5?E?u?$LI?m?$LI?A?E?d?5Mix?5Chao@
$LN25@BloodCastl:
  00331	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00337	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN24@BloodCastl:

; 1270 : }

  0033a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033d	32 c0		 xor	 al, al
  0033f	5f		 pop	 edi
  00340	5e		 pop	 esi
  00341	33 cd		 xor	 ecx, ebp
  00343	5b		 pop	 ebx
  00344	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00349	8b e5		 mov	 esp, ebp
  0034b	5d		 pop	 ebp
  0034c	c2 08 00	 ret	 8
?BloodCastleChaosMix@CBloodCastle@@QAE_NHH@Z ENDP	; CBloodCastle::BloodCastleChaosMix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?CheckChoasMixItem@CBloodCastle@@QAEHH@Z
_TEXT	SEGMENT
_bIsChaosGemExist$1$ = -28				; size = 4
_iBloodBoneLevel$1$ = -24				; size = 4
_bIsAngelKingPaperExist$1$ = -20			; size = 4
_bIsOtherItemExist$1$ = -16				; size = 4
_bIsBloodBoneExist$1$ = -12				; size = 4
?gObj@@3PAUOBJECTSTRUCT@@A$1 = -8			; size = 4
_iAngelKingPaperLevel$1$ = -4				; size = 4
_iCharmOfLuckCount$1$ = 8				; size = 4
_iIndex$ = 8						; size = 4
?CheckChoasMixItem@CBloodCastle@@QAEHH@Z PROC		; CBloodCastle::CheckChoasMixItem, COMDAT
; _this$ = ecx

; 1328 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1329 : 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	85 c9		 test	 ecx, ecx
  0000b	0f 88 20 02 00
	00		 js	 $LN43@CheckChoas
  00011	33 c0		 xor	 eax, eax
  00013	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 0d 02 00
	00		 je	 $LN43@CheckChoas

; 1332 : 	}
; 1333 : 
; 1334 : 	int iCHAOS_MIX_LEVEL = 0;
; 1335 : 	BOOL bIsChaosGemExist = FALSE;

  00024	33 c0		 xor	 eax, eax
  00026	53		 push	 ebx
  00027	56		 push	 esi

; 1336 : 	BOOL bIsAngelKingPaperExist = FALSE;
; 1337 : 	BOOL bIsBloodBoneExist = FALSE;
; 1338 : 	BOOL bIsOtherItemExist = FALSE;
; 1339 : 	int iEventItemCount = 0;
; 1340 : 	int iAngelKingPaperLevel = 0;
; 1341 : 	int iBloodBoneLevel = 0;

  00028	33 f6		 xor	 esi, esi
  0002a	89 45 e4	 mov	 DWORD PTR _bIsChaosGemExist$1$[ebp], eax
  0002d	57		 push	 edi
  0002e	89 45 ec	 mov	 DWORD PTR _bIsAngelKingPaperExist$1$[ebp], eax
  00031	33 ff		 xor	 edi, edi
  00033	89 45 f4	 mov	 DWORD PTR _bIsBloodBoneExist$1$[ebp], eax
  00036	89 45 f0	 mov	 DWORD PTR _bIsOtherItemExist$1$[ebp], eax
  00039	89 45 fc	 mov	 DWORD PTR _iAngelKingPaperLevel$1$[ebp], eax

; 1342 : 	int iCharmOfLuckCount=0;

  0003c	89 45 08	 mov	 DWORD PTR _iCharmOfLuckCount$1$[ebp], eax
  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00044	89 75 e8	 mov	 DWORD PTR _iBloodBoneLevel$1$[ebp], esi
  00047	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  0004d	0f 1f 00	 npad	 3
$LL4@CheckChoas:

; 1345 : 	{
; 1346 : 		if ( gObj[iIndex].pChaosBox[i].IsItem() == TRUE )

  00050	8b 8c 03 10 12
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4624]
  00057	03 ce		 add	 ecx, esi
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	83 f8 01	 cmp	 eax, 1
  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	89 45 f8	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$1[ebp], eax
  00069	75 20		 jne	 SHORT $LN46@CheckChoas

; 1347 : 		{
; 1348 : 			if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(12,15) ) // Chaos

  0006b	8b 8c 03 10 12
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4624]
  00072	ba 0f 18 00 00	 mov	 edx, 6159		; 0000180fH
  00077	0f b7 44 31 06	 movzx	 eax, WORD PTR [ecx+esi+6]
  0007c	66 3b c2	 cmp	 ax, dx
  0007f	75 3a		 jne	 SHORT $LN7@CheckChoas

; 1349 : 			{
; 1350 : 				bIsChaosGemExist = TRUE;

  00081	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _bIsChaosGemExist$1$[ebp], 1
$LN51@CheckChoas:

; 1364 : 				iBloodBoneLevel = iBLOOD_BONE_LEVEL;

  00088	8b 45 f8	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$1[ebp]
$LN46@CheckChoas:
  0008b	8b 55 fc	 mov	 edx, DWORD PTR _iAngelKingPaperLevel$1$[ebp]
$LN50@CheckChoas:
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _iCharmOfLuckCount$1$[ebp]
$LN2@CheckChoas:

; 1343 : 
; 1344 : 	for ( int i=0;i<CHAOS_BOX_SIZE;i++)

  00091	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00097	81 fe 80 1a 00
	00		 cmp	 esi, 6784		; 00001a80H
  0009d	7c b1		 jl	 SHORT $LL4@CheckChoas

; 1373 : 			}
; 1374 : 		}
; 1375 : 	}
; 1376 : 
; 1377 : 	gObj[iIndex].ChaosSuccessRate = iCharmOfLuckCount;

  0009f	89 8c 03 1c 12
	00 00		 mov	 DWORD PTR [ebx+eax+4636], ecx

; 1378 : 
; 1379 : 	if ( bIsOtherItemExist != FALSE )

  000a6	8b 45 f0	 mov	 eax, DWORD PTR _bIsOtherItemExist$1$[ebp]
  000a9	85 c0		 test	 eax, eax
  000ab	74 7b		 je	 SHORT $LN15@CheckChoas

; 1380 : 	{
; 1381 : 		return 8;

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	b8 08 00 00 00	 mov	 eax, 8
  000b4	5b		 pop	 ebx

; 1442 : 	}
; 1443 : 
; 1444 : 	return 0;
; 1445 : }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
$LN7@CheckChoas:

; 1351 : 			}
; 1352 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(13,16) ) //Scroll of Archangel

  000bb	ba 10 1a 00 00	 mov	 edx, 6672		; 00001a10H
  000c0	66 3b c2	 cmp	 ax, dx
  000c3	75 15		 jne	 SHORT $LN9@CheckChoas

; 1353 : 			{
; 1354 : 				int iSCROLL_LEVEL = gObj[iIndex].pChaosBox[i].m_Level;

  000c5	0f bf 54 31 08	 movsx	 edx, WORD PTR [ecx+esi+8]

; 1355 : 				iEventItemCount++;

  000ca	47		 inc	 edi

; 1356 : 				bIsAngelKingPaperExist = TRUE;
; 1357 : 				iAngelKingPaperLevel = iSCROLL_LEVEL;

  000cb	8b 45 f8	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$1[ebp]
  000ce	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bIsAngelKingPaperExist$1$[ebp], 1
  000d5	89 55 fc	 mov	 DWORD PTR _iAngelKingPaperLevel$1$[ebp], edx
  000d8	eb b4		 jmp	 SHORT $LN50@CheckChoas
$LN9@CheckChoas:

; 1358 : 			}
; 1359 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(13,17) ) //Blood Bone

  000da	ba 11 1a 00 00	 mov	 edx, 6673		; 00001a11H
  000df	66 3b c2	 cmp	 ax, dx
  000e2	75 12		 jne	 SHORT $LN11@CheckChoas

; 1360 : 			{
; 1361 : 				int iBLOOD_BONE_LEVEL = gObj[iIndex].pChaosBox[i].m_Level;

  000e4	0f bf 44 31 08	 movsx	 eax, WORD PTR [ecx+esi+8]

; 1362 : 				iEventItemCount++;

  000e9	47		 inc	 edi

; 1363 : 				bIsBloodBoneExist = TRUE;

  000ea	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bIsBloodBoneExist$1$[ebp], 1
  000f1	89 45 e8	 mov	 DWORD PTR _iBloodBoneLevel$1$[ebp], eax

; 1364 : 				iBloodBoneLevel = iBLOOD_BONE_LEVEL;

  000f4	eb 92		 jmp	 SHORT $LN51@CheckChoas
$LN11@CheckChoas:

; 1365 : 			}
; 1366 : 			else if ( gObj[iIndex].pChaosBox[i].m_Type == ITEMGET(14,53) ) //Charm

  000f6	ba 35 1c 00 00	 mov	 edx, 7221		; 00001c35H
  000fb	66 3b c2	 cmp	 ax, dx

; 1369 : 			}
; 1370 : 			else

  000fe	8b 55 fc	 mov	 edx, DWORD PTR _iAngelKingPaperLevel$1$[ebp]
  00101	75 16		 jne	 SHORT $LN13@CheckChoas

; 1367 : 			{
; 1368 : 				iCharmOfLuckCount += (int)gObj[iIndex].pChaosBox[i].m_Durability;

  00103	f3 0f 2c 44 31
	24		 cvttss2si eax, DWORD PTR [ecx+esi+36]
  00109	8b 4d 08	 mov	 ecx, DWORD PTR _iCharmOfLuckCount$1$[ebp]
  0010c	03 c8		 add	 ecx, eax

; 1369 : 			}
; 1370 : 			else

  0010e	8b 45 f8	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$1[ebp]
  00111	89 4d 08	 mov	 DWORD PTR _iCharmOfLuckCount$1$[ebp], ecx
  00114	e9 78 ff ff ff	 jmp	 $LN2@CheckChoas
$LN13@CheckChoas:
  00119	8b 45 f8	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$1[ebp]

; 1371 : 			{
; 1372 : 				bIsOtherItemExist = TRUE;

  0011c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bIsOtherItemExist$1$[ebp], 1
  00123	e9 66 ff ff ff	 jmp	 $LN50@CheckChoas
$LN15@CheckChoas:

; 1382 : 	}
; 1383 : 
; 1384 : 	if ( bIsAngelKingPaperExist == FALSE && bIsBloodBoneExist == FALSE )

  00128	8b 45 ec	 mov	 eax, DWORD PTR _bIsAngelKingPaperExist$1$[ebp]
  0012b	85 c0		 test	 eax, eax
  0012d	8b 45 f4	 mov	 eax, DWORD PTR _bIsBloodBoneExist$1$[ebp]
  00130	75 11		 jne	 SHORT $LN42@CheckChoas
  00132	85 c0		 test	 eax, eax
  00134	0f 85 e9 00 00
	00		 jne	 $LN18@CheckChoas
  0013a	5f		 pop	 edi
  0013b	5e		 pop	 esi
  0013c	5b		 pop	 ebx

; 1442 : 	}
; 1443 : 
; 1444 : 	return 0;
; 1445 : }

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 04 00	 ret	 4
$LN42@CheckChoas:

; 1385 : 	{
; 1386 : 		return 0;
; 1387 : 	}
; 1388 : 
; 1389 : 	if ( bIsAngelKingPaperExist == FALSE || bIsBloodBoneExist == FALSE )

  00143	85 c0		 test	 eax, eax
  00145	0f 84 d8 00 00
	00		 je	 $LN18@CheckChoas

; 1392 : 	}
; 1393 : 
; 1394 : 	if ( iEventItemCount > 2 )

  0014b	83 ff 02	 cmp	 edi, 2
  0014e	7e 0e		 jle	 SHORT $LN19@CheckChoas

; 1395 : 	{
; 1396 : 		return 12;

  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00157	5b		 pop	 ebx

; 1442 : 	}
; 1443 : 
; 1444 : 	return 0;
; 1445 : }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
$LN19@CheckChoas:

; 1397 : 	}
; 1398 : 
; 1399 : 	if ( iCharmOfLuckCount > 10 )

  0015e	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00161	7e 0e		 jle	 SHORT $LN20@CheckChoas

; 1400 : 	{
; 1401 : 		return 15;

  00163	5f		 pop	 edi
  00164	5e		 pop	 esi
  00165	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0016a	5b		 pop	 ebx

; 1442 : 	}
; 1443 : 
; 1444 : 	return 0;
; 1445 : }

  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c2 04 00	 ret	 4
$LN20@CheckChoas:

; 1402 : 	}
; 1403 : 
; 1404 : 	if ( iAngelKingPaperLevel != iBloodBoneLevel )

  00171	8b 75 e8	 mov	 esi, DWORD PTR _iBloodBoneLevel$1$[ebp]
  00174	3b d6		 cmp	 edx, esi
  00176	0f 85 99 00 00
	00		 jne	 $LN44@CheckChoas

; 1405 : 	{
; 1406 : 		return 9;
; 1407 : 	}
; 1408 : 
; 1409 : 	if ( BC_BRIDGE_RANGE(iAngelKingPaperLevel-1) == FALSE )

  0017c	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]
  0017f	85 c9		 test	 ecx, ecx
  00181	0f 88 8e 00 00
	00		 js	 $LN44@CheckChoas
  00187	33 c0		 xor	 eax, eax
  00189	83 f9 07	 cmp	 ecx, 7
  0018c	0f 9e c0	 setle	 al
  0018f	85 c0		 test	 eax, eax
  00191	0f 84 7e 00 00
	00		 je	 $LN44@CheckChoas

; 1412 : 	}
; 1413 : 
; 1414 : 	if ( BC_BRIDGE_RANGE(iBloodBoneLevel-1) == FALSE )

  00197	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  0019a	85 c9		 test	 ecx, ecx
  0019c	78 77		 js	 SHORT $LN44@CheckChoas
  0019e	33 c0		 xor	 eax, eax
  001a0	83 f9 07	 cmp	 ecx, 7
  001a3	0f 9e c0	 setle	 al
  001a6	85 c0		 test	 eax, eax
  001a8	74 6b		 je	 SHORT $LN44@CheckChoas

; 1415 : 	{
; 1416 : 		return 9;
; 1417 : 	}
; 1418 : 
; 1419 : 	if ( bIsChaosGemExist == FALSE )

  001aa	8b 45 e4	 mov	 eax, DWORD PTR _bIsChaosGemExist$1$[ebp]
  001ad	85 c0		 test	 eax, eax
  001af	75 0e		 jne	 SHORT $LN24@CheckChoas

; 1420 : 	{
; 1421 : 		return 10;

  001b1	5f		 pop	 edi
  001b2	5e		 pop	 esi
  001b3	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  001b8	5b		 pop	 ebx

; 1442 : 	}
; 1443 : 
; 1444 : 	return 0;
; 1445 : }

  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c2 04 00	 ret	 4
$LN24@CheckChoas:

; 1422 : 	}
; 1423 : 
; 1424 : 	if ( gObj[iIndex].Class == CLASS_DARKLORD || gObj[iIndex].Class == CLASS_MAGUMSA || gObj[iIndex].Class == CLASS_FIGHTER )

  001bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c5	0f b7 84 0b 90
	00 00 00	 movzx	 eax, WORD PTR [ebx+ecx+144]
  001cd	83 f8 04	 cmp	 eax, 4
  001d0	74 28		 je	 SHORT $LN27@CheckChoas
  001d2	83 f8 03	 cmp	 eax, 3
  001d5	74 23		 je	 SHORT $LN27@CheckChoas
  001d7	83 f8 06	 cmp	 eax, 6
  001da	74 1e		 je	 SHORT $LN27@CheckChoas

; 1429 : 		}
; 1430 : 	}
; 1431 : 	else
; 1432 : 	{
; 1433 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[0].iLOWER_BOUND )

  001dc	0f bf 84 0b 96
	00 00 00	 movsx	 eax, WORD PTR [ebx+ecx+150]
  001e4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A
$LN52@CheckChoas:
  001ea	7d 1e		 jge	 SHORT $LN28@CheckChoas

; 1434 : 		{
; 1435 : 			return 14;

  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi
  001ee	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  001f3	5b		 pop	 ebx

; 1442 : 	}
; 1443 : 
; 1444 : 	return 0;
; 1445 : }

  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c2 04 00	 ret	 4
$LN27@CheckChoas:

; 1425 : 	{
; 1426 : 		if ( gObj[iIndex].Level < g_sttBLOODCASTLE_LEVEL[0].iLOWER_BOUND_MAGUMSA )

  001fa	0f bf 84 0b 96
	00 00 00	 movsx	 eax, WORD PTR [ebx+ecx+150]
  00202	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR ?g_sttBLOODCASTLE_LEVEL@@3PAU_BLOOODCASTLE_LEVEL@@A+8

; 1427 : 		{
; 1428 : 			return 14;

  00208	eb e0		 jmp	 SHORT $LN52@CheckChoas
$LN28@CheckChoas:
  0020a	5f		 pop	 edi
  0020b	5e		 pop	 esi

; 1436 : 		}
; 1437 : 	}
; 1438 : 
; 1439 : 	if ( bIsChaosGemExist != FALSE && bIsAngelKingPaperExist != FALSE && bIsBloodBoneExist != FALSE )
; 1440 : 	{
; 1441 : 		return iAngelKingPaperLevel;

  0020c	8b c2		 mov	 eax, edx
  0020e	5b		 pop	 ebx

; 1442 : 	}
; 1443 : 
; 1444 : 	return 0;
; 1445 : }

  0020f	8b e5		 mov	 esp, ebp
  00211	5d		 pop	 ebp
  00212	c2 04 00	 ret	 4
$LN44@CheckChoas:
  00215	5f		 pop	 edi
  00216	5e		 pop	 esi

; 1410 : 	{
; 1411 : 		return 9;

  00217	b8 09 00 00 00	 mov	 eax, 9
  0021c	5b		 pop	 ebx

; 1442 : 	}
; 1443 : 
; 1444 : 	return 0;
; 1445 : }

  0021d	8b e5		 mov	 esp, ebp
  0021f	5d		 pop	 ebp
  00220	c2 04 00	 ret	 4
$LN18@CheckChoas:
  00223	5f		 pop	 edi
  00224	5e		 pop	 esi

; 1390 : 	{
; 1391 : 		return 11;

  00225	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  0022a	5b		 pop	 ebx

; 1442 : 	}
; 1443 : 
; 1444 : 	return 0;
; 1445 : }

  0022b	8b e5		 mov	 esp, ebp
  0022d	5d		 pop	 ebp
  0022e	c2 04 00	 ret	 4
$LN43@CheckChoas:

; 1330 : 	{
; 1331 : 		return false;

  00231	33 c0		 xor	 eax, eax

; 1442 : 	}
; 1443 : 
; 1444 : 	return 0;
; 1445 : }

  00233	8b e5		 mov	 esp, ebp
  00235	5d		 pop	 ebp
  00236	c2 04 00	 ret	 4
?CheckChoasMixItem@CBloodCastle@@QAEHH@Z ENDP		; CBloodCastle::CheckChoasMixItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\user.h
;	COMDAT ??_GCObjectStruct@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCObjectStruct@@UAEPAXI@Z PROC			; CObjectStruct::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 1377 : 	virtual ~CObjectStruct(){};

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CObjectStruct@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 04		 push	 4
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_GCObjectStruct@@UAEPAXI@Z ENDP			; CObjectStruct::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\user.h
;	COMDAT ??1CObjectStruct@@UAE@XZ
_TEXT	SEGMENT
??1CObjectStruct@@UAE@XZ PROC				; CObjectStruct::~CObjectStruct, COMDAT
; _this$ = ecx

; 1377 : 	virtual ~CObjectStruct(){};

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CObjectStruct@@6B@
  00006	c3		 ret	 0
??1CObjectStruct@@UAE@XZ ENDP				; CObjectStruct::~CObjectStruct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\user.h
;	COMDAT ??0CObjectStruct@@QAE@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CObjectStruct@@QAE@XZ PROC				; CObjectStruct::CObjectStruct, COMDAT
; _this$ = ecx

; 1372 : 	CObjectStruct()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CObjectStruct@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 1373 : 	{
; 1374 : 		MainObj = new OBJECTSTRUCT[OBJMAX+1];

  00027	68 44 56 e3 06	 push	 115562052		; 06e35644H
  0002c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CObjectStruct@@6B@
  00032	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	85 c0		 test	 eax, eax
  00046	74 25		 je	 SHORT $LN3@CObjectStr
  00048	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  0004d	68 00 00 00 00	 push	 OFFSET ??0OBJECTSTRUCT@@QAE@XZ
  00052	68 ed 2c 00 00	 push	 11501			; 00002cedH
  00057	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  0005a	c7 00 ed 2c 00
	00		 mov	 DWORD PTR [eax], 11501	; 00002cedH
  00060	68 40 27 00 00	 push	 10048			; 00002740H
  00065	56		 push	 esi
  00066	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0006b	eb 02		 jmp	 SHORT $LN4@CObjectStr
$LN3@CObjectStr:
  0006d	33 f6		 xor	 esi, esi
$LN4@CObjectStr:

; 1375 : 		gObj = &MainObj[1];

  0006f	8d 86 40 27 00
	00		 lea	 eax, DWORD PTR [esi+10048]
  00075	89 35 00 00 00
	00		 mov	 DWORD PTR ?MainObj@@3PAUOBJECTSTRUCT@@A, esi ; MainObj
  0007b	a3 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A, eax ; gObj

; 1376 : 	};

  00080	8b c7		 mov	 eax, edi
  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CObjectStruct@@QAE@XZ$0:
  00000	68 44 56 e3 06	 push	 115562052		; 06e35644H
  00005	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__ehhandler$??0CObjectStruct@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CObjectStruct@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CObjectStruct@@QAE@XZ ENDP				; CObjectStruct::CObjectStruct
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillelementinfo.h
;	COMDAT ??0OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0OBJECTSTRUCT@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  0002f	e8 00 00 00 00	 call	 ??0CSkillDelay@@QAE@XZ	; CSkillDelay::CSkillDelay
  00034	8d 8e 78 20 00
	00		 lea	 ecx, DWORD PTR [esi+8312]
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 21   : 		this->Reset();

  00041	e8 00 00 00 00	 call	 ?Reset@TMonsterSkillElementInfo@@QAEXXZ ; TMonsterSkillElementInfo::Reset
  00046	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  0004c	e8 00 00 00 00	 call	 ??0TMonsterAIAgro@@QAE@XZ ; TMonsterAIAgro::TMonsterAIAgro
  00051	8b c6		 mov	 eax, esi
  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	5e		 pop	 esi
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0OBJECTSTRUCT@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??0OBJECTSTRUCT@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0OBJECTSTRUCT@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::OBJECTSTRUCT
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillelementinfo.h
;	COMDAT ??0TMonsterSkillElementInfo@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterSkillElementInfo@@QAE@XZ PROC		; TMonsterSkillElementInfo::TMonsterSkillElementInfo, COMDAT
; _this$ = ecx

; 18   : 	TMonsterSkillElementInfo()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 19   : 	{
; 20   : 		// Reset Data
; 21   : 		this->Reset();

  00003	e8 00 00 00 00	 call	 ?Reset@TMonsterSkillElementInfo@@QAEXXZ ; TMonsterSkillElementInfo::Reset

; 22   : 	}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0TMonsterSkillElementInfo@@QAE@XZ ENDP		; TMonsterSkillElementInfo::TMonsterSkillElementInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	void *_Ptr = 0;
; 56   : 
; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 62   : 		_Xbad_alloc();	// report no memory
; 63   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 73   : 			_Xbad_alloc();	// report no memory
; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 534  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  :         }

  00003	5d		 pop	 ebp

; 535  :             return _time64(_Time);

  00004	e9 00 00 00 00	 jmp	 __time64
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT _localtime
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_localtime PROC						; COMDAT

; 508  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 512  :             #pragma warning(pop)
; 513  :         }

  00003	5d		 pop	 ebp

; 509  :             #pragma warning(push)
; 510  :             #pragma warning(disable: 4996)
; 511  :             return _localtime64(_Time);

  00004	e9 00 00 00 00	 jmp	 __localtime64
_localtime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\bloodcastle.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 4576 : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
