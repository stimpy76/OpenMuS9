; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\TMonsterSkillManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?s_bDataLoad@TMonsterSkillManager@@2HA		; TMonsterSkillManager::s_bDataLoad
_BSS	SEGMENT
?s_bDataLoad@TMonsterSkillManager@@2HA DD 01H DUP (?)	; TMonsterSkillManager::s_bDataLoad
_BSS	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0TMonsterSkillInfo@@QAE@XZ			; TMonsterSkillInfo::TMonsterSkillInfo
PUBLIC	?Reset@TMonsterSkillInfo@@QAEXXZ		; TMonsterSkillInfo::Reset
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	??0_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAE@XZ	; _ST_MONSTER_SKILL_DELAYTIME_INFO::_ST_MONSTER_SKILL_DELAYTIME_INFO
PUBLIC	??0TMonsterSkillManager@@QAE@XZ			; TMonsterSkillManager::TMonsterSkillManager
PUBLIC	??1TMonsterSkillManager@@QAE@XZ			; TMonsterSkillManager::~TMonsterSkillManager
PUBLIC	?LoadData@TMonsterSkillManager@@SAHPAD@Z	; TMonsterSkillManager::LoadData
PUBLIC	?DelAllSkillManagerInfo@TMonsterSkillManager@@SAXXZ ; TMonsterSkillManager::DelAllSkillManagerInfo
PUBLIC	?CheckMonsterSkill@TMonsterSkillManager@@SAHH@Z	; TMonsterSkillManager::CheckMonsterSkill
PUBLIC	?UseMonsterSkill@TMonsterSkillManager@@SAXHHHHPAVCMagicInf@@@Z ; TMonsterSkillManager::UseMonsterSkill
PUBLIC	?FindMonsterSkillUnit@TMonsterSkillManager@@SAPAVTMonsterSkillUnit@@HH@Z ; TMonsterSkillManager::FindMonsterSkillUnit
PUBLIC	?MonsterSkillProc@TMonsterSkillManager@@SAXXZ	; TMonsterSkillManager::MonsterSkillProc
PUBLIC	?AddMonsterSkillDelayInfo@TMonsterSkillManager@@SAHHHHPAVTMonsterSkillUnit@@@Z ; TMonsterSkillManager::AddMonsterSkillDelayInfo
PUBLIC	?FindMagicInf@TMonsterSkillManager@@SA_NPAVTMonsterSkillUnit@@PAVCMagicInf@@@Z ; TMonsterSkillManager::FindMagicInf
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEXPAU_stMonsterIndexInfo@@I@Z ; std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >::deallocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int> >::deallocate
PUBLIC	??1_stZoneInfo@@QAE@XZ				; _stZoneInfo::~_stZoneInfo
PUBLIC	?gGetLowHPMonster@@YAHHHH@Z			; gGetLowHPMonster
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?s_Sync@TMonsterSkillManager@@2VTSync@@A	; TMonsterSkillManager::s_Sync
PUBLIC	?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A ; TMonsterSkillManager::s_MonsterSkillInfoArray
PUBLIC	?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A ; TMonsterSkillManager::s_MonsterSkillDelayInfoArray
PUBLIC	??_C@_0DM@FNGEHCBH@?$FLMonster?5Skill?5Manager?$FN?5?9?5File?5l@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0CJ@MLGACFDE@?$FLMonster?5Skill?5Manager?$FN?5?9?5Can?8t?5@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0DH@IDDBKHCE@?$FLMonster?5Manager?$FN?5?9?5MonsterIndex@ ; `string'
PUBLIC	??_C@_0EB@NICDPOPP@?$FLMonster?5Manager?$FN?5?9?5Invalid?5Skil@ ; `string'
PUBLIC	??_C@_0HH@GONDBIOK@?$KB?$NLIndex?3?$CFd?0Name?3?$CFs?0Count?3?$CFd?0Type@ ; `string'
PUBLIC	??_C@_0CM@BOBBJDPC@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CFs?5fil@ ; `string'
PUBLIC	??_R0K@8					; unsigned long `RTTI Type Descriptor'
PUBLIC	??_C@_0DO@MGDDNBGB@?$FLMonster?5Skill?5Manager?$FN?5?9?5Loadin@ ; `string'
PUBLIC	??_C@_0DP@OCKDOEEK@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CIMonst@ ; `string'
PUBLIC	??_C@_0DL@ENELDMAN@?$FLTMonsterSkillManager?$FN?$FLUserMonst@ ; `string'
PUBLIC	??_C@_0EB@PGJFMLKA@?$FLTMonsterSkillManager?$FN?$FLUserMonst@ ; `string'
PUBLIC	??_C@_0EN@PFFOMJLG@?$FLMonster?5Skill?5Manager?$FN?5SkillUni@ ; `string'
PUBLIC	??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; `string'
PUBLIC	__real@42c80000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??0TSync@@QAE@XZ:PROC				; TSync::TSync
EXTRN	??1TSync@@QAE@XZ:PROC				; TSync::~TSync
EXTRN	?RunSkill@TMonsterSkillUnit@@QAEXHH@Z:PROC	; TMonsterSkillUnit::RunSkill
EXTRN	?FindSkillUnit@TMonsterSkillUnit@@SAPAV1@H@Z:PROC ; TMonsterSkillUnit::FindSkillUnit
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z:PROC ; GCUseMonsterSkillSend
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z:PROC ; gObjAttack
EXTRN	?GetZoneInfo@CImperialGuardian@@QAE?AU_stZoneInfo@@H@Z:PROC ; CImperialGuardian::GetZoneInfo
EXTRN	?GetAngle@CObjUseSkill@@QAEHHHHH@Z:PROC		; CObjUseSkill::GetAngle
EXTRN	?HitCheck@CSkillHitBox@@QAEHHHHHH@Z:PROC	; CSkillHitBox::HitCheck
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?g_ImperialGuardian@@3VCImperialGuardian@@A:BYTE ; g_ImperialGuardian
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?SkillElectricSparkHitBox@@3VCSkillHitBox@@A:BYTE ; SkillElectricSparkHitBox
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?s_Sync@TMonsterSkillManager@@2VTSync@@A DB 01cH DUP (?) ; TMonsterSkillManager::s_Sync
?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A DB 016000H DUP (?) ; TMonsterSkillManager::s_MonsterSkillInfoArray
?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A DB 0ea60H DUP (?) ; TMonsterSkillManager::s_MonsterSkillDelayInfoArray
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
_BSS	ENDS
CRT$XCU	SEGMENT
??s_MonsterSkillInfoArray$initializer$@TMonsterSkillManager@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A@@YAXXZ ; ??s_MonsterSkillInfoArray$initializer$@TMonsterSkillManager@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
CONST	SEGMENT
??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ DB 'invalid v'
	DB	'ector<T> subscript', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@PFFOMJLG@?$FLMonster?5Skill?5Manager?$FN?5SkillUni@
CONST	SEGMENT
??_C@_0EN@PFFOMJLG@?$FLMonster?5Skill?5Manager?$FN?5SkillUni@ DB '[Monste'
	DB	'r Skill Manager] SkillUnit is NULL : ObjIndex[%d], SkillUnitT'
	DB	'ype[%d] ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@PGJFMLKA@?$FLTMonsterSkillManager?$FN?$FLUserMonst@
CONST	SEGMENT
??_C@_0EB@PGJFMLKA@?$FLTMonsterSkillManager?$FN?$FLUserMonst@ DB '[TMonst'
	DB	'erSkillManager][UserMonsterSkill] error: iTargetIndex(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@ENELDMAN@?$FLTMonsterSkillManager?$FN?$FLUserMonst@
CONST	SEGMENT
??_C@_0DL@ENELDMAN@?$FLTMonsterSkillManager?$FN?$FLUserMonst@ DB '[TMonst'
	DB	'erSkillManager][UserMonsterSkill] error: iIndex(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@OCKDOEEK@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CIMonst@
CONST	SEGMENT
??_C@_0DP@OCKDOEEK@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CIMonst@ DB '[M'
	DB	'onster Skill Manager] - (MonsterSkillDelayInfo) Slot Full!! ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@MGDDNBGB@?$FLMonster?5Skill?5Manager?$FN?5?9?5Loadin@
CONST	SEGMENT
??_C@_0DO@MGDDNBGB@?$FLMonster?5Skill?5Manager?$FN?5?9?5Loadin@ DB '[Mons'
	DB	'ter Skill Manager] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0K@8
data$r	SEGMENT
??_R0K@8 DD	FLAT:??_7type_info@@6B@			; unsigned long `RTTI Type Descriptor'
	DD	00H
	DB	'.K', 00H
data$r	ENDS
;	COMDAT ??_C@_0CM@BOBBJDPC@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CFs?5fil@
CONST	SEGMENT
??_C@_0CM@BOBBJDPC@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CFs?5fil@ DB '['
	DB	'Monster Skill Manager] - %s file is Loaded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HH@GONDBIOK@?$KB?$NLIndex?3?$CFd?0Name?3?$CFs?0Count?3?$CFd?0Type@
CONST	SEGMENT
??_C@_0HH@GONDBIOK@?$KB?$NLIndex?3?$CFd?0Name?3?$CFs?0Count?3?$CFd?0Type@ DB 0a1H
	DB	0dbH, 'Index:%d,Name:%s,Count:%d,Type0:%d,Unit0:%d,Type1:%d,Un'
	DB	'it1:%d,Type2:%d,Unit2:%d,Type3:%d,Unit3:%d,Type4:%d,Unit4:%d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@NICDPOPP@?$FLMonster?5Manager?$FN?5?9?5Invalid?5Skil@
CONST	SEGMENT
??_C@_0EB@NICDPOPP@?$FLMonster?5Manager?$FN?5?9?5Invalid?5Skil@ DB '[Mons'
	DB	'ter Manager] - Invalid SkillInfo : MIndex(%s/%d) (%s) File.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IDDBKHCE@?$FLMonster?5Manager?$FN?5?9?5MonsterIndex@
CONST	SEGMENT
??_C@_0DH@IDDBKHCE@?$FLMonster?5Manager?$FN?5?9?5MonsterIndex@ DB '[Monst'
	DB	'er Manager] - MonsterIndex(%d) Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MLGACFDE@?$FLMonster?5Skill?5Manager?$FN?5?9?5Can?8t?5@
CONST	SEGMENT
??_C@_0CJ@MLGACFDE@?$FLMonster?5Skill?5Manager?$FN?5?9?5Can?8t?5@ DB '[Mo'
	DB	'nster Skill Manager] - Can''t Open %s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@FNGEHCBH@?$FLMonster?5Skill?5Manager?$FN?5?9?5File?5l@
CONST	SEGMENT
??_C@_0DM@FNGEHCBH@?$FLMonster?5Skill?5Manager?$FN?5?9?5File?5l@ DB '[Mon'
	DB	'ster Skill Manager] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?gGetLowHPMonster@@YAHHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?gGetLowHPMonster@@YAHHHH@Z$1
__ehfuncinfo$?gGetLowHPMonster@@YAHHHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?gGetLowHPMonster@@YAHHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoadData@TMonsterSkillManager@@SAHPAD@Z$2 DD 00H
	DD	FLAT:??_R0K@8
	DD	00H
	DD	FLAT:__catch$?LoadData@TMonsterSkillManager@@SAHPAD@Z$0
__unwindtable$?LoadData@TMonsterSkillManager@@SAHPAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?LoadData@TMonsterSkillManager@@SAHPAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?LoadData@TMonsterSkillManager@@SAHPAD@Z$2
__ehfuncinfo$?LoadData@TMonsterSkillManager@@SAHPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LoadData@TMonsterSkillManager@@SAHPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadData@TMonsterSkillManager@@SAHPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
??s_MonsterSkillDelayInfoArray$initializer$@TMonsterSkillManager@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A@@YAXXZ ; ??s_MonsterSkillDelayInfoArray$initializer$@TMonsterSkillManager@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??s_Sync$initializer$@TMonsterSkillManager@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ ; ??s_Sync$initializer$@TMonsterSkillManager@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_stMonsterIndexInfo@@@?$allocator@U_stMonsterIndexInfo@@@std@@QAEXPAU_stMonsterIndexInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_stMonsterIndexInfo@@@?$allocator@U_stMonsterIndexInfo@@@std@@QAEXPAU_stMonsterIndexInfo@@@Z PROC ; std::allocator<_stMonsterIndexInfo>::destroy<_stMonsterIndexInfo>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U_stMonsterIndexInfo@@@?$allocator@U_stMonsterIndexInfo@@@std@@QAEXPAU_stMonsterIndexInfo@@@Z ENDP ; std::allocator<_stMonsterIndexInfo>::destroy<_stMonsterIndexInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_stMonsterIndexInfo@@@?$allocator_traits@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@SAXAAV?$allocator@U_stMonsterIndexInfo@@@1@PAU_stMonsterIndexInfo@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_stMonsterIndexInfo@@@?$allocator_traits@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@SAXAAV?$allocator@U_stMonsterIndexInfo@@@1@PAU_stMonsterIndexInfo@@@Z PROC ; std::allocator_traits<std::allocator<_stMonsterIndexInfo> >::destroy<_stMonsterIndexInfo>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@U_stMonsterIndexInfo@@@?$allocator_traits@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@SAXAAV?$allocator@U_stMonsterIndexInfo@@@1@PAU_stMonsterIndexInfo@@@Z ENDP ; std::allocator_traits<std::allocator<_stMonsterIndexInfo> >::destroy<_stMonsterIndexInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@U_stMonsterIndexInfo@@@std@@YAPAU_stMonsterIndexInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@U_stMonsterIndexInfo@@@std@@YAPAU_stMonsterIndexInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<_stMonsterIndexInfo>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@U_stMonsterIndexInfo@@@std@@YAPAU_stMonsterIndexInfo@@AAU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<_stMonsterIndexInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_stMonsterIndexInfo@@@?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEXPAU_stMonsterIndexInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_stMonsterIndexInfo@@@?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEXPAU_stMonsterIndexInfo@@@Z PROC ; std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >::destroy<_stMonsterIndexInfo>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@U_stMonsterIndexInfo@@@?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEXPAU_stMonsterIndexInfo@@@Z ENDP ; std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >::destroy<_stMonsterIndexInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U_stMonsterIndexInfo@@@std@@YAPAU_stMonsterIndexInfo@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_stMonsterIndexInfo@@@std@@YAPAU_stMonsterIndexInfo@@AAU1@@Z PROC ; std::addressof<_stMonsterIndexInfo>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U_stMonsterIndexInfo@@@std@@YAPAU_stMonsterIndexInfo@@AAU1@@Z ENDP ; std::addressof<_stMonsterIndexInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@YAXPAU_stMonsterIndexInfo@@0AAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@YAXPAU_stMonsterIndexInfo@@0AAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> > >, COMDAT

; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@YAXPAU_stMonsterIndexInfo@@0AAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@U_stMonsterIndexInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU_stMonsterIndexInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@U_stMonsterIndexInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU_stMonsterIndexInfo@@0@Z PROC ; std::_Ptr_cat<_stMonsterIndexInfo,_stMonsterIndexInfo>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@U_stMonsterIndexInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU_stMonsterIndexInfo@@0@Z ENDP ; std::_Ptr_cat<_stMonsterIndexInfo,_stMonsterIndexInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int> > >, COMDAT

; 180  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z PROC ; std::_Ptr_cat<int,int>, COMDAT

; 640  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 641  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 642  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 643  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ENDP ; std::_Ptr_cat<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@YAXPAU_stMonsterIndexInfo@@0AAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@YAXPAU_stMonsterIndexInfo@@0AAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> > >, COMDAT

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@YAXPAU_stMonsterIndexInfo@@0AAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int> > >, COMDAT

; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?gGetLowHPMonster@@YAHHHH@Z
_TEXT	SEGMENT
$T2 = -228						; size = 100
$T3 = -128						; size = 100
_nMonsterCount$1$ = -28					; size = 4
_monsterInfo$1$ = -24					; size = 4
_monsterInfo$2$ = -20					; size = 4
_lpObj$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_nZoneIndex$ = 8					; size = 4
_nTargetIndex$1$ = 12					; size = 4
_nIndex$ = 12						; size = 4
_nDistance$ = 16					; size = 4
?gGetLowHPMonster@@YAHHHH@Z PROC			; gGetLowHPMonster, COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?gGetLowHPMonster@@YAHHHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 289  : 	LPOBJ lpObj = &gObj[nIndex];

  0002b	69 45 0c 40 27
	00 00		 imul	 eax, DWORD PTR _nIndex$[ebp], 10048

; 293  : 	int nMonsterCount = g_ImperialGuardian.GetZoneInfo(nZoneIndex).m_vtMonsterIndexInfo.size();

  00032	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  00037	ff 75 08	 push	 DWORD PTR _nZoneIndex$[ebp]
  0003a	c7 45 0c ff ff
	ff ff		 mov	 DWORD PTR _nTargetIndex$1$[ebp], -1
  00041	33 ff		 xor	 edi, edi
  00043	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00049	89 45 f0	 mov	 DWORD PTR _lpObj$1$[ebp], eax
  0004c	8d 45 80	 lea	 eax, DWORD PTR $T3[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?GetZoneInfo@CImperialGuardian@@QAE?AU_stZoneInfo@@H@Z ; CImperialGuardian::GetZoneInfo
  00055	8d 4d 80	 lea	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00058	8b 58 20	 mov	 ebx, DWORD PTR [eax+32]
  0005b	2b 58 1c	 sub	 ebx, DWORD PTR [eax+28]
  0005e	c1 fb 03	 sar	 ebx, 3
  00061	89 5d e4	 mov	 DWORD PTR _nMonsterCount$1$[ebp], ebx
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 293  : 	int nMonsterCount = g_ImperialGuardian.GetZoneInfo(nZoneIndex).m_vtMonsterIndexInfo.size();

  00064	e8 00 00 00 00	 call	 ??1_stZoneInfo@@QAE@XZ

; 294  : 
; 295  : 	for( int i = 0; i < nMonsterCount; i++)

  00069	33 f6		 xor	 esi, esi
  0006b	85 db		 test	 ebx, ebx
  0006d	0f 8e c4 00 00
	00		 jle	 $LN3@gGetLowHPM
  00073	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL4@gGetLowHPM:

; 297  : 		_stMonsterIndexInfo monsterInfo = g_ImperialGuardian.GetZoneInfo(nZoneIndex).m_vtMonsterIndexInfo.at(i);

  00080	ff 75 08	 push	 DWORD PTR _nZoneIndex$[ebp]
  00083	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00089	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?GetZoneInfo@CImperialGuardian@@QAE?AU_stZoneInfo@@H@Z ; CImperialGuardian::GetZoneInfo
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00094	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00097	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0009a	2b c1		 sub	 eax, ecx
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 297  : 		_stMonsterIndexInfo monsterInfo = g_ImperialGuardian.GetZoneInfo(nZoneIndex).m_vtMonsterIndexInfo.at(i);

  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  000a3	c1 f8 03	 sar	 eax, 3

; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)

  000a6	3b c6		 cmp	 eax, esi
  000a8	0f 86 9e 00 00
	00		 jbe	 $LN71@gGetLowHPM
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 297  : 		_stMonsterIndexInfo monsterInfo = g_ImperialGuardian.GetZoneInfo(nZoneIndex).m_vtMonsterIndexInfo.at(i);

  000ae	8b 1c f1	 mov	 ebx, DWORD PTR [ecx+esi*8]
  000b1	8b 44 f1 04	 mov	 eax, DWORD PTR [ecx+esi*8+4]
  000b5	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000bb	89 5d e8	 mov	 DWORD PTR _monsterInfo$1$[ebp], ebx
  000be	89 45 ec	 mov	 DWORD PTR _monsterInfo$2$[ebp], eax
  000c1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c8	e8 00 00 00 00	 call	 ??1_stZoneInfo@@QAE@XZ

; 298  : 
; 299  : 		if( gObjCalDistance(lpObj,&gObj[monsterInfo.m_iIndex]) < nDistance &&

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d2	69 db 40 27 00
	00		 imul	 ebx, ebx, 10048
  000d8	03 c3		 add	 eax, ebx
  000da	50		 push	 eax
  000db	ff 75 f0	 push	 DWORD PTR _lpObj$1$[ebp]
  000de	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000e3	83 c4 08	 add	 esp, 8
  000e6	3b 45 10	 cmp	 eax, DWORD PTR _nDistance$[ebp]
  000e9	7d 42		 jge	 SHORT $LN2@gGetLowHPM
  000eb	80 7d ec 00	 cmp	 BYTE PTR _monsterInfo$2$[ebp], 0
  000ef	74 3c		 je	 SHORT $LN2@gGetLowHPM

; 300  : 			monsterInfo.m_bLiveMonster )
; 301  : 		{
; 302  : 			nTempTargetLife = (gObj[monsterInfo.m_iIndex].Life / gObj[monsterInfo.m_iIndex].MaxLife)*100.0f;

  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f6	f3 0f 10 84 03
	d8 00 00 00	 movss	 xmm0, DWORD PTR [ebx+eax+216]
  000ff	f3 0f 5e 84 03
	dc 00 00 00	 divss	 xmm0, DWORD PTR [ebx+eax+220]
  00108	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42c80000
  00110	f3 0f 2c c0	 cvttss2si eax, xmm0

; 303  : 
; 304  : 			if( nTempTargetLife < nTargetLife || nTargetLife == 0 )

  00114	3b c7		 cmp	 eax, edi
  00116	7c 04		 jl	 SHORT $LN7@gGetLowHPM
  00118	85 ff		 test	 edi, edi
  0011a	75 11		 jne	 SHORT $LN2@gGetLowHPM
$LN7@gGetLowHPM:

; 305  : 			{
; 306  : 				if(  nTempTargetLife != 100 && nTempTargetLife > 0 )

  0011c	83 f8 64	 cmp	 eax, 100		; 00000064H
  0011f	74 0c		 je	 SHORT $LN2@gGetLowHPM
  00121	85 c0		 test	 eax, eax
  00123	7e 08		 jle	 SHORT $LN2@gGetLowHPM

; 307  : 				{
; 308  : 					nTargetLife = nTempTargetLife;

  00125	8b f8		 mov	 edi, eax

; 309  : 					nTargetIndex = monsterInfo.m_iIndex;

  00127	8b 45 e8	 mov	 eax, DWORD PTR _monsterInfo$1$[ebp]
  0012a	89 45 0c	 mov	 DWORD PTR _nTargetIndex$1$[ebp], eax
$LN2@gGetLowHPM:

; 294  : 
; 295  : 	for( int i = 0; i < nMonsterCount; i++)

  0012d	46		 inc	 esi
  0012e	3b 75 e4	 cmp	 esi, DWORD PTR _nMonsterCount$1$[ebp]
  00131	0f 8c 49 ff ff
	ff		 jl	 $LL4@gGetLowHPM
$LN3@gGetLowHPM:

; 310  : 				}
; 311  : 			}
; 312  : 		}
; 313  : 	}
; 314  : 	return nTargetIndex;

  00137	8b 45 0c	 mov	 eax, DWORD PTR _nTargetIndex$1$[ebp]

; 315  : }

  0013a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00144	59		 pop	 ecx
  00145	5f		 pop	 edi
  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
$LN71@gGetLowHPM:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1789 : 		_Xout_of_range("invalid vector<T> subscript");

  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
  00151	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN77@gGetLowHPM:
$LN76@gGetLowHPM:
  00156	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?gGetLowHPMonster@@YAHHHH@Z$1:
  00000	8d 8d 1c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1_stZoneInfo@@QAE@XZ
__ehhandler$?gGetLowHPMonster@@YAHHHH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?gGetLowHPMonster@@YAHHHH@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?gGetLowHPMonster@@YAHHHH@Z ENDP			; gGetLowHPMonster
; Function compile flags: /Ogtp
;	COMDAT ??__F?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ
text$yd	SEGMENT
??__F?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'TMonsterSkillManager::s_Sync'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_Sync@TMonsterSkillManager@@2VTSync@@A ; TMonsterSkillManager::s_Sync
  00005	e9 00 00 00 00	 jmp	 ??1TSync@@QAE@XZ	; TSync::~TSync
??__F?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'TMonsterSkillManager::s_Sync''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ??__E?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ
text$di	SEGMENT
??__E?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterSkillManager::s_Sync'', COMDAT

; 18   : TSync TMonsterSkillManager::s_Sync;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_Sync@TMonsterSkillManager@@2VTSync@@A ; TMonsterSkillManager::s_Sync
  00005	e8 00 00 00 00	 call	 ??0TSync@@QAE@XZ	; TSync::TSync
  0000a	68 00 00 00 00	 push	 OFFSET ??__F?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ ; `dynamic atexit destructor for 'TMonsterSkillManager::s_Sync''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E?s_Sync@TMonsterSkillManager@@2VTSync@@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterSkillManager::s_Sync''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ??__E?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A@@YAXXZ
text$di	SEGMENT
??__E?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterSkillManager::s_MonsterSkillDelayInfoArray'', COMDAT

; 17   : _ST_MONSTER_SKILL_DELAYTIME_INFO TMonsterSkillManager::s_MonsterSkillDelayInfoArray[MAX_MONSTER_SKILL_DELAY_INFO_ARRAY];

  00000	b9 b8 0b 00 00	 mov	 ecx, 3000		; 00000bb8H
  00005	b8 08 00 00 00	 mov	 eax, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+8
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL4@s_MonsterS:
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h

; 24   : 		this->iIndex = -1;

  00010	c7 40 fc ff ff
	ff ff		 mov	 DWORD PTR [eax-4], -1
  00017	8d 40 14	 lea	 eax, DWORD PTR [eax+20]

; 25   : 		this->iTargetIndex = -1;

  0001a	c7 40 ec ff ff
	ff ff		 mov	 DWORD PTR [eax-20], -1

; 26   : 		this->dwDelayTime = 0;

  00021	c7 40 f0 00 00
	00 00		 mov	 DWORD PTR [eax-16], 0

; 27   : 		this->bIsUsed = FALSE;

  00028	c7 40 e4 00 00
	00 00		 mov	 DWORD PTR [eax-28], 0

; 28   : 		this->lpMonsterSkillUnit = NULL;

  0002f	c7 40 f4 00 00
	00 00		 mov	 DWORD PTR [eax-12], 0
  00036	83 e9 01	 sub	 ecx, 1
  00039	75 d5		 jne	 SHORT $LL4@s_MonsterS
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 17   : _ST_MONSTER_SKILL_DELAYTIME_INFO TMonsterSkillManager::s_MonsterSkillDelayInfoArray[MAX_MONSTER_SKILL_DELAY_INFO_ARRAY];

  0003b	c3		 ret	 0
??__E?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterSkillManager::s_MonsterSkillDelayInfoArray''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ??__E?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A@@YAXXZ
text$di	SEGMENT
??__E?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A@@YAXXZ PROC ; `dynamic initializer for 'TMonsterSkillManager::s_MonsterSkillInfoArray'', COMDAT

; 16   : TMonsterSkillInfo TMonsterSkillManager::s_MonsterSkillInfoArray[MAX_MONSTER_SKILL_INFO_ARRAY];

  00000	56		 push	 esi
  00001	be 00 04 00 00	 mov	 esi, 1024		; 00000400H
  00006	ba 30 00 00 00	 mov	 edx, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A+48
  0000b	0f 1f 44 00 00	 npad	 5
$LL4@s_MonsterS:
  00010	4e		 dec	 esi
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h

; 28   : 		this->m_iMonsterIndex = -1;

  00011	c7 42 d0 ff ff
	ff ff		 mov	 DWORD PTR [edx-48], -1

; 29   : 		this->m_iSkillUnitCount = 0;

  00018	c7 42 d4 00 00
	00 00		 mov	 DWORD PTR [edx-44], 0
  0001f	8b c2		 mov	 eax, edx
  00021	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
$LL12@s_MonsterS:

; 30   : 
; 31   : 		for ( int i=0;i<MAX_SKILL_UNIT;i++)
; 32   : 		{
; 33   : 			this->m_iSkillUnitTypeArray[i] = -1;

  00026	c7 40 d8 ff ff
	ff ff		 mov	 DWORD PTR [eax-40], -1
  0002d	8d 40 04	 lea	 eax, DWORD PTR [eax+4]

; 34   : 			this->m_lpSkillUnitArray[i] = NULL;

  00030	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [eax-4], 0
  00037	83 e9 01	 sub	 ecx, 1
  0003a	75 ea		 jne	 SHORT $LL12@s_MonsterS
  0003c	83 c2 58	 add	 edx, 88			; 00000058H
  0003f	85 f6		 test	 esi, esi
  00041	75 cd		 jne	 SHORT $LL4@s_MonsterS
  00043	5e		 pop	 esi
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 16   : TMonsterSkillInfo TMonsterSkillManager::s_MonsterSkillInfoArray[MAX_MONSTER_SKILL_INFO_ARRAY];

  00044	c3		 ret	 0
??__E?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A@@YAXXZ ENDP ; `dynamic initializer for 'TMonsterSkillManager::s_MonsterSkillInfoArray''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	int ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA, 0
  00017	53		 push	 ebx
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8b d8		 mov	 ebx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	83 fb ff	 cmp	 ebx, -1
  00033	74 5d		 je	 SHORT $LN43@GetToken

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)
; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  00038	75 30		 jne	 SHORT $LN2@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00040	e8 00 00 00 00	 call	 _fgetc
  00045	8b d8		 mov	 ebx, eax
  00047	83 c4 04	 add	 esp, 4
  0004a	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  0004d	75 1b		 jne	 SHORT $LN2@GetToken
  0004f	90		 npad	 1
$LL5@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	83 fb ff	 cmp	 ebx, -1
  00053	74 3d		 je	 SHORT $LN43@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0005b	e8 00 00 00 00	 call	 _fgetc
  00060	8b d8		 mov	 ebx, eax
  00062	83 c4 04	 add	 esp, 4
  00065	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00068	75 e6		 jne	 SHORT $LL5@GetToken
$LN2@GetToken:

; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006a	53		 push	 ebx
  0006b	e8 00 00 00 00	 call	 _isspace
  00070	83 c4 04	 add	 esp, 4
  00073	85 c0		 test	 eax, eax
  00075	75 a9		 jne	 SHORT $LL4@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00077	8d 43 de	 lea	 eax, DWORD PTR [ebx-34]
  0007a	56		 push	 esi
  0007b	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  0007e	0f 87 89 01 00
	00		 ja	 $LN29@GetToken
  00084	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN58@GetToken[eax]
  0008b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN64@GetToken[eax*4]
$LN43@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE

  00092	b8 02 00 00 00	 mov	 eax, 2
  00097	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	33 cd		 xor	 ecx, ebp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN20@GetToken:
  000a6	5e		 pop	 esi

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000a7	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  000b1	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b6	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
$LN21@GetToken:
  000c5	5e		 pop	 esi

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000c6	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  000d0	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000d5	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN22@GetToken:
  000e4	5e		 pop	 esi

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000e5	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  000ef	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000f4	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f8	33 cd		 xor	 ecx, ebp
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN23@GetToken:
  00103	5e		 pop	 esi

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  00104	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0010e	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  00113	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00114	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00117	33 cd		 xor	 ecx, ebp
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN24@GetToken:
  00122	5e		 pop	 esi

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  00123	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  0012d	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  00132	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
$LN25@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  00141	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00147	53		 push	 ebx
  00148	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  0014d	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00153	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  00156	e8 00 00 00 00	 call	 _getc
  0015b	8b d8		 mov	 ebx, eax
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00160	83 fb ff	 cmp	 ebx, -1
  00163	74 2f		 je	 SHORT $LN59@GetToken
$LL9@GetToken:
  00165	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00168	74 12		 je	 SHORT $LN26@GetToken
  0016a	53		 push	 ebx
  0016b	e8 00 00 00 00	 call	 _isdigit
  00170	83 c4 04	 add	 esp, 4
  00173	85 c0		 test	 eax, eax
  00175	75 05		 jne	 SHORT $LN26@GetToken
  00177	83 fb 2d	 cmp	 ebx, 45			; 0000002dH
  0017a	75 18		 jne	 SHORT $LN59@GetToken
$LN26@GetToken:
  0017c	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00182	88 1e		 mov	 BYTE PTR [esi], bl

; 102  : 			p++;

  00184	46		 inc	 esi
  00185	e8 00 00 00 00	 call	 _getc
  0018a	8b d8		 mov	 ebx, eax
  0018c	83 c4 04	 add	 esp, 4
  0018f	83 fb ff	 cmp	 ebx, -1
  00192	75 d1		 jne	 SHORT $LL9@GetToken
$LN59@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = (float)atof( TempString);	// Select the first Byte as Main ID

  00194	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  00197	c6 06 00	 mov	 BYTE PTR [esi], 0
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _atof
  001a0	83 c4 04	 add	 esp, 4

; 106  : 		return CurrentToken  = NUMBER ;

  001a3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  001ad	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA
  001b3	b8 01 00 00 00	 mov	 eax, 1
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  001ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bd	33 cd		 xor	 ecx, ebp
  001bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$LN27@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  001c8	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  001ce	be 00 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA
  001d3	e8 00 00 00 00	 call	 _getc
  001d8	83 c4 04	 add	 esp, 4
  001db	83 f8 ff	 cmp	 eax, -1
  001de	74 1f		 je	 SHORT $LN12@GetToken
$LL11@GetToken:
  001e0	83 f8 22	 cmp	 eax, 34			; 00000022H
  001e3	0f 84 95 00 00
	00		 je	 $LN28@GetToken
  001e9	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 113  : 		{
; 114  : 			*p = ch;

  001ef	88 06		 mov	 BYTE PTR [esi], al

; 115  : 			p++;

  001f1	46		 inc	 esi
  001f2	e8 00 00 00 00	 call	 _getc
  001f7	83 c4 04	 add	 esp, 4
  001fa	83 f8 ff	 cmp	 eax, -1
  001fd	75 e1		 jne	 SHORT $LL11@GetToken
$LN12@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001ff	83 f8 22	 cmp	 eax, 34			; 00000022H
  00202	74 7a		 je	 SHORT $LN28@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  00204	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0020a	50		 push	 eax

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  0020b	eb 69		 jmp	 SHORT $LN62@GetToken
$LN29@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  0020d	53		 push	 ebx
  0020e	e8 00 00 00 00	 call	 _isalpha
  00213	83 c4 04	 add	 esp, 4
  00216	85 c0		 test	 eax, eax
  00218	0f 84 7f 00 00
	00		 je	 $LN30@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  0021e	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00224	88 1d 00 00 00
	00		 mov	 BYTE PTR ?TokenString@@3PADA, bl
  0022a	be 01 00 00 00	 mov	 esi, OFFSET ?TokenString@@3PADA+1
  0022f	e8 00 00 00 00	 call	 _getc
  00234	8b d8		 mov	 ebx, eax
  00236	83 c4 04	 add	 esp, 4
  00239	83 fb ff	 cmp	 ebx, -1
  0023c	74 31		 je	 SHORT $LN60@GetToken
  0023e	66 90		 npad	 2
$LL13@GetToken:
  00240	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00243	74 12		 je	 SHORT $LN32@GetToken
  00245	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00248	74 0d		 je	 SHORT $LN32@GetToken
  0024a	53		 push	 ebx
  0024b	e8 00 00 00 00	 call	 _isalnum
  00250	83 c4 04	 add	 esp, 4
  00253	85 c0		 test	 eax, eax
  00255	74 18		 je	 SHORT $LN60@GetToken
$LN32@GetToken:
  00257	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A

; 133  : 			{
; 134  : 				*p=ch;

  0025d	88 1e		 mov	 BYTE PTR [esi], bl

; 135  : 				p++;

  0025f	46		 inc	 esi
  00260	e8 00 00 00 00	 call	 _getc
  00265	8b d8		 mov	 ebx, eax
  00267	83 c4 04	 add	 esp, 4
  0026a	83 fb ff	 cmp	 ebx, -1
  0026d	75 d1		 jne	 SHORT $LL13@GetToken
$LN60@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0026f	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00275	53		 push	 ebx
$LN62@GetToken:
  00276	e8 00 00 00 00	 call	 _ungetc
  0027b	83 c4 08	 add	 esp, 8
$LN28@GetToken:

; 140  : 			*p=0;

  0027e	c6 06 00	 mov	 BYTE PTR [esi], 0

; 141  : 			CurrentToken=NAME;
; 142  : 			return CurrentToken;

  00281	33 c0		 xor	 eax, eax
  00283	5e		 pop	 esi
  00284	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0028e	5b		 pop	 ebx

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'
; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0028f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00292	33 cd		 xor	 ecx, ebp
  00294	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00299	8b e5		 mov	 esp, ebp
  0029b	5d		 pop	 ebp
  0029c	c3		 ret	 0
$LN30@GetToken:
  0029d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a0	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  002a5	5e		 pop	 esi
  002a6	33 cd		 xor	 ecx, ebp
  002a8	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  002b2	5b		 pop	 ebx
  002b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
$LN64@GetToken:
  002bc	00 00 00 00	 DD	 $LN27@GetToken
  002c0	00 00 00 00	 DD	 $LN20@GetToken
  002c4	00 00 00 00	 DD	 $LN22@GetToken
  002c8	00 00 00 00	 DD	 $LN25@GetToken
  002cc	00 00 00 00	 DD	 $LN21@GetToken
  002d0	00 00 00 00	 DD	 $LN23@GetToken
  002d4	00 00 00 00	 DD	 $LN24@GetToken
  002d8	00 00 00 00	 DD	 $LN29@GetToken
$LN58@GetToken:
  002dc	00		 DB	 0
  002dd	01		 DB	 1
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	07		 DB	 7
  002e2	07		 DB	 7
  002e3	07		 DB	 7
  002e4	07		 DB	 7
  002e5	07		 DB	 7
  002e6	02		 DB	 2
  002e7	03		 DB	 3
  002e8	03		 DB	 3
  002e9	07		 DB	 7
  002ea	03		 DB	 3
  002eb	03		 DB	 3
  002ec	03		 DB	 3
  002ed	03		 DB	 3
  002ee	03		 DB	 3
  002ef	03		 DB	 3
  002f0	03		 DB	 3
  002f1	03		 DB	 3
  002f2	03		 DB	 3
  002f3	03		 DB	 3
  002f4	07		 DB	 7
  002f5	04		 DB	 4
  002f6	07		 DB	 7
  002f7	07		 DB	 7
  002f8	07		 DB	 7
  002f9	07		 DB	 7
  002fa	07		 DB	 7
  002fb	07		 DB	 7
  002fc	07		 DB	 7
  002fd	07		 DB	 7
  002fe	07		 DB	 7
  002ff	07		 DB	 7
  00300	07		 DB	 7
  00301	07		 DB	 7
  00302	07		 DB	 7
  00303	07		 DB	 7
  00304	07		 DB	 7
  00305	07		 DB	 7
  00306	07		 DB	 7
  00307	07		 DB	 7
  00308	07		 DB	 7
  00309	07		 DB	 7
  0030a	07		 DB	 7
  0030b	07		 DB	 7
  0030c	07		 DB	 7
  0030d	07		 DB	 7
  0030e	07		 DB	 7
  0030f	07		 DB	 7
  00310	07		 DB	 7
  00311	07		 DB	 7
  00312	07		 DB	 7
  00313	07		 DB	 7
  00314	07		 DB	 7
  00315	07		 DB	 7
  00316	07		 DB	 7
  00317	07		 DB	 7
  00318	07		 DB	 7
  00319	07		 DB	 7
  0031a	07		 DB	 7
  0031b	07		 DB	 7
  0031c	07		 DB	 7
  0031d	07		 DB	 7
  0031e	07		 DB	 7
  0031f	07		 DB	 7
  00320	07		 DB	 7
  00321	07		 DB	 7
  00322	07		 DB	 7
  00323	07		 DB	 7
  00324	07		 DB	 7
  00325	07		 DB	 7
  00326	07		 DB	 7
  00327	07		 DB	 7
  00328	07		 DB	 7
  00329	07		 DB	 7
  0032a	07		 DB	 7
  0032b	07		 DB	 7
  0032c	07		 DB	 7
  0032d	07		 DB	 7
  0032e	07		 DB	 7
  0032f	07		 DB	 7
  00330	07		 DB	 7
  00331	07		 DB	 7
  00332	07		 DB	 7
  00333	07		 DB	 7
  00334	07		 DB	 7
  00335	05		 DB	 5
  00336	07		 DB	 7
  00337	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1_stZoneInfo@@QAE@XZ
_TEXT	SEGMENT
??1_stZoneInfo@@QAE@XZ PROC				; _stZoneInfo::~_stZoneInfo, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00004	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00007	85 c9		 test	 ecx, ecx
  00009	74 27		 je	 SHORT $LN7@stZoneInfo

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  0000b	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0000e	2b c1		 sub	 eax, ecx
  00010	c1 f8 02	 sar	 eax, 2
  00013	50		 push	 eax
  00014	51		 push	 ecx
  00015	8d 4f 58	 lea	 ecx, DWORD PTR [edi+88]
  00018	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0001d	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0

; 1663 : 			this->_Mylast() = pointer();

  00024	c7 47 5c 00 00
	00 00		 mov	 DWORD PTR [edi+92], 0

; 1664 : 			this->_Myend() = pointer();

  0002b	c7 47 60 00 00
	00 00		 mov	 DWORD PTR [edi+96], 0
$LN7@stZoneInfo:

; 1656 : 		if (this->_Myfirst() != pointer())

  00032	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00035	85 c9		 test	 ecx, ecx
  00037	74 27		 je	 SHORT $LN100@stZoneInfo

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00039	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  0003c	2b c1		 sub	 eax, ecx
  0003e	c1 f8 02	 sar	 eax, 2
  00041	50		 push	 eax
  00042	51		 push	 ecx
  00043	8d 4f 34	 lea	 ecx, DWORD PTR [edi+52]
  00046	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0004b	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0

; 1663 : 			this->_Mylast() = pointer();

  00052	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0

; 1664 : 			this->_Myend() = pointer();

  00059	c7 47 3c 00 00
	00 00		 mov	 DWORD PTR [edi+60], 0
$LN100@stZoneInfo:

; 1656 : 		if (this->_Myfirst() != pointer())

  00060	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00063	85 c9		 test	 ecx, ecx
  00065	74 27		 je	 SHORT $LN193@stZoneInfo

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00067	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  0006a	2b c1		 sub	 eax, ecx
  0006c	c1 f8 02	 sar	 eax, 2
  0006f	50		 push	 eax
  00070	51		 push	 ecx
  00071	8d 4f 28	 lea	 ecx, DWORD PTR [edi+40]
  00074	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  00079	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0

; 1663 : 			this->_Mylast() = pointer();

  00080	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0

; 1664 : 			this->_Myend() = pointer();

  00087	c7 47 30 00 00
	00 00		 mov	 DWORD PTR [edi+48], 0
$LN193@stZoneInfo:

; 1656 : 		if (this->_Myfirst() != pointer())

  0008e	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00091	85 c9		 test	 ecx, ecx
  00093	74 27		 je	 SHORT $LN286@stZoneInfo

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00095	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00098	2b c1		 sub	 eax, ecx
  0009a	c1 f8 03	 sar	 eax, 3
  0009d	50		 push	 eax
  0009e	51		 push	 ecx
  0009f	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  000a2	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEXPAU_stMonsterIndexInfo@@I@Z ; std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  000a7	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], 0

; 1663 : 			this->_Mylast() = pointer();

  000ae	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0

; 1664 : 			this->_Myend() = pointer();

  000b5	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], 0
$LN286@stZoneInfo:
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	c3		 ret	 0
??1_stZoneInfo@@QAE@XZ ENDP				; _stZoneInfo::~_stZoneInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 25		 je	 SHORT $LN2@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 02	 sar	 eax, 2
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00027	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:
  0002e	5e		 pop	 esi

; 1665 : 			}
; 1666 : 		}

  0002f	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 25		 je	 SHORT $LN4@vector

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 02	 sar	 eax, 2
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00027	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0002e	5e		 pop	 esi

; 975  : 		_Tidy();
; 976  : 		}

  0002f	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z PROC ; std::_Wrap_alloc<std::allocator<int> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 139  : 	}
; 140  : 
; 141  : 		// TEMPLATE FUNCTION _Construct
; 142  : template<class _Ty1,
; 143  : 	class _Ty2> inline
; 144  : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 145  : 	{	// construct object at _Ptr with value _Val
; 146  : 	void *_Vptr = _Ptr;
; 147  : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 148  : 	}
; 149  : 
; 150  : template<class _Ty1> inline
; 151  : 	void _Construct(_Ty1 *_Ptr)
; 152  : 	{	// construct object at _Ptr with default value
; 153  : 	void *_Vptr = _Ptr;
; 154  : 
; 155  : 	::new (_Vptr) _Ty1();
; 156  : 	}
; 157  : 
; 158  : 		// TEMPLATE FUNCTION _Destroy
; 159  : template<class _Ty> inline
; 160  : 	void _Destroy(_Ty *_Ptr)
; 161  : 	{	// destroy object at _Ptr
; 162  : 	_Ptr->~_Ty();
; 163  : 	}
; 164  : 
; 165  : 		// TEMPLATE FUNCTION _Destroy_range
; 166  : template<class _Alloc> inline
; 167  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 168  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 169  : 		_Nonscalar_ptr_iterator_tag)
; 170  : 	{	// destroy [_First, _Last), arbitrary type
; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}
; 174  : 
; 175  : template<class _Alloc> inline
; 176  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 177  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 178  : 		_Scalar_ptr_iterator_tag)
; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 180  : 	}
; 181  : 
; 182  : template<class _Alloc> inline
; 183  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 184  : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 185  : 	{	// destroy [_First, _Last)
; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}
; 188  : 
; 189  : 		// TEMPLATE CLASS _Is_simple_alloc
; 190  : template<class _Alty>
; 191  : 	struct _Is_simple_alloc
; 192  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 193  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 194  : 		&& is_same<typename _Alty::pointer,
; 195  : 			typename _Alty::value_type *>::value
; 196  : 		&& is_same<typename _Alty::const_pointer,
; 197  : 			const typename _Alty::value_type *>::value
; 198  : 		&& is_same<typename _Alty::reference,
; 199  : 			typename _Alty::value_type&>::value
; 200  : 		&& is_same<typename _Alty::const_reference,
; 201  : 			const typename _Alty::value_type&>::value>
; 202  : 	{	// tests if allocator has simple addressing
; 203  : 	};
; 204  : 
; 205  : 		// TEMPLATE CLASS _Simple_types
; 206  : template<class _Value_type>
; 207  : 	struct _Simple_types
; 208  : 	{	// wraps types needed by iterators
; 209  : 	typedef _Value_type value_type;
; 210  : 	typedef size_t size_type;
; 211  : 	typedef ptrdiff_t difference_type;
; 212  : 	typedef value_type *pointer;
; 213  : 	typedef const value_type *const_pointer;
; 214  : 	typedef value_type& reference;
; 215  : 	typedef const value_type& const_reference;
; 216  : 	};
; 217  : 
; 218  : 		// TEMPLATE CLASS _Get_voidptr
; 219  : template<class _Alty,
; 220  : 	class _Pointer>
; 221  : 	struct _Get_voidptr
; 222  : 	{	// get void pointer for allocator
; 223  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 224  : 	typedef typename _Alvoid::pointer type;
; 225  : 	};
; 226  : 
; 227  : template<class _Alty,
; 228  : 	class _Ty>
; 229  : 	struct _Get_voidptr<_Alty, _Ty *>
; 230  : 	{	// get raw void pointer for allocator
; 231  : 	typedef void *type;
; 232  : 	};
; 233  : 
; 234  : 		// TEMPLATE STRUCT _Get_first_parameter
; 235  : template<class _Ty>
; 236  : 	struct _Get_first_parameter;
; 237  : 
; 238  : template<template<class, class...> class _Ty,
; 239  : 	class _First,
; 240  : 	class... _Rest>
; 241  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 242  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 243  : 	typedef _First type;
; 244  : 	};
; 245  : 
; 246  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 247  : template<class _Newfirst,
; 248  : 	class _Ty>
; 249  : 	struct _Replace_first_parameter;
; 250  : 
; 251  : template<class _Newfirst,
; 252  : 	template<class, class...> class _Ty,
; 253  : 	class _First,
; 254  : 	class... _Rest>
; 255  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 256  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 257  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 258  : 	};
; 259  : 
; 260  : 		// TEMPLATE STRUCT _Get_element_type
; 261  : template<class _Ty>
; 262  : 	struct _Get_element_type
; 263  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 264  : 		typename _Get_first_parameter<_Uty>::type);
; 265  : 
; 266  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 267  : template<class _Ty>
; 268  : 	struct _Get_ptr_difference_type
; 269  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 270  : 		ptrdiff_t);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_rebind_type
; 273  : template<class _Ty,
; 274  : 	class _Other>
; 275  : 	struct _Get_rebind_type
; 276  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 277  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 278  : 
; 279  : 		// TEMPLATE CLASS pointer_traits
; 280  : template<class _Ty>
; 281  : 	struct pointer_traits
; 282  : 	{	// defines traits for arbitrary pointers
; 283  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 284  : 	typedef _Ty pointer;
; 285  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 286  : 
; 287  : 	template<class _Other>
; 288  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 289  : 
; 290  : 	typedef typename _If<is_void<element_type>::value,
; 291  : 		char&,
; 292  : 		typename add_lvalue_reference<element_type>::type>::type _Reftype;
; 293  : 
; 294  : 	static pointer pointer_to(_Reftype _Val)
; 295  : 		{	// convert raw reference to pointer
; 296  : 		return (_Ty::pointer_to(_Val));
; 297  : 		}
; 298  : 	};
; 299  : 
; 300  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 301  : template<class _Ty>
; 302  : 	struct pointer_traits<_Ty *>
; 303  : 	{	// defines traits for raw pointers
; 304  : 	typedef _Ty element_type;
; 305  : 	typedef _Ty *pointer;
; 306  : 	typedef ptrdiff_t difference_type;
; 307  : 
; 308  : 	template<class _Other>
; 309  : 		using rebind = _Other *;
; 310  : 
; 311  : 	typedef typename _If<is_void<_Ty>::value,
; 312  : 		char&,
; 313  : 		typename add_lvalue_reference<_Ty>::type>::type _Reftype;
; 314  : 
; 315  : 	static pointer pointer_to(_Reftype _Val)
; 316  : 		{	// convert raw reference to pointer
; 317  : 		return (_STD addressof(_Val));
; 318  : 		}
; 319  : 	};
; 320  : 
; 321  : 		// TEMPLATE STRUCT _Get_pointer_type
; 322  : template<class _Ty>
; 323  : 	struct _Get_pointer_type
; 324  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 325  : 		typename _Ty::value_type *);
; 326  : 
; 327  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 328  : template<class _Ty>
; 329  : 	struct _Get_const_pointer_type
; 330  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 331  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 332  : 			::template rebind<const typename _Ty::value_type>);
; 333  : 
; 334  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 335  : template<class _Ty>
; 336  : 	struct _Get_void_pointer_type
; 337  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 338  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 339  : 			::template rebind<void>);
; 340  : 
; 341  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 342  : template<class _Ty>
; 343  : 	struct _Get_const_void_pointer_type
; 344  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 345  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 346  : 			::template rebind<const void>);
; 347  : 
; 348  : 		// TEMPLATE STRUCT _Get_difference_type
; 349  : template<class _Ty>
; 350  : 	struct _Get_difference_type
; 351  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 352  : 		typename _Get_ptr_difference_type<
; 353  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 354  : 
; 355  : 		// TEMPLATE STRUCT _Get_size_type
; 356  : template<class _Ty>
; 357  : 	struct _Get_size_type
; 358  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 359  : 		typename make_unsigned<
; 360  : 			typename _Get_difference_type<_Ty>::type>::type);
; 361  : 
; 362  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 363  : template<class _Ty>
; 364  : 	struct _Get_propagate_on_container_copy
; 365  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 366  : 		false_type);
; 367  : 
; 368  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 369  : template<class _Ty>
; 370  : 	struct _Get_propagate_on_container_move
; 371  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 372  : 		false_type);
; 373  : 
; 374  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 375  : template<class _Ty>
; 376  : 	struct _Get_propagate_on_container_swap
; 377  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 378  : 		false_type);
; 379  : 
; 380  : 		// TEMPLATE STRUCT _Get_is_always_equal
; 381  : template<class _Ty>
; 382  : 	struct _Get_is_always_equal
; 383  : 	_GET_TYPE_OR_DEFAULT(is_always_equal,
; 384  : 		typename is_empty<_Ty>::type);
; 385  : 
; 386  : 		// STRUCT _Alloc_allocate
; 387  : struct _Alloc_allocate
; 388  : 	{	// determines allocator_traits<_Alloc>
; 389  : 		// ::allocate(size_type, const_void_pointer)
; 390  : 
; 391  : 	template<class _Alloc,
; 392  : 		class _Size_type,
; 393  : 		class _Const_void_pointer>
; 394  : 		static auto _Fn(int, _Alloc& _Al,
; 395  : 			_Size_type _Count,
; 396  : 			_Const_void_pointer _Hint)
; 397  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 398  : 		{	// call allocator supplied version
; 399  : 		return (_Al.allocate(_Count, _Hint));
; 400  : 		}
; 401  : 
; 402  : 	template<class _Alloc,
; 403  : 		class _Size_type,
; 404  : 		class _Const_void_pointer>
; 405  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 406  : 			_Size_type _Count,
; 407  : 			_Const_void_pointer)
; 408  : 			-> decltype(_Al.allocate(_Count))
; 409  : 		{	// call default version
; 410  : 		return (_Al.allocate(_Count));
; 411  : 		}
; 412  : 	};
; 413  : 
; 414  : 		// STRUCT _Alloc_construct
; 415  : struct _Alloc_construct
; 416  : 	{	// determines allocator_traits<_Ty>
; 417  : 		// ::construct(_Ty&, _Objty *, _Types&&...)
; 418  : 
; 419  : 	template<class _Ty,
; 420  : 		class _Objty,
; 421  : 		class... _Types>
; 422  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 423  : 			_Types&&... _Args)
; 424  : 			-> void_t<decltype(
; 425  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))>
; 426  : 		{	// call allocator supplied version
; 427  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 428  : 		}
; 429  : 
; 430  : 	template<class _Ty,
; 431  : 		class _Objty,
; 432  : 		class... _Types>
; 433  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 434  : 			_Types&&... _Args)
; 435  : 		{	// call default version
; 436  : 		::new (static_cast<void *>(_Ptr))
; 437  : 			_Objty(_STD forward<_Types>(_Args)...);
; 438  : 		}
; 439  : 
; 440  : 	};
; 441  : 
; 442  : 		// STRUCT _Alloc_destroy
; 443  : struct _Alloc_destroy
; 444  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 445  : 	template<class _Ty,
; 446  : 		class _Objty>
; 447  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 448  : 			-> void_t<decltype(_Al.destroy(_Ptr))>
; 449  : 		{	// call allocator supplied version
; 450  : 		_Al.destroy(_Ptr);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty,
; 454  : 		class _Objty>
; 455  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 456  : 		{	// call default version
; 457  : 		_Ptr->~_Objty();
; 458  : 		}
; 459  : 	};
; 460  : 
; 461  : 		// STRUCT _Alloc_max_size
; 462  : struct _Alloc_max_size
; 463  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 464  : 	template<class _Ty>
; 465  : 		static auto _Fn(int, const _Ty& _Al) _NOEXCEPT
; 466  : 			-> decltype(_Al.max_size())
; 467  : 		{	// call allocator supplied version
; 468  : 		return (_Al.max_size());
; 469  : 		}
; 470  : 
; 471  : 	template<class _Ty>
; 472  : 		static auto _Fn(_Wrap_int, const _Ty&) _NOEXCEPT
; 473  : 			-> typename _Get_size_type<_Ty>::type
; 474  : 		{	// call default version
; 475  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 476  : 		}
; 477  : 	};
; 478  : 
; 479  : 		// STRUCT _Alloc_select
; 480  : struct _Alloc_select
; 481  : 	{	// determines allocator_traits<_Ty>
; 482  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 483  : 
; 484  : 	template<class _Ty>
; 485  : 		static auto _Fn(int, const _Ty& _Al)
; 486  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 487  : 		{	// call allocator supplied version
; 488  : 		return (_Al.select_on_container_copy_construction());
; 489  : 		}
; 490  : 
; 491  : 	template<class _Ty>
; 492  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 493  : 			-> _Ty
; 494  : 		{	// call default version
; 495  : 		return (_Al);
; 496  : 		}
; 497  : 	};
; 498  : 
; 499  : 		// TEMPLATE CLASS allocator_traits
; 500  : template<class _Alloc>
; 501  : 	struct allocator_traits
; 502  : 	{	// defines traits for allocators
; 503  : 	typedef _Alloc allocator_type;
; 504  : 	typedef typename _Alloc::value_type value_type;
; 505  : 
; 506  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 507  : 		pointer;
; 508  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 509  : 		const_pointer;
; 510  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 511  : 		void_pointer;
; 512  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 513  : 		const_void_pointer;
; 514  : 
; 515  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 516  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 517  : 
; 518  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 519  : 		propagate_on_container_copy_assignment;
; 520  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 521  : 		propagate_on_container_move_assignment;
; 522  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 523  : 		propagate_on_container_swap;
; 524  : 	typedef typename _Get_is_always_equal<_Alloc>::type
; 525  : 		is_always_equal;
; 526  : 
; 527  : 	template<class _Other>
; 528  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 529  : 
; 530  : 	template<class _Other>
; 531  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 532  : 
; 533  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count)
; 534  : 		{	// allocate array of _Count elements
; 535  : 		return (_Al.allocate(_Count));
; 536  : 		}
; 537  : 
; 538  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count,
; 539  : 		const_void_pointer _Hint)
; 540  : 		{	// allocate array of _Count elements, with hint
; 541  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 542  : 		}
; 543  : 
; 544  : 	static void deallocate(_Alloc& _Al,
; 545  : 		pointer _Ptr, size_type _Count)
; 546  : 		{	// deallocate _Count elements at _Ptr
; 547  : 		_Al.deallocate(_Ptr, _Count);
; 548  : 		}
; 549  : 
; 550  : 	template<class _Ty,
; 551  : 		class... _Types>
; 552  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 553  : 			_Types&&... _Args)
; 554  : 		{	// construct _Ty(_Types...) at _Ptr
; 555  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 556  : 			_STD forward<_Types>(_Args)...);
; 557  : 		}
; 558  : 
; 559  : 
; 560  : 	template<class _Ty>
; 561  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 562  : 		{	// destroy object at _Ptr
; 563  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 564  : 		}
; 565  : 
; 566  : 	static size_type max_size(const _Alloc& _Al) _NOEXCEPT
; 567  : 		{	// get maximum size
; 568  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 569  : 		}
; 570  : 
; 571  : 	static _Alloc select_on_container_copy_construction(
; 572  : 		const _Alloc& _Al)
; 573  : 		{	// get allocator to use
; 574  : 		return (_Alloc_select::_Fn(0, _Al));
; 575  : 		}
; 576  : 	};
; 577  : 
; 578  : 		// TEMPLATE CLASS allocator
; 579  : template<class _Ty>
; 580  : 	class allocator
; 581  : 	{	// generic allocator for objects of class _Ty
; 582  : public:
; 583  : 	static_assert(!is_const<_Ty>::value,
; 584  : 		"The C++ Standard forbids containers of const elements "
; 585  : 		"because allocator<const T> is ill-formed.");
; 586  : 
; 587  : 	typedef _Ty value_type;
; 588  : 
; 589  : 	typedef value_type *pointer;
; 590  : 	typedef const value_type *const_pointer;
; 591  : 
; 592  : 	typedef value_type& reference;
; 593  : 	typedef const value_type& const_reference;
; 594  : 
; 595  : 	typedef size_t size_type;
; 596  : 	typedef ptrdiff_t difference_type;
; 597  : 
; 598  : 	typedef true_type propagate_on_container_move_assignment;
; 599  : 	typedef true_type is_always_equal;
; 600  : 
; 601  : 	template<class _Other>
; 602  : 		struct rebind
; 603  : 		{	// convert this type to allocator<_Other>
; 604  : 		typedef allocator<_Other> other;
; 605  : 		};
; 606  : 
; 607  : 	pointer address(reference _Val) const _NOEXCEPT
; 608  : 		{	// return address of mutable _Val
; 609  : 		return (_STD addressof(_Val));
; 610  : 		}
; 611  : 
; 612  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 613  : 		{	// return address of nonmutable _Val
; 614  : 		return (_STD addressof(_Val));
; 615  : 		}
; 616  : 
; 617  : 	allocator() _THROW0()
; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}
; 620  : 
; 621  : 	allocator(const allocator<_Ty>&) _THROW0()
; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}
; 624  : 
; 625  : 	template<class _Other>
; 626  : 		allocator(const allocator<_Other>&) _THROW0()
; 627  : 		{	// construct from a related allocator (do nothing)
; 628  : 		}
; 629  : 
; 630  : 	template<class _Other>
; 631  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 632  : 		{	// assign from a related allocator (do nothing)
; 633  : 		return (*this);
; 634  : 		}
; 635  : 
; 636  : 	void deallocate(pointer _Ptr, size_type _Count)
; 637  : 		{	// deallocate object at _Ptr
; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000e	77 31		 ja	 SHORT $LN16@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 02	 shl	 eax, 2

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 909  : 		_Mybase::deallocate(_Ptr, _Count);
; 910  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ENDP ; std::_Wrap_alloc<std::allocator<int> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000e	77 31		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 02	 shl	 eax, 2

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 639  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xran@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xran@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@IBEXXZ PROC ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::_Xran, COMDAT
; _this$ = ecx

; 1789 : 		_Xout_of_range("invalid vector<T> subscript");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@IBEXXZ ENDP ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1655 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 25		 je	 SHORT $LN2@Tidy

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 03	 sar	 eax, 3
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEXPAU_stMonsterIndexInfo@@I@Z ; std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00027	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:
  0002e	5e		 pop	 esi

; 1665 : 			}
; 1666 : 		}

  0002f	c3		 ret	 0
?_Tidy@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@IAEXPAU_stMonsterIndexInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@IAEXPAU_stMonsterIndexInfo@@0@Z PROC ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@IAEXPAU_stMonsterIndexInfo@@0@Z ENDP ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?at@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEAAU_stMonsterIndexInfo@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
?at@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEAAU_stMonsterIndexInfo@@I@Z PROC ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::at, COMDAT
; _this$ = ecx

; 1205 : 		{	// subscript mutable sequence with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	2b c2		 sub	 eax, edx

; 1206 : 		if (size() <= _Pos)

  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  0000d	c1 f8 03	 sar	 eax, 3

; 1206 : 		if (size() <= _Pos)

  00010	3b c1		 cmp	 eax, ecx
  00012	76 07		 jbe	 SHORT $LN38@at

; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));

  00014	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]

; 1209 : 		}

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN38@at:

; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())
; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();
; 1663 : 			this->_Mylast() = pointer();
; 1664 : 			this->_Myend() = pointer();
; 1665 : 			}
; 1666 : 		}
; 1667 : 
; 1668 : 	template<class _Iter>
; 1669 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1670 : 		{	// copy initializing [_First, _Last), using allocator
; 1671 : 		return (_Uninitialized_copy(_First, _Last,
; 1672 : 			_Ptr, this->_Getal()));
; 1673 : 		}
; 1674 : 
; 1675 : 	template<class _Iter>
; 1676 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1677 : 		{	// move initializing [_First, _Last), using allocator
; 1678 : 		return (_Uninitialized_move(_First, _Last,
; 1679 : 			_Ptr, this->_Getal()));
; 1680 : 		}
; 1681 : 
; 1682 : 	iterator _Insert_n(const_iterator _Where,
; 1683 : 		size_type _Count, const value_type& _Val)
; 1684 : 		{	// insert _Count * _Val at _Where
; 1685 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1686 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1687 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1688 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1689 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1693 : 		if (_Count == 0)
; 1694 : 			;
; 1695 : 		else if (_Unused_capacity() < _Count)
; 1696 : 			{	// not enough room, reallocate
; 1697 : 			if (max_size() - size() < _Count)
; 1698 : 				_Xlen();	// result too long
; 1699 : 
; 1700 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1701 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1702 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst();
; 1703 : 			int _Ncopied = 0;
; 1704 : 
; 1705 : 			_TRY_BEGIN
; 1706 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1707 : 				_STD addressof(_Val));	// add new stuff
; 1708 : 			++_Ncopied;
; 1709 : 			_Umove(this->_Myfirst(), _VIPTR(_Where),
; 1710 : 				_Newvec);	// copy prefix
; 1711 : 			++_Ncopied;
; 1712 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1713 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1714 : 			_CATCH_ALL
; 1715 : 			if (1 < _Ncopied)
; 1716 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1717 : 			if (0 < _Ncopied)
; 1718 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1719 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			_Count += size();
; 1724 : 			if (this->_Myfirst() != pointer())
; 1725 : 				{	// destroy and deallocate old array
; 1726 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1727 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1728 : 					this->_Myend() - this->_Myfirst());
; 1729 : 				}
; 1730 : 
; 1731 : 			this->_Orphan_all();
; 1732 : 			this->_Myend() = _Newvec + _Capacity;
; 1733 : 			this->_Mylast() = _Newvec + _Count;
; 1734 : 			this->_Myfirst() = _Newvec;
; 1735 : 			}
; 1736 : 		else if ((size_type)(this->_Mylast() - _VIPTR(_Where))
; 1737 : 			< _Count)
; 1738 : 			{	// new stuff spills off end
; 1739 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1740 : 
; 1741 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1742 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1743 : 
; 1744 : 			_TRY_BEGIN
; 1745 : 			_Ufill(this->_Mylast(),
; 1746 : 				_Count - (this->_Mylast() - _VIPTR(_Where)),
; 1747 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1748 : 			_CATCH_ALL
; 1749 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1750 : 				this->_Mylast() + _Count);
; 1751 : 			_RERAISE;
; 1752 : 			_CATCH_END
; 1753 : 
; 1754 : 			this->_Mylast() += _Count;
; 1755 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1756 : 			_STD fill(_VIPTR(_Where), this->_Mylast() - _Count,
; 1757 : 				_Tmp);	// insert up to old end
; 1758 : 			}
; 1759 : 		else
; 1760 : 			{	// new stuff can all be assigned
; 1761 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1762 : 
; 1763 : 			pointer _Oldend = this->_Mylast();
; 1764 : 			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
; 1765 : 				this->_Mylast());	// copy suffix
; 1766 : 
; 1767 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1768 : 			_Move_backward(_VIPTR(_Where), _Oldend - _Count,
; 1769 : 				_Oldend);	// copy hole
; 1770 : 			_STD fill(_VIPTR(_Where),
; 1771 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1772 : 			}
; 1773 : 		return (begin() + _Off);
; 1774 : 		}
; 1775 : 
; 1776 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1777 : 		{	// copy initializing _Count * _Val, using allocator
; 1778 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
; 1779 : 		return (_Ptr + _Count);
; 1780 : 		}
; 1781 : 
; 1782 : 	[[noreturn]] void _Xlen() const
; 1783 : 		{	// report a length_error
; 1784 : 		_Xlength_error("vector<T> too long");
; 1785 : 		}
; 1786 : 
; 1787 : 	[[noreturn]] void _Xran() const
; 1788 : 		{	// report an out_of_range error
; 1789 : 		_Xout_of_range("invalid vector<T> subscript");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
  00020	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN40@at:
$LN37@at:
  00025	cc		 int	 3
?at@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEAAU_stMonsterIndexInfo@@I@Z ENDP ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::at
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::size, COMDAT
; _this$ = ecx

; 1179 : 		return (this->_Mylast() - this->_Myfirst());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1180 : 		}

  00008	c3		 ret	 0
?size@?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::~vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >, COMDAT
; _this$ = ecx

; 974  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 977  : 
; 978  : 	_Myt& operator=(const _Myt& _Right)
; 979  : 		{	// assign _Right
; 980  : 		if (this != &_Right)
; 981  : 			{	// different, assign it
; 982  : 			if (this->_Getal() != _Right._Getal()
; 983  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 984  : 				{	// change allocator before copying
; 985  : 				_Tidy();
; 986  : 				this->_Copy_alloc(_Right._Getal());
; 987  : 				}
; 988  : 
; 989  : 			this->_Orphan_all();
; 990  : 
; 991  : 			if (_Right.empty())
; 992  : 				clear();	// new sequence empty, erase existing sequence
; 993  : 			else if (_Right.size() <= size())
; 994  : 				{	// enough elements, copy new and destroy old
; 995  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst(),
; 996  : 					_Right._Mylast(), this->_Myfirst());	// copy new
; 997  : 				_Destroy(_Ptr, this->_Mylast());	// destroy old
; 998  : 				this->_Mylast() = this->_Myfirst() + _Right.size();
; 999  : 				}
; 1000 : 			else if (_Right.size() <= capacity())
; 1001 : 				{	// enough room, copy and construct new
; 1002 : 				pointer _Ptr = _Right._Myfirst() + size();
; 1003 : 				_Copy_impl(_Right._Myfirst(),
; 1004 : 					_Ptr, this->_Myfirst());
; 1005 : 				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
; 1006 : 					this->_Mylast());
; 1007 : 				}
; 1008 : 			else
; 1009 : 				{	// not enough room, allocate new array and construct new
; 1010 : 				if (this->_Myfirst() != pointer())
; 1011 : 					{	// discard old array
; 1012 : 					_Destroy(this->_Myfirst(), this->_Mylast());
; 1013 : 					this->_Getal().deallocate(this->_Myfirst(),
; 1014 : 						this->_Myend() - this->_Myfirst());
; 1015 : 					}
; 1016 : 				if (_Buy(_Right.size()))
; 1017 : 					_TRY_BEGIN
; 1018 : 					this->_Mylast() =
; 1019 : 						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
; 1020 : 						this->_Myfirst());
; 1021 : 					_CATCH_ALL
; 1022 : 					_Tidy();
; 1023 : 					_RERAISE;
; 1024 : 					_CATCH_END
; 1025 : 				}
; 1026 : 			}
; 1027 : 		return (*this);
; 1028 : 		}
; 1029 : 
; 1030 : 	void reserve(size_type _Count)
; 1031 : 		{	// determine new minimum length of allocated storage
; 1032 : 		if (capacity() < _Count)
; 1033 : 			{	// something to do, check and reallocate
; 1034 : 			if (max_size() < _Count)
; 1035 : 				_Xlen();
; 1036 : 			_Reallocate(_Count);
; 1037 : 			}
; 1038 : 		}
; 1039 : 
; 1040 : 	size_type capacity() const _NOEXCEPT
; 1041 : 		{	// return current length of allocated storage
; 1042 : 		return (this->_Myend() - this->_Myfirst());
; 1043 : 		}
; 1044 : 
; 1045 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1046 : 		{	// micro-optimization for capacity() - size()
; 1047 : 		return (this->_Myend() - this->_Mylast());
; 1048 : 		}
; 1049 : 
; 1050 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1051 : 		{	// micro-optimization for capacity() != size()
; 1052 : 		return (this->_Myend() != this->_Mylast());
; 1053 : 		}
; 1054 : 
; 1055 : 	iterator begin() _NOEXCEPT
; 1056 : 		{	// return iterator for beginning of mutable sequence
; 1057 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1058 : 		}
; 1059 : 
; 1060 : 	const_iterator begin() const _NOEXCEPT
; 1061 : 		{	// return iterator for beginning of nonmutable sequence
; 1062 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
; 1063 : 		}
; 1064 : 
; 1065 : 	iterator end() _NOEXCEPT
; 1066 : 		{	// return iterator for end of mutable sequence
; 1067 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1068 : 		}
; 1069 : 
; 1070 : 	const_iterator end() const _NOEXCEPT
; 1071 : 		{	// return iterator for end of nonmutable sequence
; 1072 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));
; 1073 : 		}
; 1074 : 
; 1075 : 	iterator _Make_iter(const_iterator _Where) const
; 1076 : 		{	// make iterator from const_iterator
; 1077 : 		return (iterator(_Where._Ptr, &this->_Get_data()));
; 1078 : 		}
; 1079 : 
; 1080 : 	reverse_iterator rbegin() _NOEXCEPT
; 1081 : 		{	// return iterator for beginning of reversed mutable sequence
; 1082 : 		return (reverse_iterator(end()));
; 1083 : 		}
; 1084 : 
; 1085 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1086 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1087 : 		return (const_reverse_iterator(end()));
; 1088 : 		}
; 1089 : 
; 1090 : 	reverse_iterator rend() _NOEXCEPT
; 1091 : 		{	// return iterator for end of reversed mutable sequence
; 1092 : 		return (reverse_iterator(begin()));
; 1093 : 		}
; 1094 : 
; 1095 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1096 : 		{	// return iterator for end of reversed nonmutable sequence
; 1097 : 		return (const_reverse_iterator(begin()));
; 1098 : 		}
; 1099 : 
; 1100 : 	const_iterator cbegin() const _NOEXCEPT
; 1101 : 		{	// return iterator for beginning of nonmutable sequence
; 1102 : 		return (begin());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_iterator cend() const _NOEXCEPT
; 1106 : 		{	// return iterator for end of nonmutable sequence
; 1107 : 		return (end());
; 1108 : 		}
; 1109 : 
; 1110 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1111 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1112 : 		return (rbegin());
; 1113 : 		}
; 1114 : 
; 1115 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1116 : 		{	// return iterator for end of reversed nonmutable sequence
; 1117 : 		return (rend());
; 1118 : 		}
; 1119 : 
; 1120 : 	void shrink_to_fit()
; 1121 : 		{	// reduce capacity
; 1122 : 		if (_Has_unused_capacity())
; 1123 : 			{	// worth shrinking, do it
; 1124 : 			if (empty())
; 1125 : 				_Tidy();
; 1126 : 			else
; 1127 : 				_Reallocate(size());
; 1128 : 			}
; 1129 : 		}
; 1130 : 
; 1131 : 	void resize(size_type _Newsize)
; 1132 : 		{	// determine new length, padding as needed
; 1133 : 		if (_Newsize < size())
; 1134 : 			_Pop_back_n(size() - _Newsize);
; 1135 : 		else if (size() < _Newsize)
; 1136 : 			{	// pad as needed
; 1137 : 			_Reserve(_Newsize - size());
; 1138 : 			_TRY_BEGIN
; 1139 : 			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
; 1140 : 				this->_Getal());
; 1141 : 			_CATCH_ALL
; 1142 : 			_Tidy();
; 1143 : 			_RERAISE;
; 1144 : 			_CATCH_END
; 1145 : 			this->_Mylast() += _Newsize - size();
; 1146 : 			}
; 1147 : 		}
; 1148 : 
; 1149 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1150 : 		{	// determine new length, padding with _Val elements as needed
; 1151 : 		if (_Newsize < size())
; 1152 : 			_Pop_back_n(size() - _Newsize);
; 1153 : 		else if (size() < _Newsize)
; 1154 : 			{	// pad as needed
; 1155 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1156 : 
; 1157 : 			if (_Inside(_Ptr))
; 1158 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1159 : 				const difference_type _Idx = _Ptr
; 1160 : 					- _STD addressof(*this->_Myfirst());
; 1161 : 				_Reserve(_Newsize - size());
; 1162 : 				_Ptr = _STD addressof(*this->_Myfirst()) + _Idx;
; 1163 : 				}
; 1164 : 			else
; 1165 : 				_Reserve(_Newsize - size());
; 1166 : 
; 1167 : 			_TRY_BEGIN
; 1168 : 			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
; 1169 : 			_CATCH_ALL
; 1170 : 			_Tidy();
; 1171 : 			_RERAISE;
; 1172 : 			_CATCH_END
; 1173 : 			this->_Mylast() += _Newsize - size();
; 1174 : 			}
; 1175 : 		}
; 1176 : 
; 1177 : 	size_type size() const _NOEXCEPT
; 1178 : 		{	// return length of sequence
; 1179 : 		return (this->_Mylast() - this->_Myfirst());
; 1180 : 		}
; 1181 : 
; 1182 : 	size_type max_size() const _NOEXCEPT
; 1183 : 		{	// return maximum possible length of sequence
; 1184 : 		return (this->_Getal().max_size());
; 1185 : 		}
; 1186 : 
; 1187 : 	bool empty() const _NOEXCEPT
; 1188 : 		{	// test if sequence is empty
; 1189 : 		return (this->_Myfirst() == this->_Mylast());
; 1190 : 		}
; 1191 : 
; 1192 : 	_Alloc get_allocator() const _NOEXCEPT
; 1193 : 		{	// return allocator object for values
; 1194 : 		return (this->_Getal());
; 1195 : 		}
; 1196 : 
; 1197 : 	const_reference at(size_type _Pos) const
; 1198 : 		{	// subscript nonmutable sequence with checking
; 1199 : 		if (size() <= _Pos)
; 1200 : 			_Xran();
; 1201 : 		return (*(this->_Myfirst() + _Pos));
; 1202 : 		}
; 1203 : 
; 1204 : 	reference at(size_type _Pos)
; 1205 : 		{	// subscript mutable sequence with checking
; 1206 : 		if (size() <= _Pos)
; 1207 : 			_Xran();
; 1208 : 		return (*(this->_Myfirst() + _Pos));
; 1209 : 		}
; 1210 : 
; 1211 : 	const_reference operator[](size_type _Pos) const
; 1212 : 		{	// subscript nonmutable sequence
; 1213 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1214 : 		if (size() <= _Pos)
; 1215 : 			{	// report error
; 1216 : 			_DEBUG_ERROR("vector subscript out of range");
; 1217 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1218 : 			}
; 1219 : 
; 1220 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1221 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1222 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1223 : 
; 1224 : 		return (*(this->_Myfirst() + _Pos));
; 1225 : 		}
; 1226 : 
; 1227 : 	reference operator[](size_type _Pos)
; 1228 : 		{	// subscript mutable sequence
; 1229 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1230 : 		if (size() <= _Pos)
; 1231 : 			{	// report error
; 1232 : 			_DEBUG_ERROR("vector subscript out of range");
; 1233 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1234 : 			}
; 1235 : 
; 1236 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1237 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1238 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1239 : 
; 1240 : 		return (*(this->_Myfirst() + _Pos));
; 1241 : 		}
; 1242 : 
; 1243 : 	pointer data() _NOEXCEPT
; 1244 : 		{	// return address of first element
; 1245 : 		return (this->_Myfirst());
; 1246 : 		}
; 1247 : 
; 1248 : 	const_pointer data() const _NOEXCEPT
; 1249 : 		{	// return address of first element
; 1250 : 		return (this->_Myfirst());
; 1251 : 		}
; 1252 : 
; 1253 : 	reference front()
; 1254 : 		{	// return first element of mutable sequence
; 1255 : 		return (*begin());
; 1256 : 		}
; 1257 : 
; 1258 : 	const_reference front() const
; 1259 : 		{	// return first element of nonmutable sequence
; 1260 : 		return (*begin());
; 1261 : 		}
; 1262 : 
; 1263 : 	reference back()
; 1264 : 		{	// return last element of mutable sequence
; 1265 : 		return (*(end() - 1));
; 1266 : 		}
; 1267 : 
; 1268 : 	const_reference back() const
; 1269 : 		{	// return last element of nonmutable sequence
; 1270 : 		return (*(end() - 1));
; 1271 : 		}
; 1272 : 
; 1273 : 	void push_back(const value_type& _Val)
; 1274 : 		{	// insert element at end
; 1275 : 		if (_Inside(_STD addressof(_Val)))
; 1276 : 			{	// push back an element
; 1277 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst();
; 1278 : 			if (this->_Mylast() == this->_Myend())
; 1279 : 				_Reserve(1);
; 1280 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1281 : 			this->_Getal().construct(this->_Mylast(),
; 1282 : 				this->_Myfirst()[_Idx]);
; 1283 : 			++this->_Mylast();
; 1284 : 			}
; 1285 : 		else
; 1286 : 			{	// push back a non-element
; 1287 : 			if (this->_Mylast() == this->_Myend())
; 1288 : 				_Reserve(1);
; 1289 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1290 : 			this->_Getal().construct(this->_Mylast(),
; 1291 : 				_Val);
; 1292 : 			++this->_Mylast();
; 1293 : 			}
; 1294 : 		}
; 1295 : 
; 1296 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1297 : 	void pop_back()
; 1298 : 		{	// erase element at end
; 1299 : 		if (empty())
; 1300 : 			_DEBUG_ERROR("vector empty before pop");
; 1301 : 		else
; 1302 : 			{	// erase last element
; 1303 : 			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
; 1304 : 			this->_Getal().destroy(this->_Mylast() - 1);
; 1305 : 			--this->_Mylast();
; 1306 : 			}
; 1307 : 		}
; 1308 : 
; 1309 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1310 : 	void pop_back()
; 1311 : 		{	// erase element at end
; 1312 : 		this->_Getal().destroy(this->_Mylast() - 1);
; 1313 : 		--this->_Mylast();
; 1314 : 		}
; 1315 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1316 : 
; 1317 : 	template<class _Iter>
; 1318 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1319 : 			void>::type
; 1320 : 		assign(_Iter _First, _Iter _Last)
; 1321 : 		{	// assign [_First, _Last)
; 1322 : 		clear();
; 1323 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Iter>
; 1327 : 		void _Assign(_Iter _First, _Iter _Last,
; 1328 : 			input_iterator_tag)
; 1329 : 		{	// assign [_First, _Last), input iterators
; 1330 : 		for (; _First != _Last; ++_First)
; 1331 : 			emplace_back(*_First);
; 1332 : 		}
; 1333 : 
; 1334 : 	template<class _Iter>
; 1335 : 		void _Assign(_Iter _First, _Iter _Last,
; 1336 : 			forward_iterator_tag)
; 1337 : 		{	// assign [_First, _Last), forward iterators
; 1338 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1339 : 
; 1340 : 		if (capacity() < _Newsize)
; 1341 : 			{	// need more room, try to get it
; 1342 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1343 : 			_Tidy();
; 1344 : 			_Buy(_Newcapacity);
; 1345 : 			}
; 1346 : 
; 1347 : 		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
; 1348 : 		}
; 1349 : 
; 1350 : 	void assign(size_type _Count, const value_type& _Val)
; 1351 : 		{	// assign _Count * _Val
; 1352 : 		clear();
; 1353 : 		insert(begin(), _Count, _Val);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1357 : 		{	// insert _Val at _Where
; 1358 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1359 : 		}
; 1360 : 
; 1361 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1362 : 		const _Ty& _Val)
; 1363 : 		{	// insert _Count * _Val at _Where
; 1364 : 		return (_Insert_n(_Where, _Count, _Val));
; 1365 : 		}
; 1366 : 
; 1367 : 	template<class _Iter>
; 1368 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1369 : 			iterator>::type
; 1370 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1371 : 		{	// insert [_First, _Last) at _Where
; 1372 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1373 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1374 : 		return (begin() + _Off);
; 1375 : 		}
; 1376 : 
; 1377 : 	template<class _Iter>
; 1378 : 		void _Insert(const_iterator _Where,
; 1379 : 			_Iter _First, _Iter _Last,
; 1380 : 				input_iterator_tag)
; 1381 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1382 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst();
; 1383 : 
; 1384 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1385 : 		if (size() < _Off)
; 1386 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1387 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1388 : 
; 1389 : 		if (_First != _Last)
; 1390 : 			{	// worth doing, gather at end and rotate into place
; 1391 : 			size_type _Oldsize = size();
; 1392 : 
; 1393 : 			_TRY_BEGIN
; 1394 : 			for (; _First != _Last; ++_First)
; 1395 : 				push_back(*_First);	// append
; 1396 : 
; 1397 : 			_CATCH_ALL
; 1398 : 			erase(begin() + _Oldsize, end());
; 1399 : 			_RERAISE;
; 1400 : 			_CATCH_END
; 1401 : 
; 1402 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1403 : 			}
; 1404 : 		}
; 1405 : 
; 1406 : 	template<class _Iter>
; 1407 : 		void _Insert(const_iterator _Where,
; 1408 : 			_Iter _First, _Iter _Last,
; 1409 : 				forward_iterator_tag)
; 1410 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1413 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1414 : 			|| this->_Mylast() < _VIPTR(_Where))
; 1415 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1416 : 		_DEBUG_RANGE(_First, _Last);
; 1417 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1418 : 
; 1419 : 		size_type _Count = 0;
; 1420 : 		_Distance(_First, _Last, _Count);
; 1421 : 
; 1422 : 		if (_Count == 0)
; 1423 : 			;
; 1424 : 		else if (_Unused_capacity() < _Count)
; 1425 : 			{	// not enough room, reallocate
; 1426 : 			if (max_size() - size() < _Count)
; 1427 : 				_Xlen();	// result too long
; 1428 : 
; 1429 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1430 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1431 : 			pointer _Ptr = _Newvec;
; 1432 : 
; 1433 : 			_TRY_BEGIN
; 1434 : 			_Ptr = _Umove(this->_Myfirst(), _VIPTR(_Where),
; 1435 : 				_Newvec);	// copy prefix
; 1436 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1437 : 			_Umove(_VIPTR(_Where), this->_Mylast(),
; 1438 : 				_Ptr);	// copy suffix
; 1439 : 			_CATCH_ALL
; 1440 : 			_Destroy(_Newvec, _Ptr);
; 1441 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1442 : 			_RERAISE;
; 1443 : 			_CATCH_END
; 1444 : 
; 1445 : 			_Count += size();
; 1446 : 			if (this->_Myfirst() != pointer())
; 1447 : 				{	// destroy and deallocate old array
; 1448 : 				_Destroy(this->_Myfirst(), this->_Mylast());
; 1449 : 				this->_Getal().deallocate(this->_Myfirst(),
; 1450 : 					this->_Myend() - this->_Myfirst());
; 1451 : 				}
; 1452 : 
; 1453 : 			this->_Orphan_all();
; 1454 : 			this->_Myend() = _Newvec + _Capacity;
; 1455 : 			this->_Mylast() = _Newvec + _Count;
; 1456 : 			this->_Myfirst() = _Newvec;
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// new stuff fits, append and rotate into place
; 1460 : 			_Ucopy(_First, _Last, this->_Mylast());
; 1461 : 			_STD rotate(_VIPTR(_Where), this->_Mylast(),
; 1462 : 				this->_Mylast() + _Count);
; 1463 : 			this->_Mylast() += _Count;
; 1464 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1465 : 			}
; 1466 : 		}
; 1467 : 
; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 	iterator erase(const_iterator _Where)
; 1470 : 		{	// erase element at where
; 1471 : 		if (_VICONT(_Where) != &this->_Get_data()
; 1472 : 			|| _VIPTR(_Where) < this->_Myfirst()
; 1473 : 			|| this->_Mylast() <= _VIPTR(_Where))
; 1474 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1475 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(), _VIPTR(_Where));
; 1476 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1477 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast());
; 1478 : 		--this->_Mylast();
; 1479 : 		return (_Make_iter(_Where));
; 1480 : 		}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 	iterator erase(const_iterator _Where)
; 1484 : 		{	// erase element at where
; 1485 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast(),
; 1486 : 			_VIPTR(_Where));
; 1487 : 		_Destroy(this->_Mylast() - 1, this->_Mylast());
; 1488 : 		--this->_Mylast();
; 1489 : 		return (_Make_iter(_Where));
; 1490 : 		}
; 1491 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1492 : 
; 1493 : 	iterator erase(const_iterator _First_arg,
; 1494 : 		const_iterator _Last_arg)
; 1495 : 		{	// erase [_First, _Last)
; 1496 : 		if (_First_arg == begin() && _Last_arg == end())
; 1497 : 			clear();
; 1498 : 		else if (_First_arg != _Last_arg)
; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);
; 1501 : 			iterator _Last = _Make_iter(_Last_arg);
; 1502 : 
; 1503 : 			if (_First != _Last)
; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))
; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1510 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());
; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());
; 1520 : 				this->_Mylast() = _Ptr;
; 1521 : 				}
; 1522 : 			}
; 1523 : 		return (_Make_iter(_First_arg));
; 1524 : 		}
; 1525 : 
; 1526 : 	void _Pop_back_n(size_type _Count)
; 1527 : 		{	// erase _Count elements at end
; 1528 : 		pointer _Ptr = this->_Mylast() - _Count;
; 1529 : 
; 1530 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1531 : 		_Orphan_range(_Ptr, this->_Mylast());
; 1532 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1533 : 
; 1534 : 		_Destroy(_Ptr, this->_Mylast());
; 1535 : 		this->_Mylast() = _Ptr;
; 1536 : 		}
; 1537 : 
; 1538 : 	void clear() _NOEXCEPT
; 1539 : 		{	// erase all
; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();
; 1543 : 		}
; 1544 : 
; 1545 : 	void swap(_Myt& _Right)
; 1546 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1547 : 			|| _Alty::is_always_equal::value)
; 1548 : 		{	// exchange contents with _Right
; 1549 : 		if (this == &_Right)
; 1550 : 			;	// same object, do nothing
; 1551 : 		else if (this->_Getal() == _Right._Getal())
; 1552 : 			{	// same allocator, swap control information
; 1553 : 			this->_Swap_all(_Right);
; 1554 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1555 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1556 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1557 : 			}
; 1558 : 
; 1559 : 		else if (_Alty::propagate_on_container_swap::value)
; 1560 : 			{	// swap allocators and control information
; 1561 : 			this->_Swap_alloc(_Right);
; 1562 : 			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
; 1563 : 			_Swap_adl(this->_Mylast(), _Right._Mylast());
; 1564 : 			_Swap_adl(this->_Myend(), _Right._Myend());
; 1565 : 			}
; 1566 : 
; 1567 : 		else
; 1568 : 			{	// containers are incompatible
; 1569 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1570 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1571 : 
; 1572 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 			_XSTD terminate();
; 1574 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1575 : 			}
; 1576 : 		}
; 1577 : 
; 1578 : protected:
; 1579 : 	bool _Buy(size_type _Capacity)
; 1580 : 		{	// allocate array with _Capacity elements
; 1581 : 		this->_Myfirst() = pointer();
; 1582 : 		this->_Mylast() = pointer();
; 1583 : 		this->_Myend() = pointer();
; 1584 : 
; 1585 : 		if (_Capacity == 0)
; 1586 : 			return (false);
; 1587 : 		else if (max_size() < _Capacity)
; 1588 : 			_Xlen();	// result too long
; 1589 : 		else
; 1590 : 			{	// nonempty array, allocate storage
; 1591 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);
; 1592 : 			this->_Mylast() = this->_Myfirst();
; 1593 : 			this->_Myend() = this->_Myfirst() + _Capacity;
; 1594 : 			}
; 1595 : 		return (true);
; 1596 : 		}
; 1597 : 
; 1598 : 	void _Destroy(pointer _First, pointer _Last)
; 1599 : 		{	// destroy [_First, _Last) using allocator
; 1600 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1601 : 		}
; 1602 : 
; 1603 : 	size_type _Grow_to(size_type _Count) const
; 1604 : 		{	// grow by 50% or at least to _Count
; 1605 : 		size_type _Capacity = capacity();
; 1606 : 
; 1607 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1608 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1609 : 		if (_Capacity < _Count)
; 1610 : 			_Capacity = _Count;
; 1611 : 		return (_Capacity);
; 1612 : 		}
; 1613 : 
; 1614 : 	bool _Inside(const value_type *_Ptr) const
; 1615 : 		{	// test if _Ptr points inside vector
; 1616 : 		return (_Ptr < this->_Mylast() && this->_Myfirst() <= _Ptr);
; 1617 : 		}
; 1618 : 
; 1619 : 	void _Reallocate(size_type _Count)
; 1620 : 		{	// move to array of exactly _Count elements
; 1621 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1622 : 
; 1623 : 		_TRY_BEGIN
; 1624 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1625 : 		_CATCH_ALL
; 1626 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1627 : 		_RERAISE;
; 1628 : 		_CATCH_END
; 1629 : 
; 1630 : 		size_type _Size = size();
; 1631 : 		if (this->_Myfirst() != pointer())
; 1632 : 			{	// destroy and deallocate old array
; 1633 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1634 : 			this->_Getal().deallocate(this->_Myfirst(),
; 1635 : 				this->_Myend() - this->_Myfirst());
; 1636 : 			}
; 1637 : 
; 1638 : 		this->_Orphan_all();
; 1639 : 		this->_Myend() = _Ptr + _Count;
; 1640 : 		this->_Mylast() = _Ptr + _Size;
; 1641 : 		this->_Myfirst() = _Ptr;
; 1642 : 		}
; 1643 : 
; 1644 : 	void _Reserve(size_type _Count)
; 1645 : 		{	// ensure room for _Count new elements, grow exponentially
; 1646 : 		if (_Unused_capacity() < _Count)
; 1647 : 			{	// need more room, try to get it
; 1648 : 			if (max_size() - size() < _Count)
; 1649 : 				_Xlen();
; 1650 : 			_Reallocate(_Grow_to(size() + _Count));
; 1651 : 			}
; 1652 : 		}
; 1653 : 
; 1654 : 	void _Tidy()
; 1655 : 		{	// free all storage
; 1656 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 25		 je	 SHORT $LN4@vector

; 1657 : 			{	// something to free, destroy and deallocate it
; 1658 : 			this->_Orphan_all();
; 1659 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1660 : 			this->_Getal().deallocate(this->_Myfirst(),

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c1		 sub	 eax, ecx
  0000e	c1 f8 03	 sar	 eax, 3
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	8b ce		 mov	 ecx, esi
  00015	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEXPAU_stMonsterIndexInfo@@I@Z ; std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >::deallocate

; 1661 : 				this->_Myend() - this->_Myfirst());
; 1662 : 			this->_Myfirst() = pointer();

  0001a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1663 : 			this->_Mylast() = pointer();

  00020	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1664 : 			this->_Myend() = pointer();

  00027	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0002e	5e		 pop	 esi

; 975  : 		_Tidy();
; 976  : 		}

  0002f	c3		 ret	 0
??1?$vector@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >::~vector<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >,std::_Vector_val<std::_Simple_types<_stMonsterIndexInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >,std::_Vector_val<std::_Simple_types<_stMonsterIndexInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >,std::_Vector_val<std::_Simple_types<_stMonsterIndexInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >,std::_Vector_val<std::_Simple_types<_stMonsterIndexInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >,std::_Vector_val<std::_Simple_types<_stMonsterIndexInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >,std::_Vector_val<std::_Simple_types<_stMonsterIndexInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAPAU_stMonsterIndexInfo@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAPAU_stMonsterIndexInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 663  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAPAU_stMonsterIndexInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QBEABQAU_stMonsterIndexInfo@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QBEABQAU_stMonsterIndexInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 658  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QBEABQAU_stMonsterIndexInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAPAU_stMonsterIndexInfo@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAPAU_stMonsterIndexInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 653  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAPAU_stMonsterIndexInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QBEABQAU_stMonsterIndexInfo@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QBEABQAU_stMonsterIndexInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 648  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QBEABQAU_stMonsterIndexInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAPAU_stMonsterIndexInfo@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAPAU_stMonsterIndexInfo@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 643  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAPAU_stMonsterIndexInfo@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 638  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 633  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@U_stMonsterIndexInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 623  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		_Get_data()._Orphan_all();
; 613  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@U_stMonsterIndexInfo@@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<_stMonsterIndexInfo,std::allocator<_stMonsterIndexInfo> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEXPAU_stMonsterIndexInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEXPAU_stMonsterIndexInfo@@I@Z PROC ; std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 139  : 	}
; 140  : 
; 141  : 		// TEMPLATE FUNCTION _Construct
; 142  : template<class _Ty1,
; 143  : 	class _Ty2> inline
; 144  : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 145  : 	{	// construct object at _Ptr with value _Val
; 146  : 	void *_Vptr = _Ptr;
; 147  : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 148  : 	}
; 149  : 
; 150  : template<class _Ty1> inline
; 151  : 	void _Construct(_Ty1 *_Ptr)
; 152  : 	{	// construct object at _Ptr with default value
; 153  : 	void *_Vptr = _Ptr;
; 154  : 
; 155  : 	::new (_Vptr) _Ty1();
; 156  : 	}
; 157  : 
; 158  : 		// TEMPLATE FUNCTION _Destroy
; 159  : template<class _Ty> inline
; 160  : 	void _Destroy(_Ty *_Ptr)
; 161  : 	{	// destroy object at _Ptr
; 162  : 	_Ptr->~_Ty();
; 163  : 	}
; 164  : 
; 165  : 		// TEMPLATE FUNCTION _Destroy_range
; 166  : template<class _Alloc> inline
; 167  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 168  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 169  : 		_Nonscalar_ptr_iterator_tag)
; 170  : 	{	// destroy [_First, _Last), arbitrary type
; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}
; 174  : 
; 175  : template<class _Alloc> inline
; 176  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 177  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 178  : 		_Scalar_ptr_iterator_tag)
; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 180  : 	}
; 181  : 
; 182  : template<class _Alloc> inline
; 183  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 184  : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 185  : 	{	// destroy [_First, _Last)
; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}
; 188  : 
; 189  : 		// TEMPLATE CLASS _Is_simple_alloc
; 190  : template<class _Alty>
; 191  : 	struct _Is_simple_alloc
; 192  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 193  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 194  : 		&& is_same<typename _Alty::pointer,
; 195  : 			typename _Alty::value_type *>::value
; 196  : 		&& is_same<typename _Alty::const_pointer,
; 197  : 			const typename _Alty::value_type *>::value
; 198  : 		&& is_same<typename _Alty::reference,
; 199  : 			typename _Alty::value_type&>::value
; 200  : 		&& is_same<typename _Alty::const_reference,
; 201  : 			const typename _Alty::value_type&>::value>
; 202  : 	{	// tests if allocator has simple addressing
; 203  : 	};
; 204  : 
; 205  : 		// TEMPLATE CLASS _Simple_types
; 206  : template<class _Value_type>
; 207  : 	struct _Simple_types
; 208  : 	{	// wraps types needed by iterators
; 209  : 	typedef _Value_type value_type;
; 210  : 	typedef size_t size_type;
; 211  : 	typedef ptrdiff_t difference_type;
; 212  : 	typedef value_type *pointer;
; 213  : 	typedef const value_type *const_pointer;
; 214  : 	typedef value_type& reference;
; 215  : 	typedef const value_type& const_reference;
; 216  : 	};
; 217  : 
; 218  : 		// TEMPLATE CLASS _Get_voidptr
; 219  : template<class _Alty,
; 220  : 	class _Pointer>
; 221  : 	struct _Get_voidptr
; 222  : 	{	// get void pointer for allocator
; 223  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 224  : 	typedef typename _Alvoid::pointer type;
; 225  : 	};
; 226  : 
; 227  : template<class _Alty,
; 228  : 	class _Ty>
; 229  : 	struct _Get_voidptr<_Alty, _Ty *>
; 230  : 	{	// get raw void pointer for allocator
; 231  : 	typedef void *type;
; 232  : 	};
; 233  : 
; 234  : 		// TEMPLATE STRUCT _Get_first_parameter
; 235  : template<class _Ty>
; 236  : 	struct _Get_first_parameter;
; 237  : 
; 238  : template<template<class, class...> class _Ty,
; 239  : 	class _First,
; 240  : 	class... _Rest>
; 241  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 242  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 243  : 	typedef _First type;
; 244  : 	};
; 245  : 
; 246  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 247  : template<class _Newfirst,
; 248  : 	class _Ty>
; 249  : 	struct _Replace_first_parameter;
; 250  : 
; 251  : template<class _Newfirst,
; 252  : 	template<class, class...> class _Ty,
; 253  : 	class _First,
; 254  : 	class... _Rest>
; 255  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 256  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 257  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 258  : 	};
; 259  : 
; 260  : 		// TEMPLATE STRUCT _Get_element_type
; 261  : template<class _Ty>
; 262  : 	struct _Get_element_type
; 263  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 264  : 		typename _Get_first_parameter<_Uty>::type);
; 265  : 
; 266  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 267  : template<class _Ty>
; 268  : 	struct _Get_ptr_difference_type
; 269  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 270  : 		ptrdiff_t);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_rebind_type
; 273  : template<class _Ty,
; 274  : 	class _Other>
; 275  : 	struct _Get_rebind_type
; 276  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 277  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 278  : 
; 279  : 		// TEMPLATE CLASS pointer_traits
; 280  : template<class _Ty>
; 281  : 	struct pointer_traits
; 282  : 	{	// defines traits for arbitrary pointers
; 283  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 284  : 	typedef _Ty pointer;
; 285  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 286  : 
; 287  : 	template<class _Other>
; 288  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 289  : 
; 290  : 	typedef typename _If<is_void<element_type>::value,
; 291  : 		char&,
; 292  : 		typename add_lvalue_reference<element_type>::type>::type _Reftype;
; 293  : 
; 294  : 	static pointer pointer_to(_Reftype _Val)
; 295  : 		{	// convert raw reference to pointer
; 296  : 		return (_Ty::pointer_to(_Val));
; 297  : 		}
; 298  : 	};
; 299  : 
; 300  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 301  : template<class _Ty>
; 302  : 	struct pointer_traits<_Ty *>
; 303  : 	{	// defines traits for raw pointers
; 304  : 	typedef _Ty element_type;
; 305  : 	typedef _Ty *pointer;
; 306  : 	typedef ptrdiff_t difference_type;
; 307  : 
; 308  : 	template<class _Other>
; 309  : 		using rebind = _Other *;
; 310  : 
; 311  : 	typedef typename _If<is_void<_Ty>::value,
; 312  : 		char&,
; 313  : 		typename add_lvalue_reference<_Ty>::type>::type _Reftype;
; 314  : 
; 315  : 	static pointer pointer_to(_Reftype _Val)
; 316  : 		{	// convert raw reference to pointer
; 317  : 		return (_STD addressof(_Val));
; 318  : 		}
; 319  : 	};
; 320  : 
; 321  : 		// TEMPLATE STRUCT _Get_pointer_type
; 322  : template<class _Ty>
; 323  : 	struct _Get_pointer_type
; 324  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 325  : 		typename _Ty::value_type *);
; 326  : 
; 327  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 328  : template<class _Ty>
; 329  : 	struct _Get_const_pointer_type
; 330  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 331  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 332  : 			::template rebind<const typename _Ty::value_type>);
; 333  : 
; 334  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 335  : template<class _Ty>
; 336  : 	struct _Get_void_pointer_type
; 337  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 338  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 339  : 			::template rebind<void>);
; 340  : 
; 341  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 342  : template<class _Ty>
; 343  : 	struct _Get_const_void_pointer_type
; 344  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 345  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 346  : 			::template rebind<const void>);
; 347  : 
; 348  : 		// TEMPLATE STRUCT _Get_difference_type
; 349  : template<class _Ty>
; 350  : 	struct _Get_difference_type
; 351  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 352  : 		typename _Get_ptr_difference_type<
; 353  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 354  : 
; 355  : 		// TEMPLATE STRUCT _Get_size_type
; 356  : template<class _Ty>
; 357  : 	struct _Get_size_type
; 358  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 359  : 		typename make_unsigned<
; 360  : 			typename _Get_difference_type<_Ty>::type>::type);
; 361  : 
; 362  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 363  : template<class _Ty>
; 364  : 	struct _Get_propagate_on_container_copy
; 365  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 366  : 		false_type);
; 367  : 
; 368  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 369  : template<class _Ty>
; 370  : 	struct _Get_propagate_on_container_move
; 371  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 372  : 		false_type);
; 373  : 
; 374  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 375  : template<class _Ty>
; 376  : 	struct _Get_propagate_on_container_swap
; 377  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 378  : 		false_type);
; 379  : 
; 380  : 		// TEMPLATE STRUCT _Get_is_always_equal
; 381  : template<class _Ty>
; 382  : 	struct _Get_is_always_equal
; 383  : 	_GET_TYPE_OR_DEFAULT(is_always_equal,
; 384  : 		typename is_empty<_Ty>::type);
; 385  : 
; 386  : 		// STRUCT _Alloc_allocate
; 387  : struct _Alloc_allocate
; 388  : 	{	// determines allocator_traits<_Alloc>
; 389  : 		// ::allocate(size_type, const_void_pointer)
; 390  : 
; 391  : 	template<class _Alloc,
; 392  : 		class _Size_type,
; 393  : 		class _Const_void_pointer>
; 394  : 		static auto _Fn(int, _Alloc& _Al,
; 395  : 			_Size_type _Count,
; 396  : 			_Const_void_pointer _Hint)
; 397  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 398  : 		{	// call allocator supplied version
; 399  : 		return (_Al.allocate(_Count, _Hint));
; 400  : 		}
; 401  : 
; 402  : 	template<class _Alloc,
; 403  : 		class _Size_type,
; 404  : 		class _Const_void_pointer>
; 405  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 406  : 			_Size_type _Count,
; 407  : 			_Const_void_pointer)
; 408  : 			-> decltype(_Al.allocate(_Count))
; 409  : 		{	// call default version
; 410  : 		return (_Al.allocate(_Count));
; 411  : 		}
; 412  : 	};
; 413  : 
; 414  : 		// STRUCT _Alloc_construct
; 415  : struct _Alloc_construct
; 416  : 	{	// determines allocator_traits<_Ty>
; 417  : 		// ::construct(_Ty&, _Objty *, _Types&&...)
; 418  : 
; 419  : 	template<class _Ty,
; 420  : 		class _Objty,
; 421  : 		class... _Types>
; 422  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 423  : 			_Types&&... _Args)
; 424  : 			-> void_t<decltype(
; 425  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))>
; 426  : 		{	// call allocator supplied version
; 427  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 428  : 		}
; 429  : 
; 430  : 	template<class _Ty,
; 431  : 		class _Objty,
; 432  : 		class... _Types>
; 433  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 434  : 			_Types&&... _Args)
; 435  : 		{	// call default version
; 436  : 		::new (static_cast<void *>(_Ptr))
; 437  : 			_Objty(_STD forward<_Types>(_Args)...);
; 438  : 		}
; 439  : 
; 440  : 	};
; 441  : 
; 442  : 		// STRUCT _Alloc_destroy
; 443  : struct _Alloc_destroy
; 444  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 445  : 	template<class _Ty,
; 446  : 		class _Objty>
; 447  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 448  : 			-> void_t<decltype(_Al.destroy(_Ptr))>
; 449  : 		{	// call allocator supplied version
; 450  : 		_Al.destroy(_Ptr);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty,
; 454  : 		class _Objty>
; 455  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 456  : 		{	// call default version
; 457  : 		_Ptr->~_Objty();
; 458  : 		}
; 459  : 	};
; 460  : 
; 461  : 		// STRUCT _Alloc_max_size
; 462  : struct _Alloc_max_size
; 463  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 464  : 	template<class _Ty>
; 465  : 		static auto _Fn(int, const _Ty& _Al) _NOEXCEPT
; 466  : 			-> decltype(_Al.max_size())
; 467  : 		{	// call allocator supplied version
; 468  : 		return (_Al.max_size());
; 469  : 		}
; 470  : 
; 471  : 	template<class _Ty>
; 472  : 		static auto _Fn(_Wrap_int, const _Ty&) _NOEXCEPT
; 473  : 			-> typename _Get_size_type<_Ty>::type
; 474  : 		{	// call default version
; 475  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 476  : 		}
; 477  : 	};
; 478  : 
; 479  : 		// STRUCT _Alloc_select
; 480  : struct _Alloc_select
; 481  : 	{	// determines allocator_traits<_Ty>
; 482  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 483  : 
; 484  : 	template<class _Ty>
; 485  : 		static auto _Fn(int, const _Ty& _Al)
; 486  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 487  : 		{	// call allocator supplied version
; 488  : 		return (_Al.select_on_container_copy_construction());
; 489  : 		}
; 490  : 
; 491  : 	template<class _Ty>
; 492  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 493  : 			-> _Ty
; 494  : 		{	// call default version
; 495  : 		return (_Al);
; 496  : 		}
; 497  : 	};
; 498  : 
; 499  : 		// TEMPLATE CLASS allocator_traits
; 500  : template<class _Alloc>
; 501  : 	struct allocator_traits
; 502  : 	{	// defines traits for allocators
; 503  : 	typedef _Alloc allocator_type;
; 504  : 	typedef typename _Alloc::value_type value_type;
; 505  : 
; 506  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 507  : 		pointer;
; 508  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 509  : 		const_pointer;
; 510  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 511  : 		void_pointer;
; 512  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 513  : 		const_void_pointer;
; 514  : 
; 515  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 516  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 517  : 
; 518  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 519  : 		propagate_on_container_copy_assignment;
; 520  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 521  : 		propagate_on_container_move_assignment;
; 522  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 523  : 		propagate_on_container_swap;
; 524  : 	typedef typename _Get_is_always_equal<_Alloc>::type
; 525  : 		is_always_equal;
; 526  : 
; 527  : 	template<class _Other>
; 528  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 529  : 
; 530  : 	template<class _Other>
; 531  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 532  : 
; 533  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count)
; 534  : 		{	// allocate array of _Count elements
; 535  : 		return (_Al.allocate(_Count));
; 536  : 		}
; 537  : 
; 538  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count,
; 539  : 		const_void_pointer _Hint)
; 540  : 		{	// allocate array of _Count elements, with hint
; 541  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 542  : 		}
; 543  : 
; 544  : 	static void deallocate(_Alloc& _Al,
; 545  : 		pointer _Ptr, size_type _Count)
; 546  : 		{	// deallocate _Count elements at _Ptr
; 547  : 		_Al.deallocate(_Ptr, _Count);
; 548  : 		}
; 549  : 
; 550  : 	template<class _Ty,
; 551  : 		class... _Types>
; 552  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 553  : 			_Types&&... _Args)
; 554  : 		{	// construct _Ty(_Types...) at _Ptr
; 555  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 556  : 			_STD forward<_Types>(_Args)...);
; 557  : 		}
; 558  : 
; 559  : 
; 560  : 	template<class _Ty>
; 561  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 562  : 		{	// destroy object at _Ptr
; 563  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 564  : 		}
; 565  : 
; 566  : 	static size_type max_size(const _Alloc& _Al) _NOEXCEPT
; 567  : 		{	// get maximum size
; 568  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 569  : 		}
; 570  : 
; 571  : 	static _Alloc select_on_container_copy_construction(
; 572  : 		const _Alloc& _Al)
; 573  : 		{	// get allocator to use
; 574  : 		return (_Alloc_select::_Fn(0, _Al));
; 575  : 		}
; 576  : 	};
; 577  : 
; 578  : 		// TEMPLATE CLASS allocator
; 579  : template<class _Ty>
; 580  : 	class allocator
; 581  : 	{	// generic allocator for objects of class _Ty
; 582  : public:
; 583  : 	static_assert(!is_const<_Ty>::value,
; 584  : 		"The C++ Standard forbids containers of const elements "
; 585  : 		"because allocator<const T> is ill-formed.");
; 586  : 
; 587  : 	typedef _Ty value_type;
; 588  : 
; 589  : 	typedef value_type *pointer;
; 590  : 	typedef const value_type *const_pointer;
; 591  : 
; 592  : 	typedef value_type& reference;
; 593  : 	typedef const value_type& const_reference;
; 594  : 
; 595  : 	typedef size_t size_type;
; 596  : 	typedef ptrdiff_t difference_type;
; 597  : 
; 598  : 	typedef true_type propagate_on_container_move_assignment;
; 599  : 	typedef true_type is_always_equal;
; 600  : 
; 601  : 	template<class _Other>
; 602  : 		struct rebind
; 603  : 		{	// convert this type to allocator<_Other>
; 604  : 		typedef allocator<_Other> other;
; 605  : 		};
; 606  : 
; 607  : 	pointer address(reference _Val) const _NOEXCEPT
; 608  : 		{	// return address of mutable _Val
; 609  : 		return (_STD addressof(_Val));
; 610  : 		}
; 611  : 
; 612  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 613  : 		{	// return address of nonmutable _Val
; 614  : 		return (_STD addressof(_Val));
; 615  : 		}
; 616  : 
; 617  : 	allocator() _THROW0()
; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}
; 620  : 
; 621  : 	allocator(const allocator<_Ty>&) _THROW0()
; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}
; 624  : 
; 625  : 	template<class _Other>
; 626  : 		allocator(const allocator<_Other>&) _THROW0()
; 627  : 		{	// construct from a related allocator (do nothing)
; 628  : 		}
; 629  : 
; 630  : 	template<class _Other>
; 631  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 632  : 		{	// assign from a related allocator (do nothing)
; 633  : 		return (*this);
; 634  : 		}
; 635  : 
; 636  : 	void deallocate(pointer _Ptr, size_type _Count)
; 637  : 		{	// deallocate object at _Ptr
; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000e	77 31		 ja	 SHORT $LN16@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN7@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN18@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN19@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN20@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN21@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN7@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 909  : 		_Mybase::deallocate(_Ptr, _Count);
; 910  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN16@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  0005a	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@U_stMonsterIndexInfo@@@std@@@std@@QAEXPAU_stMonsterIndexInfo@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<_stMonsterIndexInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_stMonsterIndexInfo@@@std@@QAEXPAU_stMonsterIndexInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_stMonsterIndexInfo@@@std@@QAEXPAU_stMonsterIndexInfo@@I@Z PROC ; std::allocator<_stMonsterIndexInfo>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000e	77 31		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;

  00010	c1 e0 03	 shl	 eax, 3

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 1a		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0001a	f6 c1 1f	 test	 cl, 31			; 0000001fH
  0001d	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001f	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00022	3b c1		 cmp	 eax, ecx
  00024	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00026	2b c8		 sub	 ecx, eax
  00028	83 f9 04	 cmp	 ecx, 4
  0002b	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0002d	83 f9 23	 cmp	 ecx, 35			; 00000023H
  00030	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00032	8b c8		 mov	 ecx, eax
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003a	83 c4 04	 add	 esp, 4

; 639  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  0005a	cc		 int	 3
?deallocate@?$allocator@U_stMonsterIndexInfo@@@std@@QAEXPAU_stMonsterIndexInfo@@I@Z ENDP ; std::allocator<_stMonsterIndexInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?FindMagicInf@TMonsterSkillManager@@SA_NPAVTMonsterSkillUnit@@PAVCMagicInf@@@Z
_TEXT	SEGMENT
_lpMonsterSkillUnit$ = 8				; size = 4
_lpOutMagic$ = 12					; size = 4
?FindMagicInf@TMonsterSkillManager@@SA_NPAVTMonsterSkillUnit@@PAVCMagicInf@@@Z PROC ; TMonsterSkillManager::FindMagicInf, COMDAT

; 678  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 679  : 	if( lpMonsterSkillUnit == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMonsterSkillUnit$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 4c		 je	 SHORT $LN10@FindMagicI

; 680  : 		return false;
; 681  : 
; 682  : 	if( lpOutMagic == NULL )

  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpOutMagic$[ebp]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 45		 je	 SHORT $LN10@FindMagicI

; 683  : 		return false;
; 684  : 
; 685  : 	int nUnitNumber = lpMonsterSkillUnit->m_iUnitNumber;
; 686  : 
; 687  : 	switch( nUnitNumber )

  00011	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00014	83 c0 cd	 add	 eax, -51		; ffffffcdH
  00017	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0001a	77 3a		 ja	 SHORT $LN10@FindMagicI
  0001c	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN12@FindMagicI[eax]
  00023	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN14@FindMagicI[eax*4]
$LN6@FindMagicI:

; 688  : 	{
; 689  : 	case 64:
; 690  : 		lpOutMagic->m_Skill = 55;

  0002a	c7 41 08 37 00
	00 00		 mov	 DWORD PTR [ecx+8], 55	; 00000037H

; 703  : 	}
; 704  : 
; 705  : 	return true;

  00031	b0 01		 mov	 al, 1

; 706  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN7@FindMagicI:

; 691  : 		break;
; 692  : 	case 65:
; 693  : 		lpOutMagic->m_Skill = 237;

  00035	c7 41 08 ed 00
	00 00		 mov	 DWORD PTR [ecx+8], 237	; 000000edH

; 703  : 	}
; 704  : 
; 705  : 	return true;

  0003c	b0 01		 mov	 al, 1

; 706  : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN8@FindMagicI:

; 694  : 		break;
; 695  : 	case 66:
; 696  : 		lpOutMagic->m_Skill = 236;

  00040	c7 41 08 ec 00
	00 00		 mov	 DWORD PTR [ecx+8], 236	; 000000ecH

; 703  : 	}
; 704  : 
; 705  : 	return true;

  00047	b0 01		 mov	 al, 1

; 706  : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN9@FindMagicI:

; 697  : 		break;
; 698  : 	case 51:
; 699  : 		lpOutMagic->m_Skill = 5;

  0004b	c7 41 08 05 00
	00 00		 mov	 DWORD PTR [ecx+8], 5

; 703  : 	}
; 704  : 
; 705  : 	return true;

  00052	b0 01		 mov	 al, 1

; 706  : }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN10@FindMagicI:

; 700  : 		break;
; 701  : 	default:
; 702  : 		return false;

  00056	32 c0		 xor	 al, al

; 706  : }

  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
  0005a	66 90		 npad	 2
$LN14@FindMagicI:
  0005c	00 00 00 00	 DD	 $LN9@FindMagicI
  00060	00 00 00 00	 DD	 $LN6@FindMagicI
  00064	00 00 00 00	 DD	 $LN7@FindMagicI
  00068	00 00 00 00	 DD	 $LN8@FindMagicI
  0006c	00 00 00 00	 DD	 $LN10@FindMagicI
$LN12@FindMagicI:
  00070	00		 DB	 0
  00071	04		 DB	 4
  00072	04		 DB	 4
  00073	04		 DB	 4
  00074	04		 DB	 4
  00075	04		 DB	 4
  00076	04		 DB	 4
  00077	04		 DB	 4
  00078	04		 DB	 4
  00079	04		 DB	 4
  0007a	04		 DB	 4
  0007b	04		 DB	 4
  0007c	04		 DB	 4
  0007d	01		 DB	 1
  0007e	02		 DB	 2
  0007f	03		 DB	 3
?FindMagicInf@TMonsterSkillManager@@SA_NPAVTMonsterSkillUnit@@PAVCMagicInf@@@Z ENDP ; TMonsterSkillManager::FindMagicInf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?AddMonsterSkillDelayInfo@TMonsterSkillManager@@SAHHHHPAVTMonsterSkillUnit@@@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
_iTargetIndex$ = 12					; size = 4
_iDelayTime$ = 16					; size = 4
_lpMonsterSkillUnit$ = 20				; size = 4
?AddMonsterSkillDelayInfo@TMonsterSkillManager@@SAHHHHPAVTMonsterSkillUnit@@@Z PROC ; TMonsterSkillManager::AddMonsterSkillDelayInfo, COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  : 	for ( int i=0;i<MAX_MONSTER_SKILL_DELAY_INFO_ARRAY;i++)

  00003	33 c9		 xor	 ecx, ecx
  00005	b8 00 00 00 00	 mov	 eax, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A ; TMonsterSkillManager::s_MonsterSkillDelayInfoArray
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL4@AddMonster:

; 191  : 	{
; 192  : 		if ( TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].bIsUsed == FALSE )

  00010	83 38 00	 cmp	 DWORD PTR [eax], 0
  00013	74 1f		 je	 SHORT $LN8@AddMonster

; 190  : 	for ( int i=0;i<MAX_MONSTER_SKILL_DELAY_INFO_ARRAY;i++)

  00015	83 c0 14	 add	 eax, 20			; 00000014H
  00018	41		 inc	 ecx
  00019	3d 60 ea 00 00	 cmp	 eax, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+60000
  0001e	7c f0		 jl	 SHORT $LL4@AddMonster

; 201  : 		}
; 202  : 	}
; 203  : 
; 204  : 	LogAddC(2, "[Monster Skill Manager] - (MonsterSkillDelayInfo) Slot Full!! ");

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@OCKDOEEK@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CIMonst@
  00025	6a 02		 push	 2
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002d	83 c4 08	 add	 esp, 8

; 205  : 	return FALSE;

  00030	33 c0		 xor	 eax, eax

; 206  : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN8@AddMonster:

; 193  : 		{
; 194  : 			TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].iIndex = iIndex;

  00034	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00037	56		 push	 esi
  00038	8d 34 89	 lea	 esi, DWORD PTR [ecx+ecx*4]
  0003b	89 04 b5 04 00
	00 00		 mov	 DWORD PTR ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A[esi*4+4], eax

; 195  : 			TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].iTargetIndex = iTargetIndex;

  00042	8b 45 0c	 mov	 eax, DWORD PTR _iTargetIndex$[ebp]
  00045	89 04 b5 08 00
	00 00		 mov	 DWORD PTR ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A[esi*4+8], eax

; 196  : 			TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].dwDelayTime = GetTickCount() + iDelayTime;

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00052	03 45 10	 add	 eax, DWORD PTR _iDelayTime$[ebp]
  00055	89 04 b5 0c 00
	00 00		 mov	 DWORD PTR ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A[esi*4+12], eax

; 197  : 			TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].lpMonsterSkillUnit = lpMonsterSkillUnit;

  0005c	8b 45 14	 mov	 eax, DWORD PTR _lpMonsterSkillUnit$[ebp]
  0005f	89 04 b5 10 00
	00 00		 mov	 DWORD PTR ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A[esi*4+16], eax

; 198  : 			TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].bIsUsed = TRUE;
; 199  : 
; 200  : 			return TRUE;

  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	c7 04 b5 00 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A[esi*4], 1
  00076	5e		 pop	 esi

; 206  : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?AddMonsterSkillDelayInfo@TMonsterSkillManager@@SAHHHHPAVTMonsterSkillUnit@@@Z ENDP ; TMonsterSkillManager::AddMonsterSkillDelayInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?MonsterSkillProc@TMonsterSkillManager@@SAXXZ
_TEXT	SEGMENT
_dwCurrentTick$1$ = -4					; size = 4
?MonsterSkillProc@TMonsterSkillManager@@SAXXZ PROC	; TMonsterSkillManager::MonsterSkillProc, COMDAT

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 212  : 	DWORD dwCurrentTick = GetTickCount();

  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000d	89 45 fc	 mov	 DWORD PTR _dwCurrentTick$1$[ebp], eax
  00010	be 08 00 00 00	 mov	 esi, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+8
$LL4@MonsterSki:

; 215  : 	{
; 216  : 		if ( TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].bIsUsed == TRUE )

  00015	83 7e f8 01	 cmp	 DWORD PTR [esi-8], 1
  00019	0f 85 b6 00 00
	00		 jne	 $LN2@MonsterSki

; 217  : 		{
; 218  : 			if ( dwCurrentTick < TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].dwDelayTime )

  0001f	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00022	0f 83 ad 00 00
	00		 jae	 $LN2@MonsterSki
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h

; 34   : 		if ( !OBJMAX_RANGE(this->iIndex) || !OBJMAX_RANGE(this->iTargetIndex) )

  00028	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  0002b	85 c9		 test	 ecx, ecx
  0002d	0f 88 80 00 00
	00		 js	 $LN14@MonsterSki
  00033	33 c0		 xor	 eax, eax
  00035	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0003b	0f 9e c0	 setle	 al
  0003e	85 c0		 test	 eax, eax
  00040	74 71		 je	 SHORT $LN14@MonsterSki
  00042	8b 16		 mov	 edx, DWORD PTR [esi]
  00044	85 d2		 test	 edx, edx
  00046	78 6b		 js	 SHORT $LN14@MonsterSki
  00048	33 c0		 xor	 eax, eax
  0004a	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00050	0f 9e c0	 setle	 al
  00053	85 c0		 test	 eax, eax
  00055	74 5c		 je	 SHORT $LN14@MonsterSki

; 35   : 			return FALSE;
; 36   : 
; 37   : 		if ( this->lpMonsterSkillUnit == NULL )

  00057	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0005b	74 56		 je	 SHORT $LN14@MonsterSki
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 229  : 				LPOBJ lpTargetObj = &gObj[stInfo.iTargetIndex];

  0005d	69 d9 40 27 00
	00		 imul	 ebx, ecx, 10048
  00063	69 fa 40 27 00
	00		 imul	 edi, edx, 10048
  00069	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 230  : 
; 231  : 				if ( !lpObj->Live || !lpTargetObj->Live )

  00075	80 7b 51 00	 cmp	 BYTE PTR [ebx+81], 0
  00079	74 38		 je	 SHORT $LN14@MonsterSki
  0007b	80 7f 51 00	 cmp	 BYTE PTR [edi+81], 0
  0007f	74 32		 je	 SHORT $LN14@MonsterSki

; 232  : 				{
; 233  : 					TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].RESET();
; 234  : 					continue;
; 235  : 				}
; 236  : 
; 237  : 				if ( !gObjIsConnected(lpTargetObj))

  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00087	83 c4 04	 add	 esp, 4
  0008a	85 c0		 test	 eax, eax
  0008c	74 25		 je	 SHORT $LN14@MonsterSki

; 238  : 				{
; 239  : 					TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].RESET();
; 240  : 					continue;
; 241  : 				}
; 242  : 
; 243  : 				gObjAttack(lpObj, lpTargetObj, 0, 0, 0, 0, 0, 0, 0);

  0008e	6a 00		 push	 0
  00090	6a 00		 push	 0
  00092	6a 00		 push	 0
  00094	6a 00		 push	 0
  00096	6a 00		 push	 0
  00098	6a 00		 push	 0
  0009a	6a 00		 push	 0
  0009c	57		 push	 edi
  0009d	53		 push	 ebx
  0009e	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack

; 244  : 				stInfo.lpMonsterSkillUnit->RunSkill(stInfo.iIndex, stInfo.iTargetIndex);

  000a3	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a6	83 c4 24	 add	 esp, 36			; 00000024H
  000a9	ff 36		 push	 DWORD PTR [esi]
  000ab	ff 76 fc	 push	 DWORD PTR [esi-4]
  000ae	e8 00 00 00 00	 call	 ?RunSkill@TMonsterSkillUnit@@QAEXHH@Z ; TMonsterSkillUnit::RunSkill
$LN14@MonsterSki:
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h

; 24   : 		this->iIndex = -1;

  000b3	c7 46 fc ff ff
	ff ff		 mov	 DWORD PTR [esi-4], -1

; 25   : 		this->iTargetIndex = -1;
; 26   : 		this->dwDelayTime = 0;
; 27   : 		this->bIsUsed = FALSE;
; 28   : 		this->lpMonsterSkillUnit = NULL;

  000ba	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  000c1	c7 46 f8 00 00
	00 00		 mov	 DWORD PTR [esi-8], 0
  000c8	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  000cf	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN2@MonsterSki:
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 214  : 	for ( int i=0;i<MAX_MONSTER_SKILL_DELAY_INFO_ARRAY;i++)

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _dwCurrentTick$1$[ebp]
  000d8	83 c6 14	 add	 esi, 20			; 00000014H
  000db	81 fe 68 ea 00
	00		 cmp	 esi, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+60008
  000e1	0f 8c 2e ff ff
	ff		 jl	 $LL4@MonsterSki
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 245  : 				TMonsterSkillManager::s_MonsterSkillDelayInfoArray[i].RESET();
; 246  : 			}
; 247  : 		}
; 248  : 	}
; 249  : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
?MonsterSkillProc@TMonsterSkillManager@@SAXXZ ENDP	; TMonsterSkillManager::MonsterSkillProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?FindMonsterSkillUnit@TMonsterSkillManager@@SAPAVTMonsterSkillUnit@@HH@Z
_TEXT	SEGMENT
_iFoundSkillArray$ = -44				; size = 40
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iMonsterSkillUnitType$ = 12				; size = 4
?FindMonsterSkillUnit@TMonsterSkillManager@@SAPAVTMonsterSkillUnit@@HH@Z PROC ; TMonsterSkillManager::FindMonsterSkillUnit, COMDAT

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 254  : 	LPOBJ lpObj = &gObj[iIndex];

  00010	69 4d 08 40 27
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 10048

; 255  : 	TMonsterSkillInfo * lpMonsterSkillInfo = &TMonsterSkillManager::s_MonsterSkillInfoArray[lpObj->Class];

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001c	57		 push	 edi
  0001d	0f b7 84 01 90
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+144]
  00025	6b f8 58	 imul	 edi, eax, 88
  00028	81 c7 00 00 00
	00		 add	 edi, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A ; TMonsterSkillManager::s_MonsterSkillInfoArray
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h

; 40   : 		if ( this->m_iMonsterIndex == -1 || this->m_iSkillUnitCount == 0 )

  0002e	83 3f ff	 cmp	 DWORD PTR [edi], -1
  00031	0f 84 ef 00 00
	00		 je	 $LN12@FindMonste
  00037	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0003b	0f 84 e5 00 00
	00		 je	 $LN12@FindMonste
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 261  : 	int iFoundSkillCount = 0;

  00041	8b 45 0c	 mov	 eax, DWORD PTR _iMonsterSkillUnitType$[ebp]
  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	56		 push	 esi
  00048	33 f6		 xor	 esi, esi
  0004a	c7 45 d4 ff ff
	ff ff		 mov	 DWORD PTR _iFoundSkillArray$[ebp], -1
  00051	0f 11 45 d8	 movups	 XMMWORD PTR _iFoundSkillArray$[ebp+4], xmm0
  00055	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iFoundSkillArray$[ebp+36], 0
  0005c	0f 11 45 e8	 movups	 XMMWORD PTR _iFoundSkillArray$[ebp+20], xmm0

; 262  : 
; 263  : 	for(int i=0;i<MAX_SKILL_UNIT;i++)
; 264  : 	{
; 265  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  00060	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  00063	75 08		 jne	 SHORT $LN2@FindMonste

; 266  : 		{
; 267  : 			iFoundSkillArray[iFoundSkillCount] = i;

  00065	89 75 d4	 mov	 DWORD PTR _iFoundSkillArray$[ebp], esi

; 268  : 			iFoundSkillCount++;

  00068	be 01 00 00 00	 mov	 esi, 1
$LN2@FindMonste:

; 262  : 
; 263  : 	for(int i=0;i<MAX_SKILL_UNIT;i++)
; 264  : 	{
; 265  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  0006d	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  00070	75 09		 jne	 SHORT $LN21@FindMonste

; 266  : 		{
; 267  : 			iFoundSkillArray[iFoundSkillCount] = i;

  00072	c7 44 b5 d4 01
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 1

; 268  : 			iFoundSkillCount++;

  0007a	46		 inc	 esi
$LN21@FindMonste:

; 262  : 
; 263  : 	for(int i=0;i<MAX_SKILL_UNIT;i++)
; 264  : 	{
; 265  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  0007b	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  0007e	75 09		 jne	 SHORT $LN23@FindMonste

; 266  : 		{
; 267  : 			iFoundSkillArray[iFoundSkillCount] = i;

  00080	c7 44 b5 d4 02
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 2

; 268  : 			iFoundSkillCount++;

  00088	46		 inc	 esi
$LN23@FindMonste:

; 262  : 
; 263  : 	for(int i=0;i<MAX_SKILL_UNIT;i++)
; 264  : 	{
; 265  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  00089	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  0008c	75 09		 jne	 SHORT $LN25@FindMonste

; 266  : 		{
; 267  : 			iFoundSkillArray[iFoundSkillCount] = i;

  0008e	c7 44 b5 d4 03
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 3

; 268  : 			iFoundSkillCount++;

  00096	46		 inc	 esi
$LN25@FindMonste:

; 262  : 
; 263  : 	for(int i=0;i<MAX_SKILL_UNIT;i++)
; 264  : 	{
; 265  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  00097	3b 47 18	 cmp	 eax, DWORD PTR [edi+24]
  0009a	75 09		 jne	 SHORT $LN27@FindMonste

; 266  : 		{
; 267  : 			iFoundSkillArray[iFoundSkillCount] = i;

  0009c	c7 44 b5 d4 04
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 4

; 268  : 			iFoundSkillCount++;

  000a4	46		 inc	 esi
$LN27@FindMonste:

; 262  : 
; 263  : 	for(int i=0;i<MAX_SKILL_UNIT;i++)
; 264  : 	{
; 265  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000a5	3b 47 1c	 cmp	 eax, DWORD PTR [edi+28]
  000a8	75 09		 jne	 SHORT $LN29@FindMonste

; 266  : 		{
; 267  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000aa	c7 44 b5 d4 05
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 5

; 268  : 			iFoundSkillCount++;

  000b2	46		 inc	 esi
$LN29@FindMonste:

; 262  : 
; 263  : 	for(int i=0;i<MAX_SKILL_UNIT;i++)
; 264  : 	{
; 265  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000b3	3b 47 20	 cmp	 eax, DWORD PTR [edi+32]
  000b6	75 09		 jne	 SHORT $LN31@FindMonste

; 266  : 		{
; 267  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000b8	c7 44 b5 d4 06
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 6

; 268  : 			iFoundSkillCount++;

  000c0	46		 inc	 esi
$LN31@FindMonste:

; 262  : 
; 263  : 	for(int i=0;i<MAX_SKILL_UNIT;i++)
; 264  : 	{
; 265  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000c1	3b 47 24	 cmp	 eax, DWORD PTR [edi+36]
  000c4	75 09		 jne	 SHORT $LN33@FindMonste

; 266  : 		{
; 267  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000c6	c7 44 b5 d4 07
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 7

; 268  : 			iFoundSkillCount++;

  000ce	46		 inc	 esi
$LN33@FindMonste:

; 262  : 
; 263  : 	for(int i=0;i<MAX_SKILL_UNIT;i++)
; 264  : 	{
; 265  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000cf	3b 47 28	 cmp	 eax, DWORD PTR [edi+40]
  000d2	75 09		 jne	 SHORT $LN35@FindMonste

; 266  : 		{
; 267  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000d4	c7 44 b5 d4 08
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 8

; 268  : 			iFoundSkillCount++;

  000dc	46		 inc	 esi
$LN35@FindMonste:

; 262  : 
; 263  : 	for(int i=0;i<MAX_SKILL_UNIT;i++)
; 264  : 	{
; 265  : 		if ( iMonsterSkillUnitType == lpMonsterSkillInfo->m_iSkillUnitTypeArray[i] )

  000dd	3b 47 2c	 cmp	 eax, DWORD PTR [edi+44]
  000e0	75 09		 jne	 SHORT $LN37@FindMonste

; 266  : 		{
; 267  : 			iFoundSkillArray[iFoundSkillCount] = i;

  000e2	c7 44 b5 d4 09
	00 00 00	 mov	 DWORD PTR _iFoundSkillArray$[ebp+esi*4], 9

; 268  : 			iFoundSkillCount++;

  000ea	46		 inc	 esi
$LN37@FindMonste:

; 269  : 		}
; 270  : 	}
; 271  : 
; 272  : 	if ( iFoundSkillCount > 0 )

  000eb	85 f6		 test	 esi, esi
  000ed	7e 25		 jle	 SHORT $LN7@FindMonste

; 273  : 	{
; 274  : 		int iSlot = iFoundSkillArray[rand() % iFoundSkillCount];

  000ef	e8 00 00 00 00	 call	 _rand
  000f4	99		 cdq
  000f5	f7 fe		 idiv	 esi
  000f7	8b 44 95 d4	 mov	 eax, DWORD PTR _iFoundSkillArray$[ebp+edx*4]

; 275  : 
; 276  : 		if ( iSlot == -1 )

  000fb	83 f8 ff	 cmp	 eax, -1
  000fe	74 14		 je	 SHORT $LN7@FindMonste

; 277  : 			return NULL;
; 278  : 
; 279  : 		TMonsterSkillUnit * lpMonsterSkillUnit = lpMonsterSkillInfo->m_lpSkillUnitArray[iSlot];
; 280  : 		
; 281  : 		return lpMonsterSkillUnit;

  00100	8b 44 87 30	 mov	 eax, DWORD PTR [edi+eax*4+48]
  00104	5e		 pop	 esi
  00105	5f		 pop	 edi

; 285  : }

  00106	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00109	33 cd		 xor	 ecx, ebp
  0010b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
$LN7@FindMonste:
  00114	5e		 pop	 esi

; 282  : 	}
; 283  : 	
; 284  : 	return NULL;

  00115	33 c0		 xor	 eax, eax
  00117	5f		 pop	 edi

; 285  : }

  00118	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011b	33 cd		 xor	 ecx, ebp
  0011d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
$LN12@FindMonste:
  00126	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00129	33 c0		 xor	 eax, eax
  0012b	33 cd		 xor	 ecx, ebp
  0012d	5f		 pop	 edi
  0012e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
?FindMonsterSkillUnit@TMonsterSkillManager@@SAPAVTMonsterSkillUnit@@HH@Z ENDP ; TMonsterSkillManager::FindMonsterSkillUnit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?UseMonsterSkill@TMonsterSkillManager@@SAXHHHHPAVCMagicInf@@@Z
_TEXT	SEGMENT
_iRangeTargetIndex$1$ = -16				; size = 4
_iAngle$1$ = -12					; size = 4
tv580 = -8						; size = 4
tv592 = -4						; size = 4
_iIndex$ = 8						; size = 4
_iTargetIndex$ = 12					; size = 4
_iMonsterSkillUnitType$ = 16				; size = 4
_iMonsterSkillUnit$ = 20				; size = 4
_lpMagic$ = 24						; size = 4
?UseMonsterSkill@TMonsterSkillManager@@SAXHHHHPAVCMagicInf@@@Z PROC ; TMonsterSkillManager::UseMonsterSkill, COMDAT

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 319  : 	/*if( iIndex >= OBJ_MAXMONSTER || iIndex < 0 )
; 320  : 	{
; 321  : 		LogAddC(2,"[TMonsterSkillManager][UserMonsterSkill] error: iIndex(%d)",iIndex);
; 322  : 		return;
; 323  : 	}
; 324  : 
; 325  : 	if( iTargetIndex >= OBJMAX || iTargetIndex < 0 )
; 326  : 	{
; 327  : 		LogAddC(2,"[TMonsterSkillManager][UserMonsterSkill] error: iTargetIndex(%d)",iTargetIndex);
; 328  : 		return;
; 329  : 	}
; 330  : 
; 331  : 	LPOBJ lpObj = &gObj[iIndex];
; 332  : 	LPOBJ lpTargetObj = &gObj[iTargetIndex];
; 333  : 
; 334  : 	TMonsterSkillInfo * lpMonsterSkillInfo = &TMonsterSkillManager::s_MonsterSkillInfoArray[lpObj->Class];
; 335  : 
; 336  : 	if ( lpMonsterSkillInfo->IsValid() == FALSE )
; 337  : 		return;
; 338  : 
; 339  : 	TMonsterSkillUnit * lpMonsterSkillUnit = NULL;
; 340  : 
; 341  : 	if( iMonsterSkillUnit > -1 )
; 342  : 	{
; 343  : 		int iUnit = iMonsterSkillUnit;
; 344  : 		lpMonsterSkillUnit = lpMonsterSkillInfo->m_lpSkillUnitArray[iUnit];
; 345  : 	}
; 346  : 	else
; 347  : 	{
; 348  : 		lpMonsterSkillUnit = TMonsterSkillManager::FindMonsterSkillUnit(iIndex, iMonsterSkillUnitType);
; 349  : 	}
; 350  : 
; 351  : 	if ( lpMonsterSkillUnit == NULL )
; 352  : 	{
; 353  : 		LogAddC(2, "[Monster Skill Manager] SkillUnit is NULL : ObjIndex[%d], SkillUnitType[%d] ",iIndex,iMonsterSkillUnitType);
; 354  : 		return;
; 355  : 	}
; 356  : 
; 357  : 	if ( IF_MAP_RANGE(lpObj->MapNumber) )
; 358  : 	{
; 359  : 		CMagicInf cMagicInf;
; 360  : 		memset(&cMagicInf,0,sizeof(cMagicInf));
; 361  : 
; 362  : 		if( lpObj->Class == 519 && lpMonsterSkillUnit->m_iUnitNumber == 46 )
; 363  : 		{
; 364  : 			int nResult = gGetLowHPMonster(lpObj->m_ImperialGuardianZone,lpObj->m_Index,6);
; 365  : 
; 366  : 			if( nResult == -1 )
; 367  : 			{
; 368  : 				GCActionSend(lpObj,120,lpObj->m_Index,lpObj->TargetNumber);
; 369  : 				gObjAttack(lpObj,lpTargetObj,0,0,0,0,0,0,0);
; 370  : 				return;
; 371  : 			}
; 372  : 			else
; 373  : 			{
; 374  : 				lpTargetObj = &gObj[nResult];
; 375  : 				iTargetIndex = nResult;
; 376  : 			}
; 377  : 		}
; 378  : 
; 379  : 		if( lpMonsterSkillUnit->m_iUnitTargetType == 5 )
; 380  : 		{
; 381  : 			lpTargetObj = &gObj[iIndex];
; 382  : 			iTargetIndex = iIndex;
; 383  : 		}
; 384  : 
; 385  : 		if( lpMagic == NULL )
; 386  : 		{
; 387  : 			lpMagic = &cMagicInf;
; 388  : 			TMonsterSkillManager::FindMagicInf(lpMonsterSkillUnit,lpMagic);
; 389  : 		}
; 390  : 	}
; 391  : 
; 392  : 	GCUseMonsterSkillSend(lpObj, lpTargetObj, lpMonsterSkillUnit->m_iUnitNumber);
; 393  : 
; 394  : 	if ( lpMonsterSkillUnit->m_iUnitScopeType == -1 )
; 395  : 	{
; 396  : 		if ( lpObj->MapNumber == MAP_INDEX_RAKLION )
; 397  : 		{
; 398  : 			gObjAttack(lpObj,lpTargetObj,0,0,0,0,0,0,0);
; 399  : 		}
; 400  : 
; 401  : 		if ( lpObj->MapNumber == MAP_INDEX_RAKLIONBOSS )
; 402  : 		{
; 403  : 			if( lpObj->Class == 459 )
; 404  : 			{
; 405  : 				if ( lpMonsterSkillUnit->m_iUnitNumber == 40 )
; 406  : 				{
; 407  : 					gObjAttack(lpObj,lpTargetObj,0,0,0,0,0,0,0);
; 408  : 				}
; 409  : 				else if( lpMagic != 0 )
; 410  : 				{
; 411  : 					gObjAttack(lpObj,lpTargetObj,lpMagic,0,0,0,0,0,0);
; 412  : 				}
; 413  : 			}
; 414  : 			else
; 415  : 			{
; 416  : 				gObjAttack(lpObj,lpTargetObj,0,0,0,0,0,0,0);
; 417  : 			}
; 418  : 		}
; 419  : 
; 420  : 		//if( lpMonsterSkillUnit->m_iUnitTargetType == -1 )
; 421  : 			//iTargetIndex = iIndex;
; 422  : 
; 423  : 		lpMonsterSkillUnit->RunSkill(iIndex, iTargetIndex);
; 424  : 	}
; 425  : 	else
; 426  : 	{
; 427  : 		int iCount = 0;
; 428  : 		int iRangeTargetIndex = -1;
; 429  : 		int iAngle = gObjUseSkill.GetAngle(lpObj->X, lpObj->Y, lpTargetObj->X, lpTargetObj->Y);
; 430  : 
; 431  : 		while ( true )
; 432  : 		{
; 433  : 			if ( lpObj->VpPlayer2[iCount].state )
; 434  : 			{
; 435  : 				iRangeTargetIndex = lpObj->VpPlayer2[iCount].number;
; 436  : 
; 437  : 				if ( OBJMAX_RANGE(iRangeTargetIndex))
; 438  : 				{
; 439  : 					if ( gObj[iRangeTargetIndex].Type == OBJ_USER )
; 440  : 					{
; 441  : 						BOOL bTargetOK = FALSE;
; 442  : 
; 443  : 						if ( lpMonsterSkillUnit->m_iUnitScopeType == 0 )
; 444  : 						{
; 445  : 							if ( gObjCalDistance(lpObj, &gObj[iRangeTargetIndex]) < lpMonsterSkillUnit->m_iUnitScopeValue )
; 446  : 							{
; 447  : 								bTargetOK = TRUE;
; 448  : 							}
; 449  : 						}
; 450  : 						else  if ( lpMonsterSkillUnit->m_iUnitScopeType == 1 )
; 451  : 						{
; 452  : 							if ( SkillElectricSparkHitBox.HitCheck(iAngle, lpObj->X, lpObj->Y,
; 453  : 								gObj[iRangeTargetIndex].X, gObj[iRangeTargetIndex].Y) )
; 454  : 							{
; 455  : 								bTargetOK = TRUE;
; 456  : 							}
; 457  : 						}
; 458  : 						else if ( lpMonsterSkillUnit->m_iUnitScopeType == 2 )
; 459  : 						{
; 460  : 							bTargetOK = TRUE;
; 461  : 						}
; 462  : 						else if ( lpMonsterSkillUnit->m_iUnitScopeType == 3 )
; 463  : 						{
; 464  : 							bTargetOK = TRUE;
; 465  : 						}
; 466  : 
; 467  : 						if ( bTargetOK )
; 468  : 						{
; 469  : 							if ( lpObj->MapNumber == MAP_INDEX_RAKLION )
; 470  : 							{
; 471  : 								gObjAttack(lpObj,lpTargetObj,0,0,0,0,0,0,0);
; 472  : 							}
; 473  : 
; 474  : 							if ( lpObj->MapNumber == MAP_INDEX_RAKLIONBOSS )
; 475  : 							{
; 476  : 								if( lpObj->Class == 459 )
; 477  : 								{
; 478  : 									if ( lpMonsterSkillUnit->m_iUnitNumber == 40 )
; 479  : 									{
; 480  : 										gObjAttack(lpObj,lpTargetObj,0,0,0,0,0,0,0);
; 481  : 									}
; 482  : 									else if( lpMagic != 0 )
; 483  : 									{
; 484  : 										gObjAttack(lpObj,lpTargetObj,lpMagic,0,0,0,0,0,0);
; 485  : 									}
; 486  : 								}
; 487  : 								else
; 488  : 								{
; 489  : 									gObjAttack(lpObj,lpTargetObj,0,0,0,0,0,0,0);
; 490  : 								}
; 491  : 							}
; 492  : 
; 493  : 							if ( IF_MONSTER_RANGE(lpObj->Class) )
; 494  : 							{
; 495  : 								if( lpMagic != 0 )
; 496  : 								{
; 497  : 									gObjAttack(lpObj,lpTargetObj,lpMagic,0,0,0,0,0,0);
; 498  : 								}
; 499  : 								else
; 500  : 								{
; 501  : 									gObjAttack(lpObj,lpTargetObj,0,0,0,0,0,0,0);
; 502  : 								}
; 503  : 							}
; 504  : 
; 505  : 							lpMonsterSkillUnit->RunSkill(iIndex, iRangeTargetIndex);
; 506  : 						}
; 507  : 					}
; 508  : 				}
; 509  : 			}
; 510  : 
; 511  : 			iCount++;
; 512  : 
; 513  : 			if ( iCount > MAX_VIEWPORT_MONSTER-1)
; 514  : 				break;
; 515  : 		}
; 516  : 	}*/
; 517  : 	if (iIndex >= OBJ_MAXMONSTER || iIndex < 0)

  00003	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	81 fa 03 29 00
	00		 cmp	 edx, 10499		; 00002903H
  0000f	0f 87 ad 02 00
	00		 ja	 $LN5@UseMonster

; 520  : 		return;
; 521  : 	}
; 522  : 
; 523  : 	if (iTargetIndex >= OBJMAX || iTargetIndex < 0)

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _iTargetIndex$[ebp]
  00018	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0001e	0f 87 89 02 00
	00		 ja	 $LN7@UseMonster

; 526  : 		return;
; 527  : 	}
; 528  : 
; 529  : 	LPOBJ lpObj = &gObj[iIndex]; //loc1

  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	69 f2 40 27 00
	00		 imul	 esi, edx, 10048
  0002c	57		 push	 edi

; 530  : 	LPOBJ lpTargetObj = &gObj[iTargetIndex]; //loc2

  0002d	69 f9 40 27 00
	00		 imul	 edi, ecx, 10048
  00033	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 531  : 	TMonsterSkillInfo * lpMonsterSkillInfo = &TMonsterSkillManager::s_MonsterSkillInfoArray[lpObj->Class]; //loc3

  0003f	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  00046	6b d8 58	 imul	 ebx, eax, 88
  00049	81 c3 00 00 00
	00		 add	 ebx, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A ; TMonsterSkillManager::s_MonsterSkillInfoArray
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h

; 40   : 		if ( this->m_iMonsterIndex == -1 || this->m_iSkillUnitCount == 0 )

  0004f	83 3b ff	 cmp	 DWORD PTR [ebx], -1
  00052	74 3f		 je	 SHORT $LN61@UseMonster
  00054	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00058	74 39		 je	 SHORT $LN61@UseMonster
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 538  : 	if ( iMonsterSkillUnit > -1) //arg4

  0005a	8b 4d 14	 mov	 ecx, DWORD PTR _iMonsterSkillUnit$[ebp]
  0005d	8b 45 10	 mov	 eax, DWORD PTR _iMonsterSkillUnitType$[ebp]
  00060	83 f9 ff	 cmp	 ecx, -1
  00063	7e 06		 jle	 SHORT $LN9@UseMonster

; 539  : 	{
; 540  : 		int iMonsterSkill = iMonsterSkillUnit; //loc5
; 541  : 
; 542  : 		lpMonsterSkillUnit = lpMonsterSkillInfo->m_lpSkillUnitArray[iMonsterSkill];

  00065	8b 5c 8b 30	 mov	 ebx, DWORD PTR [ebx+ecx*4+48]

; 543  : 	}
; 544  : 	else

  00069	eb 12		 jmp	 SHORT $LN10@UseMonster
$LN9@UseMonster:

; 545  : 	{
; 546  : 		lpMonsterSkillUnit = TMonsterSkillManager::FindMonsterSkillUnit(iIndex, iMonsterSkillUnitType);

  0006b	50		 push	 eax
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 ?FindMonsterSkillUnit@TMonsterSkillManager@@SAPAVTMonsterSkillUnit@@HH@Z ; TMonsterSkillManager::FindMonsterSkillUnit
  00072	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00075	8b d8		 mov	 ebx, eax
  00077	8b 45 10	 mov	 eax, DWORD PTR _iMonsterSkillUnitType$[ebp]
  0007a	83 c4 08	 add	 esp, 8
$LN10@UseMonster:

; 547  : 	}
; 548  : 
; 549  : 	if ( lpMonsterSkillUnit == NULL )

  0007d	85 db		 test	 ebx, ebx
  0007f	75 19		 jne	 SHORT $LN11@UseMonster

; 550  : 	{
; 551  : 		LogAddC(2, "[Monster Skill Manager] SkillUnit is NULL : ObjIndex[%d], SkillUnitType[%d] ",iIndex,iMonsterSkillUnitType);

  00081	50		 push	 eax
  00082	52		 push	 edx
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@PFFOMJLG@?$FLMonster?5Skill?5Manager?$FN?5SkillUni@
  00088	6a 02		 push	 2
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00090	83 c4 10	 add	 esp, 16			; 00000010H
$LN61@UseMonster:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx

; 671  : 				break;
; 672  : 		}
; 673  : 	}
; 674  : }

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
$LN11@UseMonster:

; 552  : 		return;
; 553  : 	}
; 554  : 
; 555  : 	GCUseMonsterSkillSend(lpObj, lpTargetObj, lpMonsterSkillUnit->m_iUnitNumber);

  0009a	ff 73 18	 push	 DWORD PTR [ebx+24]
  0009d	57		 push	 edi
  0009e	56		 push	 esi
  0009f	e8 00 00 00 00	 call	 ?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z ; GCUseMonsterSkillSend
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 556  : 
; 557  : 	//TEST
; 558  : 	//char szTemp[256];
; 559  : 	//wsprintf(szTemp, "[USEMONSTERSKILL] %d", lpMonsterSkillUnit->m_iUnitNumber);
; 560  : 	//GCServerMsgStringSend(szTemp, lpTargetObj->m_Index, 1);
; 561  : 
; 562  : 	if ( lpMonsterSkillUnit->m_iUnitScopeType == -1 )

  000a7	83 7b 20 ff	 cmp	 DWORD PTR [ebx+32], -1
  000ab	0f 85 80 00 00
	00		 jne	 $LN12@UseMonster

; 563  : 	{
; 564  : 		if ( lpObj->MapNumber == MAP_INDEX_RAKLION )

  000b1	80 be 23 01 00
	00 39		 cmp	 BYTE PTR [esi+291], 57	; 00000039H
  000b8	75 18		 jne	 SHORT $LN14@UseMonster

; 565  : 		{
; 566  : 			gObjAttack(lpObj, lpTargetObj, NULL, FALSE, 0, 0, FALSE,0,0);

  000ba	6a 00		 push	 0
  000bc	6a 00		 push	 0
  000be	6a 00		 push	 0
  000c0	6a 00		 push	 0
  000c2	6a 00		 push	 0
  000c4	6a 00		 push	 0
  000c6	6a 00		 push	 0
  000c8	57		 push	 edi
  000c9	56		 push	 esi
  000ca	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  000cf	83 c4 24	 add	 esp, 36			; 00000024H
$LN14@UseMonster:

; 567  : 		}
; 568  :         if ( lpObj->MapNumber == MAP_INDEX_RAKLIONBOSS )

  000d2	80 be 23 01 00
	00 3a		 cmp	 BYTE PTR [esi+291], 58	; 0000003aH
  000d9	75 42		 jne	 SHORT $LN17@UseMonster

; 569  :         {
; 570  : 			if ( lpObj->Class == 459 )

  000db	b8 cb 01 00 00	 mov	 eax, 459		; 000001cbH
  000e0	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  000e7	75 1c		 jne	 SHORT $LN16@UseMonster

; 571  : 			{
; 572  :                 if ( lpMonsterSkillUnit->m_iUnitNumber == 40 )

  000e9	83 7b 18 28	 cmp	 DWORD PTR [ebx+24], 40	; 00000028H
  000ed	74 16		 je	 SHORT $LN16@UseMonster

; 573  :                 {
; 574  : 					gObjAttack(lpObj, lpTargetObj, NULL, FALSE, 0, 0, FALSE,0,0);
; 575  :                 }
; 576  : 				else
; 577  :                 {
; 578  : 					if ( lpMagic )

  000ef	8b 45 18	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  000f2	85 c0		 test	 eax, eax
  000f4	74 27		 je	 SHORT $LN17@UseMonster

; 579  : 					{
; 580  : 						gObjAttack(lpObj, lpTargetObj,lpMagic, 0, 0, 0, 0,0,0);

  000f6	6a 00		 push	 0
  000f8	6a 00		 push	 0
  000fa	6a 00		 push	 0
  000fc	6a 00		 push	 0
  000fe	6a 00		 push	 0
  00100	6a 00		 push	 0
  00102	50		 push	 eax

; 581  : 					}
; 582  :                 }
; 583  :             }
; 584  :             else

  00103	eb 0e		 jmp	 SHORT $LN64@UseMonster
$LN16@UseMonster:

; 585  :             {
; 586  :                 gObjAttack(lpObj, lpTargetObj, 0, 0, 0, 0, 0,0,0);

  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	6a 00		 push	 0
  0010d	6a 00		 push	 0
  0010f	6a 00		 push	 0
  00111	6a 00		 push	 0
$LN64@UseMonster:
  00113	57		 push	 edi
  00114	56		 push	 esi
  00115	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0011a	83 c4 24	 add	 esp, 36			; 00000024H
$LN17@UseMonster:

; 587  :             }
; 588  :         }
; 589  : 
; 590  : 		lpMonsterSkillUnit->RunSkill(iIndex, iTargetIndex);

  0011d	ff 75 0c	 push	 DWORD PTR _iTargetIndex$[ebp]
  00120	8b cb		 mov	 ecx, ebx
  00122	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00125	e8 00 00 00 00	 call	 ?RunSkill@TMonsterSkillUnit@@QAEXHH@Z ; TMonsterSkillUnit::RunSkill
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	5b		 pop	 ebx

; 671  : 				break;
; 672  : 		}
; 673  : 	}
; 674  : }

  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c3		 ret	 0
$LN12@UseMonster:

; 591  : 	}
; 592  : 	else
; 593  : 	{
; 594  : 		int iCount = 0;
; 595  : 		int iRangeTargetIndex = -1;
; 596  : 		int iAngle = gObjUseSkill.GetAngle(lpObj->X, lpObj->Y, lpTargetObj->X, lpTargetObj->Y);

  00131	0f b6 87 21 01
	00 00		 movzx	 eax, BYTE PTR [edi+289]
  00138	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0013d	50		 push	 eax
  0013e	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  00145	50		 push	 eax
  00146	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0014d	50		 push	 eax
  0014e	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 ?GetAngle@CObjUseSkill@@QAEHHHHH@Z ; CObjUseSkill::GetAngle
  0015b	8d 96 4a 0c 00
	00		 lea	 edx, DWORD PTR [esi+3146]
  00161	89 45 f4	 mov	 DWORD PTR _iAngle$1$[ebp], eax
  00164	89 55 f8	 mov	 DWORD PTR tv580[ebp], edx
  00167	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  0016c	c7 45 fc 4b 00
	00 00		 mov	 DWORD PTR tv592[ebp], 75 ; 0000004bH
$LL2@UseMonster:

; 597  : 
; 598  : 		while ( true )
; 599  : 		{
; 600  : 			if ( lpObj->VpPlayer2[iCount].state )

  00173	80 7a fe 00	 cmp	 BYTE PTR [edx-2], 0
  00177	0f 84 17 01 00
	00		 je	 $LN33@UseMonster

; 601  : 			{
; 602  : 				iRangeTargetIndex = lpObj->VpPlayer2[iCount].number;

  0017d	0f bf 0a	 movsx	 ecx, WORD PTR [edx]
  00180	89 4d f0	 mov	 DWORD PTR _iRangeTargetIndex$1$[ebp], ecx

; 603  : 
; 604  : 				if ( OBJMAX_RANGE(iRangeTargetIndex))

  00183	85 c9		 test	 ecx, ecx
  00185	0f 88 06 01 00
	00		 js	 $LN60@UseMonster
  0018b	33 c0		 xor	 eax, eax
  0018d	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00193	0f 9e c0	 setle	 al
  00196	85 c0		 test	 eax, eax
  00198	0f 84 f3 00 00
	00		 je	 $LN60@UseMonster

; 605  : 				{
; 606  : 					if ( gObj[iRangeTargetIndex].Type == OBJ_USER )

  0019e	69 c9 40 27 00
	00		 imul	 ecx, ecx, 10048
  001a4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001aa	80 79 50 01	 cmp	 BYTE PTR [ecx+80], 1
  001ae	0f 85 dd 00 00
	00		 jne	 $LN60@UseMonster

; 607  : 					{
; 608  : 						BOOL bTargetOK = FALSE;
; 609  : 
; 610  : 						if ( lpMonsterSkillUnit->m_iUnitScopeType == 0 )

  001b4	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  001b7	85 c0		 test	 eax, eax
  001b9	75 15		 jne	 SHORT $LN24@UseMonster

; 611  : 						{
; 612  : 							if ( gObjCalDistance(lpObj, &gObj[iRangeTargetIndex]) < lpMonsterSkillUnit->m_iUnitScopeValue )

  001bb	51		 push	 ecx
  001bc	56		 push	 esi
  001bd	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  001c2	83 c4 08	 add	 esp, 8
  001c5	3b 43 24	 cmp	 eax, DWORD PTR [ebx+36]
  001c8	0f 8d c0 00 00
	00		 jge	 $LN56@UseMonster

; 613  : 							{
; 614  : 								bTargetOK = TRUE;
; 615  : 							}
; 616  : 						}

  001ce	eb 45		 jmp	 SHORT $LN55@UseMonster
$LN24@UseMonster:

; 617  : 						else  if ( lpMonsterSkillUnit->m_iUnitScopeType == 1 )

  001d0	83 f8 01	 cmp	 eax, 1
  001d3	75 36		 jne	 SHORT $LN27@UseMonster

; 618  : 						{
; 619  : 							if ( SkillElectricSparkHitBox.HitCheck(iAngle, lpObj->X, lpObj->Y,

  001d5	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  001dc	50		 push	 eax
  001dd	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  001e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?SkillElectricSparkHitBox@@3VCSkillHitBox@@A ; SkillElectricSparkHitBox
  001e9	50		 push	 eax
  001ea	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  001f1	50		 push	 eax
  001f2	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  001f9	50		 push	 eax
  001fa	ff 75 f4	 push	 DWORD PTR _iAngle$1$[ebp]
  001fd	e8 00 00 00 00	 call	 ?HitCheck@CSkillHitBox@@QAEHHHHHH@Z ; CSkillHitBox::HitCheck
  00202	85 c0		 test	 eax, eax
  00204	75 0f		 jne	 SHORT $LN55@UseMonster
  00206	e9 83 00 00 00	 jmp	 $LN56@UseMonster
$LN27@UseMonster:

; 620  : 								gObj[iRangeTargetIndex].X, gObj[iRangeTargetIndex].Y) )
; 621  : 							{
; 622  : 								bTargetOK = TRUE;
; 623  : 							}
; 624  : 						}
; 625  : 						else if ( lpMonsterSkillUnit->m_iUnitScopeType == 2 )

  0020b	83 f8 02	 cmp	 eax, 2
  0020e	74 05		 je	 SHORT $LN55@UseMonster

; 626  : 						{
; 627  : 							bTargetOK = TRUE;
; 628  : 						}
; 629  : 						else if ( lpMonsterSkillUnit->m_iUnitScopeType == 3 )

  00210	83 f8 03	 cmp	 eax, 3
  00213	75 7c		 jne	 SHORT $LN60@UseMonster
$LN55@UseMonster:

; 630  : 						{
; 631  : 							bTargetOK = TRUE;
; 632  : 						}
; 633  : 
; 634  : 						if ( bTargetOK )
; 635  : 						{
; 636  : 							if ( lpObj->MapNumber == MAP_INDEX_RAKLION )

  00215	80 be 23 01 00
	00 39		 cmp	 BYTE PTR [esi+291], 57	; 00000039H
  0021c	75 18		 jne	 SHORT $LN34@UseMonster

; 637  : 							{
; 638  : 								gObjAttack(lpObj, lpTargetObj, NULL, FALSE, 0, 0, FALSE,0,0);

  0021e	6a 00		 push	 0
  00220	6a 00		 push	 0
  00222	6a 00		 push	 0
  00224	6a 00		 push	 0
  00226	6a 00		 push	 0
  00228	6a 00		 push	 0
  0022a	6a 00		 push	 0
  0022c	57		 push	 edi
  0022d	56		 push	 esi
  0022e	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00233	83 c4 24	 add	 esp, 36			; 00000024H
$LN34@UseMonster:

; 639  : 							}
; 640  : 							if ( lpObj->MapNumber == MAP_INDEX_RAKLIONBOSS )

  00236	80 be 23 01 00
	00 3a		 cmp	 BYTE PTR [esi+291], 58	; 0000003aH
  0023d	75 42		 jne	 SHORT $LN37@UseMonster

; 641  : 							{
; 642  : 								if ( lpObj->Class == 459 )

  0023f	b8 cb 01 00 00	 mov	 eax, 459		; 000001cbH
  00244	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  0024b	75 1c		 jne	 SHORT $LN36@UseMonster

; 643  : 								{
; 644  : 									if ( lpMonsterSkillUnit->m_iUnitNumber == 40 )

  0024d	83 7b 18 28	 cmp	 DWORD PTR [ebx+24], 40	; 00000028H
  00251	74 16		 je	 SHORT $LN36@UseMonster

; 645  : 									{
; 646  : 										gObjAttack(lpObj, lpTargetObj, NULL, FALSE, 0, 0, FALSE,0,0);
; 647  : 									}
; 648  : 									else
; 649  : 									{
; 650  : 										if ( lpMagic )

  00253	8b 45 18	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00256	85 c0		 test	 eax, eax
  00258	74 27		 je	 SHORT $LN37@UseMonster

; 651  : 										{
; 652  : 											gObjAttack(lpObj, lpTargetObj,lpMagic, 0, 0, 0, 0,0,0);

  0025a	6a 00		 push	 0
  0025c	6a 00		 push	 0
  0025e	6a 00		 push	 0
  00260	6a 00		 push	 0
  00262	6a 00		 push	 0
  00264	6a 00		 push	 0
  00266	50		 push	 eax

; 653  : 										}
; 654  : 									}
; 655  : 								}
; 656  : 								else

  00267	eb 0e		 jmp	 SHORT $LN65@UseMonster
$LN36@UseMonster:

; 657  : 								{
; 658  : 									gObjAttack(lpObj, lpTargetObj, 0, 0, 0, 0, 0,0,0);

  00269	6a 00		 push	 0
  0026b	6a 00		 push	 0
  0026d	6a 00		 push	 0
  0026f	6a 00		 push	 0
  00271	6a 00		 push	 0
  00273	6a 00		 push	 0
  00275	6a 00		 push	 0
$LN65@UseMonster:
  00277	57		 push	 edi
  00278	56		 push	 esi
  00279	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0027e	83 c4 24	 add	 esp, 36			; 00000024H
$LN37@UseMonster:

; 659  : 								}
; 660  : 							}
; 661  : 
; 662  : 							lpMonsterSkillUnit->RunSkill(iIndex, iRangeTargetIndex);

  00281	ff 75 f0	 push	 DWORD PTR _iRangeTargetIndex$1$[ebp]
  00284	8b cb		 mov	 ecx, ebx
  00286	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00289	e8 00 00 00 00	 call	 ?RunSkill@TMonsterSkillUnit@@QAEXHH@Z ; TMonsterSkillUnit::RunSkill
$LN56@UseMonster:
  0028e	8b 55 f8	 mov	 edx, DWORD PTR tv580[ebp]
$LN60@UseMonster:
  00291	8b 4d fc	 mov	 ecx, DWORD PTR tv592[ebp]
$LN33@UseMonster:

; 663  : 						}
; 664  : 					}
; 665  : 				}
; 666  : 			}
; 667  : 
; 668  : 			iCount++;

  00294	83 c2 0c	 add	 edx, 12			; 0000000cH

; 669  : 
; 670  : 			if ( iCount > MAX_VIEWPORT_MONSTER-1)

  00297	83 e9 01	 sub	 ecx, 1
  0029a	89 55 f8	 mov	 DWORD PTR tv580[ebp], edx
  0029d	89 4d fc	 mov	 DWORD PTR tv592[ebp], ecx
  002a0	0f 85 cd fe ff
	ff		 jne	 $LL2@UseMonster
  002a6	5f		 pop	 edi
  002a7	5e		 pop	 esi
  002a8	5b		 pop	 ebx

; 671  : 				break;
; 672  : 		}
; 673  : 	}
; 674  : }

  002a9	8b e5		 mov	 esp, ebp
  002ab	5d		 pop	 ebp
  002ac	c3		 ret	 0
$LN7@UseMonster:

; 524  : 	{
; 525  : 		LogAddC(2,"[TMonsterSkillManager][UserMonsterSkill] error: iTargetIndex(%d)",iTargetIndex);

  002ad	51		 push	 ecx
  002ae	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@PGJFMLKA@?$FLTMonsterSkillManager?$FN?$FLUserMonst@
  002b3	6a 02		 push	 2
  002b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 671  : 				break;
; 672  : 		}
; 673  : 	}
; 674  : }

  002be	8b e5		 mov	 esp, ebp
  002c0	5d		 pop	 ebp
  002c1	c3		 ret	 0
$LN5@UseMonster:

; 518  : 	{
; 519  : 		LogAddC(2,"[TMonsterSkillManager][UserMonsterSkill] error: iIndex(%d)",iIndex);

  002c2	52		 push	 edx
  002c3	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ENELDMAN@?$FLTMonsterSkillManager?$FN?$FLUserMonst@
  002c8	6a 02		 push	 2
  002ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 671  : 				break;
; 672  : 		}
; 673  : 	}
; 674  : }

  002d3	8b e5		 mov	 esp, ebp
  002d5	5d		 pop	 ebp
  002d6	c3		 ret	 0
?UseMonsterSkill@TMonsterSkillManager@@SAXHHHHPAVCMagicInf@@@Z ENDP ; TMonsterSkillManager::UseMonsterSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?CheckMonsterSkill@TMonsterSkillManager@@SAHH@Z
_TEXT	SEGMENT
_iMonsterClass$ = 8					; size = 4
?CheckMonsterSkill@TMonsterSkillManager@@SAHH@Z PROC	; TMonsterSkillManager::CheckMonsterSkill, COMDAT

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 176  : 	if ( iMonsterClass < 0 || iMonsterClass > MAX_MONSTER_SKILL_INFO_ARRAY-1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMonsterClass$[ebp]
  00006	3d ff 03 00 00	 cmp	 eax, 1023		; 000003ffH
  0000b	77 1a		 ja	 SHORT $LN3@CheckMonst

; 178  : 
; 179  : 	TMonsterSkillInfo * lpMonsterSkillInfo = &TMonsterSkillManager::s_MonsterSkillInfoArray[iMonsterClass];

  0000d	6b c0 58	 imul	 eax, eax, 88
  00010	05 00 00 00 00	 add	 eax, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A ; TMonsterSkillManager::s_MonsterSkillInfoArray
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h

; 40   : 		if ( this->m_iMonsterIndex == -1 || this->m_iSkillUnitCount == 0 )

  00015	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00018	74 0d		 je	 SHORT $LN3@CheckMonst
  0001a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001e	74 07		 je	 SHORT $LN3@CheckMonst
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 184  : 	return TRUE;

  00020	b8 01 00 00 00	 mov	 eax, 1

; 185  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN3@CheckMonst:

; 177  : 		return FALSE;

  00027	33 c0		 xor	 eax, eax

; 185  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?CheckMonsterSkill@TMonsterSkillManager@@SAHH@Z ENDP	; TMonsterSkillManager::CheckMonsterSkill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?DelAllSkillManagerInfo@TMonsterSkillManager@@SAXXZ
_TEXT	SEGMENT
?DelAllSkillManagerInfo@TMonsterSkillManager@@SAXXZ PROC ; TMonsterSkillManager::DelAllSkillManagerInfo, COMDAT

; 163  : 	for ( int i=0;i<MAX_MONSTER_SKILL_INFO_ARRAY;i++)

  00000	ba 30 00 00 00	 mov	 edx, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A+48
  00005	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@DelAllSkil:
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h

; 28   : 		this->m_iMonsterIndex = -1;

  00010	c7 42 d0 ff ff
	ff ff		 mov	 DWORD PTR [edx-48], -1
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 165  : 		TMonsterSkillManager::s_MonsterSkillInfoArray[i].Reset();

  00017	8b c2		 mov	 eax, edx
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h

; 29   : 		this->m_iSkillUnitCount = 0;

  00019	c7 42 d4 00 00
	00 00		 mov	 DWORD PTR [edx-44], 0
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 165  : 		TMonsterSkillManager::s_MonsterSkillInfoArray[i].Reset();

  00020	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
$LL12@DelAllSkil:
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h

; 33   : 			this->m_iSkillUnitTypeArray[i] = -1;

  00025	c7 40 d8 ff ff
	ff ff		 mov	 DWORD PTR [eax-40], -1
  0002c	8d 40 04	 lea	 eax, DWORD PTR [eax+4]

; 34   : 			this->m_lpSkillUnitArray[i] = NULL;

  0002f	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [eax-4], 0
  00036	83 e9 01	 sub	 ecx, 1
  00039	75 ea		 jne	 SHORT $LL12@DelAllSkil
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 163  : 	for ( int i=0;i<MAX_MONSTER_SKILL_INFO_ARRAY;i++)

  0003b	83 c2 58	 add	 edx, 88			; 00000058H
  0003e	81 fa 30 60 01
	00		 cmp	 edx, OFFSET ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A+90160
  00044	7c ca		 jl	 SHORT $LL4@DelAllSkil

; 168  : 	for ( int j=0;j<MAX_MONSTER_SKILL_DELAY_INFO_ARRAY;j++)

  00046	b8 08 00 00 00	 mov	 eax, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+8
  0004b	0f 1f 44 00 00	 npad	 5
$LL7@DelAllSkil:
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h

; 24   : 		this->iIndex = -1;

  00050	c7 40 fc ff ff
	ff ff		 mov	 DWORD PTR [eax-4], -1

; 25   : 		this->iTargetIndex = -1;

  00057	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 26   : 		this->dwDelayTime = 0;

  0005d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 27   : 		this->bIsUsed = FALSE;

  00064	c7 40 f8 00 00
	00 00		 mov	 DWORD PTR [eax-8], 0

; 28   : 		this->lpMonsterSkillUnit = NULL;

  0006b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 168  : 	for ( int j=0;j<MAX_MONSTER_SKILL_DELAY_INFO_ARRAY;j++)

  00072	83 c0 14	 add	 eax, 20			; 00000014H
  00075	3d 68 ea 00 00	 cmp	 eax, OFFSET ?s_MonsterSkillDelayInfoArray@TMonsterSkillManager@@2PAU_ST_MONSTER_SKILL_DELAYTIME_INFO@@A+60008
  0007a	7c d4		 jl	 SHORT $LL7@DelAllSkil

; 169  : 	{
; 170  : 		TMonsterSkillManager::s_MonsterSkillDelayInfoArray[j].RESET();
; 171  : 	}
; 172  : }

  0007c	c3		 ret	 0
?DelAllSkillManagerInfo@TMonsterSkillManager@@SAXXZ ENDP ; TMonsterSkillManager::DelAllSkillManagerInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?LoadData@TMonsterSkillManager@@SAHPAD@Z
_TEXT	SEGMENT
_lpszFileName$GSCopy$ = -344				; size = 4
_iType$1$ = -340					; size = 4
_bVerified$1$ = -336					; size = 4
_lpszFileName$GSCopy$1$ = -332				; size = 4
_MonsterSkillInfo$2 = -328				; size = 88
_szMsg$3 = -240						; size = 200
_szMonsterName$4 = -40					; size = 20
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?LoadData@TMonsterSkillManager@@SAHPAD@Z PROC		; TMonsterSkillManager::LoadData, COMDAT

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadData@TMonsterSkillManager@@SAHPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 75 08	 mov	 esi, DWORD PTR _lpszFileName$[ebp]
  00034	89 b5 b4 fe ff
	ff		 mov	 DWORD PTR _lpszFileName$GSCopy$1$[ebp], esi
  0003a	89 b5 a8 fe ff
	ff		 mov	 DWORD PTR _lpszFileName$GSCopy$[ebp], esi

; 38   : 	TMonsterSkillManager::s_bDataLoad = FALSE;

  00040	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterSkillManager@@2HA, 0 ; TMonsterSkillManager::s_bDataLoad

; 39   : 
; 40   : 	if ( !lpszFileName || !strcmp(lpszFileName, ""))

  0004a	85 f6		 test	 esi, esi
  0004c	0f 84 e4 02 00
	00		 je	 $LN10@LoadData
  00052	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00057	8b c6		 mov	 eax, esi
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL39@LoadData:
  00060	8a 10		 mov	 dl, BYTE PTR [eax]
  00062	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00064	75 1a		 jne	 SHORT $LN40@LoadData
  00066	84 d2		 test	 dl, dl
  00068	74 12		 je	 SHORT $LN41@LoadData
  0006a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0006d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00070	75 0e		 jne	 SHORT $LN40@LoadData
  00072	83 c0 02	 add	 eax, 2
  00075	83 c1 02	 add	 ecx, 2
  00078	84 d2		 test	 dl, dl
  0007a	75 e4		 jne	 SHORT $LL39@LoadData
$LN41@LoadData:
  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN42@LoadData
$LN40@LoadData:
  00080	1b c0		 sbb	 eax, eax
  00082	83 c8 01	 or	 eax, 1
$LN42@LoadData:
  00085	85 c0		 test	 eax, eax
  00087	0f 84 a9 02 00
	00		 je	 $LN10@LoadData

; 44   : 	}
; 45   : 
; 46   : 	try
; 47   : 	{
; 48   : 		SMDToken Token;
; 49   : 		SMDFile = fopen(lpszFileName, "r");

  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00092	56		 push	 esi
  00093	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0009a	e8 00 00 00 00	 call	 _fopen
  0009f	83 c4 08	 add	 esp, 8
  000a2	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax

; 50   : 
; 51   : 		if ( SMDFile == NULL )

  000a7	85 c0		 test	 eax, eax
  000a9	75 13		 jne	 SHORT $LN12@LoadData

; 52   : 		{
; 53   : 			MsgBox("[Monster Skill Manager] - Can't Open %s ", lpszFileName);

  000ab	56		 push	 esi
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@MLGACFDE@?$FLMonster?5Skill?5Manager?$FN?5?9?5Can?8t?5@
  000b1	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000b6	83 c4 08	 add	 esp, 8

; 54   : 			return FALSE;

  000b9	e9 85 02 00 00	 jmp	 $LN48@LoadData
$LN12@LoadData:

; 55   : 		}
; 56   : 
; 57   : 		TMonsterSkillManager::DelAllSkillManagerInfo();

  000be	e8 00 00 00 00	 call	 ?DelAllSkillManagerInfo@TMonsterSkillManager@@SAXXZ ; TMonsterSkillManager::DelAllSkillManagerInfo
$LL2@LoadData:

; 58   : 		int iType = -1;
; 59   : 
; 60   : 		while ( true )
; 61   : 		{
; 62   : 			Token = GetToken();

  000c3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 63   : 
; 64   : 			if ( Token == END )

  000c8	83 f8 02	 cmp	 eax, 2
  000cb	75 2b		 jne	 SHORT $LN13@LoadData

; 143  : 		}
; 144  : 
; 145  : 		fclose(SMDFile);

  000cd	ff 35 00 00 00
	00		 push	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000d3	e8 00 00 00 00	 call	 _fclose

; 146  : 
; 147  : 		LogAddC(2, "[Monster Skill Manager] - %s file is Loaded", lpszFileName);

  000d8	56		 push	 esi
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BOBBJDPC@?$FLMonster?5Skill?5Manager?$FN?5?9?5?$CFs?5fil@
  000de	6a 02		 push	 2
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000e6	83 c4 10	 add	 esp, 16			; 00000010H

; 148  : 
; 149  : 		TMonsterSkillManager::s_bDataLoad = TRUE;

  000e9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?s_bDataLoad@TMonsterSkillManager@@2HA, 1 ; TMonsterSkillManager::s_bDataLoad
  000f3	e9 4b 02 00 00	 jmp	 $LN48@LoadData
$LN13@LoadData:

; 65   : 				break;
; 66   : 
; 67   : 			iType = (int)TokenNumber;

  000f8	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00100	89 85 ac fe ff
	ff		 mov	 DWORD PTR _iType$1$[ebp], eax
$LL4@LoadData:

; 68   : 
; 69   : 			while ( true )
; 70   : 			{
; 71   : 				if ( iType == 0 )

  00106	85 c0		 test	 eax, eax
  00108	75 fc		 jne	 SHORT $LL4@LoadData

; 72   : 				{
; 73   : 					BOOL bVerified = TRUE;

  0010a	0f 57 c0	 xorps	 xmm0, xmm0
  0010d	c7 85 b0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _bVerified$1$[ebp], 1
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h

; 23   : 		this->Reset();

  00117	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _MonsterSkillInfo$2[ebp]
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 74   : 					char szMonsterName[20]={0};

  0011d	88 45 d8	 mov	 BYTE PTR _szMonsterName$4[ebp], al
  00120	0f 11 45 d9	 movups	 XMMWORD PTR _szMonsterName$4[ebp+1], xmm0
  00124	66 89 45 e9	 mov	 WORD PTR _szMonsterName$4[ebp+17], ax
  00128	88 45 eb	 mov	 BYTE PTR _szMonsterName$4[ebp+19], al
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h

; 23   : 		this->Reset();

  0012b	e8 00 00 00 00	 call	 ?Reset@TMonsterSkillInfo@@QAEXXZ ; TMonsterSkillInfo::Reset
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp

; 77   : 					Token = GetToken();

  00130	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 78   : 
; 79   : 					if ( !strcmp("end", TokenString))

  00135	b9 00 00 00 00	 mov	 ecx, OFFSET ?TokenString@@3PADA
  0013a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0013f	90		 npad	 1
$LL43@LoadData:
  00140	8a 10		 mov	 dl, BYTE PTR [eax]
  00142	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00144	75 1a		 jne	 SHORT $LN44@LoadData
  00146	84 d2		 test	 dl, dl
  00148	74 12		 je	 SHORT $LN45@LoadData
  0014a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0014d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00150	75 0e		 jne	 SHORT $LN44@LoadData
  00152	83 c0 02	 add	 eax, 2
  00155	83 c1 02	 add	 ecx, 2
  00158	84 d2		 test	 dl, dl
  0015a	75 e4		 jne	 SHORT $LL43@LoadData
$LN45@LoadData:
  0015c	33 c0		 xor	 eax, eax
  0015e	eb 05		 jmp	 SHORT $LN46@LoadData
$LN44@LoadData:
  00160	1b c0		 sbb	 eax, eax
  00162	83 c8 01	 or	 eax, 1
$LN46@LoadData:
  00165	85 c0		 test	 eax, eax
  00167	0f 84 56 ff ff
	ff		 je	 $LL2@LoadData

; 80   : 						break;
; 81   : 
; 82   : 					MonsterSkillInfo.m_iMonsterIndex = (int)TokenNumber;

  0016d	f3 0f 2c 3d 00
	00 00 00	 cvttss2si edi, DWORD PTR ?TokenNumber@@3MA
  00175	89 bd b8 fe ff
	ff		 mov	 DWORD PTR _MonsterSkillInfo$2[ebp], edi

; 83   : 
; 84   : 					Token = GetToken();

  0017b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 85   : 					memcpy(szMonsterName, TokenString, 20);

  00180	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ?TokenString@@3PADA
  00187	a1 10 00 00 00	 mov	 eax, DWORD PTR ?TokenString@@3PADA+16

; 86   : 
; 87   : 					for ( int i=0;i<MAX_SKILL_UNIT;i++)

  0018c	33 f6		 xor	 esi, esi
  0018e	89 45 e8	 mov	 DWORD PTR _szMonsterName$4[ebp+16], eax
  00191	0f 11 45 d8	 movups	 XMMWORD PTR _szMonsterName$4[ebp], xmm0
$LL8@LoadData:
  00195	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  00198	7d 58		 jge	 SHORT $LN7@LoadData

; 88   : 					{
; 89   : 						int iSkillUnitNumber = -1;
; 90   : 						Token = GetToken();

  0019a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 91   : 						MonsterSkillInfo.m_iSkillUnitTypeArray[i] = (int)TokenNumber;

  0019f	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001a7	89 84 b5 c0 fe
	ff ff		 mov	 DWORD PTR _MonsterSkillInfo$2[ebp+esi*4+8], eax

; 92   : 
; 93   : 						Token = GetToken();

  001ae	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 94   : 						iSkillUnitNumber = (int)TokenNumber;

  001b3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA

; 95   : 
; 96   : 						if ( iSkillUnitNumber == -1 )

  001bb	83 f8 ff	 cmp	 eax, -1
  001be	74 29		 je	 SHORT $LN6@LoadData

; 97   : 							continue;
; 98   : 
; 99   : 						TMonsterSkillUnit * lpSkillUnit = TMonsterSkillUnit::FindSkillUnit(iSkillUnitNumber);

  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ?FindSkillUnit@TMonsterSkillUnit@@SAPAV1@H@Z ; TMonsterSkillUnit::FindSkillUnit
  001c6	83 c4 04	 add	 esp, 4

; 100  : 						
; 101  : 						if ( lpSkillUnit == NULL )

  001c9	85 c0		 test	 eax, eax
  001cb	75 0f		 jne	 SHORT $LN17@LoadData

; 86   : 
; 87   : 					for ( int i=0;i<MAX_SKILL_UNIT;i++)

  001cd	8b bd b8 fe ff
	ff		 mov	 edi, DWORD PTR _MonsterSkillInfo$2[ebp]
  001d3	46		 inc	 esi

; 102  : 						{
; 103  : 							bVerified = FALSE;

  001d4	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _bVerified$1$[ebp], eax
  001da	eb b9		 jmp	 SHORT $LL8@LoadData
$LN17@LoadData:

; 104  : 							continue;
; 105  : 						}
; 106  : 
; 107  : 						MonsterSkillInfo.m_lpSkillUnitArray[i] = lpSkillUnit;

  001dc	89 84 b5 e8 fe
	ff ff		 mov	 DWORD PTR _MonsterSkillInfo$2[ebp+esi*4+48], eax

; 108  : 						MonsterSkillInfo.m_iSkillUnitCount++;

  001e3	ff 85 bc fe ff
	ff		 inc	 DWORD PTR _MonsterSkillInfo$2[ebp+4]
$LN6@LoadData:

; 86   : 
; 87   : 					for ( int i=0;i<MAX_SKILL_UNIT;i++)

  001e9	8b bd b8 fe ff
	ff		 mov	 edi, DWORD PTR _MonsterSkillInfo$2[ebp]
  001ef	46		 inc	 esi
  001f0	eb a3		 jmp	 SHORT $LL8@LoadData
$LN7@LoadData:

; 109  : 					}
; 110  : 
; 111  : 
; 112  : 
; 113  : 					if ( false || MonsterSkillInfo.m_iMonsterIndex >= MAX_MONSTER_SKILL_INFO_ARRAY )

  001f2	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  001f8	7c 20		 jl	 SHORT $LN18@LoadData

; 114  : 					{
; 115  : 						MsgBox("[Monster Manager] - MonsterIndex(%d) Error (%s) File. ", 

  001fa	8b b5 b4 fe ff
	ff		 mov	 esi, DWORD PTR _lpszFileName$GSCopy$1$[ebp]
  00200	56		 push	 esi
  00201	57		 push	 edi
  00202	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@IDDBKHCE@?$FLMonster?5Manager?$FN?5?9?5MonsterIndex@
  00207	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 116  : 							MonsterSkillInfo.m_iMonsterIndex, lpszFileName);
; 117  : 						continue;

  0020c	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _iType$1$[ebp]
  00212	83 c4 0c	 add	 esp, 12			; 0000000cH
  00215	e9 ec fe ff ff	 jmp	 $LL4@LoadData
$LN18@LoadData:

; 118  : 					}
; 119  : 
; 120  : 					if ( bVerified ==FALSE )

  0021a	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _bVerified$1$[ebp]
  00220	85 c0		 test	 eax, eax
  00222	75 1b		 jne	 SHORT $LN20@LoadData

; 121  : 					{
; 122  : 						LogAddC(2, "[Monster Manager] - Invalid SkillInfo : MIndex(%s/%d) (%s) File.",

  00224	ff b5 b4 fe ff
	ff		 push	 DWORD PTR _lpszFileName$GSCopy$1$[ebp]
  0022a	8d 45 d8	 lea	 eax, DWORD PTR _szMonsterName$4[ebp]
  0022d	57		 push	 edi
  0022e	50		 push	 eax
  0022f	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@NICDPOPP@?$FLMonster?5Manager?$FN?5?9?5Invalid?5Skil@
  00234	6a 02		 push	 2
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0023c	83 c4 14	 add	 esp, 20			; 00000014H
$LN20@LoadData:

; 123  : 							szMonsterName, MonsterSkillInfo.m_iMonsterIndex,lpszFileName);
; 124  : 					}
; 125  : 
; 126  : 					memcpy(&TMonsterSkillManager::s_MonsterSkillInfoArray[MonsterSkillInfo.m_iMonsterIndex],

  0023f	0f 10 85 b8 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _MonsterSkillInfo$2[ebp]
  00246	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$3[ebp]
  0024c	6b f7 58	 imul	 esi, edi, 88
  0024f	68 c8 00 00 00	 push	 200			; 000000c8H
  00254	6a 00		 push	 0
  00256	50		 push	 eax
  00257	0f 11 86 00 00
	00 00		 movups	 XMMWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi], xmm0
  0025e	0f 10 85 c8 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _MonsterSkillInfo$2[ebp+16]
  00265	0f 11 86 10 00
	00 00		 movups	 XMMWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+16], xmm0
  0026c	0f 10 85 d8 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _MonsterSkillInfo$2[ebp+32]
  00273	0f 11 86 20 00
	00 00		 movups	 XMMWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+32], xmm0
  0027a	0f 10 85 e8 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _MonsterSkillInfo$2[ebp+48]
  00281	0f 11 86 30 00
	00 00		 movups	 XMMWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+48], xmm0
  00288	0f 10 85 f8 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _MonsterSkillInfo$2[ebp+64]
  0028f	0f 11 86 40 00
	00 00		 movups	 XMMWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+64], xmm0
  00296	f3 0f 7e 85 08
	ff ff ff	 movq	 xmm0, QWORD PTR _MonsterSkillInfo$2[ebp+80]
  0029e	66 0f d6 86 50
	00 00 00	 movq	 QWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+80], xmm0
  002a6	e8 00 00 00 00	 call	 _memset

; 127  : 						&MonsterSkillInfo, sizeof(MonsterSkillInfo));
; 128  : 
; 129  : 					char szMsg[200] = {0};
; 130  : 					TMonsterSkillInfo * pMonSInfo = &TMonsterSkillManager::s_MonsterSkillInfoArray[MonsterSkillInfo.m_iMonsterIndex];
; 131  : 
; 132  : 					wsprintf(szMsg, "Index:%d,Name:%s,Count:%d,Type0:%d,Unit0:%d,Type1:%d,Unit1:%d,Type2:%d,Unit2:%d,Type3:%d,Unit3:%d,Type4:%d,Unit4:%d\n",

  002ab	ff b6 40 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+64]
  002b1	8d 45 d8	 lea	 eax, DWORD PTR _szMonsterName$4[ebp]
  002b4	ff b6 18 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+24]
  002ba	ff b6 3c 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+60]
  002c0	ff b6 14 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+20]
  002c6	ff b6 38 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+56]
  002cc	ff b6 10 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+16]
  002d2	ff b6 34 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+52]
  002d8	ff b6 0c 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+12]
  002de	ff b6 30 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+48]
  002e4	ff b6 08 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+8]
  002ea	ff b6 04 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi+4]
  002f0	50		 push	 eax
  002f1	ff b6 00 00 00
	00		 push	 DWORD PTR ?s_MonsterSkillInfoArray@TMonsterSkillManager@@2PAVTMonsterSkillInfo@@A[esi]
  002f7	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$3[ebp]
  002fd	68 00 00 00 00	 push	 OFFSET ??_C@_0HH@GONDBIOK@?$KB?$NLIndex?3?$CFd?0Name?3?$CFs?0Count?3?$CFd?0Type@
  00302	50		 push	 eax
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 133  : 						pMonSInfo->m_iMonsterIndex, szMonsterName, pMonSInfo->m_iSkillUnitCount,
; 134  : 						pMonSInfo->m_iSkillUnitTypeArray[0], pMonSInfo->m_lpSkillUnitArray[0],
; 135  : 						pMonSInfo->m_iSkillUnitTypeArray[1], pMonSInfo->m_lpSkillUnitArray[1],
; 136  : 						pMonSInfo->m_iSkillUnitTypeArray[2], pMonSInfo->m_lpSkillUnitArray[2],
; 137  : 						pMonSInfo->m_iSkillUnitTypeArray[3], pMonSInfo->m_lpSkillUnitArray[3],
; 138  : 						pMonSInfo->m_iSkillUnitTypeArray[4], pMonSInfo->m_lpSkillUnitArray[4]);
; 139  : 
; 140  : //					OutputDebugString(szMsg);
; 141  : 				}
; 142  : 			}

  00309	8b b5 b4 fe ff
	ff		 mov	 esi, DWORD PTR _lpszFileName$GSCopy$1$[ebp]
  0030f	83 c4 48	 add	 esp, 72			; 00000048H
  00312	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _iType$1$[ebp]
  00318	e9 e9 fd ff ff	 jmp	 $LL4@LoadData
__catch$?LoadData@TMonsterSkillManager@@SAHPAD@Z$0:

; 150  : 	}
; 151  : 	catch(DWORD)
; 152  : 	{
; 153  : 		MsgBox("[Monster Skill Manager] - Loading Exception Error (%s) File. ", lpszFileName);

  0031d	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _lpszFileName$GSCopy$[ebp]
  00323	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@MGDDNBGB@?$FLMonster?5Skill?5Manager?$FN?5?9?5Loadin@
  00328	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0032d	83 c4 08	 add	 esp, 8

; 154  : 	}

  00330	b8 00 00 00 00	 mov	 eax, $LN48@LoadData
  00335	c3		 ret	 0
$LN10@LoadData:

; 41   : 	{
; 42   : 		MsgBox("[Monster Skill Manager] - File load error : File Name Error");

  00336	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@FNGEHCBH@?$FLMonster?5Skill?5Manager?$FN?5?9?5File?5l@
  0033b	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00340	83 c4 04	 add	 esp, 4
$LN48@LoadData:

; 43   : 		return FALSE;

  00343	33 c0		 xor	 eax, eax

; 155  : 
; 156  : 	return FALSE;
; 157  : }

  00345	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00348	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0034f	59		 pop	 ecx
  00350	5f		 pop	 edi
  00351	5e		 pop	 esi
  00352	5b		 pop	 ebx
  00353	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00356	33 cd		 xor	 ecx, ebp
  00358	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035d	8b e5		 mov	 esp, ebp
  0035f	5d		 pop	 ebp
  00360	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?LoadData@TMonsterSkillManager@@SAHPAD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a a4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-348]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadData@TMonsterSkillManager@@SAHPAD@Z
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadData@TMonsterSkillManager@@SAHPAD@Z ENDP		; TMonsterSkillManager::LoadData
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ??1TMonsterSkillManager@@QAE@XZ
_TEXT	SEGMENT
??1TMonsterSkillManager@@QAE@XZ PROC			; TMonsterSkillManager::~TMonsterSkillManager, COMDAT
; _this$ = ecx

; 32   : 	return;
; 33   : }

  00000	c3		 ret	 0
??1TMonsterSkillManager@@QAE@XZ ENDP			; TMonsterSkillManager::~TMonsterSkillManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ??0TMonsterSkillManager@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterSkillManager@@QAE@XZ PROC			; TMonsterSkillManager::TMonsterSkillManager, COMDAT
; _this$ = ecx

; 27   : 	return;
; 28   : }

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0TMonsterSkillManager@@QAE@XZ ENDP			; TMonsterSkillManager::TMonsterSkillManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h
;	COMDAT ??0_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAE@XZ
_TEXT	SEGMENT
??0_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAE@XZ PROC	; _ST_MONSTER_SKILL_DELAYTIME_INFO::_ST_MONSTER_SKILL_DELAYTIME_INFO, COMDAT
; _this$ = ecx

; 24   : 		this->iIndex = -1;

  00000	c7 41 04 ff ff
	ff ff		 mov	 DWORD PTR [ecx+4], -1

; 44   : 	{
; 45   : 		this->RESET();
; 46   : 	}

  00007	8b c1		 mov	 eax, ecx

; 25   : 		this->iTargetIndex = -1;

  00009	c7 41 08 ff ff
	ff ff		 mov	 DWORD PTR [ecx+8], -1

; 26   : 		this->dwDelayTime = 0;

  00010	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 27   : 		this->bIsUsed = FALSE;

  00017	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 28   : 		this->lpMonsterSkillUnit = NULL;

  0001d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 44   : 	{
; 45   : 		this->RESET();
; 46   : 	}

  00024	c3		 ret	 0
??0_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAE@XZ ENDP	; _ST_MONSTER_SKILL_DELAYTIME_INFO::_ST_MONSTER_SKILL_DELAYTIME_INFO
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h
;	COMDAT ?IsValid@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEHXZ
_TEXT	SEGMENT
?IsValid@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEHXZ PROC	; _ST_MONSTER_SKILL_DELAYTIME_INFO::IsValid, COMDAT
; _this$ = ecx

; 34   : 		if ( !OBJMAX_RANGE(this->iIndex) || !OBJMAX_RANGE(this->iTargetIndex) )

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	85 d2		 test	 edx, edx
  00005	78 2e		 js	 SHORT $LN3@IsValid
  00007	33 c0		 xor	 eax, eax
  00009	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  0000f	0f 9e c0	 setle	 al
  00012	85 c0		 test	 eax, eax
  00014	74 1f		 je	 SHORT $LN3@IsValid
  00016	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00019	85 d2		 test	 edx, edx
  0001b	78 18		 js	 SHORT $LN3@IsValid
  0001d	33 c0		 xor	 eax, eax
  0001f	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00025	0f 9e c0	 setle	 al
  00028	85 c0		 test	 eax, eax
  0002a	74 09		 je	 SHORT $LN3@IsValid

; 36   : 
; 37   : 		if ( this->lpMonsterSkillUnit == NULL )

  0002c	33 c0		 xor	 eax, eax
  0002e	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00031	0f 95 c0	 setne	 al

; 38   : 			return FALSE;
; 39   : 
; 40   : 		return TRUE;
; 41   : 	}

  00034	c3		 ret	 0
$LN3@IsValid:

; 35   : 			return FALSE;

  00035	33 c0		 xor	 eax, eax

; 38   : 			return FALSE;
; 39   : 
; 40   : 		return TRUE;
; 41   : 	}

  00037	c3		 ret	 0
?IsValid@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEHXZ ENDP	; _ST_MONSTER_SKILL_DELAYTIME_INFO::IsValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.h
;	COMDAT ?RESET@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEXXZ
_TEXT	SEGMENT
?RESET@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEXXZ PROC	; _ST_MONSTER_SKILL_DELAYTIME_INFO::RESET, COMDAT
; _this$ = ecx

; 24   : 		this->iIndex = -1;

  00000	c7 41 04 ff ff
	ff ff		 mov	 DWORD PTR [ecx+4], -1

; 25   : 		this->iTargetIndex = -1;

  00007	c7 41 08 ff ff
	ff ff		 mov	 DWORD PTR [ecx+8], -1

; 26   : 		this->dwDelayTime = 0;

  0000e	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 27   : 		this->bIsUsed = FALSE;

  00015	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 28   : 		this->lpMonsterSkillUnit = NULL;

  0001b	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 29   : 	}

  00022	c3		 ret	 0
?RESET@_ST_MONSTER_SKILL_DELAYTIME_INFO@@QAEXXZ ENDP	; _ST_MONSTER_SKILL_DELAYTIME_INFO::RESET
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
;	COMDAT ?IsValid@TMonsterSkillInfo@@QAEHXZ
_TEXT	SEGMENT
?IsValid@TMonsterSkillInfo@@QAEHXZ PROC			; TMonsterSkillInfo::IsValid, COMDAT
; _this$ = ecx

; 40   : 		if ( this->m_iMonsterIndex == -1 || this->m_iSkillUnitCount == 0 )

  00000	83 39 ff	 cmp	 DWORD PTR [ecx], -1
  00003	74 0c		 je	 SHORT $LN3@IsValid
  00005	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00009	74 06		 je	 SHORT $LN3@IsValid

; 42   : 
; 43   : 		return TRUE;

  0000b	b8 01 00 00 00	 mov	 eax, 1

; 44   : 	}

  00010	c3		 ret	 0
$LN3@IsValid:

; 41   : 			return FALSE;

  00011	33 c0		 xor	 eax, eax

; 44   : 	}

  00013	c3		 ret	 0
?IsValid@TMonsterSkillInfo@@QAEHXZ ENDP			; TMonsterSkillInfo::IsValid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
;	COMDAT ?Reset@TMonsterSkillInfo@@QAEXXZ
_TEXT	SEGMENT
?Reset@TMonsterSkillInfo@@QAEXXZ PROC			; TMonsterSkillInfo::Reset, COMDAT
; _this$ = ecx

; 28   : 		this->m_iMonsterIndex = -1;

  00000	c7 01 ff ff ff
	ff		 mov	 DWORD PTR [ecx], -1

; 29   : 		this->m_iSkillUnitCount = 0;

  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 30   : 
; 31   : 		for ( int i=0;i<MAX_SKILL_UNIT;i++)
; 32   : 		{
; 33   : 			this->m_iSkillUnitTypeArray[i] = -1;

  0000d	c7 41 08 ff ff
	ff ff		 mov	 DWORD PTR [ecx+8], -1

; 34   : 			this->m_lpSkillUnitArray[i] = NULL;

  00014	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
  0001b	c7 41 0c ff ff
	ff ff		 mov	 DWORD PTR [ecx+12], -1
  00022	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0
  00029	c7 41 10 ff ff
	ff ff		 mov	 DWORD PTR [ecx+16], -1
  00030	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  00037	c7 41 14 ff ff
	ff ff		 mov	 DWORD PTR [ecx+20], -1
  0003e	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00045	c7 41 18 ff ff
	ff ff		 mov	 DWORD PTR [ecx+24], -1
  0004c	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  00053	c7 41 1c ff ff
	ff ff		 mov	 DWORD PTR [ecx+28], -1
  0005a	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0
  00061	c7 41 20 ff ff
	ff ff		 mov	 DWORD PTR [ecx+32], -1
  00068	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0
  0006f	c7 41 24 ff ff
	ff ff		 mov	 DWORD PTR [ecx+36], -1
  00076	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0
  0007d	c7 41 28 ff ff
	ff ff		 mov	 DWORD PTR [ecx+40], -1
  00084	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0
  0008b	c7 41 2c ff ff
	ff ff		 mov	 DWORD PTR [ecx+44], -1
  00092	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0

; 35   : 		}
; 36   : 	}

  00099	c3		 ret	 0
?Reset@TMonsterSkillInfo@@QAEXXZ ENDP			; TMonsterSkillInfo::Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillinfo.h
;	COMDAT ??0TMonsterSkillInfo@@QAE@XZ
_TEXT	SEGMENT
??0TMonsterSkillInfo@@QAE@XZ PROC			; TMonsterSkillInfo::TMonsterSkillInfo, COMDAT
; _this$ = ecx

; 21   : 	TMonsterSkillInfo()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 22   : 	{
; 23   : 		this->Reset();

  00003	e8 00 00 00 00	 call	 ?Reset@TMonsterSkillInfo@@QAEXXZ ; TMonsterSkillInfo::Reset

; 24   : 	}

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi
  0000b	c3		 ret	 0
??0TMonsterSkillInfo@@QAE@XZ ENDP			; TMonsterSkillInfo::TMonsterSkillInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tmonsterskillmanager.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
