; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\DSProtocol.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?dwCrywolfSyncLogTickCount@@3KA			; dwCrywolfSyncLogTickCount
_BSS	SEGMENT
?dwCrywolfSyncLogTickCount@@3KA DD 01H DUP (?)		; dwCrywolfSyncLogTickCount
_BSS	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?DataServerProtocolCore@@YAXEPAEH@Z		; DataServerProtocolCore
PUBLIC	?TestDSSend@@YAXXZ				; TestDSSend
PUBLIC	?DataServerLogin@@YAXH@Z			; DataServerLogin
PUBLIC	?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z	; DataServerLoginResult
PUBLIC	?JGPGetCharList@@YAXPAE@Z			; JGPGetCharList
PUBLIC	?DataServerGetCharListRequest@@YAXF@Z		; DataServerGetCharListRequest
PUBLIC	?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z ; JGCharacterCreateRequest
PUBLIC	?JGCharacterCreateFailSend@@YAXHPAD@Z		; JGCharacterCreateFailSend
PUBLIC	?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z ; JGCharDelRequest
PUBLIC	?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z ; JGGetCharacterInfo
PUBLIC	?GCItemListSend@@YAXH@Z				; GCItemListSend
PUBLIC	?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z	; GJSetCharacterInfo
PUBLIC	?GDGetWarehouseList@@YAXHPAD@Z			; GDGetWarehouseList
PUBLIC	?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z ; DGGetWarehouseList
PUBLIC	?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z ; GDGetWarehouseNoItem
PUBLIC	?GDSetWarehouseList@@YAXH@Z			; GDSetWarehouseList
PUBLIC	?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z		; GDUserItemSave
PUBLIC	?GDSetWarehouseMoney@@YAXH@Z			; GDSetWarehouseMoney
PUBLIC	?GDGameServerInfoSave@@YAXXZ			; GDGameServerInfoSave
PUBLIC	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z	; ItemSerialCreateSend
PUBLIC	?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z	; PetItemSerialCreateSend
PUBLIC	?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z ; ItemSerialCreateRecv
PUBLIC	?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z		; ItemMovePathSave
PUBLIC	?DGOptionDataSend@@YAXHPADPAEEEEEEEKD@Z		; DGOptionDataSend
PUBLIC	?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z ; DGOptionDataRecv
PUBLIC	?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z ; DGMoveOtherServer
PUBLIC	?gObjRequestPetItemInfo@@YAXHH@Z		; gObjRequestPetItemInfo
PUBLIC	?DGRecvPetItemInfo@@YAXPAE@Z			; DGRecvPetItemInfo
PUBLIC	?gObjSavePetItemInfo@@YAXHH@Z			; gObjSavePetItemInfo
PUBLIC	?GS_GDReqCastleTotalInfo@@YAXHH@Z		; GS_GDReqCastleTotalInfo
PUBLIC	?GS_GDReqOwnerGuildMaster@@YAXHH@Z		; GS_GDReqOwnerGuildMaster
PUBLIC	?GS_GDReqCastleNpcBuy@@YAXHHHHHHHHEEEH@Z	; GS_GDReqCastleNpcBuy
PUBLIC	?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z		; GS_GDReqCastleNpcRepair
PUBLIC	?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z		; GS_GDReqCastleNpcUpgrade
PUBLIC	?GS_GDReqTaxInfo@@YAXHH@Z			; GS_GDReqTaxInfo
PUBLIC	?GS_GDReqTaxRateChange@@YAXHHHH@Z		; GS_GDReqTaxRateChange
PUBLIC	?GS_GDReqCastleMoneyChange@@YAXHHH@Z		; GS_GDReqCastleMoneyChange
PUBLIC	?GS_GDReqSiegeDateChange@@YAXHHGEEGEE@Z		; GS_GDReqSiegeDateChange
PUBLIC	?GS_GDReqResetRegSiegeInfo@@YAXH@Z		; GS_GDReqResetRegSiegeInfo
PUBLIC	?GS_GDReqGuildMarkRegInfo@@YAXHH@Z		; GS_GDReqGuildMarkRegInfo
PUBLIC	?GS_GDReqSiegeEndedChange@@YAXHH@Z		; GS_GDReqSiegeEndedChange
PUBLIC	?GS_GDReqCastleOwnerChange@@YAXHHPAD@Z		; GS_GDReqCastleOwnerChange
PUBLIC	?GS_GDReqRegAttackGuild@@YAXHH@Z		; GS_GDReqRegAttackGuild
PUBLIC	?GS_GDReqRestartCastleState@@YAXH@Z		; GS_GDReqRestartCastleState
PUBLIC	?GS_GDReqMapSvrMsgMultiCast@@YAXHPAD@Z		; GS_GDReqMapSvrMsgMultiCast
PUBLIC	?GS_GDReqRegGuildMark@@YAXHHH@Z			; GS_GDReqRegGuildMark
PUBLIC	?GS_GDReqGuildMarkReset@@YAXHHPAD@Z		; GS_GDReqGuildMarkReset
PUBLIC	?GS_GDReqGuildSetGiveUp@@YAXHHH@Z		; GS_GDReqGuildSetGiveUp
PUBLIC	?GS_GDReqNpcRemove@@YAXHHH@Z			; GS_GDReqNpcRemove
PUBLIC	?GS_GDReqCastleStateSync@@YAXHHHHHPAD@Z		; GS_GDReqCastleStateSync
PUBLIC	?GS_GDReqCastleTributeMoney@@YAXHH@Z		; GS_GDReqCastleTributeMoney
PUBLIC	?GS_GDReqResetCastleTaxInfo@@YAXH@Z		; GS_GDReqResetCastleTaxInfo
PUBLIC	?GS_GDReqResetSiegeGuildInfo@@YAXH@Z		; GS_GDReqResetSiegeGuildInfo
PUBLIC	?GS_GDReqCastleInitData@@YAXHH@Z		; GS_GDReqCastleInitData
PUBLIC	?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z		; GS_GDReqAllGuildMarkRegInfo
PUBLIC	?GS_GDReqCalcRegGuildList@@YAXH@Z		; GS_GDReqCalcRegGuildList
PUBLIC	?GS_GDReqCsLoadTotalGuildInfo@@YAXH@Z		; GS_GDReqCsLoadTotalGuildInfo
PUBLIC	?GS_DGAnsCastleTotalInfo@@YAXPAE@Z		; GS_DGAnsCastleTotalInfo
PUBLIC	?GS_DGAnsOwnerGuildMaster@@YAXPAE@Z		; GS_DGAnsOwnerGuildMaster
PUBLIC	?GS_DGAnsCastleNpcBuy@@YAXPAE@Z			; GS_DGAnsCastleNpcBuy
PUBLIC	?GS_DGAnsCastleNpcRepair@@YAXPAE@Z		; GS_DGAnsCastleNpcRepair
PUBLIC	?GS_DGAnsCastleNpcUpgrade@@YAXPAE@Z		; GS_DGAnsCastleNpcUpgrade
PUBLIC	?GS_DGAnsTaxInfo@@YAXPAE@Z			; GS_DGAnsTaxInfo
PUBLIC	?GS_DGAnsTaxRateChange@@YAXPAE@Z		; GS_DGAnsTaxRateChange
PUBLIC	?GS_DGAnsCastleMoneyChange@@YAXPAE@Z		; GS_DGAnsCastleMoneyChange
PUBLIC	?GS_DGAnsSiegeDateChange@@YAXPAE@Z		; GS_DGAnsSiegeDateChange
PUBLIC	?GS_DGAnsGuildMarkRegInfo@@YAXPAE@Z		; GS_DGAnsGuildMarkRegInfo
PUBLIC	?GS_DGAnsSiegeEndedChange@@YAXPAE@Z		; GS_DGAnsSiegeEndedChange
PUBLIC	?GS_DGAnsCastleOwnerChange@@YAXPAE@Z		; GS_DGAnsCastleOwnerChange
PUBLIC	?GS_DGAnsRegAttackGuild@@YAXPAE@Z		; GS_DGAnsRegAttackGuild
PUBLIC	?GS_DGAnsRestartCastleState@@YAXPAE@Z		; GS_DGAnsRestartCastleState
PUBLIC	?GS_DGAnsMapSvrMsgMultiCast@@YAXPAE@Z		; GS_DGAnsMapSvrMsgMultiCast
PUBLIC	?GS_DGAnsRegGuildMark@@YAXPAE@Z			; GS_DGAnsRegGuildMark
PUBLIC	?GS_DGAnsGuildMarkReset@@YAXPAE@Z		; GS_DGAnsGuildMarkReset
PUBLIC	?GS_DGAnsGuildSetGiveUp@@YAXPAE@Z		; GS_DGAnsGuildSetGiveUp
PUBLIC	?GS_DGAnsNpcRemove@@YAXPAE@Z			; GS_DGAnsNpcRemove
PUBLIC	?GS_DGAnsCastleStateSync@@YAXPAE@Z		; GS_DGAnsCastleStateSync
PUBLIC	?GS_DGAnsCastleTributeMoney@@YAXPAE@Z		; GS_DGAnsCastleTributeMoney
PUBLIC	?GS_DGAnsResetCastleTaxInfo@@YAXPAE@Z		; GS_DGAnsResetCastleTaxInfo
PUBLIC	?GS_DGAnsResetSiegeGuildInfo@@YAXPAE@Z		; GS_DGAnsResetSiegeGuildInfo
PUBLIC	?GS_DGAnsResetRegSiegeInfo@@YAXPAE@Z		; GS_DGAnsResetRegSiegeInfo
PUBLIC	?GS_DGAnsCastleInitData@@YAXPAE@Z		; GS_DGAnsCastleInitData
PUBLIC	?GS_DGAnsCastleNpcInfo@@YAXPAE@Z		; GS_DGAnsCastleNpcInfo
PUBLIC	?GS_DGAnsAllGuildMarkRegInfo@@YAXPAE@Z		; GS_DGAnsAllGuildMarkRegInfo
PUBLIC	?GS_DGAnsFirstCreateNPC@@YAXPAE@Z		; GS_DGAnsFirstCreateNPC
PUBLIC	?GS_DGAnsCalcREgGuildList@@YAXPAE@Z		; GS_DGAnsCalcREgGuildList
PUBLIC	?GS_DGAnsCsGulidUnionInfo@@YAXPAE@Z		; GS_DGAnsCsGulidUnionInfo
PUBLIC	?GS_DGAnsCsSaveTotalGuildInfo@@YAXPAE@Z		; GS_DGAnsCsSaveTotalGuildInfo
PUBLIC	?GS_DGAnsCsLoadTotalGuildInfo@@YAXPAE@Z		; GS_DGAnsCsLoadTotalGuildInfo
PUBLIC	?GS_DGAnsCastleNpcUpdate@@YAXPAE@Z		; GS_DGAnsCastleNpcUpdate
PUBLIC	?GDReqCrywolfSync@@YAXHHH@Z			; GDReqCrywolfSync
PUBLIC	?DGAnsCrywolfSync@@YAXPAE@Z			; DGAnsCrywolfSync
PUBLIC	?GDReqCrywolfInfoLoad@@YAXH@Z			; GDReqCrywolfInfoLoad
PUBLIC	?DGAnsCrywolfInfoLoad@@YAXPAE@Z			; DGAnsCrywolfInfoLoad
PUBLIC	?GDReqCrywolfInfoSave@@YAXHHH@Z			; GDReqCrywolfInfoSave
PUBLIC	?DGAnsCrywolfInfoSave@@YAXPAE@Z			; DGAnsCrywolfInfoSave
PUBLIC	?JGPSummonerInfo@@YAXPAUPMSG_ANS_SUMMONER_CREATE@@@Z ; JGPSummonerInfo
PUBLIC	?DGSetSummonerCreate@@YAXPAUOBJECTSTRUCT@@H@Z	; DGSetSummonerCreate
PUBLIC	?GDExpandWarehouseSend@@YAXPAUOBJECTSTRUCT@@H@Z	; GDExpandWarehouseSend
PUBLIC	?GDExpandInventorySend@@YAXPAUOBJECTSTRUCT@@H@Z	; GDExpandInventorySend
PUBLIC	?DGMuBotSettingsSend@@YAXHPADPAE@Z		; DGMuBotSettingsSend
PUBLIC	?DGMuBotOptionRecv@@YAXPAUMUBOT_SETTINGS_SEND@@@Z ; DGMuBotOptionRecv
PUBLIC	?DGDeleteTempUserInfo@@YAXPAUSDHP_DELETE_TEMPUSERINFO_RESULT@@@Z ; DGDeleteTempUserInfo
PUBLIC	?DGBroadCastGlobalMessage@@YAXPAE@Z		; DGBroadCastGlobalMessage
PUBLIC	?requestDbUpdateCredits@@YAXPAUOBJECTSTRUCT@@FF@Z ; requestDbUpdateCredits
PUBLIC	?answerDbInfo@@YAXPAUpacketDbAnswerInfo@@@Z	; answerDbInfo
PUBLIC	?GS_GDReqCastleDateChange@@YAXHHGEEGEE@Z	; GS_GDReqCastleDateChange
PUBLIC	?GS_GDReqGuildMarkReqInfo@@YAXHH@Z		; GS_GDReqGuildMarkReqInfo
PUBLIC	?GS_GDReqGuildMark@@YAXHHH@Z			; GS_GDReqGuildMark
PUBLIC	?GS_GDReqResetReqSiegeInfo@@YAXH@Z		; GS_GDReqResetReqSiegeInfo
PUBLIC	?GS_GDReqCaslteNpcInfo@@YAXHH@Z			; GS_GDReqCaslteNpcInfo
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?DROP_LOG_DEBUG@@3VCLogToFile@@A		; DROP_LOG_DEBUG
PUBLIC	??_C@_0L@OHHLBHJC@?4?2Log?2Drop?$AA@		; `string'
PUBLIC	??_C@_04DJCMGLJH@Drop?$AA@			; `string'
PUBLIC	??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CFd@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0P@GMPEKMII@Test?5Data?5Send?$AA@		; `string'
PUBLIC	??_C@_0P@DNGOKBGI@DSProtocol?4cpp?$AA@		; `string'
PUBLIC	??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@ ; `string'
PUBLIC	??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@ ; `string'
PUBLIC	??_C@_0CA@ICFKKJJD@?$FL?5ZEN?5MODIFY?5?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd?5?9?$DO?50?$AA@ ; `string'
PUBLIC	??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@ ; `string'
PUBLIC	??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@ ; `string'
PUBLIC	??_C@_0EO@MMCPKNFL@?$FLFRUIT?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIMinusPo@ ; `string'
PUBLIC	??_C@_0GD@LBDNOPPJ@?$FLFRUIT?5System?$FN?5Character?5Stat?5Er@ ; `string'
PUBLIC	??_C@_0CI@DDIOKKGJ@For?5this?5server?5you?5need?5premium@ ; `string'
PUBLIC	??_C@_0EM@LOGFDPHA@?$FLMapServerMng?$FN?5GJSetCharacterInf@ ; `string'
PUBLIC	??_C@_0FG@OKDBPAON@?$FLMapServerMng?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5GJSetChar@ ; `string'
PUBLIC	??_C@_0DP@HCBBCCKB@?$FL380Item?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5380?5It@ ; `string'
PUBLIC	??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5N@ ; `string'
PUBLIC	??_C@_0HO@BMIFLCBN@?$FLSocketItem?$FN?5Generate?5Socket?5Ite@ ; `string'
PUBLIC	??_C@_04CGFJFPFD@none?$AA@			; `string'
PUBLIC	??_C@_0HH@HKJJNFBM@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5?$FL@ ; `string'
PUBLIC	??_C@_0EP@GIBMCCNN@PACKET_RECIEVED?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3?5s@ ; `string'
PUBLIC	??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5use@ ; `string'
PUBLIC	??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4?$AA@ ; `string'
PUBLIC	??_C@_0GA@EHKFCGJE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item?3@ ; `string'
PUBLIC	??_C@_0EN@FHICBGBB@?$FLItemCreate?$FN?5Error?5?3?5Failed?5To?5I@ ; `string'
PUBLIC	??_C@_0EL@KDEJKEEJ@?$FLCashShop?$FN?5Error?5?3?5Failed?5To?5Ins@ ; `string'
PUBLIC	??_C@_0EO@CJFPAOBM@?$FLQuestSystem?$FN?5Error?5?3?5Failed?5To?5@ ; `string'
PUBLIC	??_C@_0GD@LMECKDPM@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3@ ; `string'
PUBLIC	??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@ ; `string'
PUBLIC	??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI@ ; `string'
PUBLIC	??_C@_0BD@IBAEEAEE@?A?$KC?$LM?S?$MA?L?5?A?$LO?$LH?a?$LF?K?$LE?O?$LE?Y?4?$AA@ ; `string'
PUBLIC	??_C@_0CD@HNLEMMHH@?$LK?P?G?R?5?$LM?$KN?$LJ?v?$LH?N?5?A?$KC?$LM?S?G?X?A?V?$LN?C?$LB?b?5?$LJ?Y?$LG?x?$LE?O?$LE@ ; `string'
PUBLIC	??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5infom@ ; `string'
PUBLIC	??_C@_0CP@HBHBBGIF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5L@ ; `string'
PUBLIC	??_C@_0CP@HLCJJJIG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5L@ ; `string'
PUBLIC	??_C@_0HN@BJMCOPEN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HK@OKLAENCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0FK@LDEGMOJD@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ ; `string'
PUBLIC	??_C@_0FO@MKLLBJCJ@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ ; `string'
PUBLIC	??_C@_0FA@BIAOFLEB@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ ; `string'
PUBLIC	??_C@_0HN@PMNAMEJH@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0GA@JLLACOMH@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ ; `string'
PUBLIC	??_C@_0GE@FAGFLPLN@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ ; `string'
PUBLIC	??_C@_0FD@BEMJCHLC@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ ; `string'
PUBLIC	??_C@_0HO@HLBFNNIO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0FG@NIOIKHAG@?$FLCastleSiege?$FN?5ERROR?5?9?5Castle?5NPC@ ; `string'
PUBLIC	??_C@_0GE@HOFNMLEH@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x06?$FN?5GS_DG@ ; `string'
PUBLIC	??_C@_0HF@NIPKIGMO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HL@PMPBBPDM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HP@IIFHPCOO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HE@CADAABKE@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x08?$FN?5GS_DG@ ; `string'
PUBLIC	??_C@_0HN@KCDIDGDG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HO@JKCCCDJI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HO@EGJJDJOF@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HP@ODLOINGN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HM@ENOOGPCP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0IA@JGOKJONB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0IA@LNMFDGBP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HK@NECBCB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HM@JNNIOIKL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0IA@HBPHMAAG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0FA@NDMPNFNO@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x18?$FN?5GS_DG@ ; `string'
PUBLIC	??_C@_0IA@OLLELCLL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0IB@LEBBPIHB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HP@DDPBMEPM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ ; `string'
PUBLIC	??_C@_0HG@CBDKIEJG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x81@ ; `string'
PUBLIC	??_C@_0GO@LJFKFDKN@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ ; `string'
PUBLIC	??_C@_0EM@NPBCIFML@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ ; `string'
PUBLIC	??_C@_0GD@EAAPMHFJ@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ ; `string'
PUBLIC	??_C@_0GC@MGFHIKBL@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ ; `string'
PUBLIC	??_C@_0HF@FPJKEGCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x82@ ; `string'
PUBLIC	??_C@_0HL@PPDLAEKI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x83@ ; `string'
PUBLIC	??_C@_0HG@MMFIPMJM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x84@ ; `string'
PUBLIC	??_C@_0HI@DCOFLPNN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@ ; `string'
PUBLIC	??_C@_0FI@CEGBKGAK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@ ; `string'
PUBLIC	??_C@_0HI@LIMFILFK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x86@ ; `string'
PUBLIC	??_C@_0HM@DAOCJLIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x87@ ; `string'
PUBLIC	??_C@_0HM@MGDLGKIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x88@ ; `string'
PUBLIC	??_C@_0HH@KKMGHAAE@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x89@ ; `string'
PUBLIC	??_C@_07OIIICFNN@SUCCEED?$AA@			; `string'
PUBLIC	??_C@_04OOEBCMBF@FAIL?$AA@			; `string'
PUBLIC	??_C@_0EP@HIMGAPIB@?$FLCastleSiege?$FN?5?$FL0x89?$FN?5GS_DGAnsCas@ ; `string'
PUBLIC	??_C@_0CL@BPJMLKLO@?$FL?5CRYWOLF?5?$FN?5SYNC?5Occupation?3?5?$CFd?0@ ; `string'
PUBLIC	??_C@_0CM@OEMLKOCG@?$FL?5Crywolf?5?$FN?5Incorrect?5DB?5Occupat@ ; `string'
PUBLIC	??_C@_07FHODIPOK@?$CFs?5?$HM?5?$CFs?$AA@	; `string'
PUBLIC	__real@41200000
PUBLIC	__real@437f0000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_strcpy_s:PROC
EXTRN	_strncmp:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEE@Z:PROC		; CItem::Convert
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?SetPetItemInfo@CItem@@QAEXHH@Z:PROC		; CItem::SetPetItemInfo
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?ItemByteConvert16@@YAXPAEQAVCItem@@H@Z:PROC	; ItemByteConvert16
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
EXTRN	?IsItem@@YAHH@Z:PROC				; IsItem
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
EXTRN	?MagicByteConvert@@YAXPAEQAVCMagicInf@@H@Z:PROC	; MagicByteConvert
EXTRN	?DGAnswerServerInfo@CGensSystem@@QAEXPAE@Z:PROC	; CGensSystem::DGAnswerServerInfo
EXTRN	?GDReqGensInfo@CGensSystem@@QAEXH@Z:PROC	; CGensSystem::GDReqGensInfo
EXTRN	?DGAnsJoinRequest@CGensSystem@@QAEXPAE@Z:PROC	; CGensSystem::DGAnsJoinRequest
EXTRN	?DGAnsGensInfo@CGensSystem@@QAEXPAE@Z:PROC	; CGensSystem::DGAnsGensInfo
EXTRN	?DGAnsLeaveRequest@CGensSystem@@QAEXPAE@Z:PROC	; CGensSystem::DGAnsLeaveRequest
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z:PROC ; CItemSystemFor380::Is380Item
EXTRN	?IsSocketItem@CSocketItems@@QAE_NH@Z:PROC	; CSocketItems::IsSocketItem
EXTRN	?GetSocketCount@CSocketItems@@QAEEH@Z:PROC	; CSocketItems::GetSocketCount
EXTRN	?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKEPAEE@Z:PROC ; MapClass::MonsterItemDrop
EXTRN	?MapNumberCheck@@YAHH@Z:PROC			; MapNumberCheck
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCInventoryItemOneSend@@YAXHH@Z:PROC		; GCInventoryItemOneSend
EXTRN	?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z:PROC ; GCMagicListMultiSend
EXTRN	?GCSkillKeySend@@YAXHPAEEEEEEEK@Z:PROC		; GCSkillKeySend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; GCUserWarehouseSend
EXTRN	?GCWarehouseStateSend@@YAXHE@Z:PROC		; GCWarehouseStateSend
EXTRN	?CGRequestQuestInfo@@YAXH@Z:PROC		; CGRequestQuestInfo
EXTRN	?GCAnsCastleSiegeState@@YAXHHPAD0@Z:PROC	; GCAnsCastleSiegeState
EXTRN	?GCAnsRegCastleSiege@@YAXHHPAD@Z:PROC		; GCAnsRegCastleSiege
EXTRN	?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z:PROC ; GCAnsGuildRegInfo
EXTRN	?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z:PROC ; GCAnsRegGuildMark
EXTRN	?GCAnsNpcBuy@@YAXHHHH@Z:PROC			; GCAnsNpcBuy
EXTRN	?GCAnsNpcRepair@@YAXHHHHHH@Z:PROC		; GCAnsNpcRepair
EXTRN	?GCAnsNpcUpgrade@@YAXHHHHHH@Z:PROC		; GCAnsNpcUpgrade
EXTRN	?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z:PROC		; GCAnsTaxMoneyInfo
EXTRN	?GCAnsTaxRateChange@@YAXHHEH@Z:PROC		; GCAnsTaxRateChange
EXTRN	?GCAnsMoneyDrawOut@@YAXHH_J@Z:PROC		; GCAnsMoneyDrawOut
EXTRN	?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z:PROC	; GCAnsGiveUpCastleSiege
EXTRN	?GCSendMuBotSettings@@YAXHPAE@Z:PROC		; GCSendMuBotSettings
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?gObjCloseSet@@YAXHH@Z:PROC			; gObjCloseSet
EXTRN	?gObjSetCharacter@@YAHPAEH@Z:PROC		; gObjSetCharacter
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?gObjStatTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjStatTextSave
EXTRN	?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjItemTextSave
EXTRN	?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjWarehouseTextSave
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjIsAccontConnect@@YAHHPAD@Z:PROC		; gObjIsAccontConnect
EXTRN	?gObjGetAccountId@@YAPADH@Z:PROC		; gObjGetAccountId
EXTRN	?gObjInventoryInsertItem@@YAEHVCItem@@@Z:PROC	; gObjInventoryInsertItem
EXTRN	?gObjWarehouseItemSet@@YAXHHE@Z:PROC		; gObjWarehouseItemSet
EXTRN	?gObjChaosItemSet@@YAXHHE@Z:PROC		; gObjChaosItemSet
EXTRN	?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z:PROC ; gObjChaosBoxInsertItemPos
EXTRN	?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z:PROC ; gObjWarehouseInsertItemPos
EXTRN	?LevelSmallConvert@@YAEH@Z:PROC			; LevelSmallConvert
EXTRN	?PShop_CheckInventoryEmpty@@YA_NF@Z:PROC	; PShop_CheckInventoryEmpty
EXTRN	?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolCreate
EXTRN	?gObjGetStatPointState@@YAXHAAF000@Z:PROC	; gObjGetStatPointState
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?Output@CLogToFile@@QAAXPADZZ:PROC		; CLogToFile::Output
EXTRN	??0CLogToFile@@QAE@QAD0H@Z:PROC			; CLogToFile::CLogToFile
EXTRN	??1CLogToFile@@QAE@XZ:PROC			; CLogToFile::~CLogToFile
EXTRN	?Send@DBSockMng@@QAEHHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?DGAnsPartyMatchReg@@YAXPAUPMSG_PARTYMATCHING_REG_ANS@@@Z:PROC ; DGAnsPartyMatchReg
EXTRN	?DGAnsPartyMatchInfo@@YAXPAE@Z:PROC		; DGAnsPartyMatchInfo
EXTRN	?DGAnsPartyMatchJoin@@YAXPAUPMSG_PARTYMATCHING_JOIN_ANS@@@Z:PROC ; DGAnsPartyMatchJoin
EXTRN	?DGAnsPartyMatchWaitlist@@YAXPAUPMSG_PARTYMATCHING_WAIT_ANS@@@Z:PROC ; DGAnsPartyMatchWaitlist
EXTRN	?DGAnsPartyMatchCancel@@YAXPAUPMSG_PARTYMATCHING_CANCEL_ANS@@@Z:PROC ; DGAnsPartyMatchCancel
EXTRN	?DGAnsPartyMatchAcceptList@@YAXPAE@Z:PROC	; DGAnsPartyMatchAcceptList
EXTRN	?DGAnsPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_DGANS_REQUESTANSWER@@@Z:PROC ; DGAnsPartyMatchRequestAnswer
EXTRN	?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z:PROC ; CMapServerManager::CheckMoveMapSvr
EXTRN	?SetCastleOwnerGuild@CCastleSiegeSync@@QAEXPAD@Z:PROC ; CCastleSiegeSync::SetCastleOwnerGuild
EXTRN	?ResetTributeMoney@CCastleSiegeSync@@QAEXXZ:PROC ; CCastleSiegeSync::ResetTributeMoney
EXTRN	?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ChaosBoxInit
EXTRN	?QuestInfoSave@CQuestInfo@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CQuestInfo::QuestInfoSave
EXTRN	?DGReqMonsterKillInfo@CQuestMonsterKillInfo@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CQuestMonsterKillInfo::DGReqMonsterKillInfo
EXTRN	?GDAnsMonsterKillInfo@CQuestMonsterKillInfo@@QAEXPAE@Z:PROC ; CQuestMonsterKillInfo::GDAnsMonsterKillInfo
EXTRN	?SaveMonsterKillInfo@CQuestMonsterKillInfo@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CQuestMonsterKillInfo::SaveMonsterKillInfo
EXTRN	?GDReqQuestInfo@CQuestInfoEx@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CQuestInfoEx::GDReqQuestInfo
EXTRN	?DGAnsQuestInfo@CQuestInfoEx@@QAEXPAE@Z:PROC	; CQuestInfoEx::DGAnsQuestInfo
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z:PROC	; TNotice::SetNoticeProperty
EXTRN	?SendNoticeToAllUser@TNotice@@SAXPAX@Z:PROC	; TNotice::SendNoticeToAllUser
EXTRN	?DGGuildMemberInfoRequest@@YAXH@Z:PROC		; DGGuildMemberInfoRequest
EXTRN	?FriendListRequest@@YAXH@Z:PROC			; FriendListRequest
EXTRN	?GJReqMapSvrMove@@YAXHGGEE@Z:PROC		; GJReqMapSvrMove
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?DGAnsPeriodItemList@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_LIST@@@Z:PROC ; CCashItemPeriodSystem::DGAnsPeriodItemList
EXTRN	?DGAnsPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_INSERT@@@Z:PROC ; CCashItemPeriodSystem::DGAnsPeriodItemInsert
EXTRN	?DGAnsPeriodItemInquiry@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_INQUIRY@@@Z:PROC ; CCashItemPeriodSystem::DGAnsPeriodItemInquiry
EXTRN	?DGAnsPeriodItemUpdate@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_UPDATE@@@Z:PROC ; CCashItemPeriodSystem::DGAnsPeriodItemUpdate
EXTRN	?DGAnsPeriodItemDelete@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_DELETE@@@Z:PROC ; CCashItemPeriodSystem::DGAnsPeriodItemDelete
EXTRN	?GetBridgeLevel@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetBridgeLevel
EXTRN	?GetItemMap@CBloodCastle@@QAEHH@Z:PROC		; CBloodCastle::GetItemMap
EXTRN	?GetRewardMap@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetRewardMap
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSetW@@YAXPAEEH@Z:PROC			; PHeadSetW
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?SetOccupationState@CCrywolfSync@@QAEXH@Z:PROC	; CCrywolfSync::SetOccupationState
EXTRN	?SetCrywolfState@CCrywolfSync@@QAEXH@Z:PROC	; CCrywolfSync::SetCrywolfState
EXTRN	?Init@CCastleSiege@@QAEHXZ:PROC			; CCastleSiege::Init
EXTRN	?GetDataLoadState@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetDataLoadState
EXTRN	?SetDataLoadState@CCastleSiege@@QAEXH@Z:PROC	; CCastleSiege::SetDataLoadState
EXTRN	?SetDbDataLoadOK@CCastleSiege@@QAEXH@Z:PROC	; CCastleSiege::SetDbDataLoadOK
EXTRN	?FirstCreateDbNPC@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::FirstCreateDbNPC
EXTRN	?SetCastleInitData@CCastleSiege@@QAEHPAUCSP_ANS_CSINITDATA@@@Z:PROC ; CCastleSiege::SetCastleInitData
EXTRN	?SetCastleNpcData@CCastleSiege@@QAEHPAUCSP_CSINITDATA@@H@Z:PROC ; CCastleSiege::SetCastleNpcData
EXTRN	?CreateDbNPC@CCastleSiege@@QAEXXZ:PROC		; CCastleSiege::CreateDbNPC
EXTRN	?AddDbNPC@CCastleSiege@@QAEHHH@Z:PROC		; CCastleSiege::AddDbNPC
EXTRN	?RepairDbNPC@CCastleSiege@@QAEHHHHH@Z:PROC	; CCastleSiege::RepairDbNPC
EXTRN	?UpgradeDbNPC@CCastleSiege@@QAEHHHHHHH@Z:PROC	; CCastleSiege::UpgradeDbNPC
EXTRN	?SetTaxRate@CCastleSiege@@QAEXHH@Z:PROC		; CCastleSiege::SetTaxRate
EXTRN	?SetCastleMoney@CCastleSiege@@QAEX_J@Z:PROC	; CCastleSiege::SetCastleMoney
EXTRN	?ResetCastleTaxInfo@CCastleSiege@@QAEXXZ:PROC	; CCastleSiege::ResetCastleTaxInfo
EXTRN	?SetIsSiegeGuildList@CCastleSiege@@QAEXH@Z:PROC	; CCastleSiege::SetIsSiegeGuildList
EXTRN	?GetDbNpcCreated@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetDbNpcCreated
EXTRN	?SetDbNpcCreated@CCastleSiege@@QAEXH@Z:PROC	; CCastleSiege::SetDbNpcCreated
EXTRN	?ResetCastleCycle@CCastleSiege@@QAEXXZ:PROC	; CCastleSiege::ResetCastleCycle
EXTRN	?SetCalcRegGuildList@CCastleSiege@@QAEXPAUCSP_CALCREGGUILDLIST@@H@Z:PROC ; CCastleSiege::SetCalcRegGuildList
EXTRN	?MakeCsTotalGuildInfo@CCastleSiege@@QAEXPAUCSP_CSGUILDUNIONINFO@@H@Z:PROC ; CCastleSiege::MakeCsTotalGuildInfo
EXTRN	?SetCsTotalGuildInfo@CCastleSiege@@QAEXPAUCSP_CSLOADTOTALGUILDINFO@@H@Z:PROC ; CCastleSiege::SetCsTotalGuildInfo
EXTRN	?ApplyCrywolfDBInfo@CCrywolf@@QAEXHH@Z:PROC	; CCrywolf::ApplyCrywolfDBInfo
EXTRN	?IsEnabled@CMasterExperience@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CMasterExperience::IsEnabled
EXTRN	?DGReqMasterInfo@CMasterExperience@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMasterExperience::DGReqMasterInfo
EXTRN	?GDAnsMasterInfo@CMasterExperience@@QAEXPAE@Z:PROC ; CMasterExperience::GDAnsMasterInfo
EXTRN	?SaveMasterInfo@CMasterExperience@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CMasterExperience::SaveMasterInfo
EXTRN	?GCSendAllItemInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CCashShop::GCSendAllItemInfo
EXTRN	?IsElementalItem@CElementalSystem@@QAEHH@Z:PROC	; CElementalSystem::IsElementalItem
EXTRN	?GDReqErtelList@CElementalSystem@@QAEXH@Z:PROC	; CElementalSystem::GDReqErtelList
EXTRN	?DGAnsErtelList@CElementalSystem@@QAEXPAUPMSG_ANS_ERTELLIST@@@Z:PROC ; CElementalSystem::DGAnsErtelList
EXTRN	?GDSaveErtelList@CElementalSystem@@QAEXH@Z:PROC	; CElementalSystem::GDSaveErtelList
EXTRN	?AddToPriviousParty@CTemporaryUserManager@@QAEHHH@Z:PROC ; CTemporaryUserManager::AddToPriviousParty
EXTRN	?DeleteUserInParty@CTemporaryUserManager@@QAEXH@Z:PROC ; CTemporaryUserManager::DeleteUserInParty
EXTRN	?CheckMatchCharacter@CTemporaryUserManager@@QAEHPAD@Z:PROC ; CTemporaryUserManager::CheckMatchCharacter
EXTRN	?SendEventMapInfo@CTemporaryUserManager@@QAEXHH@Z:PROC ; CTemporaryUserManager::SendEventMapInfo
EXTRN	?SendNpcCoordinate@Minimap@@QAEXHEE@Z:PROC	; Minimap::SendNpcCoordinate
EXTRN	?SendPortalCoordinate@Minimap@@QAEXHE@Z:PROC	; Minimap::SendPortalCoordinate
EXTRN	?DGAnsOfferList@GuildMatch@@QAEXPAE@Z:PROC	; GuildMatch::DGAnsOfferList
EXTRN	?DGAnsOfferCreate@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_OFFERCREATE@@@Z:PROC ; GuildMatch::DGAnsOfferCreate
EXTRN	?DGAnsOfferDelete@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_OFFERDELETE@@@Z:PROC ; GuildMatch::DGAnsOfferDelete
EXTRN	?DGAnsJoinReq@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_JOINREQ@@@Z:PROC ; GuildMatch::DGAnsJoinReq
EXTRN	?DGAnsJoinReqDelete@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_OFFERDELETE@@@Z:PROC ; GuildMatch::DGAnsJoinReqDelete
EXTRN	?DGAnsJoinReqAnswer@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_REQUESTANSWER@@@Z:PROC ; GuildMatch::DGAnsJoinReqAnswer
EXTRN	?DGAnsJoinReqList@GuildMatch@@QAEXPAE@Z:PROC	; GuildMatch::DGAnsJoinReqList
EXTRN	?DGAnsJoinReqStatus@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_JOINREQSTATUS@@@Z:PROC ; GuildMatch::DGAnsJoinReqStatus
EXTRN	?SendOnConnect@Notice@@QAEXH@Z:PROC		; Notice::SendOnConnect
EXTRN	?DBSendVaultResult@WareHouseSYSTEM@@QAEXPAUPMSG_VAULT_RESULT@@@Z:PROC ; WareHouseSYSTEM::DBSendVaultResult
EXTRN	?Activate@HardcoreMode@@QAEXXZ:PROC		; HardcoreMode::Activate
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gGensSystem@@3VCGensSystem@@A:BYTE		; gGensSystem
EXTRN	?g_kItemSystemFor380@@3VCItemSystemFor380@@A:BYTE ; g_kItemSystemFor380
EXTRN	?g_SocketItem@@3VCSocketItems@@A:BYTE		; g_SocketItem
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?m_ObjBill@@3PAVBILL_CLASS@@A:BYTE		; m_ObjBill
EXTRN	?gPremiumServer@@3PAEA:DWORD			; gPremiumServer
EXTRN	?iCount@@3HA:DWORD				; iCount
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?DataServerConnected@@3HA:DWORD			; DataServerConnected
EXTRN	?GameServerPort@@3HA:DWORD			; GameServerPort
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?szServerName@@3PADA:BYTE			; szServerName
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?bCanWarehouseLock@@3HA:DWORD			; bCanWarehouseLock
EXTRN	?g_CreateCharLevelRF@@3FA:WORD			; g_CreateCharLevelRF
EXTRN	?g_CreateCharLevelSUM@@3FA:WORD			; g_CreateCharLevelSUM
EXTRN	?g_CreateCharLevelDL@@3FA:WORD			; g_CreateCharLevelDL
EXTRN	?g_CreateCharLevelMG@@3FA:WORD			; g_CreateCharLevelMG
EXTRN	?gServerReady@@3HA:DWORD			; gServerReady
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?g_ChaosBox@@3VCChaosBox@@A:BYTE		; g_ChaosBox
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?g_MonsterKillInfo@@3VCQuestMonsterKillInfo@@A:DWORD ; g_MonsterKillInfo
EXTRN	?gQuestInfoEx@@3VCQuestInfoEx@@A:BYTE		; gQuestInfoEx
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A:BYTE ; g_CashItemPeriodSystem
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?g_Crywolf@@3VCCrywolf@@A:BYTE			; g_Crywolf
EXTRN	?g_MasterExp@@3VCMasterExperience@@A:BYTE	; g_MasterExp
EXTRN	?g_CashShop@@3VCCashShop@@A:BYTE		; g_CashShop
EXTRN	?g_ElementalSystem@@3VCElementalSystem@@A:BYTE	; g_ElementalSystem
EXTRN	?cpDSPTempUserManager@@3PAVCTemporaryUserManager@@A:DWORD ; cpDSPTempUserManager
EXTRN	?g_Minimap@@3VMinimap@@A:BYTE			; g_Minimap
EXTRN	?g_GuildMatch@@3VGuildMatch@@A:BYTE		; g_GuildMatch
EXTRN	?g_Notice@@3VNotice@@A:BYTE			; g_Notice
EXTRN	?gWareHouseSYSTEM@@3VWareHouseSYSTEM@@A:BYTE	; gWareHouseSYSTEM
EXTRN	?g_HardcoreMode@@3VHardcoreMode@@A:BYTE		; g_HardcoreMode
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?DROP_LOG_DEBUG@@3VCLogToFile@@A DB 010228H DUP (?)	; DROP_LOG_DEBUG
_BSS	ENDS
CRT$XCU	SEGMENT
?DROP_LOG_DEBUG$initializer$@@3P6AXXZA DD FLAT:??__EDROP_LOG_DEBUG@@YAXXZ ; DROP_LOG_DEBUG$initializer$
CRT$XCU	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT ??_C@_07FHODIPOK@?$CFs?5?$HM?5?$CFs?$AA@
CONST	SEGMENT
??_C@_07FHODIPOK@?$CFs?5?$HM?5?$CFs?$AA@ DB '%s | %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OEMLKOCG@?$FL?5Crywolf?5?$FN?5Incorrect?5DB?5Occupat@
CONST	SEGMENT
??_C@_0CM@OEMLKOCG@?$FL?5Crywolf?5?$FN?5Incorrect?5DB?5Occupat@ DB '[ Cry'
	DB	'wolf ] Incorrect DB OccupationState!!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BPJMLKLO@?$FL?5CRYWOLF?5?$FN?5SYNC?5Occupation?3?5?$CFd?0@
CONST	SEGMENT
??_C@_0CL@BPJMLKLO@?$FL?5CRYWOLF?5?$FN?5SYNC?5Occupation?3?5?$CFd?0@ DB '['
	DB	' CRYWOLF ] SYNC Occupation: %d, State: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@HIMGAPIB@?$FLCastleSiege?$FN?5?$FL0x89?$FN?5GS_DGAnsCas@
CONST	SEGMENT
??_C@_0EP@HIMGAPIB@?$FLCastleSiege?$FN?5?$FL0x89?$FN?5GS_DGAnsCas@ DB '[C'
	DB	'astleSiege] [0x89] GS_DGAnsCastleNpcUpdate() - Npc Data Updat'
	DB	'e Result : ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOEBCMBF@FAIL?$AA@
CONST	SEGMENT
??_C@_04OOEBCMBF@FAIL?$AA@ DB 'FAIL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OIIICFNN@SUCCEED?$AA@
CONST	SEGMENT
??_C@_07OIIICFNN@SUCCEED?$AA@ DB 'SUCCEED', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HH@KKMGHAAE@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x89@
CONST	SEGMENT
??_C@_0HH@KKMGHAAE@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x89@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x89] GS_DGAnsCastleNpcUpdate() - lpM'
	DB	'sg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HM@MGDLGKIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x88@
CONST	SEGMENT
??_C@_0HM@MGDLGKIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x88@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x88] GS_DGAnsCsLoadTotalGuildInfo() '
	DB	'- lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HM@DAOCJLIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x87@
CONST	SEGMENT
??_C@_0HM@DAOCJLIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x87@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x87] GS_DGAnsCsSaveTotalGuildInfo() '
	DB	'- lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HI@LIMFILFK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x86@
CONST	SEGMENT
??_C@_0HI@LIMFILFK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x86@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x86] GS_DGAnsCsGulidUnionInfo() - lp'
	DB	'Msg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@CEGBKGAK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@
CONST	SEGMENT
??_C@_0FI@CEGBKGAK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x85] GS_DGAnsCalcREgGuildList() - lp'
	DB	'Msg->iResult != 1 (%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HI@DCOFLPNN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@
CONST	SEGMENT
??_C@_0HI@DCOFLPNN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x85] GS_DGAnsCalcREgGuildList() - lp'
	DB	'Msg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@MMFIPMJM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x84@
CONST	SEGMENT
??_C@_0HG@MMFIPMJM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x84@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x84] GS_DGAnsFirstCreateNPC() - lpMs'
	DB	'g->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HL@PPDLAEKI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x83@
CONST	SEGMENT
??_C@_0HL@PPDLAEKI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x83@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x83] GS_DGAnsAllGuildMarkRegInfo() -'
	DB	' lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@FPJKEGCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x82@
CONST	SEGMENT
??_C@_0HF@FPJKEGCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x82@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x82] GS_DGAnsCastleNpcInfo() - lpMsg'
	DB	'->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@MGFHIKBL@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
CONST	SEGMENT
??_C@_0GC@MGFHIKBL@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ DB '[Castl'
	DB	'eSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - g_CastleSie'
	DB	'ge.SetCastleNpcData() == FALSE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@EAAPMHFJ@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
CONST	SEGMENT
??_C@_0GD@EAAPMHFJ@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ DB '[Castl'
	DB	'eSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - g_CastleSie'
	DB	'ge.SetCastleInitData() == FALSE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@NPBCIFML@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
CONST	SEGMENT
??_C@_0EM@NPBCIFML@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ DB '[Castl'
	DB	'eSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - lpMsg->iRes'
	DB	'ult == 0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@LJFKFDKN@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
CONST	SEGMENT
??_C@_0GO@LJFKFDKN@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@ DB '[Castl'
	DB	'eSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - m_iCastleDa'
	DB	'taLoadState != CASTLESIEGE_DATALOAD_2 (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@CBDKIEJG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x81@
CONST	SEGMENT
??_C@_0HG@CBDKIEJG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x81@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x81] GS_DGAnsCastleInitData() - lpMs'
	DB	'g->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@DDPBMEPM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HP@DDPBMEPM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x1B] GS_DGAnsResetRegSiegeInfo'
	DB	'() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@LEBBPIHB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0IB@LEBBPIHB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x1A] GS_DGAnsResetSiegeGuildIn'
	DB	'fo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup'
	DB	'()', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@OLLELCLL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0IA@OLLELCLL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x19] GS_DGAnsResetCastleTaxInf'
	DB	'o() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup('
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NDMPNFNO@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x18?$FN?5GS_DG@
CONST	SEGMENT
??_C@_0FA@NDMPNFNO@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x18?$FN?5GS_DG@ DB '['
	DB	'CastleSiege] [0x80][0x18] GS_DGAnsCastleTributeMoney() - Mone'
	DB	'y Tribute OK (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@HBPHMAAG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0IA@HBPHMAAG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x18] GS_DGAnsCastleTributeMone'
	DB	'y() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup('
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HM@JNNIOIKL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HM@JNNIOIKL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x12] GS_DGAnsGuildSetGiveUp() '
	DB	'- lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HK@NECBCB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HK@NECBCB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Castl'
	DB	'eSiege] PACKET-ERROR [0x80][0x10] GS_DGAnsRegGuildMark() - lp'
	DB	'Msg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@LNMFDGBP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0IA@LNMFDGBP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0F] GS_DGAnsMapSvrMsgMultiCas'
	DB	't() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup('
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@JGOKJONB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0IA@JGOKJONB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0E] GS_DGAnsRestartCastleStat'
	DB	'e() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup('
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HM@ENOOGPCP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HM@ENOOGPCP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0D] GS_DGAnsRegAttackGuild() '
	DB	'- lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@ODLOINGN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HP@ODLOINGN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0C] GS_DGAnsCastleOwnerChange'
	DB	'() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@EGJJDJOF@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HO@EGJJDJOF@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0B] GS_DGAnsSiegeEndedChange('
	DB	') - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@JKCCCDJI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HO@JKCCCDJI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x0A] GS_DGAnsGuildMarkRegInfo('
	DB	') - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@KCDIDGDG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HN@KCDIDGDG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x09] GS_DGAnsSiegeDateChange()'
	DB	' - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@CADAABKE@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x08?$FN?5GS_DG@
CONST	SEGMENT
??_C@_0HE@CADAABKE@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x08?$FN?5GS_DG@ DB '['
	DB	'CastleSiege] [0x80][0x08] GS_DGAnsCastleMoneyChange() - Withd'
	DB	'raw Request OK [%s][%s] (ReqMoney:%d, TotMoney:%I64d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@IIFHPCOO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HP@IIFHPCOO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x08] GS_DGAnsCastleMoneyChange'
	DB	'() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0HL@PMPBBPDM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HL@PMPBBPDM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x07] GS_DGAnsTaxRateChange() -'
	DB	' lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@NIPKIGMO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HF@NIPKIGMO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x06] GS_DGAnsTaxInfo() - lpMsg'
	DB	'->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@HOFNMLEH@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x06?$FN?5GS_DG@
CONST	SEGMENT
??_C@_0GE@HOFNMLEH@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x06?$FN?5GS_DG@ DB '['
	DB	'CastleSiege] [0x80][0x06] GS_DGAnsTaxInfo() - Npc Upgrade OK '
	DB	'(CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@NIOIKHAG@?$FLCastleSiege?$FN?5ERROR?5?9?5Castle?5NPC@
CONST	SEGMENT
??_C@_0FG@NIOIKHAG@?$FLCastleSiege?$FN?5ERROR?5?9?5Castle?5NPC@ DB '[Cast'
	DB	'leSiege] ERROR - Castle NPC Upgrade Fail() (CLS:%d, IDX:%d, U'
	DB	'PTYPE:%d, UPVAL:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@HLBFNNIO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HO@HLBFNNIO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x05] GS_DGAnsCastleNpcUpgrade('
	DB	') - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@BEMJCHLC@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
CONST	SEGMENT
??_C@_0FD@BEMJCHLC@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcRepair() FAILED - Result:(%d), Npc:(CLS'
	DB	':%d, IDX:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@FAGFLPLN@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
CONST	SEGMENT
??_C@_0GE@FAGFLPLN@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcRepair() - CCastleSiege::RepairDbNPC() '
	DB	'FAILED - Npc:(CLS:%d, IDX:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@JLLACOMH@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
CONST	SEGMENT
??_C@_0GA@JLLACOMH@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcRepair() - CCastleSiege::RepairDbNPC() '
	DB	'OK - Npc:(CLS:%d, IDX:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@PMNAMEJH@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HN@PMNAMEJH@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x04] GS_DGAnsCastleNpcRepair()'
	DB	' - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BIAOFLEB@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
CONST	SEGMENT
??_C@_0FA@BIAOFLEB@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcBuy() FAILED - Result:(%d), Npc:(CLS:%d'
	DB	', IDX:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@MKLLBJCJ@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
CONST	SEGMENT
??_C@_0FO@MKLLBJCJ@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcBuy() - CCastleSiege::AddDbNPC() FAILED'
	DB	' - Npc:(CLS:%d, IDX:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@LDEGMOJD@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
CONST	SEGMENT
??_C@_0FK@LDEGMOJD@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@ DB '[CastleSi'
	DB	'ege] GS_DGAnsCastleNpcBuy() - CCastleSiege::AddDbNPC() OK - N'
	DB	'pc:(CLS:%d, IDX:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HK@OKLAENCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HK@OKLAENCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x03] GS_DGAnsCastleNpcBuy() - '
	DB	'lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@BJMCOPEN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
CONST	SEGMENT
??_C@_0HN@BJMCOPEN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@ DB '[Cas'
	DB	'tleSiege] PACKET-ERROR [0x80][0x00] GS_DGAnsCastleTotalInfo()'
	DB	' - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HLCJJJIG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5L@
CONST	SEGMENT
??_C@_0CP@HLCJJJIG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5L@ DB '['
	DB	'%s][%s][PW][%d,%s]serial:[%d] Level:%d Exp:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HBHBBGIF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5L@
CONST	SEGMENT
??_C@_0CP@HBHBBGIF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5L@ DB '['
	DB	'%s][%s][PI][%d,%s]serial:[%d] Level:%d Exp:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5infom@
CONST	SEGMENT
??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5infom@ DB 'Request to r'
	DB	'eceive petitem infomation doesn''t match the user %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HNLEMMHH@?$LK?P?G?R?5?$LM?$KN?$LJ?v?$LH?N?5?A?$KC?$LM?S?G?X?A?V?$LN?C?$LB?b?5?$LJ?Y?$LG?x?$LE?O?$LE@
CONST	SEGMENT
??_C@_0CD@HNLEMMHH@?$LK?P?G?R?5?$LM?$KN?$LJ?v?$LH?N?5?A?$KC?$LM?S?G?X?A?V?$LN?C?$LB?b?5?$LJ?Y?$LG?x?$LE?O?$LE@ DB 0baH
	DB	0d0H, 0c7H, 0d2H, ' ', 0bcH, 0adH, 0b9H, 0f6H, 0b7H, 0ceH, ' ', 0c1H
	DB	0a2H, 0bcH, 0d3H, 0c7H, 0d8H, 0c1H, 0d6H, 0bdH, 0c3H, 0b1H, 0e2H
	DB	' ', 0b9H, 0d9H, 0b6H, 0f8H, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IBAEEAEE@?A?$KC?$LM?S?$MA?L?5?A?$LO?$LH?a?$LF?K?$LE?O?$LE?Y?4?$AA@
CONST	SEGMENT
??_C@_0BD@IBAEEAEE@?A?$KC?$LM?S?$MA?L?5?A?$LO?$LH?a?$LF?K?$LE?O?$LE?Y?4?$AA@ DB 0c1H
	DB	0a2H, 0bcH, 0d3H, 0c0H, 0ccH, ' ', 0c1H, 0beH, 0b7H, 0e1H, 0b5H
	DB	0cbH, 0b4H, 0cfH, 0b4H, 0d9H, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI@
CONST	SEGMENT
??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI@ DB '['
	DB	'CharTrasfer] Success [%s][%s] (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@
CONST	SEGMENT
??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@ DB 0b9H
	DB	0aeH, 0c1H, 0a6H, ' ', 0b9H, 0dfH, 0bbH, 0fdH, 0bdH, 0c3H, ' c'
	DB	'hange@webzen.co.kr', 0b7H, 0ceH, ' ', 0b9H, 0aeH, 0c0H, 0c7H, 0c7H
	DB	0d8H, ' ', 0c1H, 0d6H, 0bdH, 0c3H, 0b1H, 0e2H, 0b9H, 0d9H, 0b6H
	DB	0f8H, 0b4H, 0cfH, 0b4H, 0d9H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ@ DB '['
	DB	'CharTrasfer] Fail [%s][%s] (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@LMECKDPM@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3@
CONST	SEGMENT
??_C@_0GD@LMECKDPM@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3@ DB 'M'
	DB	'onster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d'
	DB	'] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@CJFPAOBM@?$FLQuestSystem?$FN?5Error?5?3?5Failed?5To?5@
CONST	SEGMENT
??_C@_0EO@CJFPAOBM@?$FLQuestSystem?$FN?5Error?5?3?5Failed?5To?5@ DB '[Que'
	DB	'stSystem] Error : Failed To Insert Item Type:%d, TypeIndex:%d'
	DB	' to [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@KDEJKEEJ@?$FLCashShop?$FN?5Error?5?3?5Failed?5To?5Ins@
CONST	SEGMENT
??_C@_0EL@KDEJKEEJ@?$FLCashShop?$FN?5Error?5?3?5Failed?5To?5Ins@ DB '[Cas'
	DB	'hShop] Error : Failed To Insert Item Type:%d, TypeIndex:%d to'
	DB	' [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@FHICBGBB@?$FLItemCreate?$FN?5Error?5?3?5Failed?5To?5I@
CONST	SEGMENT
??_C@_0EN@FHICBGBB@?$FLItemCreate?$FN?5Error?5?3?5Failed?5To?5I@ DB '[Ite'
	DB	'mCreate] Error : Failed To Insert Item Type:%d, TypeIndex:%d '
	DB	'to [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@EHKFCGJE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item?3@
CONST	SEGMENT
??_C@_0GA@EHKFCGJE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item?3@ DB '['
	DB	'%s][%s] CBMix Item Create Item:%s [%d][%d] [%d][%d][%d][%d] E'
	DB	'x:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4?$AA@
CONST	SEGMENT
??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4?$AA@ DB 'error-L2: '
	DB	'ChaosBox not used.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5use@
CONST	SEGMENT
??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5use@ DB 'error-L2: D'
	DB	'arkTrainerBox not used.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ DB 'error-L'
	DB	'3 [%s][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@GIBMCCNN@PACKET_RECIEVED?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3?5s@
CONST	SEGMENT
??_C@_0EP@GIBMCCNN@PACKET_RECIEVED?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3?5s@ DB 'P'
	DB	'ACKET_RECIEVED [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] '
	DB	'Ex:[%d] Set:[%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HH@HKJJNFBM@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5?$FL@
CONST	SEGMENT
??_C@_0HH@HKJJNFBM@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5?$FL@ DB 'M'
	DB	'onster Item Drop Request [%s] [%d][%d][%d] : [%s][%d][%d][%d]'
	DB	'[%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d] | LootUser: [%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGFJFPFD@none?$AA@
CONST	SEGMENT
??_C@_04CGFJFPFD@none?$AA@ DB 'none', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@BMIFLCBN@?$FLSocketItem?$FN?5Generate?5Socket?5Ite@
CONST	SEGMENT
??_C@_0HO@BMIFLCBN@?$FLSocketItem?$FN?5Generate?5Socket?5Ite@ DB '[Socket'
	DB	'Item] Generate Socket Item ( Socket Slot : %d ) - %s, [%d,%d,'
	DB	'%d,%d], Serial : %u, ItemCode : %d, MapNumber : %d(%d/%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5N@
CONST	SEGMENT
??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5N@ DB '['
	DB	'%s][%s] WareHouse Save Fail : Not Open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@HCBBCCKB@?$FL380Item?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5380?5It@
CONST	SEGMENT
??_C@_0DP@HCBBCCKB@?$FL380Item?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5380?5It@ DB '['
	DB	'380Item][%s][%s] Invalid 380 Item Option in Warehouse pos[%d]'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@OKDBPAON@?$FLMapServerMng?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5GJSetChar@
CONST	SEGMENT
??_C@_0FG@OKDBPAON@?$FLMapServerMng?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5GJSetChar@ DB '['
	DB	'MapServerMng][%s][%s] GJSetCharacterInfo() - MapServerMove Ch'
	DB	'aracter Save Start (%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@LOGFDPHA@?$FLMapServerMng?$FN?5GJSetCharacterInf@
CONST	SEGMENT
??_C@_0EM@LOGFDPHA@?$FLMapServerMng?$FN?5GJSetCharacterInf@ DB '[MapServe'
	DB	'rMng] GJSetCharacterInfo() - Inventory Already Saved [%s][%s]'
	DB	' (%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DDIOKKGJ@For?5this?5server?5you?5need?5premium@
CONST	SEGMENT
??_C@_0CI@DDIOKKGJ@For?5this?5server?5you?5need?5premium@ DB 'For this se'
	DB	'rver you need premium status', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@LBDNOPPJ@?$FLFRUIT?5System?$FN?5Character?5Stat?5Er@
CONST	SEGMENT
??_C@_0GD@LBDNOPPJ@?$FLFRUIT?5System?$FN?5Character?5Stat?5Er@ DB '[FRUIT'
	DB	' System] Character Stat Error [%s][%s] (MinusPoint:%d/PlusPoi'
	DB	'nt:%d) (MaxMinus:%d/MaxPlus:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@MMCPKNFL@?$FLFRUIT?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIMinusPo@
CONST	SEGMENT
??_C@_0EO@MMCPKNFL@?$FLFRUIT?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIMinusPo@ DB '['
	DB	'FRUIT System] [%s][%s] (MinusPoint:%d/PlusPoint:%d) (MaxMinus'
	DB	':%d/MaxPlus:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@
CONST	SEGMENT
??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@ DB '[MapSe'
	DB	'rverMng] Request to Move Map Server : (%d) - [%s][%s] (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@
CONST	SEGMENT
??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@ DB '[MapSe'
	DB	'rverMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s]['
	DB	'%s] (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@ICFKKJJD@?$FL?5ZEN?5MODIFY?5?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd?5?9?$DO?50?$AA@
CONST	SEGMENT
??_C@_0CA@ICFKKJJD@?$FL?5ZEN?5MODIFY?5?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd?5?9?$DO?50?$AA@ DB '['
	DB	' ZEN MODIFY ] [%s][%s] %d -> 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@
CONST	SEGMENT
??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@ DB '[A'
	DB	'nti-HACK][JGGetCharacterInfo] Attempted Character-Copy by dou'
	DB	'ble logging [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@
CONST	SEGMENT
??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@ DB 'error-L1 '
	DB	': Load Block Character infomation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DNGOKBGI@DSProtocol?4cpp?$AA@
CONST	SEGMENT
??_C@_0P@DNGOKBGI@DSProtocol?4cpp?$AA@ DB 'DSProtocol.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GMPEKMII@Test?5Data?5Send?$AA@
CONST	SEGMENT
??_C@_0P@GMPEKMII@Test?5Data?5Send?$AA@ DB 'Test Data Send', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CFd@
CONST	SEGMENT
??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CFd@ DB 'er'
	DB	'ror-L2DataServer RECV : %d (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DJCMGLJH@Drop?$AA@
CONST	SEGMENT
??_C@_04DJCMGLJH@Drop?$AA@ DB 'Drop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OHHLBHJC@?4?2Log?2Drop?$AA@
CONST	SEGMENT
??_C@_0L@OHHLBHJC@?4?2Log?2Drop?$AA@ DB '.\Log\Drop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCaslteNpcInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqCaslteNpcInfo@@YAXHH@Z PROC			; GS_GDReqCaslteNpcInfo, COMDAT

; 4773 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4774 : 	if ( iMapSvrGroup < 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 24		 js	 SHORT $LN1@GS_GDReqCa

; 4775 : 	{
; 4776 : 		return;
; 4777 : 	}
; 4778 : 
; 4779 : 	CSP_REQ_NPCDATA pMsg;
; 4780 : 
; 4781 : 	pMsg.h.set((LPBYTE)&pMsg, 0x82, sizeof(CSP_REQ_NPCDATA));
; 4782 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00017	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4785 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00020	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00026	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  0002c	66 c7 45 f0 c1
	0c		 mov	 WORD PTR _pMsg$[ebp], 3265 ; 00000cc1H

; 87   : 		lpBuf[1] = size;
; 88   : 		lpBuf[2] = head;

  00032	c6 45 f2 82	 mov	 BYTE PTR _pMsg$[ebp+2], 130 ; 00000082H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4785 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00036	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 4786 : }

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	33 cd		 xor	 ecx, ebp
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?GS_GDReqCaslteNpcInfo@@YAXHH@Z ENDP			; GS_GDReqCaslteNpcInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqResetReqSiegeInfo@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqResetReqSiegeInfo@@YAXH@Z PROC			; GS_GDReqResetReqSiegeInfo, COMDAT

; 4707 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4708 : 	if ( iMapSvrGroup < 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 1b		 js	 SHORT $LN1@GS_GDReqRe

; 4709 : 	{
; 4710 : 		return;
; 4711 : 	}
; 4712 : 
; 4713 : 	CSP_REQ_RESETREGSIEGEINFO pMsg;
; 4714 : 
; 4715 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x1B, sizeof(CSP_REQ_RESETREGSIEGEINFO));
; 4716 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0000d	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4718 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00016	6a 06		 push	 6
  00018	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0001b	c7 45 f8 c1 06
	80 1b		 mov	 DWORD PTR _pMsg$[ebp], 461375169 ; 1b8006c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4718 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqRe:

; 4719 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?GS_GDReqResetReqSiegeInfo@@YAXH@Z ENDP			; GS_GDReqResetReqSiegeInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqGuildMark@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iItemPos$ = 16						; size = 4
?GS_GDReqGuildMark@@YAXHHH@Z PROC			; GS_GDReqGuildMark, COMDAT

; 4405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4406 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00016	85 d2		 test	 edx, edx
  00018	78 57		 js	 SHORT $LN1@GS_GDReqGu

; 4407 : 	{
; 4408 : 		return;
; 4409 : 	}
; 4410 : 
; 4411 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  0001a	85 c9		 test	 ecx, ecx
  0001c	78 53		 js	 SHORT $LN1@GS_GDReqGu
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 44		 je	 SHORT $LN1@GS_GDReqGu

; 4412 : 	{
; 4413 : 		return;
; 4414 : 	}
; 4415 : 
; 4416 : 
; 4417 : 	CSP_REQ_GUILDREGMARK pMsg;
; 4418 : 
; 4419 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x10, sizeof(CSP_REQ_GUILDREGMARK));
; 4420 : 	pMsg.wMapSvrNum = iMapSvrGroup;
; 4421 : 	pMsg.iIndex = aIndex;
; 4422 : 	pMsg.iItemPos = iItemPos;

  0002d	8b 45 10	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  00030	66 89 55 e8	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 4423 : 	memcpy(pMsg.szGuildName, gObj[aIndex].GuildName, sizeof(pMsg.szGuildName));

  00034	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  0003a	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+20], eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00046	c7 45 e4 c1 18
	80 10		 mov	 DWORD PTR _pMsg$[ebp], 276830401 ; 108018c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4425 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0004d	6a 18		 push	 24			; 00000018H
  0004f	8b 84 0a 1c 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1564]
  00056	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00059	8b 84 0a 20 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1568]
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00065	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00068	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqGu:

; 4426 : }

  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	33 cd		 xor	 ecx, ebp
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?GS_GDReqGuildMark@@YAXHHH@Z ENDP			; GS_GDReqGuildMark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqGuildMarkReqInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqGuildMarkReqInfo@@YAXHH@Z PROC			; GS_GDReqGuildMarkReqInfo, COMDAT

; 4177 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4178 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00016	85 d2		 test	 edx, edx
  00018	78 51		 js	 SHORT $LN1@GS_GDReqGu

; 4179 : 	{
; 4180 : 		return;
; 4181 : 	}
; 4182 : 
; 4183 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  0001a	85 c9		 test	 ecx, ecx
  0001c	78 4d		 js	 SHORT $LN1@GS_GDReqGu
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 3e		 je	 SHORT $LN1@GS_GDReqGu

; 4184 : 	{
; 4185 : 		return;
; 4186 : 	}
; 4187 : 
; 4188 : 
; 4189 : 	CSP_REQ_GUILDREGINFO pMsg;
; 4190 : 
; 4191 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0A, sizeof(CSP_REQ_GUILDREGINFO));
; 4192 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0002d	66 89 55 ec	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 4193 : 	pMsg.iIndex = aIndex;
; 4194 : 	memcpy(pMsg.szGuildName, gObj[aIndex].GuildName, 8);

  00031	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  00037	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00040	c7 45 e8 c1 14
	80 0a		 mov	 DWORD PTR _pMsg$[ebp], 176166081 ; 0a8014c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4196 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00047	6a 14		 push	 20			; 00000014H
  00049	8b 84 0a 1c 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1564]
  00050	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00053	8b 84 0a 20 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1568]
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0005f	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00062	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqGu:

; 4197 : }

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006e	33 cd		 xor	 ecx, ebp
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?GS_GDReqGuildMarkReqInfo@@YAXHH@Z ENDP			; GS_GDReqGuildMarkReqInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCastleDateChange@@YAXHHGEEGEE@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_wStartYear$ = 16					; size = 2
_btStartMonth$ = 20					; size = 1
_btStartDay$ = 24					; size = 1
_wEndYear$ = 28						; size = 2
_btEndMonth$ = 32					; size = 1
_btEndDay$ = 36						; size = 1
?GS_GDReqCastleDateChange@@YAXHHGEEGEE@Z PROC		; GS_GDReqCastleDateChange, COMDAT

; 4136 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4137 : 	if ( iMapSvrGroup < 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 49		 js	 SHORT $LN1@GS_GDReqCa

; 4138 : 	{
; 4139 : 		return;
; 4140 : 	}
; 4141 : 
; 4142 : 	CSP_REQ_SDEDCHANGE pMsg;
; 4143 : 
; 4144 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x09, sizeof(CSP_REQ_SDEDCHANGE));
; 4145 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00017	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4154 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00020	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00023	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00026	66 8b 45 10	 mov	 ax, WORD PTR _wStartYear$[ebp]
  0002a	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+12], ax
  0002e	8a 45 14	 mov	 al, BYTE PTR _btStartMonth$[ebp]
  00031	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+14], al
  00034	8a 45 18	 mov	 al, BYTE PTR _btStartDay$[ebp]
  00037	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+15], al
  0003a	66 8b 45 1c	 mov	 ax, WORD PTR _wEndYear$[ebp]
  0003e	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+16], ax
  00042	8a 45 20	 mov	 al, BYTE PTR _btEndMonth$[ebp]
  00045	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+18], al
  00048	8a 45 24	 mov	 al, BYTE PTR _btEndDay$[ebp]
  0004b	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+19], al
  0004e	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00051	6a 14		 push	 20			; 00000014H
  00053	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00054	c7 45 e8 c1 14
	80 09		 mov	 DWORD PTR _pMsg$[ebp], 159388865 ; 098014c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4154 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0005b	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 4155 : }

  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?GS_GDReqCastleDateChange@@YAXHHGEEGEE@Z ENDP		; GS_GDReqCastleDateChange
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FDROP_LOG_DEBUG@@YAXXZ
text$yd	SEGMENT
??__FDROP_LOG_DEBUG@@YAXXZ PROC				; `dynamic atexit destructor for 'DROP_LOG_DEBUG'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?DROP_LOG_DEBUG@@3VCLogToFile@@A ; DROP_LOG_DEBUG
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__FDROP_LOG_DEBUG@@YAXXZ ENDP				; `dynamic atexit destructor for 'DROP_LOG_DEBUG''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ??__EDROP_LOG_DEBUG@@YAXXZ
text$di	SEGMENT
??__EDROP_LOG_DEBUG@@YAXXZ PROC				; `dynamic initializer for 'DROP_LOG_DEBUG'', COMDAT

; 67   : CLogToFile DROP_LOG_DEBUG(LOG_NAME_DROP, LOG_PATH_DROP, TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OHHLBHJC@?4?2Log?2Drop?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_04DJCMGLJH@Drop?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?DROP_LOG_DEBUG@@3VCLogToFile@@A ; DROP_LOG_DEBUG
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__FDROP_LOG_DEBUG@@YAXXZ ; `dynamic atexit destructor for 'DROP_LOG_DEBUG''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__EDROP_LOG_DEBUG@@YAXXZ ENDP				; `dynamic initializer for 'DROP_LOG_DEBUG''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tnotice.h
;	COMDAT ?_ARGB@@YAKEEEE@Z
_TEXT	SEGMENT
_a$ = 8							; size = 1
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
?_ARGB@@YAKEEEE@Z PROC					; _ARGB, COMDAT

; 9    : __inline DWORD _ARGB(BYTE a, BYTE r, BYTE g, BYTE b){ return a*16777216 + b*65536 + g*256 + r;}; // in tnotice.h : line 8

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _a$[ebp]
  00007	0f b6 4d 14	 movzx	 ecx, BYTE PTR _b$[ebp]
  0000b	c1 e0 08	 shl	 eax, 8
  0000e	03 c1		 add	 eax, ecx
  00010	0f b6 4d 10	 movzx	 ecx, BYTE PTR _g$[ebp]
  00014	c1 e0 08	 shl	 eax, 8
  00017	03 c1		 add	 eax, ecx
  00019	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _r$[ebp]
  0001d	c1 e0 08	 shl	 eax, 8
  00020	03 c1		 add	 eax, ecx
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_ARGB@@YAKEEEE@Z ENDP					; _ARGB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiegesync.h
;	COMDAT ?GetTributeMoney@CCastleSiegeSync@@QAEHXZ
_TEXT	SEGMENT
?GetTributeMoney@CCastleSiegeSync@@QAEHXZ PROC		; CCastleSiegeSync::GetTributeMoney, COMDAT
; _this$ = ecx

; 35   : 	int GetTributeMoney(){return this->m_lCastleTributeMoney;};	// line : 77

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	c3		 ret	 0
?GetTributeMoney@CCastleSiegeSync@@QAEHXZ ENDP		; CCastleSiegeSync::GetTributeMoney
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiegesync.h
;	COMDAT ?SetTaxHuntZone@CCastleSiegeSync@@QAEXH@Z
_TEXT	SEGMENT
_iTaxRate$ = 8						; size = 4
?SetTaxHuntZone@CCastleSiegeSync@@QAEXH@Z PROC		; CCastleSiegeSync::SetTaxHuntZone, COMDAT
; _this$ = ecx

; 33   : 	void SetTaxHuntZone(int iTaxRate){this->m_iCurTaxHuntZone = iTaxRate;};	// line : 65

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _iTaxRate$[ebp]
  00006	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetTaxHuntZone@CCastleSiegeSync@@QAEXH@Z ENDP		; CCastleSiegeSync::SetTaxHuntZone
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiegesync.h
;	COMDAT ?SetTaxRateStore@CCastleSiegeSync@@QAEXH@Z
_TEXT	SEGMENT
_iTaxRate$ = 8						; size = 4
?SetTaxRateStore@CCastleSiegeSync@@QAEXH@Z PROC		; CCastleSiegeSync::SetTaxRateStore, COMDAT
; _this$ = ecx

; 32   : 	void SetTaxRateStore(int iTaxRate){this->m_iCurTaxRateStore = iTaxRate;};	// line : 62

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _iTaxRate$[ebp]
  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetTaxRateStore@CCastleSiegeSync@@QAEXH@Z ENDP		; CCastleSiegeSync::SetTaxRateStore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiegesync.h
;	COMDAT ?SetTaxRateChaos@CCastleSiegeSync@@QAEXH@Z
_TEXT	SEGMENT
_iTaxRate$ = 8						; size = 4
?SetTaxRateChaos@CCastleSiegeSync@@QAEXH@Z PROC		; CCastleSiegeSync::SetTaxRateChaos, COMDAT
; _this$ = ecx

; 31   : 	void SetTaxRateChaos(int iTaxRate){this->m_iCurTaxRateChaos = iTaxRate;};	// line : 59

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _iTaxRate$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetTaxRateChaos@CCastleSiegeSync@@QAEXH@Z ENDP		; CCastleSiegeSync::SetTaxRateChaos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiegesync.h
;	COMDAT ?SetCastleState@CCastleSiegeSync@@QAEXH@Z
_TEXT	SEGMENT
_iCastleState$ = 8					; size = 4
?SetCastleState@CCastleSiegeSync@@QAEXH@Z PROC		; CCastleSiegeSync::SetCastleState, COMDAT
; _this$ = ecx

; 30   : 	void SetCastleState(int iCastleState){this->m_iCurCastleState = iCastleState;};	// line : 56

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _iCastleState$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetCastleState@CCastleSiegeSync@@QAEXH@Z ENDP		; CCastleSiegeSync::SetCastleState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
;	COMDAT ?GetMapSvrGroup@CMapServerManager@@QAEHXZ
_TEXT	SEGMENT
?GetMapSvrGroup@CMapServerManager@@QAEHXZ PROC		; CMapServerManager::GetMapSvrGroup, COMDAT
; _this$ = ecx

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  00000	8b 81 f8 6a 01
	00		 mov	 eax, DWORD PTR [ecx+92920]
  00006	85 c0		 test	 eax, eax
  00008	74 05		 je	 SHORT $LN2@GetMapSvrG

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  0000a	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]

; 60   : 	}

  0000e	c3		 ret	 0
$LN2@GetMapSvrG:

; 58   : 		}
; 59   : 		return -1;

  0000f	83 c8 ff	 or	 eax, -1

; 60   : 	}

  00012	c3		 ret	 0
?GetMapSvrGroup@CMapServerManager@@QAEHXZ ENDP		; CMapServerManager::GetMapSvrGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?answerDbInfo@@YAXPAUpacketDbAnswerInfo@@@Z
_TEXT	SEGMENT
_inPacket$ = 8						; size = 4
?answerDbInfo@@YAXPAUpacketDbAnswerInfo@@@Z PROC	; answerDbInfo, COMDAT

; 6393 : void answerDbInfo(packetDbAnswerInfo* inPacket) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6394 : 	MsgOutput(inPacket->UserIndex, "%s | %s", 

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _inPacket$[ebp]
  00006	8d 41 24	 lea	 eax, DWORD PTR [ecx+36]
  00009	50		 push	 eax
  0000a	8d 41 06	 lea	 eax, DWORD PTR [ecx+6]
  0000d	50		 push	 eax
  0000e	0f bf 41 04	 movsx	 eax, WORD PTR [ecx+4]
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_07FHODIPOK@?$CFs?5?$HM?5?$CFs?$AA@
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0001d	83 c4 10	 add	 esp, 16			; 00000010H

; 6395 : 		inPacket->SqlUser, inPacket->SqlPassword);
; 6396 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?answerDbInfo@@YAXPAUpacketDbAnswerInfo@@@Z ENDP	; answerDbInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?requestDbUpdateCredits@@YAXPAUOBJECTSTRUCT@@FF@Z
_TEXT	SEGMENT
_newPacket$ = -24					; size = 19
__$ArrayPad$ = -4					; size = 4
_lpUser$ = 8						; size = 4
_Credits$ = 12						; size = 2
_ItemPrice$ = 16					; size = 2
?requestDbUpdateCredits@@YAXPAUOBJECTSTRUCT@@FF@Z PROC	; requestDbUpdateCredits, COMDAT

; 6384 : void requestDbUpdateCredits(LPOBJ lpUser, short Credits, short ItemPrice) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6385 : 	packetDbUpdateCredits newPacket = { 0 };
; 6386 : 	newPacket.h.set((LPBYTE)&newPacket, 0xFE, 1, sizeof(packetDbUpdateCredits));
; 6387 : 	newPacket.Credits = Credits;

  00010	66 8b 45 0c	 mov	 ax, WORD PTR _Credits$[ebp]
  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _lpUser$[ebp]
  0001a	0f 11 45 e9	 movups	 XMMWORD PTR _newPacket$[ebp+1], xmm0
  0001e	66 89 45 f7	 mov	 WORD PTR _newPacket$[ebp+15], ax

; 6388 : 	newPacket.ItemPrice = ItemPrice;

  00022	66 8b 45 10	 mov	 ax, WORD PTR _ItemPrice$[ebp]
  00026	66 c7 45 f9 00
	00		 mov	 WORD PTR _newPacket$[ebp+17], 0
  0002c	66 89 45 f9	 mov	 WORD PTR _newPacket$[ebp+17], ax

; 6389 : 	strcpy_s(newPacket.AccountName, sizeof(newPacket.AccountName), lpUser->AccountID);

  00030	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00033	50		 push	 eax
  00034	8d 45 ec	 lea	 eax, DWORD PTR _newPacket$[ebp+4]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00037	c7 45 e8 c1 13
	fe 01		 mov	 DWORD PTR _newPacket$[ebp], 33428417 ; 01fe13c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 6389 : 	strcpy_s(newPacket.AccountName, sizeof(newPacket.AccountName), lpUser->AccountID);

  0003e	6a 0b		 push	 11			; 0000000bH
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _strcpy_s

; 6390 : 	cDBSMng.Send((char*)&newPacket, newPacket.h.size);

  00046	0f b6 45 e9	 movzx	 eax, BYTE PTR _newPacket$[ebp+1]
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00052	50		 push	 eax
  00053	8d 45 e8	 lea	 eax, DWORD PTR _newPacket$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 6391 : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?requestDbUpdateCredits@@YAXPAUOBJECTSTRUCT@@FF@Z ENDP	; requestDbUpdateCredits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGBroadCastGlobalMessage@@YAXPAE@Z
_TEXT	SEGMENT
_lpData$ = 8						; size = 4
?DGBroadCastGlobalMessage@@YAXPAE@Z PROC		; DGBroadCastGlobalMessage, COMDAT

; 6378 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6379 : 	LPMSG_SYS_BROADCAST	lpMsg	= (LPMSG_SYS_BROADCAST)lpData;
; 6380 : 	AllSendServerMsg(&lpMsg->szMessage[1]);

  00003	83 45 08 06	 add	 DWORD PTR _lpData$[ebp], 6

; 6381 : }

  00007	5d		 pop	 ebp

; 6379 : 	LPMSG_SYS_BROADCAST	lpMsg	= (LPMSG_SYS_BROADCAST)lpData;
; 6380 : 	AllSendServerMsg(&lpMsg->szMessage[1]);

  00008	e9 00 00 00 00	 jmp	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
?DGBroadCastGlobalMessage@@YAXPAE@Z ENDP		; DGBroadCastGlobalMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGDeleteTempUserInfo@@YAXPAUSDHP_DELETE_TEMPUSERINFO_RESULT@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?DGDeleteTempUserInfo@@YAXPAUSDHP_DELETE_TEMPUSERINFO_RESULT@@@Z PROC ; DGDeleteTempUserInfo, COMDAT

; 6368 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6369 : 	int iTempUserDataSlotIndex = cpDSPTempUserManager->CheckMatchCharacter(lpMsg->szName);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cpDSPTempUserManager@@3PAVCTemporaryUserManager@@A ; cpDSPTempUserManager
  0000c	83 c0 03	 add	 eax, 3
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?CheckMatchCharacter@CTemporaryUserManager@@QAEHPAD@Z ; CTemporaryUserManager::CheckMatchCharacter

; 6370 : 
; 6371 : 	if( iTempUserDataSlotIndex != -1 )

  00015	83 f8 ff	 cmp	 eax, -1
  00018	74 0c		 je	 SHORT $LN2@DGDeleteTe

; 6372 : 	{
; 6373 : 		cpDSPTempUserManager->DeleteUserInParty(iTempUserDataSlotIndex);

  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cpDSPTempUserManager@@3PAVCTemporaryUserManager@@A ; cpDSPTempUserManager
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?DeleteUserInParty@CTemporaryUserManager@@QAEXH@Z ; CTemporaryUserManager::DeleteUserInParty
$LN2@DGDeleteTe:

; 6374 : 	}
; 6375 : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?DGDeleteTempUserInfo@@YAXPAUSDHP_DELETE_TEMPUSERINFO_RESULT@@@Z ENDP ; DGDeleteTempUserInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGMuBotOptionRecv@@YAXPAUMUBOT_SETTINGS_SEND@@@Z
_TEXT	SEGMENT
_szName$ = -12						; size = 11
_lpMsg$ = 8						; size = 4
?DGMuBotOptionRecv@@YAXPAUMUBOT_SETTINGS_SEND@@@Z PROC	; DGMuBotOptionRecv, COMDAT

; 6347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 6348 : 	int aIndex = lpMsg->aIndex;

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 6349 : 	char szName[MAX_ACCOUNT_LEN+1];
; 6350 : 
; 6351 : 	if ( aIndex < 0 || aIndex >= OBJMAX )

  0000e	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00014	77 70		 ja	 SHORT $LN3@DGMuBotOpt

; 6352 : 	{
; 6353 : 		return;
; 6354 : 	}
; 6355 : 
; 6356 : 	memset(szName, 0, sizeof(szName));
; 6357 : 	memcpy(szName, lpMsg->szName, MAX_ACCOUNT_LEN);

  00016	66 8b 46 10	 mov	 ax, WORD PTR [esi+16]
  0001a	0f 57 c0	 xorps	 xmm0, xmm0

; 6358 : 
; 6359 : 	if ( strcmp(gObj[aIndex].Name, szName) != 0 )

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	69 d7 40 27 00
	00		 imul	 edx, edi, 10048
  00029	83 c1 5d	 add	 ecx, 93			; 0000005dH
  0002c	66 0f d6 45 f4	 movq	 QWORD PTR _szName$[ebp], xmm0
  00031	f3 0f 7e 46 08	 movq	 xmm0, QWORD PTR [esi+8]
  00036	66 c7 45 fc 00
	00		 mov	 WORD PTR _szName$[ebp+8], 0
  0003c	66 89 45 fc	 mov	 WORD PTR _szName$[ebp+8], ax
  00040	8d 45 f4	 lea	 eax, DWORD PTR _szName$[ebp]
  00043	c6 45 fe 00	 mov	 BYTE PTR _szName$[ebp+10], 0
  00047	03 ca		 add	 ecx, edx
  00049	66 0f d6 45 f4	 movq	 QWORD PTR _szName$[ebp], xmm0
  0004e	66 90		 npad	 2
$LL6@DGMuBotOpt:
  00050	8a 11		 mov	 dl, BYTE PTR [ecx]
  00052	3a 10		 cmp	 dl, BYTE PTR [eax]
  00054	75 1a		 jne	 SHORT $LN7@DGMuBotOpt
  00056	84 d2		 test	 dl, dl
  00058	74 12		 je	 SHORT $LN8@DGMuBotOpt
  0005a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0005d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00060	75 0e		 jne	 SHORT $LN7@DGMuBotOpt
  00062	83 c1 02	 add	 ecx, 2
  00065	83 c0 02	 add	 eax, 2
  00068	84 d2		 test	 dl, dl
  0006a	75 e4		 jne	 SHORT $LL6@DGMuBotOpt
$LN8@DGMuBotOpt:
  0006c	33 c0		 xor	 eax, eax
  0006e	eb 05		 jmp	 SHORT $LN9@DGMuBotOpt
$LN7@DGMuBotOpt:
  00070	1b c0		 sbb	 eax, eax
  00072	83 c8 01	 or	 eax, 1
$LN9@DGMuBotOpt:
  00075	85 c0		 test	 eax, eax
  00077	75 0d		 jne	 SHORT $LN3@DGMuBotOpt

; 6360 : 	{
; 6361 : 		return;
; 6362 : 	}
; 6363 : 
; 6364 : 	GCSendMuBotSettings(lpMsg->aIndex,lpMsg->btDATA);

  00079	8d 46 13	 lea	 eax, DWORD PTR [esi+19]
  0007c	50		 push	 eax
  0007d	57		 push	 edi
  0007e	e8 00 00 00 00	 call	 ?GCSendMuBotSettings@@YAXHPAE@Z ; GCSendMuBotSettings
  00083	83 c4 08	 add	 esp, 8
$LN3@DGMuBotOpt:
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi

; 6365 : }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?DGMuBotOptionRecv@@YAXPAUMUBOT_SETTINGS_SEND@@@Z ENDP	; DGMuBotOptionRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGMuBotSettingsSend@@YAXHPADPAE@Z
_TEXT	SEGMENT
_pMsg$ = -276						; size = 272
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_szName$ = 12						; size = 4
_lpSettings$ = 16					; size = 4
?DGMuBotSettingsSend@@YAXHPADPAE@Z PROC			; DGMuBotSettingsSend, COMDAT

; 6336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 10	 mov	 esi, DWORD PTR _lpSettings$[ebp]
  00017	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001d	57		 push	 edi
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR _szName$[ebp]
  00021	68 10 01 00 00	 push	 272			; 00000110H
  00026	6a 00		 push	 0
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _memset

; 6337 : 	MUBOT_SETTINGS_REQ_SAVE pMsg={0};
; 6338 : 	PHeadSetW((LPBYTE)&pMsg,0x61,sizeof(pMsg));

  0002e	68 10 01 00 00	 push	 272			; 00000110H
  00033	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00039	6a 61		 push	 97			; 00000061H
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 6339 : 
; 6340 : 	memcpy(pMsg.szName,szName,10);

  00041	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]

; 6341 : 	memcpy(pMsg.btDATA,lpSettings,sizeof(pMsg.btDATA));

  00045	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0004a	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  0004e	83 c4 18	 add	 esp, 24			; 00000018H
  00051	66 89 85 f8 fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+12], ax
  00058	8d bd fb fe ff
	ff		 lea	 edi, DWORD PTR _pMsg$[ebp+15]
  0005e	66 0f d6 85 f0
	fe ff ff	 movq	 QWORD PTR _pMsg$[ebp+4], xmm0

; 6342 : 
; 6343 : 	cDBSMng.Send((char*)&pMsg,sizeof(pMsg));

  00066	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006c	f3 a5		 rep movsd
  0006e	68 10 01 00 00	 push	 272			; 00000110H
  00073	50		 push	 eax
  00074	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00079	a4		 movsb
  0007a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 6344 : }

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00082	5f		 pop	 edi
  00083	33 cd		 xor	 ecx, ebp
  00085	5e		 pop	 esi
  00086	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
?DGMuBotSettingsSend@@YAXHPADPAE@Z ENDP			; DGMuBotSettingsSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDExpandInventorySend@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 27
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_count$ = 12						; size = 4
?GDExpandInventorySend@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; GDExpandInventorySend, COMDAT

; 6301 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 6302 : 	CSHOP_SET_EXPANDINVENTORY pMsg = {0};
; 6303 : 	PHeadSetB((LPBYTE)&pMsg,0xA3,sizeof(pMsg));

  00014	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 1b		 push	 27			; 0000001bH
  00019	0f 57 c0	 xorps	 xmm0, xmm0
  0001c	c6 45 e0 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00020	68 a3 00 00 00	 push	 163			; 000000a3H
  00025	50		 push	 eax
  00026	0f 11 45 e1	 movups	 XMMWORD PTR _pMsg$[ebp+1], xmm0
  0002a	66 c7 45 f9 00
	00		 mov	 WORD PTR _pMsg$[ebp+25], 0
  00030	66 0f d6 45 f1	 movq	 QWORD PTR _pMsg$[ebp+17], xmm0
  00035	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6304 : 
; 6305 : 	pMsg.btType = 2;
; 6306 : 	pMsg.btCount = count;

  0003a	8a 45 0c	 mov	 al, BYTE PTR _count$[ebp]
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6307 : 
; 6308 : 	memcpy(pMsg.szAccountID,lpObj->AccountID,10);

  00040	f3 0f 7e 46 52	 movq	 xmm0, QWORD PTR [esi+82]

; 6309 : 	memcpy(pMsg.szName,lpObj->Name,10);
; 6310 : 
; 6311 : 	cDBSMng.Send((char*)&pMsg,sizeof(pMsg));

  00045	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0004a	88 45 e4	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0004d	0f b7 46 5a	 movzx	 eax, WORD PTR [esi+90]
  00051	66 89 45 ed	 mov	 WORD PTR _pMsg$[ebp+13], ax
  00055	0f b7 46 65	 movzx	 eax, WORD PTR [esi+101]
  00059	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+24], ax
  0005d	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00060	66 0f d6 45 e5	 movq	 QWORD PTR _pMsg$[ebp+5], xmm0
  00065	f3 0f 7e 46 5d	 movq	 xmm0, QWORD PTR [esi+93]
  0006a	6a 1b		 push	 27			; 0000001bH
  0006c	50		 push	 eax
  0006d	c6 45 e3 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2
  00071	66 0f d6 45 f0	 movq	 QWORD PTR _pMsg$[ebp+16], xmm0
  00076	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 6312 : }

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007e	33 cd		 xor	 ecx, ebp
  00080	5e		 pop	 esi
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?GDExpandInventorySend@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; GDExpandInventorySend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDExpandWarehouseSend@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 27
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_count$ = 12						; size = 4
?GDExpandWarehouseSend@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; GDExpandWarehouseSend, COMDAT

; 6315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 6316 : 	CSHOP_SET_EXPANDINVENTORY pMsg = {0};
; 6317 : 	PHeadSetB((LPBYTE)&pMsg,0xA3,sizeof(pMsg));

  00014	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 1b		 push	 27			; 0000001bH
  00019	0f 57 c0	 xorps	 xmm0, xmm0
  0001c	c6 45 e0 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00020	68 a3 00 00 00	 push	 163			; 000000a3H
  00025	50		 push	 eax
  00026	0f 11 45 e1	 movups	 XMMWORD PTR _pMsg$[ebp+1], xmm0
  0002a	66 c7 45 f9 00
	00		 mov	 WORD PTR _pMsg$[ebp+25], 0
  00030	66 0f d6 45 f1	 movq	 QWORD PTR _pMsg$[ebp+17], xmm0
  00035	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6318 : 
; 6319 : 	pMsg.btType = 1;
; 6320 : 	pMsg.btCount = count;

  0003a	8a 45 0c	 mov	 al, BYTE PTR _count$[ebp]
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6321 : 
; 6322 : 	memcpy(pMsg.szAccountID,lpObj->AccountID,10);

  00040	f3 0f 7e 46 52	 movq	 xmm0, QWORD PTR [esi+82]

; 6323 : 	memcpy(pMsg.szName,lpObj->Name,10);
; 6324 : 
; 6325 : 	cDBSMng.Send((char*)&pMsg,sizeof(pMsg));

  00045	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0004a	88 45 e4	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0004d	0f b7 46 5a	 movzx	 eax, WORD PTR [esi+90]
  00051	66 89 45 ed	 mov	 WORD PTR _pMsg$[ebp+13], ax
  00055	0f b7 46 65	 movzx	 eax, WORD PTR [esi+101]
  00059	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+24], ax
  0005d	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00060	66 0f d6 45 e5	 movq	 QWORD PTR _pMsg$[ebp+5], xmm0
  00065	f3 0f 7e 46 5d	 movq	 xmm0, QWORD PTR [esi+93]
  0006a	6a 1b		 push	 27			; 0000001bH
  0006c	50		 push	 eax
  0006d	c6 45 e3 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1
  00071	66 0f d6 45 f0	 movq	 QWORD PTR _pMsg$[ebp+16], xmm0
  00076	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 6326 : }

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007e	33 cd		 xor	 ecx, ebp
  00080	5e		 pop	 esi
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?GDExpandWarehouseSend@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; GDExpandWarehouseSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGSetSummonerCreate@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?DGSetSummonerCreate@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; DGSetSummonerCreate, COMDAT

; 6281 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00013	0f 57 c0	 xorps	 xmm0, xmm0

; 6284 : 	memset(pMsg.szId,0,sizeof(pMsg.szId));

  00016	66 c7 45 f7 00
	00		 mov	 WORD PTR _pMsg$[ebp+11], 0
  0001c	66 0f d6 45 ef	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0

; 6286 : 	pMsg.Index = lpObj->m_Index;
; 6287 : 
; 6288 : 	cDBSMng.Send((char*)&pMsg,sizeof(pMsg));

  00021	6a 10		 push	 16			; 00000010H
  00023	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  00027	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  0002c	66 89 45 f7	 mov	 WORD PTR _pMsg$[ebp+11], ax
  00030	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00033	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00038	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+14], ax
  0003c	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003f	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  00040	66 c7 45 ec c1
	10		 mov	 WORD PTR _pMsg$[ebp], 4289 ; 000010c1H

; 87   : 		lpBuf[1] = size;
; 88   : 		lpBuf[2] = head;

  00046	c6 45 ee a2	 mov	 BYTE PTR _pMsg$[ebp+2], 162 ; 000000a2H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 6284 : 	memset(pMsg.szId,0,sizeof(pMsg.szId));

  0004a	c6 45 f9 00	 mov	 BYTE PTR _pMsg$[ebp+13], 0

; 6285 : 	memcpy(pMsg.szId,lpObj->AccountID,10);

  0004e	66 0f d6 45 ef	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0

; 6286 : 	pMsg.Index = lpObj->m_Index;
; 6287 : 
; 6288 : 	cDBSMng.Send((char*)&pMsg,sizeof(pMsg));

  00053	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 6289 : }

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	33 cd		 xor	 ecx, ebp
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?DGSetSummonerCreate@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; DGSetSummonerCreate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?JGPSummonerInfo@@YAXPAUPMSG_ANS_SUMMONER_CREATE@@@Z
_TEXT	SEGMENT
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGPSummonerInfo@@YAXPAUPMSG_ANS_SUMMONER_CREATE@@@Z PROC ; JGPSummonerInfo, COMDAT

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 525  : 	char szId[11];
; 526  : 	szId[10] = 0;

  00015	c6 45 fa 00	 mov	 BYTE PTR _szId$[ebp+10], 0

; 527  : 	memcpy(szId,lpMsg->szAccount,10);

  00019	66 8b 47 0b	 mov	 ax, WORD PTR [edi+11]

; 528  : 	int aIndex = lpMsg->Number;

  0001d	0f bf 77 0e	 movsx	 esi, WORD PTR [edi+14]
  00021	f3 0f 7e 47 03	 movq	 xmm0, QWORD PTR [edi+3]
  00026	66 89 45 f8	 mov	 WORD PTR _szId$[ebp+8], ax

; 529  : 
; 530  : 	if ( ::gObjIsAccontConnect(aIndex, szId) == FALSE )

  0002a	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0002d	50		 push	 eax
  0002e	56		 push	 esi
  0002f	66 0f d6 45 f0	 movq	 QWORD PTR _szId$[ebp], xmm0
  00034	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00039	83 c4 08	 add	 esp, 8

; 531  : 	{
; 532  : 		LogAddC(2, lMsg.Get(MSGGET(1, 165)), gObj[aIndex].AccountID, szId);

  0003c	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00042	85 c0		 test	 eax, eax
  00044	75 40		 jne	 SHORT $LN2@JGPSummone
  00046	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  00049	50		 push	 eax
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004f	83 c0 52	 add	 eax, 82			; 00000052H
  00052	03 c1		 add	 eax, ecx
  00054	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00059	50		 push	 eax
  0005a	68 a5 01 00 00	 push	 421			; 000001a5H
  0005f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00064	50		 push	 eax
  00065	6a 02		 push	 2
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 533  : 		CloseClient(aIndex);

  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00073	83 c4 14	 add	 esp, 20			; 00000014H
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi

; 545  : 	}
; 546  : }

  00078	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007b	33 cd		 xor	 ecx, ebp
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN2@JGPSummone:
  00086	c6 47 10 01	 mov	 BYTE PTR [edi+16], 1

; 534  : 
; 535  : 		return;
; 536  : 	}
; 537  : 
; 538  : #if (__CUSTOM__ == 1)
; 539  : 	lpMsg->Result = 1;
; 540  : #endif
; 541  : 
; 542  : 	if( lpMsg->Result == TRUE )
; 543  : 	{
; 544  : 		gObj[aIndex].m_iSummonerCreateFlag = TRUE;

  0008a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	c6 84 01 84 24
	00 00 01	 mov	 BYTE PTR [ecx+eax+9348], 1

; 545  : 	}
; 546  : }

  00099	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009c	33 cd		 xor	 ecx, ebp
  0009e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?JGPSummonerInfo@@YAXPAUPMSG_ANS_SUMMONER_CREATE@@@Z ENDP ; JGPSummonerInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGAnsCrywolfInfoSave@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?DGAnsCrywolfInfoSave@@YAXPAE@Z PROC			; DGAnsCrywolfInfoSave, COMDAT

; 6270 : 	CWP_ANS_CRYWOLFINFOSAVE * lpMsg = (CWP_ANS_CRYWOLFINFOSAVE *)lpRecv;
; 6271 : }

  00000	c3		 ret	 0
?DGAnsCrywolfInfoSave@@YAXPAE@Z ENDP			; DGAnsCrywolfInfoSave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDReqCrywolfInfoSave@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCrywolfState$ = 12					; size = 4
_iOccupationState$ = 16					; size = 4
?GDReqCrywolfInfoSave@@YAXHHH@Z PROC			; GDReqCrywolfInfoSave, COMDAT

; 6244 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6245 : 	if ( iMapSvrGroup <0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 2a		 js	 SHORT $LN1@GDReqCrywo

; 6246 : 		return;
; 6247 : 
; 6248 : 	CWP_REQ_CRYWOLFINFOSAVE pMsg;
; 6249 : 
; 6250 : 	pMsg.h.set((LPBYTE)&pMsg, 0xB2, sizeof(CWP_REQ_CRYWOLFINFOSAVE));
; 6251 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00017	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 6255 : 	cDBSMng.Send((PCHAR)&pMsg, pMsg.h.size);

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00020	8b 45 0c	 mov	 eax, DWORD PTR _iCrywolfState$[ebp]
  00023	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00026	8b 45 10	 mov	 eax, DWORD PTR _iOccupationState$[ebp]
  00029	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  0002c	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002f	6a 10		 push	 16			; 00000010H
  00031	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  00032	66 c7 45 ec c1
	10		 mov	 WORD PTR _pMsg$[ebp], 4289 ; 000010c1H

; 87   : 		lpBuf[1] = size;
; 88   : 		lpBuf[2] = head;

  00038	c6 45 ee b2	 mov	 BYTE PTR _pMsg$[ebp+2], 178 ; 000000b2H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 6255 : 	cDBSMng.Send((PCHAR)&pMsg, pMsg.h.size);

  0003c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GDReqCrywo:

; 6256 : }

  00041	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00044	33 cd		 xor	 ecx, ebp
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?GDReqCrywolfInfoSave@@YAXHHH@Z ENDP			; GDReqCrywolfInfoSave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGAnsCrywolfInfoLoad@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?DGAnsCrywolfInfoLoad@@YAXPAE@Z PROC			; DGAnsCrywolfInfoLoad, COMDAT

; 6203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6204 : 	CWP_ANS_CRYWOLFINFOLOAD * lpMsg = (CWP_ANS_CRYWOLFINFOLOAD *)lpRecv;
; 6205 : 
; 6206 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 3c		 je	 SHORT $LN6@DGAnsCrywo

; 6207 : 		return;
; 6208 : 
; 6209 : 	int result;
; 6210 : 
; 6211 : 	if(TRUE && lpMsg->iOccupationState >= 0 && lpMsg->iOccupationState <= 2)

  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	85 c9		 test	 ecx, ecx
  0000f	78 0c		 js	 SHORT $LN3@DGAnsCrywo
  00011	83 f9 02	 cmp	 ecx, 2
  00014	7f 07		 jg	 SHORT $LN3@DGAnsCrywo

; 6212 : 	{
; 6213 : 		result = TRUE;

  00016	ba 01 00 00 00	 mov	 edx, 1

; 6214 : 	}
; 6215 : 	else

  0001b	eb 02		 jmp	 SHORT $LN4@DGAnsCrywo
$LN3@DGAnsCrywo:

; 6216 : 	{
; 6217 : 		result = FALSE;

  0001d	33 d2		 xor	 edx, edx
$LN4@DGAnsCrywo:

; 6218 : 	}
; 6219 : 
; 6220 : 	lpMsg->btResult = result;

  0001f	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 6221 : 
; 6222 : 	if( (result&0xFF) != FALSE )

  00022	84 d2		 test	 dl, dl
  00024	74 10		 je	 SHORT $LN5@DGAnsCrywo

; 6223 : 	{
; 6224 : 		g_Crywolf.ApplyCrywolfDBInfo(lpMsg->iCrywolfState,lpMsg->iOccupationState);

  00026	51		 push	 ecx
  00027	ff 70 04	 push	 DWORD PTR [eax+4]
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Crywolf@@3VCCrywolf@@A ; g_Crywolf
  0002f	e8 00 00 00 00	 call	 ?ApplyCrywolfDBInfo@CCrywolf@@QAEXHH@Z ; CCrywolf::ApplyCrywolfDBInfo

; 6229 : 	}
; 6230 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN5@DGAnsCrywo:

; 6225 : 	}
; 6226 : 	else
; 6227 : 	{
; 6228 : 		LogAddC(2,"[ Crywolf ] Incorrect DB OccupationState!!!");

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OEMLKOCG@?$FL?5Crywolf?5?$FN?5Incorrect?5DB?5Occupat@
  0003b	6a 02		 push	 2
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00043	83 c4 08	 add	 esp, 8
$LN6@DGAnsCrywo:

; 6229 : 	}
; 6230 : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?DGAnsCrywolfInfoLoad@@YAXPAE@Z ENDP			; DGAnsCrywolfInfoLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDReqCrywolfInfoLoad@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GDReqCrywolfInfoLoad@@YAXH@Z PROC			; GDReqCrywolfInfoLoad, COMDAT

; 6179 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6180 : 	if ( iMapSvrGroup <0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 1e		 js	 SHORT $LN1@GDReqCrywo

; 6181 : 		return;
; 6182 : 
; 6183 : 	CWP_REQ_CRYWOLFINFOLOAD pMsg;
; 6184 : 
; 6185 : 	pMsg.h.set((LPBYTE)&pMsg, 0xB1, sizeof(CWP_REQ_CRYWOLFINFOLOAD));
; 6186 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0000d	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 6188 : 	cDBSMng.Send((PCHAR)&pMsg, pMsg.h.size);

  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00016	6a 06		 push	 6
  00018	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  0001b	66 c7 45 f8 c1
	06		 mov	 WORD PTR _pMsg$[ebp], 1729 ; 000006c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 6188 : 	cDBSMng.Send((PCHAR)&pMsg, pMsg.h.size);

  00021	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 88   : 		lpBuf[2] = head;

  00022	c6 45 fa b1	 mov	 BYTE PTR _pMsg$[ebp+2], 177 ; 000000b1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 6188 : 	cDBSMng.Send((PCHAR)&pMsg, pMsg.h.size);

  00026	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GDReqCrywo:

; 6189 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GDReqCrywolfInfoLoad@@YAXH@Z ENDP			; GDReqCrywolfInfoLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGAnsCrywolfSync@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?DGAnsCrywolfSync@@YAXPAE@Z PROC			; DGAnsCrywolfSync, COMDAT

; 6153 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 6154 : 	CWP_ANS_CRYWOLFSYNC * lpMsg = (CWP_ANS_CRYWOLFSYNC *)lpRecv;
; 6155 : 
; 6156 : 	if ( lpMsg == NULL )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpRecv$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 5b		 je	 SHORT $LN3@DGAnsCrywo

; 6157 : 		return;
; 6158 : 
; 6159 : 	int iOldOccupationState = g_CrywolfSync.GetOccupationState();

  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  00010	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState

; 6160 : 	g_CrywolfSync.SetCrywolfState(lpMsg->iCrywolfState);

  00015	ff 76 04	 push	 DWORD PTR [esi+4]
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0001d	e8 00 00 00 00	 call	 ?SetCrywolfState@CCrywolfSync@@QAEXH@Z ; CCrywolfSync::SetCrywolfState

; 6161 : 	g_CrywolfSync.SetOccupationState(lpMsg->iOccupationState);

  00022	ff 76 08	 push	 DWORD PTR [esi+8]
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0002a	e8 00 00 00 00	 call	 ?SetOccupationState@CCrywolfSync@@QAEXH@Z ; CCrywolfSync::SetOccupationState

; 6162 : 
; 6163 : 	if ( GetTickCount() > (dwCrywolfSyncLogTickCount+ 60000) )

  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwCrywolfSyncLogTickCount@@3KA ; dwCrywolfSyncLogTickCount
  0003b	81 c1 60 ea 00
	00		 add	 ecx, 60000		; 0000ea60H
  00041	3b c1		 cmp	 eax, ecx
  00043	76 21		 jbe	 SHORT $LN3@DGAnsCrywo

; 6164 : 	{
; 6165 : 		LogAddC(4, "[ CRYWOLF ] SYNC Occupation: %d, State: %d", lpMsg->iOccupationState, lpMsg->iCrywolfState);

  00045	ff 76 04	 push	 DWORD PTR [esi+4]
  00048	ff 76 08	 push	 DWORD PTR [esi+8]
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@BPJMLKLO@?$FL?5CRYWOLF?5?$FN?5SYNC?5Occupation?3?5?$CFd?0@
  00050	6a 04		 push	 4
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00058	83 c4 10	 add	 esp, 16			; 00000010H

; 6166 : 		dwCrywolfSyncLogTickCount = GetTickCount();

  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00061	a3 00 00 00 00	 mov	 DWORD PTR ?dwCrywolfSyncLogTickCount@@3KA, eax ; dwCrywolfSyncLogTickCount
$LN3@DGAnsCrywo:
  00066	5e		 pop	 esi

; 6167 : 	}
; 6168 : }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?DGAnsCrywolfSync@@YAXPAE@Z ENDP			; DGAnsCrywolfSync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDReqCrywolfSync@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCrywolfState$ = 12					; size = 4
_iOccupationState$ = 16					; size = 4
?GDReqCrywolfSync@@YAXHHH@Z PROC			; GDReqCrywolfSync, COMDAT

; 6122 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6123 : 	if ( iMapSvrGroup <0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 2a		 js	 SHORT $LN1@GDReqCrywo

; 6124 : 		return;
; 6125 : 
; 6126 : 	CWP_REQ_CRYWOLFSYNC pMsg;
; 6127 : 
; 6128 : 	pMsg.h.set((LPBYTE)&pMsg, 0xB0, sizeof(CWP_REQ_CRYWOLFSYNC));
; 6129 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00017	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 6133 : 	cDBSMng.Send((PCHAR)&pMsg, pMsg.h.size);

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00020	8b 45 0c	 mov	 eax, DWORD PTR _iCrywolfState$[ebp]
  00023	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00026	8b 45 10	 mov	 eax, DWORD PTR _iOccupationState$[ebp]
  00029	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  0002c	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002f	6a 10		 push	 16			; 00000010H
  00031	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  00032	66 c7 45 ec c1
	10		 mov	 WORD PTR _pMsg$[ebp], 4289 ; 000010c1H

; 87   : 		lpBuf[1] = size;
; 88   : 		lpBuf[2] = head;

  00038	c6 45 ee b0	 mov	 BYTE PTR _pMsg$[ebp+2], 176 ; 000000b0H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 6133 : 	cDBSMng.Send((PCHAR)&pMsg, pMsg.h.size);

  0003c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GDReqCrywo:

; 6134 : }

  00041	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00044	33 cd		 xor	 ecx, ebp
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?GDReqCrywolfSync@@YAXHHH@Z ENDP			; GDReqCrywolfSync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleNpcUpdate@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleNpcUpdate@@YAXPAE@Z PROC			; GS_DGAnsCastleNpcUpdate, COMDAT

; 6093 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6094 : #if (GS_CASTLE == 1)
; 6095 : 	CSP_ANS_NPCUPDATEDATA * lpMsg = (CSP_ANS_NPCUPDATEDATA*)lpRecv;
; 6096 : 
; 6097 : 	if(lpMsg == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 4c		 je	 SHORT $LN1@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN6@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00013	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00017	eb 03		 jmp	 SHORT $LN5@GS_DGAnsCa
$LN6@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  00019	83 ca ff	 or	 edx, -1
$LN5@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 6100 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001c	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00020	3b c2		 cmp	 eax, edx
  00022	74 12		 je	 SHORT $LN3@GS_DGAnsCa

; 6101 : 	{
; 6102 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x89] GS_DGAnsCastleNpcUpdate() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0HH@KKMGHAAE@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x89@
  00029	6a 02		 push	 2
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 6103 : 		return;
; 6104 : 	}
; 6105 : 
; 6106 : 	LogAddTD("[CastleSiege] [0x89] GS_DGAnsCastleNpcUpdate() - Npc Data Update Result : '%s'",

  00031	83 c4 08	 add	 esp, 8

; 6107 : 		(lpMsg->iResult != 0) ? "SUCCEED" : "FAIL" );
; 6108 : #endif
; 6109 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@GS_DGAnsCa:

; 6103 : 		return;
; 6104 : 	}
; 6105 : 
; 6106 : 	LogAddTD("[CastleSiege] [0x89] GS_DGAnsCastleNpcUpdate() - Npc Data Update Result : '%s'",

  00036	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0003a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04OOEBCMBF@FAIL?$AA@
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07OIIICFNN@SUCCEED?$AA@
  00044	0f 44 c2	 cmove	 eax, edx
  00047	50		 push	 eax
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@HIMGAPIB@?$FLCastleSiege?$FN?5?$FL0x89?$FN?5GS_DGAnsCas@
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00053	83 c4 08	 add	 esp, 8
$LN1@GS_DGAnsCa:

; 6107 : 		(lpMsg->iResult != 0) ? "SUCCEED" : "FAIL" );
; 6108 : #endif
; 6109 : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?GS_DGAnsCastleNpcUpdate@@YAXPAE@Z ENDP			; GS_DGAnsCastleNpcUpdate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCsLoadTotalGuildInfo@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCsLoadTotalGuildInfo@@YAXPAE@Z PROC		; GS_DGAnsCsLoadTotalGuildInfo, COMDAT

; 6064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6065 : #if (GS_CASTLE == 1)
; 6066 : 	CSP_ANS_CSLOADTOTALGUILDINFO * lpMsg = (CSP_ANS_CSLOADTOTALGUILDINFO*)lpRecv;
; 6067 : 	CSP_CSLOADTOTALGUILDINFO * lpMsgBody = (CSP_CSLOADTOTALGUILDINFO*)&lpRecv[sizeof(CSP_ANS_CSLOADTOTALGUILDINFO)];

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	56		 push	 esi
  00007	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]

; 6068 : 
; 6069 : 	if(lpMsg == NULL)

  0000a	85 c9		 test	 ecx, ecx
  0000c	74 41		 je	 SHORT $LN4@GS_DGAnsCs
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000e	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00013	85 c0		 test	 eax, eax
  00015	74 06		 je	 SHORT $LN7@GS_DGAnsCs

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00017	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  0001b	eb 03		 jmp	 SHORT $LN6@GS_DGAnsCs
$LN7@GS_DGAnsCs:

; 58   : 		}
; 59   : 		return -1;

  0001d	83 ca ff	 or	 edx, -1
$LN6@GS_DGAnsCs:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 6072 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  00020	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00024	3b c2		 cmp	 eax, edx
  00026	74 13		 je	 SHORT $LN3@GS_DGAnsCs

; 6073 : 	{
; 6074 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x88] GS_DGAnsCsLoadTotalGuildInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0HM@MGDLGKIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x88@
  0002d	6a 02		 push	 2
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00035	83 c4 08	 add	 esp, 8
  00038	5e		 pop	 esi

; 6081 : 	}
; 6082 : #endif
; 6083 : }

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN3@GS_DGAnsCs:

; 6075 : 		return;
; 6076 : 	}
; 6077 : 
; 6078 : 	if(lpMsg->iResult == 1)

  0003b	83 79 04 01	 cmp	 DWORD PTR [ecx+4], 1
  0003f	75 0e		 jne	 SHORT $LN4@GS_DGAnsCs

; 6079 : 	{
; 6080 : 		g_CastleSiege.SetCsTotalGuildInfo(lpMsgBody,lpMsg->iCount);

  00041	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ?SetCsTotalGuildInfo@CCastleSiege@@QAEXPAUCSP_CSLOADTOTALGUILDINFO@@H@Z ; CCastleSiege::SetCsTotalGuildInfo
$LN4@GS_DGAnsCs:
  0004f	5e		 pop	 esi

; 6081 : 	}
; 6082 : #endif
; 6083 : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?GS_DGAnsCsLoadTotalGuildInfo@@YAXPAE@Z ENDP		; GS_DGAnsCsLoadTotalGuildInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCsSaveTotalGuildInfo@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCsSaveTotalGuildInfo@@YAXPAE@Z PROC		; GS_DGAnsCsSaveTotalGuildInfo, COMDAT

; 6031 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6032 : #if (GS_CASTLE == 1)
; 6033 : 	CSP_ANS_CSSAVETOTALGUILDINFO * lpMsg = (CSP_ANS_CSSAVETOTALGUILDINFO*)lpRecv;
; 6034 : 
; 6035 : 	if(lpMsg == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 47		 je	 SHORT $LN5@GS_DGAnsCs
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN8@GS_DGAnsCs

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00013	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00017	eb 03		 jmp	 SHORT $LN7@GS_DGAnsCs
$LN8@GS_DGAnsCs:

; 58   : 		}
; 59   : 		return -1;

  00019	83 ca ff	 or	 edx, -1
$LN7@GS_DGAnsCs:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 6038 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001c	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00020	3b c2		 cmp	 eax, edx
  00022	74 12		 je	 SHORT $LN3@GS_DGAnsCs

; 6039 : 	{
; 6040 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x87] GS_DGAnsCsSaveTotalGuildInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0HM@DAOCJLIP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x87@
  00029	6a 02		 push	 2
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00031	83 c4 08	 add	 esp, 8

; 6051 : 	}
; 6052 : #endif
; 6053 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@GS_DGAnsCs:

; 6041 : 		return;
; 6042 : 	}
; 6043 : 
; 6044 : 	if(lpMsg->iResult == 1)

  00036	83 79 04 01	 cmp	 DWORD PTR [ecx+4], 1

; 6045 : 	{
; 6046 : 		g_CastleSiege.SetIsSiegeGuildList(TRUE);

  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0003f	75 09		 jne	 SHORT $LN4@GS_DGAnsCs
  00041	6a 01		 push	 1

; 6047 : 	}
; 6048 : 	else
; 6049 : 	{
; 6050 : 		g_CastleSiege.SetIsSiegeGuildList(FALSE);

  00043	e8 00 00 00 00	 call	 ?SetIsSiegeGuildList@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetIsSiegeGuildList

; 6051 : 	}
; 6052 : #endif
; 6053 : }

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN4@GS_DGAnsCs:

; 6047 : 	}
; 6048 : 	else
; 6049 : 	{
; 6050 : 		g_CastleSiege.SetIsSiegeGuildList(FALSE);

  0004a	6a 00		 push	 0
  0004c	e8 00 00 00 00	 call	 ?SetIsSiegeGuildList@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetIsSiegeGuildList
$LN5@GS_DGAnsCs:

; 6051 : 	}
; 6052 : #endif
; 6053 : }

  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?GS_DGAnsCsSaveTotalGuildInfo@@YAXPAE@Z ENDP		; GS_DGAnsCsSaveTotalGuildInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCsGulidUnionInfo@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCsGulidUnionInfo@@YAXPAE@Z PROC		; GS_DGAnsCsGulidUnionInfo, COMDAT

; 6002 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6003 : #if (GS_CASTLE == 1)
; 6004 : 	CSP_ANS_CSGUILDUNIONINFO * lpMsg = (CSP_ANS_CSGUILDUNIONINFO*)lpRecv;
; 6005 : 	CSP_CSGUILDUNIONINFO * lpMsgBody = (CSP_CSGUILDUNIONINFO*)&lpRecv[sizeof(CSP_ANS_CSGUILDUNIONINFO)];

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	56		 push	 esi
  00007	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]

; 6006 : 
; 6007 : 	if(lpMsg == NULL)

  0000a	85 c9		 test	 ecx, ecx
  0000c	74 41		 je	 SHORT $LN4@GS_DGAnsCs
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000e	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00013	85 c0		 test	 eax, eax
  00015	74 06		 je	 SHORT $LN7@GS_DGAnsCs

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00017	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  0001b	eb 03		 jmp	 SHORT $LN6@GS_DGAnsCs
$LN7@GS_DGAnsCs:

; 58   : 		}
; 59   : 		return -1;

  0001d	83 ca ff	 or	 edx, -1
$LN6@GS_DGAnsCs:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 6010 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  00020	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00024	3b c2		 cmp	 eax, edx
  00026	74 13		 je	 SHORT $LN3@GS_DGAnsCs

; 6011 : 	{
; 6012 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x86] GS_DGAnsCsGulidUnionInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0HI@LIMFILFK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x86@
  0002d	6a 02		 push	 2
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00035	83 c4 08	 add	 esp, 8
  00038	5e		 pop	 esi

; 6019 : 	}
; 6020 : #endif
; 6021 : }

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN3@GS_DGAnsCs:

; 6013 : 		return;
; 6014 : 	}
; 6015 : 
; 6016 : 	if(lpMsg->iResult == 1)

  0003b	83 79 04 01	 cmp	 DWORD PTR [ecx+4], 1
  0003f	75 0e		 jne	 SHORT $LN4@GS_DGAnsCs

; 6017 : 	{
; 6018 : 		g_CastleSiege.MakeCsTotalGuildInfo(lpMsgBody,lpMsg->iCount);

  00041	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ?MakeCsTotalGuildInfo@CCastleSiege@@QAEXPAUCSP_CSGUILDUNIONINFO@@H@Z ; CCastleSiege::MakeCsTotalGuildInfo
$LN4@GS_DGAnsCs:
  0004f	5e		 pop	 esi

; 6019 : 	}
; 6020 : #endif
; 6021 : }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?GS_DGAnsCsGulidUnionInfo@@YAXPAE@Z ENDP		; GS_DGAnsCsGulidUnionInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCalcREgGuildList@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCalcREgGuildList@@YAXPAE@Z PROC		; GS_DGAnsCalcREgGuildList, COMDAT

; 5966 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5967 : #if (GS_CASTLE == 1)
; 5968 : 	CSP_ANS_CALCREGGUILDLIST * lpMsg = (CSP_ANS_CALCREGGUILDLIST*)lpRecv;
; 5969 : 	CSP_CALCREGGUILDLIST * lpMsgBody = (CSP_CALCREGGUILDLIST*)&lpRecv[sizeof(CSP_ANS_CALCREGGUILDLIST)];

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	56		 push	 esi
  00007	8d 71 10	 lea	 esi, DWORD PTR [ecx+16]

; 5970 : 
; 5971 : 	if(lpMsg == NULL)

  0000a	85 c9		 test	 ecx, ecx
  0000c	74 57		 je	 SHORT $LN5@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000e	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00013	85 c0		 test	 eax, eax
  00015	74 06		 je	 SHORT $LN8@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00017	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  0001b	eb 03		 jmp	 SHORT $LN7@GS_DGAnsCa
$LN8@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  0001d	83 ca ff	 or	 edx, -1
$LN7@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5974 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  00020	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00024	3b c2		 cmp	 eax, edx
  00026	74 13		 je	 SHORT $LN3@GS_DGAnsCa

; 5975 : 	{
; 5976 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x85] GS_DGAnsCalcREgGuildList() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0HI@DCOFLPNN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@
  0002d	6a 02		 push	 2
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00035	83 c4 08	 add	 esp, 8
  00038	5e		 pop	 esi

; 5987 : 			lpMsg->iResult);
; 5988 : 	}
; 5989 : 
; 5990 : #endif
; 5991 : }

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN3@GS_DGAnsCa:

; 5977 : 		return;
; 5978 : 	}
; 5979 : 
; 5980 : 	if(lpMsg->iResult == 1)

  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003e	83 f8 01	 cmp	 eax, 1
  00041	75 11		 jne	 SHORT $LN4@GS_DGAnsCa

; 5981 : 	{
; 5982 : 		g_CastleSiege.SetCalcRegGuildList(lpMsgBody,lpMsg->iCount);

  00043	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?SetCalcRegGuildList@CCastleSiege@@QAEXPAUCSP_CALCREGGUILDLIST@@H@Z ; CCastleSiege::SetCalcRegGuildList
  00051	5e		 pop	 esi

; 5987 : 			lpMsg->iResult);
; 5988 : 	}
; 5989 : 
; 5990 : #endif
; 5991 : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN4@GS_DGAnsCa:

; 5983 : 	}
; 5984 : 	else
; 5985 : 	{
; 5986 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x85] GS_DGAnsCalcREgGuildList() - lpMsg->iResult != 1 (%d)",

  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@CEGBKGAK@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x85@
  0005a	6a 02		 push	 2
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@GS_DGAnsCa:
  00065	5e		 pop	 esi

; 5987 : 			lpMsg->iResult);
; 5988 : 	}
; 5989 : 
; 5990 : #endif
; 5991 : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?GS_DGAnsCalcREgGuildList@@YAXPAE@Z ENDP		; GS_DGAnsCalcREgGuildList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsFirstCreateNPC@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsFirstCreateNPC@@YAXPAE@Z PROC			; GS_DGAnsFirstCreateNPC, COMDAT

; 5933 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5934 : #if (GS_CASTLE == 1)
; 5935 : 	CSP_ANS_NPCSAVEDATA * lpMsg = (CSP_ANS_NPCSAVEDATA*)lpRecv;
; 5936 : 
; 5937 : 	if(lpMsg == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 56		 je	 SHORT $LN5@GS_DGAnsFi
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN8@GS_DGAnsFi

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00013	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00017	eb 03		 jmp	 SHORT $LN7@GS_DGAnsFi
$LN8@GS_DGAnsFi:

; 58   : 		}
; 59   : 		return -1;

  00019	83 ca ff	 or	 edx, -1
$LN7@GS_DGAnsFi:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5940 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001c	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00020	3b c2		 cmp	 eax, edx
  00022	74 12		 je	 SHORT $LN3@GS_DGAnsFi

; 5941 : 	{
; 5942 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x84] GS_DGAnsFirstCreateNPC() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0HG@MMFIPMJM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x84@
  00029	6a 02		 push	 2
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00031	83 c4 08	 add	 esp, 8

; 5952 : 		}
; 5953 : 	}
; 5954 : #endif
; 5955 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@GS_DGAnsFi:

; 5943 : 		return;
; 5944 : 	}
; 5945 : 
; 5946 : 	if(lpMsg->iResult == 1)

  00036	83 79 04 01	 cmp	 DWORD PTR [ecx+4], 1
  0003a	75 24		 jne	 SHORT $LN5@GS_DGAnsFi

; 5947 : 	{
; 5948 : 		if(g_CastleSiege.GetDbNpcCreated() == FALSE)

  0003c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00041	e8 00 00 00 00	 call	 ?GetDbNpcCreated@CCastleSiege@@QAEHXZ ; CCastleSiege::GetDbNpcCreated
  00046	85 c0		 test	 eax, eax
  00048	75 16		 jne	 SHORT $LN5@GS_DGAnsFi

; 5949 : 		{
; 5950 : 			g_CastleSiege.CreateDbNPC();

  0004a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0004f	e8 00 00 00 00	 call	 ?CreateDbNPC@CCastleSiege@@QAEXXZ ; CCastleSiege::CreateDbNPC

; 5951 : 			g_CastleSiege.SetDbNpcCreated(TRUE);

  00054	6a 01		 push	 1
  00056	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0005b	e8 00 00 00 00	 call	 ?SetDbNpcCreated@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetDbNpcCreated
$LN5@GS_DGAnsFi:

; 5952 : 		}
; 5953 : 	}
; 5954 : #endif
; 5955 : }

  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?GS_DGAnsFirstCreateNPC@@YAXPAE@Z ENDP			; GS_DGAnsFirstCreateNPC
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsAllGuildMarkRegInfo@@YAXPAE@Z
_TEXT	SEGMENT
_cBUFFER$ = -1672					; size = 1668
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsAllGuildMarkRegInfo@@YAXPAE@Z PROC		; GS_DGAnsAllGuildMarkRegInfo, COMDAT

; 5877 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 06 00
	00		 sub	 esp, 1672		; 00000688H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpRecv$[ebp]

; 5878 : #if (GS_CASTLE == 1)
; 5879 : 	CSP_ANS_ALLGUILDREGINFO * lpMsg = (CSP_ANS_ALLGUILDREGINFO*)lpRecv;
; 5880 : 	CSP_GUILDREGINFO * lpMsgBody = (CSP_GUILDREGINFO*)&lpRecv[sizeof(CSP_ANS_ALLGUILDREGINFO)];
; 5881 : 
; 5882 : 	if(lpMsg == NULL)

  00017	85 db		 test	 ebx, ebx
  00019	0f 84 0f 01 00
	00		 je	 $LN1@GS_DGAnsAl
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0001f	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00024	85 c0		 test	 eax, eax
  00026	74 06		 je	 SHORT $LN11@GS_DGAnsAl

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00028	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0002c	eb 03		 jmp	 SHORT $LN10@GS_DGAnsAl
$LN11@GS_DGAnsAl:

; 58   : 		}
; 59   : 		return -1;

  0002e	83 c9 ff	 or	 ecx, -1
$LN10@GS_DGAnsAl:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5885 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  00031	0f b7 43 08	 movzx	 eax, WORD PTR [ebx+8]
  00035	3b c1		 cmp	 eax, ecx
  00037	74 1f		 je	 SHORT $LN6@GS_DGAnsAl

; 5886 : 	{
; 5887 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x83] GS_DGAnsAllGuildMarkRegInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0HL@PPDLAEKI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x83@
  0003e	6a 02		 push	 2
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00046	83 c4 08	 add	 esp, 8
  00049	5b		 pop	 ebx

; 5922 : #endif
; 5923 : }

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004d	33 cd		 xor	 ecx, ebp
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN6@GS_DGAnsAl:

; 5888 : 		return;
; 5889 : 	}
; 5890 : 
; 5891 : 	if(gObjIsConnected(lpMsg->iIndex) == FALSE)

  00058	ff 73 0c	 push	 DWORD PTR [ebx+12]
  0005b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00060	83 c4 04	 add	 esp, 4
  00063	85 c0		 test	 eax, eax
  00065	0f 84 c3 00 00
	00		 je	 $LN1@GS_DGAnsAl

; 5892 : 		return;
; 5893 : 
; 5894 : 	char cBUFFER[0x684];
; 5895 : 
; 5896 : 	PMSG_ANS_CSREGGUILDLIST * lpMsgSend = (PMSG_ANS_CSREGGUILDLIST*)cBUFFER;
; 5897 : 	PMSG_CSREGGUILDLIST * lpMsgSendBody = (PMSG_CSREGGUILDLIST*)&cBUFFER[sizeof(PMSG_ANS_CSREGGUILDLIST)];
; 5898 : 
; 5899 : 	lpMsgSend->iCount = 0;
; 5900 : 	lpMsgSend->btResult = lpMsg->iResult;

  0006b	8a 43 04	 mov	 al, BYTE PTR [ebx+4]
  0006e	57		 push	 edi
  0006f	33 ff		 xor	 edi, edi
  00071	88 85 7c f9 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+4], al

; 5901 : 
; 5902 : 	if(lpMsg->iResult == 1)

  00077	83 7b 04 01	 cmp	 DWORD PTR [ebx+4], 1
  0007b	89 bd 80 f9 ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+8], edi
  00081	75 68		 jne	 SHORT $LN3@GS_DGAnsAl

; 5903 : 	{
; 5904 : 		lpMsgSend->iCount = lpMsg->iCount;

  00083	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00086	89 bd 80 f9 ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+8], edi

; 5905 : 
; 5906 : 		for(int iCNT = 0; iCNT < lpMsg->iCount; iCNT++)

  0008c	85 ff		 test	 edi, edi
  0008e	7e 5b		 jle	 SHORT $LN3@GS_DGAnsAl

; 5903 : 	{
; 5904 : 		lpMsgSend->iCount = lpMsg->iCount;

  00090	56		 push	 esi
  00091	8d 73 1c	 lea	 esi, DWORD PTR [ebx+28]
  00094	8d 95 8d f9 ff
	ff		 lea	 edx, DWORD PTR _cBUFFER$[ebp+21]
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL4@GS_DGAnsAl:

; 5907 : 		{
; 5908 : 			lpMsgSendBody[iCNT].btSeqNum = lpMsgBody[iCNT].btRegRank;

  000a0	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  000a4	8d 76 10	 lea	 esi, DWORD PTR [esi+16]

; 5909 : 			lpMsgSendBody[iCNT].btIsGiveUp = lpMsgBody[iCNT].bIsGiveUp;
; 5910 : 
; 5911 : 			lpMsgSendBody[iCNT].btRegMarks1 = DWORD((DWORD(lpMsgBody[iCNT].iRegMarkCount) >> 16) & 0xFFFF) >> 8;
; 5912 : 			lpMsgSendBody[iCNT].btRegMarks2 = DWORD((DWORD(lpMsgBody[iCNT].iRegMarkCount) >> 16) & 0xFFFF) & 0xFF;

  000a7	8b 4e f0	 mov	 ecx, DWORD PTR [esi-16]
  000aa	8d 52 0e	 lea	 edx, DWORD PTR [edx+14]
  000ad	88 42 f6	 mov	 BYTE PTR [edx-10], al
  000b0	0f b6 46 f4	 movzx	 eax, BYTE PTR [esi-12]
  000b4	88 42 f5	 mov	 BYTE PTR [edx-11], al
  000b7	0f b6 46 f3	 movzx	 eax, BYTE PTR [esi-13]
  000bb	88 42 f1	 mov	 BYTE PTR [edx-15], al
  000be	8b c1		 mov	 eax, ecx
  000c0	c1 e8 10	 shr	 eax, 16			; 00000010H
  000c3	88 42 f2	 mov	 BYTE PTR [edx-14], al

; 5913 : 			lpMsgSendBody[iCNT].btRegMarks3 = DWORD((DWORD(lpMsgBody[iCNT].iRegMarkCount) & 0xFFFF) & 0xFFFF) >> 8;
; 5914 : 			lpMsgSendBody[iCNT].btRegMarks4 = DWORD((DWORD(lpMsgBody[iCNT].iRegMarkCount) & 0xFFFF) & 0xFFFF) & 0xFF;

  000c6	0f b6 46 f0	 movzx	 eax, BYTE PTR [esi-16]
  000ca	88 42 f4	 mov	 BYTE PTR [edx-12], al

; 5915 : 
; 5916 : 			memcpy(lpMsgSendBody[iCNT].szGuildName,lpMsgBody[iCNT].szGuildName,8);

  000cd	8b 46 e8	 mov	 eax, DWORD PTR [esi-24]
  000d0	c1 e9 08	 shr	 ecx, 8
  000d3	89 42 e9	 mov	 DWORD PTR [edx-23], eax
  000d6	8b 46 ec	 mov	 eax, DWORD PTR [esi-20]
  000d9	88 4a f3	 mov	 BYTE PTR [edx-13], cl
  000dc	89 42 ed	 mov	 DWORD PTR [edx-19], eax
  000df	83 ef 01	 sub	 edi, 1
  000e2	75 bc		 jne	 SHORT $LL4@GS_DGAnsAl

; 5905 : 
; 5906 : 		for(int iCNT = 0; iCNT < lpMsg->iCount; iCNT++)

  000e4	8b bd 80 f9 ff
	ff		 mov	 edi, DWORD PTR _cBUFFER$[ebp+8]
  000ea	5e		 pop	 esi
$LN3@GS_DGAnsAl:

; 5920 : 	lpMsgSend->h.set((PBYTE)lpMsgSend,0xB4,sizeof(PMSG_CSREGGUILDLIST) * lpMsgSend->iCount + sizeof(PMSG_ANS_CSREGGUILDLIST));

  000eb	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 111  : 		lpBuf[0] = 0xC2;

  000f2	c6 85 78 f9 ff
	ff c2		 mov	 BYTE PTR _cBUFFER$[ebp], 194 ; 000000c2H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5920 : 	lpMsgSend->h.set((PBYTE)lpMsgSend,0xB4,sizeof(PMSG_CSREGGUILDLIST) * lpMsgSend->iCount + sizeof(PMSG_ANS_CSREGGUILDLIST));

  000f9	2b c7		 sub	 eax, edi
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 114  : 		lpBuf[3] = head;

  000fb	c6 85 7b f9 ff
	ff b4		 mov	 BYTE PTR _cBUFFER$[ebp+3], 180 ; 000000b4H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5920 : 	lpMsgSend->h.set((PBYTE)lpMsgSend,0xB4,sizeof(PMSG_CSREGGUILDLIST) * lpMsgSend->iCount + sizeof(PMSG_ANS_CSREGGUILDLIST));

  00102	8d 0c 45 0c 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+12]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 112  : 		lpBuf[1] = SET_NUMBERH(size);

  00109	8b c1		 mov	 eax, ecx

; 113  : 		lpBuf[2] = SET_NUMBERL(size);

  0010b	88 8d 7a f9 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+2], cl
  00111	c1 e8 08	 shr	 eax, 8
  00114	88 85 79 f9 ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+1], al
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5921 : 	DataSend(lpMsg->iIndex,(PBYTE)lpMsgSend,sizeof(PMSG_CSREGGUILDLIST) * lpMsgSend->iCount + sizeof(PMSG_ANS_CSREGGUILDLIST));

  0011a	8d 85 78 f9 ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  00120	51		 push	 ecx
  00121	50		 push	 eax
  00122	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00125	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012d	5f		 pop	 edi
$LN1@GS_DGAnsAl:

; 5922 : #endif
; 5923 : }

  0012e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00131	33 cd		 xor	 ecx, ebp
  00133	5b		 pop	 ebx
  00134	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
?GS_DGAnsAllGuildMarkRegInfo@@YAXPAE@Z ENDP		; GS_DGAnsAllGuildMarkRegInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleNpcInfo@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleNpcInfo@@YAXPAE@Z PROC			; GS_DGAnsCastleNpcInfo, COMDAT

; 5826 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5827 : #if (GS_CASTLE == 1)
; 5828 : 	CSP_ANS_NPCDATA * lpMsg = (CSP_ANS_NPCDATA*)lpRecv;
; 5829 : 	CSP_NPCDATA * lpMsgBody = (CSP_NPCDATA*)&lpRecv[sizeof(CSP_ANS_NPCDATA)];
; 5830 : 
; 5831 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN3@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsCa
$LN6@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5834 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 10		 je	 SHORT $LN3@GS_DGAnsCa

; 5835 : 	{
; 5836 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x82] GS_DGAnsCastleNpcInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0HF@FPJKEGCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x82@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsCa:

; 5837 : 	}
; 5838 : #endif
; 5839 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GS_DGAnsCastleNpcInfo@@YAXPAE@Z ENDP			; GS_DGAnsCastleNpcInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleInitData@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleInitData@@YAXPAE@Z PROC			; GS_DGAnsCastleInitData, COMDAT

; 5743 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5744 : #if (GS_CASTLE == 1)
; 5745 : 	CSP_ANS_CSINITDATA * lpMsg = (CSP_ANS_CSINITDATA*)lpRecv;
; 5746 : 	CSP_CSINITDATA * lpMsgBody = (CSP_CSINITDATA*)&lpRecv[sizeof(CSP_ANS_CSINITDATA)];

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpRecv$[ebp]
  00007	57		 push	 edi
  00008	8d 7e 40	 lea	 edi, DWORD PTR [esi+64]

; 5747 : 
; 5748 : 	if(lpMsg == NULL)

  0000b	85 f6		 test	 esi, esi
  0000d	74 2a		 je	 SHORT $LN1@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000f	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00014	85 c0		 test	 eax, eax
  00016	74 06		 je	 SHORT $LN11@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00018	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0001c	eb 03		 jmp	 SHORT $LN10@GS_DGAnsCa
$LN11@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  0001e	83 c9 ff	 or	 ecx, -1
$LN10@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5751 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  00021	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00025	3b c1		 cmp	 eax, ecx
  00027	74 14		 je	 SHORT $LN3@GS_DGAnsCa

; 5752 : 	{
; 5753 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x81] GS_DGAnsCastleInitData() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0HG@CBDKIEJG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x81@

; 5778 : 	{
; 5779 : 		LogAddC(2,"[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - g_CastleSiege.SetCastleInitData() == FALSE");

  0002e	6a 02		 push	 2
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00036	83 c4 08	 add	 esp, 8
$LN1@GS_DGAnsCa:
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi

; 5800 : #endif
; 5801 : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN3@GS_DGAnsCa:

; 5754 : 		return;
; 5755 : 	}
; 5756 : 
; 5757 : 	if(g_CastleSiege.GetDataLoadState() != 2)

  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00042	e8 00 00 00 00	 call	 ?GetDataLoadState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetDataLoadState

; 5758 : 	{
; 5759 : 		LogAddC(2,"[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - m_iCastleDataLoadState != CASTLESIEGE_DATALOAD_2 (%d)",

  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0004c	83 f8 02	 cmp	 eax, 2
  0004f	74 1a		 je	 SHORT $LN4@GS_DGAnsCa
  00051	e8 00 00 00 00	 call	 ?GetDataLoadState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetDataLoadState
  00056	50		 push	 eax
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0GO@LJFKFDKN@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
  0005c	6a 02		 push	 2
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi

; 5800 : #endif
; 5801 : }

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN4@GS_DGAnsCa:

; 5760 : 			g_CastleSiege.GetDataLoadState());
; 5761 : 		return;
; 5762 : 	}
; 5763 : 
; 5764 : 	g_CastleSiege.SetDataLoadState(3);

  0006b	6a 03		 push	 3
  0006d	e8 00 00 00 00	 call	 ?SetDataLoadState@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetDataLoadState

; 5765 : 
; 5766 : 	if(lpMsg->iResult == 0)

  00072	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00076	75 1f		 jne	 SHORT $LN5@GS_DGAnsCa

; 5767 : 	{
; 5768 : 		LogAddC(2,"[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - lpMsg->iResult == 0");

  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@NPBCIFML@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
  0007d	6a 02		 push	 2
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00085	83 c4 08	 add	 esp, 8
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi

; 5769 : 		MsgBox("[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - lpMsg->iResult == 0");

  0008a	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _lpRecv$[ebp], OFFSET ??_C@_0EM@NPBCIFML@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@

; 5800 : #endif
; 5801 : }

  00091	5d		 pop	 ebp

; 5769 : 		MsgBox("[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - lpMsg->iResult == 0");

  00092	e9 00 00 00 00	 jmp	 ?MsgBox@@YAXPADZZ	; MsgBox
$LN5@GS_DGAnsCa:

; 5770 : 		return;
; 5771 : 	}
; 5772 : 
; 5773 : 	int bRET_VAL = FALSE;
; 5774 : 
; 5775 : 	bRET_VAL = g_CastleSiege.SetCastleInitData(lpMsg);

  00097	56		 push	 esi
  00098	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0009d	e8 00 00 00 00	 call	 ?SetCastleInitData@CCastleSiege@@QAEHPAUCSP_ANS_CSINITDATA@@@Z ; CCastleSiege::SetCastleInitData

; 5776 : 
; 5777 : 	if(bRET_VAL == FALSE)

  000a2	85 c0		 test	 eax, eax
  000a4	75 14		 jne	 SHORT $LN6@GS_DGAnsCa

; 5778 : 	{
; 5779 : 		LogAddC(2,"[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - g_CastleSiege.SetCastleInitData() == FALSE");

  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@EAAPMHFJ@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
  000ab	6a 02		 push	 2
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000b3	83 c4 08	 add	 esp, 8
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi

; 5800 : #endif
; 5801 : }

  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN6@GS_DGAnsCa:

; 5780 : 		return;
; 5781 : 	}
; 5782 : 
; 5783 : 	bRET_VAL = g_CastleSiege.SetCastleNpcData(lpMsgBody,lpMsg->iCount);

  000ba	ff 76 38	 push	 DWORD PTR [esi+56]
  000bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000c2	57		 push	 edi
  000c3	e8 00 00 00 00	 call	 ?SetCastleNpcData@CCastleSiege@@QAEHPAUCSP_CSINITDATA@@H@Z ; CCastleSiege::SetCastleNpcData

; 5784 : 
; 5785 : 	if(bRET_VAL == FALSE)

  000c8	85 c0		 test	 eax, eax
  000ca	75 14		 jne	 SHORT $LN7@GS_DGAnsCa

; 5786 : 	{
; 5787 : 		LogAddC(2,"[CastleSiege] CASTLE SIEGE DATA SETTING FAILED [0x81] - g_CastleSiege.SetCastleNpcData() == FALSE");

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@MGFHIKBL@?$FLCastleSiege?$FN?5CASTLE?5SIEGE?5DATA?5@
  000d1	6a 02		 push	 2
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000d9	83 c4 08	 add	 esp, 8
  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi

; 5800 : #endif
; 5801 : }

  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN7@GS_DGAnsCa:

; 5788 : 		return;
; 5789 : 	}
; 5790 : 
; 5791 : 	g_CastleSiege.SetDbDataLoadOK(TRUE);

  000e0	6a 01		 push	 1
  000e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000e7	e8 00 00 00 00	 call	 ?SetDbDataLoadOK@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetDbDataLoadOK

; 5792 : 	g_CastleSiege.SetDataLoadState(4);

  000ec	6a 04		 push	 4
  000ee	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000f3	e8 00 00 00 00	 call	 ?SetDataLoadState@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetDataLoadState

; 5793 : 
; 5794 : 	if(lpMsg->iFirstCreate == TRUE)

  000f8	83 7e 34 01	 cmp	 DWORD PTR [esi+52], 1
  000fc	75 0a		 jne	 SHORT $LN8@GS_DGAnsCa

; 5795 : 	{
; 5796 : 		g_CastleSiege.FirstCreateDbNPC();

  000fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00103	e8 00 00 00 00	 call	 ?FirstCreateDbNPC@CCastleSiege@@QAEHXZ ; CCastleSiege::FirstCreateDbNPC
$LN8@GS_DGAnsCa:

; 5797 : 	}
; 5798 : 
; 5799 : 	g_CastleSiege.Init();

  00108	5f		 pop	 edi
  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0010e	5e		 pop	 esi

; 5800 : #endif
; 5801 : }

  0010f	5d		 pop	 ebp

; 5797 : 	}
; 5798 : 
; 5799 : 	g_CastleSiege.Init();

  00110	e9 00 00 00 00	 jmp	 ?Init@CCastleSiege@@QAEHXZ ; CCastleSiege::Init
?GS_DGAnsCastleInitData@@YAXPAE@Z ENDP			; GS_DGAnsCastleInitData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsResetRegSiegeInfo@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsResetRegSiegeInfo@@YAXPAE@Z PROC		; GS_DGAnsResetRegSiegeInfo, COMDAT

; 5728 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5729 : #if (GS_CASTLE == 1)
; 5730 : 	CSP_ANS_RESETREGSIEGEINFO * lpMsg = (CSP_ANS_RESETREGSIEGEINFO*)lpRecv;
; 5731 : 
; 5732 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN3@GS_DGAnsRe
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsRe

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsRe
$LN6@GS_DGAnsRe:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsRe:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5735 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 10		 je	 SHORT $LN3@GS_DGAnsRe

; 5736 : 	{
; 5737 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x1B] GS_DGAnsResetRegSiegeInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@DDPBMEPM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsRe:

; 5738 : 	}
; 5739 : #endif
; 5740 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GS_DGAnsResetRegSiegeInfo@@YAXPAE@Z ENDP		; GS_DGAnsResetRegSiegeInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsResetSiegeGuildInfo@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsResetSiegeGuildInfo@@YAXPAE@Z PROC		; GS_DGAnsResetSiegeGuildInfo, COMDAT

; 5706 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5707 : #if (GS_CASTLE == 1)
; 5708 : 	CSP_ANS_RESETSIEGEGUILDINFO * lpMsg = (CSP_ANS_RESETSIEGEGUILDINFO*)lpRecv;
; 5709 : 
; 5710 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN3@GS_DGAnsRe
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsRe

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsRe
$LN6@GS_DGAnsRe:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsRe:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5713 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 10		 je	 SHORT $LN3@GS_DGAnsRe

; 5714 : 	{
; 5715 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x1A] GS_DGAnsResetSiegeGuildInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0IB@LEBBPIHB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsRe:

; 5716 : 	}
; 5717 : #endif
; 5718 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GS_DGAnsResetSiegeGuildInfo@@YAXPAE@Z ENDP		; GS_DGAnsResetSiegeGuildInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsResetCastleTaxInfo@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsResetCastleTaxInfo@@YAXPAE@Z PROC		; GS_DGAnsResetCastleTaxInfo, COMDAT

; 5678 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5679 : #if (GS_CASTLE == 1)
; 5680 : 	CSP_ANS_RESETCASTLETAXINFO * lpMsg = (CSP_ANS_RESETCASTLETAXINFO*)lpRecv;
; 5681 : 
; 5682 : 	if(lpMsg == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 2a		 je	 SHORT $LN4@GS_DGAnsRe
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN7@GS_DGAnsRe

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00013	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00017	eb 03		 jmp	 SHORT $LN6@GS_DGAnsRe
$LN7@GS_DGAnsRe:

; 58   : 		}
; 59   : 		return -1;

  00019	83 ca ff	 or	 edx, -1
$LN6@GS_DGAnsRe:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5685 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001c	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00020	3b c2		 cmp	 eax, edx
  00022	74 12		 je	 SHORT $LN3@GS_DGAnsRe

; 5686 : 	{
; 5687 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x19] GS_DGAnsResetCastleTaxInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0IA@OLLELCLL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  00029	6a 02		 push	 2
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00031	83 c4 08	 add	 esp, 8
$LN4@GS_DGAnsRe:

; 5694 : 	}
; 5695 : #endif
; 5696 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@GS_DGAnsRe:

; 5688 : 		return;
; 5689 : 	}
; 5690 : 
; 5691 : 	if(lpMsg->iResult = 1)

  00036	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1

; 5692 : 	{
; 5693 : 		g_CastleSiege.ResetCastleTaxInfo();

  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege

; 5694 : 	}
; 5695 : #endif
; 5696 : }

  00042	5d		 pop	 ebp

; 5692 : 	{
; 5693 : 		g_CastleSiege.ResetCastleTaxInfo();

  00043	e9 00 00 00 00	 jmp	 ?ResetCastleTaxInfo@CCastleSiege@@QAEXXZ ; CCastleSiege::ResetCastleTaxInfo
?GS_DGAnsResetCastleTaxInfo@@YAXPAE@Z ENDP		; GS_DGAnsResetCastleTaxInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleTributeMoney@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleTributeMoney@@YAXPAE@Z PROC		; GS_DGAnsCastleTributeMoney, COMDAT

; 5650 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5651 : 	CSP_ANS_CASTLETRIBUTEMONEY * lpMsg = (CSP_ANS_CASTLETRIBUTEMONEY *)lpRecv;
; 5652 : 
; 5653 : 	if ( lpMsg == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN1@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsCa
$LN6@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5658 : 	if ( lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup() )

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 12		 je	 SHORT $LN3@GS_DGAnsCa

; 5659 : 	{
; 5660 : 		LogAddC(2, "[CastleSiege] PACKET-ERROR [0x80][0x18] GS_DGAnsCastleTributeMoney() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0IA@HBPHMAAG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN1@GS_DGAnsCa:

; 5667 : 	
; 5668 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
$LN3@GS_DGAnsCa:

; 5661 : 		return;
; 5662 : 	}
; 5663 : 	
; 5664 : 	LogAddTD("[CastleSiege] [0x80][0x18] GS_DGAnsCastleTributeMoney() - Money Tribute OK (%d)",

  00037	ff 35 14 00 00
	00		 push	 DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+20
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NDMPNFNO@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x18?$FN?5GS_DG@
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00048	83 c4 08	 add	 esp, 8

; 5665 : 		g_CastleSiegeSync.GetTributeMoney());
; 5666 : 	g_CastleSiegeSync.ResetTributeMoney();

  0004b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync

; 5667 : 	
; 5668 : }

  00050	5d		 pop	 ebp

; 5665 : 		g_CastleSiegeSync.GetTributeMoney());
; 5666 : 	g_CastleSiegeSync.ResetTributeMoney();

  00051	e9 00 00 00 00	 jmp	 ?ResetTributeMoney@CCastleSiegeSync@@QAEXXZ ; CCastleSiegeSync::ResetTributeMoney
?GS_DGAnsCastleTributeMoney@@YAXPAE@Z ENDP		; GS_DGAnsCastleTributeMoney
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\castlesiegesync.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleStateSync@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleStateSync@@YAXPAE@Z PROC			; GS_DGAnsCastleStateSync, COMDAT

; 5613 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5614 : 	CSP_ANS_CASTLESTATESYNC * lpMsg = (CSP_ANS_CASTLESTATESYNC *)lpRecv;
; 5615 : 
; 5616 : 	if ( lpMsg == NULL )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 48		 je	 SHORT $LN1@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN6@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00013	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00017	eb 03		 jmp	 SHORT $LN5@GS_DGAnsCa
$LN6@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  00019	83 ca ff	 or	 edx, -1
$LN5@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5621 : 	if ( lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup() )

  0001c	0f b7 41 04	 movzx	 eax, WORD PTR [ecx+4]
  00020	3b c2		 cmp	 eax, edx
  00022	75 2e		 jne	 SHORT $LN1@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\castlesiegesync.h

; 30   : 	void SetCastleState(int iCastleState){this->m_iCurCastleState = iCastleState;};	// line : 56

  00024	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00027	a3 04 00 00 00	 mov	 DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+4, eax

; 31   : 	void SetTaxRateChaos(int iTaxRate){this->m_iCurTaxRateChaos = iTaxRate;};	// line : 59

  0002c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0002f	a3 08 00 00 00	 mov	 DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+8, eax

; 32   : 	void SetTaxRateStore(int iTaxRate){this->m_iCurTaxRateStore = iTaxRate;};	// line : 62

  00034	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00037	a3 0c 00 00 00	 mov	 DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+12, eax

; 33   : 	void SetTaxHuntZone(int iTaxRate){this->m_iCurTaxHuntZone = iTaxRate;};	// line : 65

  0003c	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0003f	a3 10 00 00 00	 mov	 DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+16, eax
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5630 : 	g_CastleSiegeSync.SetCastleOwnerGuild(lpMsg->szOwnerGuildName);

  00044	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00047	50		 push	 eax
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0004d	e8 00 00 00 00	 call	 ?SetCastleOwnerGuild@CCastleSiegeSync@@QAEXPAD@Z ; CCastleSiegeSync::SetCastleOwnerGuild
$LN1@GS_DGAnsCa:

; 5631 : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?GS_DGAnsCastleStateSync@@YAXPAE@Z ENDP			; GS_DGAnsCastleStateSync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsNpcRemove@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsNpcRemove@@YAXPAE@Z PROC			; GS_DGAnsNpcRemove, COMDAT

; 5577 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5578 : #if (GS_CASTLE == 1)
; 5579 : 	CSP_ANS_NPCREMOVE * lpMsg = (CSP_ANS_NPCREMOVE*)lpRecv;
; 5580 : 
; 5581 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN3@GS_DGAnsNp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsNp

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsNp
$LN6@GS_DGAnsNp:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsNp:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5584 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 10		 je	 SHORT $LN3@GS_DGAnsNp

; 5585 : 	{
; 5586 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x10] GS_DGAnsRegGuildMark() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0HK@NECBCB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsNp:

; 5587 : 	}
; 5588 : #endif
; 5589 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GS_DGAnsNpcRemove@@YAXPAE@Z ENDP			; GS_DGAnsNpcRemove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsGuildSetGiveUp@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsGuildSetGiveUp@@YAXPAE@Z PROC			; GS_DGAnsGuildSetGiveUp, COMDAT

; 5549 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5550 : #if (GS_CASTLE == 1)
; 5551 : 	CSP_ANS_GUILDSETGIVEUP * lpMsg = (CSP_ANS_GUILDSETGIVEUP*)lpRecv;
; 5552 : 
; 5553 : 	if(lpMsg == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 4c		 je	 SHORT $LN1@GS_DGAnsGu
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN6@GS_DGAnsGu

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00013	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00017	eb 03		 jmp	 SHORT $LN5@GS_DGAnsGu
$LN6@GS_DGAnsGu:

; 58   : 		}
; 59   : 		return -1;

  00019	83 ca ff	 or	 edx, -1
$LN5@GS_DGAnsGu:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5556 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001c	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00020	3b c2		 cmp	 eax, edx
  00022	74 12		 je	 SHORT $LN3@GS_DGAnsGu

; 5557 : 	{
; 5558 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x12] GS_DGAnsGuildSetGiveUp() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0HM@JNNIOIKL@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  00029	6a 02		 push	 2
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00031	83 c4 08	 add	 esp, 8

; 5563 : #endif
; 5564 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@GS_DGAnsGu:

; 5559 : 		return;
; 5560 : 	}
; 5561 : 
; 5562 : 	GCAnsGiveUpCastleSiege(lpMsg->iIndex,lpMsg->iResult,lpMsg->bIsGiveUp,lpMsg->iRegMarkCount,lpMsg->szGuildName);

  00036	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  0003a	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  0003d	50		 push	 eax
  0003e	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00041	0f 95 c0	 setne	 al
  00044	0f b6 c0	 movzx	 eax, al
  00047	50		 push	 eax
  00048	ff 71 04	 push	 DWORD PTR [ecx+4]
  0004b	ff 71 0c	 push	 DWORD PTR [ecx+12]
  0004e	e8 00 00 00 00	 call	 ?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z ; GCAnsGiveUpCastleSiege
  00053	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@GS_DGAnsGu:

; 5563 : #endif
; 5564 : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?GS_DGAnsGuildSetGiveUp@@YAXPAE@Z ENDP			; GS_DGAnsGuildSetGiveUp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsGuildMarkReset@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsGuildMarkReset@@YAXPAE@Z PROC			; GS_DGAnsGuildMarkReset, COMDAT

; 5522 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5523 : #if (GS_CASTLE == 1)
; 5524 : 	CSP_ANS_GUILDRESETMARK * lpMsg = (CSP_ANS_GUILDRESETMARK*)lpRecv;
; 5525 : 
; 5526 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN3@GS_DGAnsGu
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsGu

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsGu
$LN6@GS_DGAnsGu:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsGu:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5529 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 10		 je	 SHORT $LN3@GS_DGAnsGu

; 5530 : 	{
; 5531 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x10] GS_DGAnsRegGuildMark() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0HK@NECBCB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsGu:

; 5532 : 	}
; 5533 : #endif
; 5534 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GS_DGAnsGuildMarkReset@@YAXPAE@Z ENDP			; GS_DGAnsGuildMarkReset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsRegGuildMark@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsRegGuildMark@@YAXPAE@Z PROC			; GS_DGAnsRegGuildMark, COMDAT

; 5494 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5495 : #if (GS_CASTLE == 1)
; 5496 : 	CSP_ANS_GUILDREGMARK * lpMsg = (CSP_ANS_GUILDREGMARK*)lpRecv;
; 5497 : 
; 5498 : 	if(lpMsg == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 3b		 je	 SHORT $LN1@GS_DGAnsRe
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN6@GS_DGAnsRe

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00013	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00017	eb 03		 jmp	 SHORT $LN5@GS_DGAnsRe
$LN6@GS_DGAnsRe:

; 58   : 		}
; 59   : 		return -1;

  00019	83 ca ff	 or	 edx, -1
$LN5@GS_DGAnsRe:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5501 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001c	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00020	3b c2		 cmp	 eax, edx
  00022	74 12		 je	 SHORT $LN3@GS_DGAnsRe

; 5502 : 	{
; 5503 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x10] GS_DGAnsRegGuildMark() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0HK@NECBCB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  00029	6a 02		 push	 2
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00031	83 c4 08	 add	 esp, 8

; 5508 : #endif
; 5509 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@GS_DGAnsRe:

; 5504 : 		return;
; 5505 : 	}
; 5506 : 
; 5507 : 	GCAnsRegGuildMark(lpMsg->iIndex,lpMsg->iResult,lpMsg);

  00036	51		 push	 ecx
  00037	ff 71 04	 push	 DWORD PTR [ecx+4]
  0003a	ff 71 0c	 push	 DWORD PTR [ecx+12]
  0003d	e8 00 00 00 00	 call	 ?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z ; GCAnsRegGuildMark
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GS_DGAnsRe:

; 5508 : #endif
; 5509 : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?GS_DGAnsRegGuildMark@@YAXPAE@Z ENDP			; GS_DGAnsRegGuildMark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsMapSvrMsgMultiCast@@YAXPAE@Z
_TEXT	SEGMENT
_pNotice$1 = -420					; size = 272
_szNotice$ = -148					; size = 144
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
?GS_DGAnsMapSvrMsgMultiCast@@YAXPAE@Z PROC		; GS_DGAnsMapSvrMsgMultiCast, COMDAT

; 5465 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpRecv$[ebp]

; 5466 : 	CSP_ANS_MAPSVRMULTICAST * lpMsg = (CSP_ANS_MAPSVRMULTICAST *)lpRecv;
; 5467 : 
; 5468 : 	if ( lpMsg == NULL )

  00017	85 f6		 test	 esi, esi
  00019	0f 84 bc 00 00
	00		 je	 $LN4@GS_DGAnsMa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0001f	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00024	85 c0		 test	 eax, eax
  00026	74 06		 je	 SHORT $LN7@GS_DGAnsMa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00028	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0002c	eb 03		 jmp	 SHORT $LN6@GS_DGAnsMa
$LN7@GS_DGAnsMa:

; 58   : 		}
; 59   : 		return -1;

  0002e	83 c9 ff	 or	 ecx, -1
$LN6@GS_DGAnsMa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5473 : 	if ( lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup() )

  00031	0f b7 46 04	 movzx	 eax, WORD PTR [esi+4]
  00035	3b c1		 cmp	 eax, ecx
  00037	74 1f		 je	 SHORT $LN3@GS_DGAnsMa

; 5474 : 	{
; 5475 : 		LogAddC(2, "[CastleSiege] PACKET-ERROR [0x80][0x0F] GS_DGAnsMapSvrMsgMultiCast() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0IA@LNMFDGBP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0003e	6a 02		 push	 2
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00046	83 c4 08	 add	 esp, 8
  00049	5e		 pop	 esi

; 5489 : 	}
; 5490 : 
; 5491 : }

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004d	33 cd		 xor	 ecx, ebp
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN3@GS_DGAnsMa:
  00058	57		 push	 edi

; 5476 : 		return;
; 5477 : 	}
; 5478 : 
; 5479 : 	char szNotice[144] = {0};

  00059	68 8f 00 00 00	 push	 143			; 0000008fH
  0005e	8d 85 6d ff ff
	ff		 lea	 eax, DWORD PTR _szNotice$[ebp+1]
  00064	6a 00		 push	 0
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _memset
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5480 : 	memcpy(szNotice, lpMsg->szMsgText, 128);

  0006f	8d bd 6c ff ff
	ff		 lea	 edi, DWORD PTR _szNotice$[ebp]
  00075	83 c6 06	 add	 esi, 6
  00078	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0007d	f3 a5		 rep movsd

; 5481 : 
; 5482 : 	if ( strlen(szNotice) > 1 )

  0007f	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _szNotice$[ebp]
  00085	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00088	5f		 pop	 edi
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL11@GS_DGAnsMa:
  00090	8a 01		 mov	 al, BYTE PTR [ecx]
  00092	41		 inc	 ecx
  00093	84 c0		 test	 al, al
  00095	75 f9		 jne	 SHORT $LL11@GS_DGAnsMa
  00097	2b ca		 sub	 ecx, edx
  00099	83 f9 01	 cmp	 ecx, 1
  0009c	76 3d		 jbe	 SHORT $LN4@GS_DGAnsMa

; 5483 : 	{
; 5484 : 		PMSG_NOTICE pNotice;
; 5485 : 
; 5486 : 		TNotice::MakeNoticeMsg((TNotice *)&pNotice, 0, szNotice);

  0009e	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _szNotice$[ebp]
  000a4	50		 push	 eax
  000a5	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$1[ebp]
  000ab	6a 00		 push	 0
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 5487 : 		TNotice::SetNoticeProperty((TNotice *)&pNotice, 0, _ARGB(255, 255, 200, 80), 1, 0, 20);

  000b3	6a 14		 push	 20			; 00000014H
  000b5	6a 00		 push	 0
  000b7	6a 01		 push	 1
  000b9	68 ff c8 50 ff	 push	 -11482881		; ff50c8ffH
  000be	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$1[ebp]
  000c4	6a 00		 push	 0
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ?SetNoticeProperty@TNotice@@SAXPAXEKEGE@Z ; TNotice::SetNoticeProperty

; 5488 : 		TNotice::SendNoticeToAllUser((TNotice *)&pNotice);

  000cc	8d 85 5c fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$1[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?SendNoticeToAllUser@TNotice@@SAXPAX@Z ; TNotice::SendNoticeToAllUser
  000d8	83 c4 28	 add	 esp, 40			; 00000028H
$LN4@GS_DGAnsMa:

; 5489 : 	}
; 5490 : 
; 5491 : }

  000db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000de	33 cd		 xor	 ecx, ebp
  000e0	5e		 pop	 esi
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
?GS_DGAnsMapSvrMsgMultiCast@@YAXPAE@Z ENDP		; GS_DGAnsMapSvrMsgMultiCast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsRestartCastleState@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsRestartCastleState@@YAXPAE@Z PROC		; GS_DGAnsRestartCastleState, COMDAT

; 5430 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5431 : #if (GS_CASTLE == 1)
; 5432 : 	CSP_ANS_REGATTACKGUILD * lpMsg = (CSP_ANS_REGATTACKGUILD*)lpRecv;
; 5433 : 
; 5434 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN1@GS_DGAnsRe
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsRe

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsRe
$LN6@GS_DGAnsRe:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsRe:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5437 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 12		 je	 SHORT $LN3@GS_DGAnsRe

; 5438 : 	{
; 5439 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x0E] GS_DGAnsRestartCastleState() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0IA@JGOKJONB@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN1@GS_DGAnsRe:

; 5444 : #endif
; 5445 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
$LN3@GS_DGAnsRe:

; 5440 : 		return;
; 5441 : 	}
; 5442 : 
; 5443 : 	g_CastleSiege.ResetCastleCycle();

  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege

; 5444 : #endif
; 5445 : }

  0003c	5d		 pop	 ebp

; 5440 : 		return;
; 5441 : 	}
; 5442 : 
; 5443 : 	g_CastleSiege.ResetCastleCycle();

  0003d	e9 00 00 00 00	 jmp	 ?ResetCastleCycle@CCastleSiege@@QAEXXZ ; CCastleSiege::ResetCastleCycle
?GS_DGAnsRestartCastleState@@YAXPAE@Z ENDP		; GS_DGAnsRestartCastleState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsRegAttackGuild@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsRegAttackGuild@@YAXPAE@Z PROC			; GS_DGAnsRegAttackGuild, COMDAT

; 5405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5406 : #if (GS_CASTLE == 1)
; 5407 : 	CSP_ANS_REGATTACKGUILD * lpMsg = (CSP_ANS_REGATTACKGUILD*)lpRecv;
; 5408 : 
; 5409 : 	if(lpMsg == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 3e		 je	 SHORT $LN1@GS_DGAnsRe
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN6@GS_DGAnsRe

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00013	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00017	eb 03		 jmp	 SHORT $LN5@GS_DGAnsRe
$LN6@GS_DGAnsRe:

; 58   : 		}
; 59   : 		return -1;

  00019	83 ca ff	 or	 edx, -1
$LN5@GS_DGAnsRe:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5412 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001c	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00020	3b c2		 cmp	 eax, edx
  00022	74 12		 je	 SHORT $LN3@GS_DGAnsRe

; 5413 : 	{
; 5414 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x0D] GS_DGAnsRegAttackGuild() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0HM@ENOOGPCP@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  00029	6a 02		 push	 2
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00031	83 c4 08	 add	 esp, 8

; 5419 : #endif
; 5420 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@GS_DGAnsRe:

; 5415 : 		return;
; 5416 : 	}
; 5417 : 
; 5418 : 	GCAnsRegCastleSiege(lpMsg->iIndex,lpMsg->iResult,lpMsg->szEnemyGuildName);

  00036	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  00039	50		 push	 eax
  0003a	ff 71 04	 push	 DWORD PTR [ecx+4]
  0003d	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00040	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GS_DGAnsRe:

; 5419 : #endif
; 5420 : }

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?GS_DGAnsRegAttackGuild@@YAXPAE@Z ENDP			; GS_DGAnsRegAttackGuild
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleOwnerChange@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleOwnerChange@@YAXPAE@Z PROC		; GS_DGAnsCastleOwnerChange, COMDAT

; 5381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5382 : #if (GS_CASTLE == 1)
; 5383 : 	CSP_ANS_CASTLEOWNERCHANGE * lpMsg = (CSP_ANS_CASTLEOWNERCHANGE*)lpRecv;
; 5384 : 
; 5385 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN3@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsCa
$LN6@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5388 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 10		 je	 SHORT $LN3@GS_DGAnsCa

; 5389 : 	{
; 5390 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x0C] GS_DGAnsCastleOwnerChange() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@ODLOINGN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsCa:

; 5391 : 	}
; 5392 : #endif
; 5393 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GS_DGAnsCastleOwnerChange@@YAXPAE@Z ENDP		; GS_DGAnsCastleOwnerChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsSiegeEndedChange@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsSiegeEndedChange@@YAXPAE@Z PROC		; GS_DGAnsSiegeEndedChange, COMDAT

; 5357 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5358 : #if (GS_CASTLE == 1)
; 5359 : 	CSP_ANS_SIEGEENDCHANGE * lpMsg = (CSP_ANS_SIEGEENDCHANGE*)lpRecv;
; 5360 : 
; 5361 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN3@GS_DGAnsSi
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsSi

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsSi
$LN6@GS_DGAnsSi:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsSi:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5364 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 10		 je	 SHORT $LN3@GS_DGAnsSi

; 5365 : 	{
; 5366 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x0B] GS_DGAnsSiegeEndedChange() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@EGJJDJOF@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsSi:

; 5367 : 	}
; 5368 : #endif
; 5369 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GS_DGAnsSiegeEndedChange@@YAXPAE@Z ENDP		; GS_DGAnsSiegeEndedChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsGuildMarkRegInfo@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsGuildMarkRegInfo@@YAXPAE@Z PROC		; GS_DGAnsGuildMarkRegInfo, COMDAT

; 5330 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5331 : #if (GS_CASTLE == 1)
; 5332 : 
; 5333 : 	CSP_ANS_GUILDREGINFO * lpMsg = (CSP_ANS_GUILDREGINFO*)lpRecv;
; 5334 : 
; 5335 : 	if(lpMsg == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 3b		 je	 SHORT $LN1@GS_DGAnsGu
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN6@GS_DGAnsGu

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00013	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00017	eb 03		 jmp	 SHORT $LN5@GS_DGAnsGu
$LN6@GS_DGAnsGu:

; 58   : 		}
; 59   : 		return -1;

  00019	83 ca ff	 or	 edx, -1
$LN5@GS_DGAnsGu:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5338 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001c	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00020	3b c2		 cmp	 eax, edx
  00022	74 12		 je	 SHORT $LN3@GS_DGAnsGu

; 5339 : 	{
; 5340 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x0A] GS_DGAnsGuildMarkRegInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@JKCCCDJI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  00029	6a 02		 push	 2
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00031	83 c4 08	 add	 esp, 8

; 5345 : #endif
; 5346 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@GS_DGAnsGu:

; 5341 : 		return;
; 5342 : 	}
; 5343 : 
; 5344 : 	GCAnsGuildRegInfo(lpMsg->iIndex,lpMsg->iResult,lpMsg);

  00036	51		 push	 ecx
  00037	ff 71 04	 push	 DWORD PTR [ecx+4]
  0003a	ff 71 0c	 push	 DWORD PTR [ecx+12]
  0003d	e8 00 00 00 00	 call	 ?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z ; GCAnsGuildRegInfo
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GS_DGAnsGu:

; 5345 : #endif
; 5346 : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?GS_DGAnsGuildMarkRegInfo@@YAXPAE@Z ENDP		; GS_DGAnsGuildMarkRegInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsSiegeDateChange@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsSiegeDateChange@@YAXPAE@Z PROC			; GS_DGAnsSiegeDateChange, COMDAT

; 5315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5316 : #if (GS_CASTLE == 1)
; 5317 : 	CSP_ANS_SDEDCHANGE * lpMsg = (CSP_ANS_SDEDCHANGE*)lpRecv;
; 5318 : 
; 5319 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN3@GS_DGAnsSi
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsSi

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsSi
$LN6@GS_DGAnsSi:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsSi:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5322 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 10		 je	 SHORT $LN3@GS_DGAnsSi

; 5323 : 	{
; 5324 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x09] GS_DGAnsSiegeDateChange() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@KCDIDGDG@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsSi:

; 5325 : 	}
; 5326 : #endif
; 5327 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GS_DGAnsSiegeDateChange@@YAXPAE@Z ENDP			; GS_DGAnsSiegeDateChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleMoneyChange@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleMoneyChange@@YAXPAE@Z PROC		; GS_DGAnsCastleMoneyChange, COMDAT

; 5264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5265 : #if (GS_CASTLE == 1)
; 5266 : 	CSP_ANS_MONEYCHANGE * lpMsg = (CSP_ANS_MONEYCHANGE*)lpRecv;
; 5267 : 
; 5268 : 	if(lpMsg == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpRecv$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 84 f9 00 00
	00		 je	 $LN1@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000f	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00014	85 c0		 test	 eax, eax
  00016	74 06		 je	 SHORT $LN9@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00018	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0001c	eb 03		 jmp	 SHORT $LN8@GS_DGAnsCa
$LN9@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  0001e	83 c9 ff	 or	 ecx, -1
$LN8@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5271 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  00021	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00025	3b c1		 cmp	 eax, ecx
  00027	74 13		 je	 SHORT $LN3@GS_DGAnsCa

; 5272 : 	{
; 5273 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x08] GS_DGAnsCastleMoneyChange() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@IIFHPCOO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002e	6a 02		 push	 2
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00036	83 c4 08	 add	 esp, 8
  00039	5e		 pop	 esi

; 5297 : #endif
; 5298 : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN3@GS_DGAnsCa:

; 5274 : 		return;
; 5275 : 	}
; 5276 : 
; 5277 : 	if(lpMsg->iResult == 1)

  0003c	83 7e 04 01	 cmp	 DWORD PTR [esi+4], 1
  00040	0f 85 ae 00 00
	00		 jne	 $LN4@GS_DGAnsCa

; 5278 : 	{
; 5279 : 		if(gObjIsConnected(lpMsg->iIndex) && lpMsg->iMoneyChanged < 0)

  00046	ff 76 0c	 push	 DWORD PTR [esi+12]
  00049	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004e	83 c4 04	 add	 esp, 4
  00051	85 c0		 test	 eax, eax
  00053	0f 84 8b 00 00
	00		 je	 $LN5@GS_DGAnsCa
  00059	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0005c	85 d2		 test	 edx, edx
  0005e	0f 89 80 00 00
	00		 jns	 $LN5@GS_DGAnsCa

; 5280 : 		{
; 5281 : 			gObj[lpMsg->iIndex].Money -= lpMsg->iMoneyChanged;

  00064	69 4e 0c 40 27
	00 00		 imul	 ecx, DWORD PTR [esi+12], 10048
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00070	29 94 01 cc 00
	00 00		 sub	 DWORD PTR [ecx+eax+204], edx

; 5282 : 
; 5283 : 			if(gObj[lpMsg->iIndex].Money > 2000000000)

  00077	69 46 0c 40 27
	00 00		 imul	 eax, DWORD PTR [esi+12], 10048
  0007e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00084	81 bc 10 cc 00
	00 00 00 94 35
	77		 cmp	 DWORD PTR [eax+edx+204], 2000000000 ; 77359400H
  0008f	7e 11		 jle	 SHORT $LN6@GS_DGAnsCa

; 5284 : 			{
; 5285 : 				gObj[lpMsg->iIndex].Money = 2000000000;

  00091	c7 84 10 cc 00
	00 00 00 94 35
	77		 mov	 DWORD PTR [eax+edx+204], 2000000000 ; 77359400H
  0009c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN6@GS_DGAnsCa:

; 5286 : 			}
; 5287 : 
; 5288 : 			GCMoneySend(lpMsg->iIndex,gObj[lpMsg->iIndex].Money);

  000a2	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000a5	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  000ab	ff b4 10 cc 00
	00 00		 push	 DWORD PTR [eax+edx+204]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 5289 : 			LogAddTD("[CastleSiege] [0x80][0x08] GS_DGAnsCastleMoneyChange() - Withdraw Request OK [%s][%s] (ReqMoney:%d, TotMoney:%I64d)",

  000b8	69 4e 0c 40 27
	00 00		 imul	 ecx, DWORD PTR [esi+12], 10048
  000bf	ff 76 1c	 push	 DWORD PTR [esi+28]
  000c2	ff 76 18	 push	 DWORD PTR [esi+24]
  000c5	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cb	ff 76 10	 push	 DWORD PTR [esi+16]
  000ce	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000d1	50		 push	 eax
  000d2	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000d5	50		 push	 eax
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_0HE@CADAABKE@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x08?$FN?5GS_DG@
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e1	83 c4 20	 add	 esp, 32			; 00000020H
$LN5@GS_DGAnsCa:

; 5290 : 			gObj[lpMsg->iIndex].AccountID,gObj[lpMsg->iIndex].Name,lpMsg->iMoneyChanged,lpMsg->i64CastleMoney);
; 5291 : 		}
; 5292 : 
; 5293 : 		g_CastleSiege.SetCastleMoney(lpMsg->i64CastleMoney);

  000e4	ff 76 1c	 push	 DWORD PTR [esi+28]
  000e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000ec	ff 76 18	 push	 DWORD PTR [esi+24]
  000ef	e8 00 00 00 00	 call	 ?SetCastleMoney@CCastleSiege@@QAEX_J@Z ; CCastleSiege::SetCastleMoney
$LN4@GS_DGAnsCa:

; 5294 : 	}
; 5295 : 
; 5296 : 	GCAnsMoneyDrawOut(lpMsg->iIndex,lpMsg->iResult,lpMsg->i64CastleMoney);

  000f4	ff 76 1c	 push	 DWORD PTR [esi+28]
  000f7	ff 76 18	 push	 DWORD PTR [esi+24]
  000fa	ff 76 04	 push	 DWORD PTR [esi+4]
  000fd	ff 76 0c	 push	 DWORD PTR [esi+12]
  00100	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut
  00105	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@GS_DGAnsCa:
  00108	5e		 pop	 esi

; 5297 : #endif
; 5298 : }

  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
?GS_DGAnsCastleMoneyChange@@YAXPAE@Z ENDP		; GS_DGAnsCastleMoneyChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsTaxRateChange@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsTaxRateChange@@YAXPAE@Z PROC			; GS_DGAnsTaxRateChange, COMDAT

; 5232 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5233 : #if (GS_CASTLE == 1)
; 5234 : 	CSP_ANS_TAXRATECHANGE * lpMsg = (CSP_ANS_TAXRATECHANGE*)lpRecv;
; 5235 : 
; 5236 : 	if(lpMsg == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpRecv$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 59		 je	 SHORT $LN4@GS_DGAnsTa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000b	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c0		 test	 eax, eax
  00012	74 06		 je	 SHORT $LN7@GS_DGAnsTa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00018	eb 03		 jmp	 SHORT $LN6@GS_DGAnsTa
$LN7@GS_DGAnsTa:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN6@GS_DGAnsTa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5239 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 13		 je	 SHORT $LN3@GS_DGAnsTa

; 5240 : 	{
; 5241 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x07] GS_DGAnsTaxRateChange() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0HL@PMPBBPDM@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
  00035	5e		 pop	 esi

; 5249 : 	}
; 5250 : #endif
; 5251 : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN3@GS_DGAnsTa:

; 5242 : 		return;
; 5243 : 	}
; 5244 : 
; 5245 : 	if(lpMsg->iResult == 1)

  00038	83 7e 04 01	 cmp	 DWORD PTR [esi+4], 1
  0003c	75 26		 jne	 SHORT $LN4@GS_DGAnsTa

; 5246 : 	{
; 5247 : 		g_CastleSiege.SetTaxRate(lpMsg->iTaxKind,lpMsg->iTaxRate);

  0003e	ff 76 14	 push	 DWORD PTR [esi+20]
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00046	ff 76 10	 push	 DWORD PTR [esi+16]
  00049	e8 00 00 00 00	 call	 ?SetTaxRate@CCastleSiege@@QAEXHH@Z ; CCastleSiege::SetTaxRate

; 5248 : 		GCAnsTaxRateChange(lpMsg->iIndex,lpMsg->iResult,lpMsg->iTaxKind,lpMsg->iTaxRate);

  0004e	ff 76 14	 push	 DWORD PTR [esi+20]
  00051	0f b6 46 10	 movzx	 eax, BYTE PTR [esi+16]
  00055	50		 push	 eax
  00056	ff 76 04	 push	 DWORD PTR [esi+4]
  00059	ff 76 0c	 push	 DWORD PTR [esi+12]
  0005c	e8 00 00 00 00	 call	 ?GCAnsTaxRateChange@@YAXHHEH@Z ; GCAnsTaxRateChange
  00061	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@GS_DGAnsTa:
  00064	5e		 pop	 esi

; 5249 : 	}
; 5250 : #endif
; 5251 : }

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?GS_DGAnsTaxRateChange@@YAXPAE@Z ENDP			; GS_DGAnsTaxRateChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsTaxInfo@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsTaxInfo@@YAXPAE@Z PROC				; GS_DGAnsTaxInfo, COMDAT

; 5200 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5201 : #if (GS_CASTLE == 1)
; 5202 : 	CSP_ANS_TAXINFO * lpMsg = (CSP_ANS_TAXINFO*)lpRecv;
; 5203 : 
; 5204 : 	if(lpMsg == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpRecv$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 60		 je	 SHORT $LN4@GS_DGAnsTa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000b	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c0		 test	 eax, eax
  00012	74 06		 je	 SHORT $LN7@GS_DGAnsTa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00018	eb 03		 jmp	 SHORT $LN6@GS_DGAnsTa
$LN7@GS_DGAnsTa:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN6@GS_DGAnsTa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5207 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 13		 je	 SHORT $LN3@GS_DGAnsTa

; 5208 : 	{
; 5209 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x06] GS_DGAnsTaxInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0HF@NIPKIGMO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
  00035	5e		 pop	 esi

; 5217 : 	}
; 5218 : #endif
; 5219 : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
$LN3@GS_DGAnsTa:

; 5210 : 		return;
; 5211 : 	}
; 5212 : 
; 5213 : 	if(lpMsg->iResult == 1)

  00038	83 7e 04 01	 cmp	 DWORD PTR [esi+4], 1
  0003c	75 2d		 jne	 SHORT $LN4@GS_DGAnsTa

; 5214 : 	{
; 5215 : 		GCAnsTaxMoneyInfo(lpMsg->iIndex,lpMsg->iResult,lpMsg->iTaxRateChaos,lpMsg->iTaxRateStore,lpMsg->i64CastleMoney);

  0003e	ff 76 14	 push	 DWORD PTR [esi+20]
  00041	0f b6 46 1c	 movzx	 eax, BYTE PTR [esi+28]
  00045	ff 76 10	 push	 DWORD PTR [esi+16]
  00048	50		 push	 eax
  00049	0f b6 46 18	 movzx	 eax, BYTE PTR [esi+24]
  0004d	50		 push	 eax
  0004e	6a 01		 push	 1
  00050	ff 76 0c	 push	 DWORD PTR [esi+12]
  00053	e8 00 00 00 00	 call	 ?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z ; GCAnsTaxMoneyInfo
  00058	83 c4 18	 add	 esp, 24			; 00000018H

; 5216 : 		g_CastleSiege.SetCastleMoney(lpMsg->i64CastleMoney);

  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00060	ff 76 14	 push	 DWORD PTR [esi+20]
  00063	ff 76 10	 push	 DWORD PTR [esi+16]
  00066	e8 00 00 00 00	 call	 ?SetCastleMoney@CCastleSiege@@QAEX_J@Z ; CCastleSiege::SetCastleMoney
$LN4@GS_DGAnsTa:
  0006b	5e		 pop	 esi

; 5217 : 	}
; 5218 : #endif
; 5219 : }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?GS_DGAnsTaxInfo@@YAXPAE@Z ENDP				; GS_DGAnsTaxInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleNpcUpgrade@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleNpcUpgrade@@YAXPAE@Z PROC		; GS_DGAnsCastleNpcUpgrade, COMDAT

; 5158 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5159 : #if (GS_CASTLE == 1)
; 5160 : 	CSP_ANS_NPCUPGRADE * lpMsg = (CSP_ANS_NPCUPGRADE*)lpRecv;
; 5161 : 
; 5162 : 	if(lpMsg == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpRecv$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 84 a1 00 00
	00		 je	 $LN1@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000f	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00014	85 c0		 test	 eax, eax
  00016	74 06		 je	 SHORT $LN8@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00018	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0001c	eb 03		 jmp	 SHORT $LN7@GS_DGAnsCa
$LN8@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  0001e	83 c9 ff	 or	 ecx, -1
$LN7@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5165 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  00021	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00025	3b c1		 cmp	 eax, ecx
  00027	74 13		 je	 SHORT $LN3@GS_DGAnsCa

; 5166 : 	{
; 5167 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x05] GS_DGAnsCastleNpcUpgrade() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@HLBFNNIO@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002e	6a 02		 push	 2
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00036	83 c4 08	 add	 esp, 8
  00039	5e		 pop	 esi

; 5184 : #endif
; 5185 : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN3@GS_DGAnsCa:

; 5168 : 		return;
; 5169 : 	}
; 5170 : 
; 5171 : 	if(lpMsg->iResult == FALSE)

  0003c	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00040	75 1e		 jne	 SHORT $LN4@GS_DGAnsCa

; 5172 : 	{
; 5173 : 		LogAddC(2,"[CastleSiege] ERROR - Castle NPC Upgrade Fail() (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)",

  00042	ff 76 1c	 push	 DWORD PTR [esi+28]
  00045	ff 76 18	 push	 DWORD PTR [esi+24]
  00048	ff 76 14	 push	 DWORD PTR [esi+20]
  0004b	ff 76 10	 push	 DWORD PTR [esi+16]
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@NIOIKHAG@?$FLCastleSiege?$FN?5ERROR?5?9?5Castle?5NPC@
  00053	6a 02		 push	 2
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0005b	83 c4 18	 add	 esp, 24			; 00000018H

; 5174 : 			lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);
; 5175 : 	}
; 5176 : 	else

  0005e	eb 36		 jmp	 SHORT $LN5@GS_DGAnsCa
$LN4@GS_DGAnsCa:

; 5177 : 	{
; 5178 : 		g_CastleSiege.UpgradeDbNPC(lpMsg->iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,lpMsg->iNpcUpIndex);

  00060	ff 76 20	 push	 DWORD PTR [esi+32]
  00063	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00068	ff 76 1c	 push	 DWORD PTR [esi+28]
  0006b	ff 76 18	 push	 DWORD PTR [esi+24]
  0006e	ff 76 14	 push	 DWORD PTR [esi+20]
  00071	ff 76 10	 push	 DWORD PTR [esi+16]
  00074	ff 76 0c	 push	 DWORD PTR [esi+12]
  00077	e8 00 00 00 00	 call	 ?UpgradeDbNPC@CCastleSiege@@QAEHHHHHHH@Z ; CCastleSiege::UpgradeDbNPC

; 5179 : 		LogAddTD("[CastleSiege] [0x80][0x06] GS_DGAnsTaxInfo() - Npc Upgrade OK (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)",

  0007c	ff 76 1c	 push	 DWORD PTR [esi+28]
  0007f	ff 76 18	 push	 DWORD PTR [esi+24]
  00082	ff 76 14	 push	 DWORD PTR [esi+20]
  00085	ff 76 10	 push	 DWORD PTR [esi+16]
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@HOFNMLEH@?$FLCastleSiege?$FN?5?$FL0x80?$FN?$FL0x06?$FN?5GS_DG@
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00093	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@GS_DGAnsCa:

; 5180 : 			lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);
; 5181 : 	}
; 5182 : 
; 5183 : 	GCAnsNpcUpgrade(lpMsg->iIndex,lpMsg->iResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  00096	ff 76 1c	 push	 DWORD PTR [esi+28]
  00099	ff 76 18	 push	 DWORD PTR [esi+24]
  0009c	ff 76 14	 push	 DWORD PTR [esi+20]
  0009f	ff 76 10	 push	 DWORD PTR [esi+16]
  000a2	ff 76 04	 push	 DWORD PTR [esi+4]
  000a5	ff 76 0c	 push	 DWORD PTR [esi+12]
  000a8	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade
  000ad	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@GS_DGAnsCa:
  000b0	5e		 pop	 esi

; 5184 : #endif
; 5185 : }

  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?GS_DGAnsCastleNpcUpgrade@@YAXPAE@Z ENDP		; GS_DGAnsCastleNpcUpgrade
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleNpcRepair@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleNpcRepair@@YAXPAE@Z PROC			; GS_DGAnsCastleNpcRepair, COMDAT

; 5097 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5098 : #if (GS_CASTLE == 1)
; 5099 : 	CSP_ANS_NPCREPAIR * lpMsg = (CSP_ANS_NPCREPAIR*)lpRecv;
; 5100 : 
; 5101 : 	if(lpMsg == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpRecv$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 84 14 01 00
	00		 je	 $LN5@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000f	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00014	85 c0		 test	 eax, eax
  00016	74 06		 je	 SHORT $LN12@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00018	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0001c	eb 03		 jmp	 SHORT $LN11@GS_DGAnsCa
$LN12@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  0001e	83 c9 ff	 or	 ecx, -1
$LN11@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5104 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  00021	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00025	3b c1		 cmp	 eax, ecx
  00027	74 13		 je	 SHORT $LN3@GS_DGAnsCa

; 5105 : 	{
; 5106 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x04] GS_DGAnsCastleNpcRepair() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@PMNAMEJH@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002e	6a 02		 push	 2
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00036	83 c4 08	 add	 esp, 8
  00039	5e		 pop	 esi

; 5140 : 	}
; 5141 : #endif
; 5142 : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN3@GS_DGAnsCa:

; 5107 : 		return;
; 5108 : 	}
; 5109 : 
; 5110 : 	if(lpMsg->iResult == 1)

  0003c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003f	83 f8 01	 cmp	 eax, 1
  00042	0f 85 af 00 00
	00		 jne	 $LN4@GS_DGAnsCa

; 5111 : 	{
; 5112 : 		int bRETVAL = g_CastleSiege.RepairDbNPC(lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcHp,lpMsg->iNpcMaxHp);

  00048	ff 76 18	 push	 DWORD PTR [esi+24]
  0004b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00050	ff 76 1c	 push	 DWORD PTR [esi+28]
  00053	ff 76 14	 push	 DWORD PTR [esi+20]
  00056	ff 76 10	 push	 DWORD PTR [esi+16]
  00059	e8 00 00 00 00	 call	 ?RepairDbNPC@CCastleSiege@@QAEHHHHH@Z ; CCastleSiege::RepairDbNPC

; 5113 : 
; 5114 : 		if(bRETVAL == TRUE)

  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 7d		 jne	 SHORT $LN6@GS_DGAnsCa

; 5115 : 		{
; 5116 : 			if(gObjIsConnected(lpMsg->iIndex))

  00063	ff 76 0c	 push	 DWORD PTR [esi+12]
  00066	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0006b	83 c4 04	 add	 esp, 4
  0006e	85 c0		 test	 eax, eax
  00070	74 57		 je	 SHORT $LN8@GS_DGAnsCa

; 5117 : 			{
; 5118 : 				gObj[lpMsg->iIndex].Money -= lpMsg->iRepairCost;

  00072	69 4e 0c 40 27
	00 00		 imul	 ecx, DWORD PTR [esi+12], 10048
  00079	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0007c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00082	29 81 cc 00 00
	00		 sub	 DWORD PTR [ecx+204], eax

; 5119 : 
; 5120 : 				if(gObj[lpMsg->iIndex].Money < 0)

  00088	69 46 0c 40 27
	00 00		 imul	 eax, DWORD PTR [esi+12], 10048
  0008f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00095	83 bc 10 cc 00
	00 00 00	 cmp	 DWORD PTR [eax+edx+204], 0
  0009d	7d 11		 jge	 SHORT $LN9@GS_DGAnsCa

; 5121 : 					gObj[lpMsg->iIndex].Money = 0;

  0009f	c7 84 10 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx+204], 0
  000aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN9@GS_DGAnsCa:

; 5122 : 
; 5123 : 				GCMoneySend(lpMsg->iIndex,gObj[lpMsg->iIndex].Money);

  000b0	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000b3	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  000b9	ff b4 10 cc 00
	00 00		 push	 DWORD PTR [eax+edx+204]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  000c6	83 c4 08	 add	 esp, 8
$LN8@GS_DGAnsCa:

; 5124 : 			}
; 5125 : 
; 5126 : 			LogAddTD("[CastleSiege] GS_DGAnsCastleNpcRepair() - CCastleSiege::RepairDbNPC() OK - Npc:(CLS:%d, IDX:%d)",

  000c9	ff 76 14	 push	 DWORD PTR [esi+20]
  000cc	ff 76 10	 push	 DWORD PTR [esi+16]
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@JLLACOMH@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dd	5e		 pop	 esi

; 5140 : 	}
; 5141 : #endif
; 5142 : }

  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN6@GS_DGAnsCa:

; 5127 : 				lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 5128 : 		}
; 5129 : 		else
; 5130 : 		{
; 5131 : 			LogAddTD("[CastleSiege] GS_DGAnsCastleNpcRepair() - CCastleSiege::RepairDbNPC() FAILED - Npc:(CLS:%d, IDX:%d)",

  000e0	ff 76 14	 push	 DWORD PTR [esi+20]
  000e3	ff 76 10	 push	 DWORD PTR [esi+16]
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@FAGFLPLN@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	5e		 pop	 esi

; 5140 : 	}
; 5141 : #endif
; 5142 : }

  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
$LN4@GS_DGAnsCa:

; 5132 : 				lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 5133 : 		}
; 5134 : 	}
; 5135 : 	else
; 5136 : 	{
; 5137 : 		LogAddTD("[CastleSiege] GS_DGAnsCastleNpcRepair() FAILED - Result:(%d), Npc:(CLS:%d, IDX:%d)",

  000f7	ff 76 14	 push	 DWORD PTR [esi+20]
  000fa	ff 76 10	 push	 DWORD PTR [esi+16]
  000fd	50		 push	 eax
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@BEMJCHLC@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcR@
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5138 : 			lpMsg->iResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 5139 : 		GCAnsNpcRepair(lpMsg->iIndex,lpMsg->iResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcHp,lpMsg->iNpcMaxHp);

  00109	ff 76 18	 push	 DWORD PTR [esi+24]
  0010c	ff 76 1c	 push	 DWORD PTR [esi+28]
  0010f	ff 76 14	 push	 DWORD PTR [esi+20]
  00112	ff 76 10	 push	 DWORD PTR [esi+16]
  00115	ff 76 04	 push	 DWORD PTR [esi+4]
  00118	ff 76 0c	 push	 DWORD PTR [esi+12]
  0011b	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair
  00120	83 c4 28	 add	 esp, 40			; 00000028H
$LN5@GS_DGAnsCa:
  00123	5e		 pop	 esi

; 5140 : 	}
; 5141 : #endif
; 5142 : }

  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
?GS_DGAnsCastleNpcRepair@@YAXPAE@Z ENDP			; GS_DGAnsCastleNpcRepair
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleNpcBuy@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleNpcBuy@@YAXPAE@Z PROC			; GS_DGAnsCastleNpcBuy, COMDAT

; 5033 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5034 : #if (GS_CASTLE == 1)
; 5035 : 	CSP_ANS_NPCBUY * lpMsg = (CSP_ANS_NPCBUY *)lpRecv;
; 5036 : 
; 5037 : 	if(lpMsg == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpRecv$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 84 03 01 00
	00		 je	 $LN1@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000f	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00014	85 c0		 test	 eax, eax
  00016	74 06		 je	 SHORT $LN12@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00018	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0001c	eb 03		 jmp	 SHORT $LN11@GS_DGAnsCa
$LN12@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  0001e	83 c9 ff	 or	 ecx, -1
$LN11@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5040 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  00021	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00025	3b c1		 cmp	 eax, ecx
  00027	74 13		 je	 SHORT $LN3@GS_DGAnsCa

; 5041 : 	{
; 5042 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x03] GS_DGAnsCastleNpcBuy() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0HK@OKLAENCI@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002e	6a 02		 push	 2
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00036	83 c4 08	 add	 esp, 8
  00039	5e		 pop	 esi

; 5080 : #endif
; 5081 : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN3@GS_DGAnsCa:

; 5043 : 		return;
; 5044 : 	}
; 5045 : 
; 5046 : 	if(lpMsg->iResult == 1)
; 5047 : 	{
; 5048 : 		int bRETVAL = g_CastleSiege.AddDbNPC(lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  0003c	ff 76 14	 push	 DWORD PTR [esi+20]
  0003f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00042	ff 76 10	 push	 DWORD PTR [esi+16]
  00045	83 f8 01	 cmp	 eax, 1
  00048	0f 85 a1 00 00
	00		 jne	 $LN4@GS_DGAnsCa
  0004e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00053	e8 00 00 00 00	 call	 ?AddDbNPC@CCastleSiege@@QAEHHH@Z ; CCastleSiege::AddDbNPC

; 5049 : 
; 5050 : 		if(bRETVAL == TRUE)

  00058	83 f8 01	 cmp	 eax, 1
  0005b	75 7c		 jne	 SHORT $LN6@GS_DGAnsCa

; 5051 : 		{
; 5052 : 			if(gObjIsConnected(lpMsg->iIndex))

  0005d	ff 76 0c	 push	 DWORD PTR [esi+12]
  00060	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00065	83 c4 04	 add	 esp, 4
  00068	85 c0		 test	 eax, eax
  0006a	74 57		 je	 SHORT $LN8@GS_DGAnsCa

; 5053 : 			{
; 5054 : 				gObj[lpMsg->iIndex].Money -= lpMsg->iBuyCost;

  0006c	69 4e 0c 40 27
	00 00		 imul	 ecx, DWORD PTR [esi+12], 10048
  00073	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00076	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007c	29 81 cc 00 00
	00		 sub	 DWORD PTR [ecx+204], eax

; 5055 : 
; 5056 : 				if(gObj[lpMsg->iIndex].Money < 0)

  00082	69 46 0c 40 27
	00 00		 imul	 eax, DWORD PTR [esi+12], 10048
  00089	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008f	83 bc 10 cc 00
	00 00 00	 cmp	 DWORD PTR [eax+edx+204], 0
  00097	7d 11		 jge	 SHORT $LN9@GS_DGAnsCa

; 5057 : 				{
; 5058 : 					gObj[lpMsg->iIndex].Money = 0;

  00099	c7 84 10 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [eax+edx+204], 0
  000a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN9@GS_DGAnsCa:

; 5059 : 				}
; 5060 : 
; 5061 : 				GCMoneySend(lpMsg->iIndex,gObj[lpMsg->iIndex].Money);

  000aa	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000ad	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  000b3	ff b4 10 cc 00
	00 00		 push	 DWORD PTR [eax+edx+204]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  000c0	83 c4 08	 add	 esp, 8
$LN8@GS_DGAnsCa:

; 5062 : 			}
; 5063 : 
; 5064 : 			LogAddTD("[CastleSiege] GS_DGAnsCastleNpcBuy() - CCastleSiege::AddDbNPC() OK - Npc:(CLS:%d, IDX:%d)",

  000c3	ff 76 14	 push	 DWORD PTR [esi+20]
  000c6	ff 76 10	 push	 DWORD PTR [esi+16]
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@LDEGMOJD@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5065 : 				lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 5066 : 		}
; 5067 : 		else

  000d7	eb 25		 jmp	 SHORT $LN5@GS_DGAnsCa
$LN6@GS_DGAnsCa:

; 5068 : 		{
; 5069 : 			LogAddTD("[CastleSiege] GS_DGAnsCastleNpcBuy() - CCastleSiege::AddDbNPC() FAILED - Npc:(CLS:%d, IDX:%d)",

  000d9	ff 76 14	 push	 DWORD PTR [esi+20]
  000dc	ff 76 10	 push	 DWORD PTR [esi+16]
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@MKLLBJCJ@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5070 : 				lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 5071 : 		}
; 5072 : 	}
; 5073 : 	else

  000ed	eb 0f		 jmp	 SHORT $LN5@GS_DGAnsCa
$LN4@GS_DGAnsCa:

; 5074 : 	{
; 5075 : 		LogAddTD("[CastleSiege] GS_DGAnsCastleNpcBuy() FAILED - Result:(%d), Npc:(CLS:%d, IDX:%d)",

  000ef	50		 push	 eax
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@BIAOFLEB@?$FLCastleSiege?$FN?5GS_DGAnsCastleNpcB@
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000fb	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@GS_DGAnsCa:

; 5076 : 			lpMsg->iResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 5077 : 	}
; 5078 : 
; 5079 : 	GCAnsNpcBuy(lpMsg->iIndex,lpMsg->iResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  000fe	ff 76 14	 push	 DWORD PTR [esi+20]
  00101	ff 76 10	 push	 DWORD PTR [esi+16]
  00104	ff 76 04	 push	 DWORD PTR [esi+4]
  00107	ff 76 0c	 push	 DWORD PTR [esi+12]
  0010a	e8 00 00 00 00	 call	 ?GCAnsNpcBuy@@YAXHHHH@Z	; GCAnsNpcBuy
  0010f	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@GS_DGAnsCa:
  00112	5e		 pop	 esi

; 5080 : #endif
; 5081 : }

  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
?GS_DGAnsCastleNpcBuy@@YAXPAE@Z ENDP			; GS_DGAnsCastleNpcBuy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsOwnerGuildMaster@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsOwnerGuildMaster@@YAXPAE@Z PROC		; GS_DGAnsOwnerGuildMaster, COMDAT

; 5003 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5004 : #if (GS_CASTLE == 1)
; 5005 : 	CSP_ANS_OWNERGUILDMASTER * lpMsg = (CSP_ANS_OWNERGUILDMASTER *)lpRecv;
; 5006 : 
; 5007 : 	if(lpMsg == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpRecv$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 42		 je	 SHORT $LN1@GS_DGAnsOw
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN6@GS_DGAnsOw

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00013	0f b6 50 08	 movzx	 edx, BYTE PTR [eax+8]
  00017	eb 03		 jmp	 SHORT $LN5@GS_DGAnsOw
$LN6@GS_DGAnsOw:

; 58   : 		}
; 59   : 		return -1;

  00019	83 ca ff	 or	 edx, -1
$LN5@GS_DGAnsOw:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 5010 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001c	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  00020	3b c2		 cmp	 eax, edx
  00022	74 12		 je	 SHORT $LN3@GS_DGAnsOw

; 5011 : 	{
; 5012 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x00] GS_DGAnsCastleTotalInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@BJMCOPEN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  00029	6a 02		 push	 2
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00031	83 c4 08	 add	 esp, 8

; 5017 : #endif
; 5018 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN3@GS_DGAnsOw:

; 5013 : 		return;
; 5014 : 	}
; 5015 : 
; 5016 : 	GCAnsCastleSiegeState(lpMsg->iIndex,lpMsg->iResult,lpMsg->szCastleOwnGuild,lpMsg->szCastleOwnGuildMaster);

  00036	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00039	50		 push	 eax
  0003a	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  0003d	50		 push	 eax
  0003e	ff 71 04	 push	 DWORD PTR [ecx+4]
  00041	ff 71 0c	 push	 DWORD PTR [ecx+12]
  00044	e8 00 00 00 00	 call	 ?GCAnsCastleSiegeState@@YAXHHPAD0@Z ; GCAnsCastleSiegeState
  00049	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@GS_DGAnsOw:

; 5017 : #endif
; 5018 : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GS_DGAnsOwnerGuildMaster@@YAXPAE@Z ENDP		; GS_DGAnsOwnerGuildMaster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_DGAnsCastleTotalInfo@@YAXPAE@Z
_TEXT	SEGMENT
_lpRecv$ = 8						; size = 4
?GS_DGAnsCastleTotalInfo@@YAXPAE@Z PROC			; GS_DGAnsCastleTotalInfo, COMDAT

; 4978 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4979 : #if (GS_CASTLE == 1)
; 4980 : 	CSP_ANS_CASTLEDATA * lpMsg = (CSP_ANS_CASTLEDATA *)lpRecv;
; 4981 : 
; 4982 : 	if(lpMsg == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpRecv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2b		 je	 SHORT $LN3@GS_DGAnsCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0000a	8b 0d f8 6a 01
	00		 mov	 ecx, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00010	85 c9		 test	 ecx, ecx
  00012	74 06		 je	 SHORT $LN6@GS_DGAnsCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00014	0f b6 49 08	 movzx	 ecx, BYTE PTR [ecx+8]
  00018	eb 03		 jmp	 SHORT $LN5@GS_DGAnsCa
$LN6@GS_DGAnsCa:

; 58   : 		}
; 59   : 		return -1;

  0001a	83 c9 ff	 or	 ecx, -1
$LN5@GS_DGAnsCa:
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4985 : 	if(lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup())

  0001d	0f b7 40 08	 movzx	 eax, WORD PTR [eax+8]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 10		 je	 SHORT $LN3@GS_DGAnsCa

; 4986 : 	{
; 4987 : 		LogAddC(2,"[CastleSiege] PACKET-ERROR [0x80][0x00] GS_DGAnsCastleTotalInfo() - lpMsg->wMapSvrNum != g_MapServerManager.GetMapSvrGroup()");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@BJMCOPEN@?$FLCastleSiege?$FN?5PACKET?9ERROR?5?$FL0x80@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00032	83 c4 08	 add	 esp, 8
$LN3@GS_DGAnsCa:

; 4988 : 	}
; 4989 : #endif
; 4990 : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GS_DGAnsCastleTotalInfo@@YAXPAE@Z ENDP			; GS_DGAnsCastleTotalInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCsLoadTotalGuildInfo@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqCsLoadTotalGuildInfo@@YAXH@Z PROC		; GS_GDReqCsLoadTotalGuildInfo, COMDAT

; 4865 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4866 : 	if ( iMapSvrGroup < 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 1e		 js	 SHORT $LN1@GS_GDReqCs

; 4867 : 	{
; 4868 : 		return;
; 4869 : 	}
; 4870 : 
; 4871 : 	CSP_REQ_CSLOADTOTALGUILDINFO pMsg;
; 4872 : 
; 4873 : 	pMsg.h.set((LPBYTE)&pMsg, 0x88, sizeof(CSP_REQ_CSLOADTOTALGUILDINFO));
; 4874 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0000d	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4876 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00016	6a 06		 push	 6
  00018	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  0001b	66 c7 45 f8 c1
	06		 mov	 WORD PTR _pMsg$[ebp], 1729 ; 000006c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4876 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00021	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 88   : 		lpBuf[2] = head;

  00022	c6 45 fa 88	 mov	 BYTE PTR _pMsg$[ebp+2], 136 ; 00000088H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4876 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00026	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCs:

; 4877 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GS_GDReqCsLoadTotalGuildInfo@@YAXH@Z ENDP		; GS_GDReqCsLoadTotalGuildInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCalcRegGuildList@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqCalcRegGuildList@@YAXH@Z PROC			; GS_GDReqCalcRegGuildList, COMDAT

; 4835 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4836 : 	if ( iMapSvrGroup < 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 1e		 js	 SHORT $LN1@GS_GDReqCa

; 4837 : 	{
; 4838 : 		return;
; 4839 : 	}
; 4840 : 
; 4841 : 	CSP_REQ_CALCREGGUILDLIST pMsg;
; 4842 : 
; 4843 : 	pMsg.h.set((LPBYTE)&pMsg, 0x85, sizeof(CSP_REQ_CALCREGGUILDLIST));
; 4844 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0000d	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4846 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00016	6a 06		 push	 6
  00018	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  0001b	66 c7 45 f8 c1
	06		 mov	 WORD PTR _pMsg$[ebp], 1729 ; 000006c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4846 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00021	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 88   : 		lpBuf[2] = head;

  00022	c6 45 fa 85	 mov	 BYTE PTR _pMsg$[ebp+2], 133 ; 00000085H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4846 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00026	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 4847 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GS_GDReqCalcRegGuildList@@YAXH@Z ENDP			; GS_GDReqCalcRegGuildList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z PROC		; GS_GDReqAllGuildMarkRegInfo, COMDAT

; 4805 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4806 : 	if ( iMapSvrGroup < 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 24		 js	 SHORT $LN1@GS_GDReqAl

; 4807 : 	{
; 4808 : 		return;
; 4809 : 	}
; 4810 : 
; 4811 : 	CSP_REQ_ALLGUILDREGINFO pMsg;
; 4812 : 
; 4813 : 	pMsg.h.set((LPBYTE)&pMsg, 0x83, sizeof(CSP_REQ_ALLGUILDREGINFO));
; 4814 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00017	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4817 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00020	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00026	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  0002c	66 c7 45 f0 c1
	0c		 mov	 WORD PTR _pMsg$[ebp], 3265 ; 00000cc1H

; 87   : 		lpBuf[1] = size;
; 88   : 		lpBuf[2] = head;

  00032	c6 45 f2 83	 mov	 BYTE PTR _pMsg$[ebp+2], 131 ; 00000083H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4817 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00036	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqAl:

; 4818 : }

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	33 cd		 xor	 ecx, ebp
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z ENDP		; GS_GDReqAllGuildMarkRegInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCastleInitData@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCastleEventCycle$ = 12				; size = 4
?GS_GDReqCastleInitData@@YAXHH@Z PROC			; GS_GDReqCastleInitData, COMDAT

; 4739 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4740 : 	if ( iMapSvrGroup < 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 24		 js	 SHORT $LN1@GS_GDReqCa

; 4741 : 	{
; 4742 : 		return;
; 4743 : 	}
; 4744 : 
; 4745 : 	CSP_REQ_CSINITDATA pMsg;
; 4746 : 
; 4747 : 	pMsg.h.set((LPBYTE)&pMsg, 0x81, sizeof(CSP_REQ_CSINITDATA));
; 4748 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00017	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4751 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00020	8b 45 0c	 mov	 eax, DWORD PTR _iCastleEventCycle$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00026	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  0002c	66 c7 45 f0 c1
	0c		 mov	 WORD PTR _pMsg$[ebp], 3265 ; 00000cc1H

; 87   : 		lpBuf[1] = size;
; 88   : 		lpBuf[2] = head;

  00032	c6 45 f2 81	 mov	 BYTE PTR _pMsg$[ebp+2], 129 ; 00000081H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4751 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00036	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 4752 : }

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	33 cd		 xor	 ecx, ebp
  00040	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?GS_GDReqCastleInitData@@YAXHH@Z ENDP			; GS_GDReqCastleInitData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqResetSiegeGuildInfo@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqResetSiegeGuildInfo@@YAXH@Z PROC		; GS_GDReqResetSiegeGuildInfo, COMDAT

; 4675 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4676 : 	if ( iMapSvrGroup < 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 1b		 js	 SHORT $LN1@GS_GDReqRe

; 4677 : 	{
; 4678 : 		return;
; 4679 : 	}
; 4680 : 
; 4681 : 	CSP_REQ_RESETSIEGEGUILDINFO pMsg;
; 4682 : 
; 4683 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x1A, sizeof(CSP_REQ_RESETSIEGEGUILDINFO));
; 4684 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0000d	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4686 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00016	6a 06		 push	 6
  00018	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0001b	c7 45 f8 c1 06
	80 1a		 mov	 DWORD PTR _pMsg$[ebp], 444597953 ; 1a8006c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4686 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqRe:

; 4687 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?GS_GDReqResetSiegeGuildInfo@@YAXH@Z ENDP		; GS_GDReqResetSiegeGuildInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqResetCastleTaxInfo@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqResetCastleTaxInfo@@YAXH@Z PROC		; GS_GDReqResetCastleTaxInfo, COMDAT

; 4645 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4646 : 	if ( iMapSvrGroup < 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 1b		 js	 SHORT $LN1@GS_GDReqRe

; 4647 : 	{
; 4648 : 		return;
; 4649 : 	}
; 4650 : 
; 4651 : 	CSP_REQ_RESETCASTLETAXINFO pMsg;
; 4652 : 
; 4653 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x19, sizeof(CSP_REQ_RESETCASTLETAXINFO));
; 4654 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0000d	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4656 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00016	6a 06		 push	 6
  00018	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0001b	c7 45 f8 c1 06
	80 19		 mov	 DWORD PTR _pMsg$[ebp], 427820737 ; 198006c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4656 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqRe:

; 4657 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?GS_GDReqResetCastleTaxInfo@@YAXH@Z ENDP		; GS_GDReqResetCastleTaxInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCastleTributeMoney@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCastleTributeMoney$ = 12				; size = 4
?GS_GDReqCastleTributeMoney@@YAXHH@Z PROC		; GS_GDReqCastleTributeMoney, COMDAT

; 4608 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4609 : 	if ( iMapSvrGroup < 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 25		 js	 SHORT $LN1@GS_GDReqCa

; 4610 : 	{
; 4611 : 		return;
; 4612 : 	}
; 4613 : 
; 4614 : 	if ( iCastleTributeMoney < 0 )

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _iCastleTributeMoney$[ebp]
  0001a	85 c9		 test	 ecx, ecx
  0001c	78 1e		 js	 SHORT $LN1@GS_GDReqCa

; 4615 : 	{
; 4616 : 		return;
; 4617 : 	}
; 4618 : 
; 4619 : 	CSP_REQ_CASTLETRIBUTEMONEY pMsg;
; 4620 : 
; 4621 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x18, sizeof(CSP_REQ_CASTLETRIBUTEMONEY));
; 4622 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0001e	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4625 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00022	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00025	6a 0c		 push	 12			; 0000000cH
  00027	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0002f	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00030	c7 45 f0 c1 0c
	80 18		 mov	 DWORD PTR _pMsg$[ebp], 411045057 ; 18800cc1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4625 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00037	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 4626 : }

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003f	33 cd		 xor	 ecx, ebp
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?GS_GDReqCastleTributeMoney@@YAXHH@Z ENDP		; GS_GDReqCastleTributeMoney
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCastleStateSync@@YAXHHHHHPAD@Z
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCastleState$ = 12					; size = 4
_iTaxRateChaos$ = 16					; size = 4
_iTaxRateStore$ = 20					; size = 4
_iTaxHuntZone$ = 24					; size = 4
_lpszOwnerGuild$ = 28					; size = 4
?GS_GDReqCastleStateSync@@YAXHHHHHPAD@Z PROC		; GS_GDReqCastleStateSync, COMDAT

; 4569 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4570 : 	if ( iMapSvrGroup < 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	8b 4d 1c	 mov	 ecx, DWORD PTR _lpszOwnerGuild$[ebp]
  00016	85 c0		 test	 eax, eax
  00018	78 3e		 js	 SHORT $LN1@GS_GDReqCa

; 4571 : 	{
; 4572 : 		return;
; 4573 : 	}
; 4574 : 
; 4575 : 	CSP_REQ_CASTLESTATESYNC pMsg;
; 4576 : 
; 4577 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x17, sizeof(CSP_REQ_CASTLESTATESYNC));
; 4578 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0001a	66 89 45 e0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4579 : 	pMsg.iCastleState = iCastleState;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _iCastleState$[ebp]
  00021	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4580 : 	pMsg.iTaxRateChaos = iTaxRateChaos;

  00024	8b 45 10	 mov	 eax, DWORD PTR _iTaxRateChaos$[ebp]
  00027	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 4581 : 	pMsg.iTaxRateStore = iTaxRateStore;

  0002a	8b 45 14	 mov	 eax, DWORD PTR _iTaxRateStore$[ebp]
  0002d	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 4582 : 	pMsg.iTaxHuntZone = iTaxHuntZone;

  00030	8b 45 18	 mov	 eax, DWORD PTR _iTaxHuntZone$[ebp]
  00033	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 4583 : 	memcpy(pMsg.szOwnerGuildName, lpszOwnerGuild, 8);

  00036	8b 01		 mov	 eax, DWORD PTR [ecx]
  00038	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  0003b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 4585 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00043	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+28], eax
  00046	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00049	6a 20		 push	 32			; 00000020H
  0004b	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0004c	c7 45 dc c1 20
	80 17		 mov	 DWORD PTR _pMsg$[ebp], 394272961 ; 178020c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4585 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00053	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 4586 : }

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	33 cd		 xor	 ecx, ebp
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?GS_GDReqCastleStateSync@@YAXHHHHHPAD@Z ENDP		; GS_GDReqCastleStateSync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqNpcRemove@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iNpcNumber$ = 12					; size = 4
_iNpcIndex$ = 16					; size = 4
?GS_GDReqNpcRemove@@YAXHHH@Z PROC			; GS_GDReqNpcRemove, COMDAT

; 4532 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4533 : 	if ( iMapSvrGroup < 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 27		 js	 SHORT $LN1@GS_GDReqNp

; 4534 : 	{
; 4535 : 		return;
; 4536 : 	}
; 4537 : 
; 4538 : 	CSP_REQ_NPCREMOVE pMsg;
; 4539 : 
; 4540 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x16, sizeof(CSP_REQ_NPCREMOVE));
; 4541 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00017	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4545 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00020	8b 45 0c	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  00023	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00026	8b 45 10	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  00029	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  0002c	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002f	6a 10		 push	 16			; 00000010H
  00031	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00032	c7 45 ec c1 10
	80 16		 mov	 DWORD PTR _pMsg$[ebp], 377491649 ; 168010c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4545 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00039	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqNp:

; 4546 : }

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00041	33 cd		 xor	 ecx, ebp
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?GS_GDReqNpcRemove@@YAXHHH@Z ENDP			; GS_GDReqNpcRemove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqGuildSetGiveUp@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_bIsGiveUp$ = 16					; size = 4
?GS_GDReqGuildSetGiveUp@@YAXHHH@Z PROC			; GS_GDReqGuildSetGiveUp, COMDAT

; 4491 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4492 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00016	85 d2		 test	 edx, edx
  00018	78 57		 js	 SHORT $LN1@GS_GDReqGu

; 4493 : 	{
; 4494 : 		return;
; 4495 : 	}
; 4496 : 
; 4497 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  0001a	85 c9		 test	 ecx, ecx
  0001c	78 53		 js	 SHORT $LN1@GS_GDReqGu
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 44		 je	 SHORT $LN1@GS_GDReqGu

; 4498 : 	{
; 4499 : 		return;
; 4500 : 	}
; 4501 : 
; 4502 : 	CSP_REQ_GUILDSETGIVEUP pMsg;
; 4503 : 
; 4504 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x12, sizeof(CSP_REQ_GUILDSETGIVEUP));
; 4505 : 	pMsg.wMapSvrNum = iMapSvrGroup;
; 4506 : 	pMsg.iIndex = aIndex;
; 4507 : 	pMsg.bIsGiveUp = bIsGiveUp;

  0002d	8b 45 10	 mov	 eax, DWORD PTR _bIsGiveUp$[ebp]
  00030	66 89 55 e8	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 4508 : 	memcpy(pMsg.szGuildName, gObj[aIndex].GuildName, 8);

  00034	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  0003a	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+20], eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00046	c7 45 e4 c1 18
	80 12		 mov	 DWORD PTR _pMsg$[ebp], 310384833 ; 128018c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4510 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0004d	6a 18		 push	 24			; 00000018H
  0004f	8b 84 0a 1c 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1564]
  00056	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00059	8b 84 0a 20 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1568]
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00065	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00068	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqGu:

; 4511 : }

  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	33 cd		 xor	 ecx, ebp
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?GS_GDReqGuildSetGiveUp@@YAXHHH@Z ENDP			; GS_GDReqGuildSetGiveUp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqGuildMarkReset@@YAXHHPAD@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_lpszGuildName$ = 16					; size = 4
?GS_GDReqGuildMarkReset@@YAXHHPAD@Z PROC		; GS_GDReqGuildMarkReset, COMDAT

; 4446 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 10	 mov	 edx, DWORD PTR _lpszGuildName$[ebp]
  00013	56		 push	 esi

; 4447 : 	if ( iMapSvrGroup < 0 )

  00014	8b 75 08	 mov	 esi, DWORD PTR _iMapSvrGroup$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	78 43		 js	 SHORT $LN1@GS_GDReqGu

; 4448 : 	{
; 4449 : 		return;
; 4450 : 	}
; 4451 : 
; 4452 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001e	85 c9		 test	 ecx, ecx
  00020	78 3c		 js	 SHORT $LN1@GS_GDReqGu
  00022	33 c0		 xor	 eax, eax
  00024	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	74 2d		 je	 SHORT $LN1@GS_GDReqGu

; 4453 : 	{
; 4454 : 		return;
; 4455 : 	}
; 4456 : 
; 4457 : 	if ( lpszGuildName == NULL )

  00031	85 d2		 test	 edx, edx
  00033	74 29		 je	 SHORT $LN1@GS_GDReqGu

; 4466 : 	pMsg.iIndex = aIndex;
; 4467 : 	memcpy(pMsg.szGuildName, lpszGuildName, 8);

  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  0003a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003d	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 4468 : 	
; 4469 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00040	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00043	6a 14		 push	 20			; 00000014H
  00045	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0004d	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0004e	c7 45 e8 c1 14
	80 11		 mov	 DWORD PTR _pMsg$[ebp], 293606593 ; 118014c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4465 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00055	66 89 75 ec	 mov	 WORD PTR _pMsg$[ebp+4], si

; 4468 : 	
; 4469 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00059	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqGu:

; 4470 : }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	33 cd		 xor	 ecx, ebp
  00063	5e		 pop	 esi
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?GS_GDReqGuildMarkReset@@YAXHHPAD@Z ENDP		; GS_GDReqGuildMarkReset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqRegGuildMark@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iItemPos$ = 16						; size = 4
?GS_GDReqRegGuildMark@@YAXHHH@Z PROC			; GS_GDReqRegGuildMark, COMDAT

; 4921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4922 : #if (GS_CASTLE == 1)
; 4923 : 	if(iMapSvrGroup < 0)

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00016	85 d2		 test	 edx, edx
  00018	78 57		 js	 SHORT $LN1@GS_GDReqRe

; 4924 : 		return;
; 4925 : 
; 4926 : 	if(OBJMAX_RANGE(aIndex) == FALSE)

  0001a	85 c9		 test	 ecx, ecx
  0001c	78 53		 js	 SHORT $LN1@GS_GDReqRe
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 44		 je	 SHORT $LN1@GS_GDReqRe

; 4927 : 		return;
; 4928 : 
; 4929 : 	CSP_REQ_GUILDREGMARK pMsg;
; 4930 : 
; 4931 : 	pMsg.h.set((PBYTE)&pMsg,0x80,0x10,sizeof(pMsg));
; 4932 : 	pMsg.wMapSvrNum = iMapSvrGroup;
; 4933 : 	pMsg.iIndex = aIndex;
; 4934 : 	pMsg.iItemPos = iItemPos;

  0002d	8b 45 10	 mov	 eax, DWORD PTR _iItemPos$[ebp]
  00030	66 89 55 e8	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 4935 : 	memcpy(pMsg.szGuildName,gObj[aIndex].GuildName,8);

  00034	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  0003a	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  0003d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+20], eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00046	c7 45 e4 c1 18
	80 10		 mov	 DWORD PTR _pMsg$[ebp], 276830401 ; 108018c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4937 : 	cDBSMng.Send((char*)&pMsg,sizeof(pMsg));

  0004d	6a 18		 push	 24			; 00000018H
  0004f	8b 84 0a 1c 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1564]
  00056	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00059	8b 84 0a 20 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1568]
  00060	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00065	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00068	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqRe:

; 4938 : #endif
; 4939 : }

  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	33 cd		 xor	 ecx, ebp
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?GS_GDReqRegGuildMark@@YAXHHH@Z ENDP			; GS_GDReqRegGuildMark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqMapSvrMsgMultiCast@@YAXHPAD@Z
_TEXT	SEGMENT
_pMsg$ = -140						; size = 134
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_lpszMsgText$ = 12					; size = 4
?GS_GDReqMapSvrMsgMultiCast@@YAXHPAD@Z PROC		; GS_GDReqMapSvrMsgMultiCast, COMDAT

; 4363 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4364 : 	if ( iMapSvrGroup < 0 )

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _iMapSvrGroup$[ebp]
  00016	85 c9		 test	 ecx, ecx
  00018	78 4f		 js	 SHORT $LN1@GS_GDReqMa

; 4365 : 	{
; 4366 : 		return;
; 4367 : 	}
; 4368 : 
; 4369 : 	if ( lpszMsgText == NULL )

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _lpszMsgText$[ebp]
  0001d	85 c0		 test	 eax, eax
  0001f	74 48		 je	 SHORT $LN1@GS_GDReqMa

; 4379 : 	strcpy(pMsg.szMsgText, lpszMsgText);

  00021	8d 95 7a ff ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp+6]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00027	c7 85 74 ff ff
	ff c1 86 80 0f	 mov	 DWORD PTR _pMsg$[ebp], 260081345 ; 0f8086c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4378 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00031	66 89 8d 78 ff
	ff ff		 mov	 WORD PTR _pMsg$[ebp+4], cx

; 4379 : 	strcpy(pMsg.szMsgText, lpszMsgText);

  00038	2b d0		 sub	 edx, eax
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL5@GS_GDReqMa:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00045	88 4c 02 ff	 mov	 BYTE PTR [edx+eax-1], cl
  00049	84 c9		 test	 cl, cl
  0004b	75 f3		 jne	 SHORT $LL5@GS_GDReqMa

; 4380 : 	pMsg.szMsgText[127] = 0;
; 4381 : 	
; 4382 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0004d	0f b6 85 75 ff
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00054	50		 push	 eax
  00055	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0005b	88 4d f9	 mov	 BYTE PTR _pMsg$[ebp+133], cl
  0005e	50		 push	 eax
  0005f	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00064	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqMa:

; 4383 : }

  00069	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006c	33 cd		 xor	 ecx, ebp
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?GS_GDReqMapSvrMsgMultiCast@@YAXHPAD@Z ENDP		; GS_GDReqMapSvrMsgMultiCast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqRestartCastleState@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqRestartCastleState@@YAXH@Z PROC		; GS_GDReqRestartCastleState, COMDAT

; 4331 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4332 : 	if ( iMapSvrGroup < 0 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 1b		 js	 SHORT $LN1@GS_GDReqRe

; 4333 : 	{
; 4334 : 		return;
; 4335 : 	}
; 4336 : 
; 4337 : 	CSP_REQ_CASTLESIEGEEND pMsg;
; 4338 : 
; 4339 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0E, sizeof(CSP_REQ_CASTLESIEGEEND));
; 4340 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0000d	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4342 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00016	6a 06		 push	 6
  00018	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0001b	c7 45 f8 c1 06
	80 0e		 mov	 DWORD PTR _pMsg$[ebp], 243271361 ; 0e8006c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4342 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqRe:

; 4343 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?GS_GDReqRestartCastleState@@YAXH@Z ENDP		; GS_GDReqRestartCastleState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqRegAttackGuild@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqRegAttackGuild@@YAXHH@Z PROC			; GS_GDReqRegAttackGuild, COMDAT

; 4292 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4293 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00016	85 d2		 test	 edx, edx
  00018	78 51		 js	 SHORT $LN1@GS_GDReqRe

; 4294 : 	{
; 4295 : 		return;
; 4296 : 	}
; 4297 : 
; 4298 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  0001a	85 c9		 test	 ecx, ecx
  0001c	78 4d		 js	 SHORT $LN1@GS_GDReqRe
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 3e		 je	 SHORT $LN1@GS_GDReqRe

; 4299 : 	{
; 4300 : 		return;
; 4301 : 	}
; 4302 : 
; 4303 : 
; 4304 : 	CSP_REQ_REGATTACKGUILD pMsg;
; 4305 : 
; 4306 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0D, sizeof(CSP_REQ_REGATTACKGUILD));
; 4307 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0002d	66 89 55 ec	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 4308 : 	pMsg.iIndex = aIndex;
; 4309 : 	memcpy(pMsg.szEnemyGuildName, gObj[aIndex].GuildName, 8);

  00031	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  00037	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00040	c7 45 e8 c1 14
	80 0d		 mov	 DWORD PTR _pMsg$[ebp], 226497729 ; 0d8014c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4311 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00047	6a 14		 push	 20			; 00000014H
  00049	8b 84 0a 1c 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1564]
  00050	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00053	8b 84 0a 20 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1568]
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0005f	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00062	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqRe:

; 4312 : }

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006e	33 cd		 xor	 ecx, ebp
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?GS_GDReqRegAttackGuild@@YAXHH@Z ENDP			; GS_GDReqRegAttackGuild
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCastleOwnerChange@@YAXHHPAD@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_bIsCastleOccupied$ = 12				; size = 4
_lpszGuildName$ = 16					; size = 4
?GS_GDReqCastleOwnerChange@@YAXHHPAD@Z PROC		; GS_GDReqCastleOwnerChange, COMDAT

; 4251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4252 : 	if ( iMapSvrGroup < 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _lpszGuildName$[ebp]
  00016	85 c0		 test	 eax, eax
  00018	78 30		 js	 SHORT $LN1@GS_GDReqCa

; 4253 : 	{
; 4254 : 		return;
; 4255 : 	}
; 4256 : 
; 4257 : 	if ( lpszGuildName == NULL )

  0001a	85 c9		 test	 ecx, ecx
  0001c	74 2c		 je	 SHORT $LN1@GS_GDReqCa

; 4258 : 	{
; 4259 : 		return;
; 4260 : 	}
; 4261 : 
; 4262 : 
; 4263 : 	CSP_REQ_CASTLEOWNERCHANGE pMsg;
; 4264 : 
; 4265 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0C, sizeof(CSP_REQ_CASTLEOWNERCHANGE));
; 4266 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0001e	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4267 : 	pMsg.bIsCastleOccupied = bIsCastleOccupied;

  00022	8b 45 0c	 mov	 eax, DWORD PTR _bIsCastleOccupied$[ebp]
  00025	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 4268 : 	memcpy(pMsg.szOwnerGuildName, lpszGuildName, 8);

  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  0002d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 4270 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00030	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00035	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00038	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003b	6a 14		 push	 20			; 00000014H
  0003d	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0003e	c7 45 e8 c1 14
	80 0c		 mov	 DWORD PTR _pMsg$[ebp], 209720513 ; 0c8014c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4270 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00045	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 4271 : }

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004d	33 cd		 xor	 ecx, ebp
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?GS_GDReqCastleOwnerChange@@YAXHHPAD@Z ENDP		; GS_GDReqCastleOwnerChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqSiegeEndedChange@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_bIsSiegeEnded$ = 12					; size = 4
?GS_GDReqSiegeEndedChange@@YAXHH@Z PROC			; GS_GDReqSiegeEndedChange, COMDAT

; 4217 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4218 : 	if ( iMapSvrGroup < 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 21		 js	 SHORT $LN1@GS_GDReqSi

; 4219 : 	{
; 4220 : 		return;
; 4221 : 	}
; 4222 : 
; 4223 : 
; 4224 : 	CSP_REQ_SIEGEENDCHANGE pMsg;
; 4225 : 
; 4226 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x0B, sizeof(CSP_REQ_SIEGEENDCHANGE));
; 4227 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00017	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4230 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00020	8b 45 0c	 mov	 eax, DWORD PTR _bIsSiegeEnded$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00026	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0002c	c7 45 f0 c1 0c
	80 0b		 mov	 DWORD PTR _pMsg$[ebp], 192941249 ; 0b800cc1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4230 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00033	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqSi:

; 4231 : }

  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?GS_GDReqSiegeEndedChange@@YAXHH@Z ENDP			; GS_GDReqSiegeEndedChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqGuildMarkRegInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqGuildMarkRegInfo@@YAXHH@Z PROC			; GS_GDReqGuildMarkRegInfo, COMDAT

; 4880 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4881 : #if (GS_CASTLE == 1)
; 4882 : 	if(iMapSvrGroup < 0)

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00016	85 d2		 test	 edx, edx
  00018	78 51		 js	 SHORT $LN1@GS_GDReqGu

; 4883 : 		return;
; 4884 : 
; 4885 : 	if(OBJMAX_RANGE(aIndex) == FALSE)

  0001a	85 c9		 test	 ecx, ecx
  0001c	78 4d		 js	 SHORT $LN1@GS_GDReqGu
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 3e		 je	 SHORT $LN1@GS_GDReqGu

; 4886 : 		return;
; 4887 : 
; 4888 : 	CSP_REQ_GUILDREGINFO pMsg;
; 4889 : 	pMsg.h.set((PBYTE)&pMsg,0x80,0x0A,sizeof(pMsg));
; 4890 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0002d	66 89 55 ec	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 4891 : 	pMsg.iIndex = aIndex;
; 4892 : 
; 4893 : 	memcpy(pMsg.szGuildName,gObj[aIndex].GuildName,8);

  00031	69 d1 40 27 00
	00		 imul	 edx, ecx, 10048
  00037	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00040	c7 45 e8 c1 14
	80 0a		 mov	 DWORD PTR _pMsg$[ebp], 176166081 ; 0a8014c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4894 : 	cDBSMng.Send((char*)&pMsg,pMsg.h.size);

  00047	6a 14		 push	 20			; 00000014H
  00049	8b 84 0a 1c 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1564]
  00050	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00053	8b 84 0a 20 06
	00 00		 mov	 eax, DWORD PTR [edx+ecx+1568]
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0005f	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00062	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqGu:

; 4895 : #endif
; 4896 : }

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006e	33 cd		 xor	 ecx, ebp
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?GS_GDReqGuildMarkRegInfo@@YAXHH@Z ENDP			; GS_GDReqGuildMarkRegInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqResetRegSiegeInfo@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iMapSvrGroup$ = 8					; size = 4
?GS_GDReqResetRegSiegeInfo@@YAXH@Z PROC			; GS_GDReqResetRegSiegeInfo, COMDAT

; 4942 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4943 : #if (GS_CASTLE == 1)
; 4944 : 	if(iMapSvrGroup < 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c0		 test	 eax, eax
  0000b	78 1b		 js	 SHORT $LN1@GS_GDReqRe

; 4945 : 		return;
; 4946 : 
; 4947 : 	CSP_REQ_RESETREGSIEGEINFO pMsg;
; 4948 : 	pMsg.h.set((PBYTE)&pMsg,0x80,0x1B,sizeof(pMsg));
; 4949 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0000d	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4951 : 	cDBSMng.Send((char*)&pMsg,pMsg.h.size);

  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00016	6a 06		 push	 6
  00018	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0001b	c7 45 f8 c1 06
	80 1b		 mov	 DWORD PTR _pMsg$[ebp], 461375169 ; 1b8006c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4951 : 	cDBSMng.Send((char*)&pMsg,pMsg.h.size);

  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqRe:

; 4952 : #endif
; 4953 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?GS_GDReqResetRegSiegeInfo@@YAXH@Z ENDP			; GS_GDReqResetRegSiegeInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqSiegeDateChange@@YAXHHGEEGEE@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_wStartYear$ = 16					; size = 2
_btStartMonth$ = 20					; size = 1
_btStartDay$ = 24					; size = 1
_wEndYear$ = 28						; size = 2
_btEndMonth$ = 32					; size = 1
_btEndDay$ = 36						; size = 1
?GS_GDReqSiegeDateChange@@YAXHHGEEGEE@Z PROC		; GS_GDReqSiegeDateChange, COMDAT

; 4899 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4900 : #if (GS_CASTLE == 1)
; 4901 : 	if(iMapSvrGroup < 0)

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 49		 js	 SHORT $LN1@GS_GDReqSi

; 4902 : 		return;
; 4903 : 
; 4904 : 	CSP_REQ_SDEDCHANGE pMsg;
; 4905 : 
; 4906 : 	pMsg.h.set((PBYTE)&pMsg,0x80,9,sizeof(pMsg));
; 4907 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00017	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 4916 : 	cDBSMng.Send((char*)&pMsg,pMsg.h.size);

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00020	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00023	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00026	66 8b 45 10	 mov	 ax, WORD PTR _wStartYear$[ebp]
  0002a	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+12], ax
  0002e	8a 45 14	 mov	 al, BYTE PTR _btStartMonth$[ebp]
  00031	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+14], al
  00034	8a 45 18	 mov	 al, BYTE PTR _btStartDay$[ebp]
  00037	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+15], al
  0003a	66 8b 45 1c	 mov	 ax, WORD PTR _wEndYear$[ebp]
  0003e	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+16], ax
  00042	8a 45 20	 mov	 al, BYTE PTR _btEndMonth$[ebp]
  00045	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+18], al
  00048	8a 45 24	 mov	 al, BYTE PTR _btEndDay$[ebp]
  0004b	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+19], al
  0004e	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00051	6a 14		 push	 20			; 00000014H
  00053	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00054	c7 45 e8 c1 14
	80 09		 mov	 DWORD PTR _pMsg$[ebp], 159388865 ; 098014c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4916 : 	cDBSMng.Send((char*)&pMsg,pMsg.h.size);

  0005b	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqSi:

; 4917 : #endif
; 4918 : }

  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?GS_GDReqSiegeDateChange@@YAXHHGEEGEE@Z ENDP		; GS_GDReqSiegeDateChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCastleMoneyChange@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iMoneyChange$ = 16					; size = 4
?GS_GDReqCastleMoneyChange@@YAXHHH@Z PROC		; GS_GDReqCastleMoneyChange, COMDAT

; 4088 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4089 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 d2		 test	 edx, edx
  00015	78 3a		 js	 SHORT $LN1@GS_GDReqCa

; 4090 : 	{
; 4091 : 		return;
; 4092 : 	}
; 4093 : 
; 4094 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001a	85 c9		 test	 ecx, ecx
  0001c	78 33		 js	 SHORT $LN1@GS_GDReqCa
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 24		 je	 SHORT $LN1@GS_GDReqCa

; 4104 : 	pMsg.iIndex = aIndex;
; 4105 : 	pMsg.iMoneyChanged = iMoneyChange;

  0002d	8b 45 10	 mov	 eax, DWORD PTR _iMoneyChange$[ebp]
  00030	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 4106 : 	
; 4107 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00033	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00036	6a 10		 push	 16			; 00000010H
  00038	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00040	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00041	c7 45 ec c1 10
	80 08		 mov	 DWORD PTR _pMsg$[ebp], 142610625 ; 088010c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4103 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00048	66 89 55 f0	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 4106 : 	
; 4107 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0004c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 4108 : }

  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?GS_GDReqCastleMoneyChange@@YAXHHH@Z ENDP		; GS_GDReqCastleMoneyChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqTaxRateChange@@YAXHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iTaxType$ = 16						; size = 4
_iTaxRate$ = 20						; size = 4
?GS_GDReqTaxRateChange@@YAXHHHH@Z PROC			; GS_GDReqTaxRateChange, COMDAT

; 4044 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4045 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 d2		 test	 edx, edx
  00015	78 40		 js	 SHORT $LN1@GS_GDReqTa

; 4046 : 	{
; 4047 : 		return;
; 4048 : 	}
; 4049 : 
; 4050 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001a	85 c9		 test	 ecx, ecx
  0001c	78 39		 js	 SHORT $LN1@GS_GDReqTa
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 2a		 je	 SHORT $LN1@GS_GDReqTa

; 4060 : 	pMsg.iIndex = aIndex;
; 4061 : 	pMsg.iTaxRate = iTaxRate; 

  0002d	8b 45 14	 mov	 eax, DWORD PTR _iTaxRate$[ebp]
  00030	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 4062 : 	pMsg.iTaxKind = iTaxType;

  00033	8b 45 10	 mov	 eax, DWORD PTR _iTaxType$[ebp]
  00036	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 4063 : 	
; 4064 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00039	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003c	6a 14		 push	 20			; 00000014H
  0003e	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00046	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00047	c7 45 e8 c1 14
	80 07		 mov	 DWORD PTR _pMsg$[ebp], 125834433 ; 078014c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4059 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0004e	66 89 55 ec	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 4063 : 	
; 4064 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00052	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqTa:

; 4065 : }

  00057	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005a	33 cd		 xor	 ecx, ebp
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?GS_GDReqTaxRateChange@@YAXHHHH@Z ENDP			; GS_GDReqTaxRateChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqTaxInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqTaxInfo@@YAXHH@Z PROC				; GS_GDReqTaxInfo, COMDAT

; 4002 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4003 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 d2		 test	 edx, edx
  00015	78 34		 js	 SHORT $LN1@GS_GDReqTa

; 4004 : 	{
; 4005 : 		return;
; 4006 : 	}
; 4007 : 
; 4008 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001a	85 c9		 test	 ecx, ecx
  0001c	78 2d		 js	 SHORT $LN1@GS_GDReqTa
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 1e		 je	 SHORT $LN1@GS_GDReqTa

; 4018 : 	pMsg.iIndex = aIndex;
; 4019 : 
; 4020 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0002d	6a 0c		 push	 12			; 0000000cH
  0002f	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00032	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00035	50		 push	 eax
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0003b	c7 45 f0 c1 0c
	80 06		 mov	 DWORD PTR _pMsg$[ebp], 109055169 ; 06800cc1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 4017 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00042	66 89 55 f4	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 4018 : 	pMsg.iIndex = aIndex;
; 4019 : 
; 4020 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00046	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqTa:

; 4021 : }

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?GS_GDReqTaxInfo@@YAXHH@Z ENDP				; GS_GDReqTaxInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iNpcUpType$ = 24					; size = 4
_iNpcUpValue$ = 28					; size = 4
_iNpcUpIndex$ = 32					; size = 4
?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z PROC		; GS_GDReqCastleNpcUpgrade, COMDAT

; 3959 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3960 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 d2		 test	 edx, edx
  00015	78 52		 js	 SHORT $LN1@GS_GDReqCa

; 3961 : 	{
; 3962 : 		return;
; 3963 : 	}
; 3964 : 
; 3965 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001a	85 c9		 test	 ecx, ecx
  0001c	78 4b		 js	 SHORT $LN1@GS_GDReqCa
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 3c		 je	 SHORT $LN1@GS_GDReqCa

; 3975 : 	pMsg.iIndex = aIndex;
; 3976 : 	pMsg.iNpcNumber = iNpcNumber;

  0002d	8b 45 10	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  00030	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 3977 : 	pMsg.iNpcIndex = iNpcIndex;

  00033	8b 45 14	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  00036	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 3978 : 	pMsg.iNpcUpType = iNpcUpType;

  00039	8b 45 18	 mov	 eax, DWORD PTR _iNpcUpType$[ebp]
  0003c	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 3979 : 	pMsg.iNpcUpValue = iNpcUpValue;

  0003f	8b 45 1c	 mov	 eax, DWORD PTR _iNpcUpValue$[ebp]
  00042	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 3980 : 	pMsg.iNpcUpIndex = iNpcUpIndex;

  00045	8b 45 20	 mov	 eax, DWORD PTR _iNpcUpIndex$[ebp]
  00048	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+28], eax

; 3981 : 
; 3982 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0004b	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004e	6a 20		 push	 32			; 00000020H
  00050	89 4d e4	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00058	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00059	c7 45 dc c1 20
	80 05		 mov	 DWORD PTR _pMsg$[ebp], 92283073 ; 058020c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 3974 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00060	66 89 55 e0	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 3981 : 
; 3982 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00064	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 3983 : }

  00069	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006c	33 cd		 xor	 ecx, ebp
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z ENDP		; GS_GDReqCastleNpcUpgrade
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iRepairCost$ = 24					; size = 4
?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z PROC		; GS_GDReqCastleNpcRepair, COMDAT

; 3912 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3913 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 d2		 test	 edx, edx
  00015	78 46		 js	 SHORT $LN1@GS_GDReqCa

; 3914 : 	{
; 3915 : 		return;
; 3916 : 	}
; 3917 : 
; 3918 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001a	85 c9		 test	 ecx, ecx
  0001c	78 3f		 js	 SHORT $LN1@GS_GDReqCa
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 30		 je	 SHORT $LN1@GS_GDReqCa

; 3928 : 	pMsg.iIndex = aIndex;
; 3929 : 	pMsg.iNpcNumber = iNpcNumber;

  0002d	8b 45 10	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  00030	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 3930 : 	pMsg.iNpcIndex = iNpcIndex;

  00033	8b 45 14	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  00036	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 3931 : 	pMsg.iRepairCost = iRepairCost;

  00039	8b 45 18	 mov	 eax, DWORD PTR _iRepairCost$[ebp]
  0003c	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 3932 : 
; 3933 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0003f	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00042	6a 18		 push	 24			; 00000018H
  00044	89 4d ec	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0004c	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0004d	c7 45 e4 c1 18
	80 04		 mov	 DWORD PTR _pMsg$[ebp], 75503809 ; 048018c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 3927 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00054	66 89 55 e8	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 3932 : 
; 3933 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00058	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 3934 : }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	33 cd		 xor	 ecx, ebp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z ENDP		; GS_GDReqCastleNpcRepair
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCastleNpcBuy@@YAXHHHHHHHHEEEH@Z
_TEXT	SEGMENT
_pMsg$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iNpcDfLevel$ = 24					; size = 4
_iNpcRgLevel$ = 28					; size = 4
_iNpcMaxHP$ = 32					; size = 4
_iNpcHP$ = 36						; size = 4
_btNpcX$ = 40						; size = 1
_btNpcY$ = 44						; size = 1
_btNpcDIR$ = 48						; size = 1
_iBuyCost$ = 52						; size = 4
?GS_GDReqCastleNpcBuy@@YAXHHHHHHHHEEEH@Z PROC		; GS_GDReqCastleNpcBuy, COMDAT

; 3856 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3857 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 d2		 test	 edx, edx
  00015	78 70		 js	 SHORT $LN1@GS_GDReqCa

; 3858 : 	{
; 3859 : 		return;
; 3860 : 	}
; 3861 : 
; 3862 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001a	85 c9		 test	 ecx, ecx
  0001c	78 69		 js	 SHORT $LN1@GS_GDReqCa
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 5a		 je	 SHORT $LN1@GS_GDReqCa

; 3872 : 	pMsg.iIndex = aIndex;
; 3873 : 	pMsg.iNpcNumber = iNpcNumber;

  0002d	8b 45 10	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  00030	89 45 dc	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 3874 : 	pMsg.iNpcIndex = iNpcIndex;

  00033	8b 45 14	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  00036	89 45 e0	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 3875 : 	pMsg.iNpcDfLevel = iNpcDfLevel;

  00039	8b 45 18	 mov	 eax, DWORD PTR _iNpcDfLevel$[ebp]
  0003c	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+20], eax

; 3876 : 	pMsg.iNpcRgLevel = iNpcRgLevel;

  0003f	8b 45 1c	 mov	 eax, DWORD PTR _iNpcRgLevel$[ebp]
  00042	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+24], eax

; 3877 : 	pMsg.iNpcMaxHp = iNpcMaxHP;

  00045	8b 45 20	 mov	 eax, DWORD PTR _iNpcMaxHP$[ebp]
  00048	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+28], eax

; 3878 : 	pMsg.iNpcHp = iNpcHP;

  0004b	8b 45 24	 mov	 eax, DWORD PTR _iNpcHP$[ebp]
  0004e	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+32], eax

; 3879 : 	pMsg.btNpcX = btNpcX;

  00051	8a 45 28	 mov	 al, BYTE PTR _btNpcX$[ebp]
  00054	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+36], al

; 3880 : 	pMsg.btNpcY = btNpcY;

  00057	8a 45 2c	 mov	 al, BYTE PTR _btNpcY$[ebp]
  0005a	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+37], al

; 3881 : 	pMsg.btNpcDIR = btNpcDIR;

  0005d	8a 45 30	 mov	 al, BYTE PTR _btNpcDIR$[ebp]
  00060	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+38], al

; 3882 : 	pMsg.iBuyCost = iBuyCost;

  00063	8b 45 34	 mov	 eax, DWORD PTR _iBuyCost$[ebp]
  00066	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+40], eax

; 3883 : 
; 3884 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00069	8d 45 d0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006c	6a 2c		 push	 44			; 0000002cH
  0006e	89 4d d8	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00071	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00076	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00077	c7 45 d0 c1 2c
	80 03		 mov	 DWORD PTR _pMsg$[ebp], 58731713 ; 03802cc1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 3871 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  0007e	66 89 55 d4	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 3883 : 
; 3884 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00082	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 3885 : }

  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	33 cd		 xor	 ecx, ebp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
?GS_GDReqCastleNpcBuy@@YAXHHHHHHHHEEEH@Z ENDP		; GS_GDReqCastleNpcBuy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqOwnerGuildMaster@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_aIndex$ = 12						; size = 4
?GS_GDReqOwnerGuildMaster@@YAXHH@Z PROC			; GS_GDReqOwnerGuildMaster, COMDAT

; 3805 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3806 : 	if ( iMapSvrGroup < 0 )

  00010	8b 55 08	 mov	 edx, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 d2		 test	 edx, edx
  00015	78 34		 js	 SHORT $LN1@GS_GDReqOw

; 3807 : 	{
; 3808 : 		return;
; 3809 : 	}
; 3810 : 
; 3811 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0001a	85 c9		 test	 ecx, ecx
  0001c	78 2d		 js	 SHORT $LN1@GS_GDReqOw
  0001e	33 c0		 xor	 eax, eax
  00020	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00026	0f 9e c0	 setle	 al
  00029	85 c0		 test	 eax, eax
  0002b	74 1e		 je	 SHORT $LN1@GS_GDReqOw

; 3821 : 	pMsg.iIndex = aIndex;
; 3822 : 
; 3823 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0002d	6a 0c		 push	 12			; 0000000cH
  0002f	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00032	89 4d f8	 mov	 DWORD PTR _pMsg$[ebp+8], ecx
  00035	50		 push	 eax
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0003b	c7 45 f0 c1 0c
	80 01		 mov	 DWORD PTR _pMsg$[ebp], 25169089 ; 01800cc1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 3820 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00042	66 89 55 f4	 mov	 WORD PTR _pMsg$[ebp+4], dx

; 3821 : 	pMsg.iIndex = aIndex;
; 3822 : 
; 3823 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00046	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqOw:

; 3824 : }

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?GS_GDReqOwnerGuildMaster@@YAXHH@Z ENDP			; GS_GDReqOwnerGuildMaster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GS_GDReqCastleTotalInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_iMapSvrGroup$ = 8					; size = 4
_iCastleEventCycle$ = 12				; size = 4
?GS_GDReqCastleTotalInfo@@YAXHH@Z PROC			; GS_GDReqCastleTotalInfo, COMDAT

; 3772 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3773 : 	if ( iMapSvrGroup < 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _iMapSvrGroup$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	78 21		 js	 SHORT $LN1@GS_GDReqCa

; 3774 : 	{
; 3775 : 		return;
; 3776 : 	}
; 3777 : 
; 3778 : 	CSP_REQ_CASTLEDATA pMsg;
; 3779 : 
; 3780 : 	pMsg.h.set((LPBYTE)&pMsg, 0x80, 0x00, sizeof(CSP_REQ_CASTLEDATA));
; 3781 : 	pMsg.wMapSvrNum = iMapSvrGroup;

  00017	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 3784 : 	::cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00020	8b 45 0c	 mov	 eax, DWORD PTR _iCastleEventCycle$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00026	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	50		 push	 eax
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0002c	c7 45 f0 c1 0c
	80 00		 mov	 DWORD PTR _pMsg$[ebp], 8391873 ; 00800cc1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 3784 : 	::cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00033	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GS_GDReqCa:

; 3785 : }

  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?GS_GDReqCastleTotalInfo@@YAXHH@Z ENDP			; GS_GDReqCastleTotalInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?gObjSavePetItemInfo@@YAXHH@Z
_TEXT	SEGMENT
_petIteminfo$ = -1060					; size = 12
_lofs$1$ = -1048					; size = 4
_founditemcount$1$ = -1044				; size = 4
_n$1$ = -1040						; size = 4
_n$1$ = -1040						; size = 4
tv481 = -1036						; size = 4
tv477 = -1036						; size = 4
_pMsg$1 = -1036						; size = 5
_pbuffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_inventype$ = 12					; size = 4
?gObjSavePetItemInfo@@YAXHH@Z PROC			; gObjSavePetItemInfo, COMDAT

; 3680 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 04 00
	00		 sub	 esp, 1060		; 00000424H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 3681 : 	LPOBJ lpObj = &gObj[aIndex];
; 3682 : 	char pbuffer[1024];
; 3683 : 	int lofs = sizeof(SDHP_SAVE_PETITEM_INFO);
; 3684 : 	int founditemcount = 0;

  00016	33 d2		 xor	 edx, edx
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	69 f8 40 27 00
	00		 imul	 edi, eax, 10048

; 3685 : 	Save_PetItem_Info petIteminfo;
; 3686 : 
; 3687 : 	if ( inventype == 0 )

  00021	8b 45 0c	 mov	 eax, DWORD PTR _inventype$[ebp]
  00024	c7 85 e8 fb ff
	ff 05 00 00 00	 mov	 DWORD PTR _lofs$1$[ebp], 5
  0002e	89 95 ec fb ff
	ff		 mov	 DWORD PTR _founditemcount$1$[ebp], edx
  00034	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003a	85 c0		 test	 eax, eax
  0003c	0f 85 f1 00 00
	00		 jne	 $LN8@gObjSavePe

; 3688 : 	{
; 3689 : 		for ( int n=0;n<INVENTORY_SIZE;n++)

  00042	33 f6		 xor	 esi, esi
  00044	8d 85 01 fc ff
	ff		 lea	 eax, DWORD PTR _pbuffer$[ebp+5]
  0004a	89 b5 f0 fb ff
	ff		 mov	 DWORD PTR _n$1$[ebp], esi
  00050	33 db		 xor	 ebx, ebx
  00052	89 85 f4 fb ff
	ff		 mov	 DWORD PTR tv481[ebp], eax
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@gObjSavePe:

; 3690 : 		{
; 3691 : 			if ( lpObj->pInventory[n].IsItem() )

  00060	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  00066	03 cb		 add	 ecx, ebx
  00068	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006d	85 c0		 test	 eax, eax
  0006f	0f 84 a0 00 00
	00		 je	 $LN2@gObjSavePe

; 3692 : 			{
; 3693 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,4) || lpObj->pInventory[n].m_Type == ITEMGET(13,5) )

  00075	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  0007b	ba 04 1a 00 00	 mov	 edx, 6660		; 00001a04H
  00080	03 cb		 add	 ecx, ebx
  00082	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00086	66 3b c2	 cmp	 ax, dx
  00089	74 0e		 je	 SHORT $LN12@gObjSavePe
  0008b	ba 05 1a 00 00	 mov	 edx, 6661		; 00001a05H
  00090	66 3b c2	 cmp	 ax, dx
  00093	0f 85 7c 00 00
	00		 jne	 $LN2@gObjSavePe
$LN12@gObjSavePe:

; 3694 : 				{
; 3695 : 					if ( lpObj->pInventory[n].m_IsLoadPetItemInfo != FALSE )

  00099	83 b9 b4 00 00
	00 00		 cmp	 DWORD PTR [ecx+180], 0
  000a0	74 73		 je	 SHORT $LN2@gObjSavePe

; 3696 : 					{
; 3697 : 						founditemcount++;
; 3698 : 						petIteminfo.nSerial = lpObj->pInventory[n].m_Number;
; 3699 : 						petIteminfo.Level = lpObj->pInventory[n].m_PetItem_Level;

  000a2	8a 81 b8 00 00
	00		 mov	 al, BYTE PTR [ecx+184]

; 3700 : 						petIteminfo.Exp = lpObj->pInventory[n].m_PetItem_Exp;

  000a8	8b b1 bc 00 00
	00		 mov	 esi, DWORD PTR [ecx+188]
  000ae	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b0	ff 85 ec fb ff
	ff		 inc	 DWORD PTR _founditemcount$1$[ebp]
  000b6	88 85 e0 fb ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp+4], al

; 3701 : 
; 3702 : 						LogAddTD("[%s][%s][PI][%d,%s]serial:[%d] Level:%d Exp:%d",

  000bc	56		 push	 esi
  000bd	0f b6 c0	 movzx	 eax, al
  000c0	50		 push	 eax
  000c1	52		 push	 edx
  000c2	89 95 dc fb ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp], edx
  000c8	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000cd	50		 push	 eax
  000ce	ff b5 f0 fb ff
	ff		 push	 DWORD PTR _n$1$[ebp]
  000d4	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  000d7	50		 push	 eax
  000d8	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  000db	50		 push	 eax
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@HBHBBGIF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPI?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5L@
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3703 : 							lpObj->AccountID, lpObj->Name, n, lpObj->pInventory[n].GetName(),petIteminfo.nSerial,
; 3704 : 							petIteminfo.Level, petIteminfo.Exp);
; 3705 : 
; 3706 : 						memcpy(&pbuffer[lofs], &petIteminfo, sizeof(petIteminfo));

  000e7	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR tv481[ebp]
  000ed	83 c4 20	 add	 esp, 32			; 00000020H
  000f0	f3 0f 7e 85 dc
	fb ff ff	 movq	 xmm0, QWORD PTR _petIteminfo$[ebp]

; 3707 : 						lofs += sizeof(petIteminfo);

  000f8	83 85 e8 fb ff
	ff 0c		 add	 DWORD PTR _lofs$1$[ebp], 12 ; 0000000cH
  000ff	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00103	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00106	83 c0 0c	 add	 eax, 12			; 0000000cH
  00109	8b b5 f0 fb ff
	ff		 mov	 esi, DWORD PTR _n$1$[ebp]
  0010f	89 85 f4 fb ff
	ff		 mov	 DWORD PTR tv481[ebp], eax
$LN2@gObjSavePe:

; 3688 : 	{
; 3689 : 		for ( int n=0;n<INVENTORY_SIZE;n++)

  00115	46		 inc	 esi
  00116	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  0011c	89 b5 f0 fb ff
	ff		 mov	 DWORD PTR _n$1$[ebp], esi
  00122	81 fb 44 c4 00
	00		 cmp	 ebx, 50244		; 0000c444H
  00128	0f 8c 32 ff ff
	ff		 jl	 $LL4@gObjSavePe

; 3708 : 					}
; 3709 : 				}
; 3710 : 			}
; 3711 : 		}
; 3712 : 	}
; 3713 : 	else if ( inventype == 1 )

  0012e	e9 ed 00 00 00	 jmp	 $LN6@gObjSavePe
$LN8@gObjSavePe:
  00133	83 f8 01	 cmp	 eax, 1
  00136	0f 85 3a 01 00
	00		 jne	 $LN19@gObjSavePe

; 3714 : 	{
; 3715 : 		for ( int n=0;n<WAREHOUSE_SIZE;n++)

  0013c	33 f6		 xor	 esi, esi
  0013e	8d 85 01 fc ff
	ff		 lea	 eax, DWORD PTR _pbuffer$[ebp+5]
  00144	89 b5 f0 fb ff
	ff		 mov	 DWORD PTR _n$1$[ebp], esi
  0014a	33 db		 xor	 ebx, ebx
  0014c	89 85 f4 fb ff
	ff		 mov	 DWORD PTR tv477[ebp], eax
$LL7@gObjSavePe:

; 3716 : 		{
; 3717 : 			if ( lpObj->pWarehouse[n].IsItem() )

  00152	8b 8f f8 11 00
	00		 mov	 ecx, DWORD PTR [edi+4600]
  00158	03 cb		 add	 ecx, ebx
  0015a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0015f	85 c0		 test	 eax, eax
  00161	0f 84 a0 00 00
	00		 je	 $LN5@gObjSavePe

; 3718 : 			{
; 3719 : 				if ( lpObj->pWarehouse[n].m_Type == ITEMGET(13,4) || lpObj->pWarehouse[n].m_Type == ITEMGET(13,5) )

  00167	8b 8f f8 11 00
	00		 mov	 ecx, DWORD PTR [edi+4600]
  0016d	ba 04 1a 00 00	 mov	 edx, 6660		; 00001a04H
  00172	03 cb		 add	 ecx, ebx
  00174	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00178	66 3b c2	 cmp	 ax, dx
  0017b	74 0e		 je	 SHORT $LN17@gObjSavePe
  0017d	ba 05 1a 00 00	 mov	 edx, 6661		; 00001a05H
  00182	66 3b c2	 cmp	 ax, dx
  00185	0f 85 7c 00 00
	00		 jne	 $LN5@gObjSavePe
$LN17@gObjSavePe:

; 3720 : 				{
; 3721 : 					if ( lpObj->pWarehouse[n].m_IsLoadPetItemInfo != FALSE )

  0018b	83 b9 b4 00 00
	00 00		 cmp	 DWORD PTR [ecx+180], 0
  00192	74 73		 je	 SHORT $LN5@gObjSavePe

; 3722 : 					{
; 3723 : 						founditemcount++;
; 3724 : 						petIteminfo.nSerial = lpObj->pWarehouse[n].m_Number;
; 3725 : 						petIteminfo.Level = lpObj->pWarehouse[n].m_PetItem_Level;

  00194	8a 81 b8 00 00
	00		 mov	 al, BYTE PTR [ecx+184]

; 3726 : 						petIteminfo.Exp = lpObj->pWarehouse[n].m_PetItem_Exp;

  0019a	8b b1 bc 00 00
	00		 mov	 esi, DWORD PTR [ecx+188]
  001a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a2	ff 85 ec fb ff
	ff		 inc	 DWORD PTR _founditemcount$1$[ebp]
  001a8	88 85 e0 fb ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp+4], al

; 3727 : 
; 3728 : 						LogAddTD("[%s][%s][PW][%d,%s]serial:[%d] Level:%d Exp:%d",

  001ae	56		 push	 esi
  001af	0f b6 c0	 movzx	 eax, al
  001b2	50		 push	 eax
  001b3	52		 push	 edx
  001b4	89 95 dc fb ff
	ff		 mov	 DWORD PTR _petIteminfo$[ebp], edx
  001ba	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  001bf	50		 push	 eax
  001c0	ff b5 f0 fb ff
	ff		 push	 DWORD PTR _n$1$[ebp]
  001c6	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  001c9	50		 push	 eax
  001ca	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  001cd	50		 push	 eax
  001ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@HLCJJJIG@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPW?$FN?$FL?$CFd?0?$CFs?$FNserial?3?$FL?$CFd?$FN?5L@
  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3729 : 							lpObj->AccountID, lpObj->Name, n, lpObj->pWarehouse[n].GetName(),petIteminfo.nSerial,
; 3730 : 							petIteminfo.Level, petIteminfo.Exp);
; 3731 : 
; 3732 : 						memcpy(&pbuffer[lofs], &petIteminfo, sizeof(petIteminfo));

  001d9	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR tv477[ebp]
  001df	83 c4 20	 add	 esp, 32			; 00000020H
  001e2	f3 0f 7e 85 dc
	fb ff ff	 movq	 xmm0, QWORD PTR _petIteminfo$[ebp]

; 3733 : 						lofs += sizeof(petIteminfo);

  001ea	83 85 e8 fb ff
	ff 0c		 add	 DWORD PTR _lofs$1$[ebp], 12 ; 0000000cH
  001f1	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  001f5	89 70 08	 mov	 DWORD PTR [eax+8], esi
  001f8	83 c0 0c	 add	 eax, 12			; 0000000cH
  001fb	8b b5 f0 fb ff
	ff		 mov	 esi, DWORD PTR _n$1$[ebp]
  00201	89 85 f4 fb ff
	ff		 mov	 DWORD PTR tv477[ebp], eax
$LN5@gObjSavePe:

; 3714 : 	{
; 3715 : 		for ( int n=0;n<WAREHOUSE_SIZE;n++)

  00207	46		 inc	 esi
  00208	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  0020e	89 b5 f0 fb ff
	ff		 mov	 DWORD PTR _n$1$[ebp], esi
  00214	81 fb c0 c6 00
	00		 cmp	 ebx, 50880		; 0000c6c0H
  0021a	0f 8c 32 ff ff
	ff		 jl	 $LL7@gObjSavePe
$LN6@gObjSavePe:

; 3734 : 					}
; 3735 : 				}
; 3736 : 			}
; 3737 : 		}
; 3738 : 	}
; 3739 : 
; 3740 : 	if ( founditemcount )

  00220	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR _founditemcount$1$[ebp]
  00226	85 d2		 test	 edx, edx
  00228	74 4c		 je	 SHORT $LN19@gObjSavePe

; 3741 : 	{
; 3742 : 		SDHP_SAVE_PETITEM_INFO pMsg;
; 3743 : 
; 3744 : 		pMsg.h.set((LPBYTE)&pMsg, 0x57, lofs+sizeof(pMsg));

  0022a	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR _lofs$1$[ebp]
  00230	83 c1 05	 add	 ecx, 5
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 111  : 		lpBuf[0] = 0xC2;

  00233	c6 85 f4 fb ff
	ff c2		 mov	 BYTE PTR _pMsg$1[ebp], 194 ; 000000c2H

; 112  : 		lpBuf[1] = SET_NUMBERH(size);

  0023a	8b c1		 mov	 eax, ecx

; 113  : 		lpBuf[2] = SET_NUMBERL(size);

  0023c	88 8d f6 fb ff
	ff		 mov	 BYTE PTR _pMsg$1[ebp+2], cl
  00242	c1 e8 08	 shr	 eax, 8
  00245	88 85 f5 fb ff
	ff		 mov	 BYTE PTR _pMsg$1[ebp+1], al

; 114  : 		lpBuf[3] = head;

  0024b	c6 85 f7 fb ff
	ff 57		 mov	 BYTE PTR _pMsg$1[ebp+3], 87 ; 00000057H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 3746 : 		memcpy(pbuffer, &pMsg, sizeof(pMsg));

  00252	8b 85 f4 fb ff
	ff		 mov	 eax, DWORD PTR _pMsg$1[ebp]
  00258	89 85 fc fb ff
	ff		 mov	 DWORD PTR _pbuffer$[ebp], eax

; 3747 : 
; 3748 : 		cDBSMng.Send(pbuffer, lofs+sizeof(pMsg));

  0025e	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _pbuffer$[ebp]
  00264	51		 push	 ecx
  00265	50		 push	 eax
  00266	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0026b	88 95 00 fc ff
	ff		 mov	 BYTE PTR _pbuffer$[ebp+4], dl
  00271	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN19@gObjSavePe:

; 3749 : 	}
; 3750 : }

  00276	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00279	5f		 pop	 edi
  0027a	5e		 pop	 esi
  0027b	33 cd		 xor	 ecx, ebp
  0027d	5b		 pop	 ebx
  0027e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00283	8b e5		 mov	 esp, ebp
  00285	5d		 pop	 ebp
  00286	c3		 ret	 0
?gObjSavePetItemInfo@@YAXHH@Z ENDP			; gObjSavePetItemInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGRecvPetItemInfo@@YAXPAE@Z
_TEXT	SEGMENT
tv592 = -32						; size = 4
_ReCalc$1$ = -28					; size = 4
tv632 = -24						; size = 4
tv631 = -20						; size = 4
_aIndex$1$ = -20					; size = 4
_szAccountId$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpData$ = 8						; size = 4
?DGRecvPetItemInfo@@YAXPAE@Z PROC			; DGRecvPetItemInfo, COMDAT

; 3595 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpData$[ebp]
  00014	56		 push	 esi
  00015	57		 push	 edi

; 3596 : 	SDHP_RECV_PETITEM_INFO* lpMsg = (SDHP_RECV_PETITEM_INFO *)lpData;
; 3597 : 	Recv_PetItem_Info* pPetItemInfo = (Recv_PetItem_Info *)((DWORD)lpData + sizeof(SDHP_RECV_PETITEM_INFO));
; 3598 : 	int aIndex = lpMsg->Number;
; 3599 : 	char szAccountId[MAX_ACCOUNT_LEN+1];
; 3600 : 	szAccountId[MAX_ACCOUNT_LEN]=0;

  00016	c6 45 fa 00	 mov	 BYTE PTR _szAccountId$[ebp+10], 0

; 3601 : 
; 3602 : 	memcpy(szAccountId, lpMsg->AccountID, MAX_ACCOUNT_LEN);

  0001a	66 8b 43 0c	 mov	 ax, WORD PTR [ebx+12]
  0001e	8d 73 14	 lea	 esi, DWORD PTR [ebx+20]
  00021	0f b7 7b 10	 movzx	 edi, WORD PTR [ebx+16]
  00025	f3 0f 7e 43 04	 movq	 xmm0, QWORD PTR [ebx+4]
  0002a	66 89 45 f8	 mov	 WORD PTR _szAccountId$[ebp+8], ax

; 3603 : 	
; 3604 : 	if ( !gObjIsAccontConnect(aIndex, szAccountId))

  0002e	8d 45 f0	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00031	50		 push	 eax
  00032	57		 push	 edi
  00033	89 7d ec	 mov	 DWORD PTR _aIndex$1$[ebp], edi
  00036	66 0f d6 45 f0	 movq	 QWORD PTR _szAccountId$[ebp], xmm0
  0003b	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00040	83 c4 08	 add	 esp, 8
  00043	85 c0		 test	 eax, eax
  00045	75 2b		 jne	 SHORT $LN8@DGRecvPetI

; 3605 : 	{
; 3606 : 		LogAddC(2, "Request to receive petitem infomation doesn't match the user %s", szAccountId);

  00047	8d 45 f0	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@PICKNLKN@Request?5to?5receive?5petitem?5infom@
  00050	6a 02		 push	 2
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 3607 : 		CloseClient(aIndex);

  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 3647 : 				}
; 3648 : 			}
; 3649 : 		}
; 3650 : 
; 3651 : 	}
; 3652 : }

  00064	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00067	33 cd		 xor	 ecx, ebp
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN8@DGRecvPetI:

; 3608 : 		
; 3609 : 		return;
; 3610 : 	}
; 3611 : 
; 3612 : 	if ( lpMsg->InvenType == 0 )

  00072	8a 43 12	 mov	 al, BYTE PTR [ebx+18]
  00075	84 c0		 test	 al, al
  00077	0f 85 a8 00 00
	00		 jne	 $LN9@DGRecvPetI

; 3613 : 	{
; 3614 : 		BOOL ReCalc = 0;

  0007d	33 c9		 xor	 ecx, ecx

; 3615 : 
; 3616 : 		for ( int n=0;n<lpMsg->nCount;n++)

  0007f	33 ff		 xor	 edi, edi
  00081	38 4b 13	 cmp	 BYTE PTR [ebx+19], cl
  00084	0f 86 0a 01 00
	00		 jbe	 $LN6@DGRecvPetI

; 3613 : 	{
; 3614 : 		BOOL ReCalc = 0;

  0008a	69 55 ec 40 27
	00 00		 imul	 edx, DWORD PTR _aIndex$1$[ebp], 10048
  00091	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv592[ebp], 1
  00098	81 c2 c0 11 00
	00		 add	 edx, 4544		; 000011c0H
  0009e	89 55 e8	 mov	 DWORD PTR tv632[ebp], edx
$LL4@DGRecvPetI:

; 3617 : 		{
; 3618 : 			if ( pPetItemInfo[n].nPos < INVETORY_WEAR_SIZE )

  000a1	80 3e 0c	 cmp	 BYTE PTR [esi], 12	; 0000000cH

; 3619 : 			{
; 3620 : 				ReCalc = 1;
; 3621 : 			}
; 3622 : 
; 3623 : 			if ( gObj[aIndex].pInventory[pPetItemInfo[n].nPos].IsItem() )

  000a4	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  000a7	0f 42 4d e0	 cmovb	 ecx, DWORD PTR tv592[ebp]
  000ab	89 4d e4	 mov	 DWORD PTR _ReCalc$1$[ebp], ecx
  000ae	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  000b4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b9	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  000bc	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 3624 : 			{
; 3625 : 				if ( gObj[aIndex].pInventory[pPetItemInfo[n].nPos].m_Number == pPetItemInfo[n].nSerial )

  000c1	8b 55 e8	 mov	 edx, DWORD PTR tv632[ebp]
  000c4	85 c0		 test	 eax, eax
  000c6	74 2a		 je	 SHORT $LN2@DGRecvPetI
  000c8	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  000cb	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d6	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000d9	03 c8		 add	 ecx, eax
  000db	8b 01		 mov	 eax, DWORD PTR [ecx]
  000dd	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000e0	75 10		 jne	 SHORT $LN2@DGRecvPetI

; 3626 : 				{
; 3627 : 					gObj[aIndex].pInventory[pPetItemInfo[n].nPos].SetPetItemInfo(pPetItemInfo[n].Level, pPetItemInfo[n].Exp);

  000e2	ff 76 0c	 push	 DWORD PTR [esi+12]
  000e5	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 ?SetPetItemInfo@CItem@@QAEXHH@Z ; CItem::SetPetItemInfo
  000ef	8b 55 e8	 mov	 edx, DWORD PTR tv632[ebp]
$LN2@DGRecvPetI:

; 3615 : 
; 3616 : 		for ( int n=0;n<lpMsg->nCount;n++)

  000f2	0f b6 43 13	 movzx	 eax, BYTE PTR [ebx+19]
  000f6	47		 inc	 edi
  000f7	8b 4d e4	 mov	 ecx, DWORD PTR _ReCalc$1$[ebp]
  000fa	83 c6 10	 add	 esi, 16			; 00000010H
  000fd	3b f8		 cmp	 edi, eax
  000ff	7c a0		 jl	 SHORT $LL4@DGRecvPetI

; 3628 : 				}
; 3629 : 			}
; 3630 : 		}
; 3631 : 
; 3632 : 		if ( ReCalc != FALSE )

  00101	85 c9		 test	 ecx, ecx
  00103	0f 84 8b 00 00
	00		 je	 $LN6@DGRecvPetI

; 3633 : 		{
; 3634 : 			gObjCalCharacter(aIndex);

  00109	ff 75 ec	 push	 DWORD PTR _aIndex$1$[ebp]
  0010c	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00111	83 c4 04	 add	 esp, 4
  00114	5f		 pop	 edi
  00115	5e		 pop	 esi
  00116	5b		 pop	 ebx

; 3647 : 				}
; 3648 : 			}
; 3649 : 		}
; 3650 : 
; 3651 : 	}
; 3652 : }

  00117	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011a	33 cd		 xor	 ecx, ebp
  0011c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c3		 ret	 0
$LN9@DGRecvPetI:

; 3635 : 		}
; 3636 : 	}
; 3637 : 	else if ( lpMsg->InvenType == 1 )

  00125	3c 01		 cmp	 al, 1
  00127	75 6b		 jne	 SHORT $LN6@DGRecvPetI

; 3638 : 	{
; 3639 : 		for ( int n=0;n<lpMsg->nCount;n++)

  00129	33 ff		 xor	 edi, edi
  0012b	80 7b 13 00	 cmp	 BYTE PTR [ebx+19], 0
  0012f	76 63		 jbe	 SHORT $LN6@DGRecvPetI
  00131	69 55 ec 40 27
	00 00		 imul	 edx, DWORD PTR _aIndex$1$[ebp], 10048
  00138	81 c2 f8 11 00
	00		 add	 edx, 4600		; 000011f8H
  0013e	89 55 ec	 mov	 DWORD PTR tv631[ebp], edx
$LL7@DGRecvPetI:

; 3640 : 		{
; 3641 : 
; 3642 : 			if ( gObj[aIndex].pWarehouse[pPetItemInfo[n].nPos].IsItem() )

  00141	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00144	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0014a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014f	03 0c 02	 add	 ecx, DWORD PTR [edx+eax]
  00152	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 3643 : 			{
; 3644 : 				if ( gObj[aIndex].pWarehouse[pPetItemInfo[n].nPos].m_Number == pPetItemInfo[n].nSerial )

  00157	8b 55 ec	 mov	 edx, DWORD PTR tv631[ebp]
  0015a	85 c0		 test	 eax, eax
  0015c	74 2a		 je	 SHORT $LN5@DGRecvPetI
  0015e	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00161	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00167	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016c	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0016f	03 c8		 add	 ecx, eax
  00171	8b 01		 mov	 eax, DWORD PTR [ecx]
  00173	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00176	75 10		 jne	 SHORT $LN5@DGRecvPetI

; 3645 : 				{
; 3646 : 					gObj[aIndex].pWarehouse[pPetItemInfo[n].nPos].SetPetItemInfo(pPetItemInfo[n].Level, pPetItemInfo[n].Exp);

  00178	ff 76 0c	 push	 DWORD PTR [esi+12]
  0017b	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 ?SetPetItemInfo@CItem@@QAEXHH@Z ; CItem::SetPetItemInfo
  00185	8b 55 ec	 mov	 edx, DWORD PTR tv631[ebp]
$LN5@DGRecvPetI:

; 3638 : 	{
; 3639 : 		for ( int n=0;n<lpMsg->nCount;n++)

  00188	0f b6 43 13	 movzx	 eax, BYTE PTR [ebx+19]
  0018c	47		 inc	 edi
  0018d	83 c6 10	 add	 esi, 16			; 00000010H
  00190	3b f8		 cmp	 edi, eax
  00192	7c ad		 jl	 SHORT $LL7@DGRecvPetI
$LN6@DGRecvPetI:

; 3647 : 				}
; 3648 : 			}
; 3649 : 		}
; 3650 : 
; 3651 : 	}
; 3652 : }

  00194	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	33 cd		 xor	 ecx, ebp
  0019b	5b		 pop	 ebx
  0019c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c3		 ret	 0
?DGRecvPetItemInfo@@YAXPAE@Z ENDP			; DGRecvPetItemInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?gObjRequestPetItemInfo@@YAXHH@Z
_TEXT	SEGMENT
_petIteminfo$ = -1072					; size = 8
_aIndex$GSCopy$1$ = -1064				; size = 4
_pMsg$1 = -1060						; size = 20
tv358 = -1040						; size = 4
tv355 = -1040						; size = 4
_lofs$1$ = -1036					; size = 4
_founditemcount$1$ = -1032				; size = 4
_pbuffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_inventype$ = 12					; size = 4
?gObjRequestPetItemInfo@@YAXHH@Z PROC			; gObjRequestPetItemInfo, COMDAT

; 3514 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 04 00
	00		 sub	 esp, 1072		; 00000430H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 3515 : 	LPOBJ lpObj = &gObj[aIndex];
; 3516 : 	char pbuffer[1024];
; 3517 : 	int lofs = sizeof(SDHP_REQUEST_PETITEM_INFO);
; 3518 : 	int founditemcount = 0;

  00016	33 d2		 xor	 edx, edx
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  00021	89 85 d8 fb ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], eax

; 3519 : 	Request_PetItem_Info petIteminfo;
; 3520 : 
; 3521 : 	if ( inventype == 0 )

  00027	8b 45 0c	 mov	 eax, DWORD PTR _inventype$[ebp]
  0002a	c7 85 f4 fb ff
	ff 14 00 00 00	 mov	 DWORD PTR _lofs$1$[ebp], 20 ; 00000014H
  00034	89 95 f8 fb ff
	ff		 mov	 DWORD PTR _founditemcount$1$[ebp], edx
  0003a	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00040	85 c0		 test	 eax, eax
  00042	0f 85 8c 00 00
	00		 jne	 $LN8@gObjReques

; 3522 : 	{
; 3523 : 		for ( int n=0;n<INVENTORY_SIZE;n++)

  00048	8d 85 10 fc ff
	ff		 lea	 eax, DWORD PTR _pbuffer$[ebp+20]
  0004e	33 db		 xor	 ebx, ebx
  00050	89 85 f0 fb ff
	ff		 mov	 DWORD PTR tv358[ebp], eax
  00056	33 f6		 xor	 esi, esi
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@gObjReques:

; 3524 : 		{
; 3525 : 			if ( lpObj->pInventory[n].IsItem() )

  00060	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  00066	03 ce		 add	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006d	85 c0		 test	 eax, eax
  0006f	74 4f		 je	 SHORT $LN2@gObjReques

; 3526 : 			{
; 3527 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,4) || lpObj->pInventory[n].m_Type == ITEMGET(13,5) )

  00071	8b 8f c0 11 00
	00		 mov	 ecx, DWORD PTR [edi+4544]
  00077	ba 04 1a 00 00	 mov	 edx, 6660		; 00001a04H
  0007c	0f b7 44 31 06	 movzx	 eax, WORD PTR [ecx+esi+6]
  00081	66 3b c2	 cmp	 ax, dx
  00084	74 0a		 je	 SHORT $LN12@gObjReques
  00086	ba 05 1a 00 00	 mov	 edx, 6661		; 00001a05H
  0008b	66 3b c2	 cmp	 ax, dx
  0008e	75 30		 jne	 SHORT $LN2@gObjReques
$LN12@gObjReques:

; 3528 : 				{
; 3529 : 					founditemcount++;
; 3530 : 					petIteminfo.nPos = n;
; 3531 : 					petIteminfo.nSerial = lpObj->pInventory[n].m_Number;
; 3532 : 					memcpy(&pbuffer[lofs], &petIteminfo, sizeof(petIteminfo));

  00090	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR tv358[ebp]
  00096	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  00099	ff 85 f8 fb ff
	ff		 inc	 DWORD PTR _founditemcount$1$[ebp]

; 3533 : 					lofs +=sizeof(petIteminfo);

  0009f	83 85 f4 fb ff
	ff 08		 add	 DWORD PTR _lofs$1$[ebp], 8
  000a6	88 9d d0 fb ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp], bl
  000ac	8b 85 d0 fb ff
	ff		 mov	 eax, DWORD PTR _petIteminfo$[ebp]
  000b2	89 02		 mov	 DWORD PTR [edx], eax
  000b4	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000b7	83 c2 08	 add	 edx, 8
  000ba	89 95 f0 fb ff
	ff		 mov	 DWORD PTR tv358[ebp], edx
$LN2@gObjReques:

; 3522 : 	{
; 3523 : 		for ( int n=0;n<INVENTORY_SIZE;n++)

  000c0	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  000c6	43		 inc	 ebx
  000c7	81 fe 44 c4 00
	00		 cmp	 esi, 50244		; 0000c444H
  000cd	7c 91		 jl	 SHORT $LL4@gObjReques

; 3534 : 				}
; 3535 : 			}
; 3536 : 		}
; 3537 : 	}
; 3538 : 	else if ( inventype == 1 )

  000cf	e9 8b 00 00 00	 jmp	 $LN6@gObjReques
$LN8@gObjReques:
  000d4	83 f8 01	 cmp	 eax, 1
  000d7	0f 85 18 01 00
	00		 jne	 $LN17@gObjReques

; 3539 : 	{
; 3540 : 		for ( int n=0;n<WAREHOUSE_SIZE;n++)

  000dd	8d 85 10 fc ff
	ff		 lea	 eax, DWORD PTR _pbuffer$[ebp+20]
  000e3	33 db		 xor	 ebx, ebx
  000e5	89 85 f0 fb ff
	ff		 mov	 DWORD PTR tv355[ebp], eax
  000eb	33 f6		 xor	 esi, esi
  000ed	0f 1f 00	 npad	 3
$LL7@gObjReques:

; 3541 : 		{
; 3542 : 			if ( lpObj->pWarehouse[n].IsItem() )

  000f0	8b 8f f8 11 00
	00		 mov	 ecx, DWORD PTR [edi+4600]
  000f6	03 ce		 add	 ecx, esi
  000f8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000fd	85 c0		 test	 eax, eax
  000ff	74 4f		 je	 SHORT $LN5@gObjReques

; 3543 : 			{
; 3544 : 				if ( lpObj->pWarehouse[n].m_Type == ITEMGET(13,4) || lpObj->pWarehouse[n].m_Type == ITEMGET(13,5) )

  00101	8b 8f f8 11 00
	00		 mov	 ecx, DWORD PTR [edi+4600]
  00107	ba 04 1a 00 00	 mov	 edx, 6660		; 00001a04H
  0010c	0f b7 44 31 06	 movzx	 eax, WORD PTR [ecx+esi+6]
  00111	66 3b c2	 cmp	 ax, dx
  00114	74 0a		 je	 SHORT $LN16@gObjReques
  00116	ba 05 1a 00 00	 mov	 edx, 6661		; 00001a05H
  0011b	66 3b c2	 cmp	 ax, dx
  0011e	75 30		 jne	 SHORT $LN5@gObjReques
$LN16@gObjReques:

; 3545 : 				{
; 3546 : 					founditemcount++;
; 3547 : 					petIteminfo.nPos = n;
; 3548 : 					petIteminfo.nSerial = lpObj->pWarehouse[n].m_Number;
; 3549 : 					memcpy(&pbuffer[lofs], &petIteminfo, sizeof(petIteminfo));

  00120	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR tv355[ebp]
  00126	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  00129	ff 85 f8 fb ff
	ff		 inc	 DWORD PTR _founditemcount$1$[ebp]

; 3550 : 					lofs +=sizeof(petIteminfo);

  0012f	83 85 f4 fb ff
	ff 08		 add	 DWORD PTR _lofs$1$[ebp], 8
  00136	88 9d d0 fb ff
	ff		 mov	 BYTE PTR _petIteminfo$[ebp], bl
  0013c	8b 85 d0 fb ff
	ff		 mov	 eax, DWORD PTR _petIteminfo$[ebp]
  00142	89 02		 mov	 DWORD PTR [edx], eax
  00144	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00147	83 c2 08	 add	 edx, 8
  0014a	89 95 f0 fb ff
	ff		 mov	 DWORD PTR tv355[ebp], edx
$LN5@gObjReques:

; 3539 : 	{
; 3540 : 		for ( int n=0;n<WAREHOUSE_SIZE;n++)

  00150	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00156	43		 inc	 ebx
  00157	81 fe c0 c6 00
	00		 cmp	 esi, 50880		; 0000c6c0H
  0015d	7c 91		 jl	 SHORT $LL7@gObjReques
$LN6@gObjReques:

; 3551 : 				}
; 3552 : 			}
; 3553 : 		}
; 3554 : 	}
; 3555 : 	
; 3556 : 	if ( founditemcount )

  0015f	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR _founditemcount$1$[ebp]
  00165	85 d2		 test	 edx, edx
  00167	0f 84 88 00 00
	00		 je	 $LN17@gObjReques

; 3557 : 	{
; 3558 : 		SDHP_REQUEST_PETITEM_INFO pMsg;
; 3559 : 
; 3560 : 		pMsg.h.set((LPBYTE)&pMsg, 0x56, lofs + sizeof(pMsg));

  0016d	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _lofs$1$[ebp]

; 3561 : 		memcpy(pMsg.AccountID, lpObj->AccountID, MAX_ACCOUNT_LEN);

  00173	f3 0f 7e 47 52	 movq	 xmm0, QWORD PTR [edi+82]
  00178	83 c1 14	 add	 ecx, 20			; 00000014H
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 112  : 		lpBuf[1] = SET_NUMBERH(size);

  0017b	8b c1		 mov	 eax, ecx

; 113  : 		lpBuf[2] = SET_NUMBERL(size);

  0017d	88 8d de fb ff
	ff		 mov	 BYTE PTR _pMsg$1[ebp+2], cl
  00183	c1 e8 08	 shr	 eax, 8
  00186	88 85 dd fb ff
	ff		 mov	 BYTE PTR _pMsg$1[ebp+1], al
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 3561 : 		memcpy(pMsg.AccountID, lpObj->AccountID, MAX_ACCOUNT_LEN);

  0018c	66 8b 47 5a	 mov	 ax, WORD PTR [edi+90]
  00190	66 89 85 e8 fb
	ff ff		 mov	 WORD PTR _pMsg$1[ebp+12], ax

; 3562 : 		pMsg.Number = aIndex;

  00197	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR _aIndex$GSCopy$1$[ebp]
  0019d	66 89 85 ec fb
	ff ff		 mov	 WORD PTR _pMsg$1[ebp+16], ax

; 3563 : 		pMsg.InvenType = inventype;

  001a4	8b 45 0c	 mov	 eax, DWORD PTR _inventype$[ebp]
  001a7	88 85 ee fb ff
	ff		 mov	 BYTE PTR _pMsg$1[ebp+18], al

; 3564 : 		pMsg.nCount = founditemcount;

  001ad	88 95 ef fb ff
	ff		 mov	 BYTE PTR _pMsg$1[ebp+19], dl

; 3565 : 		memcpy(pbuffer, &pMsg, sizeof(pMsg));

  001b3	8b 85 ec fb ff
	ff		 mov	 eax, DWORD PTR _pMsg$1[ebp+16]
  001b9	66 0f d6 85 e0
	fb ff ff	 movq	 QWORD PTR _pMsg$1[ebp+4], xmm0
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 111  : 		lpBuf[0] = 0xC2;

  001c1	c6 85 dc fb ff
	ff c2		 mov	 BYTE PTR _pMsg$1[ebp], 194 ; 000000c2H

; 114  : 		lpBuf[3] = head;

  001c8	c6 85 df fb ff
	ff 56		 mov	 BYTE PTR _pMsg$1[ebp+3], 86 ; 00000056H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 3565 : 		memcpy(pbuffer, &pMsg, sizeof(pMsg));

  001cf	0f 10 85 dc fb
	ff ff		 movups	 xmm0, XMMWORD PTR _pMsg$1[ebp]
  001d6	89 85 0c fc ff
	ff		 mov	 DWORD PTR _pbuffer$[ebp+16], eax

; 3566 : 
; 3567 : 		cDBSMng.Send((PCHAR)pbuffer, lofs+sizeof(pMsg));

  001dc	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _pbuffer$[ebp]
  001e2	51		 push	 ecx
  001e3	50		 push	 eax
  001e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  001e9	0f 11 85 fc fb
	ff ff		 movups	 XMMWORD PTR _pbuffer$[ebp], xmm0
  001f0	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN17@gObjReques:

; 3568 : 	}
; 3569 : }

  001f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f8	5f		 pop	 edi
  001f9	5e		 pop	 esi
  001fa	33 cd		 xor	 ecx, ebp
  001fc	5b		 pop	 ebx
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c3		 ret	 0
?gObjRequestPetItemInfo@@YAXHH@Z ENDP			; gObjRequestPetItemInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z
_TEXT	SEGMENT
_pResult$1 = 8						; size = 4
_lpMsg$ = 8						; size = 4
?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z PROC ; DGMoveOtherServer, COMDAT

; 3446 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 3447 : 	if ( !gObjIsConnectedGP(lpMsg->Number))

  00004	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00007	0f bf 47 0e	 movsx	 eax, WORD PTR [edi+14]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00011	83 c4 04	 add	 esp, 4
  00014	85 c0		 test	 eax, eax
  00016	75 1d		 jne	 SHORT $LN2@DGMoveOthe

; 3448 : 	{
; 3449 : 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00018	68 79 0d 00 00	 push	 3449			; 00000d79H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DNGOKBGI@DSProtocol?4cpp?$AA@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00027	6a 02		 push	 2
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002f	83 c4 10	 add	 esp, 16			; 00000010H
  00032	5f		 pop	 edi

; 3483 : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
$LN2@DGMoveOthe:

; 3450 : 		return;
; 3451 : 	}
; 3452 : 
; 3453 : 	LPOBJ lpObj = &gObj[lpMsg->Number];

  00035	0f bf 47 0e	 movsx	 eax, WORD PTR [edi+14]
  00039	56		 push	 esi
  0003a	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  00040	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3454 : 
; 3455 : 	if ( lpMsg->Result != 0 )

  00046	80 7f 10 00	 cmp	 BYTE PTR [edi+16], 0
  0004a	74 5b		 je	 SHORT $LN3@DGMoveOthe

; 3456 : 	{
; 3457 : 		PMSG_DEFRESULT pResult;
; 3458 : 
; 3459 : 		PHeadSetB((LPBYTE)&pResult, 0x99, sizeof(pResult));

  0004c	6a 04		 push	 4
  0004e	8d 45 08	 lea	 eax, DWORD PTR _pResult$1[ebp]
  00051	68 99 00 00 00	 push	 153			; 00000099H
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 3460 : 		pResult.result = 1;
; 3461 : 
; 3462 : 		DataSend(lpMsg->Number, (LPBYTE)&pResult, pResult.h.size);

  0005c	0f b6 45 09	 movzx	 eax, BYTE PTR _pResult$1[ebp+1]
  00060	50		 push	 eax
  00061	8d 45 08	 lea	 eax, DWORD PTR _pResult$1[ebp]
  00064	c6 45 0b 01	 mov	 BYTE PTR _pResult$1[ebp+3], 1
  00068	50		 push	 eax
  00069	0f bf 47 0e	 movsx	 eax, WORD PTR [edi+14]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3463 : 
; 3464 : 		LogAddTD("[CharTrasfer] Fail [%s][%s] (%d)",

  00073	0f b6 47 10	 movzx	 eax, BYTE PTR [edi+16]
  00077	50		 push	 eax
  00078	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0007b	50		 push	 eax
  0007c	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DOBLFOAF@?$FLCharTrasfer?$FN?5Fail?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ@
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3465 : 			lpObj->AccountID, lpObj->Name, lpMsg->Result);
; 3466 : 		
; 3467 : 		lpObj->m_MoveOtherServer = 0;
; 3468 : 		
; 3469 : 		GCServerMsgStringSend("  change@webzen.co.kr  ",lpObj->m_Index, 1);

  0008b	6a 01		 push	 1
  0008d	ff 36		 push	 DWORD PTR [esi]
  0008f	c6 86 68 14 00
	00 00		 mov	 BYTE PTR [esi+5224], 0
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@
  0009b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000a0	83 c4 34	 add	 esp, 52			; 00000034H
  000a3	5e		 pop	 esi
  000a4	5f		 pop	 edi

; 3483 : }

  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
$LN3@DGMoveOthe:

; 3470 : 		// Deathway translation here
; 3471 : 		return;
; 3472 : 	}
; 3473 : 
; 3474 : 	LogAddTD("[CharTrasfer] Success [%s][%s] (%d)",

  000a7	6a 00		 push	 0
  000a9	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000ac	50		 push	 eax
  000ad	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  000b0	50		 push	 eax
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IPHEEDFH@?$FLCharTrasfer?$FN?5Success?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI@
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3475 : 		lpObj->AccountID, lpObj->Name, lpMsg->Result);
; 3476 : 
; 3477 : 	GCServerMsgStringSend(" .", lpObj->m_Index, 1);// Deathway translation here

  000bc	6a 01		 push	 1
  000be	ff 36		 push	 DWORD PTR [esi]
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IBAEEAEE@?A?$KC?$LM?S?$MA?L?5?A?$LO?$LH?a?$LF?K?$LE?O?$LE?Y?4?$AA@
  000c5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 3478 : 	GCServerMsgStringSend("   .", lpObj->m_Index, 1);// Deathway translation here

  000ca	6a 01		 push	 1
  000cc	ff 36		 push	 DWORD PTR [esi]
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@HNLEMMHH@?$LK?P?G?R?5?$LM?$KN?$LJ?v?$LH?N?5?A?$KC?$LM?S?G?X?A?V?$LN?C?$LB?b?5?$LJ?Y?$LG?x?$LE?O?$LE@
  000d3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 3479 : 	GJSetCharacterInfo(lpObj, lpObj->m_Index, 0);

  000d8	6a 01		 push	 1
  000da	6a 00		 push	 0
  000dc	ff 36		 push	 DWORD PTR [esi]
  000de	56		 push	 esi
  000df	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z ; GJSetCharacterInfo

; 3480 : 	lpObj->LoadWareHouseInfo = false;
; 3481 : 	gObjCloseSet(lpObj->m_Index, 2);

  000e4	6a 02		 push	 2
  000e6	ff 36		 push	 DWORD PTR [esi]
  000e8	c6 86 ec 13 00
	00 00		 mov	 BYTE PTR [esi+5100], 0
  000ef	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  000f4	83 c4 40	 add	 esp, 64			; 00000040H

; 3482 : 	lpObj->m_MoveOtherServer = 0;

  000f7	c6 86 68 14 00
	00 00		 mov	 BYTE PTR [esi+5224], 0
  000fe	5e		 pop	 esi
  000ff	5f		 pop	 edi

; 3483 : }

  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z ENDP ; DGMoveOtherServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z
_TEXT	SEGMENT
_szName$ = -12						; size = 11
_lpMsg$ = 8						; size = 4
?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z PROC ; DGOptionDataRecv, COMDAT

; 3418 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 3419 : 	int aIndex = lpMsg->aIndex;

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]

; 3420 : 	char szName[MAX_ACCOUNT_LEN+1];
; 3421 : 
; 3422 : 	if ( aIndex < 0 || aIndex >= OBJMAX )

  0000e	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00014	0f 87 ad 00 00
	00		 ja	 $LN3@DGOptionDa

; 3423 : 	{
; 3424 : 		return;
; 3425 : 	}
; 3426 : 
; 3427 : 	memset(szName, 0, sizeof(szName));
; 3428 : 	memcpy(szName, lpMsg->Name, sizeof(lpMsg->Name));

  0001a	66 8b 46 10	 mov	 ax, WORD PTR [esi+16]
  0001e	0f 57 c0	 xorps	 xmm0, xmm0

; 3429 : 
; 3430 : 	if ( strcmp(gObj[aIndex].Name, szName) != 0 )

  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00027	53		 push	 ebx
  00028	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  0002e	83 c1 5d	 add	 ecx, 93			; 0000005dH
  00031	66 0f d6 45 f4	 movq	 QWORD PTR _szName$[ebp], xmm0
  00036	f3 0f 7e 46 08	 movq	 xmm0, QWORD PTR [esi+8]
  0003b	66 c7 45 fc 00
	00		 mov	 WORD PTR _szName$[ebp+8], 0
  00041	66 89 45 fc	 mov	 WORD PTR _szName$[ebp+8], ax
  00045	8d 45 f4	 lea	 eax, DWORD PTR _szName$[ebp]
  00048	c6 45 fe 00	 mov	 BYTE PTR _szName$[ebp+10], 0
  0004c	03 cb		 add	 ecx, ebx
  0004e	66 0f d6 45 f4	 movq	 QWORD PTR _szName$[ebp], xmm0
$LL6@DGOptionDa:
  00053	8a 11		 mov	 dl, BYTE PTR [ecx]
  00055	3a 10		 cmp	 dl, BYTE PTR [eax]
  00057	75 1a		 jne	 SHORT $LN7@DGOptionDa
  00059	84 d2		 test	 dl, dl
  0005b	74 12		 je	 SHORT $LN8@DGOptionDa
  0005d	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00060	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00063	75 0e		 jne	 SHORT $LN7@DGOptionDa
  00065	83 c1 02	 add	 ecx, 2
  00068	83 c0 02	 add	 eax, 2
  0006b	84 d2		 test	 dl, dl
  0006d	75 e4		 jne	 SHORT $LL6@DGOptionDa
$LN8@DGOptionDa:
  0006f	33 c0		 xor	 eax, eax
  00071	eb 05		 jmp	 SHORT $LN9@DGOptionDa
$LN7@DGOptionDa:
  00073	1b c0		 sbb	 eax, eax
  00075	83 c8 01	 or	 eax, 1
$LN9@DGOptionDa:
  00078	85 c0		 test	 eax, eax
  0007a	75 4a		 jne	 SHORT $LN10@DGOptionDa

; 3431 : 	{
; 3432 : 		return;
; 3433 : 	}
; 3434 : 
; 3435 : 	::GCSkillKeySend(aIndex, lpMsg->SkillKeyBuffer, lpMsg->GameOption, lpMsg->QkeyDefine, lpMsg->WkeyDefine, lpMsg->EkeyDefine, lpMsg->ChatWindow, lpMsg->RkeyDefine, lpMsg->QWERLevel);

  0007c	ff 76 2c	 push	 DWORD PTR [esi+44]
  0007f	0f b6 46 2b	 movzx	 eax, BYTE PTR [esi+43]
  00083	50		 push	 eax
  00084	0f b6 46 2a	 movzx	 eax, BYTE PTR [esi+42]
  00088	50		 push	 eax
  00089	0f b6 46 29	 movzx	 eax, BYTE PTR [esi+41]
  0008d	50		 push	 eax
  0008e	0f b6 46 28	 movzx	 eax, BYTE PTR [esi+40]
  00092	50		 push	 eax
  00093	0f b6 46 27	 movzx	 eax, BYTE PTR [esi+39]
  00097	50		 push	 eax
  00098	0f b6 46 26	 movzx	 eax, BYTE PTR [esi+38]
  0009c	50		 push	 eax
  0009d	8d 46 12	 lea	 eax, DWORD PTR [esi+18]
  000a0	50		 push	 eax
  000a1	57		 push	 edi
  000a2	e8 00 00 00 00	 call	 ?GCSkillKeySend@@YAXHPAEEEEEEEK@Z ; GCSkillKeySend

; 3436 : 	gObj[aIndex].m_EnableUseChangeSkin = lpMsg->EnableTransfromMode;

  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ac	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  000af	88 8c 03 12 27
	00 00		 mov	 BYTE PTR [ebx+eax+10002], cl

; 3437 :     gObjViewportListProtocolCreate(&gObj[aIndex]);

  000b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bb	03 c3		 add	 eax, ebx
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  000c3	83 c4 28	 add	 esp, 40			; 00000028H
$LN10@DGOptionDa:
  000c6	5b		 pop	 ebx
$LN3@DGOptionDa:
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi

; 3438 : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z ENDP ; DGOptionDataRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGOptionDataSend@@YAXHPADPAEEEEEEEKD@Z
_TEXT	SEGMENT
_pMsg$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_szName$ = 12						; size = 4
_KeyBuffer$ = 16					; size = 4
_GO$ = 20						; size = 1
_Qk$ = 24						; size = 1
_Wk$ = 28						; size = 1
_Ek$ = 32						; size = 1
_ChatWnd$ = 36						; size = 1
_Rk$ = 40						; size = 1
_QWERLevel$ = 44					; size = 4
_EnableTransfromMode$ = 48				; size = 1
?DGOptionDataSend@@YAXHPADPAEEEEEEEKD@Z PROC		; DGOptionDataSend, COMDAT

; 3394 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _szName$[ebp]
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _KeyBuffer$[ebp]

; 3395 : 	SDHP_SKILLKEYDATA pMsg;
; 3396 : 
; 3397 : 	pMsg.h.c = 0xC1;
; 3398 : 	pMsg.h.headcode = 0x60;
; 3399 : 	pMsg.h.size = sizeof(pMsg);
; 3400 : 	memcpy(pMsg.Name, szName, sizeof(pMsg.Name));
; 3401 : 	memcpy(pMsg.SkillKeyBuffer, KeyBuffer, sizeof(pMsg.SkillKeyBuffer));
; 3402 : 	pMsg.GameOption = GO;
; 3403 : 	pMsg.QkeyDefine = Qk;
; 3404 : 	pMsg.WkeyDefine = Wk;
; 3405 : 	pMsg.EkeyDefine = Ek;
; 3406 : 	pMsg.ChatWindow = ChatWnd;
; 3407 : 	pMsg.RkeyDefine = Rk;
; 3408 : 	pMsg.QWERLevel = QWERLevel;
; 3409 : 	pMsg.EnableTransfromMode = EnableTransfromMode; //1.01.06
; 3410 : 
; 3411 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00016	6a 30		 push	 48			; 00000030H
  00018	66 c7 45 cc c1
	30		 mov	 WORD PTR _pMsg$[ebp], 12481 ; 000030c1H
  0001e	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00022	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  00026	66 89 45 d7	 mov	 WORD PTR _pMsg$[ebp+11], ax
  0002a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002d	89 45 e9	 mov	 DWORD PTR _pMsg$[ebp+29], eax
  00030	8a 45 14	 mov	 al, BYTE PTR _GO$[ebp]
  00033	88 45 ed	 mov	 BYTE PTR _pMsg$[ebp+33], al
  00036	8a 45 18	 mov	 al, BYTE PTR _Qk$[ebp]
  00039	88 45 ee	 mov	 BYTE PTR _pMsg$[ebp+34], al
  0003c	8a 45 1c	 mov	 al, BYTE PTR _Wk$[ebp]
  0003f	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+35], al
  00042	8a 45 20	 mov	 al, BYTE PTR _Ek$[ebp]
  00045	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+36], al
  00048	8a 45 24	 mov	 al, BYTE PTR _ChatWnd$[ebp]
  0004b	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+37], al
  0004e	8a 45 28	 mov	 al, BYTE PTR _Rk$[ebp]
  00051	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+38], al
  00054	8b 45 2c	 mov	 eax, DWORD PTR _QWERLevel$[ebp]
  00057	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+40], eax
  0005a	8a 45 30	 mov	 al, BYTE PTR _EnableTransfromMode$[ebp]
  0005d	66 0f d6 45 cf	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  00062	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00065	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+44], al
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0006d	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00070	c6 45 ce 60	 mov	 BYTE PTR _pMsg$[ebp+2], 96 ; 00000060H
  00074	50		 push	 eax
  00075	0f 11 45 d9	 movups	 XMMWORD PTR _pMsg$[ebp+13], xmm0
  00079	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 3412 : }

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00081	33 cd		 xor	 ecx, ebp
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?DGOptionDataSend@@YAXHPADPAEEEEEEEKD@Z ENDP		; DGOptionDataSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z
_TEXT	SEGMENT
_pMsg$ = -80						; size = 76
__$ArrayPad$ = -4					; size = 4
_ActID$ = 8						; size = 4
_Name$ = 12						; size = 4
_level$ = 16						; size = 1
_mapnumber$ = 20					; size = 1
_x$ = 24						; size = 1
_y$ = 28						; size = 1
_Item$ = 32						; size = 4
_op1$ = 36						; size = 1
_op2$ = 40						; size = 1
_op3$ = 44						; size = 1
_serial$ = 48						; size = 4
?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z PROC		; ItemMovePathSave, COMDAT

; 3343 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3344 : 	SDHP_ITEMMOVESAVE pMsg;
; 3345 : 
; 3346 : 	pMsg.h.c = 0xC1;
; 3347 : 	pMsg.h.headcode = 0x53;
; 3348 : 	pMsg.h.size = sizeof(pMsg);
; 3349 : 	pMsg.ItemLevel = level;

  00010	8a 45 10	 mov	 al, BYTE PTR _level$[ebp]

; 3350 : 	pMsg.Serial = serial;
; 3351 : 	pMsg.ItemOp1 = op1;
; 3352 : 	pMsg.ItemOp2 = op2;
; 3353 : 	pMsg.ItemOp3 = op3;
; 3354 : 	pMsg.X = x;
; 3355 : 	pMsg.Y = y;
; 3356 : 	memcpy(pMsg.Account, ActID, sizeof(pMsg.Account));
; 3357 : 	strcpy(pMsg.ItemName, Item);

  00013	8d 55 e0	 lea	 edx, DWORD PTR _pMsg$[ebp+48]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _ActID$[ebp]
  00019	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+71], al
  0001c	8b 45 30	 mov	 eax, DWORD PTR _serial$[ebp]
  0001f	89 45 b4	 mov	 DWORD PTR _pMsg$[ebp+4], eax
  00022	8a 45 24	 mov	 al, BYTE PTR _op1$[ebp]
  00025	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00029	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+72], al
  0002c	8a 45 28	 mov	 al, BYTE PTR _op2$[ebp]
  0002f	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+73], al
  00032	8a 45 2c	 mov	 al, BYTE PTR _op3$[ebp]
  00035	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+74], al
  00038	8a 45 18	 mov	 al, BYTE PTR _x$[ebp]
  0003b	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+69], al
  0003e	8a 45 1c	 mov	 al, BYTE PTR _y$[ebp]
  00041	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+70], al
  00044	66 8b 41 08	 mov	 ax, WORD PTR [ecx+8]
  00048	8b 4d 20	 mov	 ecx, DWORD PTR _Item$[ebp]
  0004b	2b d1		 sub	 edx, ecx
  0004d	56		 push	 esi
  0004e	8b 75 0c	 mov	 esi, DWORD PTR _Name$[ebp]
  00051	66 c7 45 b0 c1
	4c		 mov	 WORD PTR _pMsg$[ebp], 19649 ; 00004cc1H
  00057	c6 45 b2 53	 mov	 BYTE PTR _pMsg$[ebp+2], 83 ; 00000053H
  0005b	66 0f d6 45 cc	 movq	 QWORD PTR _pMsg$[ebp+28], xmm0
  00060	66 89 45 d4	 mov	 WORD PTR _pMsg$[ebp+36], ax
$LL3@ItemMovePa:
  00064	8a 01		 mov	 al, BYTE PTR [ecx]
  00066	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00069	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  0006d	84 c0		 test	 al, al
  0006f	75 f3		 jne	 SHORT $LL3@ItemMovePa

; 3358 : 	memcpy(pMsg.Name, Name, sizeof(pMsg.Name));

  00071	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  00075	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  00079	66 89 45 de	 mov	 WORD PTR _pMsg$[ebp+46], ax

; 3359 : 	strcpy(pMsg.ServerName, szServerName);

  0007d	33 c0		 xor	 eax, eax
  0007f	66 0f d6 45 d6	 movq	 QWORD PTR _pMsg$[ebp+38], xmm0
  00084	5e		 pop	 esi
  00085	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@ItemMovePa:
  00090	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?szServerName@@3PADA[eax]
  00096	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00099	88 4c 05 b7	 mov	 BYTE PTR _pMsg$[ebp+eax+7], cl
  0009d	84 c9		 test	 cl, cl
  0009f	75 ef		 jne	 SHORT $LL4@ItemMovePa

; 3360 : 
; 3361 : 	cDBSMng.Send((PCHAR)&pMsg, pMsg.h.size);

  000a1	0f b6 45 b1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000aa	50		 push	 eax
  000ab	8d 45 b0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 3362 : }

  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	33 cd		 xor	 ecx, ebp
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?ItemMovePathSave@@YAXPAD0EEEE0EEEK@Z ENDP		; ItemMovePathSave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$1$ = -268					; size = 4
tv1306 = -268						; size = 4
_iRetMapNumber$1$ = -264				; size = 4
_aIndex$1$ = -264					; size = 4
tv1177 = -264						; size = 4
_iItemCount$1$ = -260					; size = 4
_iItemType$1$ = -260					; size = 4
_iItemType$1$ = -260					; size = 4
_SocketBonus$ = -260					; size = 1
tv1171 = -260						; size = 4
_pCreateItem$1 = -256					; size = 212
_pCreateItem$2 = -256					; size = 212
_NewItem$3 = -256					; size = 212
_NewItem$4 = -256					; size = 212
_pMsg$5 = -44						; size = 16
_SocketOption$ = -28					; size = 5
_ExOption$6 = -20					; size = 8
_iItemIndex$1$ = -16					; size = 4
_iItemIndex$1$ = -16					; size = 4
_iType$1$ = -16						; size = 4
_lootindex$1$ = -16					; size = 4
tv1174 = -16						; size = 4
_NewOption$7 = -12					; size = 8
_iTypeIndex$1$ = -8					; size = 4
_lpObj$1$ = -8						; size = 4
tv1311 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z PROC ; ItemSerialCreateRecv, COMDAT

; 2990 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	89 9d f4 fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], ebx

; 2991 : 
; 2992 : #if( DEBUG_DROP == 1)
; 2993 : 	DROP_LOG_DEBUG.Output("PACKET_RECIEVED [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d] Set:[%d]",

  0001f	0f b6 43 1a	 movzx	 eax, BYTE PTR [ebx+26]
  00023	50		 push	 eax
  00024	0f b6 43 13	 movzx	 eax, BYTE PTR [ebx+19]
  00028	50		 push	 eax
  00029	0f b6 43 12	 movzx	 eax, BYTE PTR [ebx+18]
  0002d	50		 push	 eax
  0002e	0f b6 43 11	 movzx	 eax, BYTE PTR [ebx+17]
  00032	50		 push	 eax
  00033	0f b6 43 10	 movzx	 eax, BYTE PTR [ebx+16]
  00037	50		 push	 eax
  00038	0f b6 43 0e	 movzx	 eax, BYTE PTR [ebx+14]
  0003c	50		 push	 eax
  0003d	0f bf 43 0c	 movsx	 eax, WORD PTR [ebx+12]
  00041	6b c0 70	 imul	 eax, eax, 112
  00044	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00049	50		 push	 eax
  0004a	ff 73 08	 push	 DWORD PTR [ebx+8]
  0004d	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00051	50		 push	 eax
  00052	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  00056	50		 push	 eax
  00057	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  0005b	50		 push	 eax
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@GIBMCCNN@PACKET_RECIEVED?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3?5s@
  00061	68 00 00 00 00	 push	 OFFSET ?DROP_LOG_DEBUG@@3VCLogToFile@@A ; DROP_LOG_DEBUG
  00066	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 2994 : 		lpMsg->MapNumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 2995 : 		lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption,lpMsg->SetOption);
; 2996 : #endif
; 2997 : 
; 2998 : 	LPOBJ lpObj;
; 2999 : 	int mapnumber = lpMsg->MapNumber;

  0006b	8a 4b 05	 mov	 cl, BYTE PTR [ebx+5]
  0006e	83 c4 34	 add	 esp, 52			; 00000034H

; 3000 : 	int aIndex = lpMsg->aIndex;
; 3001 : 	int lootindex = lpMsg->lootindex;

  00071	0f bf 43 18	 movsx	 eax, WORD PTR [ebx+24]
  00075	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]
  00078	0f b6 f9	 movzx	 edi, cl
  0007b	89 b5 f8 fe ff
	ff		 mov	 DWORD PTR _aIndex$1$[ebp], esi
  00081	89 45 f0	 mov	 DWORD PTR _lootindex$1$[ebp], eax

; 3002 : 	BYTE SocketBonus = lpMsg->SocketBonus;
; 3003 : 	BYTE SocketOption[5];
; 3004 : 
; 3005 : 	if ( mapnumber != (BYTE)-1)

  00084	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  0008a	74 16		 je	 SHORT $LN9@ItemSerial

; 3006 : 	{
; 3007 : 		if ( mapnumber < 0 || (mapnumber > MAX_NUMBER_MAP-1 && mapnumber < 235) )

  0008c	85 ff		 test	 edi, edi
  0008e	0f 88 99 09 00
	00		 js	 $LN35@ItemSerial
  00094	8d 47 9c	 lea	 eax, DWORD PTR [edi-100]
  00097	3d 86 00 00 00	 cmp	 eax, 134		; 00000086H
  0009c	0f 86 8b 09 00
	00		 jbe	 $LN35@ItemSerial
$LN9@ItemSerial:

; 3008 : 		{
; 3009 : 			return;
; 3010 : 		}
; 3011 : 	}
; 3012 : 
; 3013 : 	SocketBonus = lpMsg->SocketBonus;

  000a2	8a 43 1b	 mov	 al, BYTE PTR [ebx+27]
  000a5	88 85 fc fe ff
	ff		 mov	 BYTE PTR _SocketBonus$[ebp], al

; 3014 : 
; 3015 : 	for(int i = 0; i < MAX_SOCKET_COUNT; i++)
; 3016 : 	{
; 3017 : 		SocketOption[i] = lpMsg->SocketOptions[i];

  000ab	8a 43 1c	 mov	 al, BYTE PTR [ebx+28]
  000ae	88 45 e4	 mov	 BYTE PTR _SocketOption$[ebp], al
  000b1	8a 43 1d	 mov	 al, BYTE PTR [ebx+29]
  000b4	88 45 e5	 mov	 BYTE PTR _SocketOption$[ebp+1], al
  000b7	8a 43 1e	 mov	 al, BYTE PTR [ebx+30]
  000ba	88 45 e6	 mov	 BYTE PTR _SocketOption$[ebp+2], al
  000bd	8a 43 1f	 mov	 al, BYTE PTR [ebx+31]
  000c0	88 45 e7	 mov	 BYTE PTR _SocketOption$[ebp+3], al
  000c3	8a 43 20	 mov	 al, BYTE PTR [ebx+32]
  000c6	88 45 e8	 mov	 BYTE PTR _SocketOption$[ebp+4], al

; 3018 : 	}
; 3019 : 
; 3020 : 
; 3021 : 
; 3022 : 	if ( lpMsg->MapNumber == (BYTE)-1 || lpMsg->MapNumber == (BYTE)-2 )

  000c9	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  000cc	0f 84 c4 06 00
	00		 je	 $LN12@ItemSerial
  000d2	80 f9 fe	 cmp	 cl, 254			; 000000feH
  000d5	0f 84 bb 06 00
	00		 je	 $LN12@ItemSerial

; 3101 : 
; 3102 : 		return;
; 3103 : 	}
; 3104 : 
; 3105 : 	if ( lpMsg->MapNumber == 235 )

  000db	80 f9 eb	 cmp	 cl, 235			; 000000ebH
  000de	0f 85 97 01 00
	00		 jne	 $LN22@ItemSerial

; 3106 : 	{
; 3107 : 		if ( gObj[lpMsg->aIndex].Connected > PLAYER_CONNECTED )

  000e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e9	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  000ef	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  000f4	0f 8e 33 09 00
	00		 jle	 $LN35@ItemSerial

; 3108 : 		{
; 3109 : 			int iType  = ITEM_GET_TYPE(lpMsg->Type);

  000fa	0f bf 4b 0c	 movsx	 ecx, WORD PTR [ebx+12]
  000fe	8b c1		 mov	 eax, ecx
  00100	99		 cdq
  00101	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00107	03 c2		 add	 eax, edx
  00109	c1 f8 09	 sar	 eax, 9
  0010c	89 45 f0	 mov	 DWORD PTR _iType$1$[ebp], eax

; 3110 : 			int iTypeIndex = ITEM_GET_INDEX(lpMsg->Type);

  0010f	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  00115	79 08		 jns	 SHORT $LN71@ItemSerial
  00117	49		 dec	 ecx
  00118	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  0011e	41		 inc	 ecx
$LN71@ItemSerial:
  0011f	89 4d f8	 mov	 DWORD PTR _iTypeIndex$1$[ebp], ecx

; 3111 : 
; 3112 : 			CItem NewItem;

  00122	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$3[ebp]
  00128	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3113 : 			NewItem.m_Level = lpMsg->Level;

  0012d	0f b6 43 0e	 movzx	 eax, BYTE PTR [ebx+14]

; 3114 : 			NewItem.m_Durability = lpMsg->Dur;
; 3115 : 			NewItem.m_Number = lpMsg->m_Number; //Serial fix
; 3116 : 			NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,0,SocketOption,SocketBonus, CURRENT_DB_VERSION);

  00131	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$3[ebp]
  00137	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _NewItem$3[ebp+8], ax
  0013e	0f b6 43 0f	 movzx	 eax, BYTE PTR [ebx+15]
  00142	6a 03		 push	 3
  00144	ff b5 fc fe ff
	ff		 push	 DWORD PTR _SocketBonus$[ebp]
  0014a	66 0f 6e c0	 movd	 xmm0, eax
  0014e	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00151	89 85 00 ff ff
	ff		 mov	 DWORD PTR _NewItem$3[ebp], eax
  00157	8d 45 e4	 lea	 eax, DWORD PTR _SocketOption$[ebp]
  0015a	50		 push	 eax
  0015b	0f b6 43 1a	 movzx	 eax, BYTE PTR [ebx+26]
  0015f	6a 00		 push	 0
  00161	50		 push	 eax
  00162	0f b6 43 13	 movzx	 eax, BYTE PTR [ebx+19]
  00166	50		 push	 eax
  00167	0f b6 43 12	 movzx	 eax, BYTE PTR [ebx+18]
  0016b	50		 push	 eax
  0016c	0f b6 43 11	 movzx	 eax, BYTE PTR [ebx+17]
  00170	50		 push	 eax
  00171	0f b6 43 10	 movzx	 eax, BYTE PTR [ebx+16]
  00175	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00178	50		 push	 eax
  00179	0f bf 43 0c	 movsx	 eax, WORD PTR [ebx+12]
  0017d	50		 push	 eax
  0017e	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _NewItem$3[ebp+36], xmm0
  00186	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert

; 3117 : 
; 3118 : 			BYTE iItemPos = gObjInventoryInsertItem(lpMsg->aIndex, NewItem);

  0018b	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00191	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR _NewItem$3[ebp]
  00197	8b fc		 mov	 edi, esp
  00199	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0019e	f3 a5		 rep movsd
  001a0	ff 73 14	 push	 DWORD PTR [ebx+20]
  001a3	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  001a8	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 3119 : 
; 3120 : 			if( iItemPos == (BYTE)-1 )

  001ae	3c ff		 cmp	 al, 255			; 000000ffH
  001b0	75 42		 jne	 SHORT $LN25@ItemSerial

; 3121 : 			{
; 3122 : #if( DEBUG_DROP == 1)
; 3123 : 				DROP_LOG_DEBUG.Output("[ItemCreate] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",

  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b8	69 53 14 40 27
	00 00		 imul	 edx, DWORD PTR [ebx+20], 10048
  001bf	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001c2	03 c2		 add	 eax, edx
  001c4	50		 push	 eax
  001c5	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001c8	03 c2		 add	 eax, edx
  001ca	50		 push	 eax
  001cb	ff 75 f8	 push	 DWORD PTR _iTypeIndex$1$[ebp]
  001ce	ff 75 f0	 push	 DWORD PTR _iType$1$[ebp]
  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@FHICBGBB@?$FLItemCreate?$FN?5Error?5?3?5Failed?5To?5I@
  001d6	68 00 00 00 00	 push	 OFFSET ?DROP_LOG_DEBUG@@3VCLogToFile@@A ; DROP_LOG_DEBUG
  001db	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  001e0	83 c4 18	 add	 esp, 24			; 00000018H

; 3302 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3303 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3304 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3305 : 			lpMsg->SetOption);
; 3306 : #else
; 3307 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3308 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3309 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3310 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3311 : 			lpMsg->SetOption);
; 3312 : #endif
; 3313 : 		
; 3314 : 	}
; 3315 : }

  001e3	5f		 pop	 edi
  001e4	5e		 pop	 esi
  001e5	5b		 pop	 ebx
  001e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e9	33 cd		 xor	 ecx, ebp
  001eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c3		 ret	 0
$LN25@ItemSerial:

; 3124 : 					iType, iTypeIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);
; 3125 : #else
; 3126 : 				LogAddTD("[ItemCreate] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",
; 3127 : 					iType, iTypeIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);
; 3128 : #endif
; 3129 : 			}
; 3130 : 			else
; 3131 : 			{
; 3132 : 				::GCInventoryItemOneSend(lpMsg->aIndex, iItemPos);

  001f4	0f b6 c0	 movzx	 eax, al
  001f7	50		 push	 eax
  001f8	ff 73 14	 push	 DWORD PTR [ebx+20]
  001fb	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 3133 : #if (ENABLE_CUSTOM_OFFLINETRADE == 1)
; 3134 : 
; 3135 : 				if( gObj[lpMsg->aIndex].bOffTrade && PShop_CheckInventoryEmpty(lpMsg->aIndex) )

  00200	69 4b 14 40 27
	00 00		 imul	 ecx, DWORD PTR [ebx+20], 10048
  00207	83 c4 08	 add	 esp, 8
  0020a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020f	80 bc 01 31 27
	00 00 00	 cmp	 BYTE PTR [ecx+eax+10033], 0
  00217	0f 84 10 08 00
	00		 je	 $LN35@ItemSerial
  0021d	0f b7 43 14	 movzx	 eax, WORD PTR [ebx+20]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ?PShop_CheckInventoryEmpty@@YA_NF@Z ; PShop_CheckInventoryEmpty
  00227	83 c4 04	 add	 esp, 4
  0022a	84 c0		 test	 al, al
  0022c	0f 84 fb 07 00
	00		 je	 $LN35@ItemSerial

; 3136 : 				{
; 3137 : 					gObj[lpMsg->aIndex].OffTradeWaitItem--;

  00232	69 4b 14 40 27
	00 00		 imul	 ecx, DWORD PTR [ebx+20], 10048
  00239	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0023e	fe 8c 01 30 27
	00 00		 dec	 BYTE PTR [ecx+eax+10032]

; 3138 : 					if( gObj[lpMsg->aIndex].OffTradeWaitItem <= 0 )

  00245	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  00248	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024d	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00253	80 bc 01 30 27
	00 00 00	 cmp	 BYTE PTR [ecx+eax+10032], 0
  0025b	0f 87 cc 07 00
	00		 ja	 $LN35@ItemSerial

; 3139 : 					{
; 3140 : 						gObjDel(lpMsg->aIndex);

  00261	52		 push	 edx
  00262	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00267	83 c4 04	 add	 esp, 4

; 3302 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3303 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3304 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3305 : 			lpMsg->SetOption);
; 3306 : #else
; 3307 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3308 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3309 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3310 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3311 : 			lpMsg->SetOption);
; 3312 : #endif
; 3313 : 		
; 3314 : 	}
; 3315 : }

  0026a	5f		 pop	 edi
  0026b	5e		 pop	 esi
  0026c	5b		 pop	 ebx
  0026d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00270	33 cd		 xor	 ecx, ebp
  00272	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00277	8b e5		 mov	 esp, ebp
  00279	5d		 pop	 ebp
  0027a	c3		 ret	 0
$LN22@ItemSerial:

; 3141 : 					}
; 3142 : 				}
; 3143 : #endif
; 3144 : 			}
; 3145 : 
; 3146 : 		}
; 3147 : 	}
; 3148 : 	else if ( lpMsg->MapNumber == 236 )

  0027b	80 f9 ec	 cmp	 cl, 236			; 000000ecH
  0027e	0f 85 11 01 00
	00		 jne	 $LN29@ItemSerial

; 3149 : 	{
; 3150 : 		if ( gObj[lpMsg->aIndex].Connected > PLAYER_CONNECTED )

  00284	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00289	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0028f	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  00294	0f 8e 93 07 00
	00		 jle	 $LN35@ItemSerial

; 3151 : 		{
; 3152 : 			CItem pCreateItem;

  0029a	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$2[ebp]
  002a0	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3153 : 			int iItemType = ITEM_GET_TYPE(lpMsg->Type);

  002a5	0f bf 4b 0c	 movsx	 ecx, WORD PTR [ebx+12]
  002a9	8b c1		 mov	 eax, ecx
  002ab	99		 cdq
  002ac	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  002b2	03 d0		 add	 edx, eax
  002b4	c1 fa 09	 sar	 edx, 9
  002b7	89 95 fc fe ff
	ff		 mov	 DWORD PTR _iItemType$1$[ebp], edx

; 3154 : 			int iItemIndex	= ITEM_GET_INDEX(lpMsg->Type);

  002bd	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  002c3	79 08		 jns	 SHORT $LN72@ItemSerial
  002c5	49		 dec	 ecx
  002c6	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  002cc	41		 inc	 ecx
$LN72@ItemSerial:

; 3155 : 
; 3156 : 			pCreateItem.m_Level = lpMsg->Level;

  002cd	0f b6 43 0e	 movzx	 eax, BYTE PTR [ebx+14]
  002d1	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _pCreateItem$2[ebp+8], ax

; 3157 : 			pCreateItem.m_Durability = lpMsg->Dur;

  002d8	0f b6 43 0f	 movzx	 eax, BYTE PTR [ebx+15]

; 3158 : 
; 3159 : 			pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2,

  002dc	6a 03		 push	 3
  002de	68 ff 00 00 00	 push	 255			; 000000ffH
  002e3	6a 00		 push	 0
  002e5	66 0f 6e c0	 movd	 xmm0, eax
  002e9	0f b6 43 1a	 movzx	 eax, BYTE PTR [ebx+26]
  002ed	6a 00		 push	 0
  002ef	50		 push	 eax
  002f0	0f b6 43 13	 movzx	 eax, BYTE PTR [ebx+19]
  002f4	50		 push	 eax
  002f5	0f b6 43 12	 movzx	 eax, BYTE PTR [ebx+18]
  002f9	50		 push	 eax
  002fa	0f b6 43 11	 movzx	 eax, BYTE PTR [ebx+17]
  002fe	50		 push	 eax
  002ff	0f b6 43 10	 movzx	 eax, BYTE PTR [ebx+16]
  00303	50		 push	 eax
  00304	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00307	8b c2		 mov	 eax, edx
  00309	89 4d f0	 mov	 DWORD PTR _iItemIndex$1$[ebp], ecx
  0030c	c1 e0 09	 shl	 eax, 9
  0030f	03 c1		 add	 eax, ecx
  00311	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$2[ebp]
  00317	50		 push	 eax
  00318	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _pCreateItem$2[ebp+36], xmm0
  00320	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert

; 3160 : 				lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0,0,-1, 3);
; 3161 : 
; 3162 : 			BYTE btItemPos = gObjInventoryInsertItem(lpMsg->aIndex, pCreateItem);

  00325	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0032b	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR _pCreateItem$2[ebp]
  00331	8b fc		 mov	 edi, esp
  00333	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00338	f3 a5		 rep movsd
  0033a	ff 73 14	 push	 DWORD PTR [ebx+20]
  0033d	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  00342	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 3163 : 
; 3164 : 			if ( btItemPos == (BYTE)-1 )

  00348	3c ff		 cmp	 al, 255			; 000000ffH
  0034a	0f 85 5b 01 00
	00		 jne	 $LN37@ItemSerial

; 3165 : 			{
; 3166 : #if( DEBUG_DROP == 1)
; 3167 : 				DROP_LOG_DEBUG.Output("[CashShop] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",

  00350	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00356	69 53 14 40 27
	00 00		 imul	 edx, DWORD PTR [ebx+20], 10048
  0035d	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00360	03 c2		 add	 eax, edx
  00362	50		 push	 eax
  00363	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00366	03 c2		 add	 eax, edx
  00368	50		 push	 eax
  00369	ff 75 f0	 push	 DWORD PTR _iItemIndex$1$[ebp]
  0036c	ff b5 fc fe ff
	ff		 push	 DWORD PTR _iItemType$1$[ebp]
  00372	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@KDEJKEEJ@?$FLCashShop?$FN?5Error?5?3?5Failed?5To?5Ins@
  00377	68 00 00 00 00	 push	 OFFSET ?DROP_LOG_DEBUG@@3VCLogToFile@@A ; DROP_LOG_DEBUG
  0037c	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00381	83 c4 18	 add	 esp, 24			; 00000018H

; 3302 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3303 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3304 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3305 : 			lpMsg->SetOption);
; 3306 : #else
; 3307 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3308 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3309 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3310 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3311 : 			lpMsg->SetOption);
; 3312 : #endif
; 3313 : 		
; 3314 : 	}
; 3315 : }

  00384	5f		 pop	 edi
  00385	5e		 pop	 esi
  00386	5b		 pop	 ebx
  00387	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0038a	33 cd		 xor	 ecx, ebp
  0038c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00391	8b e5		 mov	 esp, ebp
  00393	5d		 pop	 ebp
  00394	c3		 ret	 0
$LN29@ItemSerial:

; 3168 : 					iItemType, iItemIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);
; 3169 : #else
; 3170 : 				LogAddTD("[CashShop] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",
; 3171 : 					iItemType, iItemIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);
; 3172 : #endif
; 3173 : 			}
; 3174 : 			else
; 3175 : 			{
; 3176 : 				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);
; 3177 : 			}
; 3178 : 		}
; 3179 : 	}
; 3180 : #if( __QUEST_SYSTEM__ == 1)
; 3181 : 	else if ( lpMsg->MapNumber == 237 )

  00395	80 f9 ed	 cmp	 cl, 237			; 000000edH
  00398	0f 85 2d 01 00
	00		 jne	 $LN34@ItemSerial

; 3182 : 	{
; 3183 : 		if( gObj[lpMsg->aIndex].Connected > PLAYER_CONNECTED )

  0039e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a3	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  003a9	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  003ae	0f 8e 79 06 00
	00		 jle	 $LN35@ItemSerial

; 3184 : 		{
; 3185 : 			CItem pCreateItem;

  003b4	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$1[ebp]
  003ba	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3186 : 			int iItemType = ITEM_GET_TYPE(lpMsg->Type);

  003bf	0f bf 4b 0c	 movsx	 ecx, WORD PTR [ebx+12]
  003c3	8b c1		 mov	 eax, ecx
  003c5	99		 cdq
  003c6	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  003cc	03 d0		 add	 edx, eax
  003ce	c1 fa 09	 sar	 edx, 9
  003d1	89 95 fc fe ff
	ff		 mov	 DWORD PTR _iItemType$1$[ebp], edx

; 3187 : 			int iItemIndex	= ITEM_GET_INDEX(lpMsg->Type);

  003d7	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  003dd	79 08		 jns	 SHORT $LN73@ItemSerial
  003df	49		 dec	 ecx
  003e0	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  003e6	41		 inc	 ecx
$LN73@ItemSerial:

; 3188 : 
; 3189 : 			pCreateItem.m_Level = lpMsg->Level;

  003e7	0f b6 43 0e	 movzx	 eax, BYTE PTR [ebx+14]
  003eb	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _pCreateItem$1[ebp+8], ax

; 3190 : 			pCreateItem.m_Durability = lpMsg->Dur;

  003f2	0f b6 43 0f	 movzx	 eax, BYTE PTR [ebx+15]

; 3191 : 
; 3192 : 			pCreateItem.Convert(ITEMGET(iItemType, iItemIndex), lpMsg->Op1, lpMsg->Op2,

  003f6	6a 03		 push	 3
  003f8	68 ff 00 00 00	 push	 255			; 000000ffH
  003fd	6a 00		 push	 0
  003ff	66 0f 6e c0	 movd	 xmm0, eax
  00403	0f b6 43 1a	 movzx	 eax, BYTE PTR [ebx+26]
  00407	6a 00		 push	 0
  00409	50		 push	 eax
  0040a	0f b6 43 13	 movzx	 eax, BYTE PTR [ebx+19]
  0040e	50		 push	 eax
  0040f	0f b6 43 12	 movzx	 eax, BYTE PTR [ebx+18]
  00413	50		 push	 eax
  00414	0f b6 43 11	 movzx	 eax, BYTE PTR [ebx+17]
  00418	50		 push	 eax
  00419	0f b6 43 10	 movzx	 eax, BYTE PTR [ebx+16]
  0041d	50		 push	 eax
  0041e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00421	8b c2		 mov	 eax, edx
  00423	89 4d f0	 mov	 DWORD PTR _iItemIndex$1$[ebp], ecx
  00426	c1 e0 09	 shl	 eax, 9
  00429	03 c1		 add	 eax, ecx
  0042b	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _pCreateItem$1[ebp]
  00431	50		 push	 eax
  00432	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _pCreateItem$1[ebp+36], xmm0
  0043a	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert

; 3193 : 				lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption, 0,0,-1, 3);
; 3194 : 
; 3195 : 			BYTE btItemPos = gObjInventoryInsertItem(lpMsg->aIndex, pCreateItem);

  0043f	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00445	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR _pCreateItem$1[ebp]
  0044b	8b fc		 mov	 edi, esp
  0044d	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00452	f3 a5		 rep movsd
  00454	ff 73 14	 push	 DWORD PTR [ebx+20]
  00457	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  0045c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 3196 : 
; 3197 : 			if ( btItemPos == (BYTE)-1 )

  00462	3c ff		 cmp	 al, 255			; 000000ffH
  00464	75 45		 jne	 SHORT $LN37@ItemSerial

; 3198 : 			{
; 3199 : #if( DEBUG_DROP == 1)
; 3200 : 				DROP_LOG_DEBUG.Output("[QuestSystem] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",

  00466	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0046c	69 53 14 40 27
	00 00		 imul	 edx, DWORD PTR [ebx+20], 10048
  00473	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00476	03 c2		 add	 eax, edx
  00478	50		 push	 eax
  00479	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0047c	03 c2		 add	 eax, edx
  0047e	50		 push	 eax
  0047f	ff 75 f0	 push	 DWORD PTR _iItemIndex$1$[ebp]
  00482	ff b5 fc fe ff
	ff		 push	 DWORD PTR _iItemType$1$[ebp]
  00488	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@CJFPAOBM@?$FLQuestSystem?$FN?5Error?5?3?5Failed?5To?5@
  0048d	68 00 00 00 00	 push	 OFFSET ?DROP_LOG_DEBUG@@3VCLogToFile@@A ; DROP_LOG_DEBUG
  00492	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00497	83 c4 18	 add	 esp, 24			; 00000018H

; 3302 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3303 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3304 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3305 : 			lpMsg->SetOption);
; 3306 : #else
; 3307 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3308 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3309 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3310 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3311 : 			lpMsg->SetOption);
; 3312 : #endif
; 3313 : 		
; 3314 : 	}
; 3315 : }

  0049a	5f		 pop	 edi
  0049b	5e		 pop	 esi
  0049c	5b		 pop	 ebx
  0049d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a0	33 cd		 xor	 ecx, ebp
  004a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a7	8b e5		 mov	 esp, ebp
  004a9	5d		 pop	 ebp
  004aa	c3		 ret	 0
$LN37@ItemSerial:

; 3201 : 					iItemType, iItemIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);
; 3202 : #else
; 3203 : 				LogAddTD("[QuestSystem] Error : Failed To Insert Item Type:%d, TypeIndex:%d to [%s][%s]",
; 3204 : 					iItemType, iItemIndex, gObj[lpMsg->aIndex].AccountID, gObj[lpMsg->aIndex].Name);
; 3205 : #endif
; 3206 : 			}
; 3207 : 			else
; 3208 : 			{
; 3209 : 				GCInventoryItemOneSend(lpMsg->aIndex, btItemPos);

  004ab	0f b6 c0	 movzx	 eax, al
  004ae	50		 push	 eax
  004af	ff 73 14	 push	 DWORD PTR [ebx+20]
  004b2	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  004b7	83 c4 08	 add	 esp, 8

; 3302 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3303 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3304 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3305 : 			lpMsg->SetOption);
; 3306 : #else
; 3307 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3308 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3309 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3310 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3311 : 			lpMsg->SetOption);
; 3312 : #endif
; 3313 : 		
; 3314 : 	}
; 3315 : }

  004ba	5f		 pop	 edi
  004bb	5e		 pop	 esi
  004bc	5b		 pop	 ebx
  004bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004c0	33 cd		 xor	 ecx, ebp
  004c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c7	8b e5		 mov	 esp, ebp
  004c9	5d		 pop	 ebp
  004ca	c3		 ret	 0
$LN34@ItemSerial:

; 3210 : 			}
; 3211 : 		}
; 3212 : 	}
; 3213 : #endif
; 3214 : 	else
; 3215 : 	{
; 3216 : 		int iRetMapNumber = lpMsg->MapNumber;

  004cb	8b f7		 mov	 esi, edi
  004cd	89 b5 f8 fe ff
	ff		 mov	 DWORD PTR _iRetMapNumber$1$[ebp], esi

; 3217 : 
; 3218 : 		if ( lpMsg->MapNumber >= 238 && lpMsg->MapNumber <= 245 )

  004d3	80 f9 ee	 cmp	 cl, 238			; 000000eeH
  004d6	72 12		 jb	 SHORT $LN39@ItemSerial
  004d8	80 f9 f5	 cmp	 cl, 245			; 000000f5H
  004db	77 0d		 ja	 SHORT $LN39@ItemSerial

; 3219 : 		{
; 3220 : 			mapnumber = g_BloodCastle.GetItemMap(iRetMapNumber);

  004dd	56		 push	 esi
  004de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  004e3	e8 00 00 00 00	 call	 ?GetItemMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetItemMap
  004e8	8b f8		 mov	 edi, eax
$LN39@ItemSerial:

; 3221 : 		}
; 3222 : 
; 3223 : 		if ( lpMsg->MapNumber >= 246 && lpMsg->MapNumber <= 253 )

  004ea	8a 4b 05	 mov	 cl, BYTE PTR [ebx+5]
  004ed	80 f9 f6	 cmp	 cl, 246			; 000000f6H
  004f0	72 12		 jb	 SHORT $LN40@ItemSerial
  004f2	80 f9 fd	 cmp	 cl, 253			; 000000fdH
  004f5	77 0d		 ja	 SHORT $LN40@ItemSerial

; 3224 : 		{
; 3225 : 			mapnumber = g_BloodCastle.GetRewardMap(iRetMapNumber);

  004f7	56		 push	 esi
  004f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  004fd	e8 00 00 00 00	 call	 ?GetRewardMap@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetRewardMap
  00502	8b f8		 mov	 edi, eax
$LN40@ItemSerial:

; 3226 : 		}
; 3227 : 
; 3228 : 		int iItemCount = MapC[mapnumber].MonsterItemDrop(lpMsg->Type, lpMsg->Level, lpMsg->Dur, lpMsg->x,

  00504	ff b5 fc fe ff
	ff		 push	 DWORD PTR _SocketBonus$[ebp]
  0050a	8d 45 e4	 lea	 eax, DWORD PTR _SocketOption$[ebp]
  0050d	69 cf 28 38 05
	00		 imul	 ecx, edi, 342056
  00513	50		 push	 eax
  00514	0f b6 43 1a	 movzx	 eax, BYTE PTR [ebx+26]
  00518	6a 00		 push	 0
  0051a	ff 73 08	 push	 DWORD PTR [ebx+8]
  0051d	89 4d f8	 mov	 DWORD PTR tv1311[ebp], ecx
  00520	ff 75 f0	 push	 DWORD PTR _lootindex$1$[ebp]
  00523	50		 push	 eax
  00524	0f b6 43 13	 movzx	 eax, BYTE PTR [ebx+19]
  00528	50		 push	 eax
  00529	0f b6 43 12	 movzx	 eax, BYTE PTR [ebx+18]
  0052d	50		 push	 eax
  0052e	0f b6 43 11	 movzx	 eax, BYTE PTR [ebx+17]
  00532	50		 push	 eax
  00533	0f b6 43 10	 movzx	 eax, BYTE PTR [ebx+16]
  00537	50		 push	 eax
  00538	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  0053c	50		 push	 eax
  0053d	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  00541	50		 push	 eax
  00542	0f b6 43 0f	 movzx	 eax, BYTE PTR [ebx+15]
  00546	51		 push	 ecx
  00547	8d 89 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[ecx]
  0054d	66 0f 6e c0	 movd	 xmm0, eax
  00551	0f b6 43 0e	 movzx	 eax, BYTE PTR [ebx+14]
  00555	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00558	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0055d	50		 push	 eax
  0055e	0f bf 43 0c	 movsx	 eax, WORD PTR [ebx+12]
  00562	50		 push	 eax
  00563	e8 00 00 00 00	 call	 ?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKEPAEE@Z ; MapClass::MonsterItemDrop

; 3229 : 			lpMsg->y, lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, lpMsg->NewOption, lpMsg->SetOption,
; 3230 : 			lootindex, lpMsg->m_Number, 0,SocketOption,SocketBonus);
; 3231 : 
; 3232 : 		if ( iItemCount != -1 )

  00568	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp__GetTickCount@0
  0056e	89 85 fc fe ff
	ff		 mov	 DWORD PTR _iItemCount$1$[ebp], eax
  00574	83 f8 ff	 cmp	 eax, -1
  00577	0f 84 9a 00 00
	00		 je	 $LN43@ItemSerial

; 3233 : 		{
; 3234 : 			if ( iRetMapNumber >= 238 && iRetMapNumber <= 245)

  0057d	8d 8e 12 ff ff
	ff		 lea	 ecx, DWORD PTR [esi-238]
  00583	83 f9 07	 cmp	 ecx, 7
  00586	77 39		 ja	 SHORT $LN42@ItemSerial

; 3235 : 			{
; 3236 : 				MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + 300000;

  00588	69 f0 74 04 00
	00		 imul	 esi, eax, 1140
  0058e	ff d2		 call	 edx
  00590	8b 4d f8	 mov	 ecx, DWORD PTR tv1311[ebp]
  00593	05 e0 93 04 00	 add	 eax, 300000		; 000493e0H
  00598	89 84 0e 00 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[esi+ecx+256], eax

; 3237 : 				MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + 20000;

  0059f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetTickCount@0
  005a4	ff d0		 call	 eax
  005a6	8b 4d f8	 mov	 ecx, DWORD PTR tv1311[ebp]
  005a9	05 20 4e 00 00	 add	 eax, 20000		; 00004e20H
  005ae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp__GetTickCount@0
  005b4	89 84 0e 08 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[esi+ecx+264], eax
  005bb	8b b5 f8 fe ff
	ff		 mov	 esi, DWORD PTR _iRetMapNumber$1$[ebp]
$LN42@ItemSerial:

; 3238 : 			}
; 3239 : 
; 3240 : 			if ( iRetMapNumber >= 246 && iRetMapNumber <= 253)

  005c1	8d 86 0a ff ff
	ff		 lea	 eax, DWORD PTR [esi-246]
  005c7	83 f8 07	 cmp	 eax, 7
  005ca	77 4b		 ja	 SHORT $LN43@ItemSerial

; 3241 : 			{
; 3242 : 				MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + 900000;

  005cc	69 b5 fc fe ff
	ff 74 04 00 00	 imul	 esi, DWORD PTR _iItemCount$1$[ebp], 1140
  005d6	ff d2		 call	 edx
  005d8	8b 4d f8	 mov	 ecx, DWORD PTR tv1311[ebp]
  005db	05 a0 bb 0d 00	 add	 eax, 900000		; 000dbba0H
  005e0	89 84 0e 00 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[esi+ecx+256], eax

; 3243 : 				MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + 10000;

  005e7	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetTickCount@0
  005ec	ff d0		 call	 eax
  005ee	8b 4d f8	 mov	 ecx, DWORD PTR tv1311[ebp]
  005f1	05 10 27 00 00	 add	 eax, 10000		; 00002710H

; 3244 : 
; 3245 : 				int iBridgeIndex = g_BloodCastle.GetBridgeLevel(mapnumber);

  005f6	57		 push	 edi
  005f7	89 84 0e 08 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[esi+ecx+264], eax
  005fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00603	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel

; 3246 : 				g_BloodCastle.m_BridgeData[iBridgeIndex].m_nBC_QUESTITEM_SERIAL = lpMsg->m_Number;

  00608	69 c8 0c 02 00
	00		 imul	 ecx, eax, 524
  0060e	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00611	89 81 90 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+400], eax
$LN43@ItemSerial:

; 3247 : 			}
; 3248 : 		}
; 3249 : 
; 3250 : 		if ( IT_MAP_RANGE( mapnumber ) )

  00617	83 ff 2d	 cmp	 edi, 45			; 0000002dH
  0061a	0f 8c 8a 00 00
	00		 jl	 $LN46@ItemSerial
  00620	33 c0		 xor	 eax, eax
  00622	83 ff 32	 cmp	 edi, 50			; 00000032H
  00625	0f 9e c0	 setle	 al
  00628	85 c0		 test	 eax, eax
  0062a	74 7e		 je	 SHORT $LN46@ItemSerial

; 3251 : 		{
; 3252 : 			if( lpMsg->Type == ITEMGET(14,64) )

  0062c	b8 40 1c 00 00	 mov	 eax, 7232		; 00001c40H
  00631	66 39 43 0c	 cmp	 WORD PTR [ebx+12], ax
  00635	75 34		 jne	 SHORT $LN45@ItemSerial

; 3253 : 			{
; 3254 : 				MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + 15000;

  00637	69 b5 fc fe ff
	ff 74 04 00 00	 imul	 esi, DWORD PTR _iItemCount$1$[ebp], 1140
  00641	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00647	8b 4d f8	 mov	 ecx, DWORD PTR tv1311[ebp]
  0064a	05 98 3a 00 00	 add	 eax, 15000		; 00003a98H
  0064f	89 84 0e 00 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[esi+ecx+256], eax

; 3255 : 				MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + 5000;

  00656	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0065c	8b 4d f8	 mov	 ecx, DWORD PTR tv1311[ebp]
  0065f	05 88 13 00 00	 add	 eax, 5000		; 00001388H
  00664	89 84 0e 08 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[esi+ecx+264], eax
$LN45@ItemSerial:

; 3256 : 			}
; 3257 : 
; 3258 : 			if( lpMsg->Type == ITEMGET(12,15) )

  0066b	b8 0f 18 00 00	 mov	 eax, 6159		; 0000180fH
  00670	66 39 43 0c	 cmp	 WORD PTR [ebx+12], ax
  00674	75 34		 jne	 SHORT $LN46@ItemSerial

; 3259 : 			{
; 3260 : 				MapC[mapnumber].m_cItem[iItemCount].m_Time = GetTickCount() + 300000;

  00676	69 b5 fc fe ff
	ff 74 04 00 00	 imul	 esi, DWORD PTR _iItemCount$1$[ebp], 1140
  00680	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00686	8b 4d f8	 mov	 ecx, DWORD PTR tv1311[ebp]
  00689	05 e0 93 04 00	 add	 eax, 300000		; 000493e0H
  0068e	89 84 0e 00 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[esi+ecx+256], eax

; 3261 : 				MapC[mapnumber].m_cItem[iItemCount].m_LootTime = GetTickCount() + 10000;

  00695	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0069b	8b 4d f8	 mov	 ecx, DWORD PTR tv1311[ebp]
  0069e	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  006a3	89 84 0e 08 01
	00 00		 mov	 DWORD PTR ?MapC@@3PAVMapClass@@A[esi+ecx+264], eax
$LN46@ItemSerial:

; 3262 : 			}
; 3263 : 		}
; 3264 : 
; 3265 : 		//int iItemCount;
; 3266 : 		BYTE NewOption[MAX_EXOPTION_SIZE];
; 3267 : 
; 3268 : 		for ( int i=0;i<MAX_EXOPTION_SIZE;i++)

  006aa	33 c0		 xor	 eax, eax

; 3269 : 		{
; 3270 : 			NewOption[i] = FALSE;

  006ac	83 f8 08	 cmp	 eax, 8
$LN75@ItemSerial:
  006af	0f 83 89 03 00
	00		 jae	 $LN76@ItemSerial
  006b5	c6 44 05 f4 00	 mov	 BYTE PTR _NewOption$7[ebp+eax], 0
  006ba	40		 inc	 eax
  006bb	83 f8 08	 cmp	 eax, 8
  006be	7c ef		 jl	 SHORT $LN75@ItemSerial

; 3271 : 		}
; 3272 : 
; 3273 : 		if ( (lpMsg->NewOption & 0x20) != 0 )

  006c0	8a 43 13	 mov	 al, BYTE PTR [ebx+19]
  006c3	be 01 00 00 00	 mov	 esi, 1
  006c8	0f b6 4d f4	 movzx	 ecx, BYTE PTR _NewOption$7[ebp]
  006cc	a8 20		 test	 al, 32			; 00000020H

; 3274 : 		{
; 3275 : 			NewOption[0] = TRUE;
; 3276 : 		}
; 3277 : 		if ( (lpMsg->NewOption & 0x10) != 0 )
; 3278 : 		{
; 3279 : 			NewOption[1] = TRUE;
; 3280 : 		}
; 3281 : 
; 3282 : 		if ( (lpMsg->NewOption & 0x8) != 0 )
; 3283 : 		{
; 3284 : 			NewOption[2] = TRUE;
; 3285 : 		}
; 3286 : 		if ( (lpMsg->NewOption & 0x4) != 0 )

  006ce	0f b6 5d f7	 movzx	 ebx, BYTE PTR _NewOption$7[ebp+3]

; 3287 : 		{
; 3288 : 			NewOption[3] = TRUE;
; 3289 : 		}
; 3290 : 
; 3291 : 		if ( (lpMsg->NewOption & 0x2) != 0 )

  006d2	0f b6 55 f8	 movzx	 edx, BYTE PTR _NewOption$7[ebp+4]
  006d6	0f 45 ce	 cmovne	 ecx, esi
  006d9	a8 10		 test	 al, 16			; 00000010H
  006db	89 8d fc fe ff
	ff		 mov	 DWORD PTR tv1171[ebp], ecx
  006e1	0f b6 4d f5	 movzx	 ecx, BYTE PTR _NewOption$7[ebp+1]
  006e5	0f 45 ce	 cmovne	 ecx, esi
  006e8	a8 08		 test	 al, 8
  006ea	89 4d f0	 mov	 DWORD PTR tv1174[ebp], ecx
  006ed	0f b6 4d f6	 movzx	 ecx, BYTE PTR _NewOption$7[ebp+2]
  006f1	0f 45 ce	 cmovne	 ecx, esi
  006f4	a8 04		 test	 al, 4
  006f6	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv1177[ebp], ecx

; 3292 : 		{
; 3293 : 			NewOption[4] = TRUE;
; 3294 : 		}
; 3295 : 		if ( (lpMsg->NewOption & 0x1) != 0 )

  006fc	0f b6 4d f9	 movzx	 ecx, BYTE PTR _NewOption$7[ebp+5]
  00700	0f 45 de	 cmovne	 ebx, esi
  00703	a8 02		 test	 al, 2
  00705	0f 45 d6	 cmovne	 edx, esi
  00708	a8 01		 test	 al, 1
  0070a	0f 45 ce	 cmovne	 ecx, esi

; 3296 : 		{
; 3297 : 			NewOption[5] = TRUE;
; 3298 : 		}
; 3299 : 
; 3300 : #if (DEBUG_DROP==1)
; 3301 : 		DROP_LOG_DEBUG.Output("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",

  0070d	8b b5 f4 fe ff
	ff		 mov	 esi, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00713	0f b6 46 1a	 movzx	 eax, BYTE PTR [esi+26]
  00717	50		 push	 eax
  00718	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$7[ebp+6]
  0071c	50		 push	 eax
  0071d	0f b6 c1	 movzx	 eax, cl
  00720	50		 push	 eax
  00721	0f b6 c2	 movzx	 eax, dl
  00724	50		 push	 eax
  00725	0f b6 c3	 movzx	 eax, bl
  00728	50		 push	 eax
  00729	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv1177[ebp]
  0072f	0f b6 c0	 movzx	 eax, al
  00732	50		 push	 eax
  00733	8b 45 f0	 mov	 eax, DWORD PTR tv1174[ebp]
  00736	0f b6 c0	 movzx	 eax, al
  00739	50		 push	 eax
  0073a	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv1171[ebp]
  00740	0f b6 c0	 movzx	 eax, al
  00743	50		 push	 eax
  00744	0f b6 46 12	 movzx	 eax, BYTE PTR [esi+18]
  00748	50		 push	 eax
  00749	0f b6 46 11	 movzx	 eax, BYTE PTR [esi+17]
  0074d	50		 push	 eax
  0074e	0f b6 46 10	 movzx	 eax, BYTE PTR [esi+16]
  00752	50		 push	 eax
  00753	0f b6 46 0e	 movzx	 eax, BYTE PTR [esi+14]
  00757	50		 push	 eax
  00758	0f bf 46 0c	 movsx	 eax, WORD PTR [esi+12]
  0075c	6b c0 70	 imul	 eax, eax, 112
  0075f	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00764	50		 push	 eax
  00765	ff 76 08	 push	 DWORD PTR [esi+8]
  00768	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  0076c	50		 push	 eax
  0076d	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00771	50		 push	 eax
  00772	57		 push	 edi
  00773	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@LMECKDPM@Monster?5Item?5Drop?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL?$CFd?$FN?5?3@
  00778	68 00 00 00 00	 push	 OFFSET ?DROP_LOG_DEBUG@@3VCLogToFile@@A ; DROP_LOG_DEBUG
  0077d	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00782	83 c4 4c	 add	 esp, 76			; 0000004cH

; 3302 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3303 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3304 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3305 : 			lpMsg->SetOption);
; 3306 : #else
; 3307 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3308 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3309 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3310 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3311 : 			lpMsg->SetOption);
; 3312 : #endif
; 3313 : 		
; 3314 : 	}
; 3315 : }

  00785	5f		 pop	 edi
  00786	5e		 pop	 esi
  00787	5b		 pop	 ebx
  00788	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0078b	33 cd		 xor	 ecx, ebp
  0078d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00792	8b e5		 mov	 esp, ebp
  00794	5d		 pop	 ebp
  00795	c3		 ret	 0
$LN12@ItemSerial:

; 3023 : 	{
; 3024 : 		if ( gObjIsConnectedGP(aIndex) == FALSE )

  00796	56		 push	 esi
  00797	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0079c	83 c4 04	 add	 esp, 4
  0079f	85 c0		 test	 eax, eax
  007a1	75 2b		 jne	 SHORT $LN13@ItemSerial

; 3025 : 		{
; 3026 : 			LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  007a3	68 d2 0b 00 00	 push	 3026			; 00000bd2H
  007a8	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DNGOKBGI@DSProtocol?4cpp?$AA@
  007ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  007b2	6a 02		 push	 2
  007b4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  007ba	83 c4 10	 add	 esp, 16			; 00000010H

; 3302 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3303 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3304 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3305 : 			lpMsg->SetOption);
; 3306 : #else
; 3307 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3308 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3309 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3310 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3311 : 			lpMsg->SetOption);
; 3312 : #endif
; 3313 : 		
; 3314 : 	}
; 3315 : }

  007bd	5f		 pop	 edi
  007be	5e		 pop	 esi
  007bf	5b		 pop	 ebx
  007c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007c3	33 cd		 xor	 ecx, ebp
  007c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007ca	8b e5		 mov	 esp, ebp
  007cc	5d		 pop	 ebp
  007cd	c3		 ret	 0
$LN13@ItemSerial:

; 3027 : 			return;
; 3028 : 		}
; 3029 : 		
; 3030 : 
; 3031 : 		lpObj = &gObj[aIndex];

  007ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007d3	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  007d9	03 c1		 add	 eax, ecx
  007db	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv1306[ebp], ecx

; 3032 : 
; 3033 : 		if ( lpMsg->MapNumber == (BYTE)-2 )

  007e1	8a 4b 05	 mov	 cl, BYTE PTR [ebx+5]
  007e4	89 45 f8	 mov	 DWORD PTR _lpObj$1$[ebp], eax

; 3034 : 		{
; 3035 : 			if ( lpObj->m_IfState.type != 13 )

  007e7	8b 80 b8 11 00
	00		 mov	 eax, DWORD PTR [eax+4536]
  007ed	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  007f2	80 f9 fe	 cmp	 cl, 254			; 000000feH
  007f5	75 26		 jne	 SHORT $LN14@ItemSerial
  007f7	3d 40 03 00 00	 cmp	 eax, 832		; 00000340H
  007fc	74 45		 je	 SHORT $LN17@ItemSerial

; 3036 : 			{
; 3037 : 				LogAdd("error-L2: DarkTrainerBox not used.");

  007fe	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JBKACADO@error?9L2?3?5DarkTrainerBox?5not?5use@
  00803	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00809	83 c4 04	 add	 esp, 4

; 3302 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3303 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3304 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3305 : 			lpMsg->SetOption);
; 3306 : #else
; 3307 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3308 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3309 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3310 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3311 : 			lpMsg->SetOption);
; 3312 : #endif
; 3313 : 		
; 3314 : 	}
; 3315 : }

  0080c	5f		 pop	 edi
  0080d	5e		 pop	 esi
  0080e	5b		 pop	 ebx
  0080f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00812	33 cd		 xor	 ecx, ebp
  00814	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00819	8b e5		 mov	 esp, ebp
  0081b	5d		 pop	 ebp
  0081c	c3		 ret	 0
$LN14@ItemSerial:

; 3038 : 				return;
; 3039 : 			}
; 3040 : 		}
; 3041 : 		else if ( lpObj->m_IfState.type != 7 )

  0081d	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  00822	74 1f		 je	 SHORT $LN17@ItemSerial

; 3042 : 		{
; 3043 : 			LogAdd("error-L2: ChaosBox not used.");

  00824	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@BDLDNMBN@error?9L2?3?5ChaosBox?5not?5used?4?$AA@
  00829	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0082f	83 c4 04	 add	 esp, 4

; 3302 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3303 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3304 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3305 : 			lpMsg->SetOption);
; 3306 : #else
; 3307 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3308 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3309 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3310 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3311 : 			lpMsg->SetOption);
; 3312 : #endif
; 3313 : 		
; 3314 : 	}
; 3315 : }

  00832	5f		 pop	 edi
  00833	5e		 pop	 esi
  00834	5b		 pop	 ebx
  00835	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00838	33 cd		 xor	 ecx, ebp
  0083a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0083f	8b e5		 mov	 esp, ebp
  00841	5d		 pop	 ebp
  00842	c3		 ret	 0
$LN17@ItemSerial:

; 3044 : 			return;
; 3045 : 		}
; 3046 : 		
; 3047 : 		PMSG_CHAOSMIXRESULT pMsg;
; 3048 : 
; 3049 : 		pMsg.h.c = 0xC1;
; 3050 : 		pMsg.h.headcode = 0x86;
; 3051 : 		pMsg.h.size = sizeof(PMSG_CHAOSMIXRESULT);
; 3052 : 
; 3053 : 		if ( lpMsg->MapNumber == (BYTE)-2 )

  00843	80 f9 fe	 cmp	 cl, 254			; 000000feH
  00846	66 c7 45 d4 c1
	10		 mov	 WORD PTR _pMsg$5[ebp], 4289 ; 000010c1H
  0084c	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00851	c6 45 d6 86	 mov	 BYTE PTR _pMsg$5[ebp+2], 134 ; 00000086H
  00855	b8 01 00 00 00	 mov	 eax, 1

; 3054 : 		{
; 3055 : 			pMsg.Result = 100;
; 3056 : 		}
; 3057 : 		else
; 3058 : 		{
; 3059 : 			pMsg.Result = 1;
; 3060 : 		}
; 3061 : 
; 3062 : 		CItem NewItem;

  0085a	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$4[ebp]
  00860	0f 44 c2	 cmove	 eax, edx
  00863	88 45 d7	 mov	 BYTE PTR _pMsg$5[ebp+3], al
  00866	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 3063 : 
; 3064 : 		NewItem.m_Level = lpMsg->Level;

  0086b	0f b6 43 0e	 movzx	 eax, BYTE PTR [ebx+14]
  0086f	66 89 85 08 ff
	ff ff		 mov	 WORD PTR _NewItem$4[ebp+8], ax

; 3065 : 		NewItem.m_Durability = (float)ItemGetDurability(lpMsg->Type, lpMsg->Level, lpMsg->NewOption, lpMsg->SetOption);

  00876	0f b6 43 1a	 movzx	 eax, BYTE PTR [ebx+26]
  0087a	50		 push	 eax
  0087b	0f b6 43 13	 movzx	 eax, BYTE PTR [ebx+19]
  0087f	50		 push	 eax
  00880	0f b6 43 0e	 movzx	 eax, BYTE PTR [ebx+14]
  00884	50		 push	 eax
  00885	0f bf 43 0c	 movsx	 eax, WORD PTR [ebx+12]
  00889	50		 push	 eax
  0088a	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability

; 3066 : 
; 3067 : 		if ( lpMsg->Type == ITEMGET(14,7) ) // Siege Potion

  0088f	0f b7 4b 0c	 movzx	 ecx, WORD PTR [ebx+12]
  00893	83 c4 10	 add	 esp, 16			; 00000010H
  00896	66 0f 6e c0	 movd	 xmm0, eax
  0089a	b8 07 1c 00 00	 mov	 eax, 7175		; 00001c07H
  0089f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  008a2	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _NewItem$4[ebp+36], xmm0
  008aa	66 3b c8	 cmp	 cx, ax
  008ad	75 13		 jne	 SHORT $LN20@ItemSerial

; 3068 : 		{
; 3069 : 			NewItem.m_Durability = lpMsg->Dur;

  008af	0f b6 43 0f	 movzx	 eax, BYTE PTR [ebx+15]
  008b3	66 0f 6e c0	 movd	 xmm0, eax
  008b7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  008ba	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _NewItem$4[ebp+36], xmm0
$LN20@ItemSerial:

; 3070 : 		}
; 3071 : 
; 3072 : 		if ( lpMsg->Type == ITEMGET(13,37) )

  008c2	b8 25 1a 00 00	 mov	 eax, 6693		; 00001a25H
  008c7	66 3b c8	 cmp	 cx, ax
  008ca	75 13		 jne	 SHORT $LN21@ItemSerial

; 3073 : 		{
; 3074 : 			NewItem.m_Durability = lpMsg->Dur;

  008cc	0f b6 43 0f	 movzx	 eax, BYTE PTR [ebx+15]
  008d0	66 0f 6e c0	 movd	 xmm0, eax
  008d4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  008d7	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _NewItem$4[ebp+36], xmm0
$LN21@ItemSerial:

; 3075 : 		}
; 3076 : 
; 3077 : 		NewItem.Convert(lpMsg->Type,lpMsg->Op1, lpMsg->Op2, lpMsg->Op3,lpMsg->NewOption, lpMsg->SetOption,NewItem.m_ItemOptionEx,SocketOption,SocketBonus, CURRENT_DB_VERSION);

  008df	6a 03		 push	 3
  008e1	ff b5 fc fe ff
	ff		 push	 DWORD PTR _SocketBonus$[ebp]
  008e7	8d 45 e4	 lea	 eax, DWORD PTR _SocketOption$[ebp]
  008ea	50		 push	 eax
  008eb	ff 75 c6	 push	 DWORD PTR _NewItem$4[ebp+198]
  008ee	0f b6 43 1a	 movzx	 eax, BYTE PTR [ebx+26]
  008f2	50		 push	 eax
  008f3	0f b6 43 13	 movzx	 eax, BYTE PTR [ebx+19]
  008f7	50		 push	 eax
  008f8	0f b6 43 12	 movzx	 eax, BYTE PTR [ebx+18]
  008fc	50		 push	 eax
  008fd	0f b6 43 11	 movzx	 eax, BYTE PTR [ebx+17]
  00901	50		 push	 eax
  00902	0f b6 43 10	 movzx	 eax, BYTE PTR [ebx+16]
  00906	50		 push	 eax
  00907	0f bf c1	 movsx	 eax, cx
  0090a	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$4[ebp]
  00910	50		 push	 eax
  00911	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert

; 3078 : 		
; 3079 : 		ItemByteConvert(pMsg.ItemInfo, NewItem);

  00916	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0091c	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$5[ebp+4]
  0091f	8b fc		 mov	 edi, esp
  00921	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR _NewItem$4[ebp]
  00927	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0092c	f3 a5		 rep movsd
  0092e	50		 push	 eax
  0092f	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 3080 : 		NewItem.m_Number = lpMsg->m_Number;

  00934	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00937	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 3081 : 		g_ChaosBox.ChaosBoxInit(lpObj);

  0093d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00942	89 85 00 ff ff
	ff		 mov	 DWORD PTR _NewItem$4[ebp], eax
  00948	ff 75 f8	 push	 DWORD PTR _lpObj$1$[ebp]
  0094b	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 3082 : 		gObjChaosBoxInsertItemPos(aIndex, NewItem, 0, -1);

  00950	6a ff		 push	 -1
  00952	6a 00		 push	 0
  00954	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0095a	8d b5 00 ff ff
	ff		 lea	 esi, DWORD PTR _NewItem$4[ebp]
  00960	8b fc		 mov	 edi, esp
  00962	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00967	f3 a5		 rep movsd
  00969	8b b5 f8 fe ff
	ff		 mov	 esi, DWORD PTR _aIndex$1$[ebp]
  0096f	56		 push	 esi
  00970	e8 00 00 00 00	 call	 ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ; gObjChaosBoxInsertItemPos

; 3083 : 		gObjChaosItemSet(aIndex, 0, 1);

  00975	6a 01		 push	 1
  00977	6a 00		 push	 0
  00979	56		 push	 esi
  0097a	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet
  0097f	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH

; 3084 : 		BYTE ExOption[MAX_EXOPTION_SIZE];
; 3085 : 		ItemIsBufExOption(ExOption, &NewItem);

  00985	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _NewItem$4[ebp]
  0098b	50		 push	 eax
  0098c	8d 45 ec	 lea	 eax, DWORD PTR _ExOption$6[ebp]
  0098f	50		 push	 eax
  00990	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 3086 : 
; 3087 : #if( DEBUG_DROP == 1)
; 3088 : 		DROP_LOG_DEBUG.Output("[%s][%s] CBMix Item Create Item:%s [%d][%d] [%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",

  00995	0f b6 43 1a	 movzx	 eax, BYTE PTR [ebx+26]
  00999	83 c4 08	 add	 esp, 8
  0099c	50		 push	 eax
  0099d	0f b6 45 f2	 movzx	 eax, BYTE PTR _ExOption$6[ebp+6]
  009a1	50		 push	 eax
  009a2	0f b6 45 f1	 movzx	 eax, BYTE PTR _ExOption$6[ebp+5]
  009a6	50		 push	 eax
  009a7	0f b6 45 f0	 movzx	 eax, BYTE PTR _ExOption$6[ebp+4]
  009ab	50		 push	 eax
  009ac	0f b6 45 ef	 movzx	 eax, BYTE PTR _ExOption$6[ebp+3]
  009b0	50		 push	 eax
  009b1	0f b6 45 ee	 movzx	 eax, BYTE PTR _ExOption$6[ebp+2]
  009b5	50		 push	 eax
  009b6	0f b6 45 ed	 movzx	 eax, BYTE PTR _ExOption$6[ebp+1]
  009ba	50		 push	 eax
  009bb	0f b6 45 ec	 movzx	 eax, BYTE PTR _ExOption$6[ebp]
  009bf	50		 push	 eax
  009c0	0f b6 45 92	 movzx	 eax, BYTE PTR _NewItem$4[ebp+146]
  009c4	50		 push	 eax
  009c5	0f b6 45 91	 movzx	 eax, BYTE PTR _NewItem$4[ebp+145]
  009c9	50		 push	 eax
  009ca	0f b6 45 90	 movzx	 eax, BYTE PTR _NewItem$4[ebp+144]
  009ce	50		 push	 eax
  009cf	0f bf 85 08 ff
	ff ff		 movsx	 eax, WORD PTR _NewItem$4[ebp+8]
  009d6	50		 push	 eax
  009d7	0f b6 43 0f	 movzx	 eax, BYTE PTR [ebx+15]
  009db	50		 push	 eax
  009dc	ff 73 08	 push	 DWORD PTR [ebx+8]
  009df	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _NewItem$4[ebp]
  009e5	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  009ea	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$1$[ebp]
  009ed	50		 push	 eax
  009ee	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  009f1	50		 push	 eax
  009f2	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  009f5	50		 push	 eax
  009f6	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@EHKFCGJE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CBMix?5Item?5Create?5Item?3@
  009fb	68 00 00 00 00	 push	 OFFSET ?DROP_LOG_DEBUG@@3VCLogToFile@@A ; DROP_LOG_DEBUG
  00a00	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 3089 : 			lpObj->AccountID, lpObj->Name, NewItem.GetName(), lpMsg->m_Number, lpMsg->Dur, NewItem.m_Level, 
; 3090 : 			NewItem.m_Option1, NewItem.m_Option2, NewItem.m_Option3, ExOption[0], ExOption[1],
; 3091 : 			ExOption[2], ExOption[3], ExOption[4], ExOption[5], ExOption[6], lpMsg->SetOption);
; 3092 : #else
; 3093 : 		LogAddTD("[%s][%s] CBMix Item Create Item:%s [%d][%d] [%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3094 : 			lpObj->AccountID, lpObj->Name, NewItem.GetName(), lpMsg->m_Number, lpMsg->Dur, NewItem.m_Level, 
; 3095 : 			NewItem.m_Option1, NewItem.m_Option2, NewItem.m_Option3, ExOption[0], ExOption[1],
; 3096 : 			ExOption[2], ExOption[3], ExOption[4], ExOption[5], ExOption[6], lpMsg->SetOption);
; 3097 : #endif
; 3098 : 
; 3099 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00a05	0f b6 45 d5	 movzx	 eax, BYTE PTR _pMsg$5[ebp+1]
  00a09	50		 push	 eax
  00a0a	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$5[ebp]
  00a0d	50		 push	 eax
  00a0e	56		 push	 esi
  00a0f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3100 : 		gObj[aIndex].ChaosLock = FALSE;

  00a14	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a19	83 c4 58	 add	 esp, 88			; 00000058H
  00a1c	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv1306[ebp]
  00a22	c7 84 01 20 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+4640], 0
$LN35@ItemSerial:

; 3302 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3303 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3304 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3305 : 			lpMsg->SetOption);
; 3306 : #else
; 3307 : 		LogAddTD("Monster Item Drop [%d][%d][%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 3308 : 			mapnumber, lpMsg->x, lpMsg->y, lpMsg->m_Number, ItemAttribute[lpMsg->Type].Name, lpMsg->Level,
; 3309 : 			lpMsg->Op1, lpMsg->Op2, lpMsg->Op3, 
; 3310 : 			NewOption[0],NewOption[1],NewOption[2],NewOption[3],NewOption[4],NewOption[5],NewOption[6],
; 3311 : 			lpMsg->SetOption);
; 3312 : #endif
; 3313 : 		
; 3314 : 	}
; 3315 : }

  00a2d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a30	5f		 pop	 edi
  00a31	5e		 pop	 esi
  00a32	33 cd		 xor	 ecx, ebp
  00a34	5b		 pop	 ebx
  00a35	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a3a	8b e5		 mov	 esp, ebp
  00a3c	5d		 pop	 ebp
  00a3d	c3		 ret	 0
$LN76@ItemSerial:

; 3269 : 		{
; 3270 : 			NewOption[i] = FALSE;

  00a3e	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN77@ItemSerial:
$LN74@ItemSerial:
  00a43	cc		 int	 3
?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z ENDP ; ItemSerialCreateRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z
_TEXT	SEGMENT
_pMsg$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_type$ = 24						; size = 4
_level$ = 28						; size = 1
_dur$ = 32						; size = 1
_Op1$ = 36						; size = 1
_Op2$ = 40						; size = 1
_Op3$ = 44						; size = 1
_LootIndex$ = 48					; size = 4
_NewOption$ = 52					; size = 1
_SetOption$ = 56					; size = 1
?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z PROC	; PetItemSerialCreateSend, COMDAT

; 2950 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2951 : 	SDHP_ITEMCREATE  pMsg;
; 2952 : 
; 2953 : 	pMsg.h.c = 0xC1;
; 2954 : 	pMsg.h.headcode = 0x55;
; 2955 : 	pMsg.h.size = sizeof(pMsg);
; 2956 : 	pMsg.MapNumber = MapNumber;

  00010	8a 45 0c	 mov	 al, BYTE PTR _MapNumber$[ebp]
  00013	b1 20		 mov	 cl, 32			; 00000020H

; 2957 : 	pMsg.x = x;
; 2958 : 	pMsg.y = y;
; 2959 : 	pMsg.Type = type;

  00015	8b 55 18	 mov	 edx, DWORD PTR _type$[ebp]
  00018	88 45 e1	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0001b	8a 45 10	 mov	 al, BYTE PTR _x$[ebp]
  0001e	88 45 df	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00021	8a 45 14	 mov	 al, BYTE PTR _y$[ebp]
  00024	53		 push	 ebx

; 2960 : 	pMsg.Level = level;

  00025	8a 5d 1c	 mov	 bl, BYTE PTR _level$[ebp]

; 2961 : 
; 2962 : 	if (dur == 0 )

  00028	8a 7d 38	 mov	 bh, BYTE PTR _SetOption$[ebp]
  0002b	88 45 e0	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0002e	8a 45 20	 mov	 al, BYTE PTR _dur$[ebp]
  00031	66 c7 45 dc c1
	20		 mov	 WORD PTR _pMsg$[ebp], 8385 ; 000020c1H
  00037	c6 45 de 55	 mov	 BYTE PTR _pMsg$[ebp+2], 85 ; 00000055H
  0003b	66 89 55 e2	 mov	 WORD PTR _pMsg$[ebp+6], dx
  0003f	88 5d e4	 mov	 BYTE PTR _pMsg$[ebp+8], bl
  00042	84 c0		 test	 al, al
  00044	75 19		 jne	 SHORT $LN5@PetItemSer

; 2963 : 	{
; 2964 : 		dur = ItemGetDurability(type, level, NewOption, SetOption);

  00046	0f b6 c7	 movzx	 eax, bh
  00049	50		 push	 eax
  0004a	0f b6 45 34	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  0004e	50		 push	 eax
  0004f	0f b6 c3	 movzx	 eax, bl
  00052	50		 push	 eax
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  00059	8a 4d dd	 mov	 cl, BYTE PTR _pMsg$[ebp+1]
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@PetItemSer:

; 2965 : 	}
; 2966 : 
; 2967 : 	pMsg.Dur = dur;

  0005f	88 45 e5	 mov	 BYTE PTR _pMsg$[ebp+9], al

; 2968 : 	pMsg.Op1 = Op1;

  00062	8a 45 24	 mov	 al, BYTE PTR _Op1$[ebp]
  00065	88 45 e6	 mov	 BYTE PTR _pMsg$[ebp+10], al

; 2969 : 	pMsg.Op2 = Op2;

  00068	8a 45 28	 mov	 al, BYTE PTR _Op2$[ebp]
  0006b	88 45 e7	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 2970 : 	pMsg.Op3 = Op3;

  0006e	8a 45 2c	 mov	 al, BYTE PTR _Op3$[ebp]
  00071	88 45 e8	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 2971 : 	pMsg.NewOption = NewOption;

  00074	8a 45 34	 mov	 al, BYTE PTR _NewOption$[ebp]
  00077	88 45 e9	 mov	 BYTE PTR _pMsg$[ebp+13], al

; 2972 : 	pMsg.aIndex = aIndex;

  0007a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0007d	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 2973 : 	pMsg.lootindex = LootIndex;

  00080	66 8b 45 30	 mov	 ax, WORD PTR _LootIndex$[ebp]
  00084	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+20], ax

; 2974 : 	pMsg.SetOption = SetOption;
; 2975 : 
; 2976 : 	pMsg.SocketBonus = (BYTE)-1;
; 2977 : 
; 2978 : 	for(int i = 0; i < 5; i++)	{
; 2979 : 		pMsg.SocketOptions[i] = (BYTE)-1;
; 2980 : 	}
; 2981 : 
; 2982 : 	cDBSMng.Send( (char*)&pMsg, pMsg.h.size);

  00088	0f b6 c1	 movzx	 eax, cl
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00090	50		 push	 eax
  00091	8d 45 dc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00094	88 7d f2	 mov	 BYTE PTR _pMsg$[ebp+22], bh
  00097	50		 push	 eax
  00098	c6 45 f3 ff	 mov	 BYTE PTR _pMsg$[ebp+23], 255 ; 000000ffH
  0009c	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+24], -1
  000a3	c6 45 f8 ff	 mov	 BYTE PTR _pMsg$[ebp+28], -1
  000a7	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2983 : }

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000af	33 cd		 xor	 ecx, ebp
  000b1	5b		 pop	 ebx
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
?PetItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ENDP	; PetItemSerialCreateSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z
_TEXT	SEGMENT
tv513 = -64						; size = 4
tv516 = -60						; size = 4
tv519 = -56						; size = 4
_type$GSCopy$1$ = -52					; size = 4
tv525 = -52						; size = 4
_LootIndex$GSCopy$1$ = -48				; size = 4
tv522 = -48						; size = 4
_pMsg$ = -44						; size = 32
_NewOption$1 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_MapNumber$ = 12					; size = 1
_x$ = 16						; size = 1
_y$ = 20						; size = 1
_type$ = 24						; size = 4
_level$ = 28						; size = 1
_dur$ = 32						; size = 1
_Op1$ = 36						; size = 1
_Op2$ = 40						; size = 1
_Op3$ = 44						; size = 1
_LootIndex$ = 48					; size = 4
_NewOption$ = 52					; size = 1
_SetOption$ = 56					; size = 1
_SocketBonus$ = 60					; size = 1
_SocketOptions$ = 64					; size = 4
?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z PROC	; ItemSerialCreateSend, COMDAT

; 2830 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2831 : 	SDHP_ITEMCREATE  pMsg;
; 2832 : 
; 2833 : 	pMsg.h.c = 0xC1;
; 2834 : 	pMsg.h.headcode = 0x52;
; 2835 : 	pMsg.h.size = sizeof(pMsg);
; 2836 : 	pMsg.MapNumber = MapNumber;

  00010	8a 45 0c	 mov	 al, BYTE PTR _MapNumber$[ebp]
  00013	8b 55 30	 mov	 edx, DWORD PTR _LootIndex$[ebp]
  00016	88 45 d9	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 2837 : 	pMsg.x = x;

  00019	8a 45 10	 mov	 al, BYTE PTR _x$[ebp]
  0001c	53		 push	 ebx

; 2838 : 	pMsg.y = y;
; 2839 : 	pMsg.Type = type;
; 2840 : 	pMsg.Level = level;

  0001d	8a 7d 1c	 mov	 bh, BYTE PTR _level$[ebp]

; 2841 : 
; 2842 : 	if (dur == 0 )

  00020	8a 5d 34	 mov	 bl, BYTE PTR _NewOption$[ebp]
  00023	88 45 d7	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00026	8a 45 14	 mov	 al, BYTE PTR _y$[ebp]
  00029	56		 push	 esi
  0002a	8b 75 18	 mov	 esi, DWORD PTR _type$[ebp]
  0002d	88 45 d8	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00030	8a 45 20	 mov	 al, BYTE PTR _dur$[ebp]
  00033	89 75 cc	 mov	 DWORD PTR _type$GSCopy$1$[ebp], esi
  00036	89 55 d0	 mov	 DWORD PTR _LootIndex$GSCopy$1$[ebp], edx
  00039	66 c7 45 d4 c1
	20		 mov	 WORD PTR _pMsg$[ebp], 8385 ; 000020c1H
  0003f	c6 45 d6 52	 mov	 BYTE PTR _pMsg$[ebp+2], 82 ; 00000052H
  00043	66 89 75 da	 mov	 WORD PTR _pMsg$[ebp+6], si
  00047	88 7d dc	 mov	 BYTE PTR _pMsg$[ebp+8], bh
  0004a	57		 push	 edi
  0004b	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0004e	84 c0		 test	 al, al
  00050	75 19		 jne	 SHORT $LN14@ItemSerial

; 2843 : 	{
; 2844 : 		dur = ItemGetDurability(type, level, NewOption, SetOption);

  00052	0f b6 45 38	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  00056	50		 push	 eax
  00057	0f b6 c3	 movzx	 eax, bl
  0005a	50		 push	 eax
  0005b	0f b6 c7	 movzx	 eax, bh
  0005e	50		 push	 eax
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  00065	8b 55 d0	 mov	 edx, DWORD PTR _LootIndex$GSCopy$1$[ebp]
  00068	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@ItemSerial:

; 2845 : 	}
; 2846 : 
; 2847 : 	pMsg.Dur = dur;
; 2848 : 	pMsg.Op1 = Op1;
; 2849 : 	pMsg.Op2 = Op2;
; 2850 : 	pMsg.Op3 = Op3;
; 2851 : 	pMsg.NewOption = NewOption;
; 2852 : 	pMsg.aIndex = aIndex;
; 2853 : 	pMsg.lootindex = LootIndex;
; 2854 : 	pMsg.SetOption = SetOption;
; 2855 : 
; 2856 : 	if( SocketOptions != NULL )

  0006b	8b 4d 40	 mov	 ecx, DWORD PTR _SocketOptions$[ebp]
  0006e	88 45 dd	 mov	 BYTE PTR _pMsg$[ebp+9], al
  00071	8a 45 24	 mov	 al, BYTE PTR _Op1$[ebp]
  00074	88 45 de	 mov	 BYTE PTR _pMsg$[ebp+10], al
  00077	8a 45 28	 mov	 al, BYTE PTR _Op2$[ebp]
  0007a	88 45 df	 mov	 BYTE PTR _pMsg$[ebp+11], al
  0007d	8a 45 2c	 mov	 al, BYTE PTR _Op3$[ebp]
  00080	88 45 e0	 mov	 BYTE PTR _pMsg$[ebp+12], al
  00083	8a 45 38	 mov	 al, BYTE PTR _SetOption$[ebp]
  00086	88 5d e1	 mov	 BYTE PTR _pMsg$[ebp+13], bl
  00089	89 7d e4	 mov	 DWORD PTR _pMsg$[ebp+16], edi
  0008c	66 89 55 e8	 mov	 WORD PTR _pMsg$[ebp+20], dx
  00090	88 45 ea	 mov	 BYTE PTR _pMsg$[ebp+22], al
  00093	85 c9		 test	 ecx, ecx
  00095	74 16		 je	 SHORT $LN15@ItemSerial

; 2857 : 	{
; 2858 : 		pMsg.SocketBonus = SocketBonus;

  00097	8a 45 3c	 mov	 al, BYTE PTR _SocketBonus$[ebp]
  0009a	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+23], al

; 2859 : 
; 2860 : 		for(int i = 0; i < 5; i++)
; 2861 : 		{
; 2862 : 			pMsg.SocketOptions[i] = SocketOptions[i];

  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  000a2	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  000a5	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+28], al

; 2863 : 		}
; 2864 : 	}
; 2865 : 	else if( g_SocketItem.IsSocketItem(type) )

  000a8	e9 8b 00 00 00	 jmp	 $LN10@ItemSerial
$LN15@ItemSerial:
  000ad	56		 push	 esi
  000ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketItem@@3VCSocketItems@@A ; g_SocketItem
  000b3	e8 00 00 00 00	 call	 ?IsSocketItem@CSocketItems@@QAE_NH@Z ; CSocketItems::IsSocketItem
  000b8	84 c0		 test	 al, al
  000ba	74 67		 je	 SHORT $LN17@ItemSerial

; 2866 : 	{
; 2867 : 		int SocketCount = g_SocketItem.GetSocketCount(type);

  000bc	56		 push	 esi
  000bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketItem@@3VCSocketItems@@A ; g_SocketItem
  000c2	e8 00 00 00 00	 call	 ?GetSocketCount@CSocketItems@@QAEEH@Z ; CSocketItems::GetSocketCount

; 2868 : 		pMsg.SocketBonus = (BYTE)-1;
; 2869 : 
; 2870 : 		LogAddTD("[SocketItem] Generate Socket Item ( Socket Slot : %d ) - %s, [%d,%d,%d,%d], Serial : %u, ItemCode : %d, MapNumber : %d(%d/%d)",

  000c7	8b 4d cc	 mov	 ecx, DWORD PTR _type$GSCopy$1$[ebp]
  000ca	0f b6 f0	 movzx	 esi, al
  000cd	0f b6 45 14	 movzx	 eax, BYTE PTR _y$[ebp]
  000d1	50		 push	 eax
  000d2	0f b6 45 10	 movzx	 eax, BYTE PTR _x$[ebp]
  000d6	50		 push	 eax
  000d7	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  000db	50		 push	 eax
  000dc	0f b6 45 2c	 movzx	 eax, BYTE PTR _Op3$[ebp]
  000e0	51		 push	 ecx
  000e1	50		 push	 eax
  000e2	0f b6 45 28	 movzx	 eax, BYTE PTR _Op2$[ebp]
  000e6	50		 push	 eax
  000e7	0f b6 45 24	 movzx	 eax, BYTE PTR _Op1$[ebp]
  000eb	50		 push	 eax
  000ec	0f b6 c7	 movzx	 eax, bh
  000ef	50		 push	 eax
  000f0	6b c1 70	 imul	 eax, ecx, 112
  000f3	c6 45 eb ff	 mov	 BYTE PTR _pMsg$[ebp+23], 255 ; 000000ffH
  000f7	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  000fc	50		 push	 eax
  000fd	56		 push	 esi
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_0HO@BMIFLCBN@?$FLSocketItem?$FN?5Generate?5Socket?5Ite@
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00109	83 c4 2c	 add	 esp, 44			; 0000002cH

; 2871 : 			SocketCount,ItemAttribute[type].Name,level,Op1,Op2,Op3,type,MapNumber,x,y);
; 2872 : 
; 2873 : 		for(int i = 0;i < MAX_SOCKET_COUNT;i++)

  0010c	33 c9		 xor	 ecx, ecx
  0010e	66 90		 npad	 2
$LL7@ItemSerial:

; 2874 : 		{
; 2875 : 			if( i < SocketCount )

  00110	3b ce		 cmp	 ecx, esi
  00112	0f 9d c0	 setge	 al
  00115	04 fe		 add	 al, 254			; 000000feH
  00117	88 44 0d ec	 mov	 BYTE PTR _pMsg$[ebp+ecx+24], al
  0011b	41		 inc	 ecx
  0011c	83 f9 05	 cmp	 ecx, 5
  0011f	7c ef		 jl	 SHORT $LL7@ItemSerial

; 2876 : 			{
; 2877 : 				pMsg.SocketOptions[i] = (BYTE)-2;
; 2878 : 			}
; 2879 : 			else
; 2880 : 			{
; 2881 : 				pMsg.SocketOptions[i] = (BYTE)-1;
; 2882 : 			}
; 2883 : 		}
; 2884 : 	}
; 2885 : 	else

  00121	eb 0f		 jmp	 SHORT $LN54@ItemSerial
$LN17@ItemSerial:

; 2886 : 	{
; 2887 : 		pMsg.SocketBonus = (BYTE)-1;

  00123	c6 45 eb ff	 mov	 BYTE PTR _pMsg$[ebp+23], 255 ; 000000ffH

; 2888 : 		for(int i = 0; i < 5; i++)	{
; 2889 : 			pMsg.SocketOptions[i] = (BYTE)-1;

  00127	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _pMsg$[ebp+24], -1
  0012e	c6 45 f0 ff	 mov	 BYTE PTR _pMsg$[ebp+28], -1
$LN54@ItemSerial:
  00132	8b 55 d0	 mov	 edx, DWORD PTR _LootIndex$GSCopy$1$[ebp]
  00135	8a 5d e1	 mov	 bl, BYTE PTR _pMsg$[ebp+13]
$LN10@ItemSerial:

; 2890 : 		}
; 2891 : 	}
; 2892 : 
; 2893 : 	if ( OBJMAX_RANGE(aIndex) != FALSE  && gObj[aIndex].Type != OBJ_USER )

  00138	85 ff		 test	 edi, edi
  0013a	0f 88 2f 01 00
	00		 js	 $LN21@ItemSerial
  00140	33 c0		 xor	 eax, eax
  00142	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00148	0f 9e c0	 setle	 al
  0014b	85 c0		 test	 eax, eax
  0014d	0f 84 1c 01 00
	00		 je	 $LN21@ItemSerial
  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00159	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0015f	80 7c 0e 50 01	 cmp	 BYTE PTR [esi+ecx+80], 1
  00164	0f 84 05 01 00
	00		 je	 $LN21@ItemSerial

; 2894 : 	{
; 2895 : 		BYTE NewOption[MAX_EXOPTION_SIZE];
; 2896 : 
; 2897 : 		for ( int i=0;i<MAX_EXOPTION_SIZE;i++)

  0016a	33 c0		 xor	 eax, eax

; 2898 : 		{
; 2899 : 			NewOption[i] = 0;

  0016c	83 f8 08	 cmp	 eax, 8
$LN55@ItemSerial:
  0016f	0f 83 1e 01 00
	00		 jae	 $LN56@ItemSerial
  00175	c6 44 05 f4 00	 mov	 BYTE PTR _NewOption$1[ebp+eax], 0
  0017a	40		 inc	 eax
  0017b	83 f8 08	 cmp	 eax, 8
  0017e	7c ef		 jl	 SHORT $LN55@ItemSerial

; 2900 : 		}
; 2901 : 
; 2902 : 		if ( (pMsg.NewOption & 0x20) != 0 )

  00180	0f b6 45 f4	 movzx	 eax, BYTE PTR _NewOption$1[ebp]
  00184	f6 c3 20	 test	 bl, 32			; 00000020H
  00187	bf 01 00 00 00	 mov	 edi, 1
  0018c	0f 45 c7	 cmovne	 eax, edi

; 2903 : 		{
; 2904 : 			NewOption[0] = TRUE;
; 2905 : 		}
; 2906 : 		if ( (pMsg.NewOption & 0x10) != 0 )

  0018f	f6 c3 10	 test	 bl, 16			; 00000010H
  00192	89 45 c0	 mov	 DWORD PTR tv513[ebp], eax
  00195	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$1[ebp+1]
  00199	0f 45 c7	 cmovne	 eax, edi

; 2907 : 		{
; 2908 : 			NewOption[1] = TRUE;
; 2909 : 		}
; 2910 : 
; 2911 : 		if ( (pMsg.NewOption & 0x8) != 0 )

  0019c	f6 c3 08	 test	 bl, 8
  0019f	89 45 c4	 mov	 DWORD PTR tv516[ebp], eax
  001a2	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$1[ebp+2]
  001a6	0f 45 c7	 cmovne	 eax, edi

; 2912 : 		{
; 2913 : 			NewOption[2] = TRUE;
; 2914 : 		}
; 2915 : 		if ( (pMsg.NewOption & 0x4) != 0 )

  001a9	f6 c3 04	 test	 bl, 4
  001ac	89 45 c8	 mov	 DWORD PTR tv519[ebp], eax
  001af	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$1[ebp+3]
  001b3	0f 45 c7	 cmovne	 eax, edi

; 2916 : 		{
; 2917 : 			NewOption[3] = TRUE;
; 2918 : 		}
; 2919 : 
; 2920 : 		if ( (pMsg.NewOption & 0x2) != 0 )

  001b6	f6 c3 02	 test	 bl, 2
  001b9	89 45 d0	 mov	 DWORD PTR tv522[ebp], eax
  001bc	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$1[ebp+4]
  001c0	0f 45 c7	 cmovne	 eax, edi

; 2921 : 		{
; 2922 : 			NewOption[4] = TRUE;
; 2923 : 		}
; 2924 : 		if ( (pMsg.NewOption & 0x1) != 0 )

  001c3	f6 c3 01	 test	 bl, 1
  001c6	0f b6 5d f9	 movzx	 ebx, BYTE PTR _NewOption$1[ebp+5]
  001ca	0f 45 df	 cmovne	 ebx, edi
  001cd	89 45 cc	 mov	 DWORD PTR tv525[ebp], eax

; 2925 : 		{
; 2926 : 			NewOption[5] = TRUE;
; 2927 : 		}
; 2928 : 
; 2929 : #if( DEBUG_DROP == 1)
; 2930 : 		DROP_LOG_DEBUG.Output("Monster Item Drop Request [%s] [%d][%d][%d] : [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d] | LootUser: [%s]",

  001d0	85 d2		 test	 edx, edx
  001d2	78 1c		 js	 SHORT $LN35@ItemSerial
  001d4	33 c0		 xor	 eax, eax
  001d6	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  001dc	0f 9e c0	 setle	 al
  001df	85 c0		 test	 eax, eax
  001e1	74 0d		 je	 SHORT $LN35@ItemSerial
  001e3	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  001e9	83 c0 5d	 add	 eax, 93			; 0000005dH
  001ec	03 c1		 add	 eax, ecx
  001ee	eb 05		 jmp	 SHORT $LN36@ItemSerial
$LN35@ItemSerial:
  001f0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04CGFJFPFD@none?$AA@
$LN36@ItemSerial:
  001f5	50		 push	 eax
  001f6	0f b6 45 ea	 movzx	 eax, BYTE PTR _pMsg$[ebp+22]
  001fa	50		 push	 eax
  001fb	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$1[ebp+6]
  001ff	50		 push	 eax
  00200	0f b6 c3	 movzx	 eax, bl
  00203	50		 push	 eax
  00204	8b 45 cc	 mov	 eax, DWORD PTR tv525[ebp]
  00207	0f b6 c0	 movzx	 eax, al
  0020a	50		 push	 eax
  0020b	8b 45 d0	 mov	 eax, DWORD PTR tv522[ebp]
  0020e	0f b6 c0	 movzx	 eax, al
  00211	50		 push	 eax
  00212	8b 45 c8	 mov	 eax, DWORD PTR tv519[ebp]
  00215	0f b6 c0	 movzx	 eax, al
  00218	50		 push	 eax
  00219	8b 45 c4	 mov	 eax, DWORD PTR tv516[ebp]
  0021c	0f b6 c0	 movzx	 eax, al
  0021f	50		 push	 eax
  00220	8b 45 c0	 mov	 eax, DWORD PTR tv513[ebp]
  00223	0f b6 c0	 movzx	 eax, al
  00226	50		 push	 eax
  00227	0f b6 45 e0	 movzx	 eax, BYTE PTR _pMsg$[ebp+12]
  0022b	50		 push	 eax
  0022c	0f b6 45 df	 movzx	 eax, BYTE PTR _pMsg$[ebp+11]
  00230	50		 push	 eax
  00231	0f b6 45 de	 movzx	 eax, BYTE PTR _pMsg$[ebp+10]
  00235	50		 push	 eax
  00236	0f b6 45 dc	 movzx	 eax, BYTE PTR _pMsg$[ebp+8]
  0023a	50		 push	 eax
  0023b	0f bf 45 da	 movsx	 eax, WORD PTR _pMsg$[ebp+6]
  0023f	6b c0 70	 imul	 eax, eax, 112
  00242	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00247	50		 push	 eax
  00248	0f b6 45 d8	 movzx	 eax, BYTE PTR _pMsg$[ebp+4]
  0024c	50		 push	 eax
  0024d	0f b6 45 d7	 movzx	 eax, BYTE PTR _pMsg$[ebp+3]
  00251	50		 push	 eax
  00252	0f b6 45 0c	 movzx	 eax, BYTE PTR _MapNumber$[ebp]
  00256	50		 push	 eax
  00257	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0025a	03 c6		 add	 eax, esi
  0025c	50		 push	 eax
  0025d	68 00 00 00 00	 push	 OFFSET ??_C@_0HH@HKJJNFBM@Monster?5Item?5Drop?5Request?5?$FL?$CFs?$FN?5?$FL@
  00262	68 00 00 00 00	 push	 OFFSET ?DROP_LOG_DEBUG@@3VCLogToFile@@A ; DROP_LOG_DEBUG
  00267	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0026c	83 c4 50	 add	 esp, 80			; 00000050H
$LN21@ItemSerial:

; 2931 : 			gObj[aIndex].Name, MapNumber, pMsg.x, pMsg.y, ItemAttribute[pMsg.Type].Name,
; 2932 : 			pMsg.Level, pMsg.Op1,pMsg.Op2, pMsg.Op3, NewOption[0], NewOption[1], NewOption[2],
; 2933 : 			NewOption[3], NewOption[4],	NewOption[5], NewOption[6], pMsg.SetOption, (OBJMAX_RANGE(LootIndex)) ? gObj[LootIndex].Name : "none");
; 2934 : #else
; 2935 : 		LogAddTD("Monster Item Drop Request [%s] [%d][%d][%d] : [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]",
; 2936 : 			gObj[aIndex].Name, MapNumber, pMsg.x, pMsg.y, ItemAttribute[pMsg.Type].Name,
; 2937 : 			pMsg.Level, pMsg.Op1,pMsg.Op2, pMsg.Op3, NewOption[0], NewOption[1], NewOption[2],
; 2938 : 			NewOption[3], NewOption[4],	NewOption[5], NewOption[6], pMsg.SetOption);
; 2939 : #endif
; 2940 : 	}
; 2941 : 
; 2942 : 	cDBSMng.Send( (char*)&pMsg, pMsg.h.size);

  0026f	0f b6 45 d5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00273	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00278	50		 push	 eax
  00279	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2943 : }

  00282	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00285	5f		 pop	 edi
  00286	5e		 pop	 esi
  00287	33 cd		 xor	 ecx, ebp
  00289	5b		 pop	 ebx
  0028a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028f	8b e5		 mov	 esp, ebp
  00291	5d		 pop	 ebp
  00292	c3		 ret	 0
$LN56@ItemSerial:

; 2898 : 		{
; 2899 : 			NewOption[i] = 0;

  00293	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN57@ItemSerial:
$LN53@ItemSerial:
  00298	cc		 int	 3
?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ENDP	; ItemSerialCreateSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDGameServerInfoSave@@YAXXZ
_TEXT	SEGMENT
?GDGameServerInfoSave@@YAXXZ PROC			; GDGameServerInfoSave, COMDAT

; 2792 : 	return;		// GHere goes a MACRO
; 2793 : }

  00000	c3		 ret	 0
?GDGameServerInfoSave@@YAXXZ ENDP			; GDGameServerInfoSave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDSetWarehouseMoney@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDSetWarehouseMoney@@YAXH@Z PROC			; GDSetWarehouseMoney, COMDAT

; 2777 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]

; 2778 : 	SDHP_WAREHOUSEMONEY_SAVE pMsg;
; 2779 : 
; 2780 : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, sizeof(pMsg.AccountID));

  00013	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048

; 2781 : 	pMsg.aIndex = aIndex;
; 2782 : 	pMsg.h.c = 0xC1;
; 2783 : 	pMsg.h.headcode = 0x12;
; 2784 : 	pMsg.h.size = sizeof(pMsg);
; 2785 : 	pMsg.Money = gObj[aIndex].WarehouseMoney;
; 2786 : 
; 2787 : 	cDBSMng.Send((PCHAR)&pMsg, sizeof(pMsg));

  00019	6a 14		 push	 20			; 00000014H
  0001b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00021	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  00026	66 0f d6 45 eb	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  0002b	66 8b 41 5a	 mov	 ax, WORD PTR [ecx+90]
  0002f	66 89 45 f3	 mov	 WORD PTR _pMsg$[ebp+11], ax
  00033	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+14], dx
  00037	66 c7 45 e8 c1
	14		 mov	 WORD PTR _pMsg$[ebp], 5313 ; 000014c1H
  0003d	c6 45 ea 12	 mov	 BYTE PTR _pMsg$[ebp+2], 18 ; 00000012H
  00041	8b 81 08 12 00
	00		 mov	 eax, DWORD PTR [ecx+4616]
  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0004c	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  0004f	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2788 : }

  00058	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005b	33 cd		 xor	 ecx, ebp
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?GDSetWarehouseMoney@@YAXH@Z ENDP			; GDSetWarehouseMoney
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -3812						; size = 3806
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z PROC		; GDUserItemSave, COMDAT

; 2745 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 0e 00
	00		 sub	 esp, 3812		; 00000ee4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]

; 2746 : 	SDHP_DBCHAR_ITEMSAVE pMsg;
; 2747 : 
; 2748 : 	pMsg.h.c = 0xC2;
; 2749 : 	pMsg.h.headcode = 0x11;
; 2750 : 	pMsg.h.sizeH = HIBYTE(sizeof(pMsg));
; 2751 : 	pMsg.h.sizeL = LOBYTE(sizeof(pMsg));
; 2752 : 	memcpy(pMsg.Name, lpObj->Name, sizeof(pMsg.Name));
; 2753 : 	ItemByteConvert16(pMsg.dbInventory, lpObj->pInventory, INVENTORY_SIZE);

  00016	68 ed 00 00 00	 push	 237			; 000000edH
  0001b	c7 85 1c f1 ff
	ff c2 0e de 11	 mov	 DWORD PTR _pMsg$[ebp], 299765442 ; 11de0ec2H
  00025	66 8b 41 65	 mov	 ax, WORD PTR [ecx+101]
  00029	ff b1 c0 11 00
	00		 push	 DWORD PTR [ecx+4544]
  0002f	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  00034	66 89 85 28 f1
	ff ff		 mov	 WORD PTR _pMsg$[ebp+12], ax
  0003b	8d 85 2a f1 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+14]
  00041	50		 push	 eax
  00042	66 0f d6 85 20
	f1 ff ff	 movq	 QWORD PTR _pMsg$[ebp+4], xmm0
  0004a	e8 00 00 00 00	 call	 ?ItemByteConvert16@@YAXPAEQAVCItem@@H@Z ; ItemByteConvert16
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2754 : 
; 2755 : 	cDBSMng.Send((PCHAR)&pMsg, sizeof(pMsg));

  00052	8d 85 1c f1 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0005d	68 de 0e 00 00	 push	 3806			; 00000edeH
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2756 : }

  00068	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006b	33 cd		 xor	 ecx, ebp
  0006d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; GDUserItemSave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDSetWarehouseList@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -3868						; size = 3864
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GDSetWarehouseList@@YAXH@Z PROC			; GDSetWarehouseList, COMDAT

; 2703 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 0f 00
	00		 sub	 esp, 3868		; 00000f1cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2704 : 	SDHP_GETWAREHOUSEDB_SAVE pMsg;
; 2705 : 	
; 2706 : 	if ( gObj[aIndex].LoadWareHouseInfo == false )

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001d	57		 push	 edi
  0001e	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00024	03 cf		 add	 ecx, edi
  00026	80 b9 ec 13 00
	00 00		 cmp	 BYTE PTR [ecx+5100], 0
  0002d	75 26		 jne	 SHORT $LN2@GDSetWareh

; 2707 : 	{
; 2708 : 		LogAddTD("[%s][%s] WareHouse Save Fail : Not Open",

  0002f	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00032	50		 push	 eax
  00033	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@MIGOHDHJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5WareHouse?5Save?5Fail?5?3?5N@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2726 : 	gObjWarehouseTextSave(&gObj[aIndex]);

  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 2727 : }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN2@GDSetWareh:

; 2709 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);
; 2710 : 
; 2711 : 		return;
; 2712 : 	}
; 2713 : 
; 2714 : 	memcpy(pMsg.AccountID, gObj[aIndex].AccountID, sizeof(pMsg.AccountID));

  00055	f3 0f 7e 41 52	 movq	 xmm0, QWORD PTR [ecx+82]
  0005a	66 0f d6 85 e8
	f0 ff ff	 movq	 QWORD PTR _pMsg$[ebp+4], xmm0
  00062	0f b7 41 5a	 movzx	 eax, WORD PTR [ecx+90]
  00066	66 89 85 f0 f0
	ff ff		 mov	 WORD PTR _pMsg$[ebp+12], ax

; 2715 : 	pMsg.aIndex = aIndex;

  0006d	66 89 b5 f2 f0
	ff ff		 mov	 WORD PTR _pMsg$[ebp+14], si

; 2716 : 	pMsg.h.c = 0xC2;

  00074	c7 85 e4 f0 ff
	ff c2 0f 18 09	 mov	 DWORD PTR _pMsg$[ebp], 152571842 ; 09180fc2H

; 2717 : 	pMsg.h.headcode = 0x09;
; 2718 : 	pMsg.h.sizeH = HIBYTE(sizeof(pMsg));
; 2719 : 	pMsg.h.sizeL = LOBYTE(sizeof(pMsg));
; 2720 : 	pMsg.Money = gObj[aIndex].WarehouseMoney;

  0007e	8b 81 08 12 00
	00		 mov	 eax, DWORD PTR [ecx+4616]
  00084	89 85 f4 f0 ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 2721 : 	pMsg.pw = gObj[aIndex].WarehousePW;

  0008a	0f b7 81 02 12
	00 00		 movzx	 eax, WORD PTR [ecx+4610]
  00091	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+3862], ax

; 2722 : 	ItemByteConvert16(pMsg.dbItems, gObj[aIndex].pWarehouse, WAREHOUSE_SIZE);

  00095	8d 85 f8 f0 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+20]
  0009b	68 f0 00 00 00	 push	 240			; 000000f0H
  000a0	ff b1 f8 11 00
	00		 push	 DWORD PTR [ecx+4600]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ?ItemByteConvert16@@YAXPAEQAVCItem@@H@Z ; ItemByteConvert16
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2723 : 
; 2724 : 	cDBSMng.Send((PCHAR)&pMsg, sizeof(pMsg));

  000af	8d 85 e4 f0 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  000b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000ba	68 18 0f 00 00	 push	 3864			; 00000f18H
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2725 : 	gObjSavePetItemInfo(aIndex, 1);

  000c5	6a 01		 push	 1
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 ?gObjSavePetItemInfo@@YAXHH@Z ; gObjSavePetItemInfo

; 2726 : 	gObjWarehouseTextSave(&gObj[aIndex]);

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d2	03 c7		 add	 eax, edi
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjWarehouseTextSave

; 2727 : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	33 cd		 xor	 ecx, ebp
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
?GDSetWarehouseList@@YAXH@Z ENDP			; GDSetWarehouseList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z
_TEXT	SEGMENT
_pResult$ = -28						; size = 11
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z PROC ; GDGetWarehouseNoItem, COMDAT

; 2666 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00013	56		 push	 esi

; 2667 : 	char szId[11];
; 2668 : 	int aIndex = lpMsg->aIndex;
; 2669 : 	PMSG_TALKRESULT pResult;
; 2670 : 
; 2671 : 	szId[MAX_ACCOUNT_LEN] = 0;

  00014	c6 45 fa 00	 mov	 BYTE PTR _szId$[ebp+10], 0
  00018	0f bf 70 0e	 movsx	 esi, WORD PTR [eax+14]

; 2672 : 	memcpy(szId, lpMsg->AccountID, sizeof(lpMsg->AccountID));

  0001c	f3 0f 7e 40 03	 movq	 xmm0, QWORD PTR [eax+3]
  00021	66 8b 40 0b	 mov	 ax, WORD PTR [eax+11]
  00025	66 89 45 f8	 mov	 WORD PTR _szId$[ebp+8], ax

; 2673 : 
; 2674 : 	if ( !gObjIsAccontConnect(aIndex, szId) )

  00029	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0002c	50		 push	 eax
  0002d	56		 push	 esi
  0002e	66 0f d6 45 f0	 movq	 QWORD PTR _szId$[ebp], xmm0
  00033	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00038	83 c4 08	 add	 esp, 8
  0003b	85 c0		 test	 eax, eax
  0003d	75 2f		 jne	 SHORT $LN2@GDGetWareh

; 2675 : 	{
; 2676 : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), szId, aIndex);

  0003f	56		 push	 esi
  00040	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  00043	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00048	50		 push	 eax
  00049	68 af 01 00 00	 push	 431			; 000001afH
  0004e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00053	50		 push	 eax
  00054	6a 02		 push	 2
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
  0005f	5e		 pop	 esi

; 2695 : 		}
; 2696 : 	}
; 2697 : 
; 2698 : 	lpObj->LoadWareHouseInfo = true;
; 2699 : 	lpObj->m_ReqWarehouseOpen = false;
; 2700 : }

  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN2@GDGetWareh:

; 2677 : 		return;
; 2678 : 	}
; 2679 : 
; 2680 : 	LPOBJ lpObj = &gObj[aIndex];

  0006e	69 f6 40 27 00
	00		 imul	 esi, esi, 10048
  00074	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2681 : 	
; 2682 : 	if ( lpObj->m_IfState.type == 6 )

  0007a	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  00080	8b c1		 mov	 eax, ecx
  00082	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00087	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  0008c	75 51		 jne	 SHORT $LN4@GDGetWareh

; 2683 : 	{
; 2684 : 		if ( lpObj->m_IfState.state == 0 )

  0008e	f6 c1 3c	 test	 cl, 60			; 0000003cH
  00091	75 4c		 jne	 SHORT $LN4@GDGetWareh

; 2685 : 		{
; 2686 : 			lpObj->m_IfState.state = 1;

  00093	83 e1 c7	 and	 ecx, -57		; ffffffc7H

; 2687 : 			lpObj->WarehouseSave = 1;

  00096	c7 86 0c 12 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4620], 1
  000a0	83 c9 04	 or	 ecx, 4

; 2688 : 			pResult.h.c = 0xC3;
; 2689 : 			pResult.h.headcode = 0x30;
; 2690 : 			pResult.h.size = sizeof(pResult);
; 2691 : 			pResult.result = 2;
; 2692 : 
; 2693 : 			DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  000a3	8d 45 e4	 lea	 eax, DWORD PTR _pResult$[ebp]
  000a6	6a 0b		 push	 11			; 0000000bH
  000a8	89 8e b8 11 00
	00		 mov	 DWORD PTR [esi+4536], ecx
  000ae	50		 push	 eax
  000af	c7 45 e4 c3 0b
	30 02		 mov	 DWORD PTR _pResult$[ebp], 36703171 ; 02300bc3H
  000b6	ff 36		 push	 DWORD PTR [esi]
  000b8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2694 : 			LogAddC(2, lMsg.Get(MSGGET(1, 176)), lpObj->Name);

  000c0	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000c8	50		 push	 eax
  000c9	68 b0 01 00 00	 push	 432			; 000001b0H
  000ce	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000d3	50		 push	 eax
  000d4	6a 02		 push	 2
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GDGetWareh:

; 2695 : 		}
; 2696 : 	}
; 2697 : 
; 2698 : 	lpObj->LoadWareHouseInfo = true;
; 2699 : 	lpObj->m_ReqWarehouseOpen = false;
; 2700 : }

  000df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	c6 86 ec 13 00
	00 01		 mov	 BYTE PTR [esi+5100], 1
  000e9	33 cd		 xor	 ecx, ebp
  000eb	c6 86 b0 14 00
	00 00		 mov	 BYTE PTR [esi+5296], 0
  000f2	5e		 pop	 esi
  000f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z ENDP ; GDGetWarehouseNoItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z
_TEXT	SEGMENT
tv1988 = -292						; size = 4
tv1992 = -288						; size = 4
_SocketBonus$1 = -284					; size = 1
_aIndex$1$ = -280					; size = 4
tv1994 = -276						; size = 4
_lpMsg$GSCopy$1$ = -272					; size = 4
_dbsize$2$ = -268					; size = 4
tv1996 = -264						; size = 4
_n$1$ = -260						; size = 4
tv1884 = -256						; size = 4
tv2005 = -252						; size = 4
_item$ = -248						; size = 212
_pResult$ = -36						; size = 11
_szId$ = -24						; size = 11
_SocketOptions$2 = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z PROC ; DGGetWarehouseList, COMDAT

; 2405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00018	57		 push	 edi
  00019	89 b5 f0 fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], esi

; 2406 : 	char szId[11];
; 2407 : 	int aIndex = 0;
; 2408 : 	PMSG_TALKRESULT pResult;
; 2409 : 
; 2410 : 	szId[MAX_ACCOUNT_LEN]=0;

  0001f	c6 45 f2 00	 mov	 BYTE PTR _szId$[ebp+10], 0

; 2411 : 	memcpy(szId, lpMsg->AccountID, sizeof(lpMsg->AccountID));

  00023	66 8b 46 0c	 mov	 ax, WORD PTR [esi+12]

; 2412 : 	aIndex = lpMsg->aIndex;

  00027	0f bf 5e 0e	 movsx	 ebx, WORD PTR [esi+14]
  0002b	f3 0f 7e 46 04	 movq	 xmm0, QWORD PTR [esi+4]
  00030	66 89 45 f0	 mov	 WORD PTR _szId$[ebp+8], ax

; 2413 : 
; 2414 : 	if ( !gObjIsAccontConnect(aIndex, szId))

  00034	8d 45 e8	 lea	 eax, DWORD PTR _szId$[ebp]
  00037	50		 push	 eax
  00038	53		 push	 ebx
  00039	66 0f d6 45 e8	 movq	 QWORD PTR _szId$[ebp], xmm0
  0003e	89 9d e8 fe ff
	ff		 mov	 DWORD PTR _aIndex$1$[ebp], ebx
  00044	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00049	83 c4 08	 add	 esp, 8
  0004c	85 c0		 test	 eax, eax
  0004e	75 31		 jne	 SHORT $LN11@DGGetWareh

; 2415 : 	{
; 2416 : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), szId, aIndex);

  00050	53		 push	 ebx
  00051	8d 45 e8	 lea	 eax, DWORD PTR _szId$[ebp]
  00054	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00059	50		 push	 eax
  0005a	68 af 01 00 00	 push	 431			; 000001afH
  0005f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00064	50		 push	 eax
  00065	6a 02		 push	 2
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0006d	83 c4 10	 add	 esp, 16			; 00000010H

; 2662 : 
; 2663 : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00076	33 cd		 xor	 ecx, ebp
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
$LN11@DGGetWareh:

; 2417 : 		return;
; 2418 : 	}
; 2419 : 
; 2420 : 	LPOBJ lpObj = &gObj[aIndex];

  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2421 : 	int itype;
; 2422 : 	int _type;
; 2423 : 	BYTE OptionData;
; 2424 : 	CItem item;

  00086	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0008c	69 db 40 27 00
	00		 imul	 ebx, ebx, 10048
  00092	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv1884[ebp], eax
  00098	89 9d 04 ff ff
	ff		 mov	 DWORD PTR tv2005[ebp], ebx
  0009e	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 2425 : 
; 2426 : 	memset(gObj[aIndex].pWarehouseMap, (BYTE)-1, WAREHOUSE_SIZE);

  000a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a8	68 f0 00 00 00	 push	 240			; 000000f0H
  000ad	68 ff 00 00 00	 push	 255			; 000000ffH
  000b2	ff b4 03 fc 11
	00 00		 push	 DWORD PTR [ebx+eax+4604]
  000b9	e8 00 00 00 00	 call	 _memset

; 2427 : 	gObj[aIndex].WarehouseMoney = lpMsg->Money;

  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000c9	89 8c 03 08 12
	00 00		 mov	 DWORD PTR [ebx+eax+4616], ecx

; 2428 : 	gObj[aIndex].WarehousePW = lpMsg->pw;

  000d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d5	66 8b 8e 16 0f
	00 00		 mov	 cx, WORD PTR [esi+3862]
  000dc	66 89 8c 03 02
	12 00 00	 mov	 WORD PTR [ebx+eax+4610], cx

; 2429 : 
; 2430 : 	int dbsize = 7;

  000e4	b8 07 00 00 00	 mov	 eax, 7

; 2431 : 
; 2432 : 	if( lpMsg->DbVersion >= 3 )

  000e9	8a 8e 14 0f 00
	00		 mov	 cl, BYTE PTR [esi+3860]
  000ef	80 f9 03	 cmp	 cl, 3
  000f2	72 07		 jb	 SHORT $LN12@DGGetWareh

; 2433 : 		dbsize = 16;

  000f4	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000f9	eb 0b		 jmp	 SHORT $LN88@DGGetWareh
$LN12@DGGetWareh:

; 2434 : 	else if( lpMsg->DbVersion >= 1)

  000fb	80 f9 01	 cmp	 cl, 1
  000fe	ba 0a 00 00 00	 mov	 edx, 10			; 0000000aH
  00103	0f 43 c2	 cmovae	 eax, edx
$LN88@DGGetWareh:

; 2435 : 		dbsize = 10;
; 2436 : 
; 2437 : 	for ( int n=0;n<WAREHOUSE_SIZE;n++)

  00106	8d 4e 1b	 lea	 ecx, DWORD PTR [esi+27]
  00109	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _dbsize$2$[ebp], eax
  0010f	bf ec ff ff ff	 mov	 edi, -20		; ffffffecH
  00114	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  0011e	8b d1		 mov	 edx, ecx
  00120	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1996[ebp], 0
  0012a	2b fe		 sub	 edi, esi
  0012c	89 8d ec fe ff
	ff		 mov	 DWORD PTR tv1994[ebp], ecx
  00132	8d 5e 14	 lea	 ebx, DWORD PTR [esi+20]
  00135	89 95 e0 fe ff
	ff		 mov	 DWORD PTR tv1992[ebp], edx
  0013b	89 bd dc fe ff
	ff		 mov	 DWORD PTR tv1988[ebp], edi
$LL4@DGGetWareh:

; 2438 : 	{
; 2439 : 		itype = lpMsg->dbItems[n*dbsize];

  00141	0f b6 3b	 movzx	 edi, BYTE PTR [ebx]

; 2440 : 
; 2441 : 		if ( dbsize == 16 )

  00144	83 f8 10	 cmp	 eax, 16			; 00000010H
  00147	75 1f		 jne	 SHORT $LN15@DGGetWareh

; 2442 : 		{
; 2443 : 			itype |= (lpMsg->dbItems[n*dbsize+DBI_OPTION380_DATA] & 0xF0) << 5;
; 2444 : 			itype |= (lpMsg->dbItems[n*dbsize+DBI_NOPTION_DATA] & 0x80) << 1;

  00149	0f b6 4a 02	 movzx	 ecx, BYTE PTR [edx+2]
  0014d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00150	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00156	c1 e1 04	 shl	 ecx, 4
  00159	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0015e	0b c8		 or	 ecx, eax
  00160	03 c9		 add	 ecx, ecx
  00162	0b f9		 or	 edi, ecx

; 2445 : 			_type = itype;

  00164	8b f7		 mov	 esi, edi
  00166	eb 51		 jmp	 SHORT $LN18@DGGetWareh
$LN15@DGGetWareh:

; 2446 : 		}
; 2447 : 		else if ( dbsize == 10 )

  00168	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0016b	75 2d		 jne	 SHORT $LN17@DGGetWareh

; 2448 : 		{
; 2449 : 			if ( ((lpMsg->dbItems[n*dbsize+DBI_NOPTION_DATA] >> 7) & 0x01) )

  0016d	f6 01 80	 test	 BYTE PTR [ecx], 128	; 00000080H
  00170	74 06		 je	 SHORT $LN19@DGGetWareh

; 2450 : 			{
; 2451 : 				itype += 256;

  00172	81 c7 00 01 00
	00		 add	 edi, 256		; 00000100H
$LN19@DGGetWareh:

; 2452 : 			}
; 2453 : 
; 2454 : 			_type = (itype / 32 * MAX_SUBTYPE_ITEMS) + itype % 32;

  00178	8b c7		 mov	 eax, edi
  0017a	8b cf		 mov	 ecx, edi
  0017c	99		 cdq
  0017d	83 e2 1f	 and	 edx, 31			; 0000001fH
  00180	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  00183	c1 fe 05	 sar	 esi, 5
  00186	c1 e6 09	 shl	 esi, 9
  00189	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  0018f	79 05		 jns	 SHORT $LN86@DGGetWareh
  00191	49		 dec	 ecx
  00192	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  00195	41		 inc	 ecx
$LN86@DGGetWareh:
  00196	03 f1		 add	 esi, ecx

; 2455 : 		}
; 2456 : 		else

  00198	eb 1f		 jmp	 SHORT $LN18@DGGetWareh
$LN17@DGGetWareh:

; 2457 : 		{
; 2458 : 			_type = (itype / MAX_TYPE_ITEMS * MAX_SUBTYPE_ITEMS) + itype % 16;

  0019a	8b c7		 mov	 eax, edi
  0019c	99		 cdq
  0019d	83 e2 0f	 and	 edx, 15			; 0000000fH
  001a0	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  001a3	8b c7		 mov	 eax, edi
  001a5	c1 fe 04	 sar	 esi, 4
  001a8	c1 e6 09	 shl	 esi, 9
  001ab	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  001b0	79 05		 jns	 SHORT $LN87@DGGetWareh
  001b2	48		 dec	 eax
  001b3	83 c8 f0	 or	 eax, -16		; fffffff0H
  001b6	40		 inc	 eax
$LN87@DGGetWareh:
  001b7	03 f0		 add	 esi, eax
$LN18@DGGetWareh:

; 2459 : 		}
; 2460 : 
; 2461 : 		gObj[aIndex].pWarehouse[n].Clear();

  001b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001be	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR tv2005[ebp]
  001c4	8b 8c 01 f8 11
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+4600]
  001cb	03 8d f8 fe ff
	ff		 add	 ecx, DWORD PTR tv1996[ebp]
  001d1	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 2462 : 
; 2463 : 		if ( dbsize >= 16 )

  001d6	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _dbsize$2$[ebp]
  001dc	83 f8 10	 cmp	 eax, 16			; 00000010H
  001df	7c 0e		 jl	 SHORT $LN20@DGGetWareh

; 2464 : 		{
; 2465 : 			if ( lpMsg->dbItems[n*dbsize] == (BYTE)-1 && (lpMsg->dbItems[n*dbsize+DBI_OPTION380_DATA] & 0xF0) == 0xF0 && (lpMsg->dbItems[n*dbsize+7] & 0x80) == 0x80)

  001e1	80 3b ff	 cmp	 BYTE PTR [ebx], 255	; 000000ffH
  001e4	75 29		 jne	 SHORT $LN26@DGGetWareh
  001e6	8a 43 09	 mov	 al, BYTE PTR [ebx+9]
  001e9	24 f0		 and	 al, 240			; 000000f0H
  001eb	3c f0		 cmp	 al, 240			; 000000f0H

; 2466 : 			{
; 2467 : 				itype = -1;
; 2468 : 			}
; 2469 : 		}

  001ed	eb 08		 jmp	 SHORT $LN89@DGGetWareh
$LN20@DGGetWareh:

; 2470 : 		else if ( dbsize >= 10 )

  001ef	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  001f2	7c 10		 jl	 SHORT $LN23@DGGetWareh

; 2471 : 		{
; 2472 : 			if ( lpMsg->dbItems[n*dbsize] == (BYTE)-1 && (lpMsg->dbItems[n*dbsize+DBI_NOPTION_DATA] & 0x80) == 0x80)

  001f4	80 3b ff	 cmp	 BYTE PTR [ebx], 255	; 000000ffH
$LN89@DGGetWareh:
  001f7	75 16		 jne	 SHORT $LN26@DGGetWareh
  001f9	f6 43 07 80	 test	 BYTE PTR [ebx+7], 128	; 00000080H
  001fd	74 10		 je	 SHORT $LN26@DGGetWareh

; 2473 : 			{
; 2474 : 				itype = -1;

  001ff	83 cf ff	 or	 edi, -1

; 2475 : 			}
; 2476 : 		}
; 2477 : 		else

  00202	eb 0b		 jmp	 SHORT $LN26@DGGetWareh
$LN23@DGGetWareh:

; 2478 : 		{
; 2479 : 			if ( lpMsg->dbItems[n*dbsize] == (BYTE)-1 )

  00204	80 3b ff	 cmp	 BYTE PTR [ebx], 255	; 000000ffH
  00207	b8 ff ff ff ff	 mov	 eax, -1
  0020c	0f 44 f8	 cmove	 edi, eax
$LN26@DGGetWareh:

; 2480 : 			{
; 2481 : 				itype = -1;
; 2482 : 			}
; 2483 : 		}
; 2484 : 
; 2485 : 		if ( IsItem(_type) == FALSE )

  0020f	56		 push	 esi
  00210	e8 00 00 00 00	 call	 ?IsItem@@YAHH@Z		; IsItem
  00215	83 c4 04	 add	 esp, 4
  00218	85 c0		 test	 eax, eax
  0021a	b8 ff ff ff ff	 mov	 eax, -1
  0021f	0f 44 f8	 cmove	 edi, eax

; 2486 : 		{
; 2487 : 			itype = -1;
; 2488 : 		}
; 2489 : 
; 2490 : 		if ( _type == ITEMGET(14,17) || _type == ITEMGET(14,18) )

  00222	81 fe 11 1c 00
	00		 cmp	 esi, 7185		; 00001c11H
  00228	74 08		 je	 SHORT $LN29@DGGetWareh
  0022a	81 fe 12 1c 00
	00		 cmp	 esi, 7186		; 00001c12H
  00230	75 0a		 jne	 SHORT $LN30@DGGetWareh
$LN29@DGGetWareh:

; 2491 : 		{
; 2492 : 			if ( lpMsg->dbItems[n*dbsize+DBI_DUR]== 0 )	// Level 0

  00232	80 7b 02 00	 cmp	 BYTE PTR [ebx+2], 0
  00236	75 04		 jne	 SHORT $LN30@DGGetWareh

; 2493 : 			{
; 2494 : 				_type = -1;	// #error maybe this is itype

  00238	0b f0		 or	 esi, eax

; 2495 : 			}
; 2496 : 		}
; 2497 : 
; 2498 : 		if ( _type == ITEMGET(14,19) )

  0023a	eb 12		 jmp	 SHORT $LN32@DGGetWareh
$LN30@DGGetWareh:
  0023c	81 fe 13 1c 00
	00		 cmp	 esi, 7187		; 00001c13H
  00242	75 0a		 jne	 SHORT $LN32@DGGetWareh

; 2499 : 		{
; 2500 : 			if ( lpMsg->dbItems[n*dbsize+DBI_DUR] == (BYTE)-1 )

  00244	80 7b 02 ff	 cmp	 BYTE PTR [ebx+2], 255	; 000000ffH
  00248	0f 84 58 03 00
	00		 je	 $LN85@DGGetWareh
$LN32@DGGetWareh:

; 2501 : 			{
; 2502 : 				itype = -1;
; 2503 : 			}
; 2504 : 		}
; 2505 : 
; 2506 : 		if ( itype != -1 )

  0024e	3b f8		 cmp	 edi, eax
  00250	0f 84 50 03 00
	00		 je	 $LN85@DGGetWareh

; 2507 : 		{
; 2508 : 			item.m_Level = DBI_GET_LEVEL(lpMsg->dbItems[n*dbsize+DBI_OPTION_DATA]);

  00256	8a 4b 01	 mov	 cl, BYTE PTR [ebx+1]

; 2509 : 
; 2510 : 			if ( lpMsg->DbVersion	< 2 )

  00259	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  0025f	8a c1		 mov	 al, cl
  00261	c0 e8 03	 shr	 al, 3
  00264	24 0f		 and	 al, 15			; 0000000fH
  00266	0f b6 c0	 movzx	 eax, al
  00269	80 ba 14 0f 00
	00 02		 cmp	 BYTE PTR [edx+3860], 2
  00270	66 89 85 10 ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], ax
  00277	73 06		 jae	 SHORT $LN34@DGGetWareh

; 2511 : 			{
; 2512 : 				lpMsg->dbItems[n*dbsize+DBI_SOPTION_DATA] = -1;

  00279	66 c7 43 08 ff
	ff		 mov	 WORD PTR [ebx+8], 65535	; 0000ffffH
$LN34@DGGetWareh:

; 2513 : 				lpMsg->dbItems[n*dbsize+DBI_OPTION380_DATA] = -1;
; 2514 : 			}
; 2515 : 
; 2516 : 			if ( _type != ITEMGET(14,11) )	// Box Of Luck

  0027f	81 fe 0b 1c 00
	00		 cmp	 esi, 7179		; 00001c0bH
  00285	74 0f		 je	 SHORT $LN36@DGGetWareh

; 2517 : 			{
; 2518 : 				if ( item.m_Level > MAX_ITEM_LEVEL )

  00287	66 83 f8 0f	 cmp	 ax, 15			; 0000000fH
  0028b	7e 09		 jle	 SHORT $LN36@DGGetWareh

; 2519 : 				{
; 2520 : 					item.m_Level = 0;

  0028d	33 c0		 xor	 eax, eax
  0028f	66 89 85 10 ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], ax
$LN36@DGGetWareh:

; 2521 : 				}
; 2522 : 			}
; 2523 : 
; 2524 : 			OptionData = lpMsg->dbItems[n*dbsize+DBI_OPTION_DATA];
; 2525 : 			item.m_Option1 = DBI_GET_SKILL(OptionData);

  00296	8a c1		 mov	 al, cl
  00298	c0 e8 07	 shr	 al, 7
  0029b	88 45 98	 mov	 BYTE PTR _item$[ebp+144], al

; 2526 : 			item.m_Option2 = DBI_GET_LUCK(OptionData);

  0029e	8a c1		 mov	 al, cl
  002a0	c0 e8 02	 shr	 al, 2

; 2527 : 			item.m_Option3 = DBI_GET_OPTION(OptionData);

  002a3	80 e1 03	 and	 cl, 3
  002a6	24 01		 and	 al, 1
  002a8	88 45 99	 mov	 BYTE PTR _item$[ebp+145], al

; 2528 : 
; 2529 : 			item.m_Option3 |= DBI_GET_OPTION16(lpMsg->dbItems[n*dbsize+DBI_NOPTION_DATA]);

  002ab	8a 43 07	 mov	 al, BYTE PTR [ebx+7]
  002ae	c0 e8 04	 shr	 al, 4
  002b1	24 04		 and	 al, 4
  002b3	0a c1		 or	 al, cl

; 2530 : 			item.m_Durability = lpMsg->dbItems[n*dbsize+DBI_DUR];
; 2531 : 			item.m_JewelOfHarmonyOption = lpMsg->dbItems[n*dbsize+DBI_JOH_DATA];
; 2532 : 
; 2533 : 			if ( dbsize >= 10 )

  002b5	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _dbsize$2$[ebp]
  002bb	88 45 9a	 mov	 BYTE PTR _item$[ebp+146], al
  002be	0f b6 43 02	 movzx	 eax, BYTE PTR [ebx+2]
  002c2	66 0f 6e c0	 movd	 xmm0, eax
  002c6	8a 43 0a	 mov	 al, BYTE PTR [ebx+10]
  002c9	88 45 c8	 mov	 BYTE PTR _item$[ebp+192], al
  002cc	0f 5b c0	 cvtdq2ps xmm0, xmm0
  002cf	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm0
  002d7	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  002da	7c 0d		 jl	 SHORT $LN83@DGGetWareh

; 2534 : 			{
; 2535 : 				item.m_ItemOptionEx = DBI_GET_380OPTION(lpMsg->dbItems[n*dbsize+DBI_OPTION380_DATA]);

  002dc	8a 43 09	 mov	 al, BYTE PTR [ebx+9]
  002df	24 f8		 and	 al, 248			; 000000f8H
  002e1	c0 e0 04	 shl	 al, 4
  002e4	88 45 ce	 mov	 BYTE PTR _item$[ebp+198], al
  002e7	eb 03		 jmp	 SHORT $LN37@DGGetWareh
$LN83@DGGetWareh:
  002e9	8a 45 ce	 mov	 al, BYTE PTR _item$[ebp+198]
$LN37@DGGetWareh:

; 2536 : 			}
; 2537 : 
; 2538 : 			if ( dbsize >= 16 )

  002ec	83 f9 10	 cmp	 ecx, 16			; 00000010H
  002ef	7c 51		 jl	 SHORT $LN40@DGGetWareh

; 2539 : 			{
; 2540 : 				if ( item.m_ItemOptionEx != 0 )

  002f1	84 c0		 test	 al, al
  002f3	74 4d		 je	 SHORT $LN40@DGGetWareh

; 2541 : 				{
; 2542 : 					item.m_Type = itype;
; 2543 : 					if ( g_kItemSystemFor380.Is380Item(&item)== FALSE )

  002f5	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR _item$[ebp]
  002fb	66 89 bd 0e ff
	ff ff		 mov	 WORD PTR _item$[ebp+6], di
  00302	50		 push	 eax
  00303	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  00308	e8 00 00 00 00	 call	 ?Is380Item@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380Item
  0030d	85 c0		 test	 eax, eax
  0030f	75 31		 jne	 SHORT $LN40@DGGetWareh

; 2544 : 					{
; 2545 : 						item.m_ItemOptionEx = 0;
; 2546 : 							LogAddTD("[380Item][%s][%s] Invalid 380 Item Option in Warehouse pos[%d]",

  00311	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv1884[ebp]
  00317	ff b5 fc fe ff
	ff		 push	 DWORD PTR _n$1$[ebp]
  0031d	88 45 ce	 mov	 BYTE PTR _item$[ebp+198], al
  00320	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00323	03 85 04 ff ff
	ff		 add	 eax, DWORD PTR tv2005[ebp]
  00329	50		 push	 eax
  0032a	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  0032d	03 85 04 ff ff
	ff		 add	 eax, DWORD PTR tv2005[ebp]
  00333	50		 push	 eax
  00334	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@HCBBCCKB@?$FL380Item?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5Invalid?5380?5It@
  00339	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0033f	83 c4 10	 add	 esp, 16			; 00000010H
$LN40@DGGetWareh:

; 2547 : 							lpObj->AccountID, lpObj->Name, n);
; 2548 : 					}
; 2549 : 				}
; 2550 : 			}
; 2551 : 
; 2552 : 			BYTE SocketOptions[MAX_SOCKET_COUNT];
; 2553 : 			BYTE SocketBonus = 0xFF;
; 2554 : 			int i = 0;
; 2555 : 
; 2556 : 			memset(SocketOptions,0xFF,MAX_SOCKET_COUNT);
; 2557 : 
; 2558 : 			if( g_SocketItem.IsSocketItem(itype) == TRUE ||

  00342	57		 push	 edi
  00343	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketItem@@3VCSocketItems@@A ; g_SocketItem
  00348	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _SocketOptions$2[ebp], -1
  0034f	c6 45 f8 ff	 mov	 BYTE PTR _SocketOptions$2[ebp+4], -1
  00353	e8 00 00 00 00	 call	 ?IsSocketItem@CSocketItems@@QAE_NH@Z ; CSocketItems::IsSocketItem
  00358	3c 01		 cmp	 al, 1
  0035a	74 2a		 je	 SHORT $LN43@DGGetWareh
  0035c	57		 push	 edi
  0035d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00362	e8 00 00 00 00	 call	 ?IsElementalItem@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsElementalItem
  00367	83 f8 01	 cmp	 eax, 1
  0036a	74 1a		 je	 SHORT $LN43@DGGetWareh
  0036c	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$1$[ebp]

; 2566 : 				}
; 2567 : 			}
; 2568 : 			else
; 2569 : 			{
; 2570 : 				SocketBonus = 0;

  00372	c6 85 e4 fe ff
	ff 00		 mov	 BYTE PTR _SocketBonus$1[ebp], 0

; 2571 : 
; 2572 : 				for( i = 0; i < MAX_SOCKET_COUNT; i++)
; 2573 : 				{
; 2574 : 					SocketOptions[i] = 0xFF;

  00379	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _SocketOptions$2[ebp], -1
  00380	c6 45 f8 ff	 mov	 BYTE PTR _SocketOptions$2[ebp+4], -1
  00384	eb 3b		 jmp	 SHORT $LN75@DGGetWareh
$LN43@DGGetWareh:

; 2559 : 				g_ElementalSystem.IsElementalItem(itype) == TRUE )
; 2560 : 			{
; 2561 : 				SocketBonus = lpMsg->dbItems[n*dbsize+10];

  00386	8a 43 0a	 mov	 al, BYTE PTR [ebx+10]

; 2562 : 
; 2563 : 				for( i = 0; i < MAX_SOCKET_COUNT; i++)
; 2564 : 				{
; 2565 : 					SocketOptions[i] = lpMsg->dbItems[n*dbsize+11+i];

  00389	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  0038f	88 85 e4 fe ff
	ff		 mov	 BYTE PTR _SocketBonus$1[ebp], al
  00395	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv1988[ebp]
  0039b	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  0039e	8a 44 11 1f	 mov	 al, BYTE PTR [ecx+edx+31]
  003a2	88 45 f4	 mov	 BYTE PTR _SocketOptions$2[ebp], al
  003a5	8a 44 11 20	 mov	 al, BYTE PTR [ecx+edx+32]
  003a9	88 45 f5	 mov	 BYTE PTR _SocketOptions$2[ebp+1], al
  003ac	8a 44 11 21	 mov	 al, BYTE PTR [ecx+edx+33]
  003b0	88 45 f6	 mov	 BYTE PTR _SocketOptions$2[ebp+2], al
  003b3	8a 44 11 22	 mov	 al, BYTE PTR [ecx+edx+34]
  003b7	88 45 f7	 mov	 BYTE PTR _SocketOptions$2[ebp+3], al
  003ba	8a 44 11 23	 mov	 al, BYTE PTR [ecx+edx+35]
  003be	88 45 f8	 mov	 BYTE PTR _SocketOptions$2[ebp+4], al
$LN75@DGGetWareh:

; 2575 : 				}
; 2576 : 			}
; 2577 : 
; 2578 : 			item.m_bLOCKED = ( (lpMsg->dbItems[n*dbsize+DBI_SOPTION_DATA]&0xC0) == 0xC0)  ? TRUE : FALSE;

  003c1	8a 4b 08	 mov	 cl, BYTE PTR [ebx+8]
  003c4	8a c1		 mov	 al, cl
  003c6	24 c0		 and	 al, 192			; 000000c0H
  003c8	3c c0		 cmp	 al, 192			; 000000c0H

; 2579 : 
; 2580 : 			if ( lpMsg->DbVersion == 0 )

  003ca	8a 82 14 0f 00
	00		 mov	 al, BYTE PTR [edx+3860]
  003d0	0f 94 45 d9	 sete	 BYTE PTR _item$[ebp+209]
  003d4	84 c0		 test	 al, al
  003d6	75 11		 jne	 SHORT $LN44@DGGetWareh

; 2581 : 			{
; 2582 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, 0, 0, 0,0,0xFF,3);

  003d8	6a 03		 push	 3
  003da	68 ff 00 00 00	 push	 255			; 000000ffH
  003df	6a 00		 push	 0
  003e1	6a 00		 push	 0
  003e3	6a 00		 push	 0
  003e5	6a 00		 push	 0
  003e7	eb 28		 jmp	 SHORT $LN90@DGGetWareh
$LN44@DGGetWareh:

; 2583 : 			}
; 2584 : 			else if ( lpMsg->DbVersion <= 2 )

  003e9	3c 02		 cmp	 al, 2
  003eb	77 0b		 ja	 SHORT $LN46@DGGetWareh

; 2585 : 			{
; 2586 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, DBI_GET_NOPTION(lpMsg->dbItems[n*dbsize+DBI_NOPTION_DATA]), lpMsg->dbItems[n*dbsize+DBI_SOPTION_DATA], item.m_ItemOptionEx, 0,0xFF,1);

  003ed	6a 01		 push	 1
  003ef	68 ff 00 00 00	 push	 255			; 000000ffH
  003f4	6a 00		 push	 0

; 2587 : 			}
; 2588 : 			else

  003f6	eb 0c		 jmp	 SHORT $LN91@DGGetWareh
$LN46@DGGetWareh:

; 2589 : 			{
; 2590 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, DBI_GET_NOPTION(lpMsg->dbItems[n*dbsize+DBI_NOPTION_DATA]), lpMsg->dbItems[n*dbsize+DBI_SOPTION_DATA], item.m_ItemOptionEx, &SocketOptions[0],SocketBonus,3);

  003f8	6a 03		 push	 3
  003fa	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _SocketBonus$1[ebp]
  00400	8d 45 f4	 lea	 eax, DWORD PTR _SocketOptions$2[ebp]
  00403	50		 push	 eax
$LN91@DGGetWareh:
  00404	8a 43 07	 mov	 al, BYTE PTR [ebx+7]
  00407	ff 75 ce	 push	 DWORD PTR _item$[ebp+198]
  0040a	24 3f		 and	 al, 63			; 0000003fH
  0040c	51		 push	 ecx
  0040d	0f b6 c0	 movzx	 eax, al
  00410	50		 push	 eax
$LN90@DGGetWareh:
  00411	ff 75 9a	 push	 DWORD PTR _item$[ebp+146]
  00414	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0041a	ff 75 99	 push	 DWORD PTR _item$[ebp+145]
  0041d	ff 75 98	 push	 DWORD PTR _item$[ebp+144]
  00420	57		 push	 edi
  00421	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert

; 2591 : 			}
; 2592 : 
; 2593 : 			if ( _type == ITEMGET(14,7) ) // Siege Potion

  00426	81 fe 07 1c 00
	00		 cmp	 esi, 7175		; 00001c07H
  0042c	0f 84 97 00 00
	00		 je	 $LN57@DGGetWareh

; 2594 : 			{
; 2595 : 
; 2596 : 			}
; 2597 : 			else if ( (_type >= ITEMGET(14,0) && _type <= ITEMGET(14,8)) || ( _type >= ITEMGET(14,35) && _type <= ITEMGET(14,40) ) )

  00432	81 fe 00 1c 00
	00		 cmp	 esi, 7168		; 00001c00H
  00438	7c 08		 jl	 SHORT $LN53@DGGetWareh
  0043a	81 fe 08 1c 00
	00		 cmp	 esi, 7176		; 00001c08H
  00440	7e 0b		 jle	 SHORT $LN52@DGGetWareh
$LN53@DGGetWareh:
  00442	8d 86 dd e3 ff
	ff		 lea	 eax, DWORD PTR [esi-7203]
  00448	83 f8 05	 cmp	 eax, 5
  0044b	77 35		 ja	 SHORT $LN50@DGGetWareh
$LN52@DGGetWareh:

; 2598 : 			{
; 2599 : 				if ( item.m_Durability == 0.0f )

  0044d	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _item$[ebp+36]
  00455	0f 57 c9	 xorps	 xmm1, xmm1
  00458	0f 2e c1	 ucomiss xmm0, xmm1
  0045b	9f		 lahf
  0045c	f6 c4 44	 test	 ah, 68			; 00000044H
  0045f	7a 0c		 jp	 SHORT $LN54@DGGetWareh

; 2600 : 				{
; 2601 : 					item.m_Durability = 1.0f;

  00461	c7 85 2c ff ff
	ff 00 00 80 3f	 mov	 DWORD PTR _item$[ebp+36], 1065353216 ; 3f800000H

; 2602 : 				}
; 2603 : 
; 2604 : 				if ( item.m_Durability > 255.0f )

  0046b	eb 5c		 jmp	 SHORT $LN57@DGGetWareh
$LN54@DGGetWareh:
  0046d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  00474	76 53		 jbe	 SHORT $LN57@DGGetWareh

; 2605 : 				{
; 2606 : 					item.m_Durability = 255.0f;

  00476	c7 85 2c ff ff
	ff 00 00 7f 43	 mov	 DWORD PTR _item$[ebp+36], 1132396544 ; 437f0000H

; 2607 : 				}
; 2608 : 			}

  00480	eb 47		 jmp	 SHORT $LN57@DGGetWareh
$LN50@DGGetWareh:

; 2609 : 			else if ( _type != ITEMGET(13,10) && _type != ITEMGET(14,29) && _type != ITEMGET(14,21) && item.m_Level == 3 && _type != ITEMGET(14,100) )

  00482	81 fe 0a 1a 00
	00		 cmp	 esi, 6666		; 00001a0aH
  00488	74 3f		 je	 SHORT $LN57@DGGetWareh
  0048a	81 fe 1d 1c 00
	00		 cmp	 esi, 7197		; 00001c1dH
  00490	74 37		 je	 SHORT $LN57@DGGetWareh
  00492	81 fe 15 1c 00
	00		 cmp	 esi, 7189		; 00001c15H
  00498	74 2f		 je	 SHORT $LN57@DGGetWareh
  0049a	66 83 bd 10 ff
	ff ff 03	 cmp	 WORD PTR _item$[ebp+8], 3
  004a2	75 25		 jne	 SHORT $LN57@DGGetWareh
  004a4	81 fe 64 1c 00
	00		 cmp	 esi, 7268		; 00001c64H
  004aa	74 1d		 je	 SHORT $LN57@DGGetWareh

; 2610 : 			{
; 2611 : 				if ( item.m_Durability > item.m_BaseDurability )

  004ac	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _item$[ebp+36]
  004b4	f3 0f 10 8d 34
	ff ff ff	 movss	 xmm1, DWORD PTR _item$[ebp+44]
  004bc	0f 2f c1	 comiss	 xmm0, xmm1
  004bf	76 08		 jbe	 SHORT $LN57@DGGetWareh

; 2612 : 				{
; 2613 : 					item.m_Durability = item.m_BaseDurability;

  004c1	f3 0f 11 8d 2c
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm1
$LN57@DGGetWareh:

; 2614 : 				}
; 2615 : 			}
; 2616 : 
; 2617 : 			lpObj->pWarehouse[n].m_Option1 = item.m_Option1;

  004c9	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR tv2005[ebp]
  004cf	8b bd 00 ff ff
	ff		 mov	 edi, DWORD PTR tv1884[ebp]
  004d5	8b b5 f8 fe ff
	ff		 mov	 esi, DWORD PTR tv1996[ebp]
  004db	8a 45 98	 mov	 al, BYTE PTR _item$[ebp+144]

; 2618 : 			lpObj->pWarehouse[n].m_Option2 = item.m_Option2;
; 2619 : 			lpObj->pWarehouse[n].m_Option3 = item.m_Option3;
; 2620 : 			lpObj->pWarehouse[n].m_JewelOfHarmonyOption = item.m_JewelOfHarmonyOption;
; 2621 : 			lpObj->pWarehouse[n].m_ItemOptionEx = item.m_ItemOptionEx;
; 2622 : 
; 2623 : 			WORD hiword = MAKE_NUMBERW(lpMsg->dbItems[n*dbsize+DBI_SERIAL1], lpMsg->dbItems[n*dbsize+DBI_SERIAL2]);
; 2624 : 			WORD loword = MAKE_NUMBERW(lpMsg->dbItems[n*dbsize+DBI_SERIAL3], lpMsg->dbItems[n*dbsize+DBI_SERIAL4]);
; 2625 : 			item.m_Number = MAKE_NUMBERDW(hiword, loword);
; 2626 : 			
; 2627 : 			gObjWarehouseInsertItemPos(lpObj->m_Index, item, n, -1);

  004de	6a ff		 push	 -1
  004e0	8b 8c 3a f8 11
	00 00		 mov	 ecx, DWORD PTR [edx+edi+4600]
  004e7	ff b5 fc fe ff
	ff		 push	 DWORD PTR _n$1$[ebp]
  004ed	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  004f3	88 84 0e 90 00
	00 00		 mov	 BYTE PTR [esi+ecx+144], al
  004fa	8b 8c 3a f8 11
	00 00		 mov	 ecx, DWORD PTR [edx+edi+4600]
  00501	8a 45 99	 mov	 al, BYTE PTR _item$[ebp+145]
  00504	88 84 0e 91 00
	00 00		 mov	 BYTE PTR [esi+ecx+145], al
  0050b	8b 8c 3a f8 11
	00 00		 mov	 ecx, DWORD PTR [edx+edi+4600]
  00512	8a 45 9a	 mov	 al, BYTE PTR _item$[ebp+146]
  00515	88 84 0e 92 00
	00 00		 mov	 BYTE PTR [esi+ecx+146], al
  0051c	8b 8c 3a f8 11
	00 00		 mov	 ecx, DWORD PTR [edx+edi+4600]
  00523	8a 45 c8	 mov	 al, BYTE PTR _item$[ebp+192]
  00526	88 84 0e c0 00
	00 00		 mov	 BYTE PTR [esi+ecx+192], al
  0052d	8b 8c 3a f8 11
	00 00		 mov	 ecx, DWORD PTR [edx+edi+4600]
  00534	8b fc		 mov	 edi, esp
  00536	8a 45 ce	 mov	 al, BYTE PTR _item$[ebp+198]
  00539	88 84 0e c6 00
	00 00		 mov	 BYTE PTR [esi+ecx+198], al
  00540	8d b5 08 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  00546	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  0054a	66 c1 e0 08	 shl	 ax, 8
  0054e	0f b7 c8	 movzx	 ecx, ax
  00551	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00555	0b c8		 or	 ecx, eax
  00557	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  0055b	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0055e	66 c1 e0 08	 shl	 ax, 8
  00562	0f b7 c0	 movzx	 eax, ax
  00565	0b c8		 or	 ecx, eax
  00567	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  0056b	0b c8		 or	 ecx, eax
  0056d	89 8d 08 ff ff
	ff		 mov	 DWORD PTR _item$[ebp], ecx
  00573	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00578	f3 a5		 rep movsd
  0057a	8b bd 00 ff ff
	ff		 mov	 edi, DWORD PTR tv1884[ebp]
  00580	ff 34 3a	 push	 DWORD PTR [edx+edi]
  00583	e8 00 00 00 00	 call	 ?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z ; gObjWarehouseInsertItemPos

; 2628 : 			gObjWarehouseItemSet(lpObj->m_Index, n, 1);

  00588	8b b5 04 ff ff
	ff		 mov	 esi, DWORD PTR tv2005[ebp]
  0058e	6a 01		 push	 1
  00590	ff b5 fc fe ff
	ff		 push	 DWORD PTR _n$1$[ebp]
  00596	ff 34 3e	 push	 DWORD PTR [esi+edi]
  00599	e8 00 00 00 00	 call	 ?gObjWarehouseItemSet@@YAXHHE@Z ; gObjWarehouseItemSet
  0059e	81 c4 ec 00 00
	00		 add	 esp, 236		; 000000ecH
  005a4	eb 0c		 jmp	 SHORT $LN2@DGGetWareh
$LN85@DGGetWareh:
  005a6	8b bd 00 ff ff
	ff		 mov	 edi, DWORD PTR tv1884[ebp]
  005ac	8b b5 04 ff ff
	ff		 mov	 esi, DWORD PTR tv2005[ebp]
$LN2@DGGetWareh:

; 2435 : 		dbsize = 10;
; 2436 : 
; 2437 : 	for ( int n=0;n<WAREHOUSE_SIZE;n++)

  005b2	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv1996[ebp]
  005b8	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv1992[ebp]
  005be	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  005c4	83 85 ec fe ff
	ff 0a		 add	 DWORD PTR tv1994[ebp], 10 ; 0000000aH
  005cb	83 c2 10	 add	 edx, 16			; 00000010H
  005ce	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _dbsize$2$[ebp]
  005d4	03 d8		 add	 ebx, eax
  005d6	ff 85 fc fe ff
	ff		 inc	 DWORD PTR _n$1$[ebp]
  005dc	81 f9 c0 c6 00
	00		 cmp	 ecx, 50880		; 0000c6c0H
  005e2	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv1996[ebp], ecx
  005e8	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv1994[ebp]
  005ee	89 95 e0 fe ff
	ff		 mov	 DWORD PTR tv1992[ebp], edx
  005f4	0f 8c 47 fb ff
	ff		 jl	 $LL4@DGGetWareh

; 2629 : 		}
; 2630 : 	}
; 2631 : 
; 2632 : 	pResult.h.c = 0xC3;
; 2633 : 	pResult.h.headcode = 0x30;
; 2634 : 	pResult.h.size = sizeof(PMSG_TALKRESULT);
; 2635 : 	pResult.result = 2;
; 2636 : 
; 2637 : 	DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  005fa	6a 0b		 push	 11			; 0000000bH
  005fc	8d 45 dc	 lea	 eax, DWORD PTR _pResult$[ebp]
  005ff	c7 45 dc c3 0b
	30 02		 mov	 DWORD PTR _pResult$[ebp], 36703171 ; 02300bc3H
  00606	50		 push	 eax
  00607	ff 34 3e	 push	 DWORD PTR [esi+edi]
  0060a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2638 : 	GCUserWarehouseSend(&gObj[aIndex]);

  0060f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00614	03 c6		 add	 eax, esi
  00616	50		 push	 eax
  00617	e8 00 00 00 00	 call	 ?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z ; GCUserWarehouseSend
  0061c	83 c4 10	 add	 esp, 16			; 00000010H

; 2639 : 
; 2640 : 	if ( bCanWarehouseLock == TRUE )

  0061f	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 1 ; bCanWarehouseLock
  00626	75 32		 jne	 SHORT $LN60@DGGetWareh

; 2641 : 	{
; 2642 : 		if ( gObj[aIndex].WarehousePW > 0 )

  00628	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0062d	66 83 bc 06 02
	12 00 00 00	 cmp	 WORD PTR [esi+eax+4610], 0
  00636	7e 12		 jle	 SHORT $LN59@DGGetWareh

; 2643 : 		{
; 2644 : 			if ( gObj[aIndex].WarehouseLock == 0 )

  00638	80 bc 06 04 12
	00 00 00	 cmp	 BYTE PTR [esi+eax+4612], 0
  00640	75 04		 jne	 SHORT $LN61@DGGetWareh

; 2645 : 			{
; 2646 : 				GCWarehouseStateSend(aIndex, 12);

  00642	6a 0c		 push	 12			; 0000000cH

; 2647 : 			}
; 2648 : 			else

  00644	eb 06		 jmp	 SHORT $LN92@DGGetWareh
$LN61@DGGetWareh:

; 2649 : 			{
; 2650 : 				GCWarehouseStateSend(aIndex, 1);

  00646	6a 01		 push	 1

; 2651 : 			}
; 2652 : 		}
; 2653 : 		else

  00648	eb 02		 jmp	 SHORT $LN92@DGGetWareh
$LN59@DGGetWareh:

; 2654 : 		{
; 2655 : 			GCWarehouseStateSend(aIndex, 0);

  0064a	6a 00		 push	 0
$LN92@DGGetWareh:
  0064c	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _aIndex$1$[ebp]
  00652	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  00657	83 c4 08	 add	 esp, 8
$LN60@DGGetWareh:

; 2656 : 		}
; 2657 : 	}
; 2658 : 
; 2659 : 	lpObj->LoadWareHouseInfo = true;
; 2660 : 	lpObj->m_ReqWarehouseOpen = false;
; 2661 : 	gObjRequestPetItemInfo(lpObj->m_Index, 1);

  0065a	6a 01		 push	 1
  0065c	ff 34 3e	 push	 DWORD PTR [esi+edi]
  0065f	c6 84 3e ec 13
	00 00 01	 mov	 BYTE PTR [esi+edi+5100], 1
  00667	c6 84 3e b0 14
	00 00 00	 mov	 BYTE PTR [esi+edi+5296], 0
  0066f	e8 00 00 00 00	 call	 ?gObjRequestPetItemInfo@@YAXHH@Z ; gObjRequestPetItemInfo

; 2662 : 
; 2663 : }

  00674	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00677	83 c4 08	 add	 esp, 8
  0067a	33 cd		 xor	 ecx, ebp
  0067c	5f		 pop	 edi
  0067d	5e		 pop	 esi
  0067e	5b		 pop	 ebx
  0067f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00684	8b e5		 mov	 esp, ebp
  00686	5d		 pop	 ebp
  00687	c3		 ret	 0
?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z ENDP ; DGGetWarehouseList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GDGetWarehouseList@@YAXHPAD@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_AccountID$ = 12					; size = 4
?GDGetWarehouseList@@YAXHPAD@Z PROC			; GDGetWarehouseList, COMDAT

; 2382 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _AccountID$[ebp]

; 2383 : 	if ( strlen(AccountID) < 1 )

  00013	8b ca		 mov	 ecx, edx
  00015	56		 push	 esi
  00016	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@GDGetWareh:
  00020	8a 01		 mov	 al, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL4@GDGetWareh
  00027	2b ce		 sub	 ecx, esi
  00029	5e		 pop	 esi
  0002a	83 f9 01	 cmp	 ecx, 1
  0002d	72 33		 jb	 SHORT $LN1@GDGetWareh

; 2384 : 	{
; 2385 : 		return;
; 2386 : 	}
; 2387 : 
; 2388 : 	SDHP_GETWAREHOUSEDB	pMsg;
; 2389 : 
; 2390 : 	pMsg.h.c = 0xC1;
; 2391 : 	pMsg.h.headcode = 0x08;
; 2392 : 	pMsg.h.size = sizeof(SDHP_GETWAREHOUSEDB);
; 2393 : 	pMsg.aIndex = aIndex;

  0002f	66 8b 45 08	 mov	 ax, WORD PTR _aIndex$[ebp]

; 2394 : 	memcpy(pMsg.AccountID, AccountID, sizeof(pMsg.AccountID));
; 2395 : 
; 2396 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  00033	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00038	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  0003c	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+14], ax
  00040	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  00044	66 89 45 f7	 mov	 WORD PTR _pMsg$[ebp+11], ax
  00048	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004b	6a 10		 push	 16			; 00000010H
  0004d	50		 push	 eax
  0004e	66 c7 45 ec c1
	10		 mov	 WORD PTR _pMsg$[ebp], 4289 ; 000010c1H
  00054	c6 45 ee 08	 mov	 BYTE PTR _pMsg$[ebp+2], 8
  00058	66 0f d6 45 ef	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  0005d	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@GDGetWareh:

; 2397 : }

  00062	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00065	33 cd		 xor	 ecx, ebp
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?GDGetWarehouseList@@YAXHPAD@Z ENDP			; GDGetWarehouseList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_pCSave$ = -4388					; size = 4384
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_bMapServerMove$ = 16					; size = 4
_bSaveItem$ = 20					; size = 4
?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z PROC	; GJSetCharacterInfo, COMDAT

; 2266 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 24 11 00 00	 mov	 eax, 4388		; 00001124H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 2267 : 	if ( lpObj->m_bMapSvrMoveQuit == true )

  0001b	80 be 3c 20 00
	00 01		 cmp	 BYTE PTR [esi+8252], 1
  00022	75 29		 jne	 SHORT $LN2@GJSetChara

; 2268 : 	{
; 2269 : 		LogAddC(2,"[MapServerMng] GJSetCharacterInfo() - Inventory Already Saved [%s][%s] (%d)",

  00024	ff 36		 push	 DWORD PTR [esi]
  00026	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00029	50		 push	 eax
  0002a	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0002d	50		 push	 eax
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@LOGFDPHA@?$FLMapServerMng?$FN?5GJSetCharacterInf@
  00033	6a 02		 push	 2
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
  0003e	5e		 pop	 esi

; 2359 : #if (ENABLETEST_MUUN == 1)
; 2360 : 	g_CMuunSystem.GDReqSaveMuunInvenItem(*lpObj);
; 2361 : #endif
; 2362 : }

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN2@GJSetChara:

; 2270 : 			lpObj->AccountID, lpObj->Name, lpObj->m_Index);
; 2271 : 
; 2272 : 		return;
; 2273 : 	}
; 2274 : 
; 2275 : 	if ( bMapServerMove == TRUE )

  0004d	83 7d 10 01	 cmp	 DWORD PTR _bMapServerMove$[ebp], 1
  00051	75 21		 jne	 SHORT $LN3@GJSetChara

; 2276 : 	{
; 2277 : 		lpObj->m_bMapSvrMoveQuit = TRUE;
; 2278 : 
; 2279 : 		LogAddC(5, "[MapServerMng][%s][%s] GJSetCharacterInfo() - MapServerMove Character Save Start (%d)",

  00053	ff 36		 push	 DWORD PTR [esi]
  00055	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00058	c6 86 3c 20 00
	00 01		 mov	 BYTE PTR [esi+8252], 1
  0005f	50		 push	 eax
  00060	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00063	50		 push	 eax
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@OKDBPAON@?$FLMapServerMng?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5GJSetChar@
  00069	6a 05		 push	 5
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00071	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@GJSetChara:

; 2280 : 			lpObj->AccountID, lpObj->Name, lpObj->m_Index);
; 2281 : 	}
; 2282 : 
; 2283 : 
; 2284 : 	if ( lpObj->m_IfState.use > 0 && lpObj->m_IfState.type == 6 && lpObj->m_IfState.state == 1)

  00074	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  0007a	57		 push	 edi
  0007b	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0007e	f6 c1 03	 test	 cl, 3
  00081	76 1f		 jbe	 SHORT $LN4@GJSetChara
  00083	8b c1		 mov	 eax, ecx
  00085	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0008a	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  0008f	75 11		 jne	 SHORT $LN4@GJSetChara
  00091	80 e1 3c	 and	 cl, 60			; 0000003cH
  00094	80 f9 04	 cmp	 cl, 4
  00097	75 09		 jne	 SHORT $LN4@GJSetChara

; 2285 : 	{
; 2286 : 		GDSetWarehouseList(aIndex);

  00099	57		 push	 edi
  0009a	e8 00 00 00 00	 call	 ?GDSetWarehouseList@@YAXH@Z ; GDSetWarehouseList
  0009f	83 c4 04	 add	 esp, 4
$LN4@GJSetChara:

; 2287 : 	}
; 2288 : 
; 2289 : 	SDHP_DBCHAR_INFOSAVE pCSave;	// Packet Character Save
; 2290 :  
; 2291 : 	pCSave.h.c = 0xC2;
; 2292 : 	pCSave.h.headcode = 0x07;
; 2293 : 	pCSave.h.sizeH = sizeof(SDHP_DBCHAR_INFOSAVE) >> 8;
; 2294 : 	pCSave.h.sizeL = sizeof(SDHP_DBCHAR_INFOSAVE) & 0xFF;
; 2295 : 	pCSave.Name[MAX_ACCOUNT_LEN] = 0;
; 2296 : 	memcpy(pCSave.Name, lpObj->Name, sizeof(pCSave.Name)-1);

  000a2	0f b7 46 65	 movzx	 eax, WORD PTR [esi+101]
  000a6	f3 0f 7e 46 5d	 movq	 xmm0, QWORD PTR [esi+93]

; 2297 : 	pCSave.Class = lpObj->DbClass;
; 2298 : 	pCSave.Level = lpObj->Level;
; 2299 : 	pCSave.LevelUpPoint = lpObj->LevelUpPoint;
; 2300 : 	pCSave.Exp = lpObj->Experience;
; 2301 : 	pCSave.NextExp = lpObj->NextExp;
; 2302 : 	pCSave.Money = lpObj->Money;
; 2303 : 	pCSave.Str = lpObj->Strength;
; 2304 : 	pCSave.Dex = lpObj->Dexterity;
; 2305 : 	pCSave.Vit = lpObj->Vitality;
; 2306 : 	pCSave.Energy = lpObj->Energy;
; 2307 : 	pCSave.Life = (WORD)(lpObj->Life*10.0f);

  000ab	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@41200000
  000b3	66 89 85 e8 ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+12], ax
  000ba	0f b6 86 92 00
	00 00		 movzx	 eax, BYTE PTR [esi+146]
  000c1	88 85 ee ee ff
	ff		 mov	 BYTE PTR _pCSave$[ebp+18], al
  000c7	0f b7 86 96 00
	00 00		 movzx	 eax, WORD PTR [esi+150]
  000ce	53		 push	 ebx
  000cf	66 89 85 ec ee
	ff ff		 mov	 WORD PTR _pCSave$[ebp+16], ax
  000d6	8d 5e 5d	 lea	 ebx, DWORD PTR [esi+93]
  000d9	8b 86 98 00 00
	00		 mov	 eax, DWORD PTR [esi+152]
  000df	89 85 f0 ee ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+20], eax
  000e5	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  000eb	89 85 f4 ee ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+24], eax
  000f1	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  000f7	89 85 f8 ee ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+28], eax
  000fd	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  00103	89 85 fc ee ff
	ff		 mov	 DWORD PTR _pCSave$[ebp+32], eax
  00109	0f b7 86 d0 00
	00 00		 movzx	 eax, WORD PTR [esi+208]
  00110	66 89 85 00 ef
	ff ff		 mov	 WORD PTR _pCSave$[ebp+36], ax
  00117	0f b7 86 d2 00
	00 00		 movzx	 eax, WORD PTR [esi+210]
  0011e	66 0f d6 85 e0
	ee ff ff	 movq	 QWORD PTR _pCSave$[ebp+4], xmm0
  00126	f3 0f 10 86 d8
	00 00 00	 movss	 xmm0, DWORD PTR [esi+216]
  0012e	66 89 85 02 ef
	ff ff		 mov	 WORD PTR _pCSave$[ebp+38], ax
  00135	0f b7 86 d4 00
	00 00		 movzx	 eax, WORD PTR [esi+212]
  0013c	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00140	66 89 85 04 ef
	ff ff		 mov	 WORD PTR _pCSave$[ebp+40], ax
  00147	0f b7 86 d6 00
	00 00		 movzx	 eax, WORD PTR [esi+214]
  0014e	66 89 85 06 ef
	ff ff		 mov	 WORD PTR _pCSave$[ebp+42], ax
  00155	f3 0f 2c c0	 cvttss2si eax, xmm0

; 2308 : 	pCSave.MaxLife = (WORD)(lpObj->MaxLife*10.0f);
; 2309 : 	pCSave.Mana = (WORD)(lpObj->Mana*10.0f);
; 2310 : 	pCSave.MaxMana = (WORD)(lpObj->MaxMana*10.0f);
; 2311 : 	ItemByteConvert16((LPBYTE)pCSave.dbInventory , lpObj->pInventory, INVENTORY_SIZE);

  00159	68 ed 00 00 00	 push	 237			; 000000edH
  0015e	c7 85 dc ee ff
	ff c2 11 20 07	 mov	 DWORD PTR _pCSave$[ebp], 119542210 ; 072011c2H
  00168	c6 85 ea ee ff
	ff 00		 mov	 BYTE PTR _pCSave$[ebp+14], 0
  0016f	f3 0f 10 86 dc
	00 00 00	 movss	 xmm0, DWORD PTR [esi+220]
  00177	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0017b	66 89 85 08 ef
	ff ff		 mov	 WORD PTR _pCSave$[ebp+44], ax
  00182	ff b6 c0 11 00
	00		 push	 DWORD PTR [esi+4544]
  00188	f3 0f 2c c0	 cvttss2si eax, xmm0
  0018c	f3 0f 10 86 ec
	00 00 00	 movss	 xmm0, DWORD PTR [esi+236]
  00194	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00198	66 89 85 0a ef
	ff ff		 mov	 WORD PTR _pCSave$[ebp+46], ax
  0019f	f3 0f 2c c0	 cvttss2si eax, xmm0
  001a3	f3 0f 10 86 f0
	00 00 00	 movss	 xmm0, DWORD PTR [esi+240]
  001ab	f3 0f 59 c1	 mulss	 xmm0, xmm1
  001af	66 89 85 0c ef
	ff ff		 mov	 WORD PTR _pCSave$[ebp+48], ax
  001b6	f3 0f 2c c0	 cvttss2si eax, xmm0
  001ba	66 89 85 0e ef
	ff ff		 mov	 WORD PTR _pCSave$[ebp+50], ax
  001c1	8d 85 10 ef ff
	ff		 lea	 eax, DWORD PTR _pCSave$[ebp+52]
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 ?ItemByteConvert16@@YAXPAEQAVCItem@@H@Z ; ItemByteConvert16

; 2312 : 	MagicByteConvert(pCSave.dbMagicList, lpObj->Magic, MAGIC_SIZE);

  001cd	68 96 00 00 00	 push	 150			; 00000096H
  001d2	ff b6 a8 06 00
	00		 push	 DWORD PTR [esi+1704]
  001d8	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _pCSave$[ebp+3844]
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 ?MagicByteConvert@@YAXPAEQAVCMagicInf@@H@Z ; MagicByteConvert

; 2313 : 	pCSave.MapNumber = lpObj->MapNumber;

  001e4	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  001eb	83 c4 18	 add	 esp, 24			; 00000018H
  001ee	88 45 a2	 mov	 BYTE PTR _pCSave$[ebp+4294], al

; 2314 : 	pCSave.MapX = lpObj->X;

  001f1	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  001f8	88 45 a3	 mov	 BYTE PTR _pCSave$[ebp+4295], al

; 2315 : 	pCSave.MapY = lpObj->Y;

  001fb	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00202	88 45 a4	 mov	 BYTE PTR _pCSave$[ebp+4296], al

; 2316 : 	pCSave.Dir = lpObj->Dir;

  00205	0f b6 86 22 01
	00 00		 movzx	 eax, BYTE PTR [esi+290]
  0020c	88 45 a5	 mov	 BYTE PTR _pCSave$[ebp+4297], al

; 2317 : 	pCSave.PkCount = lpObj->m_PK_Count;

  0020f	0f be 86 18 01
	00 00		 movsx	 eax, BYTE PTR [esi+280]
  00216	89 45 a8	 mov	 DWORD PTR _pCSave$[ebp+4300], eax

; 2318 : 	pCSave.PkLevel = lpObj->m_PK_Level;

  00219	0f be 86 19 01
	00 00		 movsx	 eax, BYTE PTR [esi+281]
  00220	89 45 ac	 mov	 DWORD PTR _pCSave$[ebp+4304], eax

; 2319 : 	pCSave.PkTime = lpObj->m_PK_Time;

  00223	8b 86 1c 01 00
	00		 mov	 eax, DWORD PTR [esi+284]
  00229	89 45 b0	 mov	 DWORD PTR _pCSave$[ebp+4308], eax

; 2320 : 	pCSave.Leadership = lpObj->Leadership;

  0022c	0f b7 86 f4 00
	00 00		 movzx	 eax, WORD PTR [esi+244]
  00233	66 89 45 e8	 mov	 WORD PTR _pCSave$[ebp+4364], ax

; 2321 : 	pCSave.ChatLitmitTime = lpObj->ChatLimitTime;

  00237	0f b7 86 f8 00
	00 00		 movzx	 eax, WORD PTR [esi+248]
  0023e	66 89 45 ea	 mov	 WORD PTR _pCSave$[ebp+4366], ax

; 2322 : 	pCSave.iFruitPoint = lpObj->iFruitPoint;

  00242	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  00248	89 45 ec	 mov	 DWORD PTR _pCSave$[ebp+4368], eax

; 2323 : //#ifdef STREAM
; 2324 : 	pCSave.m_Credits = lpObj->m_Credits;

  0024b	8b 86 38 27 00
	00		 mov	 eax, DWORD PTR [esi+10040]
  00251	89 45 f8	 mov	 DWORD PTR _pCSave$[ebp+4380], eax

; 2325 : //#endif
; 2326 : 
; 2327 : #if( ENABLE_CUSTOM_HARDCORE == 1 )
; 2328 : 	pCSave.HardcoreLife = lpObj->m_HardcoreLife;

  00254	0f b7 86 3c 27
	00 00		 movzx	 eax, WORD PTR [esi+10044]
  0025b	66 89 45 f4	 mov	 WORD PTR _pCSave$[ebp+4376], ax

; 2329 : #endif
; 2330 : 
; 2331 : 	pCSave.CharInfoSave = 0;

  0025f	c6 45 e6 00	 mov	 BYTE PTR _pCSave$[ebp+4362], 0

; 2332 : #if (__CUSTOM__ == 1)
; 2333 : 	pCSave.iReset = lpObj->iResetCount;
; 2334 : #if( __4GAMERS__ == 1 )
; 2335 : 	g_ResetDebug.Output("[%s] [%s] Save character, reset: %d",
; 2336 : 		lpObj->AccountID, lpObj->Name, lpObj->iResetCount);
; 2337 : #endif
; 2338 : #endif
; 2339 : 	memcpy(pCSave.dbQuest, lpObj->m_Quest, sizeof(pCSave.dbQuest));

  00263	0f 10 86 24 14
	00 00		 movups	 xmm0, XMMWORD PTR [esi+5156]
  0026a	8b 86 20 27 00
	00		 mov	 eax, DWORD PTR [esi+10016]

; 2340 : 
; 2341 : 	if ( cDBSMng.Send((char*)&pCSave, sizeof(SDHP_DBCHAR_INFOSAVE)) == FALSE )

  00270	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00275	89 45 f0	 mov	 DWORD PTR _pCSave$[ebp+4372], eax
  00278	0f b7 86 54 14
	00 00		 movzx	 eax, WORD PTR [esi+5204]
  0027f	0f 11 45 b4	 movups	 XMMWORD PTR _pCSave$[ebp+4312], xmm0
  00283	66 89 45 e4	 mov	 WORD PTR _pCSave$[ebp+4360], ax
  00287	8d 85 dc ee ff
	ff		 lea	 eax, DWORD PTR _pCSave$[ebp]
  0028d	0f 10 86 34 14
	00 00		 movups	 xmm0, XMMWORD PTR [esi+5172]
  00294	68 20 11 00 00	 push	 4384			; 00001120H
  00299	50		 push	 eax
  0029a	0f 11 45 c4	 movups	 XMMWORD PTR _pCSave$[ebp+4328], xmm0
  0029e	0f 10 86 44 14
	00 00		 movups	 xmm0, XMMWORD PTR [esi+5188]
  002a5	0f 11 45 d4	 movups	 XMMWORD PTR _pCSave$[ebp+4344], xmm0
  002a9	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  002ae	85 c0		 test	 eax, eax
  002b0	75 2d		 jne	 SHORT $LN5@GJSetChara

; 2342 : 	{
; 2343 : 		LogAddC(2, lMsg.Get(MSGGET(1, 174)), lpObj->Name);

  002b2	53		 push	 ebx
  002b3	68 ae 01 00 00	 push	 430			; 000001aeH
  002b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002bd	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002c2	50		 push	 eax
  002c3	6a 02		 push	 2
  002c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ce	5b		 pop	 ebx
  002cf	5f		 pop	 edi
  002d0	5e		 pop	 esi

; 2359 : #if (ENABLETEST_MUUN == 1)
; 2360 : 	g_CMuunSystem.GDReqSaveMuunInvenItem(*lpObj);
; 2361 : #endif
; 2362 : }

  002d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d4	33 cd		 xor	 ecx, ebp
  002d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002db	8b e5		 mov	 esp, ebp
  002dd	5d		 pop	 ebp
  002de	c3		 ret	 0
$LN5@GJSetChara:

; 2344 : 		return;
; 2345 : 	}
; 2346 : 
; 2347 : #if (__CUSTOM__==1)
; 2348 : 	if( bSaveItem == TRUE )	{

  002df	83 7d 14 01	 cmp	 DWORD PTR _bSaveItem$[ebp], 1
  002e3	75 09		 jne	 SHORT $LN6@GJSetChara

; 2349 : 		gObjItemTextSave(lpObj);

  002e5	56		 push	 esi
  002e6	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjItemTextSave
  002eb	83 c4 04	 add	 esp, 4
$LN6@GJSetChara:

; 2350 : 	}
; 2351 : #else
; 2352 : 	gObjItemTextSave(lpObj);
; 2353 : #endif
; 2354 : 	gObjStatTextSave(lpObj);

  002ee	56		 push	 esi
  002ef	e8 00 00 00 00	 call	 ?gObjStatTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjStatTextSave

; 2355 : 	gObjSavePetItemInfo(aIndex, 0);

  002f4	6a 00		 push	 0
  002f6	57		 push	 edi
  002f7	e8 00 00 00 00	 call	 ?gObjSavePetItemInfo@@YAXHH@Z ; gObjSavePetItemInfo
  002fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2356 : 	g_MonsterKillInfo.SaveMonsterKillInfo(lpObj);

  002ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterKillInfo@@3VCQuestMonsterKillInfo@@A ; g_MonsterKillInfo
  00304	56		 push	 esi
  00305	e8 00 00 00 00	 call	 ?SaveMonsterKillInfo@CQuestMonsterKillInfo@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestMonsterKillInfo::SaveMonsterKillInfo

; 2357 : 	g_MasterExp.SaveMasterInfo(lpObj);

  0030a	56		 push	 esi
  0030b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterExp@@3VCMasterExperience@@A ; g_MasterExp
  00310	e8 00 00 00 00	 call	 ?SaveMasterInfo@CMasterExperience@@QAEXPAUOBJECTSTRUCT@@@Z ; CMasterExperience::SaveMasterInfo

; 2358 : 	g_ElementalSystem.GDSaveErtelList(aIndex);

  00315	57		 push	 edi
  00316	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  0031b	e8 00 00 00 00	 call	 ?GDSaveErtelList@CElementalSystem@@QAEXH@Z ; CElementalSystem::GDSaveErtelList

; 2359 : #if (ENABLETEST_MUUN == 1)
; 2360 : 	g_CMuunSystem.GDReqSaveMuunInvenItem(*lpObj);
; 2361 : #endif
; 2362 : }

  00320	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00323	5b		 pop	 ebx
  00324	5f		 pop	 edi
  00325	33 cd		 xor	 ecx, ebp
  00327	5e		 pop	 esi
  00328	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032d	8b e5		 mov	 esp, ebp
  0032f	5d		 pop	 ebp
  00330	c3		 ret	 0
?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z ENDP	; GJSetCharacterInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?GCItemListSend@@YAXH@Z
_TEXT	SEGMENT
_aIndex$GSCopy$1$ = -4140				; size = 4
_n$1$ = -4136						; size = 4
_itemcount$1$ = -4132					; size = 4
_sOfs$1$ = -4128					; size = 4
_lpObj$1$ = -4124					; size = 4
_pMsgILC$ = -4124					; size = 6
_pMsgIL$ = -4116					; size = 13
_sendBuf$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCItemListSend@@YAXH@Z PROC				; GCItemListSend, COMDAT

; 2172 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 2c 10 00 00	 mov	 eax, 4140		; 0000102cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0001a	53		 push	 ebx
  0001b	56		 push	 esi

; 2173 : 	PMSG_INVENTORYLISTCOUNT pMsgILC;
; 2174 : 	PMSG_INVENTORYLIST pMsgIL;
; 2175 : 	int sOfs = sizeof(PMSG_INVENTORYLISTCOUNT);
; 2176 : 	int pMsgILSize = sizeof(PMSG_INVENTORYLIST);
; 2177 : 	BYTE sendBuf[4096];
; 2178 : 	LPOBJ lpObj = &gObj[aIndex];

  0001c	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  00022	57		 push	 edi
  00023	89 85 d4 ef ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], eax
  00029	c7 85 e0 ef ff
	ff 06 00 00 00	 mov	 DWORD PTR _sOfs$1$[ebp], 6

; 2179 : 	int itemcount = 0;

  00033	c7 85 dc ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _itemcount$1$[ebp], 0
  0003d	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00043	33 db		 xor	 ebx, ebx
  00045	89 b5 e4 ef ff
	ff		 mov	 DWORD PTR _lpObj$1$[ebp], esi

; 2180 : 	
; 2181 : 	for ( int n=0;n<INVENTORY_SIZE;n++)

  0004b	c7 85 d8 ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@GCItemList:

; 2182 : 	{
; 2183 : 		if ( lpObj->pInventory[n].IsItem() == TRUE )

  00060	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00066	03 cb		 add	 ecx, ebx
  00068	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006d	83 f8 01	 cmp	 eax, 1
  00070	0f 85 98 00 00
	00		 jne	 $LN13@GCItemList

; 2184 : 		{
; 2185 : 			if ( lpObj->pInventory[n].m_bItemExist == false )

  00076	8b 86 c0 11 00
	00		 mov	 eax, DWORD PTR [esi+4544]
  0007c	80 bc 18 86 00
	00 00 00	 cmp	 BYTE PTR [eax+ebx+134], 0
  00084	0f 84 84 00 00
	00		 je	 $LN13@GCItemList

; 2186 : 			{
; 2187 : 				continue;
; 2188 : 			}
; 2189 : 
; 2190 : 			pMsgIL.Pos = n;

  0008a	8b 85 d8 ef ff
	ff		 mov	 eax, DWORD PTR _n$1$[ebp]

; 2191 : 			ItemByteConvert(pMsgIL.ItemInfo,lpObj->pInventory[n]);

  00090	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00096	88 85 ec ef ff
	ff		 mov	 BYTE PTR _pMsgIL$[ebp], al
  0009c	8b fc		 mov	 edi, esp
  0009e	8b b6 c0 11 00
	00		 mov	 esi, DWORD PTR [esi+4544]
  000a4	8d 85 ed ef ff
	ff		 lea	 eax, DWORD PTR _pMsgIL$[ebp+1]
  000aa	03 f3		 add	 esi, ebx
  000ac	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  000b1	f3 a5		 rep movsd
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 2192 : 			memcpy(&sendBuf[sOfs], &pMsgIL, pMsgILSize);

  000b9	8b 8d e0 ef ff
	ff		 mov	 ecx, DWORD PTR _sOfs$1$[ebp]
  000bf	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000c5	f3 0f 7e 85 ec
	ef ff ff	 movq	 xmm0, QWORD PTR _pMsgIL$[ebp]
  000cd	8b 85 f4 ef ff
	ff		 mov	 eax, DWORD PTR _pMsgIL$[ebp+8]

; 2193 : 			itemcount++;

  000d3	8b 95 dc ef ff
	ff		 mov	 edx, DWORD PTR _itemcount$1$[ebp]
  000d9	8b b5 e4 ef ff
	ff		 mov	 esi, DWORD PTR _lpObj$1$[ebp]
  000df	42		 inc	 edx
  000e0	66 0f d6 84 0d
	fc ef ff ff	 movq	 QWORD PTR _sendBuf$[ebp+ecx], xmm0
  000e9	89 84 0d 04 f0
	ff ff		 mov	 DWORD PTR _sendBuf$[ebp+ecx+8], eax
  000f0	8a 85 f8 ef ff
	ff		 mov	 al, BYTE PTR _pMsgIL$[ebp+12]
  000f6	88 84 0d 08 f0
	ff ff		 mov	 BYTE PTR _sendBuf$[ebp+ecx+12], al

; 2194 : 			sOfs += pMsgILSize;

  000fd	83 c1 0d	 add	 ecx, 13			; 0000000dH
  00100	89 95 dc ef ff
	ff		 mov	 DWORD PTR _itemcount$1$[ebp], edx
  00106	89 8d e0 ef ff
	ff		 mov	 DWORD PTR _sOfs$1$[ebp], ecx
  0010c	eb 0c		 jmp	 SHORT $LN2@GCItemList
$LN13@GCItemList:
  0010e	8b 95 dc ef ff
	ff		 mov	 edx, DWORD PTR _itemcount$1$[ebp]
  00114	8b 8d e0 ef ff
	ff		 mov	 ecx, DWORD PTR _sOfs$1$[ebp]
$LN2@GCItemList:

; 2180 : 	
; 2181 : 	for ( int n=0;n<INVENTORY_SIZE;n++)

  0011a	ff 85 d8 ef ff
	ff		 inc	 DWORD PTR _n$1$[ebp]
  00120	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  00126	81 fb 44 c4 00
	00		 cmp	 ebx, 50244		; 0000c444H
  0012c	0f 8c 2e ff ff
	ff		 jl	 $LL4@GCItemList

; 2195 : 		}
; 2196 : 	}
; 2197 : 
; 2198 : 	pMsgILC.h.c = 0xC4;
; 2199 : 	pMsgILC.h.headcode = 0xF3;
; 2200 : 	pMsgILC.subcode = 0x10;
; 2201 : 	pMsgILC.h.sizeH = SET_NUMBERH(sOfs);

  00132	8b c1		 mov	 eax, ecx
  00134	66 c7 85 e7 ef
	ff ff f3 10	 mov	 WORD PTR _pMsgILC$[ebp+3], 4339 ; 000010f3H
  0013d	c1 e8 08	 shr	 eax, 8
  00140	88 85 e5 ef ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+1], al

; 2202 : 	pMsgILC.h.sizeL = SET_NUMBERL(sOfs);

  00146	88 8d e6 ef ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+2], cl
  0014c	c6 85 e4 ef ff
	ff c4		 mov	 BYTE PTR _pMsgILC$[ebp], 196 ; 000000c4H

; 2203 : 	pMsgILC.Count = itemcount;
; 2204 : 	memcpy(sendBuf, &pMsgILC, sizeof(PMSG_INVENTORYLISTCOUNT));

  00153	8b 85 e4 ef ff
	ff		 mov	 eax, DWORD PTR _pMsgILC$[ebp]
  00159	89 85 fc ef ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp], eax
  0015f	88 95 e9 ef ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+5], dl
  00165	66 8b 85 e8 ef
	ff ff		 mov	 ax, WORD PTR _pMsgILC$[ebp+4]
  0016c	66 89 85 00 f0
	ff ff		 mov	 WORD PTR _sendBuf$[ebp+4], ax

; 2205 : 
; 2206 : 	DataSend(aIndex, sendBuf, sOfs);

  00173	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _sendBuf$[ebp]
  00179	51		 push	 ecx
  0017a	50		 push	 eax
  0017b	ff b5 d4 ef ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  00181	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2207 : }

  00186	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00189	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018c	33 cd		 xor	 ecx, ebp
  0018e	5f		 pop	 edi
  0018f	5e		 pop	 esi
  00190	5b		 pop	 ebx
  00191	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00196	8b e5		 mov	 esp, ebp
  00198	5d		 pop	 ebp
  00199	c3		 ret	 0
?GCItemListSend@@YAXH@Z ENDP				; GCItemListSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z
_TEXT	SEGMENT
tv1039 = -156						; size = 4
_aIndex$1$ = -152					; size = 4
_lpMsg$GSCopy$1$ = -148					; size = 4
_NextExp$1$ = -144					; size = 4
_Exp$1$ = -144						; size = 4
_MaxAddPoint$ = -140					; size = 2
_MinusPoint$ = -136					; size = 2
_MaxMinusPoint$ = -132					; size = 2
_AddPoint$ = -128					; size = 2
_pjMsg$ = -124						; size = 96
_szAccountId$ = -28					; size = 11
_szName$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z PROC ; JGGetCharacterInfo, COMDAT

; 1854 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00017	57		 push	 edi
  00018	89 9d 6c ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], ebx

; 1855 : 	PMSG_CHARMAPJOINRESULT pjMsg;
; 1856 : 
; 1857 : 	char szAccountId[MAX_ACCOUNT_LEN+1];
; 1858 : 	char szName[MAX_ACCOUNT_LEN+1];
; 1859 : 	int aIndex = lpMsg->Number;
; 1860 : 
; 1861 : 	szAccountId[MAX_ACCOUNT_LEN] = 0;

  0001e	c6 45 ee 00	 mov	 BYTE PTR _szAccountId$[ebp+10], 0

; 1862 : 	memcpy(szAccountId, lpMsg->AccountID, sizeof(lpMsg->AccountID));

  00022	66 8b 43 10	 mov	 ax, WORD PTR [ebx+16]
  00026	0f bf 7b 06	 movsx	 edi, WORD PTR [ebx+6]
  0002a	f3 0f 7e 43 08	 movq	 xmm0, QWORD PTR [ebx+8]
  0002f	66 89 45 ec	 mov	 WORD PTR _szAccountId$[ebp+8], ax

; 1863 : 
; 1864 : 	if ( gObjIsAccontConnect(aIndex, szAccountId) == FALSE )

  00033	8d 45 e4	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00036	50		 push	 eax
  00037	57		 push	 edi
  00038	89 bd 68 ff ff
	ff		 mov	 DWORD PTR _aIndex$1$[ebp], edi
  0003e	66 0f d6 45 e4	 movq	 QWORD PTR _szAccountId$[ebp], xmm0
  00043	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00048	83 c4 08	 add	 esp, 8
  0004b	85 c0		 test	 eax, eax
  0004d	75 35		 jne	 SHORT $LN8@JGGetChara

; 1865 : 	{
; 1866 : 		LogAddC(2, lMsg.Get(MSGGET(1, 170)), szAccountId);

  0004f	8d 45 e4	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00052	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00057	50		 push	 eax
  00058	68 aa 01 00 00	 push	 426			; 000001aaH
  0005d	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00062	50		 push	 eax
  00063	6a 02		 push	 2
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1867 : 		CloseClient(aIndex);

  0006b	57		 push	 edi
  0006c	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00071	83 c4 10	 add	 esp, 16			; 00000010H
  00074	5f		 pop	 edi
  00075	5b		 pop	 ebx

; 2158 : //	cCustomManager.GMNotice(lpObj);
; 2159 : 	// ----
; 2160 : #if (__CUSTOM_QUEST__ == 1)
; 2161 : 	g_MyQuest.ReqUserInfo(aIndex);
; 2162 : #endif
; 2163 : 
; 2164 : #if (CUSTOM_PETS == 1)
; 2165 : 	gCustomPets.RequestSummonInfo(lpObj->m_Index,lpObj->Name);
; 2166 : #endif
; 2167 : 
; 2168 : }

  00076	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00079	33 cd		 xor	 ecx, ebp
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
$LN8@JGGetChara:

; 1868 : 
; 1869 : 		return;
; 1870 : 	}
; 1871 : 
; 1872 : 	szName[MAX_ACCOUNT_LEN] = 0;
; 1873 : 	memcpy(szName, lpMsg->Name, MAX_ACCOUNT_LEN);
; 1874 : 
; 1875 : 	if ( lpMsg->result == false )

  00084	80 7b 04 00	 cmp	 BYTE PTR [ebx+4], 0
  00088	f3 0f 7e 43 12	 movq	 xmm0, QWORD PTR [ebx+18]
  0008d	66 8b 43 1a	 mov	 ax, WORD PTR [ebx+26]
  00091	c6 45 fa 00	 mov	 BYTE PTR _szName$[ebp+10], 0
  00095	66 0f d6 45 f0	 movq	 QWORD PTR _szName$[ebp], xmm0
  0009a	66 89 45 f8	 mov	 WORD PTR _szName$[ebp+8], ax
  0009e	75 46		 jne	 SHORT $LN9@JGGetChara

; 1876 : 	{
; 1877 : 		LogAddC(2, lMsg.Get(MSGGET(1, 171)), szName, gObj[aIndex].AccountID);

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a5	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  000ab	83 c0 52	 add	 eax, 82			; 00000052H
  000ae	03 c1		 add	 eax, ecx
  000b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000b5	50		 push	 eax
  000b6	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  000b9	50		 push	 eax
  000ba	68 ab 01 00 00	 push	 427			; 000001abH
  000bf	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000c4	50		 push	 eax
$LN50@JGGetChara:
  000c5	6a 02		 push	 2
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1878 : 		CloseClient(aIndex);

  000cd	57		 push	 edi
  000ce	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000d3	83 c4 14	 add	 esp, 20			; 00000014H
  000d6	5f		 pop	 edi
  000d7	5b		 pop	 ebx

; 2158 : //	cCustomManager.GMNotice(lpObj);
; 2159 : 	// ----
; 2160 : #if (__CUSTOM_QUEST__ == 1)
; 2161 : 	g_MyQuest.ReqUserInfo(aIndex);
; 2162 : #endif
; 2163 : 
; 2164 : #if (CUSTOM_PETS == 1)
; 2165 : 	gCustomPets.RequestSummonInfo(lpObj->m_Index,lpObj->Name);
; 2166 : #endif
; 2167 : 
; 2168 : }

  000d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN9@JGGetChara:

; 1879 : 
; 1880 : 		return;
; 1881 : 	}
; 1882 : 
; 1883 : 	if ( (lpMsg->CtlCode&1) != 0 )

  000e6	f6 83 e4 10 00
	00 01		 test	 BYTE PTR [ebx+4324], 1
  000ed	74 1c		 je	 SHORT $LN10@JGGetChara

; 1884 : 	{
; 1885 : 		LogAddC(2, "error-L1 : Load Block Character infomation", szName, gObj[aIndex].AccountID);	// Deathway Fix HERE

  000ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f4	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  000fa	83 c0 52	 add	 eax, 82			; 00000052H
  000fd	03 c1		 add	 eax, ecx
  000ff	50		 push	 eax
  00100	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  00103	50		 push	 eax
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@ECFCLMFK@error?9L1?5?3?5Load?5Block?5Character?5@

; 1886 : 		CloseClient(aIndex);
; 1887 : 
; 1888 : 		return;

  00109	eb ba		 jmp	 SHORT $LN50@JGGetChara
$LN10@JGGetChara:
  0010b	56		 push	 esi

; 1889 : 	}
; 1890 : 
; 1891 : 	for (int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  0010c	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL4@JGGetChara:

; 1892 : 	{
; 1893 : 		if ( gObj[i].Connected == PLAYER_PLAYING )

  00111	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00116	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0011b	75 3c		 jne	 SHORT $LN2@JGGetChara

; 1894 : 		{
; 1895 : 			if ( gObj[i].Type == OBJ_USER )

  0011d	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00122	75 35		 jne	 SHORT $LN2@JGGetChara

; 1896 : 			{
; 1897 : 				if ( !strncmp(szName, gObj[i].Name, MAX_ACCOUNT_LEN) || !strncmp(szAccountId, gObj[i].AccountID, MAX_ACCOUNT_LEN))

  00124	83 c0 5d	 add	 eax, 93			; 0000005dH
  00127	03 c6		 add	 eax, esi
  00129	6a 0a		 push	 10			; 0000000aH
  0012b	50		 push	 eax
  0012c	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 _strncmp
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
  00138	85 c0		 test	 eax, eax
  0013a	74 6f		 je	 SHORT $LN14@JGGetChara
  0013c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00141	83 c0 52	 add	 eax, 82			; 00000052H
  00144	03 c6		 add	 eax, esi
  00146	6a 0a		 push	 10			; 0000000aH
  00148	50		 push	 eax
  00149	8d 45 e4	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _strncmp
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
  00155	85 c0		 test	 eax, eax
  00157	74 52		 je	 SHORT $LN14@JGGetChara
$LN2@JGGetChara:

; 1889 : 	}
; 1890 : 
; 1891 : 	for (int i=OBJ_STARTUSERINDEX;i<OBJMAX;i++)

  00159	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  0015f	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00165	7c aa		 jl	 SHORT $LL4@JGGetChara

; 1902 : 					return;
; 1903 : 				}
; 1904 : 			}
; 1905 : 		}
; 1906 : 	}
; 1907 : 
; 1908 : 
; 1909 : 
; 1910 : 	if ( gObjSetCharacter( (UCHAR*)lpMsg, aIndex) == FALSE )

  00167	57		 push	 edi
  00168	53		 push	 ebx
  00169	e8 00 00 00 00	 call	 ?gObjSetCharacter@@YAHPAEH@Z ; gObjSetCharacter
  0016e	83 c4 08	 add	 esp, 8
  00171	85 c0		 test	 eax, eax
  00173	75 70		 jne	 SHORT $LN15@JGGetChara

; 1911 : 	{
; 1912 : 		LogAddC(2, lMsg.Get(MSGGET(1, 172)), szName);

  00175	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  00178	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0017d	50		 push	 eax
  0017e	68 ac 01 00 00	 push	 428			; 000001acH
  00183	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00188	50		 push	 eax
  00189	6a 02		 push	 2
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1913 : 		CloseClient(aIndex);

  00191	57		 push	 edi
  00192	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00197	83 c4 10	 add	 esp, 16			; 00000010H
  0019a	5e		 pop	 esi
  0019b	5f		 pop	 edi
  0019c	5b		 pop	 ebx

; 2158 : //	cCustomManager.GMNotice(lpObj);
; 2159 : 	// ----
; 2160 : #if (__CUSTOM_QUEST__ == 1)
; 2161 : 	g_MyQuest.ReqUserInfo(aIndex);
; 2162 : #endif
; 2163 : 
; 2164 : #if (CUSTOM_PETS == 1)
; 2165 : 	gCustomPets.RequestSummonInfo(lpObj->m_Index,lpObj->Name);
; 2166 : #endif
; 2167 : 
; 2168 : }

  0019d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a0	33 cd		 xor	 ecx, ebp
  001a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a7	8b e5		 mov	 esp, ebp
  001a9	5d		 pop	 ebp
  001aa	c3		 ret	 0
$LN14@JGGetChara:

; 1898 : 				{
; 1899 : 					LogAddTD("[Anti-HACK][JGGetCharacterInfo] Attempted Character-Copy by double logging [%s][%s]",

  001ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b0	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  001b6	83 c0 52	 add	 eax, 82			; 00000052H
  001b9	03 c1		 add	 eax, ecx
  001bb	50		 push	 eax
  001bc	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  001bf	50		 push	 eax
  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@JOJGEKKO@?$FLAnti?9HACK?$FN?$FLJGGetCharacterInfo?$FN?5@
  001c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1900 : 						szName, gObj[aIndex].AccountID);
; 1901 : 					CloseClient(aIndex);

  001cb	57		 push	 edi
  001cc	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  001d1	83 c4 10	 add	 esp, 16			; 00000010H
  001d4	5e		 pop	 esi
  001d5	5f		 pop	 edi
  001d6	5b		 pop	 ebx

; 2158 : //	cCustomManager.GMNotice(lpObj);
; 2159 : 	// ----
; 2160 : #if (__CUSTOM_QUEST__ == 1)
; 2161 : 	g_MyQuest.ReqUserInfo(aIndex);
; 2162 : #endif
; 2163 : 
; 2164 : #if (CUSTOM_PETS == 1)
; 2165 : 	gCustomPets.RequestSummonInfo(lpObj->m_Index,lpObj->Name);
; 2166 : #endif
; 2167 : 
; 2168 : }

  001d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001da	33 cd		 xor	 ecx, ebp
  001dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e1	8b e5		 mov	 esp, ebp
  001e3	5d		 pop	 ebp
  001e4	c3		 ret	 0
$LN15@JGGetChara:

; 1914 : 		return;
; 1915 : 	}
; 1916 : 
; 1917 : 	gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  001e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001eb	69 d7 40 27 00
	00		 imul	 edx, edi, 10048
  001f1	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv1039[ebp], edx
  001f7	8b 84 0a 34 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx+308]
  001fe	03 84 0a 30 01
	00 00		 add	 eax, DWORD PTR [edx+ecx+304]
  00205	89 84 0a 2c 01
	00 00		 mov	 DWORD PTR [edx+ecx+300], eax

; 1918 : 
; 1919 : 	LPOBJ lpObj = &gObj[aIndex];

  0020c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00212	03 da		 add	 ebx, edx

; 1920 : 
; 1921 : 	if ( gObj[aIndex].m_Index != aIndex )

  00214	39 3b		 cmp	 DWORD PTR [ebx], edi
  00216	74 3c		 je	 SHORT $LN16@JGGetChara

; 1922 : 	{
; 1923 : 		LogAddC(2, lMsg.Get(MSGGET(1, 173)), __FILE__, __LINE__);

  00218	68 83 07 00 00	 push	 1923			; 00000783H
  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DNGOKBGI@DSProtocol?4cpp?$AA@
  00222	68 ad 01 00 00	 push	 429			; 000001adH
  00227	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0022c	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00231	50		 push	 eax
  00232	6a 02		 push	 2
  00234	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1924 : 		CloseClient(aIndex);

  0023a	57		 push	 edi
  0023b	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00240	83 c4 14	 add	 esp, 20			; 00000014H
  00243	5e		 pop	 esi
  00244	5f		 pop	 edi
  00245	5b		 pop	 ebx

; 2158 : //	cCustomManager.GMNotice(lpObj);
; 2159 : 	// ----
; 2160 : #if (__CUSTOM_QUEST__ == 1)
; 2161 : 	g_MyQuest.ReqUserInfo(aIndex);
; 2162 : #endif
; 2163 : 
; 2164 : #if (CUSTOM_PETS == 1)
; 2165 : 	gCustomPets.RequestSummonInfo(lpObj->m_Index,lpObj->Name);
; 2166 : #endif
; 2167 : 
; 2168 : }

  00246	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00249	33 cd		 xor	 ecx, ebp
  0024b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00250	8b e5		 mov	 esp, ebp
  00252	5d		 pop	 ebp
  00253	c3		 ret	 0
$LN16@JGGetChara:

; 1925 : 
; 1926 : 		return;
; 1927 : 	}
; 1928 : 
; 1929 : 	if ( lpObj->Money < 0 )

  00254	8b 83 cc 00 00
	00		 mov	 eax, DWORD PTR [ebx+204]
  0025a	85 c0		 test	 eax, eax
  0025c	79 23		 jns	 SHORT $LN17@JGGetChara

; 1930 : 	{
; 1931 : 		LogAddC(2, "[ ZEN MODIFY ] [%s][%s] %d -> 0", szName, gObj[aIndex].AccountID, lpObj->Money);

  0025e	50		 push	 eax
  0025f	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00262	50		 push	 eax
  00263	8d 45 f0	 lea	 eax, DWORD PTR _szName$[ebp]
  00266	50		 push	 eax
  00267	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@ICFKKJJD@?$FL?5ZEN?5MODIFY?5?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFd?5?9?$DO?50?$AA@
  0026c	6a 02		 push	 2
  0026e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00274	83 c4 14	 add	 esp, 20			; 00000014H

; 1932 : 		lpObj->Money = 0;

  00277	c7 83 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+204], 0
$LN17@JGGetChara:

; 1933 : 	}
; 1934 : 
; 1935 : 	if ( lpObj->m_bMapSvrMoveReq == false )

  00281	80 bb 3d 20 00
	00 00		 cmp	 BYTE PTR [ebx+8253], 0
  00288	0f 85 f3 00 00
	00		 jne	 $LN20@JGGetChara

; 1936 : 	{
; 1937 : 		if ( MapNumberCheck(lpObj->MapNumber) == FALSE )

  0028e	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  00295	50		 push	 eax
  00296	e8 00 00 00 00	 call	 ?MapNumberCheck@@YAHH@Z	; MapNumberCheck
  0029b	83 c4 04	 add	 esp, 4
  0029e	85 c0		 test	 eax, eax
  002a0	75 2f		 jne	 SHORT $LN19@JGGetChara

; 1938 : 		{
; 1939 : 			LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  002a2	68 93 07 00 00	 push	 1939			; 00000793H
  002a7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DNGOKBGI@DSProtocol?4cpp?$AA@
  002ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  002b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1940 : 			CloseClient(aIndex);

  002b7	57		 push	 edi
  002b8	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  002bd	83 c4 10	 add	 esp, 16			; 00000010H
  002c0	5e		 pop	 esi
  002c1	5f		 pop	 edi
  002c2	5b		 pop	 ebx

; 2158 : //	cCustomManager.GMNotice(lpObj);
; 2159 : 	// ----
; 2160 : #if (__CUSTOM_QUEST__ == 1)
; 2161 : 	g_MyQuest.ReqUserInfo(aIndex);
; 2162 : #endif
; 2163 : 
; 2164 : #if (CUSTOM_PETS == 1)
; 2165 : 	gCustomPets.RequestSummonInfo(lpObj->m_Index,lpObj->Name);
; 2166 : #endif
; 2167 : 
; 2168 : }

  002c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c6	33 cd		 xor	 ecx, ebp
  002c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cd	8b e5		 mov	 esp, ebp
  002cf	5d		 pop	 ebp
  002d0	c3		 ret	 0
$LN19@JGGetChara:

; 1941 : 
; 1942 : 			return;
; 1943 : 		}
; 1944 : 
; 1945 : 		short wGameServerCode = g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index, lpObj->MapNumber, lpObj->m_sPrevMapSvrCode);

  002d1	0f b7 83 44 20
	00 00		 movzx	 eax, WORD PTR [ebx+8260]
  002d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  002dd	50		 push	 eax
  002de	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  002e5	50		 push	 eax
  002e6	ff 33		 push	 DWORD PTR [ebx]
  002e8	e8 00 00 00 00	 call	 ?CheckMoveMapSvr@CMapServerManager@@QAEFHHF@Z ; CMapServerManager::CheckMoveMapSvr
  002ed	0f b7 f0	 movzx	 esi, ax

; 1946 : 
; 1947 : 		if ( wGameServerCode != gGameServerCode )

  002f0	66 3b 35 00 00
	00 00		 cmp	 si, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  002f7	0f 84 84 00 00
	00		 je	 $LN20@JGGetChara

; 1948 : 		{
; 1949 : 			if ( wGameServerCode == -1 )

  002fd	66 83 fe ff	 cmp	 si, -1
  00301	75 31		 jne	 SHORT $LN21@JGGetChara

; 1950 : 			{
; 1951 : 				LogAddC(2,"[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)",

  00303	ff 33		 push	 DWORD PTR [ebx]
  00305	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00308	50		 push	 eax
  00309	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  0030c	50		 push	 eax
  0030d	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@ICCPKMCE@?$FLMapServerMng?$FN?5Map?5Server?5Move?5F@
  00312	6a 02		 push	 2
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1952 : 					lpObj->AccountID, lpObj->Name, lpObj->m_Index);
; 1953 : 				CloseClient(aIndex);

  0031a	57		 push	 edi
  0031b	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00320	83 c4 18	 add	 esp, 24			; 00000018H
  00323	5e		 pop	 esi
  00324	5f		 pop	 edi
  00325	5b		 pop	 ebx

; 2158 : //	cCustomManager.GMNotice(lpObj);
; 2159 : 	// ----
; 2160 : #if (__CUSTOM_QUEST__ == 1)
; 2161 : 	g_MyQuest.ReqUserInfo(aIndex);
; 2162 : #endif
; 2163 : 
; 2164 : #if (CUSTOM_PETS == 1)
; 2165 : 	gCustomPets.RequestSummonInfo(lpObj->m_Index,lpObj->Name);
; 2166 : #endif
; 2167 : 
; 2168 : }

  00326	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00329	33 cd		 xor	 ecx, ebp
  0032b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00330	8b e5		 mov	 esp, ebp
  00332	5d		 pop	 ebp
  00333	c3		 ret	 0
$LN21@JGGetChara:

; 1954 : 
; 1955 : 				return;
; 1956 : 			}
; 1957 : 
; 1958 : 			GJReqMapSvrMove(lpObj->m_Index, wGameServerCode, lpObj->MapNumber, lpObj->X, lpObj->Y);

  00334	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  0033b	50		 push	 eax
  0033c	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00343	50		 push	 eax
  00344	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  0034b	50		 push	 eax
  0034c	56		 push	 esi
  0034d	ff 33		 push	 DWORD PTR [ebx]
  0034f	e8 00 00 00 00	 call	 ?GJReqMapSvrMove@@YAXHGGEE@Z ; GJReqMapSvrMove

; 1959 : 			LogAddTD("[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)",

  00354	ff 33		 push	 DWORD PTR [ebx]
  00356	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00359	50		 push	 eax
  0035a	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  0035d	50		 push	 eax
  0035e	0f bf c6	 movsx	 eax, si
  00361	50		 push	 eax
  00362	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KJANBCDD@?$FLMapServerMng?$FN?5Request?5to?5Move?5M@
  00367	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0036d	83 c4 28	 add	 esp, 40			; 00000028H
  00370	5e		 pop	 esi
  00371	5f		 pop	 edi
  00372	5b		 pop	 ebx

; 2158 : //	cCustomManager.GMNotice(lpObj);
; 2159 : 	// ----
; 2160 : #if (__CUSTOM_QUEST__ == 1)
; 2161 : 	g_MyQuest.ReqUserInfo(aIndex);
; 2162 : #endif
; 2163 : 
; 2164 : #if (CUSTOM_PETS == 1)
; 2165 : 	gCustomPets.RequestSummonInfo(lpObj->m_Index,lpObj->Name);
; 2166 : #endif
; 2167 : 
; 2168 : }

  00373	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00376	33 cd		 xor	 ecx, ebp
  00378	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037d	8b e5		 mov	 esp, ebp
  0037f	5d		 pop	 ebp
  00380	c3		 ret	 0
$LN20@JGGetChara:

; 1960 : 				wGameServerCode, lpObj->AccountID, lpObj->Name, lpObj->m_Index);
; 1961 : 
; 1962 : 			return;
; 1963 : 		}
; 1964 : 	}
; 1965 : 
; 1966 : 	lpObj->m_bMapSvrMoveReq = false;

  00381	c6 83 3d 20 00
	00 00		 mov	 BYTE PTR [ebx+8253], 0

; 1967 : 
; 1968 : 
; 1969 : 	pjMsg.h.c = 0xC3;
; 1970 : 	pjMsg.h.headcode = 0xF3;
; 1971 : 	pjMsg.h.size = sizeof(PMSG_CHARMAPJOINRESULT);
; 1972 : 	pjMsg.subcode = 0x03;
; 1973 : 	pjMsg.MapX = lpObj->X;
; 1974 : 	pjMsg.MapY = lpObj->Y;
; 1975 : 	pjMsg.MapNumber = lpObj->MapNumber;
; 1976 : 	pjMsg.Dir = lpObj->Dir;
; 1977 : 
; 1978 : 	__int64 Exp = lpObj->Experience;
; 1979 : 
; 1980 : 	if( g_MasterExp.IsEnabled(lpObj) )

  00388	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterExp@@3VCMasterExperience@@A ; g_MasterExp
  0038d	c7 45 84 c3 60
	f3 03		 mov	 DWORD PTR _pjMsg$[ebp], 66281667 ; 03f360c3H
  00394	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  0039b	88 45 88	 mov	 BYTE PTR _pjMsg$[ebp+4], al
  0039e	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  003a5	88 45 89	 mov	 BYTE PTR _pjMsg$[ebp+5], al
  003a8	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  003af	88 45 8a	 mov	 BYTE PTR _pjMsg$[ebp+6], al
  003b2	0f b6 83 22 01
	00 00		 movzx	 eax, BYTE PTR [ebx+290]
  003b9	88 45 8b	 mov	 BYTE PTR _pjMsg$[ebp+7], al
  003bc	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
  003c2	53		 push	 ebx
  003c3	89 85 70 ff ff
	ff		 mov	 DWORD PTR _Exp$1$[ebp], eax
  003c9	e8 00 00 00 00	 call	 ?IsEnabled@CMasterExperience@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterExperience::IsEnabled
  003ce	85 c0		 test	 eax, eax
  003d0	74 0e		 je	 SHORT $LN47@JGGetChara

; 1981 : 	{
; 1982 : 		Exp = lpObj->MasterExperience;

  003d2	8b 93 b0 00 00
	00		 mov	 edx, DWORD PTR [ebx+176]
  003d8	8b 8b b4 00 00
	00		 mov	 ecx, DWORD PTR [ebx+180]
  003de	eb 08		 jmp	 SHORT $LN22@JGGetChara
$LN47@JGGetChara:
  003e0	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _Exp$1$[ebp]
  003e6	33 c9		 xor	 ecx, ecx
$LN22@JGGetChara:

; 1983 : 	}
; 1984 : 	
; 1985 : 	pjMsg.Exp[0] = DWORD((DWORD(Exp >> 32) >> 16) & 0xFFFF) >> 8;

  003e8	8b c1		 mov	 eax, ecx

; 1986 : 	pjMsg.Exp[1] = DWORD((DWORD(Exp >> 32) >> 16) & 0xFFFF) & 0xFF;
; 1987 : 	pjMsg.Exp[2] = DWORD((DWORD(Exp >> 32) & 0xFFFF) & 0xFFFF) >> 8;
; 1988 : 	pjMsg.Exp[3] = DWORD((DWORD(Exp >> 32) & 0xFFFF) & 0xFFFF) & 0xFF;

  003ea	88 4d 8f	 mov	 BYTE PTR _pjMsg$[ebp+11], cl
  003ed	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  003f0	8b c1		 mov	 eax, ecx

; 1989 : 
; 1990 : 	pjMsg.Exp[4] = DWORD((DWORD(Exp & 0xFFFFFFFF) >> 16) & 0xFFFF) >> 8;
; 1991 : 	pjMsg.Exp[5] = DWORD((DWORD(Exp & 0xFFFFFFFF) >> 16) & 0xFFFF) & 0xFF;
; 1992 : 	pjMsg.Exp[6] = DWORD((DWORD(Exp & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) >> 8;
; 1993 : 	pjMsg.Exp[7] = DWORD((DWORD(Exp & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) & 0xFF;

  003f2	88 55 93	 mov	 BYTE PTR _pjMsg$[ebp+15], dl
  003f5	c1 e8 18	 shr	 eax, 24			; 00000018H
  003f8	88 45 8c	 mov	 BYTE PTR _pjMsg$[ebp+8], al
  003fb	8b c1		 mov	 eax, ecx
  003fd	c1 e8 10	 shr	 eax, 16			; 00000010H
  00400	88 45 8d	 mov	 BYTE PTR _pjMsg$[ebp+9], al
  00403	8b c1		 mov	 eax, ecx
  00405	c1 e8 08	 shr	 eax, 8

; 1994 : 
; 1995 : 	__int64 NextExp = lpObj->NextExp;
; 1996 : 
; 1997 : 	if( g_MasterExp.IsEnabled(lpObj) )

  00408	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterExp@@3VCMasterExperience@@A ; g_MasterExp
  0040d	88 45 8e	 mov	 BYTE PTR _pjMsg$[ebp+10], al
  00410	8b c2		 mov	 eax, edx
  00412	c1 e8 18	 shr	 eax, 24			; 00000018H
  00415	88 45 90	 mov	 BYTE PTR _pjMsg$[ebp+12], al
  00418	8b c2		 mov	 eax, edx
  0041a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0041d	88 45 91	 mov	 BYTE PTR _pjMsg$[ebp+13], al
  00420	8b c2		 mov	 eax, edx
  00422	c1 e8 08	 shr	 eax, 8
  00425	88 45 92	 mov	 BYTE PTR _pjMsg$[ebp+14], al
  00428	8b 83 a4 00 00
	00		 mov	 eax, DWORD PTR [ebx+164]
  0042e	53		 push	 ebx
  0042f	89 85 70 ff ff
	ff		 mov	 DWORD PTR _NextExp$1$[ebp], eax
  00435	e8 00 00 00 00	 call	 ?IsEnabled@CMasterExperience@@QAEHPAUOBJECTSTRUCT@@@Z ; CMasterExperience::IsEnabled
  0043a	85 c0		 test	 eax, eax
  0043c	74 0e		 je	 SHORT $LN48@JGGetChara

; 1998 : 	{
; 1999 : 		NextExp = lpObj->MasterNextExp;

  0043e	8b 93 b8 00 00
	00		 mov	 edx, DWORD PTR [ebx+184]
  00444	8b 8b bc 00 00
	00		 mov	 ecx, DWORD PTR [ebx+188]
  0044a	eb 08		 jmp	 SHORT $LN23@JGGetChara
$LN48@JGGetChara:
  0044c	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR _NextExp$1$[ebp]
  00452	33 c9		 xor	 ecx, ecx
$LN23@JGGetChara:

; 2000 : 	}
; 2001 : 
; 2002 : 	pjMsg.NextExp[0] = DWORD((DWORD(NextExp >> 32) >> 16) & 0xFFFF) >> 8;

  00454	8b c1		 mov	 eax, ecx

; 2003 : 	pjMsg.NextExp[1] = DWORD((DWORD(NextExp >> 32) >> 16) & 0xFFFF) & 0xFF;
; 2004 : 	pjMsg.NextExp[2] = DWORD((DWORD(NextExp >> 32) & 0xFFFF) & 0xFFFF) >> 8;
; 2005 : 	pjMsg.NextExp[3] = DWORD((DWORD(NextExp >> 32) & 0xFFFF) & 0xFFFF) & 0xFF;

  00456	88 4d 97	 mov	 BYTE PTR _pjMsg$[ebp+19], cl
  00459	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  0045c	8b c1		 mov	 eax, ecx

; 2006 : 
; 2007 : 	pjMsg.NextExp[4] = DWORD((DWORD(NextExp & 0xFFFFFFFF) >> 16) & 0xFFFF) >> 8;
; 2008 : 	pjMsg.NextExp[5] = DWORD((DWORD(NextExp & 0xFFFFFFFF) >> 16) & 0xFFFF) & 0xFF;
; 2009 : 	pjMsg.NextExp[6] = DWORD((DWORD(NextExp & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) >> 8;
; 2010 : 	pjMsg.NextExp[7] = DWORD((DWORD(NextExp & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) & 0xFF;

  0045e	88 55 9b	 mov	 BYTE PTR _pjMsg$[ebp+23], dl
  00461	c1 e8 18	 shr	 eax, 24			; 00000018H
  00464	88 45 94	 mov	 BYTE PTR _pjMsg$[ebp+16], al
  00467	8b c1		 mov	 eax, ecx
  00469	c1 e8 10	 shr	 eax, 16			; 00000010H
  0046c	88 45 95	 mov	 BYTE PTR _pjMsg$[ebp+17], al
  0046f	8b c1		 mov	 eax, ecx
  00471	c1 e8 08	 shr	 eax, 8
  00474	88 45 96	 mov	 BYTE PTR _pjMsg$[ebp+18], al
  00477	8b c2		 mov	 eax, edx
  00479	c1 e8 18	 shr	 eax, 24			; 00000018H
  0047c	88 45 98	 mov	 BYTE PTR _pjMsg$[ebp+20], al
  0047f	8b c2		 mov	 eax, edx
  00481	c1 e8 10	 shr	 eax, 16			; 00000010H
  00484	88 45 99	 mov	 BYTE PTR _pjMsg$[ebp+21], al
  00487	8b c2		 mov	 eax, edx
  00489	c1 e8 08	 shr	 eax, 8
  0048c	88 45 9a	 mov	 BYTE PTR _pjMsg$[ebp+22], al

; 2011 : 
; 2012 : 	pjMsg.LevelUpPoint = lpObj->LevelUpPoint;

  0048f	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  00496	66 89 45 9c	 mov	 WORD PTR _pjMsg$[ebp+24], ax

; 2013 : 	pjMsg.Str = lpObj->Strength;

  0049a	0f b7 83 d0 00
	00 00		 movzx	 eax, WORD PTR [ebx+208]
  004a1	66 89 45 9e	 mov	 WORD PTR _pjMsg$[ebp+26], ax

; 2014 : 	pjMsg.Dex = lpObj->Dexterity;

  004a5	0f b7 83 d2 00
	00 00		 movzx	 eax, WORD PTR [ebx+210]
  004ac	66 89 45 a0	 mov	 WORD PTR _pjMsg$[ebp+28], ax

; 2015 : 	pjMsg.Vit = lpObj->Vitality;

  004b0	0f b7 83 d4 00
	00 00		 movzx	 eax, WORD PTR [ebx+212]
  004b7	66 89 45 a2	 mov	 WORD PTR _pjMsg$[ebp+30], ax

; 2016 : 	pjMsg.Energy = lpObj->Energy;

  004bb	0f b7 83 d6 00
	00 00		 movzx	 eax, WORD PTR [ebx+214]
  004c2	66 89 45 a4	 mov	 WORD PTR _pjMsg$[ebp+32], ax

; 2017 : 	pjMsg.Money = lpObj->Money;

  004c6	8b 83 cc 00 00
	00		 mov	 eax, DWORD PTR [ebx+204]
  004cc	89 45 b8	 mov	 DWORD PTR _pjMsg$[ebp+52], eax

; 2018 : 	pjMsg.PkLevel = lpObj->m_PK_Level;

  004cf	0f b6 83 19 01
	00 00		 movzx	 eax, BYTE PTR [ebx+281]
  004d6	88 45 bc	 mov	 BYTE PTR _pjMsg$[ebp+56], al

; 2019 : 	pjMsg.Life = (WORD)lpObj->Life;

  004d9	f3 0f 2c 83 d8
	00 00 00	 cvttss2si eax, DWORD PTR [ebx+216]
  004e1	66 89 45 a6	 mov	 WORD PTR _pjMsg$[ebp+34], ax
  004e5	66 0f 6e 83 24
	01 00 00	 movd	 xmm0, DWORD PTR [ebx+292]

; 2020 : 	pjMsg.MaxLife = (WORD)(lpObj->AddLife + lpObj->MaxLife);

  004ed	0f 5b c0	 cvtdq2ps xmm0, xmm0
  004f0	f3 0f 58 83 dc
	00 00 00	 addss	 xmm0, DWORD PTR [ebx+220]
  004f8	f3 0f 2c c0	 cvttss2si eax, xmm0
  004fc	66 89 45 a8	 mov	 WORD PTR _pjMsg$[ebp+36], ax

; 2021 : 	pjMsg.Mana = (WORD)lpObj->Mana;

  00500	f3 0f 2c 83 ec
	00 00 00	 cvttss2si eax, DWORD PTR [ebx+236]
  00508	66 89 45 aa	 mov	 WORD PTR _pjMsg$[ebp+38], ax
  0050c	66 0f 6e 83 28
	01 00 00	 movd	 xmm0, DWORD PTR [ebx+296]

; 2022 : 	pjMsg.MaxMana = (WORD)(lpObj->AddMana + lpObj->MaxMana);

  00514	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00517	f3 0f 58 83 f0
	00 00 00	 addss	 xmm0, DWORD PTR [ebx+240]
  0051f	f3 0f 2c c0	 cvttss2si eax, xmm0
  00523	66 89 45 ac	 mov	 WORD PTR _pjMsg$[ebp+40], ax

; 2023 : 	pjMsg.wShield = lpObj->iShield;

  00527	0f b7 83 2c 01
	00 00		 movzx	 eax, WORD PTR [ebx+300]
  0052e	66 89 45 ae	 mov	 WORD PTR _pjMsg$[ebp+42], ax

; 2024 : 	pjMsg.wMaxShield = lpObj->iMaxShield + lpObj->iAddShield;

  00532	0f b7 83 30 01
	00 00		 movzx	 eax, WORD PTR [ebx+304]
  00539	66 03 83 34 01
	00 00		 add	 ax, WORD PTR [ebx+308]
  00540	66 89 45 b0	 mov	 WORD PTR _pjMsg$[ebp+44], ax

; 2025 : 	pjMsg.CtlCode = lpMsg->CtlCode;

  00544	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  0054a	0f b6 80 e4 10
	00 00		 movzx	 eax, BYTE PTR [eax+4324]
  00551	88 45 bd	 mov	 BYTE PTR _pjMsg$[ebp+57], al

; 2026 : 	pjMsg.BP = lpObj->BP;

  00554	0f b7 83 04 01
	00 00		 movzx	 eax, WORD PTR [ebx+260]
  0055b	66 89 45 b2	 mov	 WORD PTR _pjMsg$[ebp+46], ax

; 2027 : 	pjMsg.MaxBP = lpObj->MaxBP + lpObj->AddBP;

  0055f	0f b7 83 0c 01
	00 00		 movzx	 eax, WORD PTR [ebx+268]
  00566	66 03 83 08 01
	00 00		 add	 ax, WORD PTR [ebx+264]
  0056d	66 89 45 b4	 mov	 WORD PTR _pjMsg$[ebp+48], ax

; 2028 : 	pjMsg.Leadership = lpObj->Leadership;

  00571	0f b7 83 f4 00
	00 00		 movzx	 eax, WORD PTR [ebx+244]
  00578	66 89 45 c2	 mov	 WORD PTR _pjMsg$[ebp+62], ax

; 2029 : 
; 2030 : #if (FIX_HP==1)
; 2031 : 	pjMsg.HP = (int)lpObj->Life;

  0057c	f3 0f 2c 83 d8
	00 00 00	 cvttss2si eax, DWORD PTR [ebx+216]
  00584	89 45 cc	 mov	 DWORD PTR _pjMsg$[ebp+72], eax
  00587	66 0f 6e 83 24
	01 00 00	 movd	 xmm0, DWORD PTR [ebx+292]

; 2032 : 	pjMsg.MAXHP = (int)(lpObj->MaxLife+lpObj->AddLife);

  0058f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00592	f3 0f 58 83 dc
	00 00 00	 addss	 xmm0, DWORD PTR [ebx+220]
  0059a	f3 0f 2c c0	 cvttss2si eax, xmm0
  0059e	89 45 d0	 mov	 DWORD PTR _pjMsg$[ebp+76], eax

; 2033 : 
; 2034 : 	pjMsg.MP = (int)lpObj->Mana;

  005a1	f3 0f 2c 83 ec
	00 00 00	 cvttss2si eax, DWORD PTR [ebx+236]
  005a9	89 45 d4	 mov	 DWORD PTR _pjMsg$[ebp+80], eax
  005ac	66 0f 6e 83 28
	01 00 00	 movd	 xmm0, DWORD PTR [ebx+296]

; 2035 : 	pjMsg.MAXMP = (int)(lpObj->MaxMana+lpObj->AddMana);

  005b4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  005b7	f3 0f 58 83 f0
	00 00 00	 addss	 xmm0, DWORD PTR [ebx+240]
  005bf	f3 0f 2c c0	 cvttss2si eax, xmm0
  005c3	89 45 d8	 mov	 DWORD PTR _pjMsg$[ebp+84], eax

; 2036 : 	
; 2037 : 	pjMsg.SD = lpObj->iShield;

  005c6	8b 83 2c 01 00
	00		 mov	 eax, DWORD PTR [ebx+300]
  005cc	89 45 dc	 mov	 DWORD PTR _pjMsg$[ebp+88], eax

; 2038 : 	pjMsg.MAXSD = lpObj->iMaxShield+lpObj->iAddShield;

  005cf	8b 83 30 01 00
	00		 mov	 eax, DWORD PTR [ebx+304]
  005d5	03 83 34 01 00
	00		 add	 eax, DWORD PTR [ebx+308]
  005db	89 45 e0	 mov	 DWORD PTR _pjMsg$[ebp+92], eax

; 2039 : #endif
; 2040 : 
; 2041 : 	short AddPoint = 0;
; 2042 : 	short MaxAddPoint = 0;
; 2043 : 	short MinusPoint = 0;
; 2044 : 	short MaxMinusPoint = 0;
; 2045 : 	
; 2046 : 	gObjGetStatPointState(lpObj->m_Index, AddPoint, MaxAddPoint, MinusPoint, MaxMinusPoint);

  005de	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _MaxMinusPoint$[ebp]
  005e4	50		 push	 eax
  005e5	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _MinusPoint$[ebp]
  005eb	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _AddPoint$[ebp], 0
  005f2	50		 push	 eax
  005f3	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _MaxAddPoint$[ebp]
  005f9	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _MaxAddPoint$[ebp], 0
  00603	50		 push	 eax
  00604	8d 45 80	 lea	 eax, DWORD PTR _AddPoint$[ebp]
  00607	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _MinusPoint$[ebp], 0
  00611	50		 push	 eax
  00612	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _MaxMinusPoint$[ebp], 0
  0061c	ff 33		 push	 DWORD PTR [ebx]
  0061e	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF000@Z ; gObjGetStatPointState

; 2047 : 	pjMsg.AddPoint = AddPoint;

  00623	8b 7d 80	 mov	 edi, DWORD PTR _AddPoint$[ebp]

; 2048 : 	pjMsg.MaxAddPoint = MaxAddPoint;

  00626	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _MaxAddPoint$[ebp]

; 2049 : 	pjMsg.wMinusPoint = MinusPoint;

  0062c	8b b5 78 ff ff
	ff		 mov	 esi, DWORD PTR _MinusPoint$[ebp]

; 2050 : 	pjMsg.wMaxMinusPoint = MaxMinusPoint;

  00632	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _MaxMinusPoint$[ebp]
  00638	66 89 7d be	 mov	 WORD PTR _pjMsg$[ebp+58], di
  0063c	66 89 55 c0	 mov	 WORD PTR _pjMsg$[ebp+60], dx
  00640	66 89 75 c4	 mov	 WORD PTR _pjMsg$[ebp+64], si
  00644	66 89 4d c6	 mov	 WORD PTR _pjMsg$[ebp+66], cx

; 2051 : 	pjMsg.btInventoryExpansion = lpObj->pInventoryExtend;

  00648	0f b6 83 cd 11
	00 00		 movzx	 eax, BYTE PTR [ebx+4557]
  0064f	88 45 c8	 mov	 BYTE PTR _pjMsg$[ebp+68], al

; 2052 : 
; 2053 : 	LogAddTD("[FRUIT System] [%s][%s] (MinusPoint:%d/PlusPoint:%d) (MaxMinus:%d/MaxPlus:%d)",

  00652	0f bf c2	 movsx	 eax, dx
  00655	50		 push	 eax
  00656	0f bf c1	 movsx	 eax, cx
  00659	50		 push	 eax
  0065a	0f bf c7	 movsx	 eax, di
  0065d	8d 7b 5d	 lea	 edi, DWORD PTR [ebx+93]
  00660	50		 push	 eax
  00661	0f bf c6	 movsx	 eax, si
  00664	50		 push	 eax
  00665	57		 push	 edi
  00666	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00669	50		 push	 eax
  0066a	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@MMCPKNFL@?$FLFRUIT?5System?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIMinusPo@
  0066f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2054 : 		lpObj->AccountID, lpObj->Name, MinusPoint, AddPoint, MaxMinusPoint, MaxAddPoint);
; 2055 : 
; 2056 : 	if ( AddPoint < 0 || AddPoint > MaxAddPoint || MinusPoint < 0 || MinusPoint > MaxMinusPoint )

  00675	8b 55 80	 mov	 edx, DWORD PTR _AddPoint$[ebp]
  00678	83 c4 30	 add	 esp, 48			; 00000030H
  0067b	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR _MaxMinusPoint$[ebp]
  00681	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _MinusPoint$[ebp]
  00687	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _MaxAddPoint$[ebp]
  0068d	66 85 d2	 test	 dx, dx
  00690	78 0f		 js	 SHORT $LN25@JGGetChara
  00692	66 3b d0	 cmp	 dx, ax
  00695	7f 0a		 jg	 SHORT $LN25@JGGetChara
  00697	66 85 c9	 test	 cx, cx
  0069a	78 05		 js	 SHORT $LN25@JGGetChara
  0069c	66 3b ce	 cmp	 cx, si
  0069f	7e 21		 jle	 SHORT $LN24@JGGetChara
$LN25@JGGetChara:

; 2057 : 	{
; 2058 : 		LogAddTD("[FRUIT System] Character Stat Error [%s][%s] (MinusPoint:%d/PlusPoint:%d) (MaxMinus:%d/MaxPlus:%d)",

  006a1	98		 cwde
  006a2	50		 push	 eax
  006a3	0f bf c6	 movsx	 eax, si
  006a6	50		 push	 eax
  006a7	0f bf c2	 movsx	 eax, dx
  006aa	50		 push	 eax
  006ab	0f bf c1	 movsx	 eax, cx
  006ae	50		 push	 eax
  006af	57		 push	 edi
  006b0	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  006b3	50		 push	 eax
  006b4	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@LBDNOPPJ@?$FLFRUIT?5System?$FN?5Character?5Stat?5Er@
  006b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006bf	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN24@JGGetChara:

; 2059 : 			lpObj->AccountID, lpObj->Name, MinusPoint, AddPoint, MaxMinusPoint, MaxAddPoint);
; 2060 : 	}
; 2061 : 
; 2062 : #if (ENABLETEST_ARCA == 1)
; 2063 : 	if (g_ArcaBattle.IsArcaBattleServer()
; 2064 : #if (ENABLETEST_ACHERON == 1)
; 2065 : 		&& g_AcheronGuardianEvent.IsPlayStart()
; 2066 : #endif
; 2067 : 		)
; 2068 : 	{
; 2069 : 		g_ArcaBattle.SendArcaBattleCurrentState(*lpObj);
; 2070 : 	}
; 2071 : 
; 2072 : 	if (g_ArcaBattle.IsArcaBattleServer()
; 2073 : #if (ENABLETEST_ACHERON == 1)
; 2074 : 		&& !g_AcheronGuardianEvent.IsPlayStart()
; 2075 : #endif
; 2076 : 		)
; 2077 : 	{
; 2078 : 		g_ArcaBattle.SendArcaBattlePlayInfo(*lpObj, 1);
; 2079 : 		g_ArcaBattle.SendArcaBattleCurrentState(*lpObj);
; 2080 : 		g_ArcaBattle.EnterArcaBattleEvent(lpObj->m_Index);
; 2081 : 		//LogAddEvent("AcheronGuardianEvent:EnterUser", lpObj);
; 2082 : 	}
; 2083 : #endif
; 2084 : 
; 2085 : 	g_QuestInfo.QuestInfoSave(lpObj);

  006c2	53		 push	 ebx
  006c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  006c8	e8 00 00 00 00	 call	 ?QuestInfoSave@CQuestInfo@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestInfo::QuestInfoSave

; 2086 : 	
; 2087 : 	DataSend(aIndex, (UCHAR*)&pjMsg, pjMsg.h.size);

  006cd	0f b6 45 85	 movzx	 eax, BYTE PTR _pjMsg$[ebp+1]
  006d1	8b b5 68 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$1$[ebp]
  006d7	50		 push	 eax
  006d8	8d 45 84	 lea	 eax, DWORD PTR _pjMsg$[ebp]
  006db	50		 push	 eax
  006dc	56		 push	 esi
  006dd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2088 : 
; 2089 : 	GCItemListSend(aIndex);

  006e2	56		 push	 esi
  006e3	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  006e8	83 c4 10	 add	 esp, 16			; 00000010H

; 2090 : 	g_CashShop.GCSendAllItemInfo(lpObj);

  006eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  006f0	53		 push	 ebx
  006f1	e8 00 00 00 00	 call	 ?GCSendAllItemInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z ; CCashShop::GCSendAllItemInfo

; 2091 : 
; 2092 : #if (ENABLETEST_MUUN == 1)
; 2093 : 	g_CMuunSystem.GDReqLoadMuunInvenItem(*lpObj);
; 2094 : #endif
; 2095 : 
; 2096 : #if (ENABLETEST_RUMMY == 1)
; 2097 : 	g_CMuRummyMng.GDReqCardInfo(lpObj);
; 2098 : #endif
; 2099 : 
; 2100 : 	GCMagicListMultiSend(lpObj, 1);

  006f6	6a 01		 push	 1
  006f8	53		 push	 ebx
  006f9	e8 00 00 00 00	 call	 ?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z ; GCMagicListMultiSend
  006fe	83 c4 08	 add	 esp, 8

; 2101 : 	g_MasterExp.DGReqMasterInfo(lpObj);

  00701	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterExp@@3VCMasterExperience@@A ; g_MasterExp
  00706	53		 push	 ebx
  00707	e8 00 00 00 00	 call	 ?DGReqMasterInfo@CMasterExperience@@QAEXPAUOBJECTSTRUCT@@@Z ; CMasterExperience::DGReqMasterInfo

; 2102 : 	g_ElementalSystem.GDReqErtelList(aIndex);

  0070c	56		 push	 esi
  0070d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00712	e8 00 00 00 00	 call	 ?GDReqErtelList@CElementalSystem@@QAEXH@Z ; CElementalSystem::GDReqErtelList

; 2103 : 	CGRequestQuestInfo(aIndex);

  00717	56		 push	 esi
  00718	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo
  0071d	83 c4 04	 add	 esp, 4

; 2104 : 	g_MonsterKillInfo.DGReqMonsterKillInfo(lpObj);

  00720	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterKillInfo@@3VCQuestMonsterKillInfo@@A ; g_MonsterKillInfo
  00725	53		 push	 ebx
  00726	e8 00 00 00 00	 call	 ?DGReqMonsterKillInfo@CQuestMonsterKillInfo@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestMonsterKillInfo::DGReqMonsterKillInfo

; 2105 : 	DGGuildMemberInfoRequest(aIndex);

  0072b	56		 push	 esi
  0072c	e8 00 00 00 00	 call	 ?DGGuildMemberInfoRequest@@YAXH@Z ; DGGuildMemberInfoRequest

; 2106 : 	FriendListRequest(aIndex);

  00731	56		 push	 esi
  00732	e8 00 00 00 00	 call	 ?FriendListRequest@@YAXH@Z ; FriendListRequest
  00737	83 c4 08	 add	 esp, 8

; 2107 : 
; 2108 : #if (__QUEST_SYSTEM__== 1)
; 2109 : 	gQuestInfoEx.GDReqQuestInfo(lpObj);

  0073a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  0073f	53		 push	 ebx
  00740	e8 00 00 00 00	 call	 ?GDReqQuestInfo@CQuestInfoEx@@QAEXPAUOBJECTSTRUCT@@@Z ; CQuestInfoEx::GDReqQuestInfo

; 2110 : #else
; 2111 : 
; 2112 : #endif
; 2113 : 
; 2114 : #if (__GENS_SYSTEM__ == 1 )
; 2115 : 	gGensSystem.GDReqGensInfo(aIndex);

  00745	56		 push	 esi
  00746	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  0074b	e8 00 00 00 00	 call	 ?GDReqGensInfo@CGensSystem@@QAEXH@Z ; CGensSystem::GDReqGensInfo

; 2116 : #endif
; 2117 : 
; 2118 : 	gObjUseSkill.SkillChangeUse(aIndex);

  00750	56		 push	 esi
  00751	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00756	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 2119 : 
; 2120 : 	//g_MiniMap.SendMinimap(aIndex);
; 2121 : 	g_Minimap.SendNpcCoordinate(aIndex, gObj[aIndex].MapNumber, 0);

  0075b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00760	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Minimap@@3VMinimap@@A ; g_Minimap
  00765	8b bd 64 ff ff
	ff		 mov	 edi, DWORD PTR tv1039[ebp]
  0076b	6a 00		 push	 0
  0076d	0f b6 84 07 23
	01 00 00	 movzx	 eax, BYTE PTR [edi+eax+291]
  00775	50		 push	 eax
  00776	56		 push	 esi
  00777	e8 00 00 00 00	 call	 ?SendNpcCoordinate@Minimap@@QAEXHEE@Z ; Minimap::SendNpcCoordinate

; 2122 :     g_Minimap.SendPortalCoordinate(aIndex, gObj[aIndex].MapNumber);

  0077c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00781	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Minimap@@3VMinimap@@A ; g_Minimap
  00786	0f b6 84 07 23
	01 00 00	 movzx	 eax, BYTE PTR [edi+eax+291]
  0078e	50		 push	 eax
  0078f	56		 push	 esi
  00790	e8 00 00 00 00	 call	 ?SendPortalCoordinate@Minimap@@QAEXHE@Z ; Minimap::SendPortalCoordinate

; 2123 : 
; 2124 : 	int iTempUserDataSlotIndex = cpDSPTempUserManager->CheckMatchCharacter(lpObj->Name);

  00795	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cpDSPTempUserManager@@3PAVCTemporaryUserManager@@A ; cpDSPTempUserManager
  0079b	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  0079e	50		 push	 eax
  0079f	e8 00 00 00 00	 call	 ?CheckMatchCharacter@CTemporaryUserManager@@QAEHPAD@Z ; CTemporaryUserManager::CheckMatchCharacter
  007a4	8b f8		 mov	 edi, eax

; 2125 : 
; 2126 : 	if( iTempUserDataSlotIndex != -1 )

  007a6	83 ff ff	 cmp	 edi, -1
  007a9	74 1a		 je	 SHORT $LN26@JGGetChara

; 2127 : 	{
; 2128 : 		cpDSPTempUserManager->SendEventMapInfo(iTempUserDataSlotIndex,aIndex);

  007ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cpDSPTempUserManager@@3PAVCTemporaryUserManager@@A ; cpDSPTempUserManager
  007b1	56		 push	 esi
  007b2	57		 push	 edi
  007b3	e8 00 00 00 00	 call	 ?SendEventMapInfo@CTemporaryUserManager@@QAEXHH@Z ; CTemporaryUserManager::SendEventMapInfo

; 2129 : 		cpDSPTempUserManager->AddToPriviousParty(aIndex, iTempUserDataSlotIndex);

  007b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cpDSPTempUserManager@@3PAVCTemporaryUserManager@@A ; cpDSPTempUserManager
  007be	57		 push	 edi
  007bf	56		 push	 esi
  007c0	e8 00 00 00 00	 call	 ?AddToPriviousParty@CTemporaryUserManager@@QAEHHH@Z ; CTemporaryUserManager::AddToPriviousParty
$LN26@JGGetChara:

; 2140 : 			// ----
; 2141 : 			if( m_ObjBill[aIndex].GetPayCode() == Node )

  007c5	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  007c8	b2 01		 mov	 dl, 1
  007ca	b8 01 00 00 00	 mov	 eax, 1
  007cf	c1 e1 04	 shl	 ecx, 4
$LL7@JGGetChara:

; 2136 : 	{
; 2137 : 		if( gPremiumServer[Node] > 0 )

  007d2	80 b8 00 00 00
	00 00		 cmp	 BYTE PTR ?gPremiumServer@@3PAEA[eax], 0
  007d9	76 0a		 jbe	 SHORT $LN5@JGGetChara

; 2138 : 		{
; 2139 : 			Login = false;

  007db	32 d2		 xor	 dl, dl

; 2140 : 			// ----
; 2141 : 			if( m_ObjBill[aIndex].GetPayCode() == Node )

  007dd	39 81 00 00 00
	00		 cmp	 DWORD PTR ?m_ObjBill@@3PAVBILL_CLASS@@A[ecx], eax
  007e3	74 34		 je	 SHORT $LN29@JGGetChara
$LN5@JGGetChara:

; 2130 : 	}
; 2131 : 
; 2132 : #ifndef SILVER
; 2133 : 	bool Login = true;
; 2134 : 	// ----
; 2135 : 	for( int Node = 1; Node < 4; Node++ )

  007e5	40		 inc	 eax
  007e6	83 f8 04	 cmp	 eax, 4
  007e9	7c e7		 jl	 SHORT $LL7@JGGetChara

; 2142 : 			{
; 2143 : 				Login = true;
; 2144 : 				break;
; 2145 : 			}
; 2146 : 		}
; 2147 : 	}
; 2148 : 	// ----
; 2149 : 	if( !Login )

  007eb	84 d2		 test	 dl, dl
  007ed	75 2a		 jne	 SHORT $LN29@JGGetChara

; 2150 : 	{
; 2151 : 		GCServerMsgStringSend("For this server you need premium status", lpObj->m_Index, 0);

  007ef	6a 00		 push	 0
  007f1	ff 33		 push	 DWORD PTR [ebx]
  007f3	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@DDIOKKGJ@For?5this?5server?5you?5need?5premium@
  007f8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 2152 : 		gObjCloseSet(aIndex, 2);

  007fd	6a 02		 push	 2
  007ff	56		 push	 esi
  00800	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  00805	83 c4 14	 add	 esp, 20			; 00000014H
  00808	5e		 pop	 esi
  00809	5f		 pop	 edi
  0080a	5b		 pop	 ebx

; 2158 : //	cCustomManager.GMNotice(lpObj);
; 2159 : 	// ----
; 2160 : #if (__CUSTOM_QUEST__ == 1)
; 2161 : 	g_MyQuest.ReqUserInfo(aIndex);
; 2162 : #endif
; 2163 : 
; 2164 : #if (CUSTOM_PETS == 1)
; 2165 : 	gCustomPets.RequestSummonInfo(lpObj->m_Index,lpObj->Name);
; 2166 : #endif
; 2167 : 
; 2168 : }

  0080b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0080e	33 cd		 xor	 ecx, ebp
  00810	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00815	8b e5		 mov	 esp, ebp
  00817	5d		 pop	 ebp
  00818	c3		 ret	 0
$LN29@JGGetChara:

; 2153 : 		return;
; 2154 : 	}
; 2155 : #endif
; 2156 : 	// ----
; 2157 : 	g_Notice.SendOnConnect(lpObj->m_Index);

  00819	ff 33		 push	 DWORD PTR [ebx]
  0081b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Notice@@3VNotice@@A ; g_Notice
  00820	e8 00 00 00 00	 call	 ?SendOnConnect@Notice@@QAEXH@Z ; Notice::SendOnConnect

; 2158 : //	cCustomManager.GMNotice(lpObj);
; 2159 : 	// ----
; 2160 : #if (__CUSTOM_QUEST__ == 1)
; 2161 : 	g_MyQuest.ReqUserInfo(aIndex);
; 2162 : #endif
; 2163 : 
; 2164 : #if (CUSTOM_PETS == 1)
; 2165 : 	gCustomPets.RequestSummonInfo(lpObj->m_Index,lpObj->Name);
; 2166 : #endif
; 2167 : 
; 2168 : }

  00825	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00828	5e		 pop	 esi
  00829	5f		 pop	 edi
  0082a	33 cd		 xor	 ecx, ebp
  0082c	5b		 pop	 ebx
  0082d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00832	8b e5		 mov	 esp, ebp
  00834	5d		 pop	 ebp
  00835	c3		 ret	 0
?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z ENDP ; JGGetCharacterInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z
_TEXT	SEGMENT
_pResult$ = -24						; size = 5
_szAccountId$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z PROC	; JGCharDelRequest, COMDAT

; 1769 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00014	57		 push	 edi

; 1770 : 	PMSG_RESULT pResult;
; 1771 : 	char szAccountId[MAX_ACCOUNT_LEN+1];
; 1772 : 	int aIndex = lpMsg->Number;
; 1773 : 	szAccountId[MAX_ACCOUNT_LEN] = 0;

  00015	c6 45 fa 00	 mov	 BYTE PTR _szAccountId$[ebp+10], 0

; 1774 : 	memcpy(szAccountId, lpMsg->AccountID, sizeof(lpMsg->AccountID));

  00019	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  0001d	0f bf 7e 04	 movsx	 edi, WORD PTR [esi+4]
  00021	f3 0f 7e 46 06	 movq	 xmm0, QWORD PTR [esi+6]
  00026	66 89 45 f8	 mov	 WORD PTR _szAccountId$[ebp+8], ax

; 1775 : 
; 1776 : 	if ( ::gObjIsAccontConnect(aIndex, szAccountId) == FALSE )

  0002a	8d 45 f0	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  0002d	50		 push	 eax
  0002e	57		 push	 edi
  0002f	66 0f d6 45 f0	 movq	 QWORD PTR _szAccountId$[ebp], xmm0
  00034	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00039	83 c4 08	 add	 esp, 8
  0003c	85 c0		 test	 eax, eax
  0003e	75 35		 jne	 SHORT $LN2@JGCharDelR

; 1777 : 	{
; 1778 : 		LogAddC(2, lMsg.Get(MSGGET(1, 169)), szAccountId);

  00040	8d 45 f0	 lea	 eax, DWORD PTR _szAccountId$[ebp]
  00043	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00048	50		 push	 eax
  00049	68 a9 01 00 00	 push	 425			; 000001a9H
  0004e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00053	50		 push	 eax
  00054	6a 02		 push	 2
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1779 : 		CloseClient(aIndex);

  0005c	57		 push	 edi
  0005d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00062	83 c4 10	 add	 esp, 16			; 00000010H
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 1791 : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	33 cd		 xor	 ecx, ebp
  0006c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN2@JGCharDelR:

; 1780 : 
; 1781 : 		return;
; 1782 : 	}
; 1783 : 
; 1784 : 	pResult.h.c = 0xC1;
; 1785 : 	pResult.h.size = sizeof(PMSG_RESULT);
; 1786 : 	pResult.h.headcode = 0xF3;
; 1787 : 	pResult.subcode = 0x02;
; 1788 : 	pResult.result = lpMsg->Result;

  00075	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  00078	88 45 ec	 mov	 BYTE PTR _pResult$[ebp+4], al

; 1789 : 
; 1790 : 	DataSend(lpMsg->Number, (UCHAR*)&pResult, pResult.h.size);

  0007b	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0007e	6a 05		 push	 5
  00080	50		 push	 eax
  00081	0f bf 46 04	 movsx	 eax, WORD PTR [esi+4]
  00085	50		 push	 eax
  00086	c7 45 e8 c1 05
	f3 02		 mov	 DWORD PTR _pResult$[ebp], 49481153 ; 02f305c1H
  0008d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1791 : }

  00092	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH
  00098	33 cd		 xor	 ecx, ebp
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z ENDP	; JGCharDelRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?JGCharacterCreateFailSend@@YAXHPAD@Z
_TEXT	SEGMENT
_pResult$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_id$ = 12						; size = 4
?JGCharacterCreateFailSend@@YAXHPAD@Z PROC		; JGCharacterCreateFailSend, COMDAT

; 1747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]

; 1748 : 	PMSG_CHARCREATERESULT  pResult;
; 1749 : 
; 1750 : 	pResult.h.c = 0xC1;
; 1751 : 	pResult.h.size = sizeof (PMSG_CHARCREATERESULT);
; 1752 : 	pResult.h.headcode = 0xF3;
; 1753 : 	pResult.subcode = 0x01;
; 1754 : 	pResult.Result = false;
; 1755 : 	pResult.pos = 0;
; 1756 : 	memcpy(pResult.Name, id, sizeof(pResult.Name));
; 1757 : 
; 1758 : 	DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  00013	6a 2c		 push	 44			; 0000002cH
  00015	c7 45 d0 c1 2c
	f3 01		 mov	 DWORD PTR _pResult$[ebp], 32713921 ; 01f32cc1H
  0001c	c6 45 d4 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  00020	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00024	66 8b 40 08	 mov	 ax, WORD PTR [eax+8]
  00028	66 89 45 dd	 mov	 WORD PTR _pResult$[ebp+13], ax
  0002c	8d 45 d0	 lea	 eax, DWORD PTR _pResult$[ebp]
  0002f	50		 push	 eax
  00030	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00033	c6 45 df 00	 mov	 BYTE PTR _pResult$[ebp+15], 0
  00037	66 0f d6 45 d5	 movq	 QWORD PTR _pResult$[ebp+5], xmm0
  0003c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1759 : }

  00041	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
  00047	33 cd		 xor	 ecx, ebp
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?JGCharacterCreateFailSend@@YAXHPAD@Z ENDP		; JGCharacterCreateFailSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z
_TEXT	SEGMENT
_pResult$ = -60						; size = 44
_szAccountID$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z PROC ; JGCharacterCreateRequest, COMDAT

; 1709 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00014	57		 push	 edi

; 1710 : 	PMSG_CHARCREATERESULT pResult;
; 1711 : 	char szAccountID[MAX_ACCOUNT_LEN+1];
; 1712 : 	int aIndex = lpMsg->Number;
; 1713 : 
; 1714 : 	szAccountID[MAX_ACCOUNT_LEN] = 0;

  00015	c6 45 fa 00	 mov	 BYTE PTR _szAccountID$[ebp+10], 0

; 1715 : 	memcpy(szAccountID, lpMsg->AccountId, sizeof(lpMsg->AccountId));

  00019	66 8b 46 0e	 mov	 ax, WORD PTR [esi+14]
  0001d	0f bf 7e 04	 movsx	 edi, WORD PTR [esi+4]
  00021	f3 0f 7e 46 06	 movq	 xmm0, QWORD PTR [esi+6]
  00026	66 89 45 f8	 mov	 WORD PTR _szAccountID$[ebp+8], ax

; 1716 : 
; 1717 : 	if ( gObjIsAccontConnect(aIndex, szAccountID) == FALSE )

  0002a	8d 45 f0	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  0002d	50		 push	 eax
  0002e	57		 push	 edi
  0002f	66 0f d6 45 f0	 movq	 QWORD PTR _szAccountID$[ebp], xmm0
  00034	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00039	83 c4 08	 add	 esp, 8
  0003c	85 c0		 test	 eax, eax
  0003e	75 35		 jne	 SHORT $LN2@JGCharacte

; 1718 : 	{
; 1719 : 		LogAddC(2, lMsg.Get(MSGGET(1, 168)), szAccountID);

  00040	8d 45 f0	 lea	 eax, DWORD PTR _szAccountID$[ebp]
  00043	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00048	50		 push	 eax
  00049	68 a8 01 00 00	 push	 424			; 000001a8H
  0004e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00053	50		 push	 eax
  00054	6a 02		 push	 2
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1720 : 		CloseClient(aIndex);

  0005c	57		 push	 edi
  0005d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00062	83 c4 10	 add	 esp, 16			; 00000010H
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 1742 : }

  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	33 cd		 xor	 ecx, ebp
  0006c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN2@JGCharacte:

; 1721 : 		return;
; 1722 : 	}
; 1723 : 
; 1724 : 	pResult.h.c = 0xC1;
; 1725 : 	pResult.h.size = sizeof(PMSG_CHARCREATERESULT);
; 1726 : 	pResult.h.headcode = 0xF3;
; 1727 : 	pResult.subcode = 0x01;
; 1728 : 	pResult.Result = lpMsg->Result;
; 1729 : 	pResult.pos = lpMsg->Pos;

  00075	0f b6 46 1a	 movzx	 eax, BYTE PTR [esi+26]
  00079	8a 56 03	 mov	 dl, BYTE PTR [esi+3]

; 1730 : 	pResult.Class = (lpMsg->ClassSkin >> 4 << 5) & 0xE0;
; 1731 : 	int changeup = lpMsg->ClassSkin & 0x07; 
; 1732 : 	pResult.Class |= (changeup << 4) & 0x10;
; 1733 : 	pResult.Level = lpMsg->Level;
; 1734 : 	memcpy(pResult.Name, lpMsg->Name, sizeof(pResult.Name));

  0007c	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  00081	88 45 d3	 mov	 BYTE PTR _pResult$[ebp+15], al
  00084	8a 46 1b	 mov	 al, BYTE PTR [esi+27]
  00087	8a c8		 mov	 cl, al
  00089	c7 45 c4 c1 2c
	f3 01		 mov	 DWORD PTR _pResult$[ebp], 32713921 ; 01f32cc1H
  00090	80 e1 01	 and	 cl, 1
  00093	88 55 c8	 mov	 BYTE PTR _pResult$[ebp+4], dl
  00096	24 f0		 and	 al, 240			; 000000f0H
  00098	c0 e1 03	 shl	 cl, 3
  0009b	0a c8		 or	 cl, al
  0009d	66 0f d6 45 c9	 movq	 QWORD PTR _pResult$[ebp+5], xmm0
  000a2	0f b7 46 34	 movzx	 eax, WORD PTR [esi+52]
  000a6	02 c9		 add	 cl, cl
  000a8	66 89 45 d4	 mov	 WORD PTR _pResult$[ebp+16], ax
  000ac	0f b7 46 18	 movzx	 eax, WORD PTR [esi+24]
  000b0	88 4d d6	 mov	 BYTE PTR _pResult$[ebp+18], cl
  000b3	66 89 45 d1	 mov	 WORD PTR _pResult$[ebp+13], ax

; 1735 : 
; 1736 : 	if ( pResult.Result == 1 )

  000b7	80 fa 01	 cmp	 dl, 1
  000ba	75 12		 jne	 SHORT $LN3@JGCharacte

; 1737 : 	{
; 1738 : 		memcpy(pResult.Equipment, lpMsg->Equipment, sizeof(pResult.Equipment));

  000bc	0f 10 46 1c	 movups	 xmm0, XMMWORD PTR [esi+28]
  000c0	0f 11 45 d7	 movups	 XMMWORD PTR _pResult$[ebp+19], xmm0
  000c4	f3 0f 7e 46 2c	 movq	 xmm0, QWORD PTR [esi+44]
  000c9	66 0f d6 45 e7	 movq	 QWORD PTR _pResult$[ebp+35], xmm0
$LN3@JGCharacte:

; 1739 : 	}
; 1740 : 
; 1741 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000ce	6a 2c		 push	 44			; 0000002cH
  000d0	8d 45 c4	 lea	 eax, DWORD PTR _pResult$[ebp]
  000d3	50		 push	 eax
  000d4	57		 push	 edi
  000d5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1742 : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	33 cd		 xor	 ecx, ebp
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z ENDP ; JGCharacterCreateRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DataServerGetCharListRequest@@YAXF@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 16
_TempId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?DataServerGetCharListRequest@@YAXF@Z PROC		; DataServerGetCharListRequest, COMDAT

; 1670 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	0f b7 7d 08	 movzx	 edi, WORD PTR _aIndex$[ebp]
  00016	0f 57 c0	 xorps	 xmm0, xmm0

; 1671 : 	SDHP_GETCHARLIST pMsg;
; 1672 : 	char TempId[11];
; 1673 : 	char* AccountId;
; 1674 : 
; 1675 : 	memset(TempId, 0, sizeof(TempId));
; 1676 : 	AccountId = gObjGetAccountId(aIndex);

  00019	0f bf f7	 movsx	 esi, di
  0001c	56		 push	 esi
  0001d	66 0f d6 45 f0	 movq	 QWORD PTR _TempId$[ebp], xmm0
  00022	66 c7 45 f8 00
	00		 mov	 WORD PTR _TempId$[ebp+8], 0
  00028	c6 45 fa 00	 mov	 BYTE PTR _TempId$[ebp+10], 0
  0002c	e8 00 00 00 00	 call	 ?gObjGetAccountId@@YAPADH@Z ; gObjGetAccountId
  00031	8b c8		 mov	 ecx, eax
  00033	83 c4 04	 add	 esp, 4

; 1677 : 
; 1678 : 	if ( AccountId == 0 )

  00036	85 c9		 test	 ecx, ecx
  00038	75 39		 jne	 SHORT $LN2@DataServer

; 1679 : 	{
; 1680 : 		LogAdd(lMsg.Get(MSGGET(1, 166)), __FILE__, __LINE__);

  0003a	68 90 06 00 00	 push	 1680			; 00000690H
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DNGOKBGI@DSProtocol?4cpp?$AA@
  00044	68 a6 01 00 00	 push	 422			; 000001a6H
$LN10@DataServer:
  00049	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0004e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1681 : 		CloseClient(aIndex);

  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00060	83 c4 10	 add	 esp, 16			; 00000010H
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi

; 1704 : 	
; 1705 : }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
$LN2@DataServer:

; 1682 : 		return;
; 1683 : 	}
; 1684 : 
; 1685 : 	// When Len is Less than 1
; 1686 : 	if ( strlen(AccountId) < 1 )

  00073	8b d1		 mov	 edx, ecx
  00075	53		 push	 ebx
  00076	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@DataServer:
  00080	8a 02		 mov	 al, BYTE PTR [edx]
  00082	42		 inc	 edx
  00083	84 c0		 test	 al, al
  00085	75 f9		 jne	 SHORT $LL9@DataServer
  00087	2b d3		 sub	 edx, ebx
  00089	5b		 pop	 ebx
  0008a	83 fa 01	 cmp	 edx, 1
  0008d	73 11		 jae	 SHORT $LN3@DataServer

; 1687 : 	{
; 1688 : 		// Error Message
; 1689 : 		//
; 1690 : 		LogAdd(lMsg.Get(MSGGET(1, 167)), __FILE__, __LINE__);

  0008f	68 9a 06 00 00	 push	 1690			; 0000069aH
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DNGOKBGI@DSProtocol?4cpp?$AA@
  00099	68 a7 01 00 00	 push	 423			; 000001a7H

; 1691 : 		CloseClient(aIndex);
; 1692 : 		return;

  0009e	eb a9		 jmp	 SHORT $LN10@DataServer
$LN3@DataServer:

; 1693 : 	}
; 1694 : 
; 1695 : 	strcpy((char*)TempId, AccountId);

  000a0	8d 55 f0	 lea	 edx, DWORD PTR _TempId$[ebp]
  000a3	2b d1		 sub	 edx, ecx
$LL5@DataServer:
  000a5	8a 01		 mov	 al, BYTE PTR [ecx]
  000a7	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000aa	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  000ae	84 c0		 test	 al, al
  000b0	75 f3		 jne	 SHORT $LL5@DataServer

; 1696 : 
; 1697 : 	pMsg.h.c  = 0xC1;
; 1698 : 	pMsg.h.size  = sizeof(SDHP_GETCHARLIST);
; 1699 : 	pMsg.h.headcode = 0x01;
; 1700 : 	pMsg.Number = aIndex;
; 1701 : 	memcpy(pMsg.Id , TempId, sizeof(TempId)-1);

  000b2	66 8b 45 f8	 mov	 ax, WORD PTR _TempId$[ebp+8]

; 1702 : 
; 1703 : 	cDBSMng.Send((char*)&pMsg, pMsg.h.size);

  000b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000bb	f3 0f 7e 45 f0	 movq	 xmm0, QWORD PTR _TempId$[ebp]
  000c0	66 89 45 eb	 mov	 WORD PTR _pMsg$[ebp+11], ax
  000c4	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000c7	6a 10		 push	 16			; 00000010H
  000c9	50		 push	 eax
  000ca	66 c7 45 e0 c1
	10		 mov	 WORD PTR _pMsg$[ebp], 4289 ; 000010c1H
  000d0	c6 45 e2 01	 mov	 BYTE PTR _pMsg$[ebp+2], 1
  000d4	66 89 7d ee	 mov	 WORD PTR _pMsg$[ebp+14], di
  000d8	66 0f d6 45 e3	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  000dd	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 1704 : 	
; 1705 : }

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e5	5f		 pop	 edi
  000e6	33 cd		 xor	 ecx, ebp
  000e8	5e		 pop	 esi
  000e9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
?DataServerGetCharListRequest@@YAXF@Z ENDP		; DataServerGetCharListRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?JGPGetCharList@@YAXPAE@Z
_TEXT	SEGMENT
tv3477 = -452						; size = 4
$T1 = -448						; size = 4
tv3279 = -444						; size = 4
tv2330 = -440						; size = 4
tv3488 = -436						; size = 4
tv2510 = -432						; size = 4
tv2487 = -428						; size = 4
tv3491 = -424						; size = 4
_n$1$ = -420						; size = 4
_lOfs$1$ = -416						; size = 4
tv2469 = -412						; size = 4
tv2452 = -408						; size = 4
_aIndex$1$ = -404					; size = 4
_pCLCount$ = -400					; size = 8
tv3303 = -392						; size = 4
tv3302 = -392						; size = 4
tv2123 = -388						; size = 4
_pMsg$ = -384						; size = 5
tv3216 = -376						; size = 4
tv2527 = -376						; size = 4
tv2113 = -372						; size = 4
tv2100 = -368						; size = 4
tv2090 = -364						; size = 4
_GenerableClass$1$ = -357				; size = 1
_TempInventory$ = -356					; size = 24
tv2751 = -332						; size = 4
tv2146 = -332						; size = 4
_levelindex$1$ = -328					; size = 4
_TempInventory$4$ = -326				; size = 2
_pCList$ = -324						; size = 34
_lpRecv$GSCopy$1$ = -288				; size = 4
_levelindex$1$ = -284					; size = 4
tv2640 = -284						; size = 4
tv2077 = -284						; size = 4
_pCList$7$ = -278					; size = 1
_pCList$3$ = -278					; size = 1
_TempInventory$20$ = -277				; size = 1
_TempInventory$19$ = -277				; size = 1
_lsOfs$1$ = -276					; size = 4
_sendbuf$ = -272					; size = 256
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
?JGPGetCharList@@YAXPAE@Z PROC				; JGPGetCharList, COMDAT

; 807  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 01 00
	00		 sub	 esp, 452		; 000001c4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpRecv$[ebp]
  00018	57		 push	 edi
  00019	89 b5 e0 fe ff
	ff		 mov	 DWORD PTR _lpRecv$GSCopy$1$[ebp], esi

; 808  : 	SDHP_CHARLISTCOUNT * lpCount = (SDHP_CHARLISTCOUNT *)lpRecv;
; 809  : 	SDHP_CHARLIST * lpCL;
; 810  : 	char szId[MAX_ACCOUNT_LEN+1];
; 811  : 	BYTE sendbuf[256];
; 812  : 	int lOfs = 0;
; 813  : 	int lsOfs = sizeof(SDHP_CHARLISTCOUNT);

  0001f	c7 85 ec fe ff
	ff 1c 00 00 00	 mov	 DWORD PTR _lsOfs$1$[ebp], 28 ; 0000001cH

; 814  : 	int aIndex = lpCount->Number;
; 815  : 	BYTE index;
; 816  : 	PMSG_CHARLISTCOUNT pCLCount;	// Packet Char List Count
; 817  : 	PMSG_CHARLIST pCList;
; 818  : 	WORD TempInventory[12];
; 819  : 
; 820  : 	pCLCount.h.c = 0xC1;
; 821  : 	pCLCount.h.headcode = 0xF3;
; 822  : 	pCLCount.subcode = 0x00;
; 823  : 	pCLCount.Count = lpCount->Count;
; 824  : 
; 825  : 	szId[MAX_ACCOUNT_LEN] = 0;
; 826  : 	memcpy(szId, lpCount->AccountId, MAX_ACCOUNT_LEN);

  00029	66 8b 46 15	 mov	 ax, WORD PTR [esi+21]
  0002d	0f bf 4e 04	 movsx	 ecx, WORD PTR [esi+4]
  00031	8a 5e 06	 mov	 bl, BYTE PTR [esi+6]
  00034	f3 0f 7e 46 0d	 movq	 xmm0, QWORD PTR [esi+13]
  00039	66 89 45 f8	 mov	 WORD PTR _szId$[ebp+8], ax

; 827  : 
; 828  : 	if ( ::gObjIsAccontConnect(aIndex, szId) == FALSE )

  0003d	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  00040	50		 push	 eax
  00041	51		 push	 ecx
  00042	89 8d 6c fe ff
	ff		 mov	 DWORD PTR _aIndex$1$[ebp], ecx
  00048	c6 85 70 fe ff
	ff c1		 mov	 BYTE PTR _pCLCount$[ebp], 193 ; 000000c1H
  0004f	66 c7 85 72 fe
	ff ff f3 00	 mov	 WORD PTR _pCLCount$[ebp+2], 243 ; 000000f3H
  00058	88 9d 76 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+6], bl
  0005e	c6 45 fa 00	 mov	 BYTE PTR _szId$[ebp+10], 0
  00062	66 0f d6 45 f0	 movq	 QWORD PTR _szId$[ebp], xmm0
  00067	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0006c	83 c4 08	 add	 esp, 8
  0006f	85 c0		 test	 eax, eax
  00071	75 4d		 jne	 SHORT $LN7@JGPGetChar

; 829  : 	{
; 830  : 		LogAddC(2, lMsg.Get(MSGGET(1, 165)), gObj[aIndex].AccountID, szId);

  00073	8b 9d 6c fe ff
	ff		 mov	 ebx, DWORD PTR _aIndex$1$[ebp]
  00079	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0007c	50		 push	 eax
  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00082	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  00088	83 c0 52	 add	 eax, 82			; 00000052H
  0008b	03 c1		 add	 eax, ecx
  0008d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00092	50		 push	 eax
  00093	68 a5 01 00 00	 push	 421			; 000001a5H
  00098	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0009d	50		 push	 eax
  0009e	6a 02		 push	 2
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 831  : 		CloseClient(aIndex);

  000a6	53		 push	 ebx
  000a7	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000ac	83 c4 14	 add	 esp, 20			; 00000014H
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx

; 1645 : 
; 1646 : 	
; 1647 : }

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	33 cd		 xor	 ecx, ebp
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
$LN7@JGPGetChar:

; 832  : 
; 833  : 		return;
; 834  : 	}
; 835  : 
; 836  : 	gObj[aIndex].Magumsa		= 2;//lpCount->Magumsa;

  000c0	69 95 6c fe ff
	ff 40 27 00 00	 imul	 edx, DWORD PTR _aIndex$1$[ebp], 10048
  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 837  : 	pCLCount.MaxClass			= lpCount->Magumsa + 2;
; 838  : 	pCLCount.MaxClass			+= 1;
; 839  : 	pCLCount.MoveCnt			= lpCount->MoveCnt;
; 840  : 
; 841  : #if (ENABLETEST_SEASON10DOT2 == 1)
; 842  : 	pCLCount.CharacterSlotCount = 5; // test
; 843  : #endif
; 844  : 
; 845  : 	gObj[aIndex].pWarehouseExtend = lpCount->btExtendVault;
; 846  : 
; 847  : 	pCLCount.MaxClass = 0;
; 848  : 	pCLCount.MoveCnt = lpCount->MoveCnt;
; 849  : 	pCLCount.MultiWarehouse = lpCount->btExtendVault;
; 850  : 
; 851  : 	memset(sendbuf, 0, sizeof(sendbuf));

  000cf	68 00 01 00 00	 push	 256			; 00000100H
  000d4	6a 00		 push	 0
  000d6	89 95 58 fe ff
	ff		 mov	 DWORD PTR tv3491[ebp], edx
  000dc	c6 44 02 34 02	 mov	 BYTE PTR [edx+eax+52], 2
  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e6	8a 4e 19	 mov	 cl, BYTE PTR [esi+25]
  000e9	88 8c 02 00 12
	00 00		 mov	 BYTE PTR [edx+eax+4608], cl
  000f0	8a 46 18	 mov	 al, BYTE PTR [esi+24]
  000f3	88 85 75 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+5], al
  000f9	8a 46 19	 mov	 al, BYTE PTR [esi+25]
  000fc	88 85 77 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+7], al
  00102	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _memset

; 852  : 	lOfs += sizeof(PMSG_CHARLISTCOUNT);
; 853  : 
; 854  : 	BYTE GenerableClass = 0;
; 855  : 
; 856  : 	pCLCount.MaxClass |= 3;
; 857  : 	gObj[aIndex].m_AccountMaxLevel = 1;

  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00113	b9 08 00 00 00	 mov	 ecx, 8
  00118	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR tv3491[ebp]
  0011e	bf 01 00 00 00	 mov	 edi, 1
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH
  00126	89 8d 60 fe ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
  0012c	c6 85 9b fe ff
	ff 00		 mov	 BYTE PTR _GenerableClass$1$[ebp], 0
  00133	c6 85 74 fe ff
	ff 03		 mov	 BYTE PTR _pCLCount$[ebp+4], 3
  0013a	66 89 7c 02 08	 mov	 WORD PTR [edx+eax+8], di

; 858  : 
; 859  : 	if ( pCLCount.Count > 0 )

  0013f	8d 79 14	 lea	 edi, DWORD PTR [ecx+20]
  00142	c7 85 44 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv3279[ebp], 1
  0014c	84 db		 test	 bl, bl
  0014e	0f 84 81 14 00
	00		 je	 $LN3@JGPGetChar

; 860  : 	{
; 861  : 		for ( int n=0;n<pCLCount.Count ;n++)

  00154	0f b6 c3	 movzx	 eax, bl
  00157	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  00161	89 85 40 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00167	85 c0		 test	 eax, eax
  00169	0f 8e 66 14 00
	00		 jle	 $LN3@JGPGetChar
  0016f	8d 42 08	 lea	 eax, DWORD PTR [edx+8]
  00172	c7 85 48 fe ff
	ff 80 00 00 00	 mov	 DWORD PTR tv2330[ebp], 128 ; 00000080H
  0017c	8d 9a c4 01 00
	00		 lea	 ebx, DWORD PTR [edx+452]
  00182	89 85 4c fe ff
	ff		 mov	 DWORD PTR tv3488[ebp], eax
  00188	89 9d 3c fe ff
	ff		 mov	 DWORD PTR tv3477[ebp], ebx
  0018e	66 90		 npad	 2
$LL4@JGPGetChar:

; 862  : 		{
; 863  : 			
; 864  : 			memset(&pCList, 0, sizeof(pCList));
; 865  : 			lpCL = (SDHP_CHARLIST *)&lpRecv[lsOfs];
; 866  : 
; 867  : 			pCList.Index = lpCL->Index;

  00190	8a 04 3e	 mov	 al, BYTE PTR [esi+edi]
  00193	0f 57 c0	 xorps	 xmm0, xmm0

; 868  : 			pCList.Level = lpCL->Level;

  00196	0f b7 74 3e 0c	 movzx	 esi, WORD PTR [esi+edi+12]
  0019b	0f 11 85 bc fe
	ff ff		 movups	 XMMWORD PTR _pCList$[ebp], xmm0
  001a2	88 85 bc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp], al

; 869  : 			pCList.CtlCode = lpCL->CtlCode;
; 870  : 			pCList.btGuildStatus = lpCL->btGuildStatus;
; 871  : 
; 872  : 			if( lpCL->Level > gObj[aIndex].m_AccountMaxLevel )

  001a8	8b ce		 mov	 ecx, esi
  001aa	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  001b0	66 c7 85 dc fe
	ff ff 00 00	 mov	 WORD PTR _pCList$[ebp+32], 0
  001b9	0f 11 85 cc fe
	ff ff		 movups	 XMMWORD PTR _pCList$[ebp+16], xmm0
  001c0	66 89 b5 c8 fe
	ff ff		 mov	 WORD PTR _pCList$[ebp+12], si
  001c7	8a 54 38 0f	 mov	 dl, BYTE PTR [eax+edi+15]
  001cb	8a 44 38 41	 mov	 al, BYTE PTR [eax+edi+65]
  001cf	8b bd 4c fe ff
	ff		 mov	 edi, DWORD PTR tv3488[ebp]
  001d5	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001db	88 85 dd fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+33], al
  001e1	88 95 ca fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+14], dl
  001e7	0f bf 07	 movsx	 eax, WORD PTR [edi]
  001ea	3b c8		 cmp	 ecx, eax
  001ec	7e 03		 jle	 SHORT $LN9@JGPGetChar

; 873  : 			{
; 874  : 				gObj[aIndex].m_AccountMaxLevel = lpCL->Level;

  001ee	66 89 37	 mov	 WORD PTR [edi], si
$LN9@JGPGetChar:

; 875  : 			}
; 876  : 
; 877  : 			/*if( lpCL->Level >= 250 && pCLCount.MaxClass < 3 )
; 878  : 				pCLCount.MaxClass |= 3;
; 879  : 			else if( lpCL->Level >= 220 && pCLCount.MaxClass < 2 )
; 880  : 				pCLCount.MaxClass |= 2;
; 881  : 			else if( lpCL->Level >= 150 && pCLCount.MaxClass < 1 )
; 882  : 				pCLCount.MaxClass |= 1;*/
; 883  : 	
; 884  : 			if ( gObj[aIndex].m_cAccountItemBlock != 0 )

  001f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f6	80 3c 03 00	 cmp	 BYTE PTR [ebx+eax], 0
  001fa	74 09		 je	 SHORT $LN10@JGPGetChar

; 885  : 				pCList.CtlCode |= 0x10;	// Set Block Item

  001fc	80 ca 10	 or	 dl, 16			; 00000010H
  001ff	88 95 ca fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+14], dl
$LN10@JGPGetChar:

; 886  : 
; 887  : 			memcpy(pCList.Name, lpCL->Name, MAX_ACCOUNT_LEN);

  00205	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  0020b	8b bd ec fe ff
	ff		 mov	 edi, DWORD PTR _lsOfs$1$[ebp]

; 888  : 			
; 889  : #if (ENABLETEST_SEASON10DOT2 == 1)
; 890  : 			pCList.CharSet[CS_CLASS] = lpCL->Class & 0xF0;
; 891  : 			int changeup = lpCL->Class & 1;
; 892  : 			int changeup2 = (lpCL->Class >> 1) & 1;
; 893  : 			if (changeup2) {
; 894  : 				changeup = 1;
; 895  : 			}
; 896  : 			pCList.CharSet[CS_CLASS] |= (changeup2 << 2) & 0x4;
; 897  : 			pCList.CharSet[CS_CLASS] |= (changeup << 3) & 0x8;
; 898  : #else
; 899  : 			pCList.CharSet[CS_CLASS] = CS_GET_CLASS(lpCL->Class);
; 900  : 			int changeup = CS_GET_CHANGEUP(lpCL->Class);
; 901  : 			pCList.CharSet[CS_CLASS] |= CS_SET_CHANGEUP(changeup);
; 902  : 			pCList.CharSet[CS_CLASS] |= ((changeup >> 1) << 3) & 8;
; 903  : #endif
; 904  : 
; 905  : 			pCList.CharSet[9] = 0;

  00211	c6 85 ea fe ff
	ff 00		 mov	 BYTE PTR _pCList$3$[ebp], 0
  00218	66 8b 44 3e 09	 mov	 ax, WORD PTR [esi+edi+9]
  0021d	8a 54 3e 0e	 mov	 dl, BYTE PTR [esi+edi+14]
  00221	f3 0f 7e 44 3e
	01		 movq	 xmm0, QWORD PTR [esi+edi+1]
  00227	66 89 85 c5 fe
	ff ff		 mov	 WORD PTR _pCList$[ebp+9], ax
  0022e	0f b6 c2	 movzx	 eax, dl
  00231	80 e2 f0	 and	 dl, 240			; 000000f0H
  00234	83 e0 07	 and	 eax, 7
  00237	66 0f d6 85 bd
	fe ff ff	 movq	 QWORD PTR _pCList$[ebp+1], xmm0
  0023f	8a c8		 mov	 cl, al
  00241	24 02		 and	 al, 2
  00243	80 e1 01	 and	 cl, 1
  00246	c0 e1 02	 shl	 cl, 2
  00249	0a c8		 or	 cl, al

; 906  : 			if ( lpCL->DbVersion == 0 )

  0024b	8a 44 3e 40	 mov	 al, BYTE PTR [esi+edi+64]
  0024f	02 c9		 add	 cl, cl
  00251	0a ca		 or	 cl, dl
  00253	02 c9		 add	 cl, cl
  00255	88 8d cb fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+15], cl
  0025b	84 c0		 test	 al, al
  0025d	0f 85 bc 02 00
	00		 jne	 $LN11@JGPGetChar

; 907  : 			{
; 908  : 				if ( lpCL->dbInventory[0] != (BYTE)-1 )

  00263	8a 54 3e 10	 mov	 dl, BYTE PTR [esi+edi+16]

; 909  : 				{
; 910  : 					WORD wItemCode = lpCL->dbInventory[0] / MAX_TYPE_ITEMS * MAX_SUBTYPE_ITEMS + lpCL->dbInventory[0] % MAX_TYPE_ITEMS;

  00267	bb 00 02 00 00	 mov	 ebx, 512		; 00000200H
  0026c	80 fa ff	 cmp	 dl, 255			; 000000ffH
  0026f	74 33		 je	 SHORT $LN13@JGPGetChar
  00271	8a c2		 mov	 al, dl
  00273	c0 e8 04	 shr	 al, 4
  00276	0f b6 c8	 movzx	 ecx, al
  00279	0f b6 c2	 movzx	 eax, dl
  0027c	0f af cb	 imul	 ecx, ebx
  0027f	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  00284	79 05		 jns	 SHORT $LN194@JGPGetChar
  00286	48		 dec	 eax
  00287	83 c8 f0	 or	 eax, -16		; fffffff0H
  0028a	40		 inc	 eax
$LN194@JGPGetChar:
  0028b	66 03 c8	 add	 cx, ax
  0028e	0f b7 c1	 movzx	 eax, cx

; 911  : 					pCList.CharSet[1] = (BYTE)wItemCode;

  00291	88 85 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+16], al

; 912  : 					pCList.CharSet[12] |= DBI_GET_TYPE(wItemCode);

  00297	c1 e8 04	 shr	 eax, 4
  0029a	24 f0		 and	 al, 240			; 000000f0H
  0029c	08 85 d7 fe ff
	ff		 or	 BYTE PTR _pCList$[ebp+27], al

; 913  : 				}
; 914  : 				else

  002a2	eb 0e		 jmp	 SHORT $LN14@JGPGetChar
$LN13@JGPGetChar:

; 915  : 				{
; 916  : 					pCList.CharSet[1] = -1;
; 917  : 					pCList.CharSet[12] |= 0xF0;

  002a4	80 8d d7 fe ff
	ff f0		 or	 BYTE PTR _pCList$[ebp+27], 240 ; 000000f0H
  002ab	c6 85 cc fe ff
	ff ff		 mov	 BYTE PTR _pCList$[ebp+16], 255 ; 000000ffH
$LN14@JGPGetChar:

; 918  : 				}
; 919  : 
; 920  : 				if ( lpCL->dbInventory[2] != (BYTE)-1 )

  002b2	8a 54 3e 12	 mov	 dl, BYTE PTR [esi+edi+18]
  002b6	80 fa ff	 cmp	 dl, 255			; 000000ffH
  002b9	74 36		 je	 SHORT $LN15@JGPGetChar

; 921  : 				{
; 922  : 					WORD wItemCode = lpCL->dbInventory[2] / MAX_TYPE_ITEMS * MAX_SUBTYPE_ITEMS + lpCL->dbInventory[2] % MAX_TYPE_ITEMS;

  002bb	8a c2		 mov	 al, dl
  002bd	c0 e8 04	 shr	 al, 4
  002c0	0f b6 c8	 movzx	 ecx, al
  002c3	0f b7 c3	 movzx	 eax, bx
  002c6	0f af c8	 imul	 ecx, eax
  002c9	0f b6 c2	 movzx	 eax, dl
  002cc	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  002d1	79 05		 jns	 SHORT $LN195@JGPGetChar
  002d3	48		 dec	 eax
  002d4	83 c8 f0	 or	 eax, -16		; fffffff0H
  002d7	40		 inc	 eax
$LN195@JGPGetChar:
  002d8	66 03 c8	 add	 cx, ax
  002db	0f b7 c1	 movzx	 eax, cx

; 923  : 					pCList.CharSet[2] = (BYTE)wItemCode;

  002de	88 85 cd fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+17], al

; 924  : 					pCList.CharSet[13] |= DBI_GET_TYPE(wItemCode);

  002e4	c1 e8 04	 shr	 eax, 4
  002e7	24 f0		 and	 al, 240			; 000000f0H
  002e9	08 85 d8 fe ff
	ff		 or	 BYTE PTR _pCList$[ebp+28], al

; 925  : 				}
; 926  : 				else

  002ef	eb 0e		 jmp	 SHORT $LN16@JGPGetChar
$LN15@JGPGetChar:

; 927  : 				{
; 928  : 					pCList.CharSet[2] = -1;
; 929  : 					pCList.CharSet[13] |= 0xF0;

  002f1	80 8d d8 fe ff
	ff f0		 or	 BYTE PTR _pCList$[ebp+28], 240 ; 000000f0H
  002f8	c6 85 cd fe ff
	ff ff		 mov	 BYTE PTR _pCList$[ebp+17], 255 ; 000000ffH
$LN16@JGPGetChar:

; 930  : 				}
; 931  : 
; 932  : 				if ( lpCL->dbInventory[4] == (BYTE)-1 )

  002ff	8a 7c 3e 14	 mov	 bh, BYTE PTR [esi+edi+20]
  00303	80 ff ff	 cmp	 bh, 255			; 000000ffH
  00306	75 04		 jne	 SHORT $LN17@JGPGetChar

; 933  : 				{
; 934  : 					index = 0xF0;

  00308	b1 f0		 mov	 cl, 240			; 000000f0H

; 935  : 				}
; 936  : 				else

  0030a	eb 08		 jmp	 SHORT $LN18@JGPGetChar
$LN17@JGPGetChar:

; 937  : 				{
; 938  : 					index = (lpCL->dbInventory[4] & 0x0F) * MAX_TYPE_ITEMS;

  0030c	8a cf		 mov	 cl, bh
  0030e	80 e1 0f	 and	 cl, 15			; 0000000fH
  00311	c0 e1 04	 shl	 cl, 4
$LN18@JGPGetChar:

; 939  : 				}
; 940  : 
; 941  : 				if ( lpCL->dbInventory[6] == (BYTE)-1 )

  00314	8a 74 3e 16	 mov	 dh, BYTE PTR [esi+edi+22]
  00318	80 fe ff	 cmp	 dh, 255			; 000000ffH
  0031b	75 05		 jne	 SHORT $LN19@JGPGetChar

; 942  : 				{
; 943  : 					index |= 0x0F;

  0031d	80 c9 0f	 or	 cl, 15			; 0000000fH

; 944  : 				}
; 945  : 				else

  00320	eb 06		 jmp	 SHORT $LN20@JGPGetChar
$LN19@JGPGetChar:

; 946  : 				{
; 947  : 					index |= (lpCL->dbInventory[6] & 0x0F);

  00322	8a c6		 mov	 al, dh
  00324	24 0f		 and	 al, 15			; 0000000fH
  00326	0a c8		 or	 cl, al
$LN20@JGPGetChar:

; 948  : 				}
; 949  : 
; 950  : 				pCList.CharSet[3] = index;
; 951  : 
; 952  : 				if ( lpCL->dbInventory[8] == (BYTE)-1 )

  00328	8a 54 3e 18	 mov	 dl, BYTE PTR [esi+edi+24]
  0032c	88 8d ce fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+18], cl
  00332	80 fa ff	 cmp	 dl, 255			; 000000ffH
  00335	75 04		 jne	 SHORT $LN21@JGPGetChar

; 953  : 				{
; 954  : 					index = 0xF0;

  00337	b1 f0		 mov	 cl, 240			; 000000f0H

; 955  : 				}
; 956  : 				else

  00339	eb 08		 jmp	 SHORT $LN22@JGPGetChar
$LN21@JGPGetChar:

; 957  : 				{
; 958  : 					index = (lpCL->dbInventory[8] & 0x0F) * MAX_TYPE_ITEMS;

  0033b	8a ca		 mov	 cl, dl
  0033d	80 e1 0f	 and	 cl, 15			; 0000000fH
  00340	c0 e1 04	 shl	 cl, 4
$LN22@JGPGetChar:

; 959  : 				}
; 960  : 
; 961  : 				if ( lpCL->dbInventory[10] == (BYTE)-1 )

  00343	8a 5c 3e 1a	 mov	 bl, BYTE PTR [esi+edi+26]
  00347	80 fb ff	 cmp	 bl, 255			; 000000ffH
  0034a	75 05		 jne	 SHORT $LN23@JGPGetChar

; 962  : 				{
; 963  : 					index |= 0x0F;

  0034c	80 c9 0f	 or	 cl, 15			; 0000000fH

; 964  : 				}
; 965  : 				else

  0034f	eb 06		 jmp	 SHORT $LN24@JGPGetChar
$LN23@JGPGetChar:

; 966  : 				{
; 967  : 					index |= (lpCL->dbInventory[10] & 0x0F);

  00351	8a c3		 mov	 al, bl
  00353	24 0f		 and	 al, 15			; 0000000fH
  00355	0a c8		 or	 cl, al
$LN24@JGPGetChar:

; 968  : 				}
; 969  : 
; 970  : 				pCList.CharSet[4] = index;
; 971  : 
; 972  : 				if ( lpCL->dbInventory[12] == (BYTE)-1 )

  00357	8a 6c 3e 1c	 mov	 ch, BYTE PTR [esi+edi+28]
  0035b	88 8d cf fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+19], cl
  00361	80 fd ff	 cmp	 ch, 255			; 000000ffH
  00364	75 04		 jne	 SHORT $LN25@JGPGetChar

; 973  : 				{
; 974  : 					index = 0xF0;

  00366	b0 f0		 mov	 al, 240			; 000000f0H

; 975  : 				}
; 976  : 				else

  00368	eb 07		 jmp	 SHORT $LN26@JGPGetChar
$LN25@JGPGetChar:

; 977  : 				{
; 978  : 					index = (lpCL->dbInventory[12] & 0x0F) * MAX_TYPE_ITEMS;

  0036a	8a c5		 mov	 al, ch
  0036c	24 0f		 and	 al, 15			; 0000000fH
  0036e	c0 e0 04	 shl	 al, 4
$LN26@JGPGetChar:

; 979  : 				}
; 980  : 
; 981  : 				if ( lpCL->dbInventory[14] == (BYTE)-1 )

  00371	8a 4c 3e 1e	 mov	 cl, BYTE PTR [esi+edi+30]
  00375	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  00378	75 04		 jne	 SHORT $LN27@JGPGetChar

; 982  : 				{
; 983  : 					index |= 0x0C;

  0037a	0c 0c		 or	 al, 12			; 0000000cH

; 984  : 				}
; 985  : 				else

  0037c	eb 08		 jmp	 SHORT $LN28@JGPGetChar
$LN27@JGPGetChar:

; 986  : 				{
; 987  : 					index |= ((lpCL->dbInventory[14] & 0x03) * 4 );

  0037e	80 e1 03	 and	 cl, 3
  00381	c0 e1 02	 shl	 cl, 2
  00384	0a c1		 or	 al, cl
$LN28@JGPGetChar:

; 988  : 				}
; 989  : 
; 990  : 				if ( lpCL->dbInventory[16] == (BYTE)-1 )

  00386	8a 4c 3e 20	 mov	 cl, BYTE PTR [esi+edi+32]
  0038a	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  0038d	75 04		 jne	 SHORT $LN29@JGPGetChar

; 991  : 				{
; 992  : 					index |= 0x03;

  0038f	0c 03		 or	 al, 3

; 993  : 				}
; 994  : 				else

  00391	eb 05		 jmp	 SHORT $LN30@JGPGetChar
$LN29@JGPGetChar:

; 995  : 				{
; 996  : 					index |= (lpCL->dbInventory[16] & 0x03);

  00393	80 e1 03	 and	 cl, 3
  00396	0a c1		 or	 al, cl
$LN30@JGPGetChar:

; 997  : 				}
; 998  : 
; 999  : 				pCList.CharSet[5] = index;

  00398	88 85 d0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], al

; 1000 : 
; 1001 : 				if ( lpCL->dbInventory[4] == (BYTE)-1 )

  0039e	80 ff ff	 cmp	 bh, 255			; 000000ffH
  003a1	0f b6 85 ea fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$3$[ebp]
  003a8	0f 44 85 48 fe
	ff ff		 cmove	 eax, DWORD PTR tv2330[ebp]
  003af	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1002 : 					pCList.CharSet[9] = 0x80;
; 1003 : 
; 1004 : 				if ( lpCL->dbInventory[6] == (BYTE)-1 )

  003b5	80 fe ff	 cmp	 dh, 255			; 000000ffH
  003b8	75 08		 jne	 SHORT $LN32@JGPGetChar

; 1005 : 					pCList.CharSet[9] |= 0x40;

  003ba	0c 40		 or	 al, 64			; 00000040H
  003bc	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al
$LN32@JGPGetChar:

; 1006 : 
; 1007 : 				if ( lpCL->dbInventory[8] == (BYTE)-1 )

  003c2	80 fa ff	 cmp	 dl, 255			; 000000ffH
  003c5	75 08		 jne	 SHORT $LN33@JGPGetChar

; 1008 : 					pCList.CharSet[9] |= 0x20;

  003c7	0c 20		 or	 al, 32			; 00000020H
  003c9	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al
$LN33@JGPGetChar:

; 1009 : 
; 1010 : 				if ( lpCL->dbInventory[10] == (BYTE)-1 )

  003cf	80 fb ff	 cmp	 bl, 255			; 000000ffH
  003d2	75 08		 jne	 SHORT $LN34@JGPGetChar

; 1011 : 					pCList.CharSet[9] |= 0x10;

  003d4	0c 10		 or	 al, 16			; 00000010H
  003d6	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al
$LN34@JGPGetChar:

; 1012 : 
; 1013 : 				if ( lpCL->dbInventory[12] == (BYTE)-1 )

  003dc	80 fd ff	 cmp	 ch, 255			; 000000ffH
  003df	75 08		 jne	 SHORT $LN35@JGPGetChar

; 1014 : 					pCList.CharSet[9] |= 0x08;

  003e1	0c 08		 or	 al, 8
  003e3	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al
$LN35@JGPGetChar:

; 1015 : 
; 1016 : 				int levelindex = LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[1]));

  003e9	0f b6 44 3e 11	 movzx	 eax, BYTE PTR [esi+edi+17]
  003ee	c1 e8 03	 shr	 eax, 3
  003f1	83 e0 0f	 and	 eax, 15			; 0000000fH
  003f4	50		 push	 eax
  003f5	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  003fa	0f b6 d8	 movzx	 ebx, al

; 1017 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[3])) << 3;

  003fd	0f b6 44 3e 13	 movzx	 eax, BYTE PTR [esi+edi+19]
  00402	c1 e8 03	 shr	 eax, 3
  00405	83 e0 0f	 and	 eax, 15			; 0000000fH
  00408	50		 push	 eax
  00409	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  0040e	0f b6 c0	 movzx	 eax, al
  00411	c1 e0 03	 shl	 eax, 3
  00414	0b d8		 or	 ebx, eax

; 1018 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[5])) << 6;

  00416	0f b6 44 3e 15	 movzx	 eax, BYTE PTR [esi+edi+21]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	83 e0 0f	 and	 eax, 15			; 0000000fH
  00421	50		 push	 eax
  00422	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00427	0f b6 c0	 movzx	 eax, al
  0042a	c1 e0 06	 shl	 eax, 6
  0042d	0b d8		 or	 ebx, eax

; 1019 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[7])) << 9;

  0042f	0f b6 44 3e 17	 movzx	 eax, BYTE PTR [esi+edi+23]
  00434	c1 e8 03	 shr	 eax, 3
  00437	83 e0 0f	 and	 eax, 15			; 0000000fH
  0043a	50		 push	 eax
  0043b	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00440	0f b6 c0	 movzx	 eax, al
  00443	c1 e0 09	 shl	 eax, 9
  00446	0b d8		 or	 ebx, eax

; 1020 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[9])) << 12;

  00448	0f b6 44 3e 19	 movzx	 eax, BYTE PTR [esi+edi+25]
  0044d	c1 e8 03	 shr	 eax, 3
  00450	83 e0 0f	 and	 eax, 15			; 0000000fH
  00453	50		 push	 eax
  00454	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00459	0f b6 c0	 movzx	 eax, al
  0045c	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  0045f	0b d8		 or	 ebx, eax

; 1021 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[11])) << 15;

  00461	0f b6 44 3e 1b	 movzx	 eax, BYTE PTR [esi+edi+27]
  00466	c1 e8 03	 shr	 eax, 3
  00469	83 e0 0f	 and	 eax, 15			; 0000000fH
  0046c	50		 push	 eax
  0046d	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00472	0f b6 c0	 movzx	 eax, al
  00475	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00478	0b d8		 or	 ebx, eax

; 1022 : 				levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[13])) << 18;

  0047a	0f b6 44 3e 1d	 movzx	 eax, BYTE PTR [esi+edi+29]
  0047f	c1 e8 03	 shr	 eax, 3
  00482	83 e0 0f	 and	 eax, 15			; 0000000fH
  00485	50		 push	 eax
  00486	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  0048b	0f b6 c0	 movzx	 eax, al
  0048e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00491	c1 e0 12	 shl	 eax, 18			; 00000012H
  00494	0b d8		 or	 ebx, eax

; 1023 : 
; 1024 : 				pCList.CharSet[6] = levelindex >> 16 & 0xFF;
; 1025 : 				pCList.CharSet[7] = (levelindex >> 8) & 0xFF;
; 1026 : 				pCList.CharSet[8] = (levelindex ) & 0xFF;
; 1027 : 				pCList.CharSet[10] = 0;

  00496	66 c7 85 d5 fe
	ff ff 00 00	 mov	 WORD PTR _pCList$[ebp+25], 0
  0049f	8b c3		 mov	 eax, ebx
  004a1	88 9d d3 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+23], bl
  004a7	c1 f8 10	 sar	 eax, 16			; 00000010H
  004aa	88 85 d1 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+21], al
  004b0	8b c3		 mov	 eax, ebx
  004b2	c1 f8 08	 sar	 eax, 8

; 1028 : 				pCList.CharSet[11] = 0;
; 1029 : 
; 1030 : 				if ( lpCL->dbInventory[4] == (BYTE)-1 )

  004b5	80 7c 3e 14 ff	 cmp	 BYTE PTR [esi+edi+20], 255 ; 000000ffH
  004ba	88 85 d2 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+22], al
  004c0	75 07		 jne	 SHORT $LN36@JGPGetChar

; 1031 : 					pCList.CharSet[13] |= 0x0F;

  004c2	80 8d d8 fe ff
	ff 0f		 or	 BYTE PTR _pCList$[ebp+28], 15 ; 0000000fH
$LN36@JGPGetChar:

; 1032 : 
; 1033 : 				if ( lpCL->dbInventory[8] == (BYTE)-1 )

  004c9	80 7c 3e 18 ff	 cmp	 BYTE PTR [esi+edi+24], 255 ; 000000ffH

; 1034 : 					pCList.CharSet[14] |= 0xF0;

  004ce	8a 85 d9 fe ff
	ff		 mov	 al, BYTE PTR _pCList$[ebp+29]
  004d4	75 08		 jne	 SHORT $LN37@JGPGetChar
  004d6	0c f0		 or	 al, 240			; 000000f0H
  004d8	88 85 d9 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+29], al
$LN37@JGPGetChar:

; 1035 : 
; 1036 : 				if ( lpCL->dbInventory[10] == (BYTE)-1 )

  004de	80 7c 3e 1a ff	 cmp	 BYTE PTR [esi+edi+26], 255 ; 000000ffH
  004e3	75 08		 jne	 SHORT $LN38@JGPGetChar

; 1037 : 					pCList.CharSet[14] |= 0x0F;

  004e5	0c 0f		 or	 al, 15			; 0000000fH
  004e7	88 85 d9 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+29], al
$LN38@JGPGetChar:

; 1038 : 
; 1039 : 				if ( lpCL->dbInventory[12] == (BYTE)-1 )

  004ed	80 7c 3e 1c ff	 cmp	 BYTE PTR [esi+edi+28], 255 ; 000000ffH

; 1040 : 					pCList.CharSet[15] |= 0xF0;

  004f2	8a 85 da fe ff
	ff		 mov	 al, BYTE PTR _pCList$[ebp+30]
  004f8	75 08		 jne	 SHORT $LN39@JGPGetChar
  004fa	0c f0		 or	 al, 240			; 000000f0H
  004fc	88 85 da fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+30], al
$LN39@JGPGetChar:

; 1041 : 
; 1042 : 				if ( lpCL->dbInventory[14] == (BYTE)-1 )

  00502	80 7c 3e 1e ff	 cmp	 BYTE PTR [esi+edi+30], 255 ; 000000ffH
  00507	75 08		 jne	 SHORT $LN40@JGPGetChar

; 1043 : 					pCList.CharSet[15] |= 0x0F;

  00509	0c 0f		 or	 al, 15			; 0000000fH
  0050b	88 85 da fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+30], al
$LN40@JGPGetChar:

; 1044 : 
; 1045 : 				pCList.CharSet[16] = 0;

  00511	66 c7 85 db fe
	ff ff 00 00	 mov	 WORD PTR _pCList$[ebp+31], 0

; 1046 : 				pCList.CharSet[17] = 0;

  0051a	e9 52 10 00 00	 jmp	 $LN161@JGPGetChar
$LN11@JGPGetChar:

; 1047 : 			}
; 1048 : 			else if ( lpCL->DbVersion <= 2 )

  0051f	3c 02		 cmp	 al, 2
  00521	0f 87 dc 06 00
	00		 ja	 $LN41@JGPGetChar

; 1049 : 			{
; 1050 : 				if ( lpCL->dbInventory[0] != (BYTE)-1 )

  00527	8a 5c 3e 10	 mov	 bl, BYTE PTR [esi+edi+16]
  0052b	80 fb ff	 cmp	 bl, 255			; 000000ffH
  0052e	74 29		 je	 SHORT $LN43@JGPGetChar

; 1051 : 				{
; 1052 : 					TempInventory[0] = (lpCL->dbInventory[0] / 32) * MAX_SUBTYPE_ITEMS + lpCL->dbInventory[0] % 32;

  00530	8a c3		 mov	 al, bl
  00532	c0 e8 05	 shr	 al, 5
  00535	0f b6 d0	 movzx	 edx, al
  00538	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0053d	0f af d0	 imul	 edx, eax
  00540	0f b6 c3	 movzx	 eax, bl
  00543	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00548	79 05		 jns	 SHORT $LN196@JGPGetChar
  0054a	48		 dec	 eax
  0054b	83 c8 e0	 or	 eax, -32		; ffffffe0H
  0054e	40		 inc	 eax
$LN196@JGPGetChar:
  0054f	66 03 d0	 add	 dx, ax

; 1053 : 				}
; 1054 : 				else

  00552	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00557	eb 08		 jmp	 SHORT $LN219@JGPGetChar
$LN43@JGPGetChar:

; 1055 : 				{
; 1056 : 					TempInventory[0] = -1;

  00559	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0055e	66 8b d0	 mov	 dx, ax
$LN219@JGPGetChar:

; 1057 : 				}
; 1058 : 
; 1059 : 				if ( lpCL->dbInventory[3] != (BYTE)-1 )

  00561	8a 5c 3e 13	 mov	 bl, BYTE PTR [esi+edi+19]
  00565	66 89 95 9c fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp], dx
  0056c	80 fb ff	 cmp	 bl, 255			; 000000ffH
  0056f	74 24		 je	 SHORT $LN45@JGPGetChar

; 1060 : 				{
; 1061 : 					TempInventory[1] = (lpCL->dbInventory[3] / 32) * MAX_SUBTYPE_ITEMS + lpCL->dbInventory[3] % 32;

  00571	8a c3		 mov	 al, bl
  00573	c0 e8 05	 shr	 al, 5
  00576	0f b6 f8	 movzx	 edi, al
  00579	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0057e	0f af f8	 imul	 edi, eax
  00581	0f b6 c3	 movzx	 eax, bl
  00584	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00589	79 05		 jns	 SHORT $LN197@JGPGetChar
  0058b	48		 dec	 eax
  0058c	83 c8 e0	 or	 eax, -32		; ffffffe0H
  0058f	40		 inc	 eax
$LN197@JGPGetChar:
  00590	66 03 f8	 add	 di, ax

; 1062 : 				}
; 1063 : 				else

  00593	eb 03		 jmp	 SHORT $LN220@JGPGetChar
$LN45@JGPGetChar:

; 1064 : 				{
; 1065 : 					TempInventory[1] = -1;

  00595	66 8b f8	 mov	 di, ax
$LN220@JGPGetChar:

; 1066 : 				}
; 1067 : 
; 1068 : 				if ( lpCL->dbInventory[6] == (BYTE)-1 && (lpCL->dbInventory[8] & 0x80) == 0x80)

  00598	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
  0059e	66 89 bd 9e fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+2], di
  005a5	8a 44 0e 16	 mov	 al, BYTE PTR [esi+ecx+22]
  005a9	3c ff		 cmp	 al, 255			; 000000ffH
  005ab	75 0e		 jne	 SHORT $LN47@JGPGetChar
  005ad	f6 44 0e 18 80	 test	 BYTE PTR [esi+ecx+24], 128 ; 00000080H
  005b2	74 07		 je	 SHORT $LN47@JGPGetChar

; 1069 : 				{
; 1070 : 					TempInventory[2] = -1;

  005b4	bb ff ff 00 00	 mov	 ebx, 65535		; 0000ffffH

; 1071 : 				}
; 1072 : 				else

  005b9	eb 21		 jmp	 SHORT $LN221@JGPGetChar
$LN47@JGPGetChar:

; 1073 : 				{
; 1074 : 					TempInventory[2] = (lpCL->dbInventory[6] + ((lpCL->dbInventory[8] >> 7) <<  8) ) % 32;

  005bb	0f b6 4c 0e 18	 movzx	 ecx, BYTE PTR [esi+ecx+24]
  005c0	83 e1 80	 and	 ecx, -128		; ffffff80H
  005c3	0f b6 c0	 movzx	 eax, al
  005c6	8d 1c 48	 lea	 ebx, DWORD PTR [eax+ecx*2]
  005c9	81 e3 1f 00 00
	80		 and	 ebx, -2147483617	; 8000001fH
  005cf	79 05		 jns	 SHORT $LN198@JGPGetChar
  005d1	4b		 dec	 ebx
  005d2	83 cb e0	 or	 ebx, -32		; ffffffe0H
  005d5	43		 inc	 ebx
$LN198@JGPGetChar:
  005d6	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN221@JGPGetChar:

; 1075 : 				}
; 1076 : 
; 1077 : 				if ( lpCL->dbInventory[9] == (BYTE)-1 && (lpCL->dbInventory[11] & 0x80) == 0x80)

  005dc	8a 44 0e 19	 mov	 al, BYTE PTR [esi+ecx+25]
  005e0	66 89 9d a0 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+4], bx
  005e7	89 9d e4 fe ff
	ff		 mov	 DWORD PTR tv2077[ebp], ebx
  005ed	3c ff		 cmp	 al, 255			; 000000ffH
  005ef	75 15		 jne	 SHORT $LN49@JGPGetChar
  005f1	f6 44 0e 1b 80	 test	 BYTE PTR [esi+ecx+27], 128 ; 00000080H
  005f6	74 0e		 je	 SHORT $LN49@JGPGetChar

; 1078 : 				{
; 1079 : 					TempInventory[3] = -1;

  005f8	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  005fd	66 89 85 94 fe
	ff ff		 mov	 WORD PTR tv2090[ebp], ax

; 1080 : 				}
; 1081 : 				else

  00604	eb 27		 jmp	 SHORT $LN50@JGPGetChar
$LN49@JGPGetChar:

; 1082 : 				{
; 1083 : 					TempInventory[3] = (lpCL->dbInventory[9] + ((lpCL->dbInventory[11] >> 7) <<  8) ) % 32;

  00606	0f b6 4c 0e 1b	 movzx	 ecx, BYTE PTR [esi+ecx+27]
  0060b	83 e1 80	 and	 ecx, -128		; ffffff80H
  0060e	0f b6 c0	 movzx	 eax, al
  00611	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00614	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  0061a	79 05		 jns	 SHORT $LN199@JGPGetChar
  0061c	49		 dec	 ecx
  0061d	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  00620	41		 inc	 ecx
$LN199@JGPGetChar:
  00621	89 8d 94 fe ff
	ff		 mov	 DWORD PTR tv2090[ebp], ecx
  00627	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN50@JGPGetChar:

; 1084 : 				}
; 1085 : 
; 1086 : 				if ( lpCL->dbInventory[12] == (BYTE)-1 && (lpCL->dbInventory[14] & 0x80) == 0x80)

  0062d	8a 44 0e 1c	 mov	 al, BYTE PTR [esi+ecx+28]
  00631	3c ff		 cmp	 al, 255			; 000000ffH
  00633	75 15		 jne	 SHORT $LN51@JGPGetChar
  00635	f6 44 0e 1e 80	 test	 BYTE PTR [esi+ecx+30], 128 ; 00000080H
  0063a	74 0e		 je	 SHORT $LN51@JGPGetChar

; 1087 : 				{
; 1088 : 					TempInventory[4] = 0x1F;

  0063c	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  00641	66 89 85 90 fe
	ff ff		 mov	 WORD PTR tv2100[ebp], ax

; 1089 : 				}
; 1090 : 				else

  00648	eb 27		 jmp	 SHORT $LN52@JGPGetChar
$LN51@JGPGetChar:

; 1091 : 				{
; 1092 : 					TempInventory[4] = (lpCL->dbInventory[12] + ((lpCL->dbInventory[14] >> 7) <<  8) ) % 32;

  0064a	0f b6 4c 0e 1e	 movzx	 ecx, BYTE PTR [esi+ecx+30]
  0064f	83 e1 80	 and	 ecx, -128		; ffffff80H
  00652	0f b6 c0	 movzx	 eax, al
  00655	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00658	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  0065e	79 05		 jns	 SHORT $LN200@JGPGetChar
  00660	49		 dec	 ecx
  00661	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  00664	41		 inc	 ecx
$LN200@JGPGetChar:
  00665	89 8d 90 fe ff
	ff		 mov	 DWORD PTR tv2100[ebp], ecx
  0066b	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN52@JGPGetChar:

; 1093 : 				}
; 1094 : 
; 1095 : 				if ( lpCL->dbInventory[15] == (BYTE)-1 && (lpCL->dbInventory[17] & 0x80) == 0x80)

  00671	8a 44 0e 1f	 mov	 al, BYTE PTR [esi+ecx+31]
  00675	3c ff		 cmp	 al, 255			; 000000ffH
  00677	75 15		 jne	 SHORT $LN53@JGPGetChar
  00679	f6 44 0e 21 80	 test	 BYTE PTR [esi+ecx+33], 128 ; 00000080H
  0067e	74 0e		 je	 SHORT $LN53@JGPGetChar

; 1096 : 				{
; 1097 : 					TempInventory[5] = 0x1F;

  00680	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  00685	66 89 85 8c fe
	ff ff		 mov	 WORD PTR tv2113[ebp], ax

; 1098 : 				}
; 1099 : 				else

  0068c	eb 27		 jmp	 SHORT $LN54@JGPGetChar
$LN53@JGPGetChar:

; 1100 : 				{
; 1101 : 					TempInventory[5] = (lpCL->dbInventory[15] + ((lpCL->dbInventory[17] >> 7) <<  8) ) % 32;

  0068e	0f b6 4c 0e 21	 movzx	 ecx, BYTE PTR [esi+ecx+33]
  00693	83 e1 80	 and	 ecx, -128		; ffffff80H
  00696	0f b6 c0	 movzx	 eax, al
  00699	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0069c	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  006a2	79 05		 jns	 SHORT $LN201@JGPGetChar
  006a4	49		 dec	 ecx
  006a5	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  006a8	41		 inc	 ecx
$LN201@JGPGetChar:
  006a9	89 8d 8c fe ff
	ff		 mov	 DWORD PTR tv2113[ebp], ecx
  006af	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN54@JGPGetChar:

; 1102 : 				}
; 1103 : 
; 1104 : 				if ( lpCL->dbInventory[18] == (BYTE)-1 && (lpCL->dbInventory[20] & 0x80) == 0x80)

  006b5	8a 44 0e 22	 mov	 al, BYTE PTR [esi+ecx+34]
  006b9	3c ff		 cmp	 al, 255			; 000000ffH
  006bb	75 15		 jne	 SHORT $LN55@JGPGetChar
  006bd	f6 44 0e 24 80	 test	 BYTE PTR [esi+ecx+36], 128 ; 00000080H
  006c2	74 0e		 je	 SHORT $LN55@JGPGetChar

; 1105 : 				{
; 1106 : 					TempInventory[6] = 0x1F;

  006c4	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  006c9	66 89 85 7c fe
	ff ff		 mov	 WORD PTR tv2123[ebp], ax

; 1107 : 				}
; 1108 : 				else

  006d0	eb 27		 jmp	 SHORT $LN56@JGPGetChar
$LN55@JGPGetChar:

; 1109 : 				{
; 1110 : 					TempInventory[6] = (lpCL->dbInventory[18] + ((lpCL->dbInventory[20] >> 7) <<  8) ) % 32;

  006d2	0f b6 4c 0e 24	 movzx	 ecx, BYTE PTR [esi+ecx+36]
  006d7	83 e1 80	 and	 ecx, -128		; ffffff80H
  006da	0f b6 c0	 movzx	 eax, al
  006dd	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  006e0	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  006e6	79 05		 jns	 SHORT $LN202@JGPGetChar
  006e8	49		 dec	 ecx
  006e9	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  006ec	41		 inc	 ecx
$LN202@JGPGetChar:
  006ed	89 8d 7c fe ff
	ff		 mov	 DWORD PTR tv2123[ebp], ecx
  006f3	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN56@JGPGetChar:

; 1111 : 				}
; 1112 : 
; 1113 : 				if ( lpCL->dbInventory[21] == (BYTE)-1 && (lpCL->dbInventory[23] & 0x80) == 0x80)

  006f9	8a 44 0e 25	 mov	 al, BYTE PTR [esi+ecx+37]
  006fd	3c ff		 cmp	 al, 255			; 000000ffH
  006ff	75 0e		 jne	 SHORT $LN57@JGPGetChar
  00701	f6 44 0e 27 80	 test	 BYTE PTR [esi+ecx+39], 128 ; 00000080H
  00706	74 07		 je	 SHORT $LN57@JGPGetChar

; 1114 : 				{
; 1115 : 					TempInventory[7] = 0x1F;

  00708	be 1f 00 00 00	 mov	 esi, 31			; 0000001fH

; 1116 : 				}
; 1117 : 				else

  0070d	eb 1b		 jmp	 SHORT $LN203@JGPGetChar
$LN57@JGPGetChar:

; 1118 : 				{
; 1119 : 					TempInventory[7] = (lpCL->dbInventory[21] + ((lpCL->dbInventory[23] >> 7) <<  8) ) % 32;

  0070f	0f b6 4c 0e 27	 movzx	 ecx, BYTE PTR [esi+ecx+39]
  00714	83 e1 80	 and	 ecx, -128		; ffffff80H
  00717	0f b6 c0	 movzx	 eax, al
  0071a	8d 34 48	 lea	 esi, DWORD PTR [eax+ecx*2]
  0071d	81 e6 1f 00 00
	80		 and	 esi, -2147483617	; 8000001fH
  00723	79 05		 jns	 SHORT $LN203@JGPGetChar
  00725	4e		 dec	 esi
  00726	83 ce e0	 or	 esi, -32		; ffffffe0H
  00729	46		 inc	 esi
$LN203@JGPGetChar:

; 1120 : 				}
; 1121 : 
; 1122 : 				if ( lpCL->dbInventory[24] == (BYTE)-1 && (lpCL->dbInventory[26] & 0x80) == 0x80)

  0072a	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  00730	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  00736	66 89 b5 aa fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+14], si
  0073d	8a 44 01 28	 mov	 al, BYTE PTR [ecx+eax+40]
  00741	3c ff		 cmp	 al, 255			; 000000ffH
  00743	75 1a		 jne	 SHORT $LN59@JGPGetChar
  00745	8b 9d ec fe ff
	ff		 mov	 ebx, DWORD PTR _lsOfs$1$[ebp]
  0074b	f6 44 19 2a 80	 test	 BYTE PTR [ecx+ebx+42], 128 ; 00000080H
  00750	8b 9d e4 fe ff
	ff		 mov	 ebx, DWORD PTR tv2077[ebp]
  00756	74 07		 je	 SHORT $LN59@JGPGetChar

; 1123 : 				{
; 1124 : 					TempInventory[8] = 0x1F;

  00758	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH

; 1125 : 				}
; 1126 : 				else

  0075d	eb 26		 jmp	 SHORT $LN222@JGPGetChar
$LN59@JGPGetChar:

; 1127 : 				{
; 1128 : 					TempInventory[8] = (lpCL->dbInventory[24] + ((lpCL->dbInventory[26] >> 7) <<  8) ) % 32;

  0075f	8b 9d ec fe ff
	ff		 mov	 ebx, DWORD PTR _lsOfs$1$[ebp]
  00765	0f b6 c0	 movzx	 eax, al
  00768	0f b6 4c 19 2a	 movzx	 ecx, BYTE PTR [ecx+ebx+42]
  0076d	83 e1 80	 and	 ecx, -128		; ffffff80H
  00770	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00773	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00778	79 05		 jns	 SHORT $LN204@JGPGetChar
  0077a	48		 dec	 eax
  0077b	83 c8 e0	 or	 eax, -32		; ffffffe0H
  0077e	40		 inc	 eax
$LN204@JGPGetChar:
  0077f	8b 9d e4 fe ff
	ff		 mov	 ebx, DWORD PTR tv2077[ebp]
$LN222@JGPGetChar:

; 1129 : 				}
; 1130 : 
; 1131 : 				if ( TempInventory[0] != (WORD)-1 )

  00785	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0078a	66 89 85 ac fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+16], ax
  00791	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv2146[ebp], eax
  00797	66 3b d1	 cmp	 dx, cx
  0079a	74 1f		 je	 SHORT $LN61@JGPGetChar

; 1132 : 				{
; 1133 : 					pCList.CharSet[1] = (BYTE)TempInventory[0];

  0079c	8a 85 9c fe ff
	ff		 mov	 al, BYTE PTR _TempInventory$[ebp]
  007a2	88 85 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+16], al

; 1134 : 					pCList.CharSet[12] |= DBI_GET_TYPE(TempInventory[0]);

  007a8	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp]
  007ae	c1 e8 04	 shr	 eax, 4
  007b1	24 f0		 and	 al, 240			; 000000f0H
  007b3	08 85 d7 fe ff
	ff		 or	 BYTE PTR _pCList$[ebp+27], al

; 1135 : 				}
; 1136 : 				else

  007b9	eb 0e		 jmp	 SHORT $LN62@JGPGetChar
$LN61@JGPGetChar:

; 1137 : 				{
; 1138 : 					pCList.CharSet[1] = -1;
; 1139 : 					pCList.CharSet[12] |= 0xF0;

  007bb	80 8d d7 fe ff
	ff f0		 or	 BYTE PTR _pCList$[ebp+27], 240 ; 000000f0H
  007c2	c6 85 cc fe ff
	ff ff		 mov	 BYTE PTR _pCList$[ebp+16], 255 ; 000000ffH
$LN62@JGPGetChar:

; 1140 : 				}
; 1141 : 
; 1142 : 				if ( TempInventory[1] != (WORD)-1 )

  007c9	66 3b f9	 cmp	 di, cx
  007cc	74 1f		 je	 SHORT $LN63@JGPGetChar

; 1143 : 				{
; 1144 : 					pCList.CharSet[2] = (BYTE)TempInventory[1];

  007ce	8a 85 9e fe ff
	ff		 mov	 al, BYTE PTR _TempInventory$[ebp+2]
  007d4	88 85 cd fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+17], al

; 1145 : 					pCList.CharSet[13] |= DBI_GET_TYPE(TempInventory[1]);

  007da	8b 85 9e fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+2]
  007e0	c1 e8 04	 shr	 eax, 4
  007e3	24 f0		 and	 al, 240			; 000000f0H
  007e5	08 85 d8 fe ff
	ff		 or	 BYTE PTR _pCList$[ebp+28], al

; 1146 : 				}
; 1147 : 				else

  007eb	eb 0e		 jmp	 SHORT $LN64@JGPGetChar
$LN63@JGPGetChar:

; 1148 : 				{
; 1149 : 					pCList.CharSet[2] = -1;
; 1150 : 					pCList.CharSet[13] |= 0xF0;

  007ed	80 8d d8 fe ff
	ff f0		 or	 BYTE PTR _pCList$[ebp+28], 240 ; 000000f0H
  007f4	c6 85 cd fe ff
	ff ff		 mov	 BYTE PTR _pCList$[ebp+17], 255 ; 000000ffH
$LN64@JGPGetChar:

; 1151 : 				}
; 1152 : 
; 1153 : 				pCList.CharSet[3] = TempInventory[2] % MAX_TYPE_ITEMS * MAX_TYPE_ITEMS + TempInventory[3] % MAX_TYPE_ITEMS;

  007fb	0f b7 cb	 movzx	 ecx, bx
  007fe	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  00804	79 05		 jns	 SHORT $LN205@JGPGetChar
  00806	49		 dec	 ecx
  00807	83 c9 f0	 or	 ecx, -16		; fffffff0H
  0080a	41		 inc	 ecx
$LN205@JGPGetChar:
  0080b	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv2090[ebp]
  00811	0f b7 c0	 movzx	 eax, ax
  00814	c0 e1 04	 shl	 cl, 4
  00817	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  0081c	79 05		 jns	 SHORT $LN206@JGPGetChar
  0081e	48		 dec	 eax
  0081f	83 c8 f0	 or	 eax, -16		; fffffff0H
  00822	40		 inc	 eax
$LN206@JGPGetChar:
  00823	02 c8		 add	 cl, al

; 1154 : 				pCList.CharSet[4] = TempInventory[4] % MAX_TYPE_ITEMS * MAX_TYPE_ITEMS + TempInventory[5] % MAX_TYPE_ITEMS;

  00825	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv2100[ebp]
  0082b	88 8d ce fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+18], cl
  00831	0f b7 c8	 movzx	 ecx, ax
  00834	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  0083a	79 05		 jns	 SHORT $LN207@JGPGetChar
  0083c	49		 dec	 ecx
  0083d	83 c9 f0	 or	 ecx, -16		; fffffff0H
  00840	41		 inc	 ecx
$LN207@JGPGetChar:
  00841	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv2113[ebp]
  00847	0f b7 c0	 movzx	 eax, ax
  0084a	c0 e1 04	 shl	 cl, 4
  0084d	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  00852	79 05		 jns	 SHORT $LN208@JGPGetChar
  00854	48		 dec	 eax
  00855	83 c8 f0	 or	 eax, -16		; fffffff0H
  00858	40		 inc	 eax
$LN208@JGPGetChar:
  00859	02 c8		 add	 cl, al

; 1155 : 				index = TempInventory[6] % MAX_TYPE_ITEMS * MAX_TYPE_ITEMS;

  0085b	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR tv2123[ebp]
  00861	0f b7 d8	 movzx	 ebx, ax
  00864	88 8d cf fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+19], cl
  0086a	81 e3 0f 00 00
	80		 and	 ebx, -2147483633	; 8000000fH
  00870	79 05		 jns	 SHORT $LN209@JGPGetChar
  00872	4b		 dec	 ebx
  00873	83 cb f0	 or	 ebx, -16		; fffffff0H
  00876	43		 inc	 ebx
$LN209@JGPGetChar:

; 1156 : 				
; 1157 : 				if (TempInventory[7]== 0x1F )

  00877	8a 85 aa fe ff
	ff		 mov	 al, BYTE PTR _TempInventory$[ebp+14]
  0087d	c0 e3 04	 shl	 bl, 4
  00880	88 85 eb fe ff
	ff		 mov	 BYTE PTR _TempInventory$19$[ebp], al
  00886	66 83 fe 1f	 cmp	 si, 31			; 0000001fH
  0088a	75 05		 jne	 SHORT $LN65@JGPGetChar

; 1158 : 				{
; 1159 : 					index |= 0x0C;

  0088c	80 cb 0c	 or	 bl, 12			; 0000000cH

; 1160 : 				}
; 1161 : 				else

  0088f	eb 07		 jmp	 SHORT $LN66@JGPGetChar
$LN65@JGPGetChar:

; 1162 : 				{
; 1163 : 					index |= (TempInventory[7] & 0x03) * 4;

  00891	24 03		 and	 al, 3
  00893	c0 e0 02	 shl	 al, 2
  00896	0a d8		 or	 bl, al
$LN66@JGPGetChar:

; 1164 : 				}
; 1165 : 
; 1166 : 				if ( (TempInventory[8] & 0x04) == 0 )

  00898	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+16]
  0089e	83 e0 04	 and	 eax, 4
  008a1	89 85 78 fe ff
	ff		 mov	 DWORD PTR tv3303[ebp], eax
  008a7	75 16		 jne	 SHORT $LN67@JGPGetChar

; 1167 : 				{
; 1168 : 					if ( TempInventory[8] == 0x1F )

  008a9	66 83 bd b4 fe
	ff ff 1f	 cmp	 WORD PTR tv2146[ebp], 31 ; 0000001fH
  008b1	74 0c		 je	 SHORT $LN67@JGPGetChar

; 1169 : 					{
; 1170 : 						index |= 0x03;
; 1171 : 					}
; 1172 : 					else
; 1173 : 					{
; 1174 : 						index |= TempInventory[8] & 0x03;

  008b3	8a 85 ac fe ff
	ff		 mov	 al, BYTE PTR _TempInventory$[ebp+16]
  008b9	24 03		 and	 al, 3
  008bb	0a d8		 or	 bl, al

; 1175 : 					}
; 1176 : 				}
; 1177 : 				else

  008bd	eb 03		 jmp	 SHORT $LN68@JGPGetChar
$LN67@JGPGetChar:

; 1178 : 				{
; 1179 : 					index |= 0x03;

  008bf	80 cb 03	 or	 bl, 3
$LN68@JGPGetChar:

; 1180 : 				}
; 1181 : 
; 1182 : 				pCList.CharSet[5] = index;
; 1183 : 				int levelindex = 0;

  008c2	33 c9		 xor	 ecx, ecx
  008c4	88 9d d0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], bl

; 1184 : 
; 1185 : 				if ( TempInventory[0] != (WORD)-1 )

  008ca	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  008cf	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
  008d5	66 3b d0	 cmp	 dx, ax
  008d8	74 2e		 je	 SHORT $LN71@JGPGetChar

; 1186 : 				{
; 1187 : 					levelindex = LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[1]));

  008da	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
  008e0	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  008e6	0f b6 44 08 11	 movzx	 eax, BYTE PTR [eax+ecx+17]
  008eb	c1 e8 03	 shr	 eax, 3
  008ee	83 e0 0f	 and	 eax, 15			; 0000000fH
  008f1	50		 push	 eax
  008f2	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  008f7	0f b6 c8	 movzx	 ecx, al
  008fa	83 c4 04	 add	 esp, 4
  008fd	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
  00903	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN71@JGPGetChar:

; 1188 : 				}
; 1189 : 
; 1190 : 				if ( TempInventory[1] != (WORD)-1 )

  00908	66 3b f8	 cmp	 di, ax
  0090b	74 34		 je	 SHORT $LN72@JGPGetChar

; 1191 : 				{
; 1192 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[4]))<<3;

  0090d	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
  00913	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  00919	0f b6 44 08 14	 movzx	 eax, BYTE PTR [eax+ecx+20]
  0091e	c1 e8 03	 shr	 eax, 3
  00921	83 e0 0f	 and	 eax, 15			; 0000000fH
  00924	50		 push	 eax
  00925	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  0092a	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  00930	83 c4 04	 add	 esp, 4
  00933	0f b6 c0	 movzx	 eax, al
  00936	c1 e0 03	 shl	 eax, 3
  00939	0b c8		 or	 ecx, eax
  0093b	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
$LN72@JGPGetChar:

; 1193 : 				}
; 1194 : 
; 1195 : 				if ( TempInventory[2] < 0x1F )

  00941	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR tv2077[ebp]
  00947	66 83 ff 1f	 cmp	 di, 31			; 0000001fH
  0094b	73 34		 jae	 SHORT $LN73@JGPGetChar

; 1196 : 				{	
; 1197 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[7]))<<6;

  0094d	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
  00953	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  00959	0f b6 44 08 17	 movzx	 eax, BYTE PTR [eax+ecx+23]
  0095e	c1 e8 03	 shr	 eax, 3
  00961	83 e0 0f	 and	 eax, 15			; 0000000fH
  00964	50		 push	 eax
  00965	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  0096a	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  00970	83 c4 04	 add	 esp, 4
  00973	0f b6 c0	 movzx	 eax, al
  00976	c1 e0 06	 shl	 eax, 6
  00979	0b c8		 or	 ecx, eax
  0097b	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
$LN73@JGPGetChar:

; 1198 : 				}
; 1199 : 
; 1200 : 				if ( TempInventory[3] < 0x1F )

  00981	66 83 bd 94 fe
	ff ff 1f	 cmp	 WORD PTR tv2090[ebp], 31 ; 0000001fH
  00989	73 34		 jae	 SHORT $LN74@JGPGetChar

; 1201 : 				{	
; 1202 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[10]))<<9;

  0098b	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
  00991	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  00997	0f b6 44 08 1a	 movzx	 eax, BYTE PTR [eax+ecx+26]
  0099c	c1 e8 03	 shr	 eax, 3
  0099f	83 e0 0f	 and	 eax, 15			; 0000000fH
  009a2	50		 push	 eax
  009a3	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  009a8	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  009ae	83 c4 04	 add	 esp, 4
  009b1	0f b6 c0	 movzx	 eax, al
  009b4	c1 e0 09	 shl	 eax, 9
  009b7	0b c8		 or	 ecx, eax
  009b9	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
$LN74@JGPGetChar:

; 1203 : 				}
; 1204 : 
; 1205 : 				if ( TempInventory[4] < 0x1F )

  009bf	66 83 bd 90 fe
	ff ff 1f	 cmp	 WORD PTR tv2100[ebp], 31 ; 0000001fH
  009c7	73 34		 jae	 SHORT $LN75@JGPGetChar

; 1206 : 				{	
; 1207 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[13]))<<12;

  009c9	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
  009cf	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  009d5	0f b6 44 08 1d	 movzx	 eax, BYTE PTR [eax+ecx+29]
  009da	c1 e8 03	 shr	 eax, 3
  009dd	83 e0 0f	 and	 eax, 15			; 0000000fH
  009e0	50		 push	 eax
  009e1	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  009e6	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  009ec	83 c4 04	 add	 esp, 4
  009ef	0f b6 c0	 movzx	 eax, al
  009f2	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  009f5	0b c8		 or	 ecx, eax
  009f7	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
$LN75@JGPGetChar:

; 1208 : 				}
; 1209 : 
; 1210 : 				if ( TempInventory[5] < 0x1F )

  009fd	66 83 bd 8c fe
	ff ff 1f	 cmp	 WORD PTR tv2113[ebp], 31 ; 0000001fH
  00a05	73 34		 jae	 SHORT $LN76@JGPGetChar

; 1211 : 				{	
; 1212 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[16]))<<15;

  00a07	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
  00a0d	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  00a13	0f b6 44 08 20	 movzx	 eax, BYTE PTR [eax+ecx+32]
  00a18	c1 e8 03	 shr	 eax, 3
  00a1b	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a1e	50		 push	 eax
  00a1f	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00a24	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  00a2a	83 c4 04	 add	 esp, 4
  00a2d	0f b6 c0	 movzx	 eax, al
  00a30	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00a33	0b c8		 or	 ecx, eax
  00a35	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
$LN76@JGPGetChar:

; 1213 : 				}
; 1214 : 
; 1215 : 				if ( TempInventory[6] < 0x1F )

  00a3b	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR tv2123[ebp]
  00a41	66 83 fa 1f	 cmp	 dx, 31			; 0000001fH
  00a45	73 34		 jae	 SHORT $LN77@JGPGetChar

; 1216 : 				{	
; 1217 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[19]))<<18;

  00a47	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
  00a4d	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  00a53	0f b6 44 08 23	 movzx	 eax, BYTE PTR [eax+ecx+35]
  00a58	c1 e8 03	 shr	 eax, 3
  00a5b	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a5e	50		 push	 eax
  00a5f	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  00a64	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  00a6a	83 c4 04	 add	 esp, 4
  00a6d	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR tv2123[ebp]
  00a73	0f b6 c0	 movzx	 eax, al
  00a76	c1 e0 12	 shl	 eax, 18			; 00000012H
  00a79	0b c8		 or	 ecx, eax
$LN77@JGPGetChar:

; 1218 : 				}
; 1219 : 
; 1220 : 				pCList.CharSet[6] = ((int)levelindex>>16 ) & 0xFF;

  00a7b	8b c1		 mov	 eax, ecx

; 1221 : 				pCList.CharSet[7] = ((int)levelindex>>8 ) & 0xFF;
; 1222 : 				pCList.CharSet[8] = levelindex & 0xFF;

  00a7d	88 8d d3 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+23], cl
  00a83	c1 f8 10	 sar	 eax, 16			; 00000010H
  00a86	88 85 d1 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+21], al
  00a8c	8b c1		 mov	 eax, ecx
  00a8e	c1 f8 08	 sar	 eax, 8

; 1223 : 
; 1224 : 				if ( TempInventory[2] > 0x0F )

  00a91	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00a96	88 85 d2 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+22], al
  00a9c	66 83 ff 0f	 cmp	 di, 15			; 0000000fH
  00aa0	0f b6 85 ea fe
	ff ff		 movzx	 eax, BYTE PTR _pCList$3$[ebp]
  00aa7	0f 47 c1	 cmova	 eax, ecx

; 1225 : 					pCList.CharSet[9] = 0x80;
; 1226 : 
; 1227 : 				if ( TempInventory[3] > 0x0F )

  00aaa	66 83 bd 94 fe
	ff ff 0f	 cmp	 WORD PTR tv2090[ebp], 15 ; 0000000fH
  00ab2	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al
  00ab8	76 08		 jbe	 SHORT $LN79@JGPGetChar

; 1228 : 					pCList.CharSet[9] |= 0x40;

  00aba	0c 40		 or	 al, 64			; 00000040H
  00abc	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al
$LN79@JGPGetChar:

; 1229 : 
; 1230 : 				if ( TempInventory[4] > 0x0F )

  00ac2	66 83 bd 90 fe
	ff ff 0f	 cmp	 WORD PTR tv2100[ebp], 15 ; 0000000fH
  00aca	76 08		 jbe	 SHORT $LN80@JGPGetChar

; 1231 : 					pCList.CharSet[9] |= 0x20;

  00acc	0c 20		 or	 al, 32			; 00000020H
  00ace	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al
$LN80@JGPGetChar:

; 1232 : 
; 1233 : 				if ( TempInventory[5] > 0x0F )

  00ad4	66 83 bd 8c fe
	ff ff 0f	 cmp	 WORD PTR tv2113[ebp], 15 ; 0000000fH
  00adc	76 08		 jbe	 SHORT $LN81@JGPGetChar

; 1234 : 					pCList.CharSet[9] |= 0x10;

  00ade	0c 10		 or	 al, 16			; 00000010H
  00ae0	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al
$LN81@JGPGetChar:

; 1235 : 
; 1236 : 				if ( TempInventory[6] > 0x0F )

  00ae6	66 83 fa 0f	 cmp	 dx, 15			; 0000000fH
  00aea	76 08		 jbe	 SHORT $LN82@JGPGetChar

; 1237 : 					pCList.CharSet[9] |= 0x8;

  00aec	0c 08		 or	 al, 8
  00aee	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al
$LN82@JGPGetChar:

; 1238 : 
; 1239 : 				if ( (TempInventory[7] >= 3 && TempInventory[7] <= 6) || TempInventory[7] == 0x1E)

  00af4	66 83 fe 03	 cmp	 si, 3
  00af8	72 06		 jb	 SHORT $LN85@JGPGetChar
  00afa	66 83 fe 06	 cmp	 si, 6
  00afe	76 06		 jbe	 SHORT $LN84@JGPGetChar
$LN85@JGPGetChar:
  00b00	66 83 fe 1e	 cmp	 si, 30			; 0000001eH
  00b04	75 2d		 jne	 SHORT $LN87@JGPGetChar
$LN84@JGPGetChar:

; 1240 : 				{
; 1241 : 					pCList.CharSet[5] |= 0x0C;

  00b06	80 cb 0c	 or	 bl, 12			; 0000000cH
  00b09	88 9d d0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], bl

; 1242 : 					
; 1243 : 					if ( TempInventory[7] == 0x1E )

  00b0f	66 83 fe 1e	 cmp	 si, 30			; 0000001eH
  00b13	75 0a		 jne	 SHORT $LN86@JGPGetChar

; 1244 : 					{
; 1245 : 						pCList.CharSet[9] |= 0x05;

  00b15	0c 05		 or	 al, 5
  00b17	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al

; 1246 : 					}
; 1247 : 					else

  00b1d	eb 2f		 jmp	 SHORT $LN91@JGPGetChar
$LN86@JGPGetChar:

; 1248 : 					{
; 1249 : 						pCList.CharSet[9] |= (TempInventory[7]-2) & 0x07;

  00b1f	8a 8d eb fe ff
	ff		 mov	 cl, BYTE PTR _TempInventory$19$[ebp]
  00b25	80 e9 02	 sub	 cl, 2
  00b28	80 e1 07	 and	 cl, 7
  00b2b	0a c1		 or	 al, cl
  00b2d	88 85 d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], al
$LN87@JGPGetChar:

; 1250 : 					}
; 1251 : 				}
; 1252 : 
; 1253 : 				if ( (TempInventory[7] >= 0x24 && TempInventory[7] <= 0x28) || TempInventory[7] == 0x2B )

  00b33	66 83 fe 24	 cmp	 si, 36			; 00000024H
  00b37	72 06		 jb	 SHORT $LN90@JGPGetChar
  00b39	66 83 fe 28	 cmp	 si, 40			; 00000028H
  00b3d	76 06		 jbe	 SHORT $LN89@JGPGetChar
$LN90@JGPGetChar:
  00b3f	66 83 fe 2b	 cmp	 si, 43			; 0000002bH
  00b43	75 09		 jne	 SHORT $LN91@JGPGetChar
$LN89@JGPGetChar:

; 1254 : 				{
; 1255 : 					pCList.CharSet[5] |= 0x0C;

  00b45	80 cb 0c	 or	 bl, 12			; 0000000cH
  00b48	88 9d d0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], bl
$LN91@JGPGetChar:

; 1256 : 					pCList.CharSet[16] |= ((TempInventory[7] - 0x23) & 7) << 2;
; 1257 : 
; 1258 : 					if( TempInventory[7] == 0x2B )
; 1259 : 					{
; 1260 : 						pCList.CharSet[16] |= 0x18;
; 1261 : 					}
; 1262 : 				}
; 1263 : 
; 1264 : 				pCList.CharSet[10] = 0;
; 1265 : 
; 1266 : 				if ( (TempInventory[8] & 0x03) != 0 && TempInventory[8] != 0x1F )

  00b4e	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv2146[ebp]
  00b54	32 c0		 xor	 al, al
  00b56	f6 85 ac fe ff
	ff 03		 test	 BYTE PTR _TempInventory$[ebp+16], 3
  00b5d	88 85 d5 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+25], al
  00b63	74 15		 je	 SHORT $LN92@JGPGetChar
  00b65	66 83 f9 1f	 cmp	 cx, 31			; 0000001fH
  00b69	0f b6 c0	 movzx	 eax, al
  00b6c	bb 01 00 00 00	 mov	 ebx, 1
  00b71	0f 45 c3	 cmovne	 eax, ebx
  00b74	88 85 d5 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+25], al
$LN92@JGPGetChar:

; 1267 : 					pCList.CharSet[10] |= 1;
; 1268 : 
; 1269 : 				pCList.CharSet[11] = 0;
; 1270 : 
; 1271 : 				if ( (TempInventory[8] & 0x04) != 0 && TempInventory[8] != 0x1F )

  00b7a	66 83 bd 78 fe
	ff ff 00	 cmp	 WORD PTR tv3303[ebp], 0
  00b82	c6 85 d6 fe ff
	ff 00		 mov	 BYTE PTR _pCList$[ebp+26], 0
  00b89	74 0d		 je	 SHORT $LN93@JGPGetChar
  00b8b	66 83 f9 1f	 cmp	 cx, 31			; 0000001fH
  00b8f	74 07		 je	 SHORT $LN93@JGPGetChar

; 1272 : 					pCList.CharSet[12] |= 1;

  00b91	80 8d d7 fe ff
	ff 01		 or	 BYTE PTR _pCList$[ebp+27], 1
$LN93@JGPGetChar:

; 1273 : 
; 1274 : 				if ( TempInventory[2] >= 0x1F ) pCList.CharSet[13] |= 0x0F;

  00b98	66 83 ff 1f	 cmp	 di, 31			; 0000001fH
  00b9c	72 07		 jb	 SHORT $LN94@JGPGetChar
  00b9e	80 8d d8 fe ff
	ff 0f		 or	 BYTE PTR _pCList$[ebp+28], 15 ; 0000000fH
$LN94@JGPGetChar:

; 1275 : 				if ( TempInventory[3] >= 0x1F ) pCList.CharSet[14] |= 0xF0;

  00ba5	66 83 bd 94 fe
	ff ff 1f	 cmp	 WORD PTR tv2090[ebp], 31 ; 0000001fH
  00bad	8a 85 d9 fe ff
	ff		 mov	 al, BYTE PTR _pCList$[ebp+29]
  00bb3	72 08		 jb	 SHORT $LN95@JGPGetChar
  00bb5	0c f0		 or	 al, 240			; 000000f0H
  00bb7	88 85 d9 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+29], al
$LN95@JGPGetChar:

; 1276 : 				if ( TempInventory[4] >= 0x1F ) pCList.CharSet[14] |= 0x0F;

  00bbd	66 83 bd 90 fe
	ff ff 1f	 cmp	 WORD PTR tv2100[ebp], 31 ; 0000001fH
  00bc5	72 08		 jb	 SHORT $LN96@JGPGetChar
  00bc7	0c 0f		 or	 al, 15			; 0000000fH
  00bc9	88 85 d9 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+29], al
$LN96@JGPGetChar:

; 1277 : 				if ( TempInventory[5] >= 0x1F ) pCList.CharSet[15] |= 0xF0;

  00bcf	66 83 bd 8c fe
	ff ff 1f	 cmp	 WORD PTR tv2113[ebp], 31 ; 0000001fH
  00bd7	8a 85 da fe ff
	ff		 mov	 al, BYTE PTR _pCList$[ebp+30]
  00bdd	72 08		 jb	 SHORT $LN97@JGPGetChar
  00bdf	0c f0		 or	 al, 240			; 000000f0H
  00be1	88 85 da fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+30], al
$LN97@JGPGetChar:

; 1278 : 				if ( TempInventory[6] >= 0x1F ) pCList.CharSet[15] |= 0x0F;

  00be7	66 83 fa 1f	 cmp	 dx, 31			; 0000001fH
  00beb	72 08		 jb	 SHORT $LN98@JGPGetChar
  00bed	0c 0f		 or	 al, 15			; 0000000fH
  00bef	88 85 da fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+30], al
$LN98@JGPGetChar:

; 1279 : 
; 1280 : 				pCList.CharSet[16] = 0;

  00bf5	66 c7 85 db fe
	ff ff 00 00	 mov	 WORD PTR _pCList$[ebp+31], 0

; 1281 : 				pCList.CharSet[17] = 0;
; 1282 : 			}
; 1283 : 			else	// Case DB 3

  00bfe	e9 62 09 00 00	 jmp	 $LN193@JGPGetChar
$LN41@JGPGetChar:

; 1284 : 			{
; 1285 : 				if ( lpCL->dbInventory[0] == (BYTE)-1 && (lpCL->dbInventory[2]& 0x80) == 0x80 && (lpCL->dbInventory[3]& 0xF0) == 0xF0  )

  00c03	8a 4c 3e 10	 mov	 cl, BYTE PTR [esi+edi+16]
  00c07	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  00c0a	75 21		 jne	 SHORT $LN99@JGPGetChar
  00c0c	f6 44 3e 12 80	 test	 BYTE PTR [esi+edi+18], 128 ; 00000080H
  00c11	74 1a		 je	 SHORT $LN99@JGPGetChar
  00c13	8a 44 3e 13	 mov	 al, BYTE PTR [esi+edi+19]
  00c17	24 f0		 and	 al, 240			; 000000f0H
  00c19	3c f0		 cmp	 al, 240			; 000000f0H
  00c1b	75 10		 jne	 SHORT $LN99@JGPGetChar

; 1286 : 				{
; 1287 : 					TempInventory[0] = -1;
; 1288 : 				}
; 1289 : 				else

  00c1d	8b 9d ec fe ff
	ff		 mov	 ebx, DWORD PTR _lsOfs$1$[ebp]
  00c23	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00c28	66 8b fa	 mov	 di, dx
  00c2b	eb 2d		 jmp	 SHORT $LN223@JGPGetChar
$LN99@JGPGetChar:

; 1290 : 				{
; 1291 : 					TempInventory[0] = (lpCL->dbInventory[0] + (lpCL->dbInventory[2]&0x80)*2)+ (lpCL->dbInventory[3]&0xF0)*32;

  00c2d	8a 44 3e 13	 mov	 al, BYTE PTR [esi+edi+19]
  00c31	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00c36	8b 9d ec fe ff
	ff		 mov	 ebx, DWORD PTR _lsOfs$1$[ebp]
  00c3c	24 f0		 and	 al, 240			; 000000f0H
  00c3e	0f b6 f8	 movzx	 edi, al
  00c41	66 c1 e7 04	 shl	 di, 4
  00c45	8a 44 1e 12	 mov	 al, BYTE PTR [esi+ebx+18]
  00c49	24 80		 and	 al, 128			; 00000080H
  00c4b	0f b6 c0	 movzx	 eax, al
  00c4e	66 03 f8	 add	 di, ax
  00c51	0f b6 c1	 movzx	 eax, cl
  00c54	66 03 ff	 add	 di, di
  00c57	66 03 f8	 add	 di, ax
$LN223@JGPGetChar:

; 1292 : 				}
; 1293 : 
; 1294 : 				if ( lpCL->dbInventory[4] == (BYTE)-1 && (lpCL->dbInventory[6]& 0x80) == 0x80 && (lpCL->dbInventory[7]& 0xF0) == 0xF0  )

  00c5a	8a 4c 1e 14	 mov	 cl, BYTE PTR [esi+ebx+20]
  00c5e	66 89 bd 9c fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp], di
  00c65	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  00c68	75 11		 jne	 SHORT $LN101@JGPGetChar
  00c6a	f6 44 1e 16 80	 test	 BYTE PTR [esi+ebx+22], 128 ; 00000080H
  00c6f	74 0a		 je	 SHORT $LN101@JGPGetChar
  00c71	8a 44 1e 17	 mov	 al, BYTE PTR [esi+ebx+23]
  00c75	24 f0		 and	 al, 240			; 000000f0H
  00c77	3c f0		 cmp	 al, 240			; 000000f0H
  00c79	74 22		 je	 SHORT $LN224@JGPGetChar
$LN101@JGPGetChar:

; 1295 : 				{
; 1296 : 					TempInventory[1] = -1;
; 1297 : 				}
; 1298 : 				else
; 1299 : 				{
; 1300 : 					TempInventory[1] = (lpCL->dbInventory[4] + (lpCL->dbInventory[6]&0x80)*2)+ (lpCL->dbInventory[7]&0xF0)*32;

  00c7b	8a 44 1e 17	 mov	 al, BYTE PTR [esi+ebx+23]
  00c7f	24 f0		 and	 al, 240			; 000000f0H
  00c81	0f b6 d0	 movzx	 edx, al
  00c84	8a 44 1e 16	 mov	 al, BYTE PTR [esi+ebx+22]
  00c88	24 80		 and	 al, 128			; 00000080H
  00c8a	66 c1 e2 04	 shl	 dx, 4
  00c8e	0f b6 c0	 movzx	 eax, al
  00c91	66 03 d0	 add	 dx, ax
  00c94	0f b6 c1	 movzx	 eax, cl
  00c97	66 03 d2	 add	 dx, dx
  00c9a	66 03 d0	 add	 dx, ax
$LN224@JGPGetChar:

; 1301 : 				}
; 1302 : 
; 1303 : 				if ( lpCL->dbInventory[8] == (BYTE)-1 && (lpCL->dbInventory[10]& 0x80) == 0x80 && (lpCL->dbInventory[11]& 0xF0) == 0xF0  )

  00c9d	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
  00ca3	66 89 95 9e fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+2], dx
  00caa	66 89 95 ba fe
	ff ff		 mov	 WORD PTR _TempInventory$4$[ebp], dx
  00cb1	8a 5c 0e 18	 mov	 bl, BYTE PTR [esi+ecx+24]
  00cb5	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00cb8	75 18		 jne	 SHORT $LN103@JGPGetChar
  00cba	f6 44 0e 1a 80	 test	 BYTE PTR [esi+ecx+26], 128 ; 00000080H
  00cbf	74 11		 je	 SHORT $LN103@JGPGetChar
  00cc1	8a 44 0e 1b	 mov	 al, BYTE PTR [esi+ecx+27]
  00cc5	24 f0		 and	 al, 240			; 000000f0H
  00cc7	3c f0		 cmp	 al, 240			; 000000f0H
  00cc9	75 07		 jne	 SHORT $LN103@JGPGetChar

; 1304 : 				{
; 1305 : 					TempInventory[2] = 0x1FF;

  00ccb	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH

; 1306 : 				}
; 1307 : 				else

  00cd0	eb 3a		 jmp	 SHORT $LN225@JGPGetChar
$LN103@JGPGetChar:

; 1308 : 				{
; 1309 : 					TempInventory[2] = ((lpCL->dbInventory[8] + (lpCL->dbInventory[10]&0x80)*2)+ (lpCL->dbInventory[11]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  00cd2	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  00cd8	0f b6 4c 0e 1b	 movzx	 ecx, BYTE PTR [esi+ecx+27]
  00cdd	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00ce3	c1 e1 04	 shl	 ecx, 4
  00ce6	0f b6 44 06 1a	 movzx	 eax, BYTE PTR [esi+eax+26]
  00ceb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00cf0	03 c8		 add	 ecx, eax
  00cf2	0f b6 c3	 movzx	 eax, bl
  00cf5	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00cf8	25 ff 01 00 80	 and	 eax, -2147483137	; 800001ffH
  00cfd	79 07		 jns	 SHORT $LN210@JGPGetChar
  00cff	48		 dec	 eax
  00d00	0d 00 fe ff ff	 or	 eax, -512		; fffffe00H
  00d05	40		 inc	 eax
$LN210@JGPGetChar:
  00d06	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN225@JGPGetChar:

; 1310 : 				}
; 1311 : 
; 1312 : 				if ( lpCL->dbInventory[12] == (BYTE)-1 && (lpCL->dbInventory[14]& 0x80) == 0x80 && (lpCL->dbInventory[15]& 0xF0) == 0xF0  )

  00d0c	8a 5c 0e 1c	 mov	 bl, BYTE PTR [esi+ecx+28]
  00d10	66 89 85 a0 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+4], ax
  00d17	89 85 68 fe ff
	ff		 mov	 DWORD PTR tv2452[ebp], eax
  00d1d	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00d20	75 18		 jne	 SHORT $LN105@JGPGetChar
  00d22	f6 44 0e 1e 80	 test	 BYTE PTR [esi+ecx+30], 128 ; 00000080H
  00d27	74 11		 je	 SHORT $LN105@JGPGetChar
  00d29	8a 44 0e 1f	 mov	 al, BYTE PTR [esi+ecx+31]
  00d2d	24 f0		 and	 al, 240			; 000000f0H
  00d2f	3c f0		 cmp	 al, 240			; 000000f0H
  00d31	75 07		 jne	 SHORT $LN105@JGPGetChar

; 1313 : 				{
; 1314 : 					TempInventory[3] = 0x1FF;

  00d33	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH

; 1315 : 				}
; 1316 : 				else

  00d38	eb 3a		 jmp	 SHORT $LN226@JGPGetChar
$LN105@JGPGetChar:

; 1317 : 				{
; 1318 : 					TempInventory[3] = ((lpCL->dbInventory[12] + (lpCL->dbInventory[14]&0x80)*2)+ (lpCL->dbInventory[15]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  00d3a	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  00d40	0f b6 4c 0e 1f	 movzx	 ecx, BYTE PTR [esi+ecx+31]
  00d45	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00d4b	c1 e1 04	 shl	 ecx, 4
  00d4e	0f b6 44 06 1e	 movzx	 eax, BYTE PTR [esi+eax+30]
  00d53	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00d58	03 c8		 add	 ecx, eax
  00d5a	0f b6 c3	 movzx	 eax, bl
  00d5d	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00d60	25 ff 01 00 80	 and	 eax, -2147483137	; 800001ffH
  00d65	79 07		 jns	 SHORT $LN211@JGPGetChar
  00d67	48		 dec	 eax
  00d68	0d 00 fe ff ff	 or	 eax, -512		; fffffe00H
  00d6d	40		 inc	 eax
$LN211@JGPGetChar:
  00d6e	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN226@JGPGetChar:

; 1319 : 				}
; 1320 : 
; 1321 : 				if ( lpCL->dbInventory[16] == (BYTE)-1 && (lpCL->dbInventory[18]& 0x80) == 0x80 && (lpCL->dbInventory[19]& 0xF0) == 0xF0  )

  00d74	8a 5c 0e 20	 mov	 bl, BYTE PTR [esi+ecx+32]
  00d78	66 89 85 a2 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+6], ax
  00d7f	89 85 64 fe ff
	ff		 mov	 DWORD PTR tv2469[ebp], eax
  00d85	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00d88	75 18		 jne	 SHORT $LN107@JGPGetChar
  00d8a	f6 44 0e 22 80	 test	 BYTE PTR [esi+ecx+34], 128 ; 00000080H
  00d8f	74 11		 je	 SHORT $LN107@JGPGetChar
  00d91	8a 44 0e 23	 mov	 al, BYTE PTR [esi+ecx+35]
  00d95	24 f0		 and	 al, 240			; 000000f0H
  00d97	3c f0		 cmp	 al, 240			; 000000f0H
  00d99	75 07		 jne	 SHORT $LN107@JGPGetChar

; 1322 : 				{
; 1323 : 					TempInventory[4] = 0x1FF;

  00d9b	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH

; 1324 : 				}
; 1325 : 				else

  00da0	eb 3a		 jmp	 SHORT $LN227@JGPGetChar
$LN107@JGPGetChar:

; 1326 : 				{
; 1327 : 					TempInventory[4] = ((lpCL->dbInventory[16] + (lpCL->dbInventory[18]&0x80)*2)+ (lpCL->dbInventory[19]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  00da2	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  00da8	0f b6 4c 0e 23	 movzx	 ecx, BYTE PTR [esi+ecx+35]
  00dad	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00db3	c1 e1 04	 shl	 ecx, 4
  00db6	0f b6 44 06 22	 movzx	 eax, BYTE PTR [esi+eax+34]
  00dbb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00dc0	03 c8		 add	 ecx, eax
  00dc2	0f b6 c3	 movzx	 eax, bl
  00dc5	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00dc8	25 ff 01 00 80	 and	 eax, -2147483137	; 800001ffH
  00dcd	79 07		 jns	 SHORT $LN212@JGPGetChar
  00dcf	48		 dec	 eax
  00dd0	0d 00 fe ff ff	 or	 eax, -512		; fffffe00H
  00dd5	40		 inc	 eax
$LN212@JGPGetChar:
  00dd6	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN227@JGPGetChar:

; 1328 : 				}
; 1329 : 
; 1330 : 				if ( lpCL->dbInventory[20] == (BYTE)-1 && (lpCL->dbInventory[22]& 0x80) == 0x80 && (lpCL->dbInventory[23]& 0xF0) == 0xF0  )

  00ddc	8a 5c 0e 24	 mov	 bl, BYTE PTR [esi+ecx+36]
  00de0	66 89 85 a4 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+8], ax
  00de7	89 85 54 fe ff
	ff		 mov	 DWORD PTR tv2487[ebp], eax
  00ded	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00df0	75 18		 jne	 SHORT $LN109@JGPGetChar
  00df2	f6 44 0e 26 80	 test	 BYTE PTR [esi+ecx+38], 128 ; 00000080H
  00df7	74 11		 je	 SHORT $LN109@JGPGetChar
  00df9	8a 44 0e 27	 mov	 al, BYTE PTR [esi+ecx+39]
  00dfd	24 f0		 and	 al, 240			; 000000f0H
  00dff	3c f0		 cmp	 al, 240			; 000000f0H
  00e01	75 07		 jne	 SHORT $LN109@JGPGetChar

; 1331 : 				{
; 1332 : 					TempInventory[5] = 0x1FF;

  00e03	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH

; 1333 : 				}
; 1334 : 				else

  00e08	eb 3a		 jmp	 SHORT $LN228@JGPGetChar
$LN109@JGPGetChar:

; 1335 : 				{
; 1336 : 					TempInventory[5] = ((lpCL->dbInventory[20] + (lpCL->dbInventory[22]&0x80)*2)+ (lpCL->dbInventory[23]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  00e0a	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  00e10	0f b6 4c 0e 27	 movzx	 ecx, BYTE PTR [esi+ecx+39]
  00e15	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00e1b	c1 e1 04	 shl	 ecx, 4
  00e1e	0f b6 44 06 26	 movzx	 eax, BYTE PTR [esi+eax+38]
  00e23	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00e28	03 c8		 add	 ecx, eax
  00e2a	0f b6 c3	 movzx	 eax, bl
  00e2d	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00e30	25 ff 01 00 80	 and	 eax, -2147483137	; 800001ffH
  00e35	79 07		 jns	 SHORT $LN213@JGPGetChar
  00e37	48		 dec	 eax
  00e38	0d 00 fe ff ff	 or	 eax, -512		; fffffe00H
  00e3d	40		 inc	 eax
$LN213@JGPGetChar:
  00e3e	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN228@JGPGetChar:

; 1337 : 				}
; 1338 : 
; 1339 : 				if ( lpCL->dbInventory[24] == (BYTE)-1 && (lpCL->dbInventory[26]& 0x80) == 0x80 && (lpCL->dbInventory[27]& 0xF0) == 0xF0  )

  00e44	8a 5c 0e 28	 mov	 bl, BYTE PTR [esi+ecx+40]
  00e48	66 89 85 a6 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+10], ax
  00e4f	89 85 50 fe ff
	ff		 mov	 DWORD PTR tv2510[ebp], eax
  00e55	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00e58	75 18		 jne	 SHORT $LN111@JGPGetChar
  00e5a	f6 44 0e 2a 80	 test	 BYTE PTR [esi+ecx+42], 128 ; 00000080H
  00e5f	74 11		 je	 SHORT $LN111@JGPGetChar
  00e61	8a 44 0e 2b	 mov	 al, BYTE PTR [esi+ecx+43]
  00e65	24 f0		 and	 al, 240			; 000000f0H
  00e67	3c f0		 cmp	 al, 240			; 000000f0H
  00e69	75 07		 jne	 SHORT $LN111@JGPGetChar

; 1340 : 				{
; 1341 : 					TempInventory[6] = 0x1FF;

  00e6b	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH

; 1342 : 				}
; 1343 : 				else

  00e70	eb 3a		 jmp	 SHORT $LN229@JGPGetChar
$LN111@JGPGetChar:

; 1344 : 				{
; 1345 : 					TempInventory[6] = ((lpCL->dbInventory[24] + (lpCL->dbInventory[26]&0x80)*2)+ (lpCL->dbInventory[27]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  00e72	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  00e78	0f b6 4c 0e 2b	 movzx	 ecx, BYTE PTR [esi+ecx+43]
  00e7d	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00e83	c1 e1 04	 shl	 ecx, 4
  00e86	0f b6 44 06 2a	 movzx	 eax, BYTE PTR [esi+eax+42]
  00e8b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00e90	03 c8		 add	 ecx, eax
  00e92	0f b6 c3	 movzx	 eax, bl
  00e95	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00e98	25 ff 01 00 80	 and	 eax, -2147483137	; 800001ffH
  00e9d	79 07		 jns	 SHORT $LN214@JGPGetChar
  00e9f	48		 dec	 eax
  00ea0	0d 00 fe ff ff	 or	 eax, -512		; fffffe00H
  00ea5	40		 inc	 eax
$LN214@JGPGetChar:
  00ea6	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN229@JGPGetChar:

; 1346 : 				}
; 1347 : 
; 1348 : 				if ( lpCL->dbInventory[28] == (BYTE)-1 && (lpCL->dbInventory[30]& 0x80) == 0x80 && (lpCL->dbInventory[31]& 0xF0) == 0xF0  )

  00eac	8a 5c 0e 2c	 mov	 bl, BYTE PTR [esi+ecx+44]
  00eb0	66 89 85 a8 fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+12], ax
  00eb7	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv2527[ebp], eax
  00ebd	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00ec0	75 18		 jne	 SHORT $LN113@JGPGetChar
  00ec2	f6 44 0e 2e 80	 test	 BYTE PTR [esi+ecx+46], 128 ; 00000080H
  00ec7	74 11		 je	 SHORT $LN113@JGPGetChar
  00ec9	8a 44 0e 2f	 mov	 al, BYTE PTR [esi+ecx+47]
  00ecd	24 f0		 and	 al, 240			; 000000f0H
  00ecf	3c f0		 cmp	 al, 240			; 000000f0H
  00ed1	75 07		 jne	 SHORT $LN113@JGPGetChar

; 1349 : 				{
; 1350 : 					TempInventory[7] = 0x1FF;

  00ed3	be ff 01 00 00	 mov	 esi, 511		; 000001ffH

; 1351 : 				}
; 1352 : 				else

  00ed8	eb 3c		 jmp	 SHORT $LN230@JGPGetChar
$LN113@JGPGetChar:

; 1353 : 				{
; 1354 : 					TempInventory[7] = ((lpCL->dbInventory[28] + (lpCL->dbInventory[30]&0x80)*2)+ (lpCL->dbInventory[31]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  00eda	0f b6 4c 0e 2f	 movzx	 ecx, BYTE PTR [esi+ecx+47]
  00edf	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  00ee5	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00eeb	c1 e1 04	 shl	 ecx, 4
  00eee	0f b6 44 06 2e	 movzx	 eax, BYTE PTR [esi+eax+46]
  00ef3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00ef8	03 c8		 add	 ecx, eax
  00efa	0f b6 c3	 movzx	 eax, bl
  00efd	8d 34 48	 lea	 esi, DWORD PTR [eax+ecx*2]
  00f00	81 e6 ff 01 00
	80		 and	 esi, -2147483137	; 800001ffH
  00f06	79 08		 jns	 SHORT $LN215@JGPGetChar
  00f08	4e		 dec	 esi
  00f09	81 ce 00 fe ff
	ff		 or	 esi, -512		; fffffe00H
  00f0f	46		 inc	 esi
$LN215@JGPGetChar:
  00f10	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lsOfs$1$[ebp]
$LN230@JGPGetChar:

; 1355 : 				}
; 1356 : 
; 1357 : 				if ( lpCL->dbInventory[32] == (BYTE)-1 && (lpCL->dbInventory[34]& 0x80) == 0x80 && (lpCL->dbInventory[35]& 0xF0) == 0xF0  )

  00f16	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  00f1c	66 89 b5 aa fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+14], si
  00f23	89 b5 e4 fe ff
	ff		 mov	 DWORD PTR tv2640[ebp], esi
  00f29	8a 5c 08 30	 mov	 bl, BYTE PTR [eax+ecx+48]
  00f2d	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00f30	75 1e		 jne	 SHORT $LN115@JGPGetChar
  00f32	f6 44 08 32 80	 test	 BYTE PTR [eax+ecx+50], 128 ; 00000080H
  00f37	74 17		 je	 SHORT $LN115@JGPGetChar
  00f39	8a 44 08 33	 mov	 al, BYTE PTR [eax+ecx+51]
  00f3d	24 f0		 and	 al, 240			; 000000f0H
  00f3f	3c f0		 cmp	 al, 240			; 000000f0H
  00f41	75 07		 jne	 SHORT $LN190@JGPGetChar

; 1358 : 				{
; 1359 : 					TempInventory[8] = 0x1FF;

  00f43	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH

; 1360 : 				}
; 1361 : 				else

  00f48	eb 40		 jmp	 SHORT $LN231@JGPGetChar
$LN190@JGPGetChar:
  00f4a	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
$LN115@JGPGetChar:

; 1362 : 				{
; 1363 : 					TempInventory[8] = ((lpCL->dbInventory[32] + (lpCL->dbInventory[34]&0x80)*2)+ (lpCL->dbInventory[35]&0xF0)*32)%MAX_SUBTYPE_ITEMS;

  00f50	0f b6 4c 08 33	 movzx	 ecx, BYTE PTR [eax+ecx+51]
  00f55	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _lsOfs$1$[ebp]
  00f5b	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00f61	c1 e1 04	 shl	 ecx, 4
  00f64	0f b6 44 30 32	 movzx	 eax, BYTE PTR [eax+esi+50]
  00f69	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00f6e	03 c8		 add	 ecx, eax
  00f70	0f b6 c3	 movzx	 eax, bl
  00f73	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00f76	25 ff 01 00 80	 and	 eax, -2147483137	; 800001ffH
  00f7b	79 07		 jns	 SHORT $LN216@JGPGetChar
  00f7d	48		 dec	 eax
  00f7e	0d 00 fe ff ff	 or	 eax, -512		; fffffe00H
  00f83	40		 inc	 eax
$LN216@JGPGetChar:
  00f84	8b b5 e4 fe ff
	ff		 mov	 esi, DWORD PTR tv2640[ebp]
$LN231@JGPGetChar:

; 1364 : 				}
; 1365 : 
; 1366 : 				pCList.CharSet[12] |= DBI_GET_TYPE(TempInventory[0]);

  00f8a	8a 8d d7 fe ff
	ff		 mov	 cl, BYTE PTR _pCList$[ebp+27]
  00f90	66 89 85 ac fe
	ff ff		 mov	 WORD PTR _TempInventory$[ebp+16], ax
  00f97	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv2751[ebp], eax
  00f9d	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp]
  00fa3	c1 e8 04	 shr	 eax, 4
  00fa6	24 f0		 and	 al, 240			; 000000f0H
  00fa8	0a c8		 or	 cl, al

; 1367 : 				pCList.CharSet[1] = TempInventory[0] % 256;

  00faa	0f b7 c7	 movzx	 eax, di
  00fad	88 8d ea fe ff
	ff		 mov	 BYTE PTR _pCList$7$[ebp], cl
  00fb3	88 8d d7 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+27], cl
  00fb9	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00fbe	79 07		 jns	 SHORT $LN217@JGPGetChar
  00fc0	48		 dec	 eax
  00fc1	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00fc6	40		 inc	 eax
$LN217@JGPGetChar:

; 1368 : 
; 1369 : 				pCList.CharSet[13] |= DBI_GET_TYPE(TempInventory[1]);

  00fc7	8a 8d d8 fe ff
	ff		 mov	 cl, BYTE PTR _pCList$[ebp+28]
  00fcd	88 85 cc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+16], al
  00fd3	8b 85 9e fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+2]
  00fd9	c1 e8 04	 shr	 eax, 4
  00fdc	24 f0		 and	 al, 240			; 000000f0H
  00fde	0a c8		 or	 cl, al

; 1370 : 				pCList.CharSet[2] = TempInventory[1] % 256;

  00fe0	0f b7 c2	 movzx	 eax, dx
  00fe3	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00fe8	79 07		 jns	 SHORT $LN218@JGPGetChar
  00fea	48		 dec	 eax
  00feb	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00ff0	40		 inc	 eax
$LN218@JGPGetChar:
  00ff1	88 85 cd fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+17], al

; 1371 : 
; 1372 : 				pCList.CharSet[13] |= (int)(TempInventory[2] & 0x1E0) >> 5;

  00ff7	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+4]
  00ffd	c1 e8 05	 shr	 eax, 5

; 1373 : 				pCList.CharSet[9] |= (int)(TempInventory[2] & 0x10) << 3;
; 1374 : 				pCList.CharSet[3] |= (int)(TempInventory[2] & 0x0F) << 4;

  01000	8a 95 ce fe ff
	ff		 mov	 dl, BYTE PTR _pCList$[ebp+18]
  01006	24 0f		 and	 al, 15			; 0000000fH
  01008	0a c8		 or	 cl, al

; 1375 : 
; 1376 : 				pCList.CharSet[14] |= (int)(TempInventory[3] & 0x1E0) >> 1;

  0100a	8a 9d d9 fe ff
	ff		 mov	 bl, BYTE PTR _pCList$[ebp+29]
  01010	8a 85 a0 fe ff
	ff		 mov	 al, BYTE PTR _TempInventory$[ebp+4]
  01016	8a f8		 mov	 bh, al
  01018	88 8d d8 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+28], cl
  0101e	c0 e0 04	 shl	 al, 4
  01021	80 e7 f0	 and	 bh, 240			; 000000f0H
  01024	0a d0		 or	 dl, al

; 1377 : 				pCList.CharSet[9] |= (int)(TempInventory[3] & 0x10) << 2;

  01026	8a 8d a2 fe ff
	ff		 mov	 cl, BYTE PTR _TempInventory$[ebp+6]
  0102c	8b 85 a2 fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+6]
  01032	d1 e8		 shr	 eax, 1
  01034	24 f0		 and	 al, 240			; 000000f0H
  01036	c0 e7 03	 shl	 bh, 3
  01039	0a d8		 or	 bl, al
  0103b	8a c1		 mov	 al, cl
  0103d	24 10		 and	 al, 16			; 00000010H

; 1378 : 				pCList.CharSet[3] |= (int)(TempInventory[3] & 0x0F);

  0103f	80 e1 0f	 and	 cl, 15			; 0000000fH
  01042	c0 e0 02	 shl	 al, 2
  01045	0a d1		 or	 dl, cl

; 1379 : 
; 1380 : 				pCList.CharSet[14] |= (int)(TempInventory[4] & 0x1E0) >> 5;
; 1381 : 				pCList.CharSet[9] |= (int)(TempInventory[4] & 0x10) << 1;

  01047	8a 8d a4 fe ff
	ff		 mov	 cl, BYTE PTR _TempInventory$[ebp+8]
  0104d	0a f8		 or	 bh, al
  0104f	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+8]
  01055	c1 e8 05	 shr	 eax, 5
  01058	24 0f		 and	 al, 15			; 0000000fH
  0105a	88 95 ce fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+18], dl

; 1382 : 				pCList.CharSet[4] |= (int)(TempInventory[4] & 0x0F) << 4;

  01060	8a 95 cf fe ff
	ff		 mov	 dl, BYTE PTR _pCList$[ebp+19]
  01066	0a d8		 or	 bl, al
  01068	8a c1		 mov	 al, cl
  0106a	88 9d d9 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+29], bl

; 1383 : 
; 1384 : 				pCList.CharSet[15] |= (int)(TempInventory[5] & 0x1E0) >> 1;

  01070	8a 9d da fe ff
	ff		 mov	 bl, BYTE PTR _pCList$[ebp+30]
  01076	24 10		 and	 al, 16			; 00000010H
  01078	02 c0		 add	 al, al
  0107a	c0 e1 04	 shl	 cl, 4
  0107d	0a f8		 or	 bh, al
  0107f	0a d1		 or	 dl, cl
  01081	8b 85 a6 fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+10]

; 1385 : 				pCList.CharSet[9] |= (int)(TempInventory[5] & 0x10);

  01087	8a 8d a6 fe ff
	ff		 mov	 cl, BYTE PTR _TempInventory$[ebp+10]
  0108d	d1 e8		 shr	 eax, 1
  0108f	24 f0		 and	 al, 240			; 000000f0H
  01091	0a d8		 or	 bl, al
  01093	8a c1		 mov	 al, cl
  01095	24 10		 and	 al, 16			; 00000010H

; 1386 : 				pCList.CharSet[4] |= (int)(TempInventory[5] & 0x0F);

  01097	80 e1 0f	 and	 cl, 15			; 0000000fH
  0109a	0a f8		 or	 bh, al
  0109c	0a d1		 or	 dl, cl

; 1387 : 
; 1388 : 				pCList.CharSet[15] |= (int)(TempInventory[6] & 0x1E0) >> 5;

  0109e	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+12]

; 1389 : 				pCList.CharSet[9] |= (int)(TempInventory[6] & 0x10) >> 1;

  010a4	8a 8d a8 fe ff
	ff		 mov	 cl, BYTE PTR _TempInventory$[ebp+12]
  010aa	c1 e8 05	 shr	 eax, 5
  010ad	24 0f		 and	 al, 15			; 0000000fH
  010af	88 95 cf fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+19], dl
  010b5	0a d8		 or	 bl, al

; 1390 : 				pCList.CharSet[5] |= (int)(TempInventory[6] & 0x0F) << 4;
; 1391 : 
; 1392 : 				index = 0;
; 1393 : 
; 1394 : 				if ( TempInventory[7] == 0x1FF )

  010b7	ba ff 01 00 00	 mov	 edx, 511		; 000001ffH
  010bc	8a c1		 mov	 al, cl
  010be	88 9d da fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+30], bl
  010c4	8a 9d d0 fe ff
	ff		 mov	 bl, BYTE PTR _pCList$[ebp+20]
  010ca	d0 e8		 shr	 al, 1
  010cc	24 08		 and	 al, 8
  010ce	c0 e1 04	 shl	 cl, 4
  010d1	0a f8		 or	 bh, al
  010d3	0a d9		 or	 bl, cl
  010d5	8a 85 aa fe ff
	ff		 mov	 al, BYTE PTR _TempInventory$[ebp+14]
  010db	32 c9		 xor	 cl, cl
  010dd	88 bd d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], bh
  010e3	88 85 eb fe ff
	ff		 mov	 BYTE PTR _TempInventory$20$[ebp], al
  010e9	66 3b f2	 cmp	 si, dx
  010ec	74 3c		 je	 SHORT $LN125@JGPGetChar
$LN117@JGPGetChar:

; 1395 : 				{
; 1396 : 					index = 0;
; 1397 : 				}
; 1398 : 				else
; 1399 : 				{
; 1400 : 					if( TempInventory[7] >= 0 && TempInventory[7] <= 2 )

  010ee	66 83 fe 02	 cmp	 si, 2
  010f2	77 06		 ja	 SHORT $LN119@JGPGetChar

; 1401 : 					{
; 1402 : 						index |= 4;
; 1403 : 						pCList.CharSet[9] |= TempInventory[7]+1;

  010f4	fe c0		 inc	 al
  010f6	0a f8		 or	 bh, al
  010f8	eb 28		 jmp	 SHORT $LN232@JGPGetChar
$LN119@JGPGetChar:

; 1404 : 					}
; 1405 : 					else if( TempInventory[7] == 41 )

  010fa	66 83 fe 29	 cmp	 si, 41			; 00000029H
  010fe	75 06		 jne	 SHORT $LN121@JGPGetChar

; 1406 : 					{
; 1407 : 						index |= 4;

  01100	b1 04		 mov	 cl, 4

; 1408 : 						pCList.CharSet[9] |= 4;

  01102	0a f9		 or	 bh, cl
  01104	eb 1e		 jmp	 SHORT $LN233@JGPGetChar
$LN121@JGPGetChar:

; 1409 : 					}
; 1410 : 					else if( TempInventory[7] == 266 )

  01106	b8 0a 01 00 00	 mov	 eax, 266		; 0000010aH
  0110b	66 3b f0	 cmp	 si, ax
  0110e	75 05		 jne	 SHORT $LN123@JGPGetChar

; 1411 : 					{
; 1412 : 						index |= 4;
; 1413 : 						pCList.CharSet[9] |= 5;

  01110	80 cf 05	 or	 bh, 5
  01113	eb 0d		 jmp	 SHORT $LN232@JGPGetChar
$LN123@JGPGetChar:

; 1414 : 					}
; 1415 : 					else if( TempInventory[7] == 267 )

  01115	b8 0b 01 00 00	 mov	 eax, 267		; 0000010bH
  0111a	66 3b f0	 cmp	 si, ax
  0111d	75 0b		 jne	 SHORT $LN125@JGPGetChar

; 1418 : 						pCList.CharSet[9] |= 6;

  0111f	80 cf 06	 or	 bh, 6
$LN232@JGPGetChar:

; 1416 : 					{
; 1417 : 						index |= 4;

  01122	b1 04		 mov	 cl, 4
$LN233@JGPGetChar:

; 1418 : 						pCList.CharSet[9] |= 6;

  01124	88 bd d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], bh
$LN125@JGPGetChar:

; 1419 : 					}
; 1420 : 				}
; 1421 : 
; 1422 : 				if ( (TempInventory[8] & 0x04) == 0 )

  0112a	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+16]
  01130	83 e0 04	 and	 eax, 4
  01133	89 85 78 fe ff
	ff		 mov	 DWORD PTR tv3302[ebp], eax
  01139	75 19		 jne	 SHORT $LN126@JGPGetChar

; 1423 : 				{
; 1424 : 					if ( TempInventory[8] == 0x1FF )

  0113b	66 39 95 b4 fe
	ff ff		 cmp	 WORD PTR tv2751[ebp], dx
  01142	74 10		 je	 SHORT $LN126@JGPGetChar

; 1425 : 					{
; 1426 : 						index |= 0x03;
; 1427 : 					}
; 1428 : 					else if( (TempInventory[8] & 64) == 0 )

  01144	8a 85 ac fe ff
	ff		 mov	 al, BYTE PTR _TempInventory$[ebp+16]
  0114a	a8 40		 test	 al, 64			; 00000040H
  0114c	75 09		 jne	 SHORT $LN127@JGPGetChar

; 1429 : 					{
; 1430 : 						index |= (TempInventory[8] ) & 0x03;

  0114e	24 03		 and	 al, 3
  01150	0a c8		 or	 cl, al

; 1431 : 					}
; 1432 : 				}
; 1433 : 				else

  01152	eb 03		 jmp	 SHORT $LN127@JGPGetChar
$LN126@JGPGetChar:

; 1434 : 				{
; 1435 : 					index |= 0x03;

  01154	80 c9 03	 or	 cl, 3
$LN127@JGPGetChar:

; 1436 : 				}
; 1437 : 
; 1438 : 				pCList.CharSet[5] |= index;

  01157	0a d9		 or	 bl, cl

; 1439 : 
; 1440 : 				int levelindex = 0;
; 1441 : 
; 1442 : 				if ( TempInventory[0] != (WORD)-1 )

  01159	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0115e	33 c9		 xor	 ecx, ecx
  01160	88 9d d0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], bl
  01166	66 3b f8	 cmp	 di, ax
  01169	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx

; 1443 : 				{
; 1444 : 					levelindex = LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[1]));

  0116f	8b bd e0 fe ff
	ff		 mov	 edi, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  01175	74 28		 je	 SHORT $LN131@JGPGetChar
  01177	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  0117d	0f b6 44 07 11	 movzx	 eax, BYTE PTR [edi+eax+17]
  01182	c1 e8 03	 shr	 eax, 3
  01185	83 e0 0f	 and	 eax, 15			; 0000000fH
  01188	50		 push	 eax
  01189	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  0118e	0f b6 c8	 movzx	 ecx, al
  01191	83 c4 04	 add	 esp, 4
  01194	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
  0119a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN131@JGPGetChar:

; 1445 : 				}
; 1446 : 
; 1447 : 				if ( TempInventory[1] != (WORD)-1 )

  0119f	66 39 85 ba fe
	ff ff		 cmp	 WORD PTR _TempInventory$4$[ebp], ax
  011a6	74 2e		 je	 SHORT $LN132@JGPGetChar

; 1448 : 				{
; 1449 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[5])) << 3;

  011a8	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  011ae	0f b6 44 07 15	 movzx	 eax, BYTE PTR [edi+eax+21]
  011b3	c1 e8 03	 shr	 eax, 3
  011b6	83 e0 0f	 and	 eax, 15			; 0000000fH
  011b9	50		 push	 eax
  011ba	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  011bf	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  011c5	83 c4 04	 add	 esp, 4
  011c8	0f b6 c0	 movzx	 eax, al
  011cb	c1 e0 03	 shl	 eax, 3
  011ce	0b c8		 or	 ecx, eax
  011d0	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
$LN132@JGPGetChar:

; 1450 : 				}
; 1451 : 
; 1452 : 				if ( TempInventory[2] < 0x1FF )

  011d6	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  011db	66 39 85 68 fe
	ff ff		 cmp	 WORD PTR tv2452[ebp], ax
  011e2	73 33		 jae	 SHORT $LN133@JGPGetChar

; 1453 : 				{
; 1454 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[9])) << 6;

  011e4	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  011ea	0f b6 44 07 19	 movzx	 eax, BYTE PTR [edi+eax+25]
  011ef	c1 e8 03	 shr	 eax, 3
  011f2	83 e0 0f	 and	 eax, 15			; 0000000fH
  011f5	50		 push	 eax
  011f6	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  011fb	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  01201	83 c4 04	 add	 esp, 4
  01204	0f b6 c0	 movzx	 eax, al
  01207	c1 e0 06	 shl	 eax, 6
  0120a	0b c8		 or	 ecx, eax
  0120c	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  01211	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
$LN133@JGPGetChar:

; 1455 : 				}
; 1456 : 
; 1457 : 				if ( TempInventory[3] < 0x1FF )

  01217	66 39 85 64 fe
	ff ff		 cmp	 WORD PTR tv2469[ebp], ax
  0121e	73 33		 jae	 SHORT $LN134@JGPGetChar

; 1458 : 				{
; 1459 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[13])) << 9;

  01220	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  01226	0f b6 44 07 1d	 movzx	 eax, BYTE PTR [edi+eax+29]
  0122b	c1 e8 03	 shr	 eax, 3
  0122e	83 e0 0f	 and	 eax, 15			; 0000000fH
  01231	50		 push	 eax
  01232	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  01237	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  0123d	83 c4 04	 add	 esp, 4
  01240	0f b6 c0	 movzx	 eax, al
  01243	c1 e0 09	 shl	 eax, 9
  01246	0b c8		 or	 ecx, eax
  01248	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  0124d	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
$LN134@JGPGetChar:

; 1460 : 				}
; 1461 : 
; 1462 : 				if ( TempInventory[4] < 0x1FF )

  01253	66 39 85 54 fe
	ff ff		 cmp	 WORD PTR tv2487[ebp], ax
  0125a	73 33		 jae	 SHORT $LN135@JGPGetChar

; 1463 : 				{
; 1464 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[17])) << 12;

  0125c	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  01262	0f b6 44 07 21	 movzx	 eax, BYTE PTR [edi+eax+33]
  01267	c1 e8 03	 shr	 eax, 3
  0126a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0126d	50		 push	 eax
  0126e	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  01273	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  01279	83 c4 04	 add	 esp, 4
  0127c	0f b6 c0	 movzx	 eax, al
  0127f	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  01282	0b c8		 or	 ecx, eax
  01284	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  01289	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
$LN135@JGPGetChar:

; 1465 : 				}
; 1466 : 
; 1467 : 				if ( TempInventory[5] < 0x1FF )

  0128f	66 39 85 50 fe
	ff ff		 cmp	 WORD PTR tv2510[ebp], ax
  01296	73 33		 jae	 SHORT $LN136@JGPGetChar

; 1468 : 				{
; 1469 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[21])) << 15;

  01298	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  0129e	0f b6 44 07 25	 movzx	 eax, BYTE PTR [edi+eax+37]
  012a3	c1 e8 03	 shr	 eax, 3
  012a6	83 e0 0f	 and	 eax, 15			; 0000000fH
  012a9	50		 push	 eax
  012aa	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  012af	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  012b5	83 c4 04	 add	 esp, 4
  012b8	0f b6 c0	 movzx	 eax, al
  012bb	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  012be	0b c8		 or	 ecx, eax
  012c0	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  012c5	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _levelindex$1$[ebp], ecx
$LN136@JGPGetChar:

; 1470 : 				}
; 1471 : 
; 1472 : 				if ( TempInventory[6] < 0x1FF )

  012cb	66 39 85 88 fe
	ff ff		 cmp	 WORD PTR tv2527[ebp], ax
  012d2	73 28		 jae	 SHORT $LN137@JGPGetChar

; 1473 : 				{
; 1474 : 					levelindex |= (int)LevelSmallConvert(DBI_GET_LEVEL(lpCL->dbInventory[25])) << 18;

  012d4	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lsOfs$1$[ebp]
  012da	0f b6 44 07 29	 movzx	 eax, BYTE PTR [edi+eax+41]
  012df	c1 e8 03	 shr	 eax, 3
  012e2	83 e0 0f	 and	 eax, 15			; 0000000fH
  012e5	50		 push	 eax
  012e6	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEH@Z ; LevelSmallConvert
  012eb	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _levelindex$1$[ebp]
  012f1	83 c4 04	 add	 esp, 4
  012f4	0f b6 c0	 movzx	 eax, al
  012f7	c1 e0 12	 shl	 eax, 18			; 00000012H
  012fa	0b c8		 or	 ecx, eax
$LN137@JGPGetChar:

; 1475 : 				}
; 1476 : 
; 1477 : 				pCList.CharSet[6] = ((int)levelindex >> 0x10) & 0xFF;

  012fc	8b c1		 mov	 eax, ecx

; 1478 : 				pCList.CharSet[7] = ((int)levelindex >> 0x08) & 0xFF;
; 1479 : 				pCList.CharSet[8] = ((int)levelindex) & 0xFF;

  012fe	88 8d d3 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+23], cl
  01304	c1 f8 10	 sar	 eax, 16			; 00000010H
  01307	88 85 d1 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+21], al
  0130d	8b c1		 mov	 eax, ecx
  0130f	c1 f8 08	 sar	 eax, 8
  01312	88 85 d2 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+22], al

; 1480 : 
; 1481 : 				if ( (TempInventory[7] >= 3 && TempInventory[7] <= 6) || TempInventory[7] == 0x1E || 
; 1482 : 					  TempInventory[7] == 0x2A || TempInventory[7] == 0x31 )

  01318	66 83 fe 03	 cmp	 si, 3
  0131c	72 06		 jb	 SHORT $LN140@JGPGetChar
  0131e	66 83 fe 06	 cmp	 si, 6
  01322	76 12		 jbe	 SHORT $LN139@JGPGetChar
$LN140@JGPGetChar:
  01324	66 83 fe 1e	 cmp	 si, 30			; 0000001eH
  01328	74 0c		 je	 SHORT $LN139@JGPGetChar
  0132a	66 83 fe 2a	 cmp	 si, 42			; 0000002aH
  0132e	74 06		 je	 SHORT $LN139@JGPGetChar
  01330	66 83 fe 31	 cmp	 si, 49			; 00000031H
  01334	75 1c		 jne	 SHORT $LN187@JGPGetChar
$LN139@JGPGetChar:

; 1483 : 				{
; 1484 : 					pCList.CharSet[5] |= 0x08;

  01336	80 cb 08	 or	 bl, 8
  01339	88 9d d0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], bl

; 1485 : 
; 1486 : 					if ( TempInventory[7] == 0x1E )

  0133f	66 83 fe 1e	 cmp	 si, 30			; 0000001eH
  01343	0f 85 13 01 00
	00		 jne	 $LN141@JGPGetChar

; 1487 : 					{
; 1488 : 						pCList.CharSet[9] |= 0x05;

  01349	80 cf 05	 or	 bh, 5
$LN234@JGPGetChar:

; 1491 : 					{
; 1492 : 						pCList.CharSet[9] |= 0x06;

  0134c	88 bd d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], bh
$LN187@JGPGetChar:
  01352	8a ad eb fe ff
	ff		 mov	 ch, BYTE PTR _TempInventory$20$[ebp]
$LN146@JGPGetChar:

; 1501 : 					}
; 1502 : 				}
; 1503 : 
; 1504 : 				pCList.CharSet[10] =0;
; 1505 : 
; 1506 : 				if ( (TempInventory[8]& 0x03) != 0 && TempInventory[8] != 0x1FF )

  01358	8b bd b4 fe ff
	ff		 mov	 edi, DWORD PTR tv2751[ebp]
  0135e	32 d2		 xor	 dl, dl
  01360	f6 85 ac fe ff
	ff 03		 test	 BYTE PTR _TempInventory$[ebp+16], 3
  01367	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  0136c	88 95 d5 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+25], dl
  01372	74 13		 je	 SHORT $LN147@JGPGetChar
  01374	66 3b f8	 cmp	 di, ax
  01377	0f b6 d2	 movzx	 edx, dl
  0137a	0f 45 95 44 fe
	ff ff		 cmovne	 edx, DWORD PTR tv3279[ebp]
  01381	88 95 d5 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+25], dl
$LN147@JGPGetChar:

; 1507 : 				{
; 1508 : 					pCList.CharSet[10] |= 0x01;
; 1509 : 				}
; 1510 : 
; 1511 : 				pCList.CharSet[11] = 0;
; 1512 : 
; 1513 : 				if ( (TempInventory[8]& 0x04) != 0 && TempInventory[8] != 0x1FF )

  01387	66 83 bd 78 fe
	ff ff 00	 cmp	 WORD PTR tv3302[ebp], 0
  0138f	c6 85 d6 fe ff
	ff 00		 mov	 BYTE PTR _pCList$[ebp+26], 0
  01396	74 19		 je	 SHORT $LN148@JGPGetChar
  01398	66 3b f8	 cmp	 di, ax
  0139b	74 14		 je	 SHORT $LN148@JGPGetChar

; 1514 : 				{
; 1515 : 					pCList.CharSet[12] |= 0x01;

  0139d	8a 85 ea fe ff
	ff		 mov	 al, BYTE PTR _pCList$7$[ebp]
  013a3	0c 01		 or	 al, 1
  013a5	88 85 ea fe ff
	ff		 mov	 BYTE PTR _pCList$7$[ebp], al
  013ab	88 85 d7 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+27], al
$LN148@JGPGetChar:

; 1516 : 				}
; 1517 : 
; 1518 : 				pCList.CharSet[16] = 0;
; 1519 : 				pCList.CharSet[17] = 0;

  013b1	32 c0		 xor	 al, al
  013b3	32 c9		 xor	 cl, cl
  013b5	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv3216[ebp], eax
  013bb	88 85 dc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], al

; 1520 : 
; 1521 : 				if ( TempInventory[7] >= 0x106 && TempInventory[7] <= 0x109 )

  013c1	8b 85 aa fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+14]
  013c7	05 fa fe ff ff	 add	 eax, -262		; fffffefaH
  013cc	88 8d db fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], cl
  013d2	66 83 f8 03	 cmp	 ax, 3
  013d6	77 1a		 ja	 SHORT $LN149@JGPGetChar

; 1522 : 				{
; 1523 : 					pCList.CharSet[5] |= 0x08;
; 1524 : 					pCList.CharSet[16] = ((TempInventory[7]-0x105)&7)<<2;

  013d8	8a cd		 mov	 cl, ch
  013da	80 cb 08	 or	 bl, 8
  013dd	80 c1 03	 add	 cl, 3
  013e0	88 9d d0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], bl
  013e6	c0 e1 02	 shl	 cl, 2
  013e9	80 e1 1c	 and	 cl, 28			; 0000001cH
  013ec	88 8d db fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], cl
$LN149@JGPGetChar:

; 1525 : 				}
; 1526 : 
; 1527 : 				if ( TempInventory[8] == 0x25 && TempInventory[8] != 0x1FF )

  013f2	66 83 ff 25	 cmp	 di, 37			; 00000025H
  013f6	0f 85 9b 00 00
	00		 jne	 $LN186@JGPGetChar

; 1528 : 				{
; 1529 : 					pCList.CharSet[10] &= 0xFE;
; 1530 : 					pCList.CharSet[12] &= 0xFE;

  013fc	8a 85 ea fe ff
	ff		 mov	 al, BYTE PTR _pCList$7$[ebp]
  01402	80 e2 fe	 and	 dl, 254			; 000000feH
  01405	24 fe		 and	 al, 254			; 000000feH
  01407	88 95 d5 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+25], dl

; 1531 : 					pCList.CharSet[12] |= 0x04;
; 1532 : 					BYTE btExcellentOption = lpCL->dbInventory[34] & 0x3F;

  0140d	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _lsOfs$1$[ebp]
  01413	0c 04		 or	 al, 4
  01415	88 85 d7 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+27], al
  0141b	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  01421	8a 44 10 32	 mov	 al, BYTE PTR [eax+edx+50]
  01425	24 3f		 and	 al, 63			; 0000003fH

; 1533 : 
; 1534 : 					if ( (btExcellentOption&1) == 1 )

  01427	a8 01		 test	 al, 1
  01429	74 09		 je	 SHORT $LN151@JGPGetChar

; 1535 : 					{
; 1536 : 						pCList.CharSet[16] |= 0x01;

  0142b	80 c9 01	 or	 cl, 1
  0142e	88 8d db fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], cl
$LN151@JGPGetChar:

; 1537 : 					}
; 1538 : 
; 1539 : 					if ( (btExcellentOption&2) == 2 )

  01434	a8 02		 test	 al, 2
  01436	74 09		 je	 SHORT $LN152@JGPGetChar

; 1540 : 					{
; 1541 : 						pCList.CharSet[16] |= 0x02;

  01438	80 c9 02	 or	 cl, 2
  0143b	88 8d db fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], cl
$LN152@JGPGetChar:

; 1542 : 					}
; 1543 : 
; 1544 : 					if ( (btExcellentOption&4) == 4 )

  01441	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR tv3216[ebp]
  01447	a8 04		 test	 al, 4
  01449	0f b6 d2	 movzx	 edx, dl
  0144c	b8 01 00 00 00	 mov	 eax, 1
  01451	0f 45 d0	 cmovne	 edx, eax
  01454	88 95 dc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], dl
  0145a	eb 41		 jmp	 SHORT $LN153@JGPGetChar
$LN141@JGPGetChar:

; 1489 : 					}
; 1490 : 					else if( TempInventory[7] == 0x2A )

  0145c	66 83 fe 2a	 cmp	 si, 42			; 0000002aH
  01460	75 08		 jne	 SHORT $LN143@JGPGetChar

; 1491 : 					{
; 1492 : 						pCList.CharSet[9] |= 0x06;

  01462	80 cf 06	 or	 bh, 6
  01465	e9 e2 fe ff ff	 jmp	 $LN234@JGPGetChar
$LN143@JGPGetChar:

; 1497 : 					}
; 1498 : 					else

  0146a	8a ad eb fe ff
	ff		 mov	 ch, BYTE PTR _TempInventory$20$[ebp]
  01470	66 83 fe 31	 cmp	 si, 49			; 00000031H
  01474	75 0e		 jne	 SHORT $LN145@JGPGetChar

; 1493 : 					}
; 1494 : 					else if( TempInventory[7] == 0x31 )
; 1495 : 					{
; 1496 : 						pCList.CharSet[9] |= 0x07;

  01476	80 cf 07	 or	 bh, 7
  01479	88 bd d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], bh

; 1497 : 					}
; 1498 : 					else

  0147f	e9 d4 fe ff ff	 jmp	 $LN146@JGPGetChar
$LN145@JGPGetChar:

; 1499 : 					{
; 1500 : 						pCList.CharSet[9] |= (TempInventory[7] - 2) & 0x07;

  01484	8a c5		 mov	 al, ch
  01486	2c 02		 sub	 al, 2
  01488	24 07		 and	 al, 7
  0148a	0a f8		 or	 bh, al
  0148c	88 bd d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], bh
  01492	e9 c1 fe ff ff	 jmp	 $LN146@JGPGetChar
$LN186@JGPGetChar:
  01497	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR tv3216[ebp]
$LN153@JGPGetChar:

; 1545 : 					{
; 1546 : 						pCList.CharSet[17] |= 0x01;
; 1547 : 					}
; 1548 : 				}
; 1549 : 
; 1550 : 				if ( (TempInventory[7] >= 0x24 && TempInventory[7] <= 0x28) 
; 1551 : 					|| TempInventory[7] == 0x2B || TempInventory[7] == 0x32 )

  0149d	66 83 fe 24	 cmp	 si, 36			; 00000024H
  014a1	72 06		 jb	 SHORT $LN156@JGPGetChar
  014a3	66 83 fe 28	 cmp	 si, 40			; 00000028H
  014a7	76 0c		 jbe	 SHORT $LN155@JGPGetChar
$LN156@JGPGetChar:
  014a9	66 83 fe 2b	 cmp	 si, 43			; 0000002bH
  014ad	74 06		 je	 SHORT $LN155@JGPGetChar
  014af	66 83 fe 32	 cmp	 si, 50			; 00000032H
  014b3	75 39		 jne	 SHORT $LN159@JGPGetChar
$LN155@JGPGetChar:

; 1552 : 				{
; 1553 : 					pCList.CharSet[5] |= 0x0C;
; 1554 : 					pCList.CharSet[9] |= (TempInventory[7] - 0x23) & 7;

  014b5	8a c5		 mov	 al, ch
  014b7	80 cb 0c	 or	 bl, 12			; 0000000cH
  014ba	2c 03		 sub	 al, 3
  014bc	88 9d d0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], bl
  014c2	24 07		 and	 al, 7
  014c4	0a f8		 or	 bh, al
  014c6	88 bd d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], bh

; 1555 : 
; 1556 : 					if( TempInventory[7] == 0x2B )

  014cc	66 83 fe 2b	 cmp	 si, 43			; 0000002bH
  014d0	75 0b		 jne	 SHORT $LN157@JGPGetChar

; 1557 : 					{
; 1558 : 						pCList.CharSet[9] |= 0x06;

  014d2	80 cf 06	 or	 bh, 6
  014d5	88 bd d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], bh
  014db	eb 3b		 jmp	 SHORT $LN160@JGPGetChar
$LN157@JGPGetChar:

; 1559 : 					}
; 1560 : 					else if( TempInventory[7] == 0x32 )

  014dd	66 83 fe 32	 cmp	 si, 50			; 00000032H
  014e1	75 0b		 jne	 SHORT $LN159@JGPGetChar

; 1561 : 					{
; 1562 : 						pCList.CharSet[9] |= 0x07;

  014e3	80 cf 07	 or	 bh, 7
  014e6	88 bd d4 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+24], bh

; 1563 : 					}
; 1564 : 				}
; 1565 : 
; 1566 : 				if( TempInventory[7] >= 130 && TempInventory[7] <= 135 )

  014ec	eb 2a		 jmp	 SHORT $LN160@JGPGetChar
$LN159@JGPGetChar:
  014ee	8b 85 aa fe ff
	ff		 mov	 eax, DWORD PTR _TempInventory$[ebp+14]
  014f4	05 7e ff ff ff	 add	 eax, -130		; ffffff7eH
  014f9	66 83 f8 05	 cmp	 ax, 5
  014fd	77 19		 ja	 SHORT $LN160@JGPGetChar

; 1567 : 				{
; 1568 : 					pCList.CharSet[5] |= CS_SET_WING(3);
; 1569 : 					pCList.CharSet[17] |= ((TempInventory[7]-1)&7)*32;

  014ff	fe cd		 dec	 ch
  01501	80 cb 0c	 or	 bl, 12			; 0000000cH
  01504	80 e5 07	 and	 ch, 7
  01507	88 9d d0 fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+20], bl
  0150d	c0 e5 05	 shl	 ch, 5
  01510	0a d5		 or	 dl, ch
  01512	88 95 dc fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+32], dl
$LN160@JGPGetChar:

; 1570 : 				}
; 1571 : 
; 1572 : 				if ( (TempInventory[8] & 4) == FALSE && TempInventory[8] != 0x1FF )

  01518	66 83 bd 78 fe
	ff ff 00	 cmp	 WORD PTR tv3302[ebp], 0
  01520	75 43		 jne	 SHORT $LN193@JGPGetChar
  01522	b8 ff 01 00 00	 mov	 eax, 511		; 000001ffH
  01527	66 3b f8	 cmp	 di, ax
  0152a	74 39		 je	 SHORT $LN193@JGPGetChar

; 1573 : 				{
; 1574 : 					BYTE Helper = 0;
; 1575 : 
; 1576 : 					switch( TempInventory[8] )

  0152c	0f b7 c7	 movzx	 eax, di
  0152f	32 d2		 xor	 dl, dl
  01531	83 c0 c0	 add	 eax, -64		; ffffffc0H
  01534	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  01537	77 24		 ja	 SHORT $LN5@JGPGetChar
  01539	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN181@JGPGetChar[eax]
  01540	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN236@JGPGetChar[eax*4]
$LN162@JGPGetChar:

; 1577 : 					{
; 1578 : 					case 0x40:
; 1579 : 						Helper = 0x20;

  01547	b2 20		 mov	 dl, 32			; 00000020H

; 1580 : 						break;

  01549	eb 12		 jmp	 SHORT $LN5@JGPGetChar
$LN163@JGPGetChar:

; 1581 : 					case 0x41:
; 1582 : 						Helper = 0x40;

  0154b	b2 40		 mov	 dl, 64			; 00000040H

; 1583 : 						break;

  0154d	eb 0e		 jmp	 SHORT $LN5@JGPGetChar
$LN164@JGPGetChar:

; 1584 : 					case 0x43:
; 1585 : 						Helper = 0x80;

  0154f	b2 80		 mov	 dl, 128			; 00000080H

; 1586 : 						break;

  01551	eb 0a		 jmp	 SHORT $LN5@JGPGetChar
$LN165@JGPGetChar:

; 1587 : 					case 0x50:
; 1588 : 						Helper = 0xE0;

  01553	b2 e0		 mov	 dl, 224			; 000000e0H

; 1589 : 						break;

  01555	eb 06		 jmp	 SHORT $LN5@JGPGetChar
$LN166@JGPGetChar:

; 1590 : 					case 0x6A:
; 1591 : 						Helper = 0xA0;

  01557	b2 a0		 mov	 dl, 160			; 000000a0H

; 1592 : 						break;

  01559	eb 02		 jmp	 SHORT $LN5@JGPGetChar
$LN167@JGPGetChar:

; 1593 : 					case 0x7B:
; 1594 : 						Helper = 0x60;

  0155b	b2 60		 mov	 dl, 96			; 00000060H
$LN5@JGPGetChar:

; 1595 : 						break;
; 1596 : 					}
; 1597 : 
; 1598 : 					pCList.CharSet[16] |= Helper;

  0155d	0a ca		 or	 cl, dl
  0155f	88 8d db fe ff
	ff		 mov	 BYTE PTR _pCList$[ebp+31], cl
$LN193@JGPGetChar:
  01565	8b bd ec fe ff
	ff		 mov	 edi, DWORD PTR _lsOfs$1$[ebp]
  0156b	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR _lpRecv$GSCopy$1$[ebp]
$LN161@JGPGetChar:

; 1599 : 				}
; 1600 : 
; 1601 : #if (CUSTOM_WINGS == 1)
; 1602 : 				if ( TempInventory[7] >= 440 && TempInventory[7] <= 445 )
; 1603 : 				{
; 1604 : 					pCList.CharSet[17] |= 0x10 + TempInventory[7]%440;
; 1605 : 				}
; 1606 : #endif
; 1607 : 			}
; 1608 : 
; 1609 : 			memcpy(&sendbuf[lOfs], &pCList, sizeof(pCList));

  01571	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]

; 1610 : 			lsOfs += sizeof(SDHP_CHARLIST);

  01577	83 c7 42	 add	 edi, 66			; 00000042H
  0157a	0f 10 85 bc fe
	ff ff		 movups	 xmm0, XMMWORD PTR _pCList$[ebp]
  01581	66 8b 85 dc fe
	ff ff		 mov	 ax, WORD PTR _pCList$[ebp+32]
  01588	8b 9d 3c fe ff
	ff		 mov	 ebx, DWORD PTR tv3477[ebp]
  0158e	0f 11 84 0d f0
	fe ff ff	 movups	 XMMWORD PTR _sendbuf$[ebp+ecx], xmm0
  01596	89 bd ec fe ff
	ff		 mov	 DWORD PTR _lsOfs$1$[ebp], edi
  0159c	0f 10 85 cc fe
	ff ff		 movups	 xmm0, XMMWORD PTR _pCList$[ebp+16]
  015a3	0f 11 84 0d 00
	ff ff ff	 movups	 XMMWORD PTR _sendbuf$[ebp+ecx+16], xmm0
  015ab	66 89 84 0d 10
	ff ff ff	 mov	 WORD PTR _sendbuf$[ebp+ecx+32], ax

; 1611 : 			lOfs += sizeof(pCList);

  015b3	83 c1 22	 add	 ecx, 34			; 00000022H
  015b6	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR _n$1$[ebp]
  015bc	40		 inc	 eax
  015bd	89 8d 60 fe ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
  015c3	89 85 5c fe ff
	ff		 mov	 DWORD PTR _n$1$[ebp], eax
  015c9	3b 85 40 fe ff
	ff		 cmp	 eax, DWORD PTR $T1[ebp]
  015cf	0f 8c bb eb ff
	ff		 jl	 $LL4@JGPGetChar
$LN3@JGPGetChar:

; 1612 : 		}
; 1613 : 	}
; 1614 : 
; 1615 : 	pCLCount.h.size = lOfs;
; 1616 : 	memcpy(sendbuf, &pCLCount, sizeof(PMSG_CHARLISTCOUNT));
; 1617 : 	DataSend(aIndex, sendbuf, lOfs);

  015d5	8b 9d 6c fe ff
	ff		 mov	 ebx, DWORD PTR _aIndex$1$[ebp]
  015db	88 8d 71 fe ff
	ff		 mov	 BYTE PTR _pCLCount$[ebp+1], cl
  015e1	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR _pCLCount$[ebp]
  015e7	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], eax
  015ed	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _pCLCount$[ebp+4]
  015f3	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+4], eax
  015f9	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  015ff	51		 push	 ecx
  01600	50		 push	 eax
  01601	53		 push	 ebx
  01602	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1618 : 
; 1619 : 		if( gObj[aIndex].m_AccountMaxLevel >= g_CreateCharLevelSUM )

  01607	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0160c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0160f	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv3491[ebp]
  01615	ba 01 00 00 00	 mov	 edx, 1
  0161a	0f b7 4c 01 08	 movzx	 ecx, WORD PTR [ecx+eax+8]
  0161f	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ?g_CreateCharLevelSUM@@3FA ; g_CreateCharLevelSUM
  01626	0f b6 85 9b fe
	ff ff		 movzx	 eax, BYTE PTR _GenerableClass$1$[ebp]
  0162d	0f 4d c2	 cmovge	 eax, edx

; 1620 : 		{
; 1621 : 			GenerableClass += 1;
; 1622 : 		}
; 1623 : 		// ----
; 1624 : 		if( gObj[aIndex].m_AccountMaxLevel >= g_CreateCharLevelRF )

  01630	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ?g_CreateCharLevelRF@@3FA ; g_CreateCharLevelRF
  01637	7c 02		 jl	 SHORT $LN169@JGPGetChar

; 1625 : 		{
; 1626 : 			GenerableClass += 8;

  01639	04 08		 add	 al, 8
$LN169@JGPGetChar:

; 1627 : 		}
; 1628 : 		// ----
; 1629 : 		if( gObj[aIndex].m_AccountMaxLevel >= g_CreateCharLevelMG )

  0163b	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ?g_CreateCharLevelMG@@3FA ; g_CreateCharLevelMG
  01642	7c 02		 jl	 SHORT $LN170@JGPGetChar

; 1630 : 		{
; 1631 : 			GenerableClass += 4;

  01644	04 04		 add	 al, 4
$LN170@JGPGetChar:

; 1632 : 		}
; 1633 : 		// ----
; 1634 : 		if( gObj[aIndex].m_AccountMaxLevel >= g_CreateCharLevelDL )

  01646	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR ?g_CreateCharLevelDL@@3FA ; g_CreateCharLevelDL
  0164d	7c 02		 jl	 SHORT $LN171@JGPGetChar

; 1635 : 		{
; 1636 : 			GenerableClass += 2;

  0164f	04 02		 add	 al, 2
$LN171@JGPGetChar:

; 1637 : 		}
; 1638 : 		// ----
; 1639 : 		PMSG_UPD_SUMMONER_CREATE pMsg = { 0 };

  01651	c7 85 81 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pMsg$[ebp+1], 0

; 1640 : 		pMsg.h.set((LPBYTE)&pMsg, 0xDE, sizeof(pMsg));
; 1641 : 		pMsg.btResult = 0;
; 1642 : 		pMsg.IsSummonerEnable = GenerableClass;

  0165b	88 85 84 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], al

; 1644 : 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  01661	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  01667	6a 05		 push	 5
  01669	50		 push	 eax
  0166a	53		 push	 ebx
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  0166b	c7 85 80 fe ff
	ff c1 05 de 00	 mov	 DWORD PTR _pMsg$[ebp], 14550465 ; 00de05c1H
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp

; 1644 : 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  01675	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1645 : 
; 1646 : 	
; 1647 : }

  0167a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0167d	83 c4 0c	 add	 esp, 12			; 0000000cH
  01680	33 cd		 xor	 ecx, ebp
  01682	5f		 pop	 edi
  01683	5e		 pop	 esi
  01684	5b		 pop	 ebx
  01685	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0168a	8b e5		 mov	 esp, ebp
  0168c	5d		 pop	 ebp
  0168d	c3		 ret	 0
  0168e	66 90		 npad	 2
$LN236@JGPGetChar:
  01690	00 00 00 00	 DD	 $LN162@JGPGetChar
  01694	00 00 00 00	 DD	 $LN163@JGPGetChar
  01698	00 00 00 00	 DD	 $LN164@JGPGetChar
  0169c	00 00 00 00	 DD	 $LN165@JGPGetChar
  016a0	00 00 00 00	 DD	 $LN166@JGPGetChar
  016a4	00 00 00 00	 DD	 $LN167@JGPGetChar
  016a8	00 00 00 00	 DD	 $LN5@JGPGetChar
$LN181@JGPGetChar:
  016ac	00		 DB	 0
  016ad	01		 DB	 1
  016ae	06		 DB	 6
  016af	02		 DB	 2
  016b0	06		 DB	 6
  016b1	06		 DB	 6
  016b2	06		 DB	 6
  016b3	06		 DB	 6
  016b4	06		 DB	 6
  016b5	06		 DB	 6
  016b6	06		 DB	 6
  016b7	06		 DB	 6
  016b8	06		 DB	 6
  016b9	06		 DB	 6
  016ba	06		 DB	 6
  016bb	06		 DB	 6
  016bc	03		 DB	 3
  016bd	06		 DB	 6
  016be	06		 DB	 6
  016bf	06		 DB	 6
  016c0	06		 DB	 6
  016c1	06		 DB	 6
  016c2	06		 DB	 6
  016c3	06		 DB	 6
  016c4	06		 DB	 6
  016c5	06		 DB	 6
  016c6	06		 DB	 6
  016c7	06		 DB	 6
  016c8	06		 DB	 6
  016c9	06		 DB	 6
  016ca	06		 DB	 6
  016cb	06		 DB	 6
  016cc	06		 DB	 6
  016cd	06		 DB	 6
  016ce	06		 DB	 6
  016cf	06		 DB	 6
  016d0	06		 DB	 6
  016d1	06		 DB	 6
  016d2	06		 DB	 6
  016d3	06		 DB	 6
  016d4	06		 DB	 6
  016d5	06		 DB	 6
  016d6	04		 DB	 4
  016d7	06		 DB	 6
  016d8	06		 DB	 6
  016d9	06		 DB	 6
  016da	06		 DB	 6
  016db	06		 DB	 6
  016dc	06		 DB	 6
  016dd	06		 DB	 6
  016de	06		 DB	 6
  016df	06		 DB	 6
  016e0	06		 DB	 6
  016e1	06		 DB	 6
  016e2	06		 DB	 6
  016e3	06		 DB	 6
  016e4	06		 DB	 6
  016e5	06		 DB	 6
  016e6	06		 DB	 6
  016e7	05		 DB	 5
?JGPGetCharList@@YAXPAE@Z ENDP				; JGPGetCharList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z PROC	; DataServerLoginResult, COMDAT

; 704  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 705  : 	if (lpMsg->Result == false )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	80 78 03 00	 cmp	 BYTE PTR [eax+3], 0
  0000a	75 18		 jne	 SHORT $LN2@DataServer

; 706  : 	{
; 707  : 		MsgBox(lMsg.Get(MSGGET(1, 210)));	// Authentication error from authentication server

  0000c	68 d2 01 00 00	 push	 466			; 000001d2H
  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00016	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0001b	89 45 08	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 717  : #endif
; 718  : }

  0001e	5d		 pop	 ebp

; 706  : 	{
; 707  : 		MsgBox(lMsg.Get(MSGGET(1, 210)));	// Authentication error from authentication server

  0001f	e9 00 00 00 00	 jmp	 ?MsgBox@@YAXPADZZ	; MsgBox
$LN2@DataServer:

; 708  : 		return;
; 709  : 	}
; 710  : 	
; 711  : 	DataServerConnected = TRUE;
; 712  : 	gServerReady++;

  00024	ff 05 00 00 00
	00		 inc	 DWORD PTR ?gServerReady@@3HA ; gServerReady

; 713  : 	SendMessage(ghWnd, WM_START_SERVER, 0, 0); // Review the Message WM_USER +5

  0002a	6a 00		 push	 0
  0002c	6a 00		 push	 0
  0002e	68 05 04 00 00	 push	 1029			; 00000405H
  00033	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00039	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?DataServerConnected@@3HA, 1 ; DataServerConnected
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendMessageA@16

; 714  : 	
; 715  : #if( ENABLE_CUSTOM_HARDCORE == 1 )
; 716  : 	g_HardcoreMode.Activate();

  00049	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_HardcoreMode@@3VHardcoreMode@@A ; g_HardcoreMode

; 717  : #endif
; 718  : }

  0004e	5d		 pop	 ebp

; 714  : 	
; 715  : #if( ENABLE_CUSTOM_HARDCORE == 1 )
; 716  : 	g_HardcoreMode.Activate();

  0004f	e9 00 00 00 00	 jmp	 ?Activate@HardcoreMode@@QAEXXZ ; HardcoreMode::Activate
?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z ENDP	; DataServerLoginResult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DataServerLogin@@YAXH@Z
_TEXT	SEGMENT
_pInfo$ = -64						; size = 58
__$ArrayPad$ = -4					; size = 4
_server$ = 8						; size = 4
?DataServerLogin@@YAXH@Z PROC				; DataServerLogin, COMDAT

; 684  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 685  : 	SDHP_SERVERINFO pInfo;
; 686  : 
; 687  : 	pInfo.h.c =0xC1;
; 688  : 	pInfo.h.size = sizeof(SDHP_SERVERINFO);	// Size
; 689  : 	pInfo.h.headcode =0x00;
; 690  : 	pInfo.Port =(WORD)GameServerPort;

  00010	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?GameServerPort@@3HA
  00017	66 89 45 c4	 mov	 WORD PTR _pInfo$[ebp+4], ax

; 691  : 	pInfo.Type =1;
; 692  : 	pInfo.ServerCode =gGameServerCode;

  0001b	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00022	66 89 45 f8	 mov	 WORD PTR _pInfo$[ebp+56], ax

; 693  : 	strcpy( (char*)&pInfo.ServerName[0], (const char*)&szServerName[0] );

  00026	33 c0		 xor	 eax, eax
  00028	c7 45 c0 c1 3a
	00 01		 mov	 DWORD PTR _pInfo$[ebp], 16792257 ; 01003ac1H
  0002f	90		 npad	 1
$LL3@DataServer:
  00030	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?szServerName@@3PADA[eax]
  00036	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00039	88 4c 05 c5	 mov	 BYTE PTR _pInfo$[ebp+eax+5], cl
  0003d	84 c9		 test	 cl, cl
  0003f	75 ef		 jne	 SHORT $LL3@DataServer

; 694  : 
; 695  : 	cDBSMng.Send(server, (char*)&pInfo , pInfo.h.size  );	

  00041	0f b6 45 c1	 movzx	 eax, BYTE PTR _pInfo$[ebp+1]
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0004a	50		 push	 eax
  0004b	8d 45 c0	 lea	 eax, DWORD PTR _pInfo$[ebp]
  0004e	50		 push	 eax
  0004f	ff 75 08	 push	 DWORD PTR _server$[ebp]
  00052	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHHPADH@Z ; DBSockMng::Send

; 696  : }

  00057	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005a	33 cd		 xor	 ecx, ebp
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?DataServerLogin@@YAXH@Z ENDP				; DataServerLogin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?TestDSSend@@YAXXZ
_TEXT	SEGMENT
_pMsg$ = -2008						; size = 2004
__$ArrayPad$ = -4					; size = 4
?TestDSSend@@YAXXZ PROC					; TestDSSend, COMDAT

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 07 00
	00		 sub	 esp, 2008		; 000007d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 552  : 	PMSG_TEST pMsg;
; 553  : 	int size;
; 554  : 
; 555  : 	size = sizeof(PMSG_TEST);
; 556  : 	pMsg.h.c=0xC2;
; 557  : 	pMsg.h.headcode =0xFF;
; 558  : 	pMsg.h.sizeH = SET_NUMBERH(size);
; 559  : 	pMsg.h.sizeL = SET_NUMBERL(size);
; 560  : 
; 561  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00014	ff 35 00 00 00
	00		 push	 DWORD PTR ?iCount@@3HA	; iCount
  0001a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfA
  00020	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0002b	50		 push	 eax
  0002c	c7 85 28 f8 ff
	ff c2 07 d4 ff	 mov	 DWORD PTR _pMsg$[ebp], -2881598 ; ffd407c2H
  00036	ff d6		 call	 esi

; 562  : 	LogAdd("%s", pMsg.testbuf );

  00038	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0004a	83 c4 14	 add	 esp, 20			; 00000014H

; 563  : 	cDBSMng.Send((char *)&pMsg, size);

  0004d	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00058	68 d4 07 00 00	 push	 2004			; 000007d4H
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 564  : 	iCount++;

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00068	40		 inc	 eax

; 565  : 
; 566  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00069	50		 push	 eax
  0006a	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  0006f	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0007a	50		 push	 eax
  0007b	ff d6		 call	 esi

; 567  : 	LogAdd("%s", pMsg.testbuf);

  0007d	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0008f	83 c4 14	 add	 esp, 20			; 00000014H

; 568  : 	cDBSMng.Send((char *)&pMsg, size);

  00092	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00098	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0009d	68 d4 07 00 00	 push	 2004			; 000007d4H
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 569  : 	iCount++;

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  000ad	40		 inc	 eax

; 570  : 
; 571  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  000ae	50		 push	 eax
  000af	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  000b4	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  000bf	50		 push	 eax
  000c0	ff d6		 call	 esi

; 572  : 	LogAdd("%s", pMsg.testbuf);

  000c2	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  000c8	50		 push	 eax
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d4	83 c4 14	 add	 esp, 20			; 00000014H

; 573  : 	cDBSMng.Send((char *)&pMsg, size);

  000d7	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  000dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000e2	68 d4 07 00 00	 push	 2004			; 000007d4H
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 574  : 	iCount++;

  000ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  000f2	40		 inc	 eax

; 575  : 
; 576  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  000f3	50		 push	 eax
  000f4	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  000f9	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00104	50		 push	 eax
  00105	ff d6		 call	 esi

; 577  : 	LogAdd("%s", pMsg.testbuf);

  00107	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0010d	50		 push	 eax
  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00119	83 c4 14	 add	 esp, 20			; 00000014H

; 578  : 	cDBSMng.Send((char *)&pMsg, size);

  0011c	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00122	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00127	68 d4 07 00 00	 push	 2004			; 000007d4H
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 579  : 	iCount++;

  00132	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00137	40		 inc	 eax

; 580  : 
; 581  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00138	50		 push	 eax
  00139	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  0013e	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00149	50		 push	 eax
  0014a	ff d6		 call	 esi

; 582  : 	LogAdd("%s", pMsg.testbuf);

  0014c	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00152	50		 push	 eax
  00153	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0015e	83 c4 14	 add	 esp, 20			; 00000014H

; 583  : 	cDBSMng.Send((char *)&pMsg, size);

  00161	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00167	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0016c	68 d4 07 00 00	 push	 2004			; 000007d4H
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 584  : 	iCount++;

  00177	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0017c	40		 inc	 eax

; 585  : 
; 586  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  0017d	50		 push	 eax
  0017e	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  00183	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0018e	50		 push	 eax
  0018f	ff d6		 call	 esi

; 587  : 	LogAdd("%s", pMsg.testbuf);

  00191	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00197	50		 push	 eax
  00198	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001a3	83 c4 14	 add	 esp, 20			; 00000014H

; 588  : 	cDBSMng.Send((char *)&pMsg, size);

  001a6	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  001ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  001b1	68 d4 07 00 00	 push	 2004			; 000007d4H
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 589  : 	iCount++;

  001bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  001c1	40		 inc	 eax

; 590  : 
; 591  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  001c2	50		 push	 eax
  001c3	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  001c8	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  001ce	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  001d3	50		 push	 eax
  001d4	ff d6		 call	 esi

; 592  : 	LogAdd("%s", pMsg.testbuf);

  001d6	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  001dc	50		 push	 eax
  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001e8	83 c4 14	 add	 esp, 20			; 00000014H

; 593  : 	cDBSMng.Send((char *)&pMsg, size);

  001eb	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  001f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  001f6	68 d4 07 00 00	 push	 2004			; 000007d4H
  001fb	50		 push	 eax
  001fc	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 594  : 	iCount++;

  00201	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00206	40		 inc	 eax

; 595  : 
; 596  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00207	50		 push	 eax
  00208	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  0020d	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00213	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00218	50		 push	 eax
  00219	ff d6		 call	 esi

; 597  : 	LogAdd("%s", pMsg.testbuf);

  0021b	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00221	50		 push	 eax
  00222	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00227	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0022d	83 c4 14	 add	 esp, 20			; 00000014H

; 598  : 	cDBSMng.Send((char *)&pMsg, size);

  00230	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00236	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0023b	68 d4 07 00 00	 push	 2004			; 000007d4H
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 599  : 	iCount++;

  00246	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0024b	40		 inc	 eax

; 600  : 
; 601  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  0024c	50		 push	 eax
  0024d	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  00252	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00258	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0025d	50		 push	 eax
  0025e	ff d6		 call	 esi

; 602  : 	LogAdd("%s", pMsg.testbuf);

  00260	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00266	50		 push	 eax
  00267	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0026c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00272	83 c4 14	 add	 esp, 20			; 00000014H

; 603  : 	cDBSMng.Send((char *)&pMsg, size);

  00275	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0027b	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00280	68 d4 07 00 00	 push	 2004			; 000007d4H
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 604  : 	iCount++;

  0028b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00290	40		 inc	 eax

; 605  : 
; 606  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00291	50		 push	 eax
  00292	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  00297	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  002a2	50		 push	 eax
  002a3	ff d6		 call	 esi

; 607  : 	LogAdd("%s", pMsg.testbuf);

  002a5	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  002ab	50		 push	 eax
  002ac	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  002b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002b7	83 c4 14	 add	 esp, 20			; 00000014H

; 608  : 	cDBSMng.Send((char *)&pMsg, size);

  002ba	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  002c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  002c5	68 d4 07 00 00	 push	 2004			; 000007d4H
  002ca	50		 push	 eax
  002cb	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 609  : 	iCount++;

  002d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  002d5	40		 inc	 eax

; 610  : 
; 611  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  002d6	50		 push	 eax
  002d7	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  002dc	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  002e2	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  002e7	50		 push	 eax
  002e8	ff d6		 call	 esi

; 612  : 	LogAdd("%s", pMsg.testbuf);

  002ea	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  002f0	50		 push	 eax
  002f1	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002fc	83 c4 14	 add	 esp, 20			; 00000014H

; 613  : 	cDBSMng.Send((char *)&pMsg, size);

  002ff	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00305	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0030a	68 d4 07 00 00	 push	 2004			; 000007d4H
  0030f	50		 push	 eax
  00310	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 614  : 	iCount++;

  00315	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0031a	40		 inc	 eax

; 615  : 
; 616  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  0031b	50		 push	 eax
  0031c	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  00321	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00327	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0032c	50		 push	 eax
  0032d	ff d6		 call	 esi

; 617  : 	LogAdd("%s", pMsg.testbuf);

  0032f	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00335	50		 push	 eax
  00336	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0033b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00341	83 c4 14	 add	 esp, 20			; 00000014H

; 618  : 	cDBSMng.Send((char *)&pMsg, size);

  00344	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0034a	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0034f	68 d4 07 00 00	 push	 2004			; 000007d4H
  00354	50		 push	 eax
  00355	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 619  : 	iCount++;

  0035a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0035f	40		 inc	 eax

; 620  : 
; 621  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00360	50		 push	 eax
  00361	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  00366	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0036c	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00371	50		 push	 eax
  00372	ff d6		 call	 esi

; 622  : 	LogAdd("%s", pMsg.testbuf);

  00374	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0037a	50		 push	 eax
  0037b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00380	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00386	83 c4 14	 add	 esp, 20			; 00000014H

; 623  : 	cDBSMng.Send((char *)&pMsg, size);

  00389	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0038f	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00394	68 d4 07 00 00	 push	 2004			; 000007d4H
  00399	50		 push	 eax
  0039a	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 624  : 	iCount++;

  0039f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  003a4	40		 inc	 eax

; 625  : 
; 626  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  003a5	50		 push	 eax
  003a6	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  003ab	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  003b1	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  003b6	50		 push	 eax
  003b7	ff d6		 call	 esi

; 627  : 	LogAdd("%s", pMsg.testbuf);

  003b9	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  003bf	50		 push	 eax
  003c0	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  003c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003cb	83 c4 14	 add	 esp, 20			; 00000014H

; 628  : 	cDBSMng.Send((char *)&pMsg, size);

  003ce	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  003d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  003d9	68 d4 07 00 00	 push	 2004			; 000007d4H
  003de	50		 push	 eax
  003df	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 629  : 	iCount++;

  003e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  003e9	40		 inc	 eax

; 630  : 
; 631  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  003ea	50		 push	 eax
  003eb	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  003f0	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  003f6	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  003fb	50		 push	 eax
  003fc	ff d6		 call	 esi

; 632  : 	LogAdd("%s", pMsg.testbuf);

  003fe	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00404	50		 push	 eax
  00405	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0040a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00410	83 c4 14	 add	 esp, 20			; 00000014H

; 633  : 	cDBSMng.Send((char *)&pMsg, size);

  00413	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00419	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0041e	68 d4 07 00 00	 push	 2004			; 000007d4H
  00423	50		 push	 eax
  00424	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 634  : 	iCount++;

  00429	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  0042e	40		 inc	 eax

; 635  : 
; 636  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  0042f	50		 push	 eax
  00430	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  00435	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0043b	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00440	50		 push	 eax
  00441	ff d6		 call	 esi

; 637  : 	LogAdd("%s", pMsg.testbuf);

  00443	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00449	50		 push	 eax
  0044a	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0044f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00455	83 c4 14	 add	 esp, 20			; 00000014H

; 638  : 	cDBSMng.Send((char *)&pMsg, size);

  00458	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0045e	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00463	68 d4 07 00 00	 push	 2004			; 000007d4H
  00468	50		 push	 eax
  00469	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 639  : 	iCount++;

  0046e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00473	40		 inc	 eax

; 640  : 
; 641  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00474	50		 push	 eax
  00475	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  0047a	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00480	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00485	50		 push	 eax
  00486	ff d6		 call	 esi

; 642  : 	LogAdd("%s", pMsg.testbuf);

  00488	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0048e	50		 push	 eax
  0048f	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00494	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0049a	83 c4 14	 add	 esp, 20			; 00000014H

; 643  : 	cDBSMng.Send((char *)&pMsg, size);

  0049d	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  004a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  004a8	68 d4 07 00 00	 push	 2004			; 000007d4H
  004ad	50		 push	 eax
  004ae	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 644  : 	iCount++;

  004b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  004b8	40		 inc	 eax

; 645  : 
; 646  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  004b9	50		 push	 eax
  004ba	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  004bf	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  004c5	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  004ca	50		 push	 eax
  004cb	ff d6		 call	 esi

; 647  : 	LogAdd("%s", pMsg.testbuf);

  004cd	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  004d3	50		 push	 eax
  004d4	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  004d9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004df	83 c4 14	 add	 esp, 20			; 00000014H

; 648  : 	cDBSMng.Send((char *)&pMsg, size);

  004e2	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  004e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  004ed	68 d4 07 00 00	 push	 2004			; 000007d4H
  004f2	50		 push	 eax
  004f3	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 649  : 	iCount++;

  004f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  004fd	40		 inc	 eax

; 650  : 
; 651  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  004fe	50		 push	 eax
  004ff	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  00504	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0050a	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  0050f	50		 push	 eax
  00510	ff d6		 call	 esi

; 652  : 	LogAdd("%s", pMsg.testbuf);

  00512	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00518	50		 push	 eax
  00519	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  0051e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00524	83 c4 14	 add	 esp, 20			; 00000014H

; 653  : 	cDBSMng.Send((char *)&pMsg, size);

  00527	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0052d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00532	68 d4 07 00 00	 push	 2004			; 000007d4H
  00537	50		 push	 eax
  00538	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 654  : 	iCount++;

  0053d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00542	40		 inc	 eax

; 655  : 
; 656  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00543	50		 push	 eax
  00544	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  00549	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0054f	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00554	50		 push	 eax
  00555	ff d6		 call	 esi

; 657  : 	LogAdd("%s", pMsg.testbuf);

  00557	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0055d	50		 push	 eax
  0055e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00563	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00569	83 c4 14	 add	 esp, 20			; 00000014H

; 658  : 	cDBSMng.Send((char *)&pMsg, size);

  0056c	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00572	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00577	68 d4 07 00 00	 push	 2004			; 000007d4H
  0057c	50		 push	 eax
  0057d	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 659  : 	iCount++;

  00582	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00587	40		 inc	 eax

; 660  : 
; 661  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00588	50		 push	 eax
  00589	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  0058e	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  00594	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00599	50		 push	 eax
  0059a	ff d6		 call	 esi

; 662  : 	LogAdd("%s", pMsg.testbuf);

  0059c	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  005a2	50		 push	 eax
  005a3	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  005a8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  005ae	83 c4 14	 add	 esp, 20			; 00000014H

; 663  : 	cDBSMng.Send((char *)&pMsg, size);

  005b1	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  005b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  005bc	68 d4 07 00 00	 push	 2004			; 000007d4H
  005c1	50		 push	 eax
  005c2	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 664  : 	iCount++;

  005c7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  005cc	40		 inc	 eax

; 665  : 
; 666  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  005cd	50		 push	 eax
  005ce	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  005d3	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  005d9	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  005de	50		 push	 eax
  005df	ff d6		 call	 esi

; 667  : 	LogAdd("%s", pMsg.testbuf);

  005e1	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  005e7	50		 push	 eax
  005e8	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  005ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  005f3	83 c4 14	 add	 esp, 20			; 00000014H

; 668  : 	cDBSMng.Send((char *)&pMsg, size);

  005f6	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  005fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00601	68 d4 07 00 00	 push	 2004			; 000007d4H
  00606	50		 push	 eax
  00607	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 669  : 	iCount++;

  0060c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?iCount@@3HA ; iCount
  00611	40		 inc	 eax

; 670  : 
; 671  : 	wsprintf(pMsg.testbuf, "%d", iCount);

  00612	50		 push	 eax
  00613	a3 00 00 00 00	 mov	 DWORD PTR ?iCount@@3HA, eax ; iCount
  00618	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0061e	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00623	50		 push	 eax
  00624	ff d6		 call	 esi

; 672  : 	LogAdd("%s", pMsg.testbuf);

  00626	8d 85 2c f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp+4]
  0062c	50		 push	 eax
  0062d	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  00632	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00638	83 c4 14	 add	 esp, 20			; 00000014H

; 673  : 	cDBSMng.Send((char *)&pMsg, size);

  0063b	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00641	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00646	68 d4 07 00 00	 push	 2004			; 000007d4H
  0064b	50		 push	 eax
  0064c	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 674  : 	iCount++;

  00651	ff 05 00 00 00
	00		 inc	 DWORD PTR ?iCount@@3HA	; iCount

; 675  : 
; 676  : 	LogAdd("Test Data Send");

  00657	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GMPEKMII@Test?5Data?5Send?$AA@
  0065c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 677  : }

  00662	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00665	83 c4 04	 add	 esp, 4
  00668	33 cd		 xor	 ecx, ebp
  0066a	5e		 pop	 esi
  0066b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00670	8b e5		 mov	 esp, ebp
  00672	5d		 pop	 ebp
  00673	c3		 ret	 0
?TestDSSend@@YAXXZ ENDP					; TestDSSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?DataServerProtocolCore@@YAXEPAEH@Z
_TEXT	SEGMENT
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
?DataServerProtocolCore@@YAXEPAEH@Z PROC		; DataServerProtocolCore, COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   : 
; 77   : #if( DEBUG_PROTOCOL == 1 )
; 78   : 		LogAddHeadHexFunc(1, (LPSTR)aRecv, aLen);
; 79   : #endif
; 80   : 
; 81   : 	switch ( protoNum )

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  00007	3d fd 00 00 00	 cmp	 eax, 253		; 000000fdH
  0000c	0f 8f b5 04 00
	00		 jg	 $LN123@DataServer
  00012	0f 84 84 04 00
	00		 je	 $LN111@DataServer
  00018	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  0001d	0f 87 f8 04 00
	00		 ja	 $LN16@DataServer
  00023	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN124@DataServer[eax]
  0002a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN127@DataServer[eax*4]
$LN18@DataServer:

; 82   : 	{
; 83   : 		case 0x00:
; 84   : 			DataServerLoginResult((SDHP_RESULT *)aRecv);

  00031	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00034	e8 00 00 00 00	 call	 ?DataServerLoginResult@@YAXPAUSDHP_RESULT@@@Z ; DataServerLoginResult

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00039	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN19@DataServer:

; 85   : 			break;
; 86   : 
; 87   : 		case 0x01:
; 88   : 			JGPGetCharList(aRecv);

  0003e	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00041	e8 00 00 00 00	 call	 ?JGPGetCharList@@YAXPAE@Z ; JGPGetCharList

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00046	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN20@DataServer:

; 89   : 			break;
; 90   : 
; 91   : 		case 0x04:
; 92   : 			JGCharacterCreateRequest((SDHP_CREATECHARRESULT *)aRecv);

  0004b	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0004e	e8 00 00 00 00	 call	 ?JGCharacterCreateRequest@@YAXPAUSDHP_CREATECHARRESULT@@@Z ; JGCharacterCreateRequest

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00053	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
$LN21@DataServer:

; 93   : 			break;
; 94   : 
; 95   : 		case 0x05:
; 96   : 			JGCharDelRequest((SDHP_CHARDELETERESULT *)aRecv);

  00058	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0005b	e8 00 00 00 00	 call	 ?JGCharDelRequest@@YAXPAUSDHP_CHARDELETERESULT@@@Z ; JGCharDelRequest

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00060	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
$LN22@DataServer:

; 97   : 			break;
; 98   : 
; 99   : 		case 0x06:
; 100  : 			JGGetCharacterInfo((SDHP_DBCHAR_INFORESULT *)aRecv);

  00065	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00068	e8 00 00 00 00	 call	 ?JGGetCharacterInfo@@YAXPAUSDHP_DBCHAR_INFORESULT@@@Z ; JGGetCharacterInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  0006d	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
$LN23@DataServer:

; 101  : 			break;
; 102  : 
; 103  : 		case 0x08:
; 104  : 			DGGetWarehouseList((SDHP_GETWAREHOUSEDB_SAVE *)aRecv);

  00072	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00075	e8 00 00 00 00	 call	 ?DGGetWarehouseList@@YAXPAUSDHP_GETWAREHOUSEDB_SAVE@@@Z ; DGGetWarehouseList

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  0007a	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN24@DataServer:

; 105  : 			break;
; 106  : 
; 107  : 		case 0x10:
; 108  : 			GDGetWarehouseNoItem((SDHP_GETWAREHOUSEDB_RESULT *)aRecv);

  0007f	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00082	e8 00 00 00 00	 call	 ?GDGetWarehouseNoItem@@YAXPAUSDHP_GETWAREHOUSEDB_RESULT@@@Z ; GDGetWarehouseNoItem

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00087	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
$LN25@DataServer:

; 109  : 			break;
; 110  : 		case 0x14:
; 111  : 			g_MonsterKillInfo.GDAnsMonsterKillInfo(aRecv);

  0008c	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0008f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterKillInfo@@3VCQuestMonsterKillInfo@@A ; g_MonsterKillInfo
  00094	e8 00 00 00 00	 call	 ?GDAnsMonsterKillInfo@CQuestMonsterKillInfo@@QAEXPAE@Z ; CQuestMonsterKillInfo::GDAnsMonsterKillInfo

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN26@DataServer:

; 112  : 			break;
; 113  : #if (__QUEST_SYSTEM__== 1)
; 114  : 		case 0x16:
; 115  : 			gQuestInfoEx.DGAnsQuestInfo(aRecv);

  0009b	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0009e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  000a3	e8 00 00 00 00	 call	 ?DGAnsQuestInfo@CQuestInfoEx@@QAEXPAE@Z ; CQuestInfoEx::DGAnsQuestInfo

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN27@DataServer:

; 116  : 			break;
; 117  : #endif
; 118  : #if (__GENS_SYSTEM__ == 1 )
; 119  : 		case 0x40:
; 120  : 			{
; 121  : 				PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 122  : 				switch( lpDef->subcode )

  000aa	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  000ad	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000b1	83 f9 04	 cmp	 ecx, 4
  000b4	0f 87 61 04 00
	00		 ja	 $LN16@DataServer
  000ba	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN128@DataServer[ecx*4]
$LN28@DataServer:

; 123  : 				{
; 124  : 				case 0x00:
; 125  : 					gGensSystem.DGAnswerServerInfo(aRecv);

  000c1	50		 push	 eax
  000c2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  000c7	e8 00 00 00 00	 call	 ?DGAnswerServerInfo@CGensSystem@@QAEXPAE@Z ; CGensSystem::DGAnswerServerInfo

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
$LN29@DataServer:

; 126  : 					break;
; 127  : 				case 0x01:
; 128  : 					gGensSystem.DGAnsGensInfo(aRecv);

  000ce	50		 push	 eax
  000cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  000d4	e8 00 00 00 00	 call	 ?DGAnsGensInfo@CGensSystem@@QAEXPAE@Z ; CGensSystem::DGAnsGensInfo

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
$LN30@DataServer:

; 129  : 					break;
; 130  : 				case 0x02:
; 131  : 					gGensSystem.DGAnsJoinRequest(aRecv);

  000db	50		 push	 eax
  000dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  000e1	e8 00 00 00 00	 call	 ?DGAnsJoinRequest@CGensSystem@@QAEXPAE@Z ; CGensSystem::DGAnsJoinRequest

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
$LN31@DataServer:

; 132  : 					break;
; 133  : 				case 0x04:
; 134  : 					gGensSystem.DGAnsLeaveRequest(aRecv);

  000e8	50		 push	 eax
  000e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  000ee	e8 00 00 00 00	 call	 ?DGAnsLeaveRequest@CGensSystem@@QAEXPAE@Z ; CGensSystem::DGAnsLeaveRequest

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
$LN32@DataServer:

; 135  : 					break;
; 136  : 				}
; 137  : 			}
; 138  : 			break;
; 139  : #endif
; 140  : 		case 0x30:
; 141  : 			g_MasterExp.GDAnsMasterInfo(aRecv);

  000f5	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  000f8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterExp@@3VCMasterExperience@@A ; g_MasterExp
  000fd	e8 00 00 00 00	 call	 ?GDAnsMasterInfo@CMasterExperience@@QAEXPAE@Z ; CMasterExperience::GDAnsMasterInfo

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
$LN33@DataServer:

; 142  : 			break;
; 143  : 		case 0x52:
; 144  : 			ItemSerialCreateRecv((SDHP_ITEMCREATERECV *)aRecv);

  00104	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00107	e8 00 00 00 00	 call	 ?ItemSerialCreateRecv@@YAXPAUSDHP_ITEMCREATERECV@@@Z ; ItemSerialCreateRecv

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  0010c	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
$LN34@DataServer:

; 145  : 			break;
; 146  : 
; 147  : 		case 0x56:
; 148  : 			DGRecvPetItemInfo(aRecv);

  00111	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00114	e8 00 00 00 00	 call	 ?DGRecvPetItemInfo@@YAXPAE@Z ; DGRecvPetItemInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00119	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
$LN35@DataServer:

; 149  : 			break;
; 150  : 
; 151  : 		case 0x60:
; 152  : 			DGOptionDataRecv((SDHP_SKILLKEYDATA_SEND *)aRecv);

  0011e	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00121	e8 00 00 00 00	 call	 ?DGOptionDataRecv@@YAXPAUSDHP_SKILLKEYDATA_SEND@@@Z ; DGOptionDataRecv

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00126	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
$LN36@DataServer:

; 153  : 			break;
; 154  : 
; 155  : 		case 0x61:
; 156  : 			DGMuBotOptionRecv((LPMUBOT_SETTINGS_SEND)aRecv);

  0012b	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0012e	e8 00 00 00 00	 call	 ?DGMuBotOptionRecv@@YAXPAUMUBOT_SETTINGS_SEND@@@Z ; DGMuBotOptionRecv

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00133	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
$LN37@DataServer:

; 157  : 			break;
; 158  : 
; 159  : 		case 0x80:
; 160  : 			{
; 161  : 				PMSG_DEFAULT2 * lpDef1 = (PMSG_DEFAULT2 *)aRecv;
; 162  : 
; 163  : 				switch ( lpDef1->subcode )

  00138	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0013b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0013f	83 f9 1b	 cmp	 ecx, 27			; 0000001bH
  00142	0f 87 d3 03 00
	00		 ja	 $LN16@DataServer
  00148	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN129@DataServer[ecx*4]
$LN38@DataServer:

; 164  : 				{
; 165  : 					case 0x00:
; 166  : 						GS_DGAnsCastleTotalInfo(aRecv);

  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 ?GS_DGAnsCastleTotalInfo@@YAXPAE@Z ; GS_DGAnsCastleTotalInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00155	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00158	5d		 pop	 ebp
  00159	c3		 ret	 0
$LN39@DataServer:

; 167  : 						break;
; 168  : 
; 169  : 					case 0x01:
; 170  : 						GS_DGAnsOwnerGuildMaster(aRecv);

  0015a	50		 push	 eax
  0015b	e8 00 00 00 00	 call	 ?GS_DGAnsOwnerGuildMaster@@YAXPAE@Z ; GS_DGAnsOwnerGuildMaster

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00160	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
$LN40@DataServer:

; 171  : 						break;
; 172  : 
; 173  : 					case 0x03:
; 174  : 						GS_DGAnsCastleNpcBuy(aRecv);

  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 ?GS_DGAnsCastleNpcBuy@@YAXPAE@Z ; GS_DGAnsCastleNpcBuy

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  0016b	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
$LN41@DataServer:

; 175  : 						break;
; 176  : 
; 177  : 					case 0x04:
; 178  : 						GS_DGAnsCastleNpcRepair(aRecv);

  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ?GS_DGAnsCastleNpcRepair@@YAXPAE@Z ; GS_DGAnsCastleNpcRepair

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00176	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
$LN42@DataServer:

; 179  : 						break;
; 180  : 
; 181  : 					case 0x05:
; 182  : 						GS_DGAnsCastleNpcUpgrade(aRecv);

  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 ?GS_DGAnsCastleNpcUpgrade@@YAXPAE@Z ; GS_DGAnsCastleNpcUpgrade

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00181	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
$LN43@DataServer:

; 183  : 						break;
; 184  : 
; 185  : 					case 0x06:
; 186  : 						GS_DGAnsTaxInfo(aRecv);

  00186	50		 push	 eax
  00187	e8 00 00 00 00	 call	 ?GS_DGAnsTaxInfo@@YAXPAE@Z ; GS_DGAnsTaxInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  0018c	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0018f	5d		 pop	 ebp
  00190	c3		 ret	 0
$LN44@DataServer:

; 187  : 						break;
; 188  : 
; 189  : 					case 0x07:
; 190  : 						GS_DGAnsTaxRateChange(aRecv);

  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ?GS_DGAnsTaxRateChange@@YAXPAE@Z ; GS_DGAnsTaxRateChange

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00197	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
$LN45@DataServer:

; 191  : 						break;
; 192  : 
; 193  : 					case 0x08:
; 194  : 						GS_DGAnsCastleMoneyChange(aRecv);

  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 ?GS_DGAnsCastleMoneyChange@@YAXPAE@Z ; GS_DGAnsCastleMoneyChange

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  001a2	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  001a5	5d		 pop	 ebp
  001a6	c3		 ret	 0
$LN46@DataServer:

; 195  : 						break;
; 196  : 
; 197  : 					case 0x09:
; 198  : 						GS_DGAnsSiegeDateChange(aRecv);

  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ?GS_DGAnsSiegeDateChange@@YAXPAE@Z ; GS_DGAnsSiegeDateChange

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  001ad	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  001b0	5d		 pop	 ebp
  001b1	c3		 ret	 0
$LN47@DataServer:

; 199  : 						break;
; 200  : 
; 201  : 					case 0x0A:
; 202  : 						GS_DGAnsGuildMarkRegInfo(aRecv);

  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 ?GS_DGAnsGuildMarkRegInfo@@YAXPAE@Z ; GS_DGAnsGuildMarkRegInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  001b8	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  001bb	5d		 pop	 ebp
  001bc	c3		 ret	 0
$LN48@DataServer:

; 203  : 						break;
; 204  : 
; 205  : 					case 0x0B:
; 206  : 						GS_DGAnsSiegeEndedChange(aRecv);

  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 ?GS_DGAnsSiegeEndedChange@@YAXPAE@Z ; GS_DGAnsSiegeEndedChange

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  001c3	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$LN49@DataServer:

; 207  : 						break;
; 208  : 
; 209  : 					case 0x0C:
; 210  : 						GS_DGAnsCastleOwnerChange(aRecv);

  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 ?GS_DGAnsCastleOwnerChange@@YAXPAE@Z ; GS_DGAnsCastleOwnerChange

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  001ce	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  001d1	5d		 pop	 ebp
  001d2	c3		 ret	 0
$LN50@DataServer:

; 211  : 						break;
; 212  : 
; 213  : 					case 0x0D:
; 214  : 						GS_DGAnsRegAttackGuild(aRecv);

  001d3	50		 push	 eax
  001d4	e8 00 00 00 00	 call	 ?GS_DGAnsRegAttackGuild@@YAXPAE@Z ; GS_DGAnsRegAttackGuild

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  001d9	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  001dc	5d		 pop	 ebp
  001dd	c3		 ret	 0
$LN51@DataServer:

; 215  : 						break;
; 216  : 
; 217  : 					case 0x0E:
; 218  : 						GS_DGAnsRestartCastleState(aRecv);

  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 ?GS_DGAnsRestartCastleState@@YAXPAE@Z ; GS_DGAnsRestartCastleState

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  001e4	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  001e7	5d		 pop	 ebp
  001e8	c3		 ret	 0
$LN52@DataServer:

; 219  : 						break;
; 220  : 
; 221  : 					case 0x0F:
; 222  : 						GS_DGAnsMapSvrMsgMultiCast(aRecv);

  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 ?GS_DGAnsMapSvrMsgMultiCast@@YAXPAE@Z ; GS_DGAnsMapSvrMsgMultiCast

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  001ef	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  001f2	5d		 pop	 ebp
  001f3	c3		 ret	 0
$LN53@DataServer:

; 223  : 						break;
; 224  : 
; 225  : 					case 0x10:
; 226  : 						GS_DGAnsRegGuildMark(aRecv);

  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 ?GS_DGAnsRegGuildMark@@YAXPAE@Z ; GS_DGAnsRegGuildMark

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  001fa	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  001fd	5d		 pop	 ebp
  001fe	c3		 ret	 0
$LN54@DataServer:

; 227  : 						break;
; 228  : 
; 229  : 					case 0x11:
; 230  : 						GS_DGAnsGuildMarkReset(aRecv);

  001ff	50		 push	 eax
  00200	e8 00 00 00 00	 call	 ?GS_DGAnsGuildMarkReset@@YAXPAE@Z ; GS_DGAnsGuildMarkReset

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00205	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
$LN55@DataServer:

; 231  : 						break;
; 232  : 
; 233  : 					case 0x12:
; 234  : 						GS_DGAnsGuildSetGiveUp(aRecv);

  0020a	50		 push	 eax
  0020b	e8 00 00 00 00	 call	 ?GS_DGAnsGuildSetGiveUp@@YAXPAE@Z ; GS_DGAnsGuildSetGiveUp

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00210	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00213	5d		 pop	 ebp
  00214	c3		 ret	 0
$LN56@DataServer:

; 235  : 						break;
; 236  : 
; 237  : 					case 0x16:
; 238  : 						GS_DGAnsNpcRemove(aRecv);

  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 ?GS_DGAnsNpcRemove@@YAXPAE@Z ; GS_DGAnsNpcRemove

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  0021b	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0021e	5d		 pop	 ebp
  0021f	c3		 ret	 0
$LN57@DataServer:

; 239  : 						break;
; 240  : 
; 241  : 					case 0x17:
; 242  : 						GS_DGAnsCastleStateSync(aRecv);

  00220	50		 push	 eax
  00221	e8 00 00 00 00	 call	 ?GS_DGAnsCastleStateSync@@YAXPAE@Z ; GS_DGAnsCastleStateSync

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00226	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00229	5d		 pop	 ebp
  0022a	c3		 ret	 0
$LN58@DataServer:

; 243  : 						break;
; 244  : 
; 245  : 					case 0x18:
; 246  : 						GS_DGAnsCastleTributeMoney(aRecv);

  0022b	50		 push	 eax
  0022c	e8 00 00 00 00	 call	 ?GS_DGAnsCastleTributeMoney@@YAXPAE@Z ; GS_DGAnsCastleTributeMoney

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00231	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00234	5d		 pop	 ebp
  00235	c3		 ret	 0
$LN59@DataServer:

; 247  : 						break;
; 248  : 
; 249  : 					case 0x19:
; 250  : 						GS_DGAnsResetCastleTaxInfo(aRecv);

  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 ?GS_DGAnsResetCastleTaxInfo@@YAXPAE@Z ; GS_DGAnsResetCastleTaxInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  0023c	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0023f	5d		 pop	 ebp
  00240	c3		 ret	 0
$LN60@DataServer:

; 251  : 						break;
; 252  : 
; 253  : 					case 0x1A:
; 254  : 						GS_DGAnsResetSiegeGuildInfo(aRecv);

  00241	50		 push	 eax
  00242	e8 00 00 00 00	 call	 ?GS_DGAnsResetSiegeGuildInfo@@YAXPAE@Z ; GS_DGAnsResetSiegeGuildInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00247	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0024a	5d		 pop	 ebp
  0024b	c3		 ret	 0
$LN61@DataServer:

; 255  : 						break;
; 256  : 
; 257  : 					case 0x1B:
; 258  : 						GS_DGAnsResetRegSiegeInfo(aRecv);

  0024c	50		 push	 eax
  0024d	e8 00 00 00 00	 call	 ?GS_DGAnsResetRegSiegeInfo@@YAXPAE@Z ; GS_DGAnsResetRegSiegeInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00252	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00255	5d		 pop	 ebp
  00256	c3		 ret	 0
$LN62@DataServer:

; 259  : 						break;
; 260  : 				}
; 261  : 			}
; 262  : 			break;
; 263  : 
; 264  : 		case 0x81:
; 265  : 			GS_DGAnsCastleInitData(aRecv);

  00257	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0025a	e8 00 00 00 00	 call	 ?GS_DGAnsCastleInitData@@YAXPAE@Z ; GS_DGAnsCastleInitData

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  0025f	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
$LN63@DataServer:

; 266  : 			break;
; 267  : 
; 268  : 		case 0x82:
; 269  : 			GS_DGAnsCastleNpcInfo(aRecv);

  00264	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00267	e8 00 00 00 00	 call	 ?GS_DGAnsCastleNpcInfo@@YAXPAE@Z ; GS_DGAnsCastleNpcInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  0026c	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0026f	5d		 pop	 ebp
  00270	c3		 ret	 0
$LN64@DataServer:

; 270  : 			break;
; 271  : 
; 272  : 		case 0x83:
; 273  : 			GS_DGAnsAllGuildMarkRegInfo(aRecv);

  00271	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00274	e8 00 00 00 00	 call	 ?GS_DGAnsAllGuildMarkRegInfo@@YAXPAE@Z ; GS_DGAnsAllGuildMarkRegInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00279	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0027c	5d		 pop	 ebp
  0027d	c3		 ret	 0
$LN65@DataServer:

; 274  : 			break;
; 275  : 
; 276  : 		case 0x84:
; 277  : 			GS_DGAnsFirstCreateNPC(aRecv);

  0027e	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00281	e8 00 00 00 00	 call	 ?GS_DGAnsFirstCreateNPC@@YAXPAE@Z ; GS_DGAnsFirstCreateNPC

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00286	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00289	5d		 pop	 ebp
  0028a	c3		 ret	 0
$LN66@DataServer:

; 278  : 			break;
; 279  : 
; 280  : 		case 0x85:
; 281  : 			GS_DGAnsCalcREgGuildList(aRecv);

  0028b	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0028e	e8 00 00 00 00	 call	 ?GS_DGAnsCalcREgGuildList@@YAXPAE@Z ; GS_DGAnsCalcREgGuildList

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00293	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00296	5d		 pop	 ebp
  00297	c3		 ret	 0
$LN67@DataServer:

; 282  : 			break;
; 283  : 
; 284  : 		case 0x86:
; 285  : 			GS_DGAnsCsGulidUnionInfo(aRecv);

  00298	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  0029b	e8 00 00 00 00	 call	 ?GS_DGAnsCsGulidUnionInfo@@YAXPAE@Z ; GS_DGAnsCsGulidUnionInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  002a0	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  002a3	5d		 pop	 ebp
  002a4	c3		 ret	 0
$LN68@DataServer:

; 286  : 			break;
; 287  : 
; 288  : 		case 0x87:
; 289  : 			GS_DGAnsCsSaveTotalGuildInfo(aRecv);

  002a5	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  002a8	e8 00 00 00 00	 call	 ?GS_DGAnsCsSaveTotalGuildInfo@@YAXPAE@Z ; GS_DGAnsCsSaveTotalGuildInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  002ad	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  002b0	5d		 pop	 ebp
  002b1	c3		 ret	 0
$LN69@DataServer:

; 290  : 			break;
; 291  : 
; 292  : 		case 0x88:
; 293  : 			GS_DGAnsCsLoadTotalGuildInfo(aRecv);

  002b2	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  002b5	e8 00 00 00 00	 call	 ?GS_DGAnsCsLoadTotalGuildInfo@@YAXPAE@Z ; GS_DGAnsCsLoadTotalGuildInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  002ba	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  002bd	5d		 pop	 ebp
  002be	c3		 ret	 0
$LN70@DataServer:

; 294  : 			break;
; 295  : 
; 296  : 		case 0x89:
; 297  : 			GS_DGAnsCastleNpcUpdate(aRecv);

  002bf	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  002c2	e8 00 00 00 00	 call	 ?GS_DGAnsCastleNpcUpdate@@YAXPAE@Z ; GS_DGAnsCastleNpcUpdate

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  002c7	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  002ca	5d		 pop	 ebp
  002cb	c3		 ret	 0
$LN71@DataServer:

; 298  : 			break;
; 299  : 
; 300  : 		case 0xB0:
; 301  : 			DGAnsCrywolfSync(aRecv);

  002cc	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  002cf	e8 00 00 00 00	 call	 ?DGAnsCrywolfSync@@YAXPAE@Z ; DGAnsCrywolfSync

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  002d4	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  002d7	5d		 pop	 ebp
  002d8	c3		 ret	 0
$LN72@DataServer:

; 302  : 			break;
; 303  : 
; 304  : 		case 0xB1:
; 305  : 			DGAnsCrywolfInfoLoad(aRecv);

  002d9	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  002dc	e8 00 00 00 00	 call	 ?DGAnsCrywolfInfoLoad@@YAXPAE@Z ; DGAnsCrywolfInfoLoad

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  002e1	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  002e4	5d		 pop	 ebp
  002e5	c3		 ret	 0
$LN74@DataServer:

; 306  : 			break;
; 307  : 
; 308  : 		case 0xB2:
; 309  : 			DGAnsCrywolfInfoSave(aRecv);
; 310  : 			break;
; 311  : 
; 312  : 		case 0xCF:
; 313  : 			DGMoveOtherServer((SDHP_CHARACTER_TRANSFER_RESULT *)aRecv);

  002e6	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  002e9	e8 00 00 00 00	 call	 ?DGMoveOtherServer@@YAXPAUSDHP_CHARACTER_TRANSFER_RESULT@@@Z ; DGMoveOtherServer

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  002ee	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  002f1	5d		 pop	 ebp
  002f2	c3		 ret	 0
$LN75@DataServer:

; 314  : 			break;
; 315  : 
; 316  : 		case 0xD0:
; 317  : 			{
; 318  : 				int subcode = -1;
; 319  : 				if( aRecv[0] == 0xC1 )

  002f3	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  002f6	8a 08		 mov	 cl, BYTE PTR [eax]
  002f8	80 f9 c1	 cmp	 cl, 193			; 000000c1H
  002fb	75 06		 jne	 SHORT $LN76@DataServer

; 320  : 				{
; 321  : 					PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;
; 322  : 					subcode = lpMsg->subcode;

  002fd	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00301	eb 0d		 jmp	 SHORT $LN79@DataServer
$LN76@DataServer:

; 323  : 				}
; 324  : 				else if( aRecv[0] == 0xC2 )

  00303	80 f9 c2	 cmp	 cl, 194			; 000000c2H
  00306	0f 85 0f 02 00
	00		 jne	 $LN16@DataServer

; 325  : 				{
; 326  : 					PWMSG_HEAD2 * lpMsg = (PWMSG_HEAD2 *)aRecv;
; 327  : 					subcode = lpMsg->subcode;

  0030c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
$LN79@DataServer:

; 328  : 				}
; 329  : 				else
; 330  : 				{
; 331  : 					break;
; 332  : 				}
; 333  : 
; 334  : 
; 335  : 				switch ( subcode )

  00310	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00313	83 f9 08	 cmp	 ecx, 8
  00316	0f 87 ff 01 00
	00		 ja	 $LN16@DataServer
  0031c	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN130@DataServer[ecx*4]
$LN80@DataServer:

; 336  : 				{
; 337  : 					case 0x02:
; 338  : 						g_CashItemPeriodSystem.DGAnsPeriodItemInquiry((PMSG_ANS_PERIODITEM_INQUIRY *)aRecv);

  00323	50		 push	 eax
  00324	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00329	e8 00 00 00 00	 call	 ?DGAnsPeriodItemInquiry@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_INQUIRY@@@Z ; CCashItemPeriodSystem::DGAnsPeriodItemInquiry

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0032e	5d		 pop	 ebp
  0032f	c3		 ret	 0
$LN81@DataServer:

; 339  : 						break;
; 340  : 
; 341  : 					case 0x04:
; 342  : 						g_CashItemPeriodSystem.DGAnsPeriodItemInsert((PMSG_ANS_PERIODITEM_INSERT *)aRecv);

  00330	50		 push	 eax
  00331	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00336	e8 00 00 00 00	 call	 ?DGAnsPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_INSERT@@@Z ; CCashItemPeriodSystem::DGAnsPeriodItemInsert

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0033b	5d		 pop	 ebp
  0033c	c3		 ret	 0
$LN82@DataServer:

; 343  : 						break;
; 344  : 
; 345  : 					case 0x06:
; 346  : 						g_CashItemPeriodSystem.DGAnsPeriodItemList((PMSG_ANS_PERIODITEM_LIST *)aRecv);

  0033d	50		 push	 eax
  0033e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00343	e8 00 00 00 00	 call	 ?DGAnsPeriodItemList@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_LIST@@@Z ; CCashItemPeriodSystem::DGAnsPeriodItemList

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00348	5d		 pop	 ebp
  00349	c3		 ret	 0
$LN83@DataServer:

; 347  : 						break;
; 348  : 
; 349  : 					case 0x08:
; 350  : 						g_CashItemPeriodSystem.DGAnsPeriodItemUpdate((PMSG_ANS_PERIODITEM_UPDATE *)aRecv);

  0034a	50		 push	 eax
  0034b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00350	e8 00 00 00 00	 call	 ?DGAnsPeriodItemUpdate@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_UPDATE@@@Z ; CCashItemPeriodSystem::DGAnsPeriodItemUpdate

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00355	5d		 pop	 ebp
  00356	c3		 ret	 0
$LN84@DataServer:

; 351  : 						break;
; 352  : 					case 0x0A:
; 353  : 						g_CashItemPeriodSystem.DGAnsPeriodItemDelete((PMSG_ANS_PERIODITEM_DELETE *)aRecv);

  00357	50		 push	 eax
  00358	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  0035d	e8 00 00 00 00	 call	 ?DGAnsPeriodItemDelete@CCashItemPeriodSystem@@QAEXPAUPMSG_ANS_PERIODITEM_DELETE@@@Z ; CCashItemPeriodSystem::DGAnsPeriodItemDelete

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00362	5d		 pop	 ebp
  00363	c3		 ret	 0
$LN85@DataServer:

; 354  : 						break;
; 355  : 				}
; 356  : 			}
; 357  : 			break;
; 358  : 		case 0x72:
; 359  : 			JGPSummonerInfo((PMSG_ANS_SUMMONER_CREATE*)aRecv);

  00364	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00367	e8 00 00 00 00	 call	 ?JGPSummonerInfo@@YAXPAUPMSG_ANS_SUMMONER_CREATE@@@Z ; JGPSummonerInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  0036c	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0036f	5d		 pop	 ebp
  00370	c3		 ret	 0
$LN86@DataServer:

; 360  : 			break;
; 361  : 		case 0xA4:
; 362  : 			g_ElementalSystem.DGAnsErtelList((PMSG_ANS_ERTELLIST*)aRecv);

  00371	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00374	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00379	e8 00 00 00 00	 call	 ?DGAnsErtelList@CElementalSystem@@QAEXPAUPMSG_ANS_ERTELLIST@@@Z ; CElementalSystem::DGAnsErtelList

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0037e	5d		 pop	 ebp
  0037f	c3		 ret	 0
$LN87@DataServer:

; 363  : 			break;
; 364  : 		case 0xEF:
; 365  : 			{
; 366  : 				int subcode = -1;
; 367  : 				if( aRecv[0] == 0xC1 )

  00380	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00383	8a 08		 mov	 cl, BYTE PTR [eax]
  00385	80 f9 c1	 cmp	 cl, 193			; 000000c1H
  00388	75 06		 jne	 SHORT $LN88@DataServer

; 368  : 				{
; 369  : 					PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;
; 370  : 					subcode = lpMsg->subcode;

  0038a	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0038e	eb 0d		 jmp	 SHORT $LN90@DataServer
$LN88@DataServer:

; 371  : 				}
; 372  : 				else if( aRecv[0] == 0xC2 )

  00390	80 f9 c2	 cmp	 cl, 194			; 000000c2H
  00393	0f 85 82 01 00
	00		 jne	 $LN16@DataServer

; 373  : 				{
; 374  : 					PWMSG_HEAD2 * lpMsg = (PWMSG_HEAD2 *)aRecv;
; 375  : 					subcode = lpMsg->subcode;

  00399	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
$LN90@DataServer:

; 376  : 				}
; 377  : 
; 378  : 				switch(subcode)

  0039d	83 f9 06	 cmp	 ecx, 6
  003a0	0f 87 75 01 00
	00		 ja	 $LN16@DataServer
  003a6	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN131@DataServer[ecx*4]
$LN91@DataServer:

; 379  : 				{
; 380  : 				case 0x00:
; 381  : 					DGAnsPartyMatchReg((PMSG_PARTYMATCHING_REG_ANS*)aRecv);

  003ad	50		 push	 eax
  003ae	e8 00 00 00 00	 call	 ?DGAnsPartyMatchReg@@YAXPAUPMSG_PARTYMATCHING_REG_ANS@@@Z ; DGAnsPartyMatchReg

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  003b3	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  003b6	5d		 pop	 ebp
  003b7	c3		 ret	 0
$LN92@DataServer:

; 382  : 					break;
; 383  : 				case 0x01:
; 384  : 					DGAnsPartyMatchInfo(aRecv);

  003b8	50		 push	 eax
  003b9	e8 00 00 00 00	 call	 ?DGAnsPartyMatchInfo@@YAXPAE@Z ; DGAnsPartyMatchInfo

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  003be	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  003c1	5d		 pop	 ebp
  003c2	c3		 ret	 0
$LN93@DataServer:

; 385  : 					break;
; 386  : 				case 0x02:
; 387  : 					DGAnsPartyMatchJoin((PMSG_PARTYMATCHING_JOIN_ANS*)aRecv);

  003c3	50		 push	 eax
  003c4	e8 00 00 00 00	 call	 ?DGAnsPartyMatchJoin@@YAXPAUPMSG_PARTYMATCHING_JOIN_ANS@@@Z ; DGAnsPartyMatchJoin

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  003c9	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  003cc	5d		 pop	 ebp
  003cd	c3		 ret	 0
$LN94@DataServer:

; 388  : 					break;
; 389  : 				case 0x03:
; 390  : 					DGAnsPartyMatchWaitlist((PMSG_PARTYMATCHING_WAIT_ANS*)aRecv);

  003ce	50		 push	 eax
  003cf	e8 00 00 00 00	 call	 ?DGAnsPartyMatchWaitlist@@YAXPAUPMSG_PARTYMATCHING_WAIT_ANS@@@Z ; DGAnsPartyMatchWaitlist

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  003d4	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  003d7	5d		 pop	 ebp
  003d8	c3		 ret	 0
$LN95@DataServer:

; 391  : 					break;
; 392  : 				case 0x04:
; 393  : 					DGAnsPartyMatchAcceptList(aRecv);

  003d9	50		 push	 eax
  003da	e8 00 00 00 00	 call	 ?DGAnsPartyMatchAcceptList@@YAXPAE@Z ; DGAnsPartyMatchAcceptList

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  003df	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  003e2	5d		 pop	 ebp
  003e3	c3		 ret	 0
$LN96@DataServer:

; 394  : 					break;
; 395  : 				case 0x05:
; 396  : 					DGAnsPartyMatchRequestAnswer((PARTYMATCH_DGANS_REQUESTANSWER*)aRecv);

  003e4	50		 push	 eax
  003e5	e8 00 00 00 00	 call	 ?DGAnsPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_DGANS_REQUESTANSWER@@@Z ; DGAnsPartyMatchRequestAnswer

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  003ea	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  003ed	5d		 pop	 ebp
  003ee	c3		 ret	 0
$LN97@DataServer:

; 397  : 					break;
; 398  : 				case 0x06:
; 399  : 					DGAnsPartyMatchCancel((PMSG_PARTYMATCHING_CANCEL_ANS*)aRecv);

  003ef	50		 push	 eax
  003f0	e8 00 00 00 00	 call	 ?DGAnsPartyMatchCancel@@YAXPAUPMSG_PARTYMATCHING_CANCEL_ANS@@@Z ; DGAnsPartyMatchCancel

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  003f5	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  003f8	5d		 pop	 ebp
  003f9	c3		 ret	 0
$LN98@DataServer:

; 400  : 					break;
; 401  : 				}
; 402  : 			}
; 403  : 			break;
; 404  : 		case 0xED:
; 405  : 			{
; 406  : 				int subcode = -1;
; 407  : 
; 408  : 				if( aRecv[0] == 0xC1 )

  003fa	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  003fd	8a 08		 mov	 cl, BYTE PTR [eax]
  003ff	80 f9 c1	 cmp	 cl, 193			; 000000c1H
  00402	75 06		 jne	 SHORT $LN99@DataServer

; 409  : 				{
; 410  : 					PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;
; 411  : 					subcode = lpMsg->subcode;

  00404	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00408	eb 0d		 jmp	 SHORT $LN101@DataServer
$LN99@DataServer:

; 412  : 				}
; 413  : 				else if( aRecv[0] == 0xC2 )

  0040a	80 f9 c2	 cmp	 cl, 194			; 000000c2H
  0040d	0f 85 08 01 00
	00		 jne	 $LN16@DataServer

; 414  : 				{
; 415  : 					PWMSG_HEAD2 * lpMsg = (PWMSG_HEAD2 *)aRecv;
; 416  : 					subcode = lpMsg->subcode;

  00413	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
$LN101@DataServer:

; 417  : 				}
; 418  : 				
; 419  : 				switch(subcode)

  00417	83 f9 08	 cmp	 ecx, 8
  0041a	0f 87 fb 00 00
	00		 ja	 $LN16@DataServer
  00420	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN132@DataServer[ecx*4]
$LN102@DataServer:

; 420  : 				{
; 421  : 				case 0x00:
; 422  : 					g_GuildMatch.DGAnsOfferList(aRecv);

  00427	50		 push	 eax
  00428	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  0042d	e8 00 00 00 00	 call	 ?DGAnsOfferList@GuildMatch@@QAEXPAE@Z ; GuildMatch::DGAnsOfferList

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00432	5d		 pop	 ebp
  00433	c3		 ret	 0
$LN103@DataServer:

; 423  : 					break;
; 424  : 				case 0x02:
; 425  : 					g_GuildMatch.DGAnsOfferCreate((GUILDMATCH_DGANS_OFFERCREATE*)aRecv);

  00434	50		 push	 eax
  00435	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  0043a	e8 00 00 00 00	 call	 ?DGAnsOfferCreate@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_OFFERCREATE@@@Z ; GuildMatch::DGAnsOfferCreate

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0043f	5d		 pop	 ebp
  00440	c3		 ret	 0
$LN104@DataServer:

; 426  : 					break;
; 427  : 				case 0x03:
; 428  : 					g_GuildMatch.DGAnsOfferDelete((GUILDMATCH_DGANS_OFFERDELETE*)aRecv);

  00441	50		 push	 eax
  00442	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00447	e8 00 00 00 00	 call	 ?DGAnsOfferDelete@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_OFFERDELETE@@@Z ; GuildMatch::DGAnsOfferDelete

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0044c	5d		 pop	 ebp
  0044d	c3		 ret	 0
$LN105@DataServer:

; 429  : 					break;
; 430  : 				case 0x04:
; 431  : 					g_GuildMatch.DGAnsJoinReq((GUILDMATCH_DGANS_JOINREQ*)aRecv);

  0044e	50		 push	 eax
  0044f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00454	e8 00 00 00 00	 call	 ?DGAnsJoinReq@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_JOINREQ@@@Z ; GuildMatch::DGAnsJoinReq

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00459	5d		 pop	 ebp
  0045a	c3		 ret	 0
$LN106@DataServer:

; 432  : 					break;
; 433  : 				case 0x05:
; 434  : 					g_GuildMatch.DGAnsJoinReqDelete((GUILDMATCH_DGANS_OFFERDELETE*)aRecv);

  0045b	50		 push	 eax
  0045c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00461	e8 00 00 00 00	 call	 ?DGAnsJoinReqDelete@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_OFFERDELETE@@@Z ; GuildMatch::DGAnsJoinReqDelete

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00466	5d		 pop	 ebp
  00467	c3		 ret	 0
$LN107@DataServer:

; 435  : 					break;
; 436  : 				case 0x06:
; 437  : 					g_GuildMatch.DGAnsJoinReqAnswer((GUILDMATCH_DGANS_REQUESTANSWER*)aRecv);

  00468	50		 push	 eax
  00469	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  0046e	e8 00 00 00 00	 call	 ?DGAnsJoinReqAnswer@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_REQUESTANSWER@@@Z ; GuildMatch::DGAnsJoinReqAnswer

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00473	5d		 pop	 ebp
  00474	c3		 ret	 0
$LN108@DataServer:

; 438  : 					break;
; 439  : 				case 0x07:
; 440  : 					g_GuildMatch.DGAnsJoinReqList(aRecv);

  00475	50		 push	 eax
  00476	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  0047b	e8 00 00 00 00	 call	 ?DGAnsJoinReqList@GuildMatch@@QAEXPAE@Z ; GuildMatch::DGAnsJoinReqList

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  00480	5d		 pop	 ebp
  00481	c3		 ret	 0
$LN109@DataServer:

; 441  : 					break;
; 442  : 				case 0x08:
; 443  : 					g_GuildMatch.DGAnsJoinReqStatus((GUILDMATCH_DGANS_JOINREQSTATUS*)aRecv);

  00482	50		 push	 eax
  00483	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00488	e8 00 00 00 00	 call	 ?DGAnsJoinReqStatus@GuildMatch@@QAEXPAUGUILDMATCH_DGANS_JOINREQSTATUS@@@Z ; GuildMatch::DGAnsJoinReqStatus

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0048d	5d		 pop	 ebp
  0048e	c3		 ret	 0
$LN110@DataServer:

; 444  : 					break;
; 445  : 				}
; 446  : 			}
; 447  : 			break;
; 448  : #if (ENABLETEST_RUMMY == 1)
; 449  : 		case 0xE8:
; 450  : 			{
; 451  : 				if (aRecv[3] == 0)
; 452  : 				{
; 453  : 					g_CMuRummyMng.GDAnsCardInfo((_tagPMSG_ANS_MURUMMY_SELECT_DS*)aRecv);
; 454  : 				}
; 455  : 			}
; 456  : 			break;
; 457  : #endif
; 458  : 		case 0xCD:
; 459  : 			{
; 460  : 				DGBroadCastGlobalMessage(aRecv);

  0048f	ff 75 0c	 push	 DWORD PTR _aRecv$[ebp]
  00492	e8 00 00 00 00	 call	 ?DGBroadCastGlobalMessage@@YAXPAE@Z ; DGBroadCastGlobalMessage

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00497	83 c4 04	 add	 esp, 4

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0049a	5d		 pop	 ebp
  0049b	c3		 ret	 0
$LN111@DataServer:

; 461  : 			}
; 462  : 			break;
; 463  : 		case 0xFD:
; 464  : 			{
; 465  : 				int subcode = -1;
; 466  : 				
; 467  : 				if( aRecv[0] == 0xC1 )

  0049c	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0049f	8a 08		 mov	 cl, BYTE PTR [eax]
  004a1	80 f9 c1	 cmp	 cl, 193			; 000000c1H
  004a4	75 06		 jne	 SHORT $LN112@DataServer

; 468  : 				{
; 469  : 					PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;
; 470  : 					subcode = lpMsg->subcode;

  004a6	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  004aa	eb 09		 jmp	 SHORT $LN114@DataServer
$LN112@DataServer:

; 471  : 				}
; 472  : 				else if( aRecv[0] == 0xC2 )

  004ac	80 f9 c2	 cmp	 cl, 194			; 000000c2H
  004af	75 6a		 jne	 SHORT $LN16@DataServer

; 473  : 				{
; 474  : 					PWMSG_HEAD2 * lpMsg = (PWMSG_HEAD2 *)aRecv;
; 475  : 					subcode = lpMsg->subcode;

  004b1	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
$LN114@DataServer:

; 476  : 				}
; 477  : 				
; 478  : 				switch(subcode)

  004b5	83 f9 04	 cmp	 ecx, 4
  004b8	75 61		 jne	 SHORT $LN16@DataServer

; 479  : 				{
; 480  : 					case 0x04:
; 481  : 						gWareHouseSYSTEM.DBSendVaultResult((PMSG_VAULT_RESULT*)aRecv);

  004ba	50		 push	 eax
  004bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gWareHouseSYSTEM@@3VWareHouseSYSTEM@@A ; gWareHouseSYSTEM
  004c0	e8 00 00 00 00	 call	 ?DBSendVaultResult@WareHouseSYSTEM@@QAEXPAUPMSG_VAULT_RESULT@@@Z ; WareHouseSYSTEM::DBSendVaultResult

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  004c5	5d		 pop	 ebp
  004c6	c3		 ret	 0
$LN123@DataServer:

; 76   : 
; 77   : #if( DEBUG_PROTOCOL == 1 )
; 78   : 		LogAddHeadHexFunc(1, (LPSTR)aRecv, aLen);
; 79   : #endif
; 80   : 
; 81   : 	switch ( protoNum )

  004c7	2d fe 00 00 00	 sub	 eax, 254		; 000000feH
  004cc	74 23		 je	 SHORT $LN116@DataServer
  004ce	83 e8 01	 sub	 eax, 1
  004d1	75 48		 jne	 SHORT $LN16@DataServer

; 503  : 			break;
; 504  : 				}
; 505  : 			 } break;
; 506  : 		case 0xFF:	// Test Packet
; 507  : 			{
; 508  : 				PMSG_TEST * pMsg = (PMSG_TEST *)aRecv;
; 509  : 
; 510  : 				LogAddC(2, "error-L2DataServer RECV : %d (%d)", aLen, pMsg->count);

  004d3	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  004d6	ff b0 d0 07 00
	00		 push	 DWORD PTR [eax+2000]
  004dc	ff 75 10	 push	 DWORD PTR _aLen$[ebp]
  004df	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MBCBAID@error?9L2DataServer?5RECV?5?3?5?$CFd?5?$CI?$CFd@
  004e4	6a 02		 push	 2
  004e6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  004ec	83 c4 10	 add	 esp, 16			; 00000010H

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  004ef	5d		 pop	 ebp
  004f0	c3		 ret	 0
$LN116@DataServer:

; 482  : 						break;
; 483  : 				}
; 484  : 			}
; 485  : 			break;
; 486  : 		case 0xFE: 
; 487  : 			{
; 488  : 				int subcode = -1;
; 489  : 				if( aRecv[0] == 0xC1 )

  004f1	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  004f4	83 c8 ff	 or	 eax, -1
  004f7	8a 11		 mov	 dl, BYTE PTR [ecx]
  004f9	80 fa c1	 cmp	 dl, 193			; 000000c1H
  004fc	75 06		 jne	 SHORT $LN117@DataServer

; 490  : 				{
; 491  : 					PMSG_DEFAULT2 * lpMsg = (PMSG_DEFAULT2 *)aRecv;
; 492  : 					subcode = lpMsg->subcode;

  004fe	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00502	eb 09		 jmp	 SHORT $LN119@DataServer
$LN117@DataServer:

; 493  : 				}
; 494  : 				else if( aRecv[0] == 0xC2 )

  00504	80 fa c2	 cmp	 dl, 194			; 000000c2H
  00507	75 04		 jne	 SHORT $LN119@DataServer

; 495  : 				{
; 496  : 					PWMSG_HEAD2 * lpMsg = (PWMSG_HEAD2 *)aRecv;
; 497  : 					subcode = lpMsg->subcode;

  00509	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
$LN119@DataServer:

; 498  : 				}
; 499  : 
; 500  : 				switch(subcode) {

  0050d	83 e8 02	 sub	 eax, 2
  00510	75 09		 jne	 SHORT $LN16@DataServer

; 501  : 		case 2:
; 502  : 			answerDbInfo((packetDbAnswerInfo*)aRecv);

  00512	51		 push	 ecx
  00513	e8 00 00 00 00	 call	 ?answerDbInfo@@YAXPAUpacketDbAnswerInfo@@@Z ; answerDbInfo
  00518	83 c4 04	 add	 esp, 4
$LN16@DataServer:

; 511  : 			}
; 512  : 			break;
; 513  : 	}
; 514  : }

  0051b	5d		 pop	 ebp
  0051c	c3		 ret	 0
  0051d	0f 1f 00	 npad	 3
$LN127@DataServer:
  00520	00 00 00 00	 DD	 $LN18@DataServer
  00524	00 00 00 00	 DD	 $LN19@DataServer
  00528	00 00 00 00	 DD	 $LN20@DataServer
  0052c	00 00 00 00	 DD	 $LN21@DataServer
  00530	00 00 00 00	 DD	 $LN22@DataServer
  00534	00 00 00 00	 DD	 $LN23@DataServer
  00538	00 00 00 00	 DD	 $LN24@DataServer
  0053c	00 00 00 00	 DD	 $LN25@DataServer
  00540	00 00 00 00	 DD	 $LN26@DataServer
  00544	00 00 00 00	 DD	 $LN32@DataServer
  00548	00 00 00 00	 DD	 $LN27@DataServer
  0054c	00 00 00 00	 DD	 $LN33@DataServer
  00550	00 00 00 00	 DD	 $LN34@DataServer
  00554	00 00 00 00	 DD	 $LN35@DataServer
  00558	00 00 00 00	 DD	 $LN36@DataServer
  0055c	00 00 00 00	 DD	 $LN85@DataServer
  00560	00 00 00 00	 DD	 $LN37@DataServer
  00564	00 00 00 00	 DD	 $LN62@DataServer
  00568	00 00 00 00	 DD	 $LN63@DataServer
  0056c	00 00 00 00	 DD	 $LN64@DataServer
  00570	00 00 00 00	 DD	 $LN65@DataServer
  00574	00 00 00 00	 DD	 $LN66@DataServer
  00578	00 00 00 00	 DD	 $LN67@DataServer
  0057c	00 00 00 00	 DD	 $LN68@DataServer
  00580	00 00 00 00	 DD	 $LN69@DataServer
  00584	00 00 00 00	 DD	 $LN70@DataServer
  00588	00 00 00 00	 DD	 $LN86@DataServer
  0058c	00 00 00 00	 DD	 $LN71@DataServer
  00590	00 00 00 00	 DD	 $LN72@DataServer
  00594	00 00 00 00	 DD	 $LN16@DataServer
  00598	00 00 00 00	 DD	 $LN110@DataServer
  0059c	00 00 00 00	 DD	 $LN74@DataServer
  005a0	00 00 00 00	 DD	 $LN75@DataServer
  005a4	00 00 00 00	 DD	 $LN98@DataServer
  005a8	00 00 00 00	 DD	 $LN87@DataServer
  005ac	00 00 00 00	 DD	 $LN16@DataServer
$LN124@DataServer:
  005b0	00		 DB	 0
  005b1	01		 DB	 1
  005b2	23		 DB	 35			; 00000023H
  005b3	23		 DB	 35			; 00000023H
  005b4	02		 DB	 2
  005b5	03		 DB	 3
  005b6	04		 DB	 4
  005b7	23		 DB	 35			; 00000023H
  005b8	05		 DB	 5
  005b9	23		 DB	 35			; 00000023H
  005ba	23		 DB	 35			; 00000023H
  005bb	23		 DB	 35			; 00000023H
  005bc	23		 DB	 35			; 00000023H
  005bd	23		 DB	 35			; 00000023H
  005be	23		 DB	 35			; 00000023H
  005bf	23		 DB	 35			; 00000023H
  005c0	06		 DB	 6
  005c1	23		 DB	 35			; 00000023H
  005c2	23		 DB	 35			; 00000023H
  005c3	23		 DB	 35			; 00000023H
  005c4	07		 DB	 7
  005c5	23		 DB	 35			; 00000023H
  005c6	08		 DB	 8
  005c7	23		 DB	 35			; 00000023H
  005c8	23		 DB	 35			; 00000023H
  005c9	23		 DB	 35			; 00000023H
  005ca	23		 DB	 35			; 00000023H
  005cb	23		 DB	 35			; 00000023H
  005cc	23		 DB	 35			; 00000023H
  005cd	23		 DB	 35			; 00000023H
  005ce	23		 DB	 35			; 00000023H
  005cf	23		 DB	 35			; 00000023H
  005d0	23		 DB	 35			; 00000023H
  005d1	23		 DB	 35			; 00000023H
  005d2	23		 DB	 35			; 00000023H
  005d3	23		 DB	 35			; 00000023H
  005d4	23		 DB	 35			; 00000023H
  005d5	23		 DB	 35			; 00000023H
  005d6	23		 DB	 35			; 00000023H
  005d7	23		 DB	 35			; 00000023H
  005d8	23		 DB	 35			; 00000023H
  005d9	23		 DB	 35			; 00000023H
  005da	23		 DB	 35			; 00000023H
  005db	23		 DB	 35			; 00000023H
  005dc	23		 DB	 35			; 00000023H
  005dd	23		 DB	 35			; 00000023H
  005de	23		 DB	 35			; 00000023H
  005df	23		 DB	 35			; 00000023H
  005e0	09		 DB	 9
  005e1	23		 DB	 35			; 00000023H
  005e2	23		 DB	 35			; 00000023H
  005e3	23		 DB	 35			; 00000023H
  005e4	23		 DB	 35			; 00000023H
  005e5	23		 DB	 35			; 00000023H
  005e6	23		 DB	 35			; 00000023H
  005e7	23		 DB	 35			; 00000023H
  005e8	23		 DB	 35			; 00000023H
  005e9	23		 DB	 35			; 00000023H
  005ea	23		 DB	 35			; 00000023H
  005eb	23		 DB	 35			; 00000023H
  005ec	23		 DB	 35			; 00000023H
  005ed	23		 DB	 35			; 00000023H
  005ee	23		 DB	 35			; 00000023H
  005ef	23		 DB	 35			; 00000023H
  005f0	0a		 DB	 10			; 0000000aH
  005f1	23		 DB	 35			; 00000023H
  005f2	23		 DB	 35			; 00000023H
  005f3	23		 DB	 35			; 00000023H
  005f4	23		 DB	 35			; 00000023H
  005f5	23		 DB	 35			; 00000023H
  005f6	23		 DB	 35			; 00000023H
  005f7	23		 DB	 35			; 00000023H
  005f8	23		 DB	 35			; 00000023H
  005f9	23		 DB	 35			; 00000023H
  005fa	23		 DB	 35			; 00000023H
  005fb	23		 DB	 35			; 00000023H
  005fc	23		 DB	 35			; 00000023H
  005fd	23		 DB	 35			; 00000023H
  005fe	23		 DB	 35			; 00000023H
  005ff	23		 DB	 35			; 00000023H
  00600	23		 DB	 35			; 00000023H
  00601	23		 DB	 35			; 00000023H
  00602	0b		 DB	 11			; 0000000bH
  00603	23		 DB	 35			; 00000023H
  00604	23		 DB	 35			; 00000023H
  00605	23		 DB	 35			; 00000023H
  00606	0c		 DB	 12			; 0000000cH
  00607	23		 DB	 35			; 00000023H
  00608	23		 DB	 35			; 00000023H
  00609	23		 DB	 35			; 00000023H
  0060a	23		 DB	 35			; 00000023H
  0060b	23		 DB	 35			; 00000023H
  0060c	23		 DB	 35			; 00000023H
  0060d	23		 DB	 35			; 00000023H
  0060e	23		 DB	 35			; 00000023H
  0060f	23		 DB	 35			; 00000023H
  00610	0d		 DB	 13			; 0000000dH
  00611	0e		 DB	 14			; 0000000eH
  00612	23		 DB	 35			; 00000023H
  00613	23		 DB	 35			; 00000023H
  00614	23		 DB	 35			; 00000023H
  00615	23		 DB	 35			; 00000023H
  00616	23		 DB	 35			; 00000023H
  00617	23		 DB	 35			; 00000023H
  00618	23		 DB	 35			; 00000023H
  00619	23		 DB	 35			; 00000023H
  0061a	23		 DB	 35			; 00000023H
  0061b	23		 DB	 35			; 00000023H
  0061c	23		 DB	 35			; 00000023H
  0061d	23		 DB	 35			; 00000023H
  0061e	23		 DB	 35			; 00000023H
  0061f	23		 DB	 35			; 00000023H
  00620	23		 DB	 35			; 00000023H
  00621	23		 DB	 35			; 00000023H
  00622	0f		 DB	 15			; 0000000fH
  00623	23		 DB	 35			; 00000023H
  00624	23		 DB	 35			; 00000023H
  00625	23		 DB	 35			; 00000023H
  00626	23		 DB	 35			; 00000023H
  00627	23		 DB	 35			; 00000023H
  00628	23		 DB	 35			; 00000023H
  00629	23		 DB	 35			; 00000023H
  0062a	23		 DB	 35			; 00000023H
  0062b	23		 DB	 35			; 00000023H
  0062c	23		 DB	 35			; 00000023H
  0062d	23		 DB	 35			; 00000023H
  0062e	23		 DB	 35			; 00000023H
  0062f	23		 DB	 35			; 00000023H
  00630	10		 DB	 16			; 00000010H
  00631	11		 DB	 17			; 00000011H
  00632	12		 DB	 18			; 00000012H
  00633	13		 DB	 19			; 00000013H
  00634	14		 DB	 20			; 00000014H
  00635	15		 DB	 21			; 00000015H
  00636	16		 DB	 22			; 00000016H
  00637	17		 DB	 23			; 00000017H
  00638	18		 DB	 24			; 00000018H
  00639	19		 DB	 25			; 00000019H
  0063a	23		 DB	 35			; 00000023H
  0063b	23		 DB	 35			; 00000023H
  0063c	23		 DB	 35			; 00000023H
  0063d	23		 DB	 35			; 00000023H
  0063e	23		 DB	 35			; 00000023H
  0063f	23		 DB	 35			; 00000023H
  00640	23		 DB	 35			; 00000023H
  00641	23		 DB	 35			; 00000023H
  00642	23		 DB	 35			; 00000023H
  00643	23		 DB	 35			; 00000023H
  00644	23		 DB	 35			; 00000023H
  00645	23		 DB	 35			; 00000023H
  00646	23		 DB	 35			; 00000023H
  00647	23		 DB	 35			; 00000023H
  00648	23		 DB	 35			; 00000023H
  00649	23		 DB	 35			; 00000023H
  0064a	23		 DB	 35			; 00000023H
  0064b	23		 DB	 35			; 00000023H
  0064c	23		 DB	 35			; 00000023H
  0064d	23		 DB	 35			; 00000023H
  0064e	23		 DB	 35			; 00000023H
  0064f	23		 DB	 35			; 00000023H
  00650	23		 DB	 35			; 00000023H
  00651	23		 DB	 35			; 00000023H
  00652	23		 DB	 35			; 00000023H
  00653	23		 DB	 35			; 00000023H
  00654	1a		 DB	 26			; 0000001aH
  00655	23		 DB	 35			; 00000023H
  00656	23		 DB	 35			; 00000023H
  00657	23		 DB	 35			; 00000023H
  00658	23		 DB	 35			; 00000023H
  00659	23		 DB	 35			; 00000023H
  0065a	23		 DB	 35			; 00000023H
  0065b	23		 DB	 35			; 00000023H
  0065c	23		 DB	 35			; 00000023H
  0065d	23		 DB	 35			; 00000023H
  0065e	23		 DB	 35			; 00000023H
  0065f	23		 DB	 35			; 00000023H
  00660	1b		 DB	 27			; 0000001bH
  00661	1c		 DB	 28			; 0000001cH
  00662	1d		 DB	 29			; 0000001dH
  00663	23		 DB	 35			; 00000023H
  00664	23		 DB	 35			; 00000023H
  00665	23		 DB	 35			; 00000023H
  00666	23		 DB	 35			; 00000023H
  00667	23		 DB	 35			; 00000023H
  00668	23		 DB	 35			; 00000023H
  00669	23		 DB	 35			; 00000023H
  0066a	23		 DB	 35			; 00000023H
  0066b	23		 DB	 35			; 00000023H
  0066c	23		 DB	 35			; 00000023H
  0066d	23		 DB	 35			; 00000023H
  0066e	23		 DB	 35			; 00000023H
  0066f	23		 DB	 35			; 00000023H
  00670	23		 DB	 35			; 00000023H
  00671	23		 DB	 35			; 00000023H
  00672	23		 DB	 35			; 00000023H
  00673	23		 DB	 35			; 00000023H
  00674	23		 DB	 35			; 00000023H
  00675	23		 DB	 35			; 00000023H
  00676	23		 DB	 35			; 00000023H
  00677	23		 DB	 35			; 00000023H
  00678	23		 DB	 35			; 00000023H
  00679	23		 DB	 35			; 00000023H
  0067a	23		 DB	 35			; 00000023H
  0067b	23		 DB	 35			; 00000023H
  0067c	23		 DB	 35			; 00000023H
  0067d	1e		 DB	 30			; 0000001eH
  0067e	23		 DB	 35			; 00000023H
  0067f	1f		 DB	 31			; 0000001fH
  00680	20		 DB	 32			; 00000020H
  00681	23		 DB	 35			; 00000023H
  00682	23		 DB	 35			; 00000023H
  00683	23		 DB	 35			; 00000023H
  00684	23		 DB	 35			; 00000023H
  00685	23		 DB	 35			; 00000023H
  00686	23		 DB	 35			; 00000023H
  00687	23		 DB	 35			; 00000023H
  00688	23		 DB	 35			; 00000023H
  00689	23		 DB	 35			; 00000023H
  0068a	23		 DB	 35			; 00000023H
  0068b	23		 DB	 35			; 00000023H
  0068c	23		 DB	 35			; 00000023H
  0068d	23		 DB	 35			; 00000023H
  0068e	23		 DB	 35			; 00000023H
  0068f	23		 DB	 35			; 00000023H
  00690	23		 DB	 35			; 00000023H
  00691	23		 DB	 35			; 00000023H
  00692	23		 DB	 35			; 00000023H
  00693	23		 DB	 35			; 00000023H
  00694	23		 DB	 35			; 00000023H
  00695	23		 DB	 35			; 00000023H
  00696	23		 DB	 35			; 00000023H
  00697	23		 DB	 35			; 00000023H
  00698	23		 DB	 35			; 00000023H
  00699	23		 DB	 35			; 00000023H
  0069a	23		 DB	 35			; 00000023H
  0069b	23		 DB	 35			; 00000023H
  0069c	23		 DB	 35			; 00000023H
  0069d	21		 DB	 33			; 00000021H
  0069e	23		 DB	 35			; 00000023H
  0069f	22		 DB	 34			; 00000022H
$LN128@DataServer:
  006a0	00 00 00 00	 DD	 $LN28@DataServer
  006a4	00 00 00 00	 DD	 $LN29@DataServer
  006a8	00 00 00 00	 DD	 $LN30@DataServer
  006ac	00 00 00 00	 DD	 $LN16@DataServer
  006b0	00 00 00 00	 DD	 $LN31@DataServer
$LN129@DataServer:
  006b4	00 00 00 00	 DD	 $LN38@DataServer
  006b8	00 00 00 00	 DD	 $LN39@DataServer
  006bc	00 00 00 00	 DD	 $LN16@DataServer
  006c0	00 00 00 00	 DD	 $LN40@DataServer
  006c4	00 00 00 00	 DD	 $LN41@DataServer
  006c8	00 00 00 00	 DD	 $LN42@DataServer
  006cc	00 00 00 00	 DD	 $LN43@DataServer
  006d0	00 00 00 00	 DD	 $LN44@DataServer
  006d4	00 00 00 00	 DD	 $LN45@DataServer
  006d8	00 00 00 00	 DD	 $LN46@DataServer
  006dc	00 00 00 00	 DD	 $LN47@DataServer
  006e0	00 00 00 00	 DD	 $LN48@DataServer
  006e4	00 00 00 00	 DD	 $LN49@DataServer
  006e8	00 00 00 00	 DD	 $LN50@DataServer
  006ec	00 00 00 00	 DD	 $LN51@DataServer
  006f0	00 00 00 00	 DD	 $LN52@DataServer
  006f4	00 00 00 00	 DD	 $LN53@DataServer
  006f8	00 00 00 00	 DD	 $LN54@DataServer
  006fc	00 00 00 00	 DD	 $LN55@DataServer
  00700	00 00 00 00	 DD	 $LN16@DataServer
  00704	00 00 00 00	 DD	 $LN16@DataServer
  00708	00 00 00 00	 DD	 $LN16@DataServer
  0070c	00 00 00 00	 DD	 $LN56@DataServer
  00710	00 00 00 00	 DD	 $LN57@DataServer
  00714	00 00 00 00	 DD	 $LN58@DataServer
  00718	00 00 00 00	 DD	 $LN59@DataServer
  0071c	00 00 00 00	 DD	 $LN60@DataServer
  00720	00 00 00 00	 DD	 $LN61@DataServer
$LN130@DataServer:
  00724	00 00 00 00	 DD	 $LN80@DataServer
  00728	00 00 00 00	 DD	 $LN16@DataServer
  0072c	00 00 00 00	 DD	 $LN81@DataServer
  00730	00 00 00 00	 DD	 $LN16@DataServer
  00734	00 00 00 00	 DD	 $LN82@DataServer
  00738	00 00 00 00	 DD	 $LN16@DataServer
  0073c	00 00 00 00	 DD	 $LN83@DataServer
  00740	00 00 00 00	 DD	 $LN16@DataServer
  00744	00 00 00 00	 DD	 $LN84@DataServer
$LN131@DataServer:
  00748	00 00 00 00	 DD	 $LN91@DataServer
  0074c	00 00 00 00	 DD	 $LN92@DataServer
  00750	00 00 00 00	 DD	 $LN93@DataServer
  00754	00 00 00 00	 DD	 $LN94@DataServer
  00758	00 00 00 00	 DD	 $LN95@DataServer
  0075c	00 00 00 00	 DD	 $LN96@DataServer
  00760	00 00 00 00	 DD	 $LN97@DataServer
$LN132@DataServer:
  00764	00 00 00 00	 DD	 $LN102@DataServer
  00768	00 00 00 00	 DD	 $LN16@DataServer
  0076c	00 00 00 00	 DD	 $LN103@DataServer
  00770	00 00 00 00	 DD	 $LN104@DataServer
  00774	00 00 00 00	 DD	 $LN105@DataServer
  00778	00 00 00 00	 DD	 $LN106@DataServer
  0077c	00 00 00 00	 DD	 $LN107@DataServer
  00780	00 00 00 00	 DD	 $LN108@DataServer
  00784	00 00 00 00	 DD	 $LN109@DataServer
?DataServerProtocolCore@@YAXEPAEH@Z ENDP		; DataServerProtocolCore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\user.h
;	COMDAT ?GetPayCode@BILL_CLASS@@QAEHXZ
_TEXT	SEGMENT
?GetPayCode@BILL_CLASS@@QAEHXZ PROC			; BILL_CLASS::GetPayCode, COMDAT
; _this$ = ecx

; 2017 : 	int GetPayCode() {return this->PayCode;}	// line : 252

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?GetPayCode@BILL_CLASS@@QAEHXZ ENDP			; BILL_CLASS::GetPayCode
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 139  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 140  : 		lpBuf[0] = 0xC1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]

; 141  : 		lpBuf[1] = size;

  00006	8a 45 14	 mov	 al, BYTE PTR _size$[ebp]
  00009	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 142  : 		lpBuf[2] = head;

  0000c	8a 45 0c	 mov	 al, BYTE PTR _head$[ebp]
  0000f	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 143  : 		lpBuf[3] = sub;

  00012	8a 45 10	 mov	 al, BYTE PTR _sub$[ebp]
  00015	c6 01 c1	 mov	 BYTE PTR [ecx], 193	; 000000c1H
  00018	88 41 03	 mov	 BYTE PTR [ecx+3], al

; 144  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
;	COMDAT ?set@PWMSG_HEAD@@QAEXPAEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 4
?set@PWMSG_HEAD@@QAEXPAEEH@Z PROC			; PWMSG_HEAD::set, COMDAT
; _this$ = ecx

; 110  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 		lpBuf[0] = 0xC2;

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpBuf$[ebp]

; 112  : 		lpBuf[1] = SET_NUMBERH(size);

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 08	 shr	 eax, 8
  0000e	88 42 01	 mov	 BYTE PTR [edx+1], al

; 113  : 		lpBuf[2] = SET_NUMBERL(size);
; 114  : 		lpBuf[3] = head;

  00011	8a 45 0c	 mov	 al, BYTE PTR _head$[ebp]
  00014	c6 02 c2	 mov	 BYTE PTR [edx], 194	; 000000c2H
  00017	88 4a 02	 mov	 BYTE PTR [edx+2], cl
  0001a	88 42 03	 mov	 BYTE PTR [edx+3], al

; 115  : 	};

  0001d	5d		 pop	 ebp
  0001e	c2 0c 00	 ret	 12			; 0000000cH
?set@PWMSG_HEAD@@QAEXPAEEH@Z ENDP			; PWMSG_HEAD::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD@@QAEXPAEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 1
?set@PBMSG_HEAD@@QAEXPAEEE@Z PROC			; PBMSG_HEAD::set, COMDAT
; _this$ = ecx

; 85   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 		lpBuf[0] = 0xC1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]

; 87   : 		lpBuf[1] = size;

  00006	8a 45 10	 mov	 al, BYTE PTR _size$[ebp]
  00009	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 88   : 		lpBuf[2] = head;

  0000c	8a 45 0c	 mov	 al, BYTE PTR _head$[ebp]
  0000f	c6 01 c1	 mov	 BYTE PTR [ecx], 193	; 000000c1H
  00012	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 89   : 	};	// line : 22

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?set@PBMSG_HEAD@@QAEXPAEEE@Z ENDP			; PBMSG_HEAD::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\dsprotocol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 6397 : }

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
