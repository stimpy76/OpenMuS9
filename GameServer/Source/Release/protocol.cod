; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	C:\Users\Michel\Desktop\Source\GameServer\Source\protocol.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ltesttime@@3HA					; ltesttime
PUBLIC	?logincounttest@@3HA				; logincounttest
PUBLIC	?tempindex@@3HA					; tempindex
PUBLIC	?iCount@@3HA					; iCount
_BSS	SEGMENT
?ltesttime@@3HA DD 01H DUP (?)				; ltesttime
?logincounttest@@3HA DD 01H DUP (?)			; logincounttest
?tempindex@@3HA DD 01H DUP (?)				; tempindex
?iCount@@3HA DD	01H DUP (?)				; iCount
_BSS	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	_sprintf_s
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?isValidChatSyntax@ZTHelper@@SA_NPBD@Z		; ZTHelper::isValidChatSyntax
PUBLIC	??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
PUBLIC	?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::IsValidDurationTime
PUBLIC	?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z	; TDurMagicKeyChecker::SetDurationTime
PUBLIC	?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidDurationTime
PUBLIC	?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z	; TDurMagicKeyChecker::GetValidCount
PUBLIC	??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char *>
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?ProtocolCore@@YAXEPAEHHHH@Z			; ProtocolCore
PUBLIC	?TestSend@@YAXXZ				; TestSend
PUBLIC	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z		; MsgSendV2
PUBLIC	?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z	; CGLiveClient
PUBLIC	?GCCheckMainExeKeySend@@YAXH@Z			; GCCheckMainExeKeySend
PUBLIC	?EncryptCheckSumKey@@YAGG@Z			; EncryptCheckSumKey
PUBLIC	?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ; CGCheckMainRecv
PUBLIC	?PEchoProc@@YAXPAEHF@Z				; PEchoProc
PUBLIC	?GCResultSend@@YAXHEE@Z				; GCResultSend
PUBLIC	?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z		; ChatSend
PUBLIC	?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ		; vChatSend
PUBLIC	?AllSendServerMsg@@YAXPAD@Z			; AllSendServerMsg
PUBLIC	?DataSendAll@@YAXPAEH@Z				; DataSendAll
PUBLIC	?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z	; ChatTargetSend
PUBLIC	?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z		; PChatProc
PUBLIC	?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z	; CGChatRecv
PUBLIC	?GCServerMsgSend@@YAXEH@Z			; GCServerMsgSend
PUBLIC	?GCServerMsgStringSend@@YAXPADHE@Z		; GCServerMsgStringSend
PUBLIC	?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
PUBLIC	?GCEventStateSend@@YAXHEE@Z			; GCEventStateSend
PUBLIC	?GCMapEventStateSend@@YAXHEE@Z			; GCMapEventStateSend
PUBLIC	?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ; CGChatWhisperRecv
PUBLIC	?SCPJoinResultSend@@YAXHE@Z			; SCPJoinResultSend
PUBLIC	?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z	; CSPJoinIdPassRequest
PUBLIC	?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z ; CSPJoinIdPassRequestTEST
PUBLIC	?GCJoinBillCheckSend@@YAXPADH@Z			; GCJoinBillCheckSend
PUBLIC	?GCJoinResult@@YAXEH@Z				; GCJoinResult
PUBLIC	?GCJoinSocketResult@@YAXEI@Z			; GCJoinSocketResult
PUBLIC	?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z	; CGClientCloseMsg
PUBLIC	?GCCloseMsgSend@@YAXHE@Z			; GCCloseMsgSend
PUBLIC	?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z		; CGClientMsg
PUBLIC	?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z	; CGPCharacterCreate
PUBLIC	?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z		; CGPCharDel
PUBLIC	?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ; CGPCharacterMapJoinRequest
PUBLIC	?GCLevelUpMsgSend@@YAXHH@Z			; GCLevelUpMsgSend
PUBLIC	?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z	; CGLevelUpPointAdd
PUBLIC	?GCInventoryItemOneSend@@YAXHH@Z		; GCInventoryItemOneSend
PUBLIC	?GCPkLevelSend@@YAXHE@Z				; GCPkLevelSend
PUBLIC	?GCMagicListOneSend@@YAXHDGEEE@Z		; GCMagicListOneSend
PUBLIC	?GCMagicListOneDelSend@@YAXHDGEEE@Z		; GCMagicListOneDelSend
PUBLIC	?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z	; GCMagicListMultiSend
PUBLIC	?GCEquipmentSend@@YAXH@Z			; GCEquipmentSend
PUBLIC	?GCRecallMonLife@@YAXHHH@Z			; GCRecallMonLife
PUBLIC	?GCTimeViewSend@@YAXHH@Z			; GCTimeViewSend
PUBLIC	?GCGoalSend@@YAXHPADE0E@Z			; GCGoalSend
PUBLIC	?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z	; GCSkillKeyRecv
PUBLIC	?GCSkillKeySend@@YAXHPAEEEEEEEK@Z		; GCSkillKeySend
PUBLIC	?GCMoneySend@@YAXHK@Z				; GCMoneySend
PUBLIC	?GCItemInventoryPutSend@@YAXHEEE@Z		; GCItemInventoryPutSend
PUBLIC	?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ; CGItemGetRequest
PUBLIC	?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z	; CGItemDropRequest
PUBLIC	?GCItemMoveResultSend@@YAXHEEQAE@Z		; GCItemMoveResultSend
PUBLIC	?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ; CGInventoryItemMove
PUBLIC	?GCEquipmentChange@@YAXHH@Z			; GCEquipmentChange
PUBLIC	?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z	; CGTalkRequestRecv
PUBLIC	?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z	; GCUserWarehouseSend
PUBLIC	?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z	; CGBuyRequestRecv
PUBLIC	?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z	; CGSellRequestRecv
PUBLIC	?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z	; GetNeedMoneyItemDurRepaire
PUBLIC	?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire
PUBLIC	?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ; CGModifyRequestItem
PUBLIC	?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ; CGTradeRequestSend
PUBLIC	?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ; CGTradeResponseRecv
PUBLIC	?GCTradeResponseSend@@YAHEHPADGH@Z		; GCTradeResponseSend
PUBLIC	?GCTradeOtherDel@@YAHHE@Z			; GCTradeOtherDel
PUBLIC	?GCTradeOtherAdd@@YAHHEPAE@Z			; GCTradeOtherAdd
PUBLIC	?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z	; CGTradeMoneyRecv
PUBLIC	?GCTradeMoneyOther@@YAHHK@Z			; GCTradeMoneyOther
PUBLIC	?GCTradeOkButtonSend@@YAHHE@Z			; GCTradeOkButtonSend
PUBLIC	?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ; CGTradeOkButtonRecv
PUBLIC	?CGTradeCancelButtonRecv@@YAXH@Z		; CGTradeCancelButtonRecv
PUBLIC	?CGTradeResult@@YAXHE@Z				; CGTradeResult
PUBLIC	?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ; CGPShopReqSetItemPrice
PUBLIC	?CGPShopAnsSetItemPrice@@YAXHEE@Z		; CGPShopAnsSetItemPrice
PUBLIC	?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z	; CGPShopReqOpen
PUBLIC	?CGPShopAnsOpen@@YAXHE@Z			; CGPShopAnsOpen
PUBLIC	?CGPShopReqClose@@YAXH@Z			; CGPShopReqClose
PUBLIC	?CGPShopAnsClose@@YAXHE@Z			; CGPShopAnsClose
PUBLIC	?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ; CGPShopReqBuyList
PUBLIC	?CGPShopAnsBuyList@@YAXHHE_N@Z			; CGPShopAnsBuyList
PUBLIC	?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CGPShopReqBuyItem
PUBLIC	?CGPShopAnsBuyItem@@YAXHHHE@Z			; CGPShopAnsBuyItem
PUBLIC	?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z ; CGPShopReqCloseDeal
PUBLIC	?CGPShopAnsSoldItem@@YAXHHH@Z			; CGPShopAnsSoldItem
PUBLIC	?CGPShopAnsDealerClosedShop@@YAXHH@Z		; CGPShopAnsDealerClosedShop
PUBLIC	?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ; CGPartyRequestRecv
PUBLIC	?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ; CGPartyRequestResultRecv
PUBLIC	?CGPartyList@@YAXH@Z				; CGPartyList
PUBLIC	?CGPartyListAll@@YAXH@Z				; CGPartyListAll
PUBLIC	?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z	; CGPartyDelUser
PUBLIC	?CGPartyDelUserAsExitGameByForce@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUserAsExitGameByForce
PUBLIC	?GCPartyDelUserSend@@YAXH@Z			; GCPartyDelUserSend
PUBLIC	?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z	; CGGuildRequestRecv
PUBLIC	?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ; CGGuildRequestResultRecv
PUBLIC	?CGGuildListAll@@YAXH@Z				; CGGuildListAll
PUBLIC	?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z	; CGGuildDelUser
PUBLIC	?GCGuildDelUserResult@@YAXHE@Z			; GCGuildDelUserResult
PUBLIC	?GCGuildMasterQuestionSend@@YAXH@Z		; GCGuildMasterQuestionSend
PUBLIC	?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ; CGGuildMasterAnswerRecv
PUBLIC	?GCGuildMasterManagerRun@@YAXH@Z		; GCGuildMasterManagerRun
PUBLIC	?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ; CGGuildMasterInfoSave
PUBLIC	?CGGuildMasterCreateCancel@@YAXH@Z		; CGGuildMasterCreateCancel
PUBLIC	?GCGuildViewportNowPaint@@YAXHPADPAEH@Z		; GCGuildViewportNowPaint
PUBLIC	?GCGuildViewportDelNow@@YAXHH@Z			; GCGuildViewportDelNow
PUBLIC	?GCManagerGuildWarEnd@@YAXPAD@Z			; GCManagerGuildWarEnd
PUBLIC	?GCManagerGuildWarSet@@YAXPAD0H@Z		; GCManagerGuildWarSet
PUBLIC	?GCGuildWarRequestResult@@YAXPADHH@Z		; GCGuildWarRequestResult
PUBLIC	?GCGuildWarRequestSend@@YAXPADHH@Z		; GCGuildWarRequestSend
PUBLIC	?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ; GCGuildWarRequestSendRecv
PUBLIC	?GCGuildWarDeclare@@YAXHPAD@Z			; GCGuildWarDeclare
PUBLIC	?GCGuildWarEnd@@YAXHEPAD@Z			; GCGuildWarEnd
PUBLIC	?GCGuildWarScore@@YAXH@Z			; GCGuildWarScore
PUBLIC	?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ; CGWarehouseMoneyInOut
PUBLIC	?GCWarehouseInventoryMoneySend@@YAXHEHH@Z	; GCWarehouseInventoryMoneySend
PUBLIC	?CGWarehouseUseEnd@@YAXH@Z			; CGWarehouseUseEnd
PUBLIC	?GCWarehouseStateSend@@YAXHE@Z			; GCWarehouseStateSend
PUBLIC	?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ; GCWarehouseRecivePassword
PUBLIC	?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z	; GCUserChaosBoxSend
PUBLIC	?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ; CGChaosBoxItemMixButtonClick
PUBLIC	?CGChaosBoxUseEnd@@YAXH@Z			; CGChaosBoxUseEnd
PUBLIC	?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z		; PMoveProc
PUBLIC	?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
PUBLIC	?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z		; CGAttack
PUBLIC	?GCDamageSend@@YAXHHH@Z				; GCDamageSend
PUBLIC	?GCDamageSend@@YAXHHHHHH@Z			; GCDamageSend
PUBLIC	?GCDamageSend@@YAXHHHE@Z			; GCDamageSend
PUBLIC	?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z		; GCLifeSendAll
PUBLIC	?GCKillPlayerExpSend@@YAXHHHHH@Z		; GCKillPlayerExpSend
PUBLIC	?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HGH@Z	; GCDiePlayerSend
PUBLIC	?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z	; GCActionSend
PUBLIC	?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z		; CGActionRecv
PUBLIC	?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z	; CGMagicAttack
PUBLIC	?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend
PUBLIC	?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z	; GCMagicCancelSend
PUBLIC	?GCSendEffect@@YAXPAUOBJECTSTRUCT@@HHHH@Z	; GCSendEffect
PUBLIC	?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z	; CGMagicCancel
PUBLIC	?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z ; GCUseMonsterSkillSend
PUBLIC	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z	; GCStateInfoSend
PUBLIC	?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z	; CGTeleportRecv
PUBLIC	?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ; CGTargetTeleportRecv
PUBLIC	?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z	; GCTeleportSend
PUBLIC	?CGBeattackRecv@@YAXPAEHH@Z			; CGBeattackRecv
PUBLIC	?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ; CGDurationMagicRecv
PUBLIC	?ObjectMapJoinPositionSend@@YAXF@Z		; ObjectMapJoinPositionSend
PUBLIC	?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z		; CGUseItemRecv
PUBLIC	?GCReFillSend@@YAXHGEEG@Z			; GCReFillSend
PUBLIC	?GCManaSend@@YAXHFEEG@Z				; GCManaSend
PUBLIC	?GCInventoryItemDeleteSend@@YAXHEE@Z		; GCInventoryItemDeleteSend
PUBLIC	?GCItemUseSpecialTimeSend@@YAXHEH@Z		; GCItemUseSpecialTimeSend
PUBLIC	?GCItemDurSend@@YAXHEEE@Z			; GCItemDurSend
PUBLIC	?GCItemDurSend2@@YAXHEEE@Z			; GCItemDurSend2
PUBLIC	?CGWeatherSend@@YAXHE@Z				; CGWeatherSend
PUBLIC	?GCServerCmd@@YAXHEEE@Z				; GCServerCmd
PUBLIC	?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ; GCReqmoveDevilSquare
PUBLIC	?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ; GCReqDevilSquareRemainTime
PUBLIC	?AllSendMsg@@YAXPAEH@Z				; AllSendMsg
PUBLIC	?AllSendSameMapMsg@@YAXPAEHE@Z			; AllSendSameMapMsg
PUBLIC	?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ; GCRegEventChipRecv
PUBLIC	?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ; GCGetMutoNumRecv
PUBLIC	?GCUseEndEventChipRescv@@YAXH@Z			; GCUseEndEventChipRescv
PUBLIC	?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ; GCUseRenaChangeZenRecv
PUBLIC	?CGRequestQuestInfo@@YAXH@Z			; CGRequestQuestInfo
PUBLIC	?GCSendQuestInfo@@YAXHH@Z			; GCSendQuestInfo
PUBLIC	?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z	; CGSetQuestState
PUBLIC	?GCSendQuestPrize@@YAXHEE@Z			; GCSendQuestPrize
PUBLIC	?CGCloseWindow@@YAXH@Z				; CGCloseWindow
PUBLIC	?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ; CGRequestEnterBloodCastle
PUBLIC	?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ; CGRequestEnterChaosCastle
PUBLIC	?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ; CGRequestRepositionUserInChaosCastle
PUBLIC	?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ; CGRequestEventEnterCount
PUBLIC	?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ; CGRequestLottoRegister
PUBLIC	?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z ; CGReqMoveOtherServer
PUBLIC	?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ; GCPacketCheckSumRecv
PUBLIC	?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z	; GCNPggSendCheckSum
PUBLIC	?GCNPggCheckSumRecv@@YAXPAUPMSG_NPROTECTGGCHECKSUM@@H@Z ; GCNPggCheckSumRecv
PUBLIC	?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z ; CGDuelStartRequestRecv
PUBLIC	?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z ; CGDuelEndRequestRecv
PUBLIC	?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z ; CGDuelOkRequestRecv
PUBLIC	?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z	; GCSendGetItemInfoForParty
PUBLIC	?GCSendEffectInfo@@YAXHE@Z			; GCSendEffectInfo
PUBLIC	?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ; CGRequestPetItemCommand
PUBLIC	?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ; CGRequestPetItemInfo
PUBLIC	?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z ; GCGuildViewportInfo
PUBLIC	?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z ; CGGuildAssignStatus
PUBLIC	?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z ; CGGuildAssignType
PUBLIC	?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z ; CGRelationShipReqJoinBreakOff
PUBLIC	?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z ; CGRelationShipAnsJoinBreakOff
PUBLIC	?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z	; CGUnionList
PUBLIC	?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z ; CGRelationShipReqKickOutUnionMember
PUBLIC	?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z ; CGReqMapSvrAuth
PUBLIC	?GCAnsMapSvrAuth@@YAXHH@Z			; GCAnsMapSvrAuth
PUBLIC	?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z ; CGReqCastleSiegeState
PUBLIC	?GCAnsCastleSiegeState@@YAXHHPAD0@Z		; GCAnsCastleSiegeState
PUBLIC	?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z ; CGReqRegCastleSiege
PUBLIC	?GCAnsRegCastleSiege@@YAXHHPAD@Z		; GCAnsRegCastleSiege
PUBLIC	?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z ; CGReqGiveUpCastleSiege
PUBLIC	?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z ; CGReqGuildRegInfo
PUBLIC	?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z ; GCAnsGuildRegInfo
PUBLIC	?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z ; CGReqRegGuildMark
PUBLIC	?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z ; GCAnsRegGuildMark
PUBLIC	?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z	; CGReqNpcBuy
PUBLIC	?GCAnsNpcBuy@@YAXHHHH@Z				; GCAnsNpcBuy
PUBLIC	?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z	; CGReqNpcRepair
PUBLIC	?GCAnsNpcRepair@@YAXHHHHHH@Z			; GCAnsNpcRepair
PUBLIC	?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z ; CGReqNpcUpgrade
PUBLIC	?GCAnsNpcUpgrade@@YAXHHHHHH@Z			; GCAnsNpcUpgrade
PUBLIC	?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z ; CGReqTaxMoneyInfo
PUBLIC	?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z			; GCAnsTaxMoneyInfo
PUBLIC	?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z ; CGReqTaxRateChange
PUBLIC	?GCAnsTaxRateChange@@YAXHHEH@Z			; GCAnsTaxRateChange
PUBLIC	?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z ; CGReqMoneyDrawOut
PUBLIC	?GCAnsMoneyDrawOut@@YAXHH_J@Z			; GCAnsMoneyDrawOut
PUBLIC	?GCAnsCsGateState@@YAXHHH@Z			; GCAnsCsGateState
PUBLIC	?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z ; CGReqCsGateOperate
PUBLIC	?GCAnsCsGateOperate@@YAXHHHH@Z			; GCAnsCsGateOperate
PUBLIC	?GCAnsCsGateCurState@@YAXHHH@Z			; GCAnsCsGateCurState
PUBLIC	?GCAnsCsAccessSwitchState@@YAXHHHE@Z		; GCAnsCsAccessSwitchState
PUBLIC	?GCAnsCsAccessCrownState@@YAXHE@Z		; GCAnsCsAccessCrownState
PUBLIC	?GCAnsCsNotifyStart@@YAXHE@Z			; GCAnsCsNotifyStart
PUBLIC	?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z			; GCAnsCsMapSvrTaxInfo
PUBLIC	?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z ; CGReqCsMiniMapData
PUBLIC	?GCAnsCsMiniMapData@@YAXHE@Z			; GCAnsCsMiniMapData
PUBLIC	?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z ; CGReqStopCsMiniMapData
PUBLIC	?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z ; CGReqCsSendCommand
PUBLIC	?GCAnsCsSendCommand@@YAXHEEEE@Z			; GCAnsCsSendCommand
PUBLIC	?GCAnsCsLeftTimeAlarm@@YAXEE@Z			; GCAnsCsLeftTimeAlarm
PUBLIC	?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z		; GCAnsSelfCsLeftTimeAlarm
PUBLIC	?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z ; CGReqCsSetEnterHuntZone
PUBLIC	?GCAnsCsSetEnterHuntZone@@YAXHEE@Z		; GCAnsCsSetEnterHuntZone
PUBLIC	?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z	; CGReqNpcDbList
PUBLIC	?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z ; CGReqCsRegGuildList
PUBLIC	?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z ; CGReqCsAttkGuildList
PUBLIC	?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z	; CGReqWeaponUse
PUBLIC	?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z ; CGReqWeaponDamageValue
PUBLIC	?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z ; CGReqGuildMarkOfCastleOwner
PUBLIC	?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z	; CGReqJewelMix
PUBLIC	?GCAnsJewelMix@@YAXHH@Z				; GCAnsJewelMix
PUBLIC	?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z ; CGReqJewelUnMix
PUBLIC	?GCAnsJewelUnMix@@YAXHH@Z			; GCAnsJewelUnMix
PUBLIC	?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z ; CGReqCrywolfInfo
PUBLIC	?GCAnsCrywolfInfo@@YAXHEE@Z			; GCAnsCrywolfInfo
PUBLIC	?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z ; CGReqAlatrContract
PUBLIC	?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z ; CGReqPlusChaosRate
PUBLIC	?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z ; CGReqKanturuStateInfo
PUBLIC	?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z ; GCReqEnterKanturuBossMap
PUBLIC	?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z		; GCAnsGiveUpCastleSiege
PUBLIC	?GCSendObjectCreationState@@YAXH@Z		; GCSendObjectCreationState
PUBLIC	?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z ; CGReqCastleHuntZoneEntrance
PUBLIC	?GCReqEnterBarracks@@YAXH@Z			; GCReqEnterBarracks
PUBLIC	?GCReqEnterBalgassLair@@YAXH@Z			; GCReqEnterBalgassLair
PUBLIC	?GCReqmoveIllusionTemple@@YAXPAUPMSG_REQ_MOVEILLUSIONTEMPLE@@H@Z ; GCReqmoveIllusionTemple
PUBLIC	?GCIllusionSkillUseSend@@YAXPAUPMSG_ILLUSION_REQ_SKILLUSE@@H@Z ; GCIllusionSkillUseSend
PUBLIC	?GCIllusionSendPoint@@YAXHE@Z			; GCIllusionSendPoint
PUBLIC	?CGIllusionTempleReward@@YAXH@Z			; CGIllusionTempleReward
PUBLIC	?GCSendEffectInfo@@YAXPAUOBJECTSTRUCT@@HHHH@Z	; GCSendEffectInfo
PUBLIC	?GCAttackSpeedSend@@YAXH@Z			; GCAttackSpeedSend
PUBLIC	?CGOpenPCBangShop@@YAXPAEH@Z			; CGOpenPCBangShop
PUBLIC	?CGBuyPCBangShop@@YAXPAEH@Z			; CGBuyPCBangShop
PUBLIC	?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z	; PacketCheckTime
PUBLIC	?CGReqmoveDoubleGoer@@YAXPAEH@Z			; CGReqmoveDoubleGoer
PUBLIC	?CGReqEnterZone@@YAXPAUPMSG_REQ_ENTERZONE@@H@Z	; CGReqEnterZone
PUBLIC	?GCSendExp@@YAXHH_JHH@Z				; GCSendExp
PUBLIC	?CGReqmoveLorenMarket@@YAXH@Z			; CGReqmoveLorenMarket
PUBLIC	?CGReqMoveAcheron@@YAXH@Z			; CGReqMoveAcheron
PUBLIC	?CGWindowReqMove@@YAXPAUPMSG_MOVE_REQUEST@@H@Z	; CGWindowReqMove
PUBLIC	?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z	; GCMonkMagicAttack
PUBLIC	?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z ; GCMonkMagicAttackNumberSend
PUBLIC	?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z ; GCMonkDarkSideTargetSelect
PUBLIC	?CGSaveMuBotSettings@@YAXPAUPMSG_MUBOT_SETTINGS_RECV@@H@Z ; CGSaveMuBotSettings
PUBLIC	?GCSendMuBotSettings@@YAXHPAE@Z			; GCSendMuBotSettings
PUBLIC	?CGRequestStartMuBot@@YAXPAUPMSG_MUBOT_REQ_START@@H@Z ; CGRequestStartMuBot
PUBLIC	?CGEnableUsePolymorphSkinrRecv@@YAXPAUPMSG_REQ_USE_POLYMORPH_SKIN@@H@Z ; CGEnableUsePolymorphSkinrRecv
PUBLIC	?ClientTestSend@@YAXHPAUClientTest@@@Z		; ClientTestSend
PUBLIC	?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z ; CGInventoryEquipment
PUBLIC	?TalkRefDel@CQeustNpcTeleport@@QAEXXZ		; CQeustNpcTeleport::TalkRefDel
PUBLIC	??0_CS_NPC_DATA@@QAE@XZ				; _CS_NPC_DATA::_CS_NPC_DATA
PUBLIC	??1_CS_NPC_DATA@@UAE@XZ				; _CS_NPC_DATA::~_CS_NPC_DATA
PUBLIC	?Clear@_CS_NPC_DATA@@QAEXXZ			; _CS_NPC_DATA::Clear
PUBLIC	??_G_CS_NPC_DATA@@UAEPAXI@Z			; _CS_NPC_DATA::`scalar deleting destructor'
PUBLIC	?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z	; CNewPVP::IsDuel
PUBLIC	?getInstance@MonsterSpawnerMng@@SAPAV1@XZ	; MonsterSpawnerMng::getInstance
PUBLIC	?DataEncryptCheck@@YAHHEH@Z			; DataEncryptCheck
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
PUBLIC	?GCAnsCsNotifyProgress@@YAXHEPBD@Z		; GCAnsCsNotifyProgress
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM?$AA@			; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@ ; `string'
PUBLIC	??_7_CS_NPC_DATA@@6B@				; _CS_NPC_DATA::`vftable'
PUBLIC	?g_CreditLog@@3VCLogToFile@@A			; g_CreditLog
PUBLIC	??_C@_0O@BDDJAJFG@?4?2Log?2Credits?$AA@		; `string'
PUBLIC	??_C@_07GDHHDJMO@Credits?$AA@			; `string'
PUBLIC	??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@ ; `string'
PUBLIC	??_C@_0L@HMJAEILC@1111111111?$AA@		; `string'
PUBLIC	??_C@_0BM@BJHJAKKO@?$FL0xBF?$FN?5Unknown?5packet?5BF?3?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@		; `string'
PUBLIC	??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@ ; `string'
PUBLIC	??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@		; `string'
PUBLIC	??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@ ; `string'
PUBLIC	??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@ ; `string'
PUBLIC	??_C@_0BB@FKJLBJJB@Incorrect?5syntax?$AA@	; `string'
PUBLIC	??_C@_08IOFCDDNP@?1post?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BM@KJGOCGNH@Need?5more?5zen?5for?5gens?5chat?$AA@ ; `string'
PUBLIC	??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@ ; `string'
PUBLIC	??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@	; `string'
PUBLIC	??_C@_04FLFDNKBN@m321?$AA@			; `string'
PUBLIC	??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@ ; `string'
PUBLIC	??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@ ; `string'
PUBLIC	??_C@_0CA@LCMJGFID@Character?5creation?5is?5disabled?$CB?$AA@ ; `string'
PUBLIC	??_C@_0DN@NJBNDAEI@?$FL?$CFs?$FN?5Create?5character?5error?5?$CIReq@ ; `string'
PUBLIC	??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@ ; `string'
PUBLIC	??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@ ; `string'
PUBLIC	??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ ; `string'
PUBLIC	??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ ; `string'
PUBLIC	??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@ ; `string'
PUBLIC	??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@ ; `string'
PUBLIC	??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@ ; `string'
PUBLIC	??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@ ; `string'
PUBLIC	??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@ ; `string'
PUBLIC	??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@ ; `string'
PUBLIC	??_C@_0EH@MPCKANHC@?$FLDoppelganger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dim@ ; `string'
PUBLIC	??_C@_0EJ@KBMFDFFG@?$FLImperialGuardianFort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0DF@EMLONCAM@?$FLAcheron?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Spirit?5M@ ; `string'
PUBLIC	??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	??_C@_0EO@IHPJKMLA@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@ ; `string'
PUBLIC	??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@ ; `string'
PUBLIC	??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@ ; `string'
PUBLIC	??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_04BGCMBJDA@Item?$AA@			; `string'
PUBLIC	??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@ ; `string'
PUBLIC	??_C@_0EM@HPFBFIFH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Fireworks@ ; `string'
PUBLIC	??_C@_0FC@GOMPGJDH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0ED@PDKMNGPH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0EM@LPMBPPDG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@ ; `string'
PUBLIC	??_C@_0CP@KAEBPCMA@?$FLSnakeBegins?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5t@ ; `string'
PUBLIC	??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@ ; `string'
PUBLIC	??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ ; `string'
PUBLIC	??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@ ; `string'
PUBLIC	??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@ ; `string'
PUBLIC	??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@ ; `string'
PUBLIC	??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ ; `string'
PUBLIC	??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@ ; `string'
PUBLIC	??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@ ; `string'
PUBLIC	??_C@_0CF@LHICMFIE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5LuckyItem?5Mi@ ; `string'
PUBLIC	??_C@_0CF@GLNEHHDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5Elemental?5Mi@ ; `string'
PUBLIC	??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@ ; `string'
PUBLIC	??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@ ; `string'
PUBLIC	??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@ ; `string'
PUBLIC	??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@ ; `string'
PUBLIC	??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@ ; `string'
PUBLIC	??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@ ; `string'
PUBLIC	??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@ ; `string'
PUBLIC	??_C@_0CF@MFLOOBGJ@Item?5has?5been?5purchased?0?5balance@ ; `string'
PUBLIC	??_C@_0DP@ONDPGNEF@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5item?5has?5been?5purchase@ ; `string'
PUBLIC	??_C@_0BP@FPLNFNIC@You?5have?5no?5enough?5empty?5space?$AA@ ; `string'
PUBLIC	??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@ ; `string'
PUBLIC	??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@ ; `string'
PUBLIC	??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@ ; `string'
PUBLIC	??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@ ; `string'
PUBLIC	??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CJ@GFPCHONE@You?5cannot?5trade?5inside?5Illusion@ ; `string'
PUBLIC	??_C@_0CG@MDHDJBIA@You?5cannot?5trade?5inside?5Doppelga@ ; `string'
PUBLIC	??_C@_0CH@BFADMIPH@You?5cannot?5trade?5inside?5Imperial@ ; `string'
PUBLIC	??_C@_0CA@CHOLFFAK@Trade?5not?5allowed?5on?5duel?5arena?$AA@ ; `string'
PUBLIC	??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@ ; `string'
PUBLIC	??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@ ; `string'
PUBLIC	??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@ ; `string'
PUBLIC	??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@ ; `string'
PUBLIC	??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@ ; `string'
PUBLIC	??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@ ; `string'
PUBLIC	??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@ ; `string'
PUBLIC	??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@ ; `string'
PUBLIC	??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@ ; `string'
PUBLIC	??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@ ; `string'
PUBLIC	??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@ ; `string'
PUBLIC	??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ ; `string'
PUBLIC	??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@ ; `string'
PUBLIC	??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@ ; `string'
PUBLIC	??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@ ; `string'
PUBLIC	??_C@_0CK@ODKADHDC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Ou@ ; `string'
PUBLIC	??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@ ; `string'
PUBLIC	??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@ ; `string'
PUBLIC	??_C@_0DL@LHDFDIDM@You?5cannot?5open?5your?5Personal?5Sh@ ; `string'
PUBLIC	??_C@_0DI@MIGHMEIJ@You?5cannot?5open?5your?5Personal?5Sh@ ; `string'
PUBLIC	??_C@_0DJ@GMNEGEAG@You?5cannot?5open?5your?5Personal?5Sh@ ; `string'
PUBLIC	??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@ ; `string'
PUBLIC	??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@ ; `string'
PUBLIC	??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@ ; `string'
PUBLIC	??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@ ; `string'
PUBLIC	??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@ ; `string'
PUBLIC	??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@ ; `string'
PUBLIC	??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@ ; `string'
PUBLIC	??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ ; `string'
PUBLIC	??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@ ; `string'
PUBLIC	??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EG@KFEECMPB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ ; `string'
PUBLIC	??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FC@CGGBJBAH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ ; `string'
PUBLIC	??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@ ; `string'
PUBLIC	??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@ ; `string'
PUBLIC	??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@ ; `string'
PUBLIC	??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@ ; `string'
PUBLIC	??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@ ; `string'
PUBLIC	??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0P@GAPFACKC@User?5Not?5found?$AA@		; `string'
PUBLIC	??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0CG@IDLFABNI@PartyMember?$CI?$CFd?$CJ?5?3?5Party?5Out?4?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0P@IDGHFMPH@No?5party?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0P@CPKIABHC@User?5not?5found?$AA@		; `string'
PUBLIC	??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@ ; `string'
PUBLIC	??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@ ; `string'
PUBLIC	??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@ ; `string'
PUBLIC	??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@ ; `string'
PUBLIC	??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@ ; `string'
PUBLIC	??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@ ; `string'
PUBLIC	??_C@_0DE@OPCGOEPD@Guild?5War?5cannot?5be?5started?5with@ ; `string'
PUBLIC	??_C@_0DB@IJAALLLN@Guild?5War?5cannot?5be?5started?5with@ ; `string'
PUBLIC	??_C@_0DC@ENCBPHMM@Guild?5War?5cannot?5be?5started?5with@ ; `string'
PUBLIC	??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@ ; `string'
PUBLIC	??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@ ; `string'
PUBLIC	??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@ ; `string'
PUBLIC	??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@ ; `string'
PUBLIC	??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@ ; `string'
PUBLIC	??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@ ; `string'
PUBLIC	??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@ ; `string'
PUBLIC	??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@ ; `string'
PUBLIC	??_C@_0DI@CILMICFP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@ ; `string'
PUBLIC	??_C@_0EB@PGHIAIFO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ ; `string'
PUBLIC	??_C@_0DF@LECGNCFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@ ; `string'
PUBLIC	??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ ; `string'
PUBLIC	??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ ; `string'
PUBLIC	??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ ; `string'
PUBLIC	??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@ ; `string'
PUBLIC	??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@ ; `string'
PUBLIC	??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@ ; `string'
PUBLIC	??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@ ; `string'
PUBLIC	??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ ; `string'
PUBLIC	??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@ ; `string'
PUBLIC	??_C@_0DN@PFIDPOLC@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@ ; `string'
PUBLIC	??_C@_0DJ@COJBHLGO@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@ ; `string'
PUBLIC	??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@ ; `string'
PUBLIC	??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ ; `string'
PUBLIC	??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ ; `string'
PUBLIC	??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@ ; `string'
PUBLIC	??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@ ; `string'
PUBLIC	??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@ ; `string'
PUBLIC	??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@ ; `string'
PUBLIC	??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@ ; `string'
PUBLIC	??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@ ; `string'
PUBLIC	??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@ ; `string'
PUBLIC	??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@ ; `string'
PUBLIC	??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@ ; `string'
PUBLIC	??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ ; `string'
PUBLIC	??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ ; `string'
PUBLIC	??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@ ; `string'
PUBLIC	??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@ ; `string'
PUBLIC	??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@ ; `string'
PUBLIC	??_C@_0CN@HEGKGIOI@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ ; `string'
PUBLIC	??_C@_0BI@IGJGPHCH@Master?5Skill?5Reset?5Fail?$AA@ ; `string'
PUBLIC	??_C@_0DG@CEAHPFGG@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ ; `string'
PUBLIC	??_C@_0EB@LLBOIAD@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ ; `string'
PUBLIC	??_C@_0CJ@HAOMGPEH@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ ; `string'
PUBLIC	??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@ ; `string'
PUBLIC	??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@ ; `string'
PUBLIC	??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@ ; `string'
PUBLIC	??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ ; `string'
PUBLIC	??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ ; `string'
PUBLIC	??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ ; `string'
PUBLIC	??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ ; `string'
PUBLIC	??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ ; `string'
PUBLIC	??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ ; `string'
PUBLIC	??_C@_0BM@JDNCDNDO@You?5lack?5items?5to?5exchange?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@ ; `string'
PUBLIC	??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@ ; `string'
PUBLIC	??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ ; `string'
PUBLIC	??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ ; `string'
PUBLIC	??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ ; `string'
PUBLIC	??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@ ; `string'
PUBLIC	??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@ ; `string'
PUBLIC	??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@ ; `string'
PUBLIC	??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@ ; `string'
PUBLIC	??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@ ; `string'
PUBLIC	??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN?$FL@ ; `string'
PUBLIC	??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ ; `string'
PUBLIC	??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@ ; `string'
PUBLIC	??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@ ; `string'
PUBLIC	??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@ ; `string'
PUBLIC	??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@ ; `string'
PUBLIC	??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@ ; `string'
PUBLIC	??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@ ; `string'
PUBLIC	??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@ ; `string'
PUBLIC	??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ ; `string'
PUBLIC	??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ ; `string'
PUBLIC	??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@ ; `string'
PUBLIC	??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ ; `string'
PUBLIC	??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@ ; `string'
PUBLIC	??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@ ; `string'
PUBLIC	??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ ; `string'
PUBLIC	??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ ; `string'
PUBLIC	??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ ; `string'
PUBLIC	??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ ; `string'
PUBLIC	??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ ; `string'
PUBLIC	??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ ; `string'
PUBLIC	??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ ; `string'
PUBLIC	??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ ; `string'
PUBLIC	??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@ ; `string'
PUBLIC	??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@ ; `string'
PUBLIC	??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@ ; `string'
PUBLIC	??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@ ; `string'
PUBLIC	??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@ ; `string'
PUBLIC	??_C@_0EM@GKLOHMBB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ ; `string'
PUBLIC	??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ ; `string'
PUBLIC	??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ ; `string'
PUBLIC	??_C@_0BN@JLEKNDOL@?$FLMuBot?$FN?5Option?5Save?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BN@JAGJPNLP@?$FLMuBot?$FN?5Option?5Send?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ ; `string'
PUBLIC	??_C@_0DB@OKKAKFII@Only?5characters?5above?5?$CFd?5level?5c@ ; `string'
PUBLIC	??_C@_0CE@IHDJCCIO@MU?5Helper?5cant?5run?5on?5this?5locat@ ; `string'
PUBLIC	??_C@_0GN@LMFACHAA@?$FLUseCahngeSkinState?$FN?$FLCGEnableUse@ ; `string'
PUBLIC	??_C@_0BM@JGJDNBPL@?$FLDEBUG?$FN?5Text?3?5?$CFs?0?5Value?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_R4_CS_NPC_DATA@@6B@				; _CS_NPC_DATA::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU_CS_NPC_DATA@@@8			; _CS_NPC_DATA `RTTI Type Descriptor'
PUBLIC	??_R3_CS_NPC_DATA@@8				; _CS_NPC_DATA::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_CS_NPC_DATA@@8				; _CS_NPC_DATA::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_CS_NPC_DATA@@8			; _CS_NPC_DATA::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@3fe4cccccccccccd
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@406fc00000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@40a00000
PUBLIC	__real@41200000
PUBLIC	__real@41c80000
PUBLIC	__real@42340000
PUBLIC	__real@42c80000
PUBLIC	__xmm@ffffffffffffffffffffffffffffffff
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_isalnum:PROC
EXTRN	_memchr:PROC
EXTRN	_memmove:PROC
EXTRN	_strncmp:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	_rand:PROC
EXTRN	__imp__ntohl@4:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z:PROC ; CGuildClass::SearchGuild
EXTRN	?SearchGuild_Number@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@H@Z:PROC ; CGuildClass::SearchGuild_Number
EXTRN	?CGJoinRequest@CGensSystem@@QAEXPAEH@Z:PROC	; CGensSystem::CGJoinRequest
EXTRN	?CGLeaveRequest@CGensSystem@@QAEXH@Z:PROC	; CGensSystem::CGLeaveRequest
EXTRN	?CGRequestPrize@CGensSystem@@QAEXPAEH@Z:PROC	; CGensSystem::CGRequestPrize
EXTRN	?SendGensInfo@CGensSystem@@QAEXH@Z:PROC		; CGensSystem::SendGensInfo
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEE@Z:PROC		; CItem::Convert
EXTRN	?Value@CItem@@QAEXXZ:PROC			; CItem::Value
EXTRN	?GetSize@CItem@@QAEHAAH0@Z:PROC			; CItem::GetSize
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	?PetValue@CItem@@QAEXXZ:PROC			; CItem::PetValue
EXTRN	?IsClass@CItem@@QAEHDHH@Z:PROC			; CItem::IsClass
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?GetNumber@CItem@@QAEKXZ:PROC			; CItem::GetNumber
EXTRN	?IsExtItem@CItem@@QAEHXZ:PROC			; CItem::IsExtItem
EXTRN	?IsFullAncient@CItem@@QAEHXZ:PROC		; CItem::IsFullAncient
EXTRN	?IsFullExcellent@CItem@@QAE_NXZ:PROC		; CItem::IsFullExcellent
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?ItemByteConvert@@YAXPAEHEEEEEEEEE0E@Z:PROC	; ItemByteConvert
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?HasItemDurability@@YAHH@Z:PROC			; HasItemDurability
EXTRN	?GetAllRepairItemRate@@YAMH@Z:PROC		; GetAllRepairItemRate
EXTRN	?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z:PROC	; GetItemAttr
EXTRN	?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z:PROC ; CMagicDamage::SkillGetRequireClass
EXTRN	?CheckStatus@CMagicDamage@@QAEHHH@Z:PROC	; CMagicDamage::CheckStatus
EXTRN	?CheckKillCount@CMagicDamage@@QAEHHH@Z:PROC	; CMagicDamage::CheckKillCount
EXTRN	?GetSkillUseType@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::GetSkillUseType
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?CheckCombo@CComboAttack@@QAEHHH@Z:PROC		; CComboAttack::CheckCombo
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
EXTRN	?IsMagic@CMagicInf@@QAEHXZ:PROC			; CMagicInf::IsMagic
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	?IsJewelOfHarmonyOriginal@CJewelOfHarmonySystem@@QAEHF@Z:PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonyOriginal
EXTRN	?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z:PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
EXTRN	?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z:PROC ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
EXTRN	?PurityJewelOfHarmony@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CJewelOfHarmonySystem::PurityJewelOfHarmony
EXTRN	?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemStrengthenOption
EXTRN	?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::GetItemOptionLevel
EXTRN	?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z:PROC ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
EXTRN	?MakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CJewelOfHarmonySystem::MakeSmeltingStoneItem
EXTRN	?SmeltItemBySmeltingStone@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z:PROC ; CJewelOfHarmonySystem::SmeltItemBySmeltingStone
EXTRN	?RestoreStrengthenItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CJewelOfHarmonySystem::RestoreStrengthenItem
EXTRN	?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z:PROC ; CItemSystemFor380::Is380OptionItem
EXTRN	?ChaosMix380ItemOption@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CItemSystemFor380::ChaosMix380ItemOption
EXTRN	?GetItemOptions@CSocketItems@@QAEXPAVCItem@@PAE1@Z:PROC ; CSocketItems::GetItemOptions
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjClearViewport
EXTRN	?gObjCloseSet@@YAXHH@Z:PROC			; gObjCloseSet
EXTRN	?IsDuelEnable@@YA_NH@Z:PROC			; IsDuelEnable
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; gObjCanItemTouch
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjItemTextSave
EXTRN	?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjWarehouseTextSave
EXTRN	?gObjUserKill@@YAXH@Z:PROC			; gObjUserKill
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjIsGamePlaing@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsGamePlaing
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; gObjIsConnected
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
EXTRN	?gObjIsAccontConnect@@YAHHPAD@Z:PROC		; gObjIsAccontConnect
EXTRN	?gObjJoominCheck@@YAHHPAD@Z:PROC		; gObjJoominCheck
EXTRN	?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckXYMapTile
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjPositionCheck
EXTRN	?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?gObjLevelUpPointAdd@@YAHEPAUOBJECTSTRUCT@@@Z:PROC ; gObjLevelUpPointAdd
EXTRN	?gObjGuildMasterCapacityTest@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjGuildMasterCapacityTest
EXTRN	?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z:PROC ; gObjAttack
EXTRN	?gObjInventoryTrans@@YAHH@Z:PROC		; gObjInventoryTrans
EXTRN	?gObjInventoryCommit@@YAHH@Z:PROC		; gObjInventoryCommit
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?gObjFixInventoryPointer@@YA_NH@Z:PROC		; gObjFixInventoryPointer
EXTRN	?gObjInventoryItemSet_PShop@@YAXHHE@Z:PROC	; gObjInventoryItemSet_PShop
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z:PROC ; gObjOnlyInventoryInsertItem
EXTRN	?gObjSearchItem@@YAHPAUOBJECTSTRUCT@@HHH@Z:PROC	; gObjSearchItem
EXTRN	?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjSearchItemMinus
EXTRN	?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z:PROC ; gObjShopBuyInventoryInsertItem
EXTRN	?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z:PROC ; gObjInventoryInsertItemTemp
EXTRN	?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z:PROC ; gObjInventoryInsertItem
EXTRN	?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; CheckInventoryEmptySpace
EXTRN	?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z:PROC ; gObjInventorySearchSerialNumber
EXTRN	?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z:PROC	; gObjInventoryMoveItem
EXTRN	?gObjTradeInventoryMove@@YAEPAUOBJECTSTRUCT@@EE@Z:PROC ; gObjTradeInventoryMove
EXTRN	?gObjInventoryTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z:PROC ; gObjInventoryTradeMove
EXTRN	?gObjTradeTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z:PROC ; gObjTradeTradeMove
EXTRN	?gObjTradeCancel@@YAXH@Z:PROC			; gObjTradeCancel
EXTRN	?gObjTradeOkButton@@YAXH@Z:PROC			; gObjTradeOkButton
EXTRN	?LevelSmallConvert@@YAEHH@Z:PROC		; LevelSmallConvert
EXTRN	?gObjMakePreviewCharSet@@YAXH@Z:PROC		; gObjMakePreviewCharSet
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?PShop_CheckInventoryEmpty@@YA_NF@Z:PROC	; PShop_CheckInventoryEmpty
EXTRN	?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; gObjUseDrink
EXTRN	?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolCreate
EXTRN	?gObjTeleportMagicUse@@YAXHEE@Z:PROC		; gObjTeleportMagicUse
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?gObjTeleport@@YAXHHHH@Z:PROC			; gObjTeleport
EXTRN	?gObjMoveDataLoadingOK@@YAXH@Z:PROC		; gObjMoveDataLoadingOK
EXTRN	?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagic
EXTRN	?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagicSearch
EXTRN	?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z:PROC ; gObjMagicManaUse
EXTRN	?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z:PROC ; gObjMagicBPUse
EXTRN	?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EEEAAG@Z:PROC ; gObjMagicAdd
EXTRN	?gObjItemLevelUpPickAxe@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjItemLevelUpPickAxe
EXTRN	?gObjItemDurUp@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC	; gObjItemDurUp
EXTRN	?gObjItemStrenghtenUp@@YAHPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjItemStrenghtenUp
EXTRN	?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z:PROC ; gObjGuildWarEndSend
EXTRN	?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z:PROC ; gObjGuildWarEnd
EXTRN	?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; gObjGuildWarMasterClose
EXTRN	?gObjMonsterCallKill@@YAXH@Z:PROC		; gObjMonsterCallKill
EXTRN	?gObjCheckTeleportArea@@YAHHEE@Z:PROC		; gObjCheckTeleportArea
EXTRN	?gObjCheckAttackArea@@YAHHH@Z:PROC		; gObjCheckAttackArea
EXTRN	?gObjFind10EventChip@@YAHH@Z:PROC		; gObjFind10EventChip
EXTRN	?gObjSetPosition@@YAXHHH@Z:PROC			; gObjSetPosition
EXTRN	?gObjGetItemCountInIventory@@YAHHHHH@Z:PROC	; gObjGetItemCountInIventory
EXTRN	?gObjDelteItemCountInInventory@@YAXHHHHH@Z:PROC	; gObjDelteItemCountInInventory
EXTRN	?gObjGetStatPointState@@YAXHAAF000@Z:PROC	; gObjGetStatPointState
EXTRN	?gObjUsePlusStatFruit@@YAXHH@Z:PROC		; gObjUsePlusStatFruit
EXTRN	?gObjUseMinusStatFruit@@YAXHH@Z:PROC		; gObjUseMinusStatFruit
EXTRN	?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjDuelCheck
EXTRN	?gObjCheckMaxZen@@YAHHH@Z:PROC			; gObjCheckMaxZen
EXTRN	?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjGetRelationShip
EXTRN	?gObjNotifyUseWeaponV1@@YAXPAUOBJECTSTRUCT@@0HH@Z:PROC ; gObjNotifyUseWeaponV1
EXTRN	?gObjNotifyUseWeaponDamage@@YAXPAUOBJECTSTRUCT@@HH@Z:PROC ; gObjNotifyUseWeaponDamage
EXTRN	?gObjUseBlessAndSoulPotion@@YAXHH@Z:PROC	; gObjUseBlessAndSoulPotion
EXTRN	?MsgOutput@@YAXHPADZZ:PROC			; MsgOutput
EXTRN	?gObjCheckOverlapItemUsingDur@@YAHHHHH@Z:PROC	; gObjCheckOverlapItemUsingDur
EXTRN	?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z:PROC ; gObjOverlapItemUsingDur
EXTRN	?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z:PROC	; gObjCheckSerial0ItemList
EXTRN	?gCheckSkillDistance@@YAHHHH@Z:PROC		; gCheckSkillDistance
EXTRN	?ExMinusStatFruit@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; ExMinusStatFruit
EXTRN	?UseCashItems@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; UseCashItems
EXTRN	?UsePKRemoveItem@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; UsePKRemoveItem
EXTRN	?UseExCashPotions@@YAXPAUOBJECTSTRUCT@@H@Z:PROC	; UseExCashPotions
EXTRN	?UseMediumElitePotion@@YAXPAUOBJECTSTRUCT@@HN@Z:PROC ; UseMediumElitePotion
EXTRN	?CheckAuthority@@YAEHPAUOBJECTSTRUCT@@@Z:PROC	; CheckAuthority
EXTRN	?gObjCheckMapBind@@YAHH@Z:PROC			; gObjCheckMapBind
EXTRN	?IsTransformCharcterSkin@@YA_NH@Z:PROC		; IsTransformCharcterSkin
EXTRN	?IsTransformEquipment@@YA_NH@Z:PROC		; IsTransformEquipment
EXTRN	?ItemGive@MapClass@@QAEHHH_N@Z:PROC		; MapClass::ItemGive
EXTRN	?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEPAEE@Z:PROC ; MapClass::ItemDrop
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?DataSendEventChip@@YAXPADH@Z:PROC		; DataSendEventChip
EXTRN	?EGReqBloodCastleEnterCount@@YAXH@Z:PROC	; EGReqBloodCastleEnterCount
EXTRN	?DataSend@wsJoinServerCli@@QAEHPADH@Z:PROC	; wsJoinServerCli::DataSend
EXTRN	?DataSocketSend@CwsGameServer@@QAEHIPADH@Z:PROC	; CwsGameServer::DataSocketSend
EXTRN	?InCheck@NSerialCheck@@QAEHE@Z:PROC		; NSerialCheck::InCheck
EXTRN	?GetSerial@NSerialCheck@@QAEHXZ:PROC		; NSerialCheck::GetSerial
EXTRN	?AddCash@CWhisperCash@@QAEHPAD@Z:PROC		; CWhisperCash::AddCash
EXTRN	?IsParty@PartyClass@@QAEHH@Z:PROC		; PartyClass::IsParty
EXTRN	?Create@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::Create
EXTRN	?Destroy@PartyClass@@QAEHH@Z:PROC		; PartyClass::Destroy
EXTRN	?Add@PartyClass@@QAEHHHHH@Z:PROC		; PartyClass::Add
EXTRN	?Delete@PartyClass@@QAEXHH@Z:PROC		; PartyClass::Delete
EXTRN	?GetCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetCount
EXTRN	?GetIndexUser@PartyClass@@QAEHHHAAH0@Z:PROC	; PartyClass::GetIndexUser
EXTRN	?GetPartyCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetPartyCount
EXTRN	?GetIndex@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::GetIndex
EXTRN	?Paint@PartyClass@@QAEXH@Z:PROC			; PartyClass::Paint
EXTRN	?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z:PROC	; PartyClass::UpdatePKPartyPanalty
EXTRN	?GetReallyConnectPartyMemberCount@PartyClass@@QAEHH@Z:PROC ; PartyClass::GetReallyConnectPartyMemberCount
EXTRN	?SwitchLeader@PartyClass@@QAEXH@Z:PROC		; PartyClass::SwitchLeader
EXTRN	?ChangeLeader@PartyClass@@QAEXH@Z:PROC		; PartyClass::ChangeLeader
EXTRN	?GetPartyPkLevel@PartyClass@@QAEDH@Z:PROC	; PartyClass::GetPartyPkLevel
EXTRN	?CGReqPartyMatchWindow@@YAXPAUPMSG_PARTYMATCH_INFO_REQ@@H@Z:PROC ; CGReqPartyMatchWindow
EXTRN	?CGReqPartyMatchReg@@YAXPAUPMSG_PARTYMATCH_REG_REQ@@H@Z:PROC ; CGReqPartyMatchReg
EXTRN	?CGReqPartyMatchJoin@@YAXPAUPMSG_PARTYMATCH_JOIN_REQ@@H@Z:PROC ; CGReqPartyMatchJoin
EXTRN	?CGReqPartyMatchWaitingList@@YAXH@Z:PROC	; CGReqPartyMatchWaitingList
EXTRN	?CGReqPartyMatchCancel@@YAXPAUPMSG_PARTYMATCH_CANCEL_REQ@@H@Z:PROC ; CGReqPartyMatchCancel
EXTRN	?CGReqPartyMatchAcceptList@@YAXH@Z:PROC		; CGReqPartyMatchAcceptList
EXTRN	?CGReqPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_CGREQ_REQUESTANSWER@@H@Z:PROC ; CGReqPartyMatchRequestAnswer
EXTRN	?GetWarehouseUsedHowMuch@@YAHHHH@Z:PROC		; GetWarehouseUsedHowMuch
EXTRN	?BuxConvert@@YAXPADH@Z:PROC			; BuxConvert
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?PHeadSetW@@YAXPAEEH@Z:PROC			; PHeadSetW
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
EXTRN	?PHeadSubSetBE@@YAXPAEEEH@Z:PROC		; PHeadSubSetBE
EXTRN	?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z:PROC	; TNotice::MakeNoticeMsg
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z:PROC ; CQuestInfo::GetQuestInfo
EXTRN	?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::GetQuestState
EXTRN	?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::GetQuestStateBYTE
EXTRN	?SetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@HH@Z:PROC ; CQuestInfo::SetQuestState
EXTRN	?NotifyResultEnterBarracks@CQuestInfo@@QAEXH@Z:PROC ; CQuestInfo::NotifyResultEnterBarracks
EXTRN	?NotifyResultEnterRefuge@CQuestInfo@@QAEXH@Z:PROC ; CQuestInfo::NotifyResultEnterRefuge
EXTRN	?CheckItemCount@CQuestInfo@@QAEHHFF@Z:PROC	; CQuestInfo::CheckItemCount
EXTRN	?CGRequestQuestState@CQuestInfoEx@@QAEXH@Z:PROC	; CQuestInfoEx::CGRequestQuestState
EXTRN	?CGRequestInitQuest@CQuestInfoEx@@QAEXPAEH@Z:PROC ; CQuestInfoEx::CGRequestInitQuest
EXTRN	?CGQuestComplete@CQuestInfoEx@@QAEXPAEH@Z:PROC	; CQuestInfoEx::CGQuestComplete
EXTRN	?CGQuitQuest@CQuestInfoEx@@QAEXPAEH@Z:PROC	; CQuestInfoEx::CGQuitQuest
EXTRN	?CGRequestQuestStep@CQuestInfoEx@@QAEXPAEH@Z:PROC ; CQuestInfoEx::CGRequestQuestStep
EXTRN	?CGClientAction@CQuestInfoEx@@QAEXPAEH@Z:PROC	; CQuestInfoEx::CGClientAction
EXTRN	?CGReqQuestInfo@CQuestInfoEx@@QAEXPAEH@Z:PROC	; CQuestInfoEx::CGReqQuestInfo
EXTRN	?GCSendAvaibleQuest@CQuestInfoEx@@QAEXH@Z:PROC	; CQuestInfoEx::GCSendAvaibleQuest
EXTRN	?GCSendBuff@CQuestInfoEx@@QAEXH@Z:PROC		; CQuestInfoEx::GCSendBuff
EXTRN	?IsMember@CConMember@@QAEHPAD@Z:PROC		; CConMember::IsMember
EXTRN	?gCheckBlankBattleGround@@YAHXZ:PROC		; gCheckBlankBattleGround
EXTRN	?gBattleGroundEnable@@YAXHH@Z:PROC		; gBattleGroundEnable
EXTRN	?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z:PROC ; gSetBattleTeamMaster
EXTRN	?BattleSoccerGoalEnd@@YAXH@Z:PROC		; BattleSoccerGoalEnd
EXTRN	?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ChaosBoxInit
EXTRN	?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CChaosBox::PlusItemLevelChaosMix
EXTRN	?PegasiaChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::PegasiaChaosMix
EXTRN	?CircleChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::CircleChaosMix
EXTRN	?WingChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::WingChaosMix
EXTRN	?DefaultChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::DefaultChaosMix
EXTRN	?DevilSquareItemChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::DevilSquareItemChaosMix
EXTRN	?BloodCastleItemChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::BloodCastleItemChaosMix
EXTRN	?DarkHorseChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::DarkHorseChaosMix
EXTRN	?DarkSpiritChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::DarkSpiritChaosMix
EXTRN	?BlessPotionChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::BlessPotionChaosMix
EXTRN	?SoulPotionChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::SoulPotionChaosMix
EXTRN	?LifeStoneChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::LifeStoneChaosMix
EXTRN	?HiddenTreasureBoxItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::HiddenTreasureBoxItemMix
EXTRN	?Fenrir_01Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::Fenrir_01Level_Mix
EXTRN	?Fenrir_02Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::Fenrir_02Level_Mix
EXTRN	?Fenrir_03Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::Fenrir_03Level_Mix
EXTRN	?Fenrir_04Upgrade_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::Fenrir_04Upgrade_Mix
EXTRN	?ShieldPotionLv1_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ShieldPotionLv1_Mix
EXTRN	?ShieldPotionLv2_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ShieldPotionLv2_Mix
EXTRN	?ShieldPotionLv3_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::ShieldPotionLv3_Mix
EXTRN	?CondorFeather_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::CondorFeather_Mix
EXTRN	?NewWingChaos_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::NewWingChaos_Mix
EXTRN	?LotteryItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::LotteryItemMix
EXTRN	?CherryBlossomMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::CherryBlossomMix
EXTRN	?IllusionTemple_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::IllusionTemple_Mix
EXTRN	?SeedExtractMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::SeedExtractMix
EXTRN	?SeedSphereCompositeMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::SeedSphereCompositeMix
EXTRN	?SetSeedSphereMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@E@Z:PROC ; CChaosBox::SetSeedSphereMix
EXTRN	?RemoveSeedSphereMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@E@Z:PROC ; CChaosBox::RemoveSeedSphereMix
EXTRN	?SecromiconMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::SecromiconMix
EXTRN	?LuckySystemItemCreate@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::LuckySystemItemCreate
EXTRN	?LuckySystemJewelCreate@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::LuckySystemJewelCreate
EXTRN	?GoldenNSilverBoxMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::GoldenNSilverBoxMix
EXTRN	?Wing25Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::Wing25Mix
EXTRN	?SocketItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@H@Z:PROC ; CChaosBox::SocketItemMix
EXTRN	?CastleSpecialItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CChaosBox::CastleSpecialItemMix
EXTRN	?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateChaos
EXTRN	?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z:PROC	; CCastleSiegeSync::GetTaxRateStore
EXTRN	?GetTaxHuntZone@CCastleSiegeSync@@QAEHHH@Z:PROC	; CCastleSiegeSync::GetTaxHuntZone
EXTRN	?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z:PROC	; CCastleSiegeSync::AddTributeMoney
EXTRN	?CheckOverlapCsMarks@CCastleSiegeSync@@QAEHH@Z:PROC ; CCastleSiegeSync::CheckOverlapCsMarks
EXTRN	?GetGuildRelationShipCount@TUnion@@QAEHHH@Z:PROC ; TUnion::GetGuildRelationShipCount
EXTRN	?GetGuildUnionMemberList@TUnion@@QAEHHAAHPAH@Z:PROC ; TUnion::GetGuildUnionMemberList
EXTRN	?SearchUnion@TUnion@@QAEPAVTUnionInfo@@H@Z:PROC	; TUnion::SearchUnion
EXTRN	?MixJewel@CJewelMixSystem@@SAHHHH@Z:PROC	; CJewelMixSystem::MixJewel
EXTRN	?UnMixJewel@CJewelMixSystem@@SAHHHHH@Z:PROC	; CJewelMixSystem::UnMixJewel
EXTRN	?SetWeaponCalDamageInfo@CWeapon@@QAEHGEEH@Z:PROC ; CWeapon::SetWeaponCalDamageInfo
EXTRN	?GetWeaponCalDamageInfo@CWeapon@@QAEHGAAE0@Z:PROC ; CWeapon::GetWeaponCalDamageInfo
EXTRN	?GetTargetPointXY@CWeapon@@QAEHHHAAE0H@Z:PROC	; CWeapon::GetTargetPointXY
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z:PROC	; CKalimaGate::CreateKalimaGate
EXTRN	?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z:PROC ; CKalimaGate::CheckOverlapKundunMark
EXTRN	?GetKalimaGateLevel2@CKalimaGate@@QAEHH@Z:PROC	; CKalimaGate::GetKalimaGateLevel2
EXTRN	?SpeedHackCheck@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SpeedHackCheck
EXTRN	?EnableSkill@CObjUseSkill@@QAEHH@Z:PROC		; CObjUseSkill::EnableSkill
EXTRN	?CheckWeapon@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CObjUseSkill::CheckWeapon
EXTRN	?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::UseSkill
EXTRN	?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z:PROC ; CObjUseSkill::UseSkill
EXTRN	?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::MaGumSkillDefenseDown
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z:PROC ; CObjUseSkill::SkillFireScream
EXTRN	?SkillMonkDarkSideGetTargetIndex@CObjUseSkill@@QAEHHHPAVCMagicInf@@PAG@Z:PROC ; CObjUseSkill::SkillMonkDarkSideGetTargetIndex
EXTRN	?PickupRelic@CIllusionTempleEvent@@QAEXEHE@Z:PROC ; CIllusionTempleEvent::PickupRelic
EXTRN	?PickupRelicSend@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z:PROC ; CIllusionTempleEvent::PickupRelicSend
EXTRN	?Enter@CIllusionTempleEvent@@QAEHHEE@Z:PROC	; CIllusionTempleEvent::Enter
EXTRN	?DropRelic@CIllusionTempleEvent@@QAEXEH@Z:PROC	; CIllusionTempleEvent::DropRelic
EXTRN	?GetState@CIllusionTempleEvent@@QAEEE@Z:PROC	; CIllusionTempleEvent::GetState
EXTRN	?UseSkill@CIllusionTempleEvent@@QAEXHGHE@Z:PROC	; CIllusionTempleEvent::UseSkill
EXTRN	?TeleportLock@CIllusionTempleEvent@@QAEHH@Z:PROC ; CIllusionTempleEvent::TeleportLock
EXTRN	?DropReward@CIllusionTempleEvent@@QAEXH@Z:PROC	; CIllusionTempleEvent::DropReward
EXTRN	?GetLeftTime@CIllusionTempleEvent@@QAEEXZ:PROC	; CIllusionTempleEvent::GetLeftTime
EXTRN	?Is2ndSkillActive@CIllusionTempleEvent@@QAEHHE@Z:PROC ; CIllusionTempleEvent::Is2ndSkillActive
EXTRN	?NpcTalk@@YAHPAUOBJECTSTRUCT@@0@Z:PROC		; NpcTalk
EXTRN	?Get@ShopManager@@QAEPAVCShop@@H@Z:PROC		; ShopManager::Get
EXTRN	?GDReqPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z:PROC ; CCashItemPeriodSystem::GDReqPeriodItemInsert
EXTRN	?GDReqPeriodItemDelete@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CCashItemPeriodSystem::GDReqPeriodItemDelete
EXTRN	?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjMonsterRegen
EXTRN	?IsInGate@CGate@@QAEHHH@Z:PROC			; CGate::IsInGate
EXTRN	?AddCheckSum@CPacketCheckSum@@QAEXHHK@Z:PROC	; CPacketCheckSum::AddCheckSum
EXTRN	?ChangeCommand@CDarkSpirit@@QAEXHH@Z:PROC	; CDarkSpirit::ChangeCommand
EXTRN	?GetAltarState@CCrywolfAltar@@QAEHH@Z:PROC	; CCrywolfAltar::GetAltarState
EXTRN	?SetAltarUserIndex@CCrywolfAltar@@QAEHHHH@Z:PROC ; CCrywolfAltar::SetAltarUserIndex
EXTRN	?GetOccupationState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetOccupationState
EXTRN	?GetCrywolfState@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetCrywolfState
EXTRN	?GetPlusChaosRate@CCrywolfSync@@QAEHXZ:PROC	; CCrywolfSync::GetPlusChaosRate
EXTRN	?IncObjCount@CDevilSquareGround@@QAEXXZ:PROC	; CDevilSquareGround::IncObjCount
EXTRN	?GetObjCount@CDevilSquareGround@@QAEJXZ:PROC	; CDevilSquareGround::GetObjCount
EXTRN	?GetRemainTime@CDevilSquare@@QAEHXZ:PROC	; CDevilSquare::GetRemainTime
EXTRN	?GetDevilSquareIndex@CDevilSquare@@QAEHH@Z:PROC	; CDevilSquare::GetDevilSquareIndex
EXTRN	?GetUserLevelToEnter@CDevilSquare@@QAEHHAAH@Z:PROC ; CDevilSquare::GetUserLevelToEnter
EXTRN	?NotifyEntranceInfo@CKanturuEntranceNPC@@QAEXH@Z:PROC ; CKanturuEntranceNPC::NotifyEntranceInfo
EXTRN	?NotifyResultEnterKanturuBossMap@CKanturuEntranceNPC@@QAEXH@Z:PROC ; CKanturuEntranceNPC::NotifyResultEnterKanturuBossMap
EXTRN	?CGCashShopOpen@CCashShop@@QAEHPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHSHOPOPEN@@@Z:PROC ; CCashShop::CGCashShopOpen
EXTRN	?CGCashPoint@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CCashShop::CGCashPoint
EXTRN	?CGReqInfo@CCashShop@@QAEHPAEH@Z:PROC		; CCashShop::CGReqInfo
EXTRN	?GCSendItemInfo@CCashShop@@QAEXHHHK@Z:PROC	; CCashShop::GCSendItemInfo
EXTRN	?CGCashItemBuy@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z:PROC ; CCashShop::CGCashItemBuy
EXTRN	?CGCashGiftSend@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z:PROC ; CCashShop::CGCashGiftSend
EXTRN	?CGReqUseItem@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPSMG_REQ_CASHITEM_USE@@@Z:PROC ; CCashShop::CGReqUseItem
EXTRN	?IsCashItem@@YAHH@Z:PROC			; IsCashItem
EXTRN	?IsCashSpecialItem@@YAHH@Z:PROC			; IsCashSpecialItem
EXTRN	??_E_CS_NPC_DATA@@UAEPAXI@Z:PROC		; _CS_NPC_DATA::`vector deleting destructor'
EXTRN	?GetCastleState@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetCastleState
EXTRN	?GetCastleLeftSiegeDate@CCastleSiege@@QAE?AU_SYSTEMTIME@@XZ:PROC ; CCastleSiege::GetCastleLeftSiegeDate
EXTRN	?GetCastleStateTerm@CCastleSiege@@QAEHPAU_SYSTEMTIME@@0@Z:PROC ; CCastleSiege::GetCastleStateTerm
EXTRN	?GetCurRemainSec@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetCurRemainSec
EXTRN	?CheckAddDbNPC@CCastleSiege@@QAEHHHHPAE@Z:PROC	; CCastleSiege::CheckAddDbNPC
EXTRN	?PayForUpgradeDbNPC@CCastleSiege@@QAEHHHHHHH@Z:PROC ; CCastleSiege::PayForUpgradeDbNPC
EXTRN	?SendNpcStateList@CCastleSiege@@QAEXHH@Z:PROC	; CCastleSiege::SendNpcStateList
EXTRN	?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z:PROC ; CCastleSiege::GetNpcData
EXTRN	?SendCsGateStateViewPort@CCastleSiege@@QAEXHE@Z:PROC ; CCastleSiege::SendCsGateStateViewPort
EXTRN	?CheckCsGateAlive@CCastleSiege@@QAEHH@Z:PROC	; CCastleSiege::CheckCsGateAlive
EXTRN	?CheckCastleHasMoney@CCastleSiege@@QAEH_J@Z:PROC ; CCastleSiege::CheckCastleHasMoney
EXTRN	?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z:PROC ; CCastleSiege::CheckGuildOwnCastle
EXTRN	?GetHuntZoneEnter@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetHuntZoneEnter
EXTRN	?SetHuntZoneEnter@CCastleSiege@@QAEXH@Z:PROC	; CCastleSiege::SetHuntZoneEnter
EXTRN	?NotifySelfCsJoinSide@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::NotifySelfCsJoinSide
EXTRN	?OperateGate@CCastleSiege@@QAEHHHH@Z:PROC	; CCastleSiege::OperateGate
EXTRN	?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::CheckCastleOwnerMember
EXTRN	?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::CheckCastleOwnerUnionMember
EXTRN	?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z:PROC ; CCastleSiege::CheckUnionGuildMaster
EXTRN	?GetCsAttkGuildList@CCastleSiege@@QAEHPAUPMSG_CSATTKGUILDLIST@@PAH@Z:PROC ; CCastleSiege::GetCsAttkGuildList
EXTRN	?CheckTeleportMagicAxisY@CCastleSiege@@QAEHHHH@Z:PROC ; CCastleSiege::CheckTeleportMagicAxisY
EXTRN	?NotifyCsSelfLeftTime@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::NotifyCsSelfLeftTime
EXTRN	?AddMiniMapDataReqUser@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::AddMiniMapDataReqUser
EXTRN	?DelMiniMapDataReqUser@CCastleSiege@@QAEXH@Z:PROC ; CCastleSiege::DelMiniMapDataReqUser
EXTRN	?GetCrownAccessTickCount@CCastleSiege@@QAEHXZ:PROC ; CCastleSiege::GetCrownAccessTickCount
EXTRN	?CreateLifeStone@CLifeStone@@QAEHH@Z:PROC	; CLifeStone::CreateLifeStone
EXTRN	?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjAddBuffEffect
EXTRN	?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
EXTRN	?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckUsedBuffEffect
EXTRN	?GDGuildCreateSend@@YAXHPAD0PAEH@Z:PROC		; GDGuildCreateSend
EXTRN	?GDGuildDestroySend@@YAXHPAD0@Z:PROC		; GDGuildDestroySend
EXTRN	?GDGuildMemberAdd@@YAXHPAD0@Z:PROC		; GDGuildMemberAdd
EXTRN	?GDGuildMemberDel@@YAXHPAD0@Z:PROC		; GDGuildMemberDel
EXTRN	?GDGuildNoticeSave@@YAXPAD0@Z:PROC		; GDGuildNoticeSave
EXTRN	?GDGuildServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z:PROC ; GDGuildServerGroupChattingSend
EXTRN	?GDUnionServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z:PROC ; GDUnionServerGroupChattingSend
EXTRN	?GDGuildReqAssignStatus@@YAXHHPADH@Z:PROC	; GDGuildReqAssignStatus
EXTRN	?GDGuildReqAssignType@@YAXHH@Z:PROC		; GDGuildReqAssignType
EXTRN	?GDRelationShipReqJoin@@YAXHHH@Z:PROC		; GDRelationShipReqJoin
EXTRN	?GDUnionBreakOff@@YAXHH@Z:PROC			; GDUnionBreakOff
EXTRN	?GDRelationShipReqBreakOff@@YAXHHH@Z:PROC	; GDRelationShipReqBreakOff
EXTRN	?GDUnionListSend@@YAXHH@Z:PROC			; GDUnionListSend
EXTRN	?GDRelationShipReqKickOutUnionMember@@YAXHPAD@Z:PROC ; GDRelationShipReqKickOutUnionMember
EXTRN	?FriendListRequest@@YAXH@Z:PROC			; FriendListRequest
EXTRN	?FriendStateClientRecv@@YAXPAUPMSG_FRIEND_STATE_C@@H@Z:PROC ; FriendStateClientRecv
EXTRN	?FriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_REQ@@H@Z:PROC ; FriendAddRequest
EXTRN	?WaitFriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_SIN_RESULT@@H@Z:PROC ; WaitFriendAddRequest
EXTRN	?FriendDelRequest@@YAXPAUPMSG_FRIEND_DEL_REQ@@H@Z:PROC ; FriendDelRequest
EXTRN	?FriendChatRoomCreateReq@@YAXPAUPMSG_FRIEND_ROOMCREATE_REQ@@H@Z:PROC ; FriendChatRoomCreateReq
EXTRN	?FriendMemoSend@@YAXPAUPMSG_FRIEND_MEMO@@H@Z:PROC ; FriendMemoSend
EXTRN	?FriendMemoListReq@@YAXH@Z:PROC			; FriendMemoListReq
EXTRN	?FriendMemoReadReq@@YAXPAUPMSG_FRIEND_READ_MEMO_REQ@@H@Z:PROC ; FriendMemoReadReq
EXTRN	?FriendMemoDelReq@@YAXPAUPMSG_FRIEND_MEMO_DEL_REQ@@H@Z:PROC ; FriendMemoDelReq
EXTRN	?FriendRoomInvitationReq@@YAXPAUPMSG_ROOM_INVITATION@@H@Z:PROC ; FriendRoomInvitationReq
EXTRN	?GJReqMapSvrAuth@@YAXHPAD0HHHH@Z:PROC		; GJReqMapSvrAuth
EXTRN	?Output@CLogToFile@@QAAXPADZZ:PROC		; CLogToFile::Output
EXTRN	??0CLogToFile@@QAE@QAD0H@Z:PROC			; CLogToFile::CLogToFile
EXTRN	??1CLogToFile@@QAE@XZ:PROC			; CLogToFile::~CLogToFile
EXTRN	?DataServerGetCharListRequest@@YAXF@Z:PROC	; DataServerGetCharListRequest
EXTRN	?JGCharacterCreateFailSend@@YAXHPAD@Z:PROC	; JGCharacterCreateFailSend
EXTRN	?GCItemListSend@@YAXH@Z:PROC			; GCItemListSend
EXTRN	?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z:PROC ; GJSetCharacterInfo
EXTRN	?GDGetWarehouseList@@YAXHPAD@Z:PROC		; GDGetWarehouseList
EXTRN	?GDSetWarehouseList@@YAXH@Z:PROC		; GDSetWarehouseList
EXTRN	?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; GDUserItemSave
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z:PROC ; ItemSerialCreateSend
EXTRN	?DGOptionDataSend@@YAXHPADPAEEEEEEEKD@Z:PROC	; DGOptionDataSend
EXTRN	?GS_GDReqOwnerGuildMaster@@YAXHH@Z:PROC		; GS_GDReqOwnerGuildMaster
EXTRN	?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z:PROC	; GS_GDReqCastleNpcRepair
EXTRN	?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z:PROC	; GS_GDReqCastleNpcUpgrade
EXTRN	?GS_GDReqTaxInfo@@YAXHH@Z:PROC			; GS_GDReqTaxInfo
EXTRN	?GS_GDReqTaxRateChange@@YAXHHHH@Z:PROC		; GS_GDReqTaxRateChange
EXTRN	?GS_GDReqCastleMoneyChange@@YAXHHH@Z:PROC	; GS_GDReqCastleMoneyChange
EXTRN	?GS_GDReqGuildMarkRegInfo@@YAXHH@Z:PROC		; GS_GDReqGuildMarkRegInfo
EXTRN	?GS_GDReqRegAttackGuild@@YAXHH@Z:PROC		; GS_GDReqRegAttackGuild
EXTRN	?GS_GDReqRegGuildMark@@YAXHHH@Z:PROC		; GS_GDReqRegGuildMark
EXTRN	?GS_GDReqGuildSetGiveUp@@YAXHHH@Z:PROC		; GS_GDReqGuildSetGiveUp
EXTRN	?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z:PROC	; GS_GDReqAllGuildMarkRegInfo
EXTRN	?GDExpandWarehouseSend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GDExpandWarehouseSend
EXTRN	?GDExpandInventorySend@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; GDExpandInventorySend
EXTRN	?DGMuBotSettingsSend@@YAXHPADPAE@Z:PROC		; DGMuBotSettingsSend
EXTRN	?requestDbUpdateCredits@@YAXPAUOBJECTSTRUCT@@FF@Z:PROC ; requestDbUpdateCredits
EXTRN	?CheckMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z:PROC ; CMasterLevelSkillTreeSystem::CheckMasterLevelSkill
EXTRN	?IsExistMLSBasedSkill@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMasterLevelSkillTreeSystem::IsExistMLSBasedSkill
EXTRN	?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z:PROC ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
EXTRN	?CGReqGetMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEXPAUPMSG_REQ_MASTERLEVEL_SKILL@@H@Z:PROC ; CMasterLevelSkillTreeSystem::CGReqGetMasterLevelSkill
EXTRN	?MLS_MaGumSkillDefenseDown@CMasterLevelSkillTreeSystem@@QAEXHH@Z:PROC ; CMasterLevelSkillTreeSystem::MLS_MaGumSkillDefenseDown
EXTRN	?MLS_FireScream@CMasterLevelSkillTreeSystem@@QAEHHHPAVCMagicInf@@@Z:PROC ; CMasterLevelSkillTreeSystem::MLS_FireScream
EXTRN	?CheckUsableWeaponSkill@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMasterLevelSkillTreeSystem::CheckUsableWeaponSkill
EXTRN	?MLS_MaGumSkillDefenseDownMastery@CMasterLevelSkillTreeSystem@@QAEXHHPAVCMagicInf@@@Z:PROC ; CMasterLevelSkillTreeSystem::MLS_MaGumSkillDefenseDownMastery
EXTRN	?CheckMasterSkillPoint@CMasterLevelSkillTreeSystem@@QAEDHH@Z:PROC ; CMasterLevelSkillTreeSystem::CheckMasterSkillPoint
EXTRN	?ResetMasterSkill@CMasterLevelSkillTreeSystem@@QAEDHH@Z:PROC ; CMasterLevelSkillTreeSystem::ResetMasterSkill
EXTRN	?CreateMercenary@CMercenary@@QAEHHHEE@Z:PROC	; CMercenary::CreateMercenary
EXTRN	?CreateGuardian@CGuardian@@QAEHH@Z:PROC		; CGuardian::CreateGuardian
EXTRN	?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMoveCommand::CheckEquipmentToMove
EXTRN	?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z:PROC ; CMoveCommand::Move
EXTRN	?BuyRequest@CGamblingEvent@@QAEEHEEEE@Z:PROC	; CGamblingEvent::BuyRequest
EXTRN	?OpenBox@EventItemBagManager@@QAEEHHE@Z:PROC	; EventItemBagManager::OpenBox
EXTRN	?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z:PROC ; EventItemBagManager::OpenSpecial
EXTRN	?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z:PROC ; CDoubleGoerEvent::EnterRequest
EXTRN	?CGEnterPortal@CImperialGuardian@@QAEXHH@Z:PROC	; CImperialGuardian::CGEnterPortal
EXTRN	?GetCurrentZoneIndex@CImperialGuardian@@QAEHH@Z:PROC ; CImperialGuardian::GetCurrentZoneIndex
EXTRN	?CheckOverlapMysteriousPaper@CImperialGuardian@@QAEHHH@Z:PROC ; CImperialGuardian::CheckOverlapMysteriousPaper
EXTRN	?IsElementalItem@CElementalSystem@@QAEHH@Z:PROC	; CElementalSystem::IsElementalItem
EXTRN	?SendShopElementalItem@CElementalSystem@@QAEXHH@Z:PROC ; CElementalSystem::SendShopElementalItem
EXTRN	?CGInsertErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_INSERTERTEL@@@Z:PROC ; CElementalSystem::CGInsertErtel
EXTRN	?CGRemoveErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_REMOVEERTEL@@@Z:PROC ; CElementalSystem::CGRemoveErtel
EXTRN	?ClearErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z:PROC ; CElementalSystem::ClearErtel
EXTRN	?PShopErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z:PROC ; CElementalSystem::PShopErtel
EXTRN	?CGCombineButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_COMBINE@@H@Z:PROC ; CElementalSystem::CGCombineButtonClick
EXTRN	?CGUpgradeButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_LEVELUP@@H@Z:PROC ; CElementalSystem::CGUpgradeButtonClick
EXTRN	?TidyUpTempuserdate@@YAXHHE@Z:PROC		; TidyUpTempuserdate
EXTRN	?CGMiningRequest@@YAXPAUPMSG_MINING_REQUEST@@H@Z:PROC ; CGMiningRequest
EXTRN	?CGRewardRequest@@YAXPAUPMSG_MINING_REWARD_REQUEST@@H@Z:PROC ; CGRewardRequest
EXTRN	?CGMiningEnd@@YAXPAUPMSG_MINING_END@@H@Z:PROC	; CGMiningEnd
EXTRN	?CGReqSendMemberPosInfoStart@Minimap@@QAEXH@Z:PROC ; Minimap::CGReqSendMemberPosInfoStart
EXTRN	?CGReqSendMemberPosInfoStop@Minimap@@QAEXH@Z:PROC ; Minimap::CGReqSendMemberPosInfoStop
EXTRN	?GCReqSendNpcPosInfo@Minimap@@QAEXPAU_PMSG_REQ_NPC_POSITION@@H@Z:PROC ; Minimap::GCReqSendNpcPosInfo
EXTRN	?CGReqItemSearch@ShopBoard@@QAEXHPAUSHOPBOARD_CGREQ_ITEM@@@Z:PROC ; ShopBoard::CGReqItemSearch
EXTRN	?CGReqOfferList@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERLIST@@@Z:PROC ; GuildMatch::CGReqOfferList
EXTRN	?CGReqOfferListByFilter@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERLISTFILTER@@@Z:PROC ; GuildMatch::CGReqOfferListByFilter
EXTRN	?CGReqOfferCreate@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERCREATE@@@Z:PROC ; GuildMatch::CGReqOfferCreate
EXTRN	?CGReqOfferDelete@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERDELETE@@@Z:PROC ; GuildMatch::CGReqOfferDelete
EXTRN	?CGReqJoinReq@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQ@@@Z:PROC ; GuildMatch::CGReqJoinReq
EXTRN	?CGReqJoinReqDelete@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQDELETE@@@Z:PROC ; GuildMatch::CGReqJoinReqDelete
EXTRN	?CGReqJoinReqAnswer@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_REQUESTANSWER@@@Z:PROC ; GuildMatch::CGReqJoinReqAnswer
EXTRN	?CGReqJoinReqList@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_REQUESTLIST@@@Z:PROC ; GuildMatch::CGReqJoinReqList
EXTRN	?CGReqJoinReqStatus@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQSTATUS@@@Z:PROC ; GuildMatch::CGReqJoinReqStatus
EXTRN	?AddExperience@CBloodCastle@@QAE_NHH@Z:PROC	; CBloodCastle::AddExperience
EXTRN	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDeleteQuestItem
EXTRN	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDropQuestItem
EXTRN	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z:PROC ; CBloodCastle::SendNoticeMessage
EXTRN	?EnterUserBridge@CBloodCastle@@QAEHHH@Z:PROC	; CBloodCastle::EnterUserBridge
EXTRN	?GetCurrentState@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetCurrentState
EXTRN	?GetRemainTime@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetRemainTime
EXTRN	?CheckEnterLevel@CBloodCastle@@QAEHHH@Z:PROC	; CBloodCastle::CheckEnterLevel
EXTRN	?CheckCanEnter@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckCanEnter
EXTRN	?CheckPlayStart@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckPlayStart
EXTRN	?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z:PROC ; CBloodCastle::CheckQuestItemSerial
EXTRN	?GetBridgeLevel@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetBridgeLevel
EXTRN	?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::EnterUserChaosCastle
EXTRN	?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::LeaveUserChaosCastle
EXTRN	?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetUserLevelToEnter
EXTRN	?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z:PROC ; CChaosCastle::CheckUserEnterMoney
EXTRN	?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z:PROC	; CChaosCastle::PayUserEnterMoney
EXTRN	?GetCurrentState@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurrentState
EXTRN	?GetCurEnteredUser@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurEnteredUser
EXTRN	?GetRemainTime@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetRemainTime
EXTRN	?CheckCanEnter@CChaosCastle@@QAE_NH@Z:PROC	; CChaosCastle::CheckCanEnter
EXTRN	?ObjSetPosition@CChaosCastle@@QAEHHHH@Z:PROC	; CChaosCastle::ObjSetPosition
EXTRN	?DropScroll@SnakeBegins@@QAE_NPAUOBJECTSTRUCT@@G@Z:PROC ; SnakeBegins::DropScroll
EXTRN	?Mix@SnakeBegins@@QAEXPAUOBJECTSTRUCT@@@Z:PROC	; SnakeBegins::Mix
EXTRN	?GetPrice@ItemPrice@@QAE_NFGEAAKAAE@Z:PROC	; ItemPrice::GetPrice
EXTRN	?SendPrice@ItemPrice@@QAEXHH@Z:PROC		; ItemPrice::SendPrice
EXTRN	?ProcInsert@ItemUpgradeJewels@@QAEXPAUOBJECTSTRUCT@@HH@Z:PROC ; ItemUpgradeJewels::ProcInsert
EXTRN	?IsJewel@ItemUpgradeJewels@@QAE_NH@Z:PROC	; ItemUpgradeJewels::IsJewel
EXTRN	?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z:PROC ; CNewPVP::IsObserver
EXTRN	?Reset@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z:PROC	; CNewPVP::Reset
EXTRN	?OnCGInviteDuel@@YAHPAU_tagPMSG_REQ_DUEL_INVITE@@H@Z:PROC ; OnCGInviteDuel
EXTRN	?OnCGAnswerDuel@@YAHPAU_tagPMSG_ANS_DUEL_ANSWER@@H@Z:PROC ; OnCGAnswerDuel
EXTRN	?OnCGLeaveDuel@@YAHPAU_tagPMSG_REQ_DUEL_EXIT@@H@Z:PROC ; OnCGLeaveDuel
EXTRN	?OnDuelChannelJoin@@YAHPAU_tagPMSG_REQ_DUEL_JOINCNANNEL@@H@Z:PROC ; OnDuelChannelJoin
EXTRN	?OnDuelChannelLeave@@YAHPAU_tagPMSG_REQ_DUEL_LEAVECNANNEL@@H@Z:PROC ; OnDuelChannelLeave
EXTRN	??0MonsterSpawnerMng@@QAE@XZ:PROC		; MonsterSpawnerMng::MonsterSpawnerMng
EXTRN	?procCreate@MonsterSpawnerMng@@QAE_NFH@Z:PROC	; MonsterSpawnerMng::procCreate
EXTRN	?isKeyItem@MonsterSpawnerMng@@QAE_NH@Z:PROC	; MonsterSpawnerMng::isKeyItem
EXTRN	?CG_RequestStart@ResetSystem@@QAEXHPAUPacketResetStart@@@Z:PROC ; ResetSystem::CG_RequestStart
EXTRN	?Run@CommandManager@@QAEXPAUOBJECTSTRUCT@@PAD@Z:PROC ; CommandManager::Run
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__chkstk:PROC
EXTRN	__except_handler4:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	__local_unwind4:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?gGensSystem@@3VCGensSystem@@A:BYTE		; gGensSystem
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?MagicDamageC@@3VCMagicDamage@@A:BYTE		; MagicDamageC
EXTRN	?gComboAttack@@3VCComboAttack@@A:DWORD		; gComboAttack
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?LogAddHeadHex@@3P6AXPAD0H@ZA:DWORD		; LogAddHeadHex
EXTRN	?LogAddL@@3P6AXPADZZA:DWORD			; LogAddL
EXTRN	?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A:BYTE ; g_kJewelOfHarmonySystem
EXTRN	?g_kItemSystemFor380@@3VCItemSystemFor380@@A:BYTE ; g_kItemSystemFor380
EXTRN	?g_SocketItem@@3VCSocketItems@@A:BYTE		; g_SocketItem
EXTRN	?RoadPathTable@@3PAFA:BYTE			; RoadPathTable
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?g_SelfDefenseOn@@3_NA:BYTE			; g_SelfDefenseOn
EXTRN	?g_SelfDefenseTime@@3HA:DWORD			; g_SelfDefenseTime
EXTRN	?g_ConnectMemberLoad@@3_NA:BYTE			; g_ConnectMemberLoad
EXTRN	?gSpeedHackPenalty@@3HA:DWORD			; gSpeedHackPenalty
EXTRN	?gEnableServerDivision@@3HA:DWORD		; gEnableServerDivision
EXTRN	?gMerryXMasNpcEvent@@3HA:DWORD			; gMerryXMasNpcEvent
EXTRN	?gHappyNewYearNpcEvent@@3HA:DWORD		; gHappyNewYearNpcEvent
EXTRN	?gStalkProtocolId@@3PADA:BYTE			; gStalkProtocolId
EXTRN	?gNonPK@@3HA:DWORD				; gNonPK
EXTRN	?gPkLimitFree@@3HA:DWORD			; gPkLimitFree
EXTRN	?bIsIgnorePacketSpeedHackDetect@@3HA:DWORD	; bIsIgnorePacketSpeedHackDetect
EXTRN	?gIsKickDetecHackCountLimit@@3HA:DWORD		; gIsKickDetecHackCountLimit
EXTRN	?gDoPShopOpen@@3HA:DWORD			; gDoPShopOpen
EXTRN	?wsGServer@@3VCwsGameServer@@A:BYTE		; wsGServer
EXTRN	?wsJServerCli@@3VwsJoinServerCli@@A:BYTE	; wsJServerCli
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?WhisperCash@@3VCWhisperCash@@A:BYTE		; WhisperCash
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?Guild@@3VCGuildClass@@A:BYTE			; Guild
EXTRN	?gNSerialCheck@@3PAVNSerialCheck@@A:BYTE	; gNSerialCheck
EXTRN	?szGameServerExeSerial@@3PADA:BYTE		; szGameServerExeSerial
EXTRN	?g_iServerGroupGuildChatting@@3HA:DWORD		; g_iServerGroupGuildChatting
EXTRN	?g_iServerGroupUnionChatting@@3HA:DWORD		; g_iServerGroupUnionChatting
EXTRN	?g_iSkillDistanceKick@@3HA:DWORD		; g_iSkillDistanceKick
EXTRN	?g_iSkillDistanceKickCount@@3HA:DWORD		; g_iSkillDistanceKickCount
EXTRN	?g_iSkillDiatanceKickCheckTime@@3KA:DWORD	; g_iSkillDiatanceKickCheckTime
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
EXTRN	?gStalkProtocol@@3HA:DWORD			; gStalkProtocol
EXTRN	?szClientVersion@@3PADA:QWORD			; szClientVersion
EXTRN	?bCanTrade@@3HA:DWORD				; bCanTrade
EXTRN	?bCanChaosBox@@3HA:DWORD			; bCanChaosBox
EXTRN	?bCanWarehouseLock@@3HA:DWORD			; bCanWarehouseLock
EXTRN	?gCreateCharacter@@3HA:DWORD			; gCreateCharacter
EXTRN	?gGuildDestroy@@3HA:DWORD			; gGuildDestroy
EXTRN	?g_GuildMaxMember@@3HA:DWORD			; g_GuildMaxMember
EXTRN	?g_GuildMaxAllianceMember@@3HA:DWORD		; g_GuildMaxAllianceMember
EXTRN	?g_CastleMinGuildMember@@3HA:DWORD		; g_CastleMinGuildMember
EXTRN	?gDQChaosSuccessRateLevel1@@3HA:DWORD		; gDQChaosSuccessRateLevel1
EXTRN	?gDQChaosSuccessRateLevel2@@3HA:DWORD		; gDQChaosSuccessRateLevel2
EXTRN	?gDQChaosSuccessRateLevel3@@3HA:DWORD		; gDQChaosSuccessRateLevel3
EXTRN	?gDQChaosSuccessRateLevel4@@3HA:DWORD		; gDQChaosSuccessRateLevel4
EXTRN	?gDQChaosSuccessRateLevel5@@3HA:DWORD		; gDQChaosSuccessRateLevel5
EXTRN	?gDQChaosSuccessRateLevel6@@3HA:DWORD		; gDQChaosSuccessRateLevel6
EXTRN	?gDQChaosSuccessRateLevel7@@3HA:DWORD		; gDQChaosSuccessRateLevel7
EXTRN	?gHackCheckCount@@3KA:DWORD			; gHackCheckCount
EXTRN	?gDetectedHackKickCount@@3HA:DWORD		; gDetectedHackKickCount
EXTRN	?g_bMuBotSystemOn@@3HA:DWORD			; g_bMuBotSystemOn
EXTRN	?g_iMuBotSystemUserLevel@@3HA:DWORD		; g_iMuBotSystemUserLevel
EXTRN	?g_iMuBotStage1Zen@@3HA:DWORD			; g_iMuBotStage1Zen
EXTRN	?g_CreateCharLevelRF@@3FA:WORD			; g_CreateCharLevelRF
EXTRN	?g_CreateCharLevelSUM@@3FA:WORD			; g_CreateCharLevelSUM
EXTRN	?g_CreateCharLevelDL@@3FA:WORD			; g_CreateCharLevelDL
EXTRN	?g_CreateCharLevelMG@@3FA:WORD			; g_CreateCharLevelMG
EXTRN	?g_MultilangCharacterName@@3EA:BYTE		; g_MultilangCharacterName
EXTRN	?g_MultilangGuildName@@3EA:BYTE			; g_MultilangGuildName
EXTRN	?gc_bBlockFullExcellent@@3HA:DWORD		; gc_bBlockFullExcellent
EXTRN	?gc_bBlockFullAncient@@3HA:DWORD		; gc_bBlockFullAncient
EXTRN	?gc_bPersonalID@@3HA:DWORD			; gc_bPersonalID
EXTRN	?g_RenaCount@@3HA:DWORD				; g_RenaCount
EXTRN	?g_StoneCount@@3HA:DWORD			; g_StoneCount
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?gQuestInfoEx@@3VCQuestInfoEx@@A:BYTE		; gQuestInfoEx
EXTRN	?ConMember@@3VCConMember@@A:BYTE		; ConMember
EXTRN	?g_ChaosBox@@3VCChaosBox@@A:BYTE		; g_ChaosBox
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?UnionManager@@3VTUnion@@A:BYTE			; UnionManager
EXTRN	?g_CsNPC_Weapon@@3VCWeapon@@A:BYTE		; g_CsNPC_Weapon
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?g_KalimaGate@@3VCKalimaGate@@A:BYTE		; g_KalimaGate
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?g_IllusionTemple@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTemple
EXTRN	?g_ShopManager@@3VShopManager@@A:BYTE		; g_ShopManager
EXTRN	?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A:BYTE ; g_CashItemPeriodSystem
EXTRN	?gBSGround@@3PAPAVCBattleSoccer@@A:DWORD	; gBSGround
EXTRN	?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A:BYTE	; gQeustNpcTeleport
EXTRN	?gGateC@@3VCGate@@A:BYTE			; gGateC
EXTRN	?gPacketCheckSum@@3VCPacketCheckSum@@A:BYTE	; gPacketCheckSum
EXTRN	?gDarkSpirit@@3PAVCDarkSpirit@@A:BYTE		; gDarkSpirit
EXTRN	?g_CrywolfNPC_Altar@@3VCCrywolfAltar@@A:BYTE	; g_CrywolfNPC_Altar
EXTRN	?g_CrywolfSync@@3VCCrywolfSync@@A:BYTE		; g_CrywolfSync
EXTRN	?g_DevilSquare@@3VCDevilSquare@@A:BYTE		; g_DevilSquare
EXTRN	?g_KanturuEntranceNPC@@3VCKanturuEntranceNPC@@A:DWORD ; g_KanturuEntranceNPC
EXTRN	?g_CashShop@@3VCCashShop@@A:BYTE		; g_CashShop
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?g_iNpcUpDfLevel_CGATE@@3PAY02HA:BYTE		; g_iNpcUpDfLevel_CGATE
EXTRN	?g_iNpcUpDfLevel_CSTATUE@@3PAY02HA:BYTE		; g_iNpcUpDfLevel_CSTATUE
EXTRN	?g_iNpcUpMaxHP_CGATE@@3PAY02HA:BYTE		; g_iNpcUpMaxHP_CGATE
EXTRN	?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA:BYTE		; g_iNpcUpMaxHP_CSTATUE
EXTRN	?g_iNpcUpRgLevel_CSTATUE@@3PAY02HA:BYTE		; g_iNpcUpRgLevel_CSTATUE
EXTRN	?g_CsNPC_LifeStone@@3VCLifeStone@@A:DWORD	; g_CsNPC_LifeStone
EXTRN	?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A:BYTE ; g_MasterSkillSystem
EXTRN	?g_CsNPC_Mercenary@@3VCMercenary@@A:QWORD	; g_CsNPC_Mercenary
EXTRN	?g_CsNPC_Guardian@@3VCGuardian@@A:DWORD		; g_CsNPC_Guardian
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
EXTRN	?gGamblingEvent@@3VCGamblingEvent@@A:BYTE	; gGamblingEvent
EXTRN	?g_EventItemBagManager@@3VEventItemBagManager@@A:BYTE ; g_EventItemBagManager
EXTRN	?gDoubleGoer@@3VCDoubleGoerEvent@@A:BYTE	; gDoubleGoer
EXTRN	?g_ImperialGuardian@@3VCImperialGuardian@@A:BYTE ; g_ImperialGuardian
EXTRN	?g_ElementalSystem@@3VCElementalSystem@@A:BYTE	; g_ElementalSystem
EXTRN	?g_Minimap@@3VMinimap@@A:BYTE			; g_Minimap
EXTRN	?g_ShopBoard@@3VShopBoard@@A:DWORD		; g_ShopBoard
EXTRN	?g_GuildMatch@@3VGuildMatch@@A:BYTE		; g_GuildMatch
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?g_SnakeBegins@@3VSnakeBegins@@A:BYTE		; g_SnakeBegins
EXTRN	?g_ItemPrice@@3VItemPrice@@A:BYTE		; g_ItemPrice
EXTRN	?g_ItemUpgradeJewels@@3VItemUpgradeJewels@@A:BYTE ; g_ItemUpgradeJewels
EXTRN	?g_NewPVP@@3VCNewPVP@@A:BYTE			; g_NewPVP
EXTRN	?m_Instance@MonsterSpawnerMng@@0PAV1@A:DWORD	; MonsterSpawnerMng::m_Instance
EXTRN	?g_ResetSystem@@3VResetSystem@@A:BYTE		; g_ResetSystem
EXTRN	?g_CommandManager@@3VCommandManager@@A:BYTE	; g_CommandManager
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?g_CreditLog@@3VCLogToFile@@A DB 010228H DUP (?)	; g_CreditLog
_BSS	ENDS
CRT$XCU	SEGMENT
?g_CreditLog$initializer$@@3P6AXXZA DD FLAT:??__Eg_CreditLog@@YAXXZ ; g_CreditLog$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@ffffffffffffffffffffffffffffffff
CONST	SEGMENT
__xmm@ffffffffffffffffffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@406fc00000000000
CONST	SEGMENT
__real@406fc00000000000 DQ 0406fc00000000000r	; 254
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fe4cccccccccccd
CONST	SEGMENT
__real@3fe4cccccccccccd DQ 03fe4cccccccccccdr	; 0.65
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_CS_NPC_DATA@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_CS_NPC_DATA@@8 DD FLAT:??_R0?AU_CS_NPC_DATA@@@8 ; _CS_NPC_DATA::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_CS_NPC_DATA@@8
rdata$r	ENDS
;	COMDAT ??_R2_CS_NPC_DATA@@8
rdata$r	SEGMENT
??_R2_CS_NPC_DATA@@8 DD FLAT:??_R1A@?0A@EA@_CS_NPC_DATA@@8 ; _CS_NPC_DATA::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_CS_NPC_DATA@@8
rdata$r	SEGMENT
??_R3_CS_NPC_DATA@@8 DD 00H				; _CS_NPC_DATA::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_CS_NPC_DATA@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_CS_NPC_DATA@@@8
data$r	SEGMENT
??_R0?AU_CS_NPC_DATA@@@8 DD FLAT:??_7type_info@@6B@	; _CS_NPC_DATA `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_CS_NPC_DATA@@', 00H
data$r	ENDS
;	COMDAT ??_R4_CS_NPC_DATA@@6B@
rdata$r	SEGMENT
??_R4_CS_NPC_DATA@@6B@ DD 00H				; _CS_NPC_DATA::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU_CS_NPC_DATA@@@8
	DD	FLAT:??_R3_CS_NPC_DATA@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BM@JGJDNBPL@?$FLDEBUG?$FN?5Text?3?5?$CFs?0?5Value?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BM@JGJDNBPL@?$FLDEBUG?$FN?5Text?3?5?$CFs?0?5Value?3?5?$CFd?$AA@ DB '['
	DB	'DEBUG] Text: %s, Value: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GN@LMFACHAA@?$FLUseCahngeSkinState?$FN?$FLCGEnableUse@
CONST	SEGMENT
??_C@_0GN@LMFACHAA@?$FLUseCahngeSkinState?$FN?$FLCGEnableUse@ DB '[UseCah'
	DB	'ngeSkinState][CGEnableUsePolymorphSkinrRecv] [ChaageEanbleSta'
	DB	'te : %d] On(Use): 0 / Off: 1(Don''t Use) ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IHDJCCIO@MU?5Helper?5cant?5run?5on?5this?5locat@
CONST	SEGMENT
??_C@_0CE@IHDJCCIO@MU?5Helper?5cant?5run?5on?5this?5locat@ DB 'MU Helper '
	DB	'cant run on this location', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OKKAKFII@Only?5characters?5above?5?$CFd?5level?5c@
CONST	SEGMENT
??_C@_0DB@OKKAKFII@Only?5characters?5above?5?$CFd?5level?5c@ DB 'Only cha'
	DB	'racters above %d level can run MU Helper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JAGJPNLP@?$FLMuBot?$FN?5Option?5Send?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BN@JAGJPNLP@?$FLMuBot?$FN?5Option?5Send?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ DB '['
	DB	'MuBot] Option Send [%s][%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JLEKNDOL@?$FLMuBot?$FN?5Option?5Save?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BN@JLEKNDOL@?$FLMuBot?$FN?5Option?5Save?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ DB '['
	DB	'MuBot] Option Save [%s][%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
CONST	SEGMENT
??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ DB '['
	DB	'0x4A] CGRageAttack() - Invalid KillCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
CONST	SEGMENT
??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@ DB '['
	DB	'0x4A] CGRageAttack() - Invalid Status', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@GKLOHMBB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
CONST	SEGMENT
??_C@_0EM@GKLOHMBB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ DB '['
	DB	'%s][%s] Try Attack In Not Attack Area [Protocol] (%d:%d,%d) e'
	DB	'rrortype = %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@
CONST	SEGMENT
??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@ DB '['
	DB	'Castle HuntZone] [%s][%s] - Entrance TAX : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcDbList() ERROR - Authority Fail [%s][%s],'
	DB	' Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@
CONST	SEGMENT
??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@ DB '['
	DB	'CastleSiege] [Reg. Fail] Accumulated Crown AccessTime : %d [%'
	DB	's](%s)(%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@
CONST	SEGMENT
??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@ DB '['
	DB	'CastleSiege] [Reg. Success] Accumulated Crown AccessTime : %d'
	DB	' [%s](%s)(%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@
CONST	SEGMENT
??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@ DB '['
	DB	'CastleSiege] [Reg. Attempt] Accumulated Crown AccessTime : %d'
	DB	' [%s](%s)(%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() ERROR - Gate Doesn''t Exist [%s][%s'
	DB	'], Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() OK - [%s][%s], Guild:(%s)(%d), DOOR'
	DB	':(%d)(X:%d,Y:%d)(STATUE:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() ERROR - Operate Gate Failed [%s][%s'
	DB	'], Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
CONST	SEGMENT
??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@ DB '[CastleSi'
	DB	'ege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Gu'
	DB	'ild:(%s)(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
CONST	SEGMENT
??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() REQ OK - [%s][%s], Guild:(%s)(%d)'
	DB	', Money:%d, TotMoney:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
CONST	SEGMENT
??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() ERROR - Castle Money is Low [%s]['
	DB	'%s], Guild:(%s)(%d), Money:%d, TotMoney:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
CONST	SEGMENT
??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() ERROR - Req Money < 0 [%s][%s], G'
	DB	'uild:(%s)(%d), Money:%d, TotMoney:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
CONST	SEGMENT
??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@ DB '[Castl'
	DB	'eSiege] CGReqMoneyDrawOut() ERROR - Authority Fail [%s][%s], '
	DB	'Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
CONST	SEGMENT
??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ DB '[CastleSi'
	DB	'ege] CGReqTaxRateChange() REQ OK - [%s][%s], Guild:(%s)(%d), '
	DB	'TaxType:%d, TaxRate:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
CONST	SEGMENT
??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ DB '[CastleSi'
	DB	'ege] CGReqTaxRateChange() ERROR - Tax Rate Out of Range [%s]['
	DB	'%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
CONST	SEGMENT
??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@ DB '[CastleSi'
	DB	'ege] CGReqTaxRateChange() ERROR - Authority Fail [%s][%s], Gu'
	DB	'ild:(%s)(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
CONST	SEGMENT
??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ DB '[Castl'
	DB	'eSiege] CGReqTaxMoneyInfo() REQ OK - [%s][%s], Guild:(%s)(%d)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
CONST	SEGMENT
??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@ DB '[Castl'
	DB	'eSiege] CGReqTaxMoneyInfo() ERROR - Authority Fail [%s][%s], '
	DB	'Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[Ca'
	DB	'stleSiege] CGReqNpcUpgrade() REQ OK - [%s][%s], Guild:(%s)(%d'
	DB	'), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@
CONST	SEGMENT
??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@ DB '['
	DB	'CastleSiege] [0xB2][0x07] CGReqNpcUpgrade() - Pay For Npc Upg'
	DB	'rade (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - Gem is Low [%s][%s], Gu'
	DB	'ild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:'
	DB	'%d, Gem:%d, Need Gem:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - Money is Low [%s][%s], '
	DB	'Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTL'
	DB	'V:%d, Money:%d, Need Money:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - UpType doesn''t Exist ['
	DB	'%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL'
	DB	':%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
CONST	SEGMENT
??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@ DB '[C'
	DB	'astleSiege] CGReqNpcUpgrade() ERROR - Authority Fail [%s][%s]'
	DB	', Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@
CONST	SEGMENT
??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() OK - [%s][%s], Guild:(%s)(%d), N'
	DB	'pc:(CLS:%d, IDX:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - Money isn''t enough [%s]'
	DB	'[%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch '
	DB	'[%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - CL Request Fail [%s][%s]'
	DB	', Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
CONST	SEGMENT
??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@ DB '[C'
	DB	'astleSiege] CGReqNpcRepair() ERROR - Authority Fail [%s][%s],'
	DB	' Guild:(%s)(%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@
CONST	SEGMENT
??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@ DB '['
	DB	'CastleSiege] CGReqNpcBuy() OK - [%s][%s], Guild:(%s)(%d), Npc'
	DB	':(CLS:%d, IDX:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
CONST	SEGMENT
??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ DB '[C'
	DB	'astleSiege] CGReqNpcBuy() ERROR - CCastleSiege::CheckAddDbNPC'
	DB	'() [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
CONST	SEGMENT
??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@ DB '[C'
	DB	'astleSiege] CGReqNpcBuy() ERROR - Authority Fail [%s][%s], Gu'
	DB	'ild:(%s)(%d), Npc:(CLS:%d, IDX:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@
CONST	SEGMENT
??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@ DB '['
	DB	'CastleSiege] [%s][%s] GiveUp Castle Siege (GUILD:%s) - Result'
	DB	':%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@
CONST	SEGMENT
??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@ DB '['
	DB	'CastleSiege] [%s][%s] Registered Castle Siege (GUILD:%s) - Re'
	DB	'sult:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@
CONST	SEGMENT
??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@ DB '[Ma'
	DB	'pServerMng] Packet Error JG [0x7B] - Index out of bound : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@
CONST	SEGMENT
??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@ DB '[MapSe'
	DB	'rverMng] Map Server Join Send : [%s][%s](%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@
CONST	SEGMENT
??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@ DB 0a1H, 0d9H, ' Term'
	DB	'inated Guild.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@
CONST	SEGMENT
??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@ DB 0a1H, 0daH, ' Termi'
	DB	'nated User.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@
CONST	SEGMENT
??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0d9H, ' ', 0b1H, 0e6H, 0b5H, 0e5H, ' ', 0c1H
	DB	0a4H, 0baH, 0b8H, ' ', 0c3H, 0a3H, 0c0H, 0bbH, 0bcH, 0f6H, ' ', 0beH
	DB	0f8H, 0c0H, 0bdH, '. ', 0c0H, 0ccH, 0b8H, 0a7H, ' : [%s] ', 0b9H
	DB	0f8H, 0c8H, 0a3H, ' : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Chaos nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid TargetTrade nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Trade nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid WareHouse nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
CONST	SEGMENT
??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@ DB '['
	DB	'PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@ DB 'error-L2 :'
	DB	' Index %s %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Duel] [%s][%s] Duel Ended [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@
CONST	SEGMENT
??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@ DB '['
	DB	'Duel] [%s][%s] Requested to Start Duel to [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@
CONST	SEGMENT
??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@ DB '[CharTr'
	DB	'asfer] Request Character Trasfer [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@
CONST	SEGMENT
??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@ DB 0b9H
	DB	0aeH, 0c1H, 0a6H, ' ', 0b9H, 0dfH, 0bbH, 0fdH, 0bdH, 0c3H, ' c'
	DB	'hange@webzen.co.kr', 0b7H, 0ceH, ' ', 0b9H, 0aeH, 0c0H, 0c7H, 0c7H
	DB	0d8H, ' ', 0c1H, 0d6H, 0bdH, 0c3H, 0b1H, 0e2H, 0b9H, 0d9H, 0b6H
	DB	0f8H, 0b4H, 0cfH, 0b4H, 0d9H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@
CONST	SEGMENT
??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@ DB '[Char'
	DB	'Trasfer] Fail (JoominNumber) [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@
CONST	SEGMENT
??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@ DB '['
	DB	'Mu_2Anv_Event] [%s][%s] Register Lotto Number (Serial: %s-%s-'
	DB	'%s)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle'
	DB	' (Guard Mail Set Serial:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle'
	DB	' (Invisible Cloak Serial:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@
CONST	SEGMENT
??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ DB '['
	DB	'EventChip] [%s][%s] Request Change Rena', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@
CONST	SEGMENT
??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@ DB '['
	DB	'EventChip] [%s][%s] Request Change Stones', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@
CONST	SEGMENT
??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@ DB '['
	DB	'EventChip] [%s][%s] Request MutoNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@
CONST	SEGMENT
??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@ DB 0c0H
	DB	0ccH, 0b9H, 0ccH, ' ', 0b7H, 0e7H, 0b0H, 0a1H, 0b5H, 0e5H, 0c0H
	DB	0c7H, ' ', 0bcH, 0fdH, 0c0H, 0daH, 0b0H, 0a1H, ' ', 0c0H, 0d6H
	DB	0bdH, 0c0H, 0b4H, 0cfH, 0b4H, 0d9H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JDNCDNDO@You?5lack?5items?5to?5exchange?$CB?$AA@
CONST	SEGMENT
??_C@_0BM@JDNCDNDO@You?5lack?5items?5to?5exchange?$CB?$AA@ DB 'You lack i'
	DB	'tems to exchange!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
CONST	SEGMENT
??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ DB '['
	DB	'EventChip] [%s][%s] Not Found EventChip (RegEventchip) #2 %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
CONST	SEGMENT
??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@ DB '['
	DB	'EventChip] [%s][%s] Not Found EventChip (RegEventchip) #1 %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
CONST	SEGMENT
??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ DB '['
	DB	'EventChip] [%s][%s] Attempted ItemCopy using ChaosBox Window', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
CONST	SEGMENT
??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@ DB '['
	DB	'EventChip] [%s][%s] Attempted ItemCopy using Trade Window', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'PK User][BloodCastle] [%s][%s] Move Fail [PK Level:%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'PK User][DevilSquare] [%s][%s] Move Fail [PK Level:%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] Remov'
	DB	'eItem[%s][%d][%d][%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@
CONST	SEGMENT
??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@ DB '['
	DB	'DevilSquare] [%s][%s] GetUserLevelToEnter() failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Invitation LevelError '
	DB	'[%d][%d][%d][%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
CONST	SEGMENT
??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@ DB '['
	DB	'DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@
CONST	SEGMENT
??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@ DB '['
	DB	'DevilSquare] [%s][%s] Request Move DevilSquare [%d][%d][%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@ DB 'return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@ DB 'GCMa'
	DB	'naSend() return %s %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@ DB 'e'
	DB	'rror-L3 : %s return %s %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@
CONST	SEGMENT
??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@ DB 'e'
	DB	'rror-L3 : %s return %s %d %d %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HAOMGPEH@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
CONST	SEGMENT
??_C@_0CJ@HAOMGPEH@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ DB '['
	DB	'%s] [%s] [MasterLevelSkill Reset] - All', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@LLBOIAD@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
CONST	SEGMENT
??_C@_0EB@LLBOIAD@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ DB '['
	DB	'%s] [%s] [MasterLevelSkill Reset] - Enhance Attack/Defense (%'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@CEAHPFGG@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
CONST	SEGMENT
??_C@_0DG@CEAHPFGG@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ DB '['
	DB	'%s] [%s] [MasterLevelSkill Reset] - Strengthen Skill', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IGJGPHCH@Master?5Skill?5Reset?5Fail?$AA@
CONST	SEGMENT
??_C@_0BI@IGJGPHCH@Master?5Skill?5Reset?5Fail?$AA@ DB 'Master Skill Reset'
	DB	' Fail', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HEGKGIOI@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
CONST	SEGMENT
??_C@_0CN@HEGKGIOI@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@ DB '['
	DB	'%s] [%s] [MasterLevelSkill Reset] - Passive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@
CONST	SEGMENT
??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@ DB '['
	DB	'Using Item] [Charm of Move - SavePosition] [%s][%s] Map:[%d] '
	DB	'X:[%d] Y:[%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@ DB '['
	DB	'Using Item] [Charm of Move] [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@
CONST	SEGMENT
??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@ DB '['
	DB	'Using Item] [Charm of Raise] [%s][%s] Die Position Map:[%d] X'
	DB	':[%d] Y:[%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@
CONST	SEGMENT
??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@ DB '[PCS]'
	DB	' Use Free Kalima Ticket Failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@
CONST	SEGMENT
??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@ DB '[PCS]'
	DB	' Use Free Kalima Ticket Success', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
CONST	SEGMENT
??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ DB '[Castle'
	DB	'Siege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s]['
	DB	'%s]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
CONST	SEGMENT
??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@ DB '[Castle'
	DB	'Siege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s]['
	DB	'%s] - (Guild : %s)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@ DB '['
	DB	'Using Item] [Return Scroll] [%s][%s] - Current Map:[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@
CONST	SEGMENT
??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@ DB '['
	DB	'%s][%s]Use Compound Potion Lv3 - SD[%d] HP[%f] -> SD[%d] HP[%'
	DB	'f]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@
CONST	SEGMENT
??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@ DB '['
	DB	'%s][%s]Use Compound Potion Lv2 - SD[%d] HP[%f] -> SD[%d] HP[%'
	DB	'f]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@
CONST	SEGMENT
??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@ DB '['
	DB	'%s][%s]Use Compound Potion Lv1 - SD[%d] HP[%f] -> SD[%d] HP[%'
	DB	'f]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@
CONST	SEGMENT
??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [UseItem] (%s)(%s) Item(%s) Pos(%d)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@
CONST	SEGMENT
??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@ DB 'e'
	DB	'rror-L1 : [%s][%s] CGUseItemRecv()_Pos return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@
CONST	SEGMENT
??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@ DB '['
	DB	'%s][%s] CGUseItemRecv()_Inventory return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@
CONST	SEGMENT
??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@ DB '['
	DB	'%s][%s] CGUseItemRecv() Failed : Transaction == 1, IF_TYPE : '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@
CONST	SEGMENT
??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@ DB '['
	DB	'%s][%s] CGUseItemRecv()_CloseType return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@
CONST	SEGMENT
??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@ DB '['
	DB	'%s][%s] CGUseItemRecv()_If return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
CONST	SEGMENT
??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ DB '['
	DB	'0x1E] CGDurationMagicRecv() - Invalid KillCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
CONST	SEGMENT
??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@ DB '['
	DB	'0x1E] CGDurationMagicRecv() - Invalid Status', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@
CONST	SEGMENT
??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@ DB '['
	DB	'%s][%s] %s Detect Hack : Multi Attack', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@COJBHLGO@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@
CONST	SEGMENT
??_C@_0DJ@COJBHLGO@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0daH, 0a1H, 0daH, ' InValid VailidCoun'
	DB	't = %d ( Count : %d) [%s][%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@PFIDPOLC@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@
CONST	SEGMENT
??_C@_0DN@PFIDPOLC@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@ DB 0a1H
	DB	0daH, 0a1H, 0daH, 0a1H, 0daH, 0a1H, 0daH, ' InValid DurationTi'
	DB	'me Key = %d ( Time : %d) [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
CONST	SEGMENT
??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@ DB '['
	DB	'%s][%s] %s Apply Attack Speed Penalty (%d left)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
CONST	SEGMENT
??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ DB '['
	DB	'%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
CONST	SEGMENT
??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@ DB '['
	DB	'%s][%s] %s Kick DetecHackCountLimit Over User (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@
CONST	SEGMENT
??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@ DB 'Too long ti'
	DB	'me passed after casting magic. [%s][%s] (%d)(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@
CONST	SEGMENT
??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@ DB '['
	DB	'%s][%s] Try Target Teleport Not Move Area [%d,%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@
CONST	SEGMENT
??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@ DB '['
	DB	'%s][%s] Try Teleport Not Move Area [%d,%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. '
	DB	'count(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
CONST	SEGMENT
??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ DB '['
	DB	'0x19] CGMagicAttack() - Invalid KillCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
CONST	SEGMENT
??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@ DB '['
	DB	'0x19] CGMagicAttack() - Invalid Status', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
CONST	SEGMENT
??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ DB '['
	DB	'%s][%s] Try Attack In Not Attack Area [Protocol] (%s:%d,%d) e'
	DB	'rrortype = %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@ DB 'error :%s %d %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LECGNCFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
CONST	SEGMENT
??_C@_0DF@LECGNCFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@ DB '['
	DB	'%s][%s] %s Apply Attack Speed Penalty (%d left) @%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@PGHIAIFO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
CONST	SEGMENT
??_C@_0EB@PGHIAIFO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@ DB '['
	DB	'%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d @'
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CILMICFP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
CONST	SEGMENT
??_C@_0DI@CILMICFP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@ DB '['
	DB	'%s][%s] %s Kick DetecHackCountLimit Over User (%d) @%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@
CONST	SEGMENT
??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@ DB '['
	DB	'CGAttack] [UserIndex Error] :%s %d %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@
CONST	SEGMENT
??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@ DB 'error : mo'
	DB	've protocol index error %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@
CONST	SEGMENT
??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@ DB 'error'
	DB	'-L3 : Path Count error %d id:%s %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@
CONST	SEGMENT
??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@ DB 'error-L3 '
	DB	': move protocol index error %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@
CONST	SEGMENT
??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@ DB '['
	DB	'%s][%s] Undefine chaosmix type detect %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@
CONST	SEGMENT
??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@ DB '['
	DB	'%s][%s] Already Used Chaos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@
CONST	SEGMENT
??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@ DB 'Get WareHo'
	DB	'use Money(In WareHouse) : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@
CONST	SEGMENT
??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@ DB 'Get WareHo'
	DB	'use Money(In Inventory) : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@ DB 'error-L'
	DB	'3 [%s][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@ DB 'Target Score %s %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@ DB 'Score %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@ENCBPHMM@Guild?5War?5cannot?5be?5started?5with@
CONST	SEGMENT
??_C@_0DC@ENCBPHMM@Guild?5War?5cannot?5be?5started?5with@ DB 'Guild War c'
	DB	'annot be started within Imperial Fort.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@IJAALLLN@Guild?5War?5cannot?5be?5started?5with@
CONST	SEGMENT
??_C@_0DB@IJAALLLN@Guild?5War?5cannot?5be?5started?5with@ DB 'Guild War c'
	DB	'annot be started within Doppelganger.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OPCGOEPD@Guild?5War?5cannot?5be?5started?5with@
CONST	SEGMENT
??_C@_0DE@OPCGOEPD@Guild?5War?5cannot?5be?5started?5with@ DB 'Guild War c'
	DB	'annot be started within Illusion Temple.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@
CONST	SEGMENT
??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@ DB 'Error on '
	DB	'declaring war : Target GuildMaster Is Murderer 0x04 %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@
CONST	SEGMENT
??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@ DB '['
	DB	'U.System][Guildwar] Can''t declare guildwar between Same Unio'
	DB	'n (%s / %d) <-> (%s / %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@
CONST	SEGMENT
??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@ DB 'Error on d'
	DB	'eclaring war : GuildMaster Is Murderer 0x04 %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@
CONST	SEGMENT
??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@ DB '['
	DB	'%s][%s] Guild Request - Leave : %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@
CONST	SEGMENT
??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@ DB '['
	DB	'%s][%s] Guild Request - Dismiss All : %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@
CONST	SEGMENT
??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@ DB '['
	DB	'%s][%s] Guild Request - Join : %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CPKIABHC@User?5not?5found?$AA@
CONST	SEGMENT
??_C@_0P@CPKIABHC@User?5not?5found?$AA@ DB 'User not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDGHFMPH@No?5party?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@IDGHFMPH@No?5party?5?$CFs?5?$CFs?$AA@ DB 'No party %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IDLFABNI@PartyMember?$CI?$CFd?$CJ?5?3?5Party?5Out?4?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0CG@IDLFABNI@PartyMember?$CI?$CFd?$CJ?5?3?5Party?5Out?4?5?$FL?$CFs@ DB 'P'
	DB	'artyMember(%d) : Party Out. [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@ DB '%s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAPFACKC@User?5Not?5found?$AA@
CONST	SEGMENT
??_C@_0P@GAPFACKC@User?5Not?5found?$AA@ DB 'User Not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@ DB 'No Party %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@ DB '%s %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'P'
	DB	'arty result : %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@
CONST	SEGMENT
??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@ DB 'Party not a'
	DB	'llowed in Imperial Fort.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@
CONST	SEGMENT
??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@ DB 'Party not al'
	DB	'lowed in Doppelganger.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@
CONST	SEGMENT
??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@ DB 'Party not a'
	DB	'llowed in Illusion Temple.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@
CONST	SEGMENT
??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@ DB '['
	DB	'PShop] [%s][%s] Sold All Items - Auto Closing PShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@
CONST	SEGMENT
??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@ DB '['
	DB	'PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s]'
	DB	'[%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, S'
	DB	'erial:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No R'
	DB	'oom to Buy Item', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Boun'
	DB	'dle Jewels - Type: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No e'
	DB	'nough Jewels - Type: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@CGGBJBAH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FC@CGGBJBAH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No R'
	DB	'oom to Store Reward', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exce'
	DB	'eding Zen of the Host', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack'
	DB	' of Zen', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did '
	DB	'Not Choose Item Price', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Requester Tra'
	DB	'nsaction == 1, IF_TYPE : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
CONST	SEGMENT
??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [PShop Buy] (%s)(%s) Item(%s) Pos(%'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Alre'
	DB	'ady Trade With Other', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is i'
	DB	'n Item Block', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is C'
	DB	'losing Connection', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Name Mismatch'
	DB	' [%s] - [%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did '
	DB	'not Open PShop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@KFEECMPB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EG@KFEECMPB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Mini'
	DB	'ng (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Not'
	DB	' CHARACTER (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller did No'
	DB	't CONNECTED (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@
CONST	SEGMENT
??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@ DB '['
	DB	'PShop] [%s][%s] is Receiving PShop List From [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Requester Transac'
	DB	'tion == 1, IF_TYPE : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : [%s][%s] is in It'
	DB	'em Block', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : [%s][%s] Did not '
	DB	'Open PShop', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Requested to Him(/Her)Self', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Clos'
	DB	'ing (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
CONST	SEGMENT
??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@ DB '['
	DB	'PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Clo'
	DB	'sing (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Seller is Not CHA'
	DB	'RACTER (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
CONST	SEGMENT
??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@ DB '['
	DB	'PShop] [%s][%s] PShop List Request Failed : Seller did Not CO'
	DB	'NNECTED (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@
CONST	SEGMENT
??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@ DB '['
	DB	'PShop] [%s][%s] Close PShop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@
CONST	SEGMENT
??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@ DB '['
	DB	'PShop] [%s][%s] Requested to Close PShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@
CONST	SEGMENT
??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@ DB '['
	DB	'PShop] [%s][%s] Personal Shop Already Opened - Changing PShop'
	DB	' Name', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@
CONST	SEGMENT
??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@ DB '['
	DB	'PShop] [%s][%s] Personal Shop Opened', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@
CONST	SEGMENT
??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@ DB '['
	DB	'PShop] [%s][%s] ERROR : Transaction == 1, IF_TYPE : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@
CONST	SEGMENT
??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@ DB '['
	DB	'PShop] [%s][%s] ERROR : Unknown m_IfState.type : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@
CONST	SEGMENT
??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@ DB '['
	DB	'PShop] [%s][%s] ERROR : m_IfState.type is Using : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@GMNEGEAG@You?5cannot?5open?5your?5Personal?5Sh@
CONST	SEGMENT
??_C@_0DJ@GMNEGEAG@You?5cannot?5open?5your?5Personal?5Sh@ DB 'You cannot '
	DB	'open your Personal Shop within Imperial Fort.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@MIGHMEIJ@You?5cannot?5open?5your?5Personal?5Sh@
CONST	SEGMENT
??_C@_0DI@MIGHMEIJ@You?5cannot?5open?5your?5Personal?5Sh@ DB 'You cannot '
	DB	'open your Personal Shop within Doppelganger.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@LHDFDIDM@You?5cannot?5open?5your?5Personal?5Sh@
CONST	SEGMENT
??_C@_0DL@LHDFDIDM@You?5cannot?5open?5your?5Personal?5Sh@ DB 'You cannot '
	DB	'open your Personal Shop within Illusion Temple.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@
CONST	SEGMENT
??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@ DB '['
	DB	'PShop] [%s][%s] ERROR : Cant''t Open Shop - Item Block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@
CONST	SEGMENT
??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@ DB '['
	DB	'PShop] [%s][%s] Changing Item Price : %d (B: %d, S: %d, C: %d'
	DB	') (Type:%d (%s), Lev:%d, Serial:%d, Dur:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@ODKADHDC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Ou@
CONST	SEGMENT
??_C@_0CK@ODKADHDC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Ou@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Outof Bound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@
CONST	SEGMENT
??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Price Change - Item Block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@
CONST	SEGMENT
??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@ DB '['
	DB	'PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
CONST	SEGMENT
??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@ DB 'e'
	DB	'rror-L2 : CopyItem [%s][%s] return %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
CONST	SEGMENT
??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [PShop] (%s)(%s) Item(%s) Pos(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@
CONST	SEGMENT
??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Does Not Exist : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@
CONST	SEGMENT
??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@ DB '['
	DB	'PShop] [%s][%s] ERROR : Item Position Out of Bound : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@
CONST	SEGMENT
??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@ DB '['
	DB	'PShop] [%s][%s] ERROR : Level is Under 6 : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
CONST	SEGMENT
??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@ DB '[PS'
	DB	'hop] ERROR : Index is not CHARACTER : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
CONST	SEGMENT
??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@ DB '[PS'
	DB	'hop] ERROR : Index is not CONNECTED : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@
CONST	SEGMENT
??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@ DB '[%s'
	DB	'][%s] Trade Accept', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@ DB 'Interface State :'
	DB	' %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@ DB '['
	DB	'%s][%s] Trade Ready [%s][%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@
CONST	SEGMENT
??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@ DB '['
	DB	'%s][%s] Made Trade Error (in Transaction) [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@
CONST	SEGMENT
??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@ DB '['
	DB	'%s][%s] CGTradeResponseRecv() Failed : Transaction == 1, IF_T'
	DB	'YPE : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@
CONST	SEGMENT
??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@ DB '('
	DB	'%s)(%s) Trade Interface State Error : use:%d type:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@
CONST	SEGMENT
??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@ DB 'e'
	DB	'rror-L1 : target:%d (A_ID:%s) %s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@ DB 'e'
	DB	'rror-L1 : %d (A_ID:%s) %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@
CONST	SEGMENT
??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@ DB '['
	DB	'%s][%s] CGTradeRequestSend() Failed : Transaction == 1, IF_TY'
	DB	'PE : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CHOLFFAK@Trade?5not?5allowed?5on?5duel?5arena?$AA@
CONST	SEGMENT
??_C@_0CA@CHOLFFAK@Trade?5not?5allowed?5on?5duel?5arena?$AA@ DB 'Trade no'
	DB	't allowed on duel arena', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BFADMIPH@You?5cannot?5trade?5inside?5Imperial@
CONST	SEGMENT
??_C@_0CH@BFADMIPH@You?5cannot?5trade?5inside?5Imperial@ DB 'You cannot t'
	DB	'rade inside Imperial Fort.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MDHDJBIA@You?5cannot?5trade?5inside?5Doppelga@
CONST	SEGMENT
??_C@_0CG@MDHDJBIA@You?5cannot?5trade?5inside?5Doppelga@ DB 'You cannot t'
	DB	'rade inside Doppelganger.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GFPCHONE@You?5cannot?5trade?5inside?5Illusion@
CONST	SEGMENT
??_C@_0CJ@GFPCHONE@You?5cannot?5trade?5inside?5Illusion@ DB 'You cannot t'
	DB	'rade inside Illusion Temple.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@ DB 'error '
	DB	': %s %d (%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@
CONST	SEGMENT
??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@ DB 'ID:%s CharID:%s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@
CONST	SEGMENT
??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [Sell Item] (%s)(%s) Item(%s) Pos(%'
	DB	'd)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@
CONST	SEGMENT
??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@ DB '['
	DB	'%s][%s] CGSellRequestRecv() Failed : Transaction == 1, IF_TYP'
	DB	'E : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@
CONST	SEGMENT
??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@ DB '['
	DB	'%s][%s] (%d) Shop buy [%d][%d][%d][%s] LEV:%d, DUR:%d, OP:[%d'
	DB	'][%d][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FPLNFNIC@You?5have?5no?5enough?5empty?5space?$AA@
CONST	SEGMENT
??_C@_0BP@FPLNFNIC@You?5have?5no?5enough?5empty?5space?$AA@ DB 'You have '
	DB	'no enough empty space', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@ONDPGNEF@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5item?5has?5been?5purchase@
CONST	SEGMENT
??_C@_0DP@ONDPGNEF@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5item?5has?5been?5purchase@ DB '['
	DB	'%s] [%s] item has been purchased (%s, price: %d), balance: %d'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MFLOOBGJ@Item?5has?5been?5purchased?0?5balance@
CONST	SEGMENT
??_C@_0CF@MFLOOBGJ@Item?5has?5been?5purchased?0?5balance@ DB 'Item has be'
	DB	'en purchased, balance: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@
CONST	SEGMENT
??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@ DB '['
	DB	'%s][%s] Open Chaos Box', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
CONST	SEGMENT
??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@ DB '['
	DB	'%s][%s] is Already Opening PShop, ChaosBox Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@
CONST	SEGMENT
??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@ DB '['
	DB	'ANTI-HACK][NPC Talk] Couldn''t talk.. (%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@
CONST	SEGMENT
??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@ DB 'Pay WareHo'
	DB	'use Money(In WareHouse) : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@
CONST	SEGMENT
??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@ DB 'Pay WareHo'
	DB	'use Money(In Inventory) : %d - %d = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@
CONST	SEGMENT
??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@ DB '['
	DB	'%s][%s] error-L1 : used not Trade', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@
CONST	SEGMENT
??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@ DB '['
	DB	'%s][%s] error-L1 : used not Warehouse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLNEHHDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5Elemental?5Mi@
CONST	SEGMENT
??_C@_0CF@GLNEHHDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5Elemental?5Mi@ DB '['
	DB	'%s][%s] error-L3 : Elemental Mixing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LHICMFIE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5LuckyItem?5Mi@
CONST	SEGMENT
??_C@_0CF@LHICMFIE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5LuckyItem?5Mi@ DB '['
	DB	'%s][%s] error-L3 : LuckyItem Mixing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@
CONST	SEGMENT
??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@ DB '['
	DB	'%s][%s] error-L3 : SocketItem Mixing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@
CONST	SEGMENT
??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@ DB '['
	DB	'%s][%s] error-L3 : JewelOfHarmony Mixing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@
CONST	SEGMENT
??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ DB '['
	DB	'%s][%s] error-L1 : used not ChaosBox', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@
CONST	SEGMENT
??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@ DB '['
	DB	'%s][%s] error-L3 : DarkTrainerBoxMixing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@
CONST	SEGMENT
??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@ DB '['
	DB	'%s][%s] error-L1 : used not DarkTrainerBox', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@
CONST	SEGMENT
??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@ DB '['
	DB	'%s][%s] error-L3 : CBMixing', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@
CONST	SEGMENT
??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@ DB '['
	DB	'%s][%s] error-L1 : used not Chaosbox', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@
CONST	SEGMENT
??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@ DB '[%s][%d'
	DB	'] error-L3', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@KAEBPCMA@?$FLSnakeBegins?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5t@
CONST	SEGMENT
??_C@_0CP@KAEBPCMA@?$FLSnakeBegins?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5t@ DB '['
	DB	'SnakeBegins] [%s][%s] Success to create Snake', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@
CONST	SEGMENT
??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@ DB '['
	DB	'Kalima] [%s][%s] Success to Make Kalima Gate (Lost Kalima Map'
	DB	' Serial:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Event ZenDrop : %d : (%d)('
	DB	'%d/%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@LPMBPPDG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0EM@LPMBPPDG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Throw Surprise Treasure Bo'
	DB	'x - serial:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@PDKMNGPH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0ED@PDKMNGPH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Throw Crystal (%d) - seria'
	DB	'l:%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@GOMPGJDH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
CONST	SEGMENT
??_C@_0FC@GOMPGJDH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@ DB '['
	DB	'Hidden TreasureBox Event] [%s][%s] Throw Mysterious Bead : Dr'
	DB	'op (%d) - serial:%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@HPFBFIFH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Fireworks@
CONST	SEGMENT
??_C@_0EM@HPFBFIFH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Fireworks@ DB '['
	DB	'%s][%s][%d]%d/%d Used Fireworks:%u (%s:%d/level:%d/skill:%d/o'
	DB	'p2:%d/op3:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@
CONST	SEGMENT
??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [ItemDrop] (%s)(%s) Item(%s) Pos(%d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGCMBJDA@Item?$AA@
CONST	SEGMENT
??_C@_04BGCMBJDA@Item?$AA@ DB 'Item', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@ DB 'error:%s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@
CONST	SEGMENT
??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@ DB '['
	DB	'%s][%s] CGItemDropRequest() Failed : Transaction == 1, IF_TYP'
	DB	'E : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@
CONST	SEGMENT
??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@ DB '['
	DB	'ANTI-HACK][Item Duplication] - Item Drop during MapServer Mov'
	DB	'e [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@IHPJKMLA@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@
CONST	SEGMENT
??_C@_0EO@IHPJKMLA@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@ DB '['
	DB	'Illusion Temple] (%d) (Account:%s, Name:%s) picked up Relics '
	DB	'Item(serial:%u)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
CONST	SEGMENT
??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@ DB '['
	DB	'Blood Castle] (%d) (Account:%s, Name:%s) picked up Angel King'
	DB	'''s Weapon (%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EMLONCAM@?$FLAcheron?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Spirit?5M@
CONST	SEGMENT
??_C@_0DF@EMLONCAM@?$FLAcheron?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Spirit?5M@ DB '['
	DB	'Acheron] [%s][%s] Make Spirit Map (Left Old Map:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@KBMFDFFG@?$FLImperialGuardianFort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0EJ@KBMFDFFG@?$FLImperialGuardianFort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'ImperialGuardianFort] [%s][%s] Make Imperial Letter (Left Old'
	DB	' Paper:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@MPCKANHC@?$FLDoppelganger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dim@
CONST	SEGMENT
??_C@_0EH@MPCKANHC@?$FLDoppelganger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dim@ DB '['
	DB	'Doppelganger] [%s][%s] Make Dimension Mirror (Left Dimension '
	DB	'Mark:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@
CONST	SEGMENT
??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@ DB '['
	DB	'Kalima] [%s][%s] Make Lost Kalima Map (Left Kundun Mark:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@
CONST	SEGMENT
??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@ DB '[ Ch'
	DB	'angeRing ] Too many have ChangeRing [%s][%s] ( Name:%s, Count'
	DB	':%d )', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@
CONST	SEGMENT
??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@ DB '[ Moon'
	DB	'StonePendant ] Too many have MoonStonePendant [%s][%s] ( Name'
	DB	':%s, Count:%d )', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@
CONST	SEGMENT
??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@ DB '[Ring'
	DB	' Event] Too many have Magician''s Ring [%s][%s] (Name:%s, Cou'
	DB	'nt:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@
CONST	SEGMENT
??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@ DB '['
	DB	'%s][%s] CGItemGetRequest() Failed : Transaction == 1, IF_TYPE'
	DB	' : %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
CONST	SEGMENT
??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@ DB '['
	DB	'Fix Inv.Ptr] False Location - %s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'O'
	DB	'ption Send %d %d %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@ DB 'O'
	DB	'ption Recv %d %d %d %d %d %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@
CONST	SEGMENT
??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@ DB 'Character'
	DB	' delete : %s,%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
CONST	SEGMENT
??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ DB '[A'
	DB	'nti-HACK][CGPCharDel] Attempted Character Delete during Preve'
	DB	'nted Time. [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
CONST	SEGMENT
??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@ DB '[An'
	DB	'ti-HACK][CGPCharDel] Attempted Character Delete during GamePl'
	DB	'ay. [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@
CONST	SEGMENT
??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@ DB 'Character'
	DB	' create : %s,%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@
CONST	SEGMENT
??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@ DB 'error-L1: D'
	DB	'arklord Character create error [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@
CONST	SEGMENT
??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@ DB 'error-L1: M'
	DB	'agumsa Character create error [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NJBNDAEI@?$FL?$CFs?$FN?5Create?5character?5error?5?$CIReq@
CONST	SEGMENT
??_C@_0DN@NJBNDAEI@?$FL?$CFs?$FN?5Create?5character?5error?5?$CIReq@ DB '['
	DB	'%s] Create character error (ReqLevel: %d, AccountLevel: %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LCMJGFID@Character?5creation?5is?5disabled?$CB?$AA@
CONST	SEGMENT
??_C@_0CA@LCMJGFID@Character?5creation?5is?5disabled?$CB?$AA@ DB 'Charact'
	DB	'er creation is disabled!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@
CONST	SEGMENT
??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@ DB '[A'
	DB	'nti-HACK][CGPCharacterCreate] Attempted Character Create duri'
	DB	'ng GamePlay. [%s][%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@
CONST	SEGMENT
??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@ DB 'e'
	DB	'rror-L1 : HackCheck [%s][%s] 0x%x 0x%x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@ DB '['
	DB	'UserSelClose] Go CharSelect [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@
CONST	SEGMENT
??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@ DB '['
	DB	'UserSelClose] Go ServerList [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
CONST	SEGMENT
??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@ DB '['
	DB	'UserSelClose] Go Exit [%s][%s] Map:[%d][%d/%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@ DB 'login send : %s'
	DB	' %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04FLFDNKBN@m321?$AA@
CONST	SEGMENT
??_C@_04FLFDNKBN@m321?$AA@ DB 'm321', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@
CONST	SEGMENT
??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@ DB 0bdH, 0b8H, 0b5H, 0b9H
	DB	0c0H, 0ccH, '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@ DB 'join send '
	DB	': (%d)%s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@ DB 'error : %d %s '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@ DB 'e'
	DB	'rror-L1: Serial error [%s] [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KJGOCGNH@Need?5more?5zen?5for?5gens?5chat?$AA@
CONST	SEGMENT
??_C@_0BM@KJGOCGNH@Need?5more?5zen?5for?5gens?5chat?$AA@ DB 'Need more ze'
	DB	'n for gens chat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOFCDDNP@?1post?5?$CFs?$AA@
CONST	SEGMENT
??_C@_08IOFCDDNP@?1post?5?$CFs?$AA@ DB '/post %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FKJLBJJB@Incorrect?5syntax?$AA@
CONST	SEGMENT
??_C@_0BB@FKJLBJJB@Incorrect?5syntax?$AA@ DB 'Incorrect syntax', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@
CONST	SEGMENT
??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@ DB '['
	DB	'Anti-HACK][PChatProc][%s][%s] Chat Message Len : %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@
CONST	SEGMENT
??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@ DB '['
	DB	'%s][%s][%s] ClientHack Detected : Editing AttackSpeed [%d][%d'
	DB	'] [%d][%d]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@
CONST	SEGMENT
??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@ DB 'TEST Data Send', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@
CONST	SEGMENT
??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@ DB 'er'
	DB	'ror-L2 : account:%s name:%s HEAD:%x (%s,%d) State:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
CONST	SEGMENT
??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@ DB 'protocol.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BJHJAKKO@?$FL0xBF?$FN?5Unknown?5packet?5BF?3?$CFd?$AA@
CONST	SEGMENT
??_C@_0BM@BJHJAKKO@?$FL0xBF?$FN?5Unknown?5packet?5BF?3?$CFd?$AA@ DB '[0xB'
	DB	'F] Unknown packet BF:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HMJAEILC@1111111111?$AA@
CONST	SEGMENT
??_C@_0L@HMJAEILC@1111111111?$AA@ DB '1111111111', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@
CONST	SEGMENT
??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@ DB 'Er'
	DB	'ror-L1 : Socket Serial %s %d o_serial:%d serial:%d ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@ DB 'Err'
	DB	'or-L1 : Not Encrypt %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GDHHDJMO@Credits?$AA@
CONST	SEGMENT
??_C@_07GDHHDJMO@Credits?$AA@ DB 'Credits', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BDDJAJFG@?4?2Log?2Credits?$AA@
CONST	SEGMENT
??_C@_0O@BDDJAJFG@?4?2Log?2Credits?$AA@ DB '.\Log\Credits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_CS_NPC_DATA@@6B@
CONST	SEGMENT
??_7_CS_NPC_DATA@@6B@ DD FLAT:??_R4_CS_NPC_DATA@@6B@	; _CS_NPC_DATA::`vftable'
	DD	FLAT:??_E_CS_NPC_DATA@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@ DB 'QeustNpc R'
	DB	'efCount Dec= %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM?$AA@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM?$AA@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ$0
__ehfuncinfo$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$1
__ehfuncinfo$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z$0
__ehfuncinfo$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffff14H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN175@CGPShopReq
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$129 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$128 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$128
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$129
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsNotifyProgress@@YAXHEPBD@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_btCastleSiegeState$ = 12				; size = 1
_lpszGuildName$ = 16					; size = 4
?GCAnsCsNotifyProgress@@YAXHEPBD@Z PROC			; GCAnsCsNotifyProgress, COMDAT

; 19049: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _lpszGuildName$[ebp]

; 19050: 	if ( lpszGuildName == NULL )

  00013	85 c9		 test	 ecx, ecx
  00015	74 35		 je	 SHORT $LN1@GCAnsCsNot

; 19051: 		return;
; 19052: 
; 19053: 	PMSG_ANS_NOTIFYCSPROGRESS pMsgResult;
; 19054: 
; 19055: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x18, sizeof(pMsgResult));
; 19056: 	pMsgResult.btCastleSiegeState = btCastleSiegeState;

  00017	8a 45 0c	 mov	 al, BYTE PTR _btCastleSiegeState$[ebp]
  0001a	0f 57 c0	 xorps	 xmm0, xmm0
  0001d	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 141  : 		lpBuf[1] = size;

  00020	b2 0d		 mov	 dl, 13			; 0000000dH
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19058: 	memcpy(pMsgResult.szGuildName, lpszGuildName, sizeof(pMsgResult.szGuildName));

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	66 0f d6 45 f1	 movq	 QWORD PTR _pMsgResult$[ebp+5], xmm0
  00029	89 45 f1	 mov	 DWORD PTR _pMsgResult$[ebp+5], eax
  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	89 45 f5	 mov	 DWORD PTR _pMsgResult$[ebp+9], eax

; 19060: 	DataSend(iIndex, (UCHAR*)&pMsgResult, pMsgResult.h.size);

  00032	0f b6 c2	 movzx	 eax, dl
  00035	50		 push	 eax
  00036	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00039	c7 45 ec c1 0d
	b2 18		 mov	 DWORD PTR _pMsgResult$[ebp], 414322113 ; 18b20dc1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19060: 	DataSend(iIndex, (UCHAR*)&pMsgResult, pMsgResult.h.size);

  00040	50		 push	 eax
  00041	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00044	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCAnsCsNot:

; 19061: }

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004f	33 cd		 xor	 ecx, ebp
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?GCAnsCsNotifyProgress@@YAXHEPBD@Z ENDP			; GCAnsCsNotifyProgress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 1850 :     )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	68 00 01 00 00	 push	 256			; 00000100H
  00011	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00014	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	ff 30		 push	 DWORD PTR [eax]
  0001e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1499 : }
; 1500 : #endif
; 1501 : 
; 1502 : #if __STDC_WANT_SECURE_LIB__
; 1503 : 
; 1504 :     _Success_(return >= 0)
; 1505 :     _Check_return_opt_
; 1506 :     _CRT_STDIO_INLINE int __CRTDECL vsprintf_s(
; 1507 :         _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1508 :         _In_                          size_t      const _BufferCount,
; 1509 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1510 :                                       va_list           _ArgList
; 1511 :         )
; 1512 : #if defined _NO_CRT_STDIO_INLINE
; 1513 : ;
; 1514 : #else
; 1515 :     {
; 1516 :         return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1517 :     }
; 1518 : #endif
; 1519 :     
; 1520 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
; 1521 :         _Success_(return >= 0)
; 1522 :         int, vsprintf_s,
; 1523 :         _Post_z_                      char,        _Buffer,
; 1524 :         _In_z_ _Printf_format_string_ char const*, _Format,
; 1525 :                                       va_list,     _ArgList
; 1526 :         )
; 1527 : 
; 1528 : #endif
; 1529 : 
; 1530 : _Success_(return >= 0)
; 1531 : _Check_return_opt_
; 1532 : _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p_l(
; 1533 :     _Out_writes_z_(_BufferCount)            char*       const _Buffer,
; 1534 :     _In_                                    size_t      const _BufferCount,
; 1535 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1536 :     _In_opt_                                _locale_t   const _Locale,
; 1537 :                                             va_list           _ArgList
; 1538 :     )
; 1539 : #if defined _NO_CRT_STDIO_INLINE
; 1540 : ;
; 1541 : #else
; 1542 : {
; 1543 :     int const _Result = __stdio_common_vsprintf_p(
; 1544 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1545 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1546 : 
; 1547 :     return _Result < 0 ? -1 : _Result;
; 1548 : }
; 1549 : #endif
; 1550 : 
; 1551 : _Success_(return >= 0)
; 1552 : _Check_return_opt_
; 1553 : _CRT_STDIO_INLINE int __CRTDECL _vsprintf_p(
; 1554 :     _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1555 :     _In_                          size_t      const _BufferCount,
; 1556 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1557 :                                   va_list           _ArgList
; 1558 :     )
; 1559 : #if defined _NO_CRT_STDIO_INLINE
; 1560 : ;
; 1561 : #else
; 1562 : {
; 1563 :     return _vsprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1564 : }
; 1565 : #endif
; 1566 : 
; 1567 : _Success_(return >= 0)
; 1568 : _Check_return_opt_
; 1569 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s_l(
; 1570 :     _Out_writes_z_(_BufferCount)            char*       const _Buffer,
; 1571 :     _In_                                    size_t      const _BufferCount,
; 1572 :     _In_                                    size_t      const _MaxCount,
; 1573 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1574 :     _In_opt_                                _locale_t   const _Locale,
; 1575 :                                             va_list          _ArgList
; 1576 :     )
; 1577 : #if defined _NO_CRT_STDIO_INLINE
; 1578 : ;
; 1579 : #else
; 1580 : {
; 1581 :     int const _Result = __stdio_common_vsnprintf_s(
; 1582 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1583 :         _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1584 : 
; 1585 :     return _Result < 0 ? -1 : _Result;
; 1586 : }
; 1587 : #endif
; 1588 : 
; 1589 : _Success_(return >= 0)
; 1590 : _Check_return_opt_
; 1591 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s(
; 1592 :     _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1593 :     _In_                          size_t      const _BufferCount,
; 1594 :     _In_                          size_t      const _MaxCount,
; 1595 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1596 :                                   va_list           _ArgList
; 1597 :     )
; 1598 : #if defined _NO_CRT_STDIO_INLINE
; 1599 : ;
; 1600 : #else
; 1601 : {
; 1602 :     return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1603 : }
; 1604 : #endif
; 1605 : 
; 1606 : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
; 1607 :     _Success_(return >= 0)
; 1608 :     int, _vsnprintf_s,
; 1609 :     _Post_z_                      char,        _Buffer,
; 1610 :     _In_                          size_t,      _BufferCount,
; 1611 :     _In_z_ _Printf_format_string_ char const*, _Format,
; 1612 :                                   va_list,     _ArgList
; 1613 :     )
; 1614 : 
; 1615 : #if __STDC_WANT_SECURE_LIB__
; 1616 : 
; 1617 :     _Success_(return >= 0)
; 1618 :     _Check_return_opt_
; 1619 :     _CRT_STDIO_INLINE int __CRTDECL vsnprintf_s(
; 1620 :         _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1621 :         _In_                          size_t      const _BufferCount,
; 1622 :         _In_                          size_t      const _MaxCount,
; 1623 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1624 :                                       va_list           _ArgList
; 1625 :         )
; 1626 : #if defined _NO_CRT_STDIO_INLINE
; 1627 : ;
; 1628 : #else
; 1629 :     {
; 1630 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1631 :     }
; 1632 : #endif
; 1633 :     
; 1634 :     __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
; 1635 :         _Success_(return >= 0)
; 1636 :         int, vsnprintf_s,
; 1637 :         _Post_z_                      char,        _Buffer,
; 1638 :         _In_                          size_t,      _BufferCount,
; 1639 :         _In_z_ _Printf_format_string_ char const*, _Format,
; 1640 :                                       va_list,     _ArgList
; 1641 :         )
; 1642 : 
; 1643 : #endif
; 1644 : 
; 1645 : _Check_return_opt_
; 1646 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf_l(
; 1647 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1648 :     _In_opt_                                _locale_t   const _Locale,
; 1649 :                                             va_list           _ArgList
; 1650 :     )
; 1651 : #if defined _NO_CRT_STDIO_INLINE
; 1652 : ;
; 1653 : #else
; 1654 : {
; 1655 :     int const _Result = __stdio_common_vsprintf(
; 1656 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1657 :         NULL, 0, _Format, _Locale, _ArgList);
; 1658 : 
; 1659 :     return _Result < 0 ? -1 : _Result;
; 1660 : }
; 1661 : #endif
; 1662 : 
; 1663 : _Check_return_
; 1664 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf(
; 1665 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1666 :                                   va_list           _ArgList
; 1667 :     )
; 1668 : #if defined _NO_CRT_STDIO_INLINE
; 1669 : ;
; 1670 : #else
; 1671 : {
; 1672 :     return _vscprintf_l(_Format, NULL, _ArgList);
; 1673 : }
; 1674 : #endif
; 1675 : 
; 1676 : _Check_return_opt_
; 1677 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p_l(
; 1678 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1679 :     _In_opt_                                _locale_t   const _Locale,
; 1680 :                                             va_list           _ArgList
; 1681 :     )
; 1682 : #if defined _NO_CRT_STDIO_INLINE
; 1683 : ;
; 1684 : #else
; 1685 : {
; 1686 :     int const _Result = __stdio_common_vsprintf_p(
; 1687 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1688 :         NULL, 0, _Format, _Locale, _ArgList);
; 1689 : 
; 1690 :     return _Result < 0 ? -1 : _Result;
; 1691 : }
; 1692 : #endif
; 1693 : 
; 1694 : _Check_return_
; 1695 : _CRT_STDIO_INLINE int __CRTDECL _vscprintf_p(
; 1696 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1697 :                                   va_list           _ArgList
; 1698 :     )
; 1699 : #if defined _NO_CRT_STDIO_INLINE
; 1700 : ;
; 1701 : #else
; 1702 : {
; 1703 :     return _vscprintf_p_l(_Format, NULL, _ArgList);
; 1704 : }
; 1705 : #endif
; 1706 : 
; 1707 : _Check_return_opt_
; 1708 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c_l(
; 1709 :     _Out_writes_(_BufferCount)              char*       const _Buffer,
; 1710 :     _In_                                    size_t      const _BufferCount,
; 1711 :     _In_z_ _Printf_format_string_params_(2) char const* const _Format,
; 1712 :     _In_opt_                                _locale_t   const _Locale,
; 1713 :                                             va_list           _ArgList
; 1714 :     )
; 1715 : #if defined _NO_CRT_STDIO_INLINE
; 1716 : ;
; 1717 : #else
; 1718 : {
; 1719 :     int const _Result = __stdio_common_vsprintf(
; 1720 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1721 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1722 : 
; 1723 :     return _Result < 0 ? -1 : _Result;
; 1724 : }
; 1725 : #endif
; 1726 : 
; 1727 : _Success_(return >= 0)
; 1728 : _Check_return_opt_
; 1729 : _CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c(
; 1730 :     _Out_writes_(_BufferCount)    char*       const _Buffer,
; 1731 :     _In_                          size_t      const _BufferCount,
; 1732 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1733 :                                   va_list           _ArgList
; 1734 :     )
; 1735 : #if defined _NO_CRT_STDIO_INLINE
; 1736 : ;
; 1737 : #else
; 1738 : {
; 1739 :     return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1740 : }
; 1741 : #endif
; 1742 : 
; 1743 : _Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sprintf_s_l)
; 1744 : _CRT_STDIO_INLINE int __CRTDECL _sprintf_l(
; 1745 :     _Pre_notnull_ _Post_z_                  char*       const _Buffer,
; 1746 :     _In_z_ _Printf_format_string_params_(0) char const* const _Format,
; 1747 :     _In_opt_                                _locale_t   const _Locale,
; 1748 :     ...)
; 1749 : #if defined _NO_CRT_STDIO_INLINE
; 1750 : ;
; 1751 : #else
; 1752 : {
; 1753 :     int _Result;
; 1754 :     va_list _ArgList;
; 1755 :     __crt_va_start(_ArgList, _Locale);
; 1756 : 
; 1757 :     #pragma warning(push)
; 1758 :     #pragma warning(disable: 4996) // Deprecation
; 1759 :     _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
; 1760 :     #pragma warning(pop)
; 1761 : 
; 1762 :     __crt_va_end(_ArgList);
; 1763 :     return _Result;
; 1764 : }
; 1765 : #endif
; 1766 : 
; 1767 : _Success_(return >= 0)
; 1768 : _Check_return_opt_
; 1769 : _CRT_STDIO_INLINE int __CRTDECL sprintf(
; 1770 :     _Pre_notnull_ _Post_z_        char*       const _Buffer,
; 1771 :     _In_z_ _Printf_format_string_ char const* const _Format,
; 1772 :     ...)
; 1773 : #if defined _NO_CRT_STDIO_INLINE
; 1774 : ;
; 1775 : #else
; 1776 : {
; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }
; 1789 : #endif
; 1790 : 
; 1791 : #pragma warning(push)
; 1792 : #pragma warning(disable: 4996)
; 1793 : __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(
; 1794 :     _Success_(return >= 0)
; 1795 :     int, __RETURN_POLICY_SAME, __EMPTY_DECLSPEC, __CRTDECL, sprintf, vsprintf,
; 1796 :     _Pre_notnull_ _Post_z_,       char,        _Buffer,
; 1797 :     _In_z_ _Printf_format_string_ char const*, _Format
; 1798 :     )
; 1799 : #pragma warning(pop)
; 1800 : 
; 1801 : _Success_(return >= 0)
; 1802 : _Check_return_opt_
; 1803 : _CRT_STDIO_INLINE int __CRTDECL _sprintf_s_l(
; 1804 :     _Out_writes_z_(_BufferCount)            char*       const _Buffer,
; 1805 :     _In_                                    size_t      const _BufferCount,
; 1806 :     _In_z_ _Printf_format_string_params_(0) char const* const _Format,
; 1807 :     _In_opt_                                _locale_t   const _Locale,
; 1808 :     ...)
; 1809 : #if defined _NO_CRT_STDIO_INLINE
; 1810 : ;
; 1811 : #else
; 1812 : {
; 1813 :     int _Result;
; 1814 :     va_list _ArgList;
; 1815 :     __crt_va_start(_ArgList, _Locale);
; 1816 :     _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1817 :     __crt_va_end(_ArgList);
; 1818 :     return _Result;
; 1819 : }
; 1820 : #endif
; 1821 : 
; 1822 : #if __STDC_WANT_SECURE_LIB__
; 1823 : 
; 1824 :     _Success_(return >= 0)
; 1825 :     _Check_return_opt_
; 1826 :     _CRT_STDIO_INLINE int __CRTDECL sprintf_s(
; 1827 :         _Out_writes_z_(_BufferCount)  char*       const _Buffer,
; 1828 :         _In_                          size_t      const _BufferCount,
; 1829 :         _In_z_ _Printf_format_string_ char const* const _Format,
; 1830 :         ...)
; 1831 : #if defined _NO_CRT_STDIO_INLINE
; 1832 : ;
; 1833 : #else
; 1834 :     {
; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);
; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1839 :         __crt_va_end(_ArgList);
; 1840 :         return _Result;
; 1841 :     }
; 1842 : #endif
; 1843 : 
; 1844 : #endif
; 1845 : 
; 1846 : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?DataEncryptCheck@@YAHHEH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_protoNum$ = 12						; size = 1
_Encrypt$ = 16						; size = 4
?DataEncryptCheck@@YAHHEH@Z PROC			; DataEncryptCheck, COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 133  : 	if ( Encrypt == FALSE )

  00003	83 7d 10 00	 cmp	 DWORD PTR _Encrypt$[ebp], 0
  00007	75 33		 jne	 SHORT $LN2@DataEncryp

; 134  : 	{
; 135  : 		LogAdd("Error-L1 : Not Encrypt %s %d", gObj[aIndex].AccountID, protoNum);

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _protoNum$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00011	50		 push	 eax
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00017	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0001d	83 c0 52	 add	 eax, 82			; 00000052H
  00020	03 c1		 add	 eax, ecx
  00022	50		 push	 eax
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LAHEKONH@Error?9L1?5?3?5Not?5Encrypt?5?$CFs?5?$CFd?$AA@
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 136  : 		CloseClient(aIndex);

  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 137  : 		return FALSE;

  00037	33 c0		 xor	 eax, eax
  00039	5e		 pop	 esi

; 141  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN2@DataEncryp:

; 138  : 	}
; 139  : 
; 140  : 	return TRUE;

  0003c	b8 01 00 00 00	 mov	 eax, 1

; 141  : }

  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?DataEncryptCheck@@YAHHEH@Z ENDP			; DataEncryptCheck
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_CreditLog@@YAXXZ
text$yd	SEGMENT
??__Fg_CreditLog@@YAXXZ PROC				; `dynamic atexit destructor for 'g_CreditLog'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CreditLog@@3VCLogToFile@@A ; g_CreditLog
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__Fg_CreditLog@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_CreditLog''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ??__Eg_CreditLog@@YAXXZ
text$di	SEGMENT
??__Eg_CreditLog@@YAXXZ PROC				; `dynamic initializer for 'g_CreditLog'', COMDAT

; 108  : CLogToFile g_CreditLog(LOG_NAME_CREDITS, LOG_PATH_CREDITS, TRUE);

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BDDJAJFG@?4?2Log?2Credits?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_07GDHHDJMO@Credits?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CreditLog@@3VCLogToFile@@A ; g_CreditLog
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__Fg_CreditLog@@YAXXZ ; `dynamic atexit destructor for 'g_CreditLog''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__Eg_CreditLog@@YAXXZ ENDP				; `dynamic initializer for 'g_CreditLog''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\monsterspawner.h
;	COMDAT ?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?getInstance@MonsterSpawnerMng@@SAPAV1@XZ PROC		; MonsterSpawnerMng::getInstance, COMDAT

; 137  : 	static MonsterSpawnerMng* getInstance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 138  : 		if (m_Instance == NULL) {

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A ; MonsterSpawnerMng::m_Instance
  00028	85 c0		 test	 eax, eax
  0002a	75 3a		 jne	 SHORT $LN2@getInstanc

; 139  : 			m_Instance = new MonsterSpawnerMng();

  0002c	6a 1c		 push	 28			; 0000001cH
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	85 c0		 test	 eax, eax
  00042	74 1b		 je	 SHORT $LN4@getInstanc
  00044	8b c8		 mov	 ecx, eax
  00046	e8 00 00 00 00	 call	 ??0MonsterSpawnerMng@@QAE@XZ ; MonsterSpawnerMng::MonsterSpawnerMng
  0004b	a3 00 00 00 00	 mov	 DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A, eax ; MonsterSpawnerMng::m_Instance

; 140  : 		}
; 141  : 		return m_Instance;
; 142  : 	}

  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN4@getInstanc:

; 139  : 			m_Instance = new MonsterSpawnerMng();

  0005f	33 c0		 xor	 eax, eax
  00061	a3 00 00 00 00	 mov	 DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A, eax ; MonsterSpawnerMng::m_Instance
$LN2@getInstanc:

; 140  : 		}
; 141  : 		return m_Instance;
; 142  : 	}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ$0:
  00000	6a 1c		 push	 28			; 0000001cH
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getInstance@MonsterSpawnerMng@@SAPAV1@XZ ENDP		; MonsterSpawnerMng::getInstance
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h
;	COMDAT ?IsPKFieldMap@CNewPVP@@QAEHH@Z
_TEXT	SEGMENT
_nMapNumber$ = 8					; size = 4
?IsPKFieldMap@CNewPVP@@QAEHH@Z PROC			; CNewPVP::IsPKFieldMap, COMDAT
; _this$ = ecx

; 312  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		return nMapNumber == MAP_INDEX_PKFIELD;

  00003	33 c0		 xor	 eax, eax
  00005	83 7d 08 40	 cmp	 DWORD PTR _nMapNumber$[ebp], 64 ; 00000040H
  00009	0f 94 c0	 sete	 al

; 314  : 	}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?IsPKFieldMap@CNewPVP@@QAEHH@Z ENDP			; CNewPVP::IsPKFieldMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h
;	COMDAT ?IsVulcanusMap@CNewPVP@@QAEHH@Z
_TEXT	SEGMENT
_nMapNumber$ = 8					; size = 4
?IsVulcanusMap@CNewPVP@@QAEHH@Z PROC			; CNewPVP::IsVulcanusMap, COMDAT
; _this$ = ecx

; 307  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  : 		return nMapNumber == MAP_INDEX_VULCANUS;

  00003	33 c0		 xor	 eax, eax
  00005	83 7d 08 3f	 cmp	 DWORD PTR _nMapNumber$[ebp], 63 ; 0000003fH
  00009	0f 94 c0	 sete	 al

; 309  : 	}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?IsVulcanusMap@CNewPVP@@QAEHH@Z ENDP			; CNewPVP::IsVulcanusMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h
;	COMDAT ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z PROC		; CNewPVP::IsDuel, COMDAT
; _this$ = ecx

; 296  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 297  : 		return CHECK_LIMIT(obj.m_iDuelUser, OBJMAX);

  00003	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00006	8b 88 50 12 00
	00		 mov	 ecx, DWORD PTR [eax+4688]
  0000c	33 c0		 xor	 eax, eax
  0000e	85 c9		 test	 ecx, ecx
  00010	78 09		 js	 SHORT $LN4@IsDuel
  00012	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00018	0f 9e c0	 setle	 al
$LN4@IsDuel:

; 298  : 	}

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ENDP		; CNewPVP::IsDuel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\snakebegins.h
;	COMDAT ?IsScroll@SnakeBegins@@QAE_NG@Z
_TEXT	SEGMENT
_ItemType$ = 8						; size = 2
?IsScroll@SnakeBegins@@QAE_NG@Z PROC			; SnakeBegins::IsScroll, COMDAT
; _this$ = ecx

; 18   : 	bool	IsScroll(WORD ItemType) { return ItemType >= ITEMGET(14, 210) && ItemType <= ITEMGET(14, 213); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _ItemType$[ebp]
  00006	66 b9 03 00	 mov	 cx, 3
  0000a	05 2e e3 ff ff	 add	 eax, -7378		; ffffe32eH
  0000f	66 3b c8	 cmp	 cx, ax
  00012	1b c0		 sbb	 eax, eax
  00014	40		 inc	 eax
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?IsScroll@SnakeBegins@@QAE_NG@Z ENDP			; SnakeBegins::IsScroll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h
;	COMDAT ??_G_CS_NPC_DATA@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_CS_NPC_DATA@@UAEPAXI@Z PROC			; _CS_NPC_DATA::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 75   : 	{

  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_CS_NPC_DATA@@6B@
  00010	74 0b		 je	 SHORT $LN7@scalar
  00012	6a 74		 push	 116			; 00000074H
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN7@scalar:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??_G_CS_NPC_DATA@@UAEPAXI@Z ENDP			; _CS_NPC_DATA::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h
;	COMDAT ?Clear@_CS_NPC_DATA@@QAEXXZ
_TEXT	SEGMENT
?Clear@_CS_NPC_DATA@@QAEXXZ PROC			; _CS_NPC_DATA::Clear, COMDAT
; _this$ = ecx

; 81   : 		m_bIN_USE = 0;

  00000	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 82   : 		m_iNPC_NUM = -1;

  00007	c7 41 08 ff ff
	ff ff		 mov	 DWORD PTR [ecx+8], -1

; 83   : 		m_iNPC_INDEX = -1;

  0000e	c7 41 0c ff ff
	ff ff		 mov	 DWORD PTR [ecx+12], -1

; 84   : 		m_iNPC_LIVE = 0;

  00015	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 85   : 		m_iNPC_AUTH = -1;

  0001c	c7 41 6c ff ff
	ff ff		 mov	 DWORD PTR [ecx+108], -1

; 86   : 		m_bNPC_DBSAVE = 0;

  00023	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 87   : 		m_iNPC_SIDE = 0;

  0002a	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 88   : 		m_iNPC_OBJINDEX = -1;

  00031	c7 41 18 ff ff
	ff ff		 mov	 DWORD PTR [ecx+24], -1

; 89   : 		m_iNPC_DF_LEVEL = 0;

  00038	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 90   : 		m_iNPC_RG_LEVEL = 0;

  0003f	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0

; 91   : 		m_iNPC_MAXHP = 0;

  00046	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 92   : 		m_iNPC_HP = 0;

  0004d	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 93   : 		m_iNPC_SX = -1;

  00054	c7 41 2c ff ff
	ff ff		 mov	 DWORD PTR [ecx+44], -1

; 94   : 		m_iNPC_SY = -1;

  0005b	c7 41 30 ff ff
	ff ff		 mov	 DWORD PTR [ecx+48], -1

; 95   : 		m_iNPC_DX = -1;

  00062	c7 41 34 ff ff
	ff ff		 mov	 DWORD PTR [ecx+52], -1

; 96   : 		m_iNPC_DY = -1;

  00069	c7 41 38 ff ff
	ff ff		 mov	 DWORD PTR [ecx+56], -1

; 97   : 		m_iNPC_DIR = -1;

  00070	c7 41 3c ff ff
	ff ff		 mov	 DWORD PTR [ecx+60], -1

; 98   : 		m_iNPC_BASE_DF_LEVEL = 0;

  00077	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 99   : 		m_iNPC_BASE_RG_LEVEL = 0;

  0007e	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 100  : 		m_iNPC_BASE_MAXHP = 0;

  00085	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0

; 101  : 		m_iNPC_BASE_HP = 0;

  0008c	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0

; 102  : 		m_iNPC_BASE_SX = -1;

  00093	c7 41 50 ff ff
	ff ff		 mov	 DWORD PTR [ecx+80], -1

; 103  : 		m_iNPC_BASE_SY = -1;

  0009a	c7 41 54 ff ff
	ff ff		 mov	 DWORD PTR [ecx+84], -1

; 104  : 		m_iNPC_BASE_DX = -1;

  000a1	c7 41 58 ff ff
	ff ff		 mov	 DWORD PTR [ecx+88], -1

; 105  : 		m_iNPC_BASE_DY = -1;

  000a8	c7 41 5c ff ff
	ff ff		 mov	 DWORD PTR [ecx+92], -1

; 106  : 		m_iNPC_BASE_DIR = -1;

  000af	c7 41 60 ff ff
	ff ff		 mov	 DWORD PTR [ecx+96], -1

; 107  : 		m_iCsNpcExistVal = 0;

  000b6	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], 0

; 108  : 	}

  000bd	c3		 ret	 0
?Clear@_CS_NPC_DATA@@QAEXXZ ENDP			; _CS_NPC_DATA::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h
;	COMDAT ??1_CS_NPC_DATA@@UAE@XZ
_TEXT	SEGMENT
??1_CS_NPC_DATA@@UAE@XZ PROC				; _CS_NPC_DATA::~_CS_NPC_DATA, COMDAT
; _this$ = ecx

; 75   : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_CS_NPC_DATA@@6B@

; 76   : 
; 77   : 	};

  00006	c3		 ret	 0
??1_CS_NPC_DATA@@UAE@XZ ENDP				; _CS_NPC_DATA::~_CS_NPC_DATA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h
;	COMDAT ??0_CS_NPC_DATA@@QAE@XZ
_TEXT	SEGMENT
??0_CS_NPC_DATA@@QAE@XZ PROC				; _CS_NPC_DATA::_CS_NPC_DATA, COMDAT
; _this$ = ecx

; 68   : 	_CS_NPC_DATA()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 69   : 	{

  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7_CS_NPC_DATA@@6B@

; 70   : 		Clear();

  00009	e8 00 00 00 00	 call	 ?Clear@_CS_NPC_DATA@@QAEXXZ ; _CS_NPC_DATA::Clear

; 71   : 		m_iCS_GATE_LEVER_INDEX = -1;

  0000e	c7 46 64 ff ff
	ff ff		 mov	 DWORD PTR [esi+100], -1

; 72   : 	};

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	c3		 ret	 0
??0_CS_NPC_DATA@@QAE@XZ ENDP				; _CS_NPC_DATA::_CS_NPC_DATA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
;	COMDAT ?GetMapSvrGroup@CMapServerManager@@QAEHXZ
_TEXT	SEGMENT
?GetMapSvrGroup@CMapServerManager@@QAEHXZ PROC		; CMapServerManager::GetMapSvrGroup, COMDAT
; _this$ = ecx

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  00000	8b 81 f8 6a 01
	00		 mov	 eax, DWORD PTR [ecx+92920]
  00006	85 c0		 test	 eax, eax
  00008	74 05		 je	 SHORT $LN2@GetMapSvrG

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  0000a	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]

; 60   : 	}

  0000e	c3		 ret	 0
$LN2@GetMapSvrG:

; 58   : 		}
; 59   : 		return -1;

  0000f	83 c8 ff	 or	 eax, -1

; 60   : 	}

  00012	c3		 ret	 0
?GetMapSvrGroup@CMapServerManager@@QAEHXZ ENDP		; CMapServerManager::GetMapSvrGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\devilsquare.h
;	COMDAT ?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ
_TEXT	SEGMENT
?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ PROC ; CDevilSquare::GetState, COMDAT
; _this$ = ecx

; 46   : 	enum eDevilSquareState GetState(){return this->m_eState;};	// line : 93

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetState@CDevilSquare@@QAE?AW4eDevilSquareState@@XZ ENDP ; CDevilSquare::GetState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\gobjmonster.h
;	COMDAT ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ
_TEXT	SEGMENT
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ PROC		; CQeustNpcTeleport::TalkRefDel, COMDAT
; _this$ = ecx

; 75   : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 76   : 		EnterCriticalSection(&this->CsRef);

  00004	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00007	57		 push	 edi
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 77   : 		this->RefCount--;

  0000e	83 06 ff	 add	 DWORD PTR [esi], -1

; 78   : 
; 79   : 		if ( this->RefCount < 0 )

  00011	79 06		 jns	 SHORT $LN2@TalkRefDel

; 80   : 		{
; 81   : 			this->RefCount = 0;

  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN2@TalkRefDel:

; 82   : 		}
; 83   : 		
; 84   : 		LogAdd("QeustNpc RefCount Dec= %d", this->RefCount);

  00019	ff 36		 push	 DWORD PTR [esi]
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd?$AA@
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00026	83 c4 08	 add	 esp, 8

; 85   : 		LeaveCriticalSection(&this->CsRef);

  00029	57		 push	 edi
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi

; 86   : 	};	// line : 135

  00032	c3		 ret	 0
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ENDP		; CQeustNpcTeleport::TalkRefDel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiegesync.h
;	COMDAT ?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ
_TEXT	SEGMENT
?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ PROC	; CCastleSiegeSync::GetCastleOwnerGuild, COMDAT
; _this$ = ecx

; 36   : 	LPSTR GetCastleOwnerGuild(){return this->m_szCastleOwnerGuild;};	// line : 85

  00000	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetCastleOwnerGuild@CCastleSiegeSync@@QAEPADXZ ENDP	; CCastleSiegeSync::GetCastleOwnerGuild
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\castlesiegesync.h
;	COMDAT ?GetCastleState@CCastleSiegeSync@@QAEHXZ
_TEXT	SEGMENT
?GetCastleState@CCastleSiegeSync@@QAEHXZ PROC		; CCastleSiegeSync::GetCastleState, COMDAT
; _this$ = ecx

; 34   : 	int  GetCastleState(){return this->m_iCurCastleState;};	// line : 70

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetCastleState@CCastleSiegeSync@@QAEHXZ ENDP		; CCastleSiegeSync::GetCastleState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\questinfo.h
;	COMDAT ?GetQeustCount@CQuestInfo@@QAEHXZ
_TEXT	SEGMENT
?GetQeustCount@CQuestInfo@@QAEHXZ PROC			; CQuestInfo::GetQeustCount, COMDAT
; _this$ = ecx

; 84   : 	int GetQeustCount(){return m_QuestCount;}

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetQeustCount@CQuestInfo@@QAEHXZ ENDP			; CQuestInfo::GetQeustCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_lpMsg$ = 8						; size = 4
tv477 = 12						; size = 4
_iIndex$ = 12						; size = 4
?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z PROC ; CGInventoryEquipment, COMDAT

; 20425: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 20426: 	if( !OBJMAX_RANGE(iIndex) )

  00007	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	0f 88 e4 01 00
	00		 js	 $LN1@CGInventor
  00012	33 c0		 xor	 eax, eax
  00014	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 d1 01 00
	00		 je	 $LN1@CGInventor

; 20427: 	{
; 20428: 		return;
; 20429: 	}
; 20430: 	// ----
; 20431: 	LPOBJ lpObj = &gObj[iIndex];

  00025	57		 push	 edi
  00026	69 fe 40 27 00
	00		 imul	 edi, esi, 10048

; 20432: 	// ----
; 20433: 	if( !gObjIsConnected(iIndex) )

  0002c	56		 push	 esi
  0002d	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00038	83 c4 04	 add	 esp, 4
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 b2 01 00
	00		 je	 $LN34@CGInventor

; 20434: 	{
; 20435: 		return;
; 20436: 	}
; 20437: 	// ----
; 20438: 	_tagPMSG_ANS_INVENTORY_EQUIPMENT_ITEM pMsg = { 0 };
; 20439: 	pMsg.btResult = 0;
; 20440: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x20, sizeof(_tagPMSG_ANS_INVENTORY_EQUIPMENT_ITEM));

  00043	53		 push	 ebx
  00044	6a 06		 push	 6
  00046	6a 20		 push	 32			; 00000020H
  00048	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004b	c6 45 fd 00	 mov	 BYTE PTR _pMsg$[ebp+5], 0
  0004f	68 bf 00 00 00	 push	 191			; 000000bfH
  00054	50		 push	 eax
  00055	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00059	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
  00060	c6 45 fd 00	 mov	 BYTE PTR _pMsg$[ebp+5], 0
  00064	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 20441: 	pMsg.btItemPos = lpMsg->btItemPos;

  00069	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0006c	83 c4 10	 add	 esp, 16			; 00000010H
  0006f	8a 59 04	 mov	 bl, BYTE PTR [ecx+4]

; 20442: 	// ----
; 20443: 	if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 0.0 )

  00072	0f b6 c3	 movzx	 eax, bl
  00075	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  0007b	88 5d fc	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  0007e	8b 97 c0 11 00
	00		 mov	 edx, DWORD PTR [edi+4544]
  00084	89 45 0c	 mov	 DWORD PTR tv477[ebp], eax
  00087	f3 0f 10 44 10
	24		 movss	 xmm0, DWORD PTR [eax+edx+36]
  0008d	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00094	9f		 lahf
  00095	f6 c4 44	 test	 ah, 68			; 00000044H
  00098	7a 1d		 jp	 SHORT $LN6@CGInventor

; 20444: 	{
; 20445: 		pMsg.btResult = -1;
; 20446: 		DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0009a	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0009e	50		 push	 eax
  0009f	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000a2	c6 45 fd ff	 mov	 BYTE PTR _pMsg$[ebp+5], 255 ; 000000ffH
  000a6	50		 push	 eax
  000a7	56		 push	 esi
  000a8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b0	5b		 pop	 ebx
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi

; 20573: }

  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
$LN6@CGInventor:

; 20447: 		return;
; 20448: 	}
; 20449: 	// ----
; 20450: 	switch( lpObj->pInventory[lpMsg->btItemPos].m_Type )

  000b7	8b 45 0c	 mov	 eax, DWORD PTR tv477[ebp]
  000ba	0f bf 44 10 06	 movsx	 eax, WORD PTR [eax+edx+6]
  000bf	05 80 e5 ff ff	 add	 eax, -6784		; ffffe580H
  000c4	83 f8 06	 cmp	 eax, 6
  000c7	0f 87 0f 01 00
	00		 ja	 $LN28@CGInventor
  000cd	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN43@CGInventor[eax*4]
$LN7@CGInventor:

; 20451: 	{
; 20452: 	case ITEMGET(13, 128):
; 20453: 	case ITEMGET(13, 129):
; 20454: 		{
; 20455: 			if( !lpObj->m_btSculptPos )

  000d4	8a 87 9c 25 00
	00		 mov	 al, BYTE PTR [edi+9628]
  000da	84 c0		 test	 al, al
  000dc	0f 85 9b 00 00
	00		 jne	 $LN24@CGInventor

; 20456: 			{
; 20457: 				if( lpMsg->btValue == 254 )

  000e2	80 79 05 fe	 cmp	 BYTE PTR [ecx+5], 254	; 000000feH
  000e6	0f 85 f0 00 00
	00		 jne	 $LN28@CGInventor

; 20458: 				{
; 20459: 					if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 255.0 )

  000ec	0f 5a c0	 cvtps2pd xmm0, xmm0
  000ef	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@406fe00000000000
  000f7	9f		 lahf
  000f8	f6 c4 44	 test	 ah, 68			; 00000044H
  000fb	0f 8a db 00 00
	00		 jp	 $LN28@CGInventor

; 20460: 					{
; 20461: 						lpObj->m_btSculptPos = lpMsg->btItemPos;

  00101	88 9f 9c 25 00
	00		 mov	 BYTE PTR [edi+9628], bl

; 20462: 						lpObj->pInventory[lpMsg->btItemPos].m_Durability = 254.0;
; 20463: 						pMsg.btResult = -2;
; 20464: 					}
; 20465: 				}
; 20466: 				break;
; 20467: 			}
; 20468: 			// ----
; 20469: 			if(		lpObj->m_btSculptPos < INVETORY_WEAR_SIZE 
; 20470: 				||	lpObj->m_btSculptPos >= MAIN_INVENTORY_SIZE )
; 20471: 			{
; 20472: 				break;
; 20473: 			}
; 20474: 			// ----
; 20475: 			if(		lpMsg->btValue			== 255
; 20476: 				&&	lpObj->m_btSculptPos	== lpMsg->btItemPos )
; 20477: 			{
; 20478: 				if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 254.0 )
; 20479: 				{
; 20480: 					lpObj->pInventory[lpMsg->btItemPos].m_Durability = 255.0;
; 20481: 					pMsg.btResult = -1;
; 20482: 				}
; 20483: 				break;
; 20484: 			}
; 20485: 			// ----
; 20486: 			GCServerMsgStringSend(lMsg.Get(3480), lpObj->m_Index, 1);
; 20487:             DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 20488: 		}
; 20489: 		break;

  00107	eb 5c		 jmp	 SHORT $LN41@CGInventor
$LN15@CGInventor:

; 20490: 		// --
; 20491: 	case ITEMGET(13, 130):
; 20492: 	case ITEMGET(13, 131):
; 20493: 	case ITEMGET(13, 132):
; 20494: 	case ITEMGET(13, 133):
; 20495: 		{
; 20496: 			if( !lpObj->m_btCharmPos )

  00109	8a 87 9d 25 00
	00		 mov	 al, BYTE PTR [edi+9629]
  0010f	84 c0		 test	 al, al
  00111	75 6a		 jne	 SHORT $LN24@CGInventor

; 20497: 			{
; 20498: 				if( lpMsg->btValue == 254 )

  00113	80 79 05 fe	 cmp	 BYTE PTR [ecx+5], 254	; 000000feH
  00117	0f 85 bf 00 00
	00		 jne	 $LN28@CGInventor

; 20499: 				{
; 20500: 					if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 255.0 )

  0011d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00120	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@406fe00000000000
  00128	9f		 lahf
  00129	f6 c4 44	 test	 ah, 68			; 00000044H
  0012c	0f 8a aa 00 00
	00		 jp	 $LN28@CGInventor

; 20501: 					{
; 20502: 						lpObj->m_btCharmPos = lpMsg->btItemPos;

  00132	88 9f 9d 25 00
	00		 mov	 BYTE PTR [edi+9629], bl

; 20503: 						lpObj->pInventory[lpMsg->btItemPos].m_Durability = 254.0;
; 20504: 						pMsg.btResult = -2;
; 20505: 					}
; 20506: 				}
; 20507: 				break;
; 20508: 			}
; 20509: 			// ----
; 20510: 			if(		lpObj->m_btCharmPos < INVETORY_WEAR_SIZE 
; 20511: 				||	lpObj->m_btCharmPos >= MAIN_INVENTORY_SIZE )
; 20512: 			{
; 20513: 				break;
; 20514: 			}
; 20515: 			// ----
; 20516: 			if(		lpMsg->btValue		== 255
; 20517: 				&&	lpObj->m_btCharmPos == lpMsg->btItemPos )
; 20518: 			{
; 20519: 				if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 254.0 )
; 20520: 				{
; 20521: 					lpObj->pInventory[lpMsg->btItemPos].m_Durability = 255.0;
; 20522: 					pMsg.btResult = -1;
; 20523: 				}
; 20524: 				break;
; 20525: 			}
; 20526: 			// ----
; 20527: 			GCServerMsgStringSend(lMsg.Get(3480), lpObj->m_Index, 1);
; 20528:             DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 20529: 		}
; 20530: 		break;

  00138	eb 2b		 jmp	 SHORT $LN41@CGInventor
$LN23@CGInventor:

; 20531: 		// --
; 20532: 	case ITEMGET(13, 134):
; 20533: 		{
; 20534: 			if( !lpObj->m_btArtifactPos )

  0013a	8a 87 9e 25 00
	00		 mov	 al, BYTE PTR [edi+9630]
  00140	84 c0		 test	 al, al
  00142	75 39		 jne	 SHORT $LN24@CGInventor

; 20535: 			{
; 20536: 				if( lpMsg->btValue == 254 )

  00144	80 79 05 fe	 cmp	 BYTE PTR [ecx+5], 254	; 000000feH
  00148	0f 85 8e 00 00
	00		 jne	 $LN28@CGInventor

; 20537: 				{
; 20538: 					if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 255.0 )

  0014e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00151	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@406fe00000000000
  00159	9f		 lahf
  0015a	f6 c4 44	 test	 ah, 68			; 00000044H
  0015d	7a 7d		 jp	 SHORT $LN28@CGInventor

; 20539: 					{
; 20540: 						lpObj->m_btArtifactPos = lpMsg->btItemPos;

  0015f	88 9f 9e 25 00
	00		 mov	 BYTE PTR [edi+9630], bl
$LN41@CGInventor:

; 20541: 						lpObj->pInventory[lpMsg->btItemPos].m_Durability = 254.0;

  00165	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00169	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  0016f	c7 44 10 24 00
	00 7e 43	 mov	 DWORD PTR [eax+edx+36], 1132331008 ; 437e0000H

; 20542: 						pMsg.btResult = -2;

  00177	c6 45 fd fe	 mov	 BYTE PTR _pMsg$[ebp+5], 254 ; 000000feH

; 20543: 					}
; 20544: 				}
; 20545: 				break;

  0017b	eb 5f		 jmp	 SHORT $LN28@CGInventor
$LN24@CGInventor:

; 20546: 			}
; 20547: 			// ----
; 20548: 			if(		lpObj->m_btArtifactPos < INVETORY_WEAR_SIZE 
; 20549: 				||	lpObj->m_btArtifactPos >= MAIN_INVENTORY_SIZE )

  0017d	3c 0c		 cmp	 al, 12			; 0000000cH
  0017f	72 5b		 jb	 SHORT $LN28@CGInventor
  00181	3c cc		 cmp	 al, 204			; 000000ccH
  00183	73 57		 jae	 SHORT $LN28@CGInventor

; 20550: 			{
; 20551: 				break;
; 20552: 			}
; 20553: 			// ----
; 20554: 			if(		lpMsg->btValue			== 255
; 20555: 				&&	lpObj->m_btArtifactPos	== lpMsg->btItemPos )

  00185	80 79 05 ff	 cmp	 BYTE PTR [ecx+5], 255	; 000000ffH
  00189	75 26		 jne	 SHORT $LN29@CGInventor
  0018b	3a c3		 cmp	 al, bl
  0018d	75 22		 jne	 SHORT $LN29@CGInventor

; 20556: 			{
; 20557: 				if( lpObj->pInventory[lpMsg->btItemPos].m_Durability == 254.0 )

  0018f	0f 5a c0	 cvtps2pd xmm0, xmm0
  00192	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@406fc00000000000
  0019a	9f		 lahf
  0019b	f6 c4 44	 test	 ah, 68			; 00000044H
  0019e	7a 3c		 jp	 SHORT $LN28@CGInventor

; 20558: 				{
; 20559: 					lpObj->pInventory[lpMsg->btItemPos].m_Durability = 255.0;

  001a0	8b 45 0c	 mov	 eax, DWORD PTR tv477[ebp]
  001a3	c7 44 10 24 00
	00 7f 43	 mov	 DWORD PTR [eax+edx+36], 1132396544 ; 437f0000H

; 20560: 					pMsg.btResult = -1;

  001ab	c6 45 fd ff	 mov	 BYTE PTR _pMsg$[ebp+5], 255 ; 000000ffH

; 20561: 				}
; 20562: 				break;

  001af	eb 2b		 jmp	 SHORT $LN28@CGInventor
$LN29@CGInventor:

; 20563: 			}
; 20564: 			// ----
; 20565: 			GCServerMsgStringSend(lMsg.Get(3480), lpObj->m_Index, 1);

  001b1	6a 01		 push	 1
  001b3	ff 37		 push	 DWORD PTR [edi]
  001b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001ba	68 98 0d 00 00	 push	 3480			; 00000d98H
  001bf	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 20566:             DataSend(iIndex, (LPBYTE)&pMsg, pMsg.h.size);

  001ca	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001ce	50		 push	 eax
  001cf	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001d2	50		 push	 eax
  001d3	56		 push	 esi
  001d4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001d9	83 c4 18	 add	 esp, 24			; 00000018H
$LN28@CGInventor:

; 20567: 		}
; 20568: 		break;
; 20569: 	}
; 20570: 	// ----
; 20571: 	gObjCalCharacter(iIndex);

  001dc	56		 push	 esi
  001dd	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter

; 20572: 	DataSend(iIndex,(LPBYTE)&pMsg, pMsg.h.size);

  001e2	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  001e6	50		 push	 eax
  001e7	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  001ea	50		 push	 eax
  001eb	56		 push	 esi
  001ec	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f1	83 c4 10	 add	 esp, 16			; 00000010H
  001f4	5b		 pop	 ebx
$LN34@CGInventor:
  001f5	5f		 pop	 edi
$LN1@CGInventor:
  001f6	5e		 pop	 esi

; 20573: }

  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	c3		 ret	 0
  001fb	90		 npad	 1
$LN43@CGInventor:
  001fc	00 00 00 00	 DD	 $LN7@CGInventor
  00200	00 00 00 00	 DD	 $LN7@CGInventor
  00204	00 00 00 00	 DD	 $LN15@CGInventor
  00208	00 00 00 00	 DD	 $LN15@CGInventor
  0020c	00 00 00 00	 DD	 $LN15@CGInventor
  00210	00 00 00 00	 DD	 $LN15@CGInventor
  00214	00 00 00 00	 DD	 $LN23@CGInventor
?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z ENDP ; CGInventoryEquipment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?ClientTestSend@@YAXHPAUClientTest@@@Z
_TEXT	SEGMENT
_UserIndex$ = 8						; size = 4
_lpResult$ = 12						; size = 4
?ClientTestSend@@YAXHPAUClientTest@@@Z PROC		; ClientTestSend, COMDAT

; 20576: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 20577: 	LogAddC(2, "[DEBUG] Text: %s, Value: %d",

  00003	8b 45 0c	 mov	 eax, DWORD PTR _lpResult$[ebp]
  00006	ff 70 68	 push	 DWORD PTR [eax+104]
  00009	83 c0 04	 add	 eax, 4
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JGJDNBPL@?$FLDEBUG?$FN?5Text?3?5?$CFs?0?5Value?3?5?$CFd?$AA@
  00012	6a 02		 push	 2
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0001a	83 c4 10	 add	 esp, 16			; 00000010H

; 20578: 		lpResult->Text, lpResult->Value);
; 20579: }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?ClientTestSend@@YAXHPAUClientTest@@@Z ENDP		; ClientTestSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGEnableUsePolymorphSkinrRecv@@YAXPAUPMSG_REQ_USE_POLYMORPH_SKIN@@H@Z
_TEXT	SEGMENT
_pMove$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGEnableUsePolymorphSkinrRecv@@YAXPAUPMSG_REQ_USE_POLYMORPH_SKIN@@H@Z PROC ; CGEnableUsePolymorphSkinrRecv, COMDAT

; 20397: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 20398: 	PMSG_MOVE pMove = { 0 };
; 20399: 	// ---
; 20400: 	if( lpMsg->EnableUsePolymorphSkin == 1 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 20401: 	{
; 20402: 		if( IsTransformCharcterSkin(gObj[aIndex].m_Change) )

  0001b	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00021	80 78 04 01	 cmp	 BYTE PTR [eax+4], 1
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	66 0f d6 45 ed	 movq	 QWORD PTR _pMove$[ebp+1], xmm0
  0002f	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _pMove$[ebp+9], 0
  00036	75 22		 jne	 SHORT $LN2@CGEnableUs
  00038	ff b4 06 34 06
	00 00		 push	 DWORD PTR [esi+eax+1588]
  0003f	e8 00 00 00 00	 call	 ?IsTransformCharcterSkin@@YA_NH@Z ; IsTransformCharcterSkin
  00044	83 c4 04	 add	 esp, 4
  00047	84 c0		 test	 al, al
  00049	74 17		 je	 SHORT $LN3@CGEnableUs

; 20403: 		{
; 20404: 		  gObj[aIndex].m_EnableUseChangeSkin = 0;

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00050	c6 84 06 12 27
	00 00 00	 mov	 BYTE PTR [esi+eax+10002], 0

; 20405: 		}
; 20406: 	 }
; 20407: 	 else

  00058	eb 08		 jmp	 SHORT $LN3@CGEnableUs
$LN2@CGEnableUs:

; 20408: 	 {
; 20409: 		gObj[aIndex].m_EnableUseChangeSkin = 1;

  0005a	c6 84 06 12 27
	00 00 01	 mov	 BYTE PTR [esi+eax+10002], 1
$LN3@CGEnableUs:

; 20410: 	 }
; 20411: 	 // ----
; 20412: 	 pMove.h.c			= 0xC1;
; 20413: 	 pMove.h.headcode	= 0xD7;
; 20414: 	 pMove.h.size		= 0xD;
; 20415: 	 pMove.X			= gObj[aIndex].X;

  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 20416: 	 pMove.Y			= gObj[aIndex].Y;
; 20417: 	 PMoveProc(&pMove, aIndex);

  00068	57		 push	 edi
  00069	66 c7 45 ec c1
	0d		 mov	 WORD PTR _pMove$[ebp], 3521 ; 00000dc1H
  0006f	c6 45 ee d7	 mov	 BYTE PTR _pMove$[ebp+2], 215 ; 000000d7H
  00073	8a 84 31 20 01
	00 00		 mov	 al, BYTE PTR [ecx+esi+288]
  0007a	88 45 ef	 mov	 BYTE PTR _pMove$[ebp+3], al
  0007d	8a 84 31 21 01
	00 00		 mov	 al, BYTE PTR [ecx+esi+289]
  00084	88 45 f0	 mov	 BYTE PTR _pMove$[ebp+4], al
  00087	8d 45 ec	 lea	 eax, DWORD PTR _pMove$[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ; PMoveProc

; 20418: 	 LogAddTD("[UseCahngeSkinState][CGEnableUsePolymorphSkinrRecv] [ChaageEanbleState : %d] On(Use): 0 / Off: 1(Don't Use) ",

  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00096	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00099	03 c6		 add	 eax, esi
  0009b	50		 push	 eax
  0009c	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0009f	03 c6		 add	 eax, esi
  000a1	50		 push	 eax
  000a2	0f be 84 31 12
	27 00 00	 movsx	 eax, BYTE PTR [ecx+esi+10002]
  000aa	50		 push	 eax
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0GN@LMFACHAA@?$FLUseCahngeSkinState?$FN?$FLCGEnableUse@
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 20419: 		gObj[aIndex].m_EnableUseChangeSkin, gObj[aIndex].AccountID, gObj[aIndex].Name);
; 20420: 	 gObjViewportListProtocolCreate(&gObj[aIndex]);

  000b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bb	03 c6		 add	 eax, esi
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate

; 20421: }

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c6	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c9	33 cd		 xor	 ecx, ebp
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
?CGEnableUsePolymorphSkinrRecv@@YAXPAUPMSG_REQ_USE_POLYMORPH_SKIN@@H@Z ENDP ; CGEnableUsePolymorphSkinrRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRequestStartMuBot@@YAXPAUPMSG_MUBOT_REQ_START@@H@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestStartMuBot@@YAXPAUPMSG_MUBOT_REQ_START@@H@Z PROC ; CGRequestStartMuBot, COMDAT

; 20319: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 20320: 	if (g_bMuBotSystemOn == FALSE) {

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bMuBotSystemOn@@3HA, 0 ; g_bMuBotSystemOn
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001b	0f 84 62 01 00
	00		 je	 $LN1@CGRequestS

; 20321: 		return;
; 20322: 	}
; 20323: 
; 20324: 	if (!gObjIsConnectedGP(aIndex)) {

  00021	57		 push	 edi
  00022	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00027	83 c4 04	 add	 esp, 4
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 51 01 00
	00		 je	 $LN1@CGRequestS

; 20325: 		return;
; 20326: 	}
; 20327: 
; 20328: 	PMSG_MUBOT_USE pMsg;
; 20329: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBF, 0x51, sizeof(pMsg));

  00032	56		 push	 esi
  00033	6a 10		 push	 16			; 00000010H
  00035	6a 51		 push	 81			; 00000051H
  00037	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003a	68 bf 00 00 00	 push	 191			; 000000bfH
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 20330: 	pMsg.Money = 0;
; 20331: 	pMsg.Time = 0;
; 20332: 	pMsg.Status = 1;
; 20333: 
; 20334: 	LPOBJ lpObj = &gObj[aIndex];

  00045	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0004b	33 c0		 xor	 eax, eax
  0004d	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax
  00051	83 c4 10	 add	 esp, 16			; 00000010H
  00054	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+8], 0
  0005b	c6 45 f8 01	 mov	 BYTE PTR _pMsg$[ebp+12], 1
  0005f	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 20335: 
; 20336: 	if (lpObj->m_IfState.use == TRUE) {

  00065	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  0006b	24 03		 and	 al, 3
  0006d	3c 01		 cmp	 al, 1
  0006f	0f 84 0d 01 00
	00		 je	 $LN13@CGRequestS

; 20337: 		return;
; 20338: 	}
; 20339: 
; 20340: 	if (lpObj->Level < g_iMuBotSystemUserLevel) {

  00075	0f bf 86 96 00
	00 00		 movsx	 eax, WORD PTR [esi+150]
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_iMuBotSystemUserLevel@@3HA ; g_iMuBotSystemUserLevel
  00082	3b c1		 cmp	 eax, ecx
  00084	7d 2e		 jge	 SHORT $LN5@CGRequestS

; 20341: 		MsgOutput(aIndex, "Only characters above %d level can run MU Helper", g_iMuBotSystemUserLevel);

  00086	51		 push	 ecx
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OKKAKFII@Only?5characters?5above?5?$CFd?5level?5c@
  0008c	57		 push	 edi
  0008d	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 20342: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00092	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00096	50		 push	 eax
  00097	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009a	50		 push	 eax
  0009b	57		 push	 edi
  0009c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20349: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000a1	83 c4 18	 add	 esp, 24			; 00000018H
  000a4	5e		 pop	 esi
  000a5	5f		 pop	 edi

; 20373: }

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a9	33 cd		 xor	 ecx, ebp
  000ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
$LN5@CGRequestS:

; 20343: 		return;
; 20344: 	}
; 20345: 	
; 20346: 	if (lpObj->MapNumber == MAP_INDEX_CASTLESIEGE
; 20347: 		|| lpObj->MapNumber == MAP_INDEX_PKFIELD) {

  000b4	8a 86 23 01 00
	00		 mov	 al, BYTE PTR [esi+291]
  000ba	3c 1e		 cmp	 al, 30			; 0000001eH
  000bc	0f 84 98 00 00
	00		 je	 $LN7@CGRequestS
  000c2	3c 40		 cmp	 al, 64			; 00000040H
  000c4	0f 84 90 00 00
	00		 je	 $LN7@CGRequestS

; 20351: 		return;
; 20352: 	}
; 20353: 
; 20354: 	if (lpMsg->btType == 0) {

  000ca	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000cd	80 78 04 00	 cmp	 BYTE PTR [eax+4], 0
  000d1	75 47		 jne	 SHORT $LN8@CGRequestS

; 20355: 		if (lpObj->Money < g_iMuBotStage1Zen) {

  000d3	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_iMuBotStage1Zen@@3HA ; g_iMuBotStage1Zen
  000df	3b c1		 cmp	 eax, ecx
  000e1	7d 06		 jge	 SHORT $LN10@CGRequestS

; 20356: 			pMsg.Status = 2;

  000e3	c6 45 f8 02	 mov	 BYTE PTR _pMsg$[ebp+12], 2

; 20357: 		}
; 20358: 		else {

  000e7	eb 3b		 jmp	 SHORT $LN9@CGRequestS
$LN10@CGRequestS:

; 20359: 			lpObj->Money -= g_iMuBotStage1Zen;

  000e9	2b c1		 sub	 eax, ecx

; 20360: 			GCMoneySend(lpObj->m_Index,lpObj->Money);

  000eb	50		 push	 eax
  000ec	ff 36		 push	 DWORD PTR [esi]
  000ee	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  000f4	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  000f9	83 c4 08	 add	 esp, 8

; 20361: 			pMsg.Status = 0;

  000fc	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+12], 0

; 20362: 			pMsg.Time = 0;

  00100	33 c0		 xor	 eax, eax
  00102	66 89 45 f0	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 20363: 			pMsg.Money = g_iMuBotStage1Zen;

  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_iMuBotStage1Zen@@3HA ; g_iMuBotStage1Zen
  0010b	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 20364: 			lpObj->m_bMUBOT = TRUE;

  0010e	c7 86 d0 26 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+9936], 1

; 20365: 		}
; 20366: 	} else {

  00118	eb 0a		 jmp	 SHORT $LN9@CGRequestS
$LN8@CGRequestS:

; 20367: 		lpObj->m_bMUBOT = FALSE;

  0011a	c7 86 d0 26 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9936], 0
$LN9@CGRequestS:

; 20368: 	}
; 20369: 
; 20370: 	lpObj->m_iMUBOT_TIME = 0;

  00124	c7 86 d8 26 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9944], 0

; 20371: 	lpObj->m_iMUBOT_STAGE = 0;

  0012e	c7 86 d4 26 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9940], 0

; 20372: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00138	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0013c	50		 push	 eax
  0013d	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00140	50		 push	 eax
  00141	57		 push	 edi
  00142	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014a	5e		 pop	 esi
  0014b	5f		 pop	 edi

; 20373: }

  0014c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014f	33 cd		 xor	 ecx, ebp
  00151	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c3		 ret	 0
$LN7@CGRequestS:

; 20348: 		MsgOutput(aIndex, "MU Helper cant run on this location", g_iMuBotSystemUserLevel);

  0015a	51		 push	 ecx
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IHDJCCIO@MU?5Helper?5cant?5run?5on?5this?5locat@
  00160	57		 push	 edi
  00161	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 20349: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00166	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0016a	50		 push	 eax
  0016b	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0016e	50		 push	 eax
  0016f	57		 push	 edi
  00170	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20350: 		lpObj->m_bMUBOT = FALSE;

  00175	c7 86 d0 26 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9936], 0
  0017f	83 c4 18	 add	 esp, 24			; 00000018H
$LN13@CGRequestS:
  00182	5e		 pop	 esi
$LN1@CGRequestS:

; 20373: }

  00183	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00186	33 cd		 xor	 ecx, ebp
  00188	5f		 pop	 edi
  00189	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018e	8b e5		 mov	 esp, ebp
  00190	5d		 pop	 ebp
  00191	c3		 ret	 0
?CGRequestStartMuBot@@YAXPAUPMSG_MUBOT_REQ_START@@H@Z ENDP ; CGRequestStartMuBot
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSendMuBotSettings@@YAXHPAE@Z
_TEXT	SEGMENT
_pMsg$ = -268						; size = 262
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpData$ = 12						; size = 4
?GCSendMuBotSettings@@YAXHPAE@Z PROC			; GCSendMuBotSettings, COMDAT

; 20302: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _lpData$[ebp]

; 20303: 	if( !gObjIsConnected(aIndex) )

  0001b	53		 push	 ebx
  0001c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	74 61		 je	 SHORT $LN1@GCSendMuBo

; 20304: 		return;
; 20305: 
; 20306: 	PMSG_MUBOT_SETTINGS_RECV pMsg;
; 20307: 	PHeadSetW((LPBYTE)&pMsg,0xAE,sizeof(pMsg));

  00028	57		 push	 edi
  00029	68 06 01 00 00	 push	 262			; 00000106H
  0002e	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00034	68 ae 00 00 00	 push	 174			; 000000aeH
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 20308: 
; 20309: 	pMsg.btType = 0;

  0003f	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 20310: 	memcpy(pMsg.btDATA,lpData,sizeof(pMsg.btDATA));

  00046	8d bd f9 fe ff
	ff		 lea	 edi, DWORD PTR _pMsg$[ebp+5]
  0004c	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H

; 20311: 
; 20312: 	DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  00051	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00057	f3 a5		 rep movsd
  00059	68 06 01 00 00	 push	 262			; 00000106H
  0005e	50		 push	 eax
  0005f	53		 push	 ebx
  00060	a4		 movsb
  00061	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 20313: 
; 20314: 	LogAddL("[MuBot] Option Send [%s][%s]",

  00066	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  0006c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00072	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00075	50		 push	 eax
  00076	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JAGJPNLP@?$FLMuBot?$FN?5Option?5Send?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  00085	83 c4 24	 add	 esp, 36			; 00000024H
  00088	5f		 pop	 edi
$LN1@GCSendMuBo:

; 20315: 		gObj[aIndex].AccountID,gObj[aIndex].Name);
; 20316: }

  00089	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008c	5e		 pop	 esi
  0008d	33 cd		 xor	 ecx, ebp
  0008f	5b		 pop	 ebx
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?GCSendMuBotSettings@@YAXHPAE@Z ENDP			; GCSendMuBotSettings
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGSaveMuBotSettings@@YAXPAUPMSG_MUBOT_SETTINGS_RECV@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGSaveMuBotSettings@@YAXPAUPMSG_MUBOT_SETTINGS_RECV@@H@Z PROC ; CGSaveMuBotSettings, COMDAT

; 20291: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 20292: 	if( !gObjIsConnectedGP(aIndex) )

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 40		 je	 SHORT $LN1@CGSaveMuBo

; 20293: 		return;
; 20294: 
; 20295: 	DGMuBotSettingsSend(aIndex,gObj[aIndex].Name,&lpMsg->btDATA[0]);

  00014	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00017	83 c0 05	 add	 eax, 5
  0001a	56		 push	 esi
  0001b	50		 push	 eax
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00021	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00027	83 c0 5d	 add	 eax, 93			; 0000005dH
  0002a	03 c6		 add	 eax, esi
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?DGMuBotSettingsSend@@YAXHPADPAE@Z ; DGMuBotSettingsSend

; 20296: 
; 20297: 	LogAddL("[MuBot] Option Save [%s][%s]",

  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0003c	03 c6		 add	 eax, esi
  0003e	50		 push	 eax
  0003f	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00042	03 c1		 add	 eax, ecx
  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JLEKNDOL@?$FLMuBot?$FN?5Option?5Save?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  00050	83 c4 18	 add	 esp, 24			; 00000018H
  00053	5e		 pop	 esi
$LN1@CGSaveMuBo:
  00054	5f		 pop	 edi

; 20298: 		gObj[aIndex].AccountID,gObj[aIndex].Name);
; 20299: }

  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?CGSaveMuBotSettings@@YAXPAUPMSG_MUBOT_SETTINGS_RECV@@H@Z ENDP ; CGSaveMuBotSettings
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z
_TEXT	SEGMENT
_wTargetIndex$1$ = -36					; size = 4
_pDarkSideTargetList$ = -32				; size = 16
_wTargetList$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z PROC ; GCMonkDarkSideTargetSelect, COMDAT

; 20248: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	56		 push	 esi

; 20249: 	WORD wMagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH,lpMsg->MagicNumberL);

  00018	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  0001c	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00020	66 c1 e1 08	 shl	 cx, 8
  00024	66 0b c8	 or	 cx, ax

; 20250: 	WORD wTargetIndex = MAKE_NUMBERW(lpMsg->NumberH,lpMsg->NumberL);
; 20251: 	WORD wTargetList[5];
; 20252: 
; 20253: 	int i;
; 20254: 	for(i = 0; i < 5; i++)
; 20255: 	{
; 20256: 		wTargetList[i] = 10000;
; 20257: 	}
; 20258: 
; 20259: 	if( gObj[aIndex].CloseCount >= 0 )

  00027	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  0002d	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  00031	57		 push	 edi
  00032	0f b7 f9	 movzx	 edi, cx
  00035	0f b6 4a 05	 movzx	 ecx, BYTE PTR [edx+5]
  00039	66 c1 e1 08	 shl	 cx, 8
  0003d	66 0b c8	 or	 cx, ax
  00040	0f b7 c1	 movzx	 eax, cx
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00049	03 ce		 add	 ecx, esi
  0004b	89 45 dc	 mov	 DWORD PTR _wTargetIndex$1$[ebp], eax
  0004e	b8 10 27 10 27	 mov	 eax, 655370000		; 27102710H
  00053	89 45 f0	 mov	 DWORD PTR _wTargetList$[ebp], eax
  00056	89 45 f4	 mov	 DWORD PTR _wTargetList$[ebp+4], eax
  00059	66 89 45 f8	 mov	 WORD PTR _wTargetList$[ebp+8], ax
  0005d	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00061	0f 8d fc 00 00
	00		 jge	 $LN1@GCMonkDark

; 20260: 		return;
; 20261: 
; 20262: 	CMagicInf* lpMagic = NULL;
; 20263: 	lpMagic = gObjGetMagicSearch(&gObj[aIndex],wMagicNumber);

  00067	57		 push	 edi
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0006e	83 c4 08	 add	 esp, 8

; 20264: 
; 20265: 	if( lpMagic == NULL )

  00071	85 c0		 test	 eax, eax
  00073	0f 84 ea 00 00
	00		 je	 $LN1@GCMonkDark

; 20266: 		return;
; 20267: 
; 20268: 	if( !gObjUseSkill.SkillMonkDarkSideGetTargetIndex(aIndex,wTargetIndex,lpMagic,&wTargetList[0]) )

  00079	8d 4d f0	 lea	 ecx, DWORD PTR _wTargetList$[ebp]
  0007c	51		 push	 ecx
  0007d	50		 push	 eax
  0007e	8b 45 dc	 mov	 eax, DWORD PTR _wTargetIndex$1$[ebp]
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00086	0f b7 c0	 movzx	 eax, ax
  00089	50		 push	 eax
  0008a	53		 push	 ebx
  0008b	e8 00 00 00 00	 call	 ?SkillMonkDarkSideGetTargetIndex@CObjUseSkill@@QAEHHHPAVCMagicInf@@PAG@Z ; CObjUseSkill::SkillMonkDarkSideGetTargetIndex
  00090	85 c0		 test	 eax, eax
  00092	0f 84 cb 00 00
	00		 je	 $LN1@GCMonkDark

; 20269: 		return;
; 20270: 
; 20271: 	PMSG_MONK_DARKSIDE_ANS pDarkSideTargetList;
; 20272: 	memset(&pDarkSideTargetList,0,sizeof(pDarkSideTargetList));
; 20273: 	PHeadSetB((LPBYTE)&pDarkSideTargetList,0x4B,sizeof(pDarkSideTargetList));

  00098	6a 10		 push	 16			; 00000010H
  0009a	8d 45 e0	 lea	 eax, DWORD PTR _pDarkSideTargetList$[ebp]
  0009d	0f 57 c0	 xorps	 xmm0, xmm0
  000a0	6a 4b		 push	 75			; 0000004bH
  000a2	50		 push	 eax
  000a3	0f 11 45 e0	 movups	 XMMWORD PTR _pDarkSideTargetList$[ebp], xmm0
  000a7	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 20274: 	memcpy(pDarkSideTargetList.Target,wTargetList,sizeof(wTargetList));

  000ac	66 8b 45 f8	 mov	 ax, WORD PTR _wTargetList$[ebp+8]

; 20275: 	pDarkSideTargetList.MagicNumber = wMagicNumber;
; 20276: 	gObj[aIndex].m_btDarkSideTargetCount = 0;
; 20277: 
; 20278: 	for(i = 0; i < 5; i++)
; 20279: 	{
; 20280: 		if( wTargetList[i] != 10000 )

  000b0	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  000b5	f3 0f 7e 45 f0	 movq	 xmm0, QWORD PTR _wTargetList$[ebp]
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	66 89 45 ee	 mov	 WORD PTR _pDarkSideTargetList$[ebp+14], ax
  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c6	66 0f d6 45 e6	 movq	 QWORD PTR _pDarkSideTargetList$[ebp+6], xmm0
  000cb	66 89 7d e4	 mov	 WORD PTR _pDarkSideTargetList$[ebp+4], di
  000cf	c6 84 06 c0 26
	00 00 00	 mov	 BYTE PTR [esi+eax+9920], 0
  000d7	66 39 4d f0	 cmp	 WORD PTR _wTargetList$[ebp], cx
  000db	74 0c		 je	 SHORT $LN5@GCMonkDark

; 20281: 		{
; 20282: 			gObj[aIndex].m_btDarkSideTargetCount++;

  000dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e2	fe 84 06 c0 26
	00 00		 inc	 BYTE PTR [esi+eax+9920]
$LN5@GCMonkDark:

; 20275: 	pDarkSideTargetList.MagicNumber = wMagicNumber;
; 20276: 	gObj[aIndex].m_btDarkSideTargetCount = 0;
; 20277: 
; 20278: 	for(i = 0; i < 5; i++)
; 20279: 	{
; 20280: 		if( wTargetList[i] != 10000 )

  000e9	66 39 4d f2	 cmp	 WORD PTR _wTargetList$[ebp+2], cx
  000ed	74 0c		 je	 SHORT $LN23@GCMonkDark

; 20281: 		{
; 20282: 			gObj[aIndex].m_btDarkSideTargetCount++;

  000ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f4	fe 84 06 c0 26
	00 00		 inc	 BYTE PTR [esi+eax+9920]
$LN23@GCMonkDark:

; 20275: 	pDarkSideTargetList.MagicNumber = wMagicNumber;
; 20276: 	gObj[aIndex].m_btDarkSideTargetCount = 0;
; 20277: 
; 20278: 	for(i = 0; i < 5; i++)
; 20279: 	{
; 20280: 		if( wTargetList[i] != 10000 )

  000fb	66 39 4d f4	 cmp	 WORD PTR _wTargetList$[ebp+4], cx
  000ff	74 0c		 je	 SHORT $LN25@GCMonkDark

; 20281: 		{
; 20282: 			gObj[aIndex].m_btDarkSideTargetCount++;

  00101	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00106	fe 84 06 c0 26
	00 00		 inc	 BYTE PTR [esi+eax+9920]
$LN25@GCMonkDark:

; 20275: 	pDarkSideTargetList.MagicNumber = wMagicNumber;
; 20276: 	gObj[aIndex].m_btDarkSideTargetCount = 0;
; 20277: 
; 20278: 	for(i = 0; i < 5; i++)
; 20279: 	{
; 20280: 		if( wTargetList[i] != 10000 )

  0010d	66 39 4d f6	 cmp	 WORD PTR _wTargetList$[ebp+6], cx
  00111	74 0c		 je	 SHORT $LN27@GCMonkDark

; 20281: 		{
; 20282: 			gObj[aIndex].m_btDarkSideTargetCount++;

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00118	fe 84 06 c0 26
	00 00		 inc	 BYTE PTR [esi+eax+9920]
$LN27@GCMonkDark:

; 20275: 	pDarkSideTargetList.MagicNumber = wMagicNumber;
; 20276: 	gObj[aIndex].m_btDarkSideTargetCount = 0;
; 20277: 
; 20278: 	for(i = 0; i < 5; i++)
; 20279: 	{
; 20280: 		if( wTargetList[i] != 10000 )

  0011f	66 39 4d f8	 cmp	 WORD PTR _wTargetList$[ebp+8], cx
  00123	74 0c		 je	 SHORT $LN29@GCMonkDark

; 20281: 		{
; 20282: 			gObj[aIndex].m_btDarkSideTargetCount++;

  00125	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0012a	fe 84 06 c0 26
	00 00		 inc	 BYTE PTR [esi+eax+9920]
$LN29@GCMonkDark:

; 20283: 		}
; 20284: 	}
; 20285: 
; 20286: 	memcpy(gObj[aIndex].m_wDarkSideTarget,wTargetList,sizeof(wTargetList));

  00131	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00137	f3 0f 7e 45 f0	 movq	 xmm0, QWORD PTR _wTargetList$[ebp]
  0013c	66 0f d6 84 31
	c2 26 00 00	 movq	 QWORD PTR [ecx+esi+9922], xmm0
  00145	66 8b 45 f8	 mov	 ax, WORD PTR _wTargetList$[ebp+8]
  00149	66 89 84 31 ca
	26 00 00	 mov	 WORD PTR [ecx+esi+9930], ax

; 20287: 	DataSend(aIndex,(LPBYTE)&pDarkSideTargetList,pDarkSideTargetList.h.size);

  00151	0f b6 45 e1	 movzx	 eax, BYTE PTR _pDarkSideTargetList$[ebp+1]
  00155	50		 push	 eax
  00156	8d 45 e0	 lea	 eax, DWORD PTR _pDarkSideTargetList$[ebp]
  00159	50		 push	 eax
  0015a	53		 push	 ebx
  0015b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCMonkDark:

; 20288: }

  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	33 cd		 xor	 ecx, ebp
  0016a	5b		 pop	 ebx
  0016b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c3		 ret	 0
?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z ENDP ; GCMonkDarkSideTargetSelect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_pAttack$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 4
_usernumber$ = 16					; size = 4
_skillsuccess$ = 20					; size = 4
?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z PROC ; GCMonkMagicAttackNumberSend, COMDAT

; 20115: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 20116: 	PMSG_MAGICATTACK_RESULT pAttack;
; 20117: 	PHeadSetBE((LPBYTE)&pAttack, 0x4A, sizeof(pAttack));

  00014	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  00017	6a 09		 push	 9
  00019	6a 4a		 push	 74			; 0000004aH
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 20118: 
; 20119: 	pAttack.MagicNumberH = SET_NUMBERH(MagicNumber);

  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _MagicNumber$[ebp]
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20120: 	pAttack.MagicNumberL = SET_NUMBERL(MagicNumber);
; 20121: 
; 20122: 	pAttack.SourceNumberH = SET_NUMBERH(lpObj->m_Index);

  00027	8b 16		 mov	 edx, DWORD PTR [esi]
  00029	8b c1		 mov	 eax, ecx
  0002b	c1 e8 08	 shr	 eax, 8
  0002e	88 45 f5	 mov	 BYTE PTR _pAttack$[ebp+5], al
  00031	8b c2		 mov	 eax, edx
  00033	c1 e8 08	 shr	 eax, 8
  00036	88 45 f3	 mov	 BYTE PTR _pAttack$[ebp+3], al

; 20123: 	pAttack.SourceNumberL = SET_NUMBERL(lpObj->m_Index);

  00039	8a c2		 mov	 al, dl
  0003b	88 4d f6	 mov	 BYTE PTR _pAttack$[ebp+6], cl
  0003e	88 45 f4	 mov	 BYTE PTR _pAttack$[ebp+4], al

; 20124: 	pAttack.TargetNumberH = SET_NUMBERH(usernumber);

  00041	8b 45 10	 mov	 eax, DWORD PTR _usernumber$[ebp]
  00044	8b c8		 mov	 ecx, eax
  00046	c1 e9 08	 shr	 ecx, 8

; 20125: 	pAttack.TargetNumberL = SET_NUMBERL(usernumber);
; 20126: 	pAttack.TargetNumberH &= 0x7F;

  00049	80 e1 7f	 and	 cl, 127			; 0000007fH
  0004c	88 45 f8	 mov	 BYTE PTR _pAttack$[ebp+8], al

; 20127: 
; 20128: 	if ( skillsuccess )

  0004f	83 7d 14 00	 cmp	 DWORD PTR _skillsuccess$[ebp], 0
  00053	88 4d f7	 mov	 BYTE PTR _pAttack$[ebp+7], cl
  00056	74 06		 je	 SHORT $LN2@GCMonkMagi

; 20129: 		pAttack.TargetNumberH |= 0x80;

  00058	80 c9 80	 or	 cl, 128			; 00000080H
  0005b	88 4d f7	 mov	 BYTE PTR _pAttack$[ebp+7], cl
$LN2@GCMonkMagi:

; 20130: 
; 20131: 	if ( lpObj->Type == OBJ_USER )

  0005e	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00062	75 12		 jne	 SHORT $LN3@GCMonkMagi

; 20132: 		DataSend(lpObj->m_Index, (LPBYTE)&pAttack, pAttack.h.size);

  00064	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  00068	50		 push	 eax
  00069	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0006c	50		 push	 eax
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCMonkMagi:

; 20133: 	
; 20134: 	MsgSendV2(lpObj, (LPBYTE)&pAttack, pAttack.h.size);

  00076	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  0007a	50		 push	 eax
  0007b	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0007e	50		 push	 eax
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 20135: }

  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	33 cd		 xor	 ecx, ebp
  0008d	5e		 pop	 esi
  0008e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z ENDP ; GCMonkMagicAttackNumberSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z
_TEXT	SEGMENT
tv414 = -4						; size = 4
tv412 = 8						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z PROC	; GCMonkMagicAttack, COMDAT

; 20138: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 20139: 	LPOBJ lpObj;
; 20140: 	LPOBJ lpTargetObj;
; 20141: 	int usernumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00004	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]

; 20142: 	CMagicInf* lpMagic;
; 20143: 
; 20144: 
; 20145: 	if( gObj[aIndex].CloseCount >= 0 )

  00007	69 4d 0c 40 27
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 10048
  0000e	56		 push	 esi
  0000f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00019	66 c1 e0 08	 shl	 ax, 8
  0001d	57		 push	 edi
  0001e	0f b7 f8	 movzx	 edi, ax
  00021	03 f1		 add	 esi, ecx
  00023	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00027	0b f8		 or	 edi, eax
  00029	89 4d fc	 mov	 DWORD PTR tv414[ebp], ecx
  0002c	80 7e 0c 00	 cmp	 BYTE PTR [esi+12], 0
  00030	0f 8d 76 02 00
	00		 jge	 $LN1@GCMonkMagi

; 20146: 		return;
; 20147: 
; 20148: 	WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH, lpMsg->MagicNumberL);

  00036	0f b6 4a 04	 movzx	 ecx, BYTE PTR [edx+4]
  0003a	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  0003e	66 c1 e1 08	 shl	 cx, 8
  00042	66 0b c8	 or	 cx, ax

; 20149: 
; 20150: 	if( MagicNumber == AT_SKILL_RAGEFIGHTER_DARKSIDE ||
; 20151: 		MagicNumber == AT_MSKILL_RF_DARKSIDE1 ||

  00045	b8 07 01 00 00	 mov	 eax, 263		; 00000107H
  0004a	53		 push	 ebx
  0004b	0f b7 d9	 movzx	 ebx, cx
  0004e	66 3b d8	 cmp	 bx, ax
  00051	0f 84 40 02 00
	00		 je	 $LN4@GCMonkMagi
  00057	b8 2f 02 00 00	 mov	 eax, 559		; 0000022fH
  0005c	66 3b d8	 cmp	 bx, ax
  0005f	0f 84 32 02 00
	00		 je	 $LN4@GCMonkMagi
  00065	b8 33 02 00 00	 mov	 eax, 563		; 00000233H
  0006a	66 3b d8	 cmp	 bx, ax
  0006d	0f 84 24 02 00
	00		 je	 $LN4@GCMonkMagi

; 20155: 		return;
; 20156: 	}
; 20157: 
; 20158: 	if( usernumber < 0 || usernumber > OBJMAX-1 )

  00073	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00079	0f 87 f8 01 00
	00		 ja	 $LN6@GCMonkMagi

; 20161: 		return;
; 20162: 	}
; 20163: 
; 20164: 	if( gObj[aIndex].Live == FALSE || 

  0007f	80 7e 51 00	 cmp	 BYTE PTR [esi+81], 0
  00083	0f 84 22 02 00
	00		 je	 $LN24@GCMonkMagi
  00089	83 7e 04 02	 cmp	 DWORD PTR [esi+4], 2
  0008d	0f 8e 18 02 00
	00		 jle	 $LN24@GCMonkMagi

; 20165: 		gObj[aIndex].Connected <= PLAYER_LOGGED )
; 20166: 	{
; 20167: 		return;
; 20168: 	}
; 20169: 
; 20170: 	lpObj = &gObj[aIndex];
; 20171: 	lpTargetObj = &gObj[usernumber];
; 20172: 
; 20173: 	int attackret = gObjCheckAttackArea(aIndex,usernumber);

  00093	57		 push	 edi
  00094	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  00097	e8 00 00 00 00	 call	 ?gObjCheckAttackArea@@YAHHH@Z ; gObjCheckAttackArea
  0009c	83 c4 08	 add	 esp, 8

; 20174: 
; 20175: 	if( attackret != 0 )

  0009f	85 c0		 test	 eax, eax
  000a1	74 54		 je	 SHORT $LN11@GCMonkMagi

; 20176: 	{
; 20177: 		LogAddTD("[%s][%s] Try Attack In Not Attack Area [Protocol] (%d:%d,%d) errortype = %d",

  000a3	50		 push	 eax
  000a4	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  000ab	50		 push	 eax
  000ac	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  000b3	50		 push	 eax
  000b4	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  000bb	50		 push	 eax
  000bc	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000bf	50		 push	 eax
  000c0	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  000c3	50		 push	 eax
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@GKLOHMBB@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 20178: 			lpObj->AccountID,lpObj->Name,lpObj->MapNumber,lpObj->X,lpObj->Y,attackret);
; 20179: 
; 20180: 		if( lpObj->Class == 275 )

  000cf	b8 13 01 00 00	 mov	 eax, 275		; 00000113H
  000d4	83 c4 1c	 add	 esp, 28			; 0000001cH
  000d7	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  000de	75 0a		 jne	 SHORT $LN10@GCMonkMagi

; 20181: 			lpObj->TargetNumber = -1;

  000e0	83 c8 ff	 or	 eax, -1
  000e3	66 89 86 38 06
	00 00		 mov	 WORD PTR [esi+1592], ax
$LN10@GCMonkMagi:

; 20182: 		if( bIsIgnorePacketSpeedHackDetect != 0 )

  000ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  000f1	0f 85 b4 01 00
	00		 jne	 $LN24@GCMonkMagi
$LN11@GCMonkMagi:

; 20183: 			return;
; 20184: 	}
; 20185: 
; 20186: 	if ( lpObj->Type == OBJ_USER )

  000f7	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  000fb	0f 85 a5 00 00
	00		 jne	 $LN12@GCMonkMagi

; 20187: 	{
; 20188: 		lpMagic = gObjGetMagicSearch(lpObj, MagicNumber);

  00101	8b c3		 mov	 eax, ebx
  00103	50		 push	 eax
  00104	56		 push	 esi
  00105	89 45 08	 mov	 DWORD PTR tv412[ebp], eax
  00108	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0010d	8b d8		 mov	 ebx, eax
  0010f	83 c4 08	 add	 esp, 8

; 20189: 
; 20190: 		if ( !lpMagic )

  00112	85 db		 test	 ebx, ebx
  00114	0f 84 91 01 00
	00		 je	 $LN24@GCMonkMagi

; 20191: 			return;
; 20192: 
; 20193: 		if ( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, lpObj->ChangeUP2 , lpMagic->m_Skill) < 1 )

  0011a	ff 73 08	 push	 DWORD PTR [ebx+8]
  0011d	0f b6 8e 94 00
	00 00		 movzx	 ecx, BYTE PTR [esi+148]
  00124	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  0012b	51		 push	 ecx
  0012c	0f b6 8e 93 00
	00 00		 movzx	 ecx, BYTE PTR [esi+147]
  00133	51		 push	 ecx
  00134	50		 push	 eax
  00135	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0013a	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z ; CMagicDamage::SkillGetRequireClass
  0013f	83 f8 01	 cmp	 eax, 1
  00142	0f 8c 63 01 00
	00		 jl	 $LN24@GCMonkMagi

; 20194: 			return;
; 20195: 
; 20196: 		if ( MagicDamageC.CheckStatus(lpMagic->m_Skill, lpObj->GuildStatus) == 0 )

  00148	ff b6 28 06 00
	00		 push	 DWORD PTR [esi+1576]
  0014e	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00153	ff 73 08	 push	 DWORD PTR [ebx+8]
  00156	e8 00 00 00 00	 call	 ?CheckStatus@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckStatus
  0015b	85 c0		 test	 eax, eax
  0015d	75 17		 jne	 SHORT $LN16@GCMonkMagi

; 20197: 		{
; 20198: 			LogAddC(2, "[0x4A] CGRageAttack() - Invalid Status");

  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MELJEGBP@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
  00164	6a 02		 push	 2
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0016c	83 c4 08	 add	 esp, 8
  0016f	5b		 pop	 ebx
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi

; 20245: }

  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
$LN16@GCMonkMagi:

; 20199: 			return;
; 20200: 		}
; 20201: 
; 20202: 		if ( MagicDamageC.CheckKillCount(lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )

  00176	0f b6 86 64 20
	00 00		 movzx	 eax, BYTE PTR [esi+8292]
  0017d	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00182	50		 push	 eax
  00183	ff 73 08	 push	 DWORD PTR [ebx+8]
  00186	e8 00 00 00 00	 call	 ?CheckKillCount@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckKillCount
  0018b	85 c0		 test	 eax, eax
  0018d	79 2e		 jns	 SHORT $LN18@GCMonkMagi

; 20203: 		{
; 20204: 			LogAddC(2, "[0x4A] CGRageAttack() - Invalid KillCount");

  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IHOODACF@?$FL0x4A?$FN?5CGRageAttack?$CI?$CJ?5?9?5Invalid?5@
  00194	6a 02		 push	 2
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0019c	83 c4 08	 add	 esp, 8
  0019f	5b		 pop	 ebx
  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi

; 20245: }

  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c3		 ret	 0
$LN12@GCMonkMagi:

; 20205: 			return;
; 20206: 		}
; 20207: 	}
; 20208: 	else
; 20209: 	{
; 20210: 		lpMagic = gObjGetMagic(lpObj, MagicNumber);

  001a6	53		 push	 ebx
  001a7	56		 push	 esi
  001a8	89 5d 08	 mov	 DWORD PTR tv412[ebp], ebx
  001ab	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
  001b0	8b d8		 mov	 ebx, eax
  001b2	83 c4 08	 add	 esp, 8

; 20211: 
; 20212: 		if ( !lpMagic )

  001b5	85 db		 test	 ebx, ebx
  001b7	0f 84 ee 00 00
	00		 je	 $LN24@GCMonkMagi
$LN18@GCMonkMagi:

; 20213: 			return;
; 20214: 	}
; 20215: 
; 20216: 	if ( !gCheckSkillDistance(aIndex, usernumber, lpMagic->m_Skill))

  001bd	ff 73 08	 push	 DWORD PTR [ebx+8]
  001c0	57		 push	 edi
  001c1	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  001c4	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  001c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cc	85 c0		 test	 eax, eax
  001ce	0f 85 85 00 00
	00		 jne	 $LN19@GCMonkMagi

; 20217: 	{
; 20218: 		DWORD dwTick = GetTickCount() - lpObj->m_dwSkillDistanceErrorTick;

  001d4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  001da	ff d7		 call	 edi

; 20219: 		
; 20220: 		if ( dwTick > (g_iSkillDiatanceKickCheckTime*1000) )

  001dc	69 0d 00 00 00
	00 e8 03 00 00	 imul	 ecx, DWORD PTR ?g_iSkillDiatanceKickCheckTime@@3KA, 1000 ; g_iSkillDiatanceKickCheckTime
  001e6	2b 86 28 24 00
	00		 sub	 eax, DWORD PTR [esi+9256]
  001ec	3b c1		 cmp	 eax, ecx
  001ee	76 12		 jbe	 SHORT $LN20@GCMonkMagi

; 20221: 		{
; 20222: 			lpObj->m_iSkillDistanceErrorCount = 0;

  001f0	c7 86 24 24 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9252], 0

; 20223: 			lpObj->m_dwSkillDistanceErrorTick = GetTickCount();

  001fa	ff d7		 call	 edi
  001fc	89 86 28 24 00
	00		 mov	 DWORD PTR [esi+9256], eax
$LN20@GCMonkMagi:

; 20224: 		}
; 20225: 
; 20226: 		lpObj->m_iSkillDistanceErrorCount++;

  00202	ff 86 24 24 00
	00		 inc	 DWORD PTR [esi+9252]
  00208	8b 86 24 24 00
	00		 mov	 eax, DWORD PTR [esi+9252]

; 20227: 
; 20228: 		if ( lpObj->m_iSkillDistanceErrorCount > g_iSkillDistanceKickCount )

  0020e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iSkillDistanceKickCount@@3HA ; g_iSkillDistanceKickCount
  00214	0f 8e 91 00 00
	00		 jle	 $LN24@GCMonkMagi

; 20229: 		{
; 20230: 			if ( g_iSkillDistanceKick )

  0021a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iSkillDistanceKick@@3HA, 0 ; g_iSkillDistanceKick
  00221	74 25		 je	 SHORT $LN22@GCMonkMagi

; 20231: 			{
; 20232: 				LogAddTD("[SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. count(%d)",

  00223	50		 push	 eax
  00224	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00227	50		 push	 eax
  00228	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0022b	50		 push	 eax
  0022c	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  00231	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 20233: 					lpObj->AccountID, lpObj->Name, lpObj->m_iSkillDistanceErrorCount);
; 20234: 
; 20235: 				CloseClient(lpObj->m_Index);

  00237	ff 36		 push	 DWORD PTR [esi]
  00239	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0023e	83 c4 14	 add	 esp, 20			; 00000014H
  00241	5b		 pop	 ebx
  00242	5f		 pop	 edi
  00243	5e		 pop	 esi

; 20245: }

  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c3		 ret	 0
$LN22@GCMonkMagi:
  00248	5b		 pop	 ebx
  00249	5f		 pop	 edi

; 20236: 				return;
; 20237: 			}
; 20238: 
; 20239: 			lpObj->m_iSkillDistanceErrorCount=0;

  0024a	c7 86 24 24 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9252], 0
  00254	5e		 pop	 esi

; 20245: }

  00255	8b e5		 mov	 esp, ebp
  00257	5d		 pop	 ebp
  00258	c3		 ret	 0
$LN19@GCMonkMagi:

; 20240: 		}
; 20241: 
; 20242: 		return;
; 20243: 	}
; 20244: 	GCMonkMagicAttackNumberSend(&gObj[aIndex],MagicNumber,usernumber,TRUE);

  00259	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0025e	03 45 fc	 add	 eax, DWORD PTR tv414[ebp]
  00261	6a 01		 push	 1
  00263	57		 push	 edi
  00264	ff 75 08	 push	 DWORD PTR tv412[ebp]
  00267	50		 push	 eax
  00268	e8 00 00 00 00	 call	 ?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z ; GCMonkMagicAttackNumberSend
  0026d	83 c4 10	 add	 esp, 16			; 00000010H
  00270	5b		 pop	 ebx
  00271	5f		 pop	 edi
  00272	5e		 pop	 esi

; 20245: }

  00273	8b e5		 mov	 esp, ebp
  00275	5d		 pop	 ebp
  00276	c3		 ret	 0
$LN6@GCMonkMagi:

; 20159: 	{
; 20160: 		LogAdd("error :%s %d %d",__FILE__,__LINE__,usernumber);

  00277	57		 push	 edi
  00278	68 c0 4e 00 00	 push	 20160			; 00004ec0H
  0027d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00282	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@
  00287	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0028d	83 c4 10	 add	 esp, 16			; 00000010H
  00290	5b		 pop	 ebx
  00291	5f		 pop	 edi
  00292	5e		 pop	 esi

; 20245: }

  00293	8b e5		 mov	 esp, ebp
  00295	5d		 pop	 ebp
  00296	c3		 ret	 0
$LN4@GCMonkMagi:

; 20152: 		MagicNumber == AT_MSKILL_RF_DARKSIDE2 )
; 20153: 	{
; 20154: 		GCMonkMagicAttackNumberSend(&gObj[aIndex],MagicNumber,gObj[aIndex].m_wDarkSideTarget[0],TRUE);

  00297	0f bf 86 c2 26
	00 00		 movsx	 eax, WORD PTR [esi+9922]
  0029e	6a 01		 push	 1
  002a0	50		 push	 eax
  002a1	53		 push	 ebx
  002a2	56		 push	 esi
  002a3	e8 00 00 00 00	 call	 ?GCMonkMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@HHH@Z ; GCMonkMagicAttackNumberSend
  002a8	83 c4 10	 add	 esp, 16			; 00000010H
$LN24@GCMonkMagi:
  002ab	5b		 pop	 ebx
$LN1@GCMonkMagi:
  002ac	5f		 pop	 edi
  002ad	5e		 pop	 esi

; 20245: }

  002ae	8b e5		 mov	 esp, ebp
  002b0	5d		 pop	 ebp
  002b1	c3		 ret	 0
?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ENDP	; GCMonkMagicAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGWindowReqMove@@YAXPAUPMSG_MOVE_REQUEST@@H@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 8
_movereq$1$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
tv266 = 12						; size = 4
_aIndex$ = 12						; size = 4
?CGWindowReqMove@@YAXPAUPMSG_MOVE_REQUEST@@H@Z PROC	; CGWindowReqMove, COMDAT

; 20049: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	57		 push	 edi

; 20050: 	if ( !OBJMAX_RANGE(aIndex))

  00007	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 4d 01 00
	00		 js	 $LN1@CGWindowRe
  00012	33 c0		 xor	 eax, eax
  00014	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 3a 01 00
	00		 je	 $LN1@CGWindowRe

; 20051: 	{
; 20052: 		return;
; 20053: 	}
; 20054: 
; 20055: 	if( !gObjIsConnected(aIndex) )

  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 29 01 00
	00		 je	 $LN1@CGWindowRe

; 20056: 		return;
; 20057: 
; 20058: 
; 20059: 	if (g_SelfDefenseOn)

  00036	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_SelfDefenseOn@@3_NA, 0 ; g_SelfDefenseOn
  0003d	53		 push	 ebx
  0003e	74 48		 je	 SHORT $LN15@CGWindowRe

; 20060: 	{
; 20061: 		if ((GetTickCount() - gObj[aIndex].MySelfDefenseTime) < g_SelfDefenseTime * 1000) 

  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00046	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00052	2b 84 19 fc 05
	00 00		 sub	 eax, DWORD PTR [ecx+ebx+1532]
  00059	69 0d 00 00 00
	00 e8 03 00 00	 imul	 ecx, DWORD PTR ?g_SelfDefenseTime@@3HA, 1000 ; g_SelfDefenseTime
  00063	3b c1		 cmp	 eax, ecx
  00065	73 27		 jae	 SHORT $LN5@CGWindowRe

; 20062: 		{
; 20063: 			GCServerMsgStringSend(lMsg.Get(1133),aIndex,1);

  00067	6a 01		 push	 1
  00069	57		 push	 edi
  0006a	68 6d 04 00 00	 push	 1133			; 0000046dH
$LN18@CGWindowRe:
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00074	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 20111: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	5b		 pop	 ebx
  00083	5f		 pop	 edi

; 20112: }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN15@CGWindowRe:

; 20064: 			return;

  00088	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN5@CGWindowRe:
  0008e	56		 push	 esi

; 20065: 		}
; 20066: 	}
; 20067: 
; 20068: 	LPOBJ lpObj = &gObj[aIndex];
; 20069: 	int movereq = lpMsg->wMoveNumber;

  0008f	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00092	69 c7 40 27 00
	00		 imul	 eax, edi, 10048

; 20070: 
; 20071: 	PMSG_MOVE_ANSWER pMsg;
; 20072: 	PHeadSetB((LPBYTE) &pMsg,0x8E,sizeof(pMsg));

  00098	6a 08		 push	 8
  0009a	68 8e 00 00 00	 push	 142			; 0000008eH
  0009f	89 45 0c	 mov	 DWORD PTR tv266[ebp], eax
  000a2	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  000a6	89 45 fc	 mov	 DWORD PTR _movereq$1$[ebp], eax
  000a9	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 20073: 	pMsg.CHECK = lpMsg->CHECK;
; 20074: 
; 20075: 	if ( lpObj->Teleport != 0 )

  000b2	8b 55 0c	 mov	 edx, DWORD PTR tv266[ebp]
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000bb	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+4], eax
  000be	80 bc 1a 88 05
	00 00 00	 cmp	 BYTE PTR [edx+ebx+1416], 0
  000c6	5e		 pop	 esi
  000c7	74 0c		 je	 SHORT $LN6@CGWindowRe
$LN19@CGWindowRe:

; 20076: 	{
; 20077: 		GCServerMsgStringSend(lMsg.Get(MSGGET(6, 68)), lpObj->m_Index, 1);

  000c9	6a 01		 push	 1
  000cb	ff 34 1a	 push	 DWORD PTR [edx+ebx]
  000ce	68 44 06 00 00	 push	 1604			; 00000644H

; 20078: 		return;

  000d3	eb 9a		 jmp	 SHORT $LN18@CGWindowRe
$LN6@CGWindowRe:

; 20079: 	}
; 20080: 
; 20081: 
; 20082: 	if ( (lpObj->m_IfState.use) != 0 )

  000d5	8b 8c 1a b8 11
	00 00		 mov	 ecx, DWORD PTR [edx+ebx+4536]
  000dc	f6 c1 03	 test	 cl, 3
  000df	74 26		 je	 SHORT $LN8@CGWindowRe

; 20083: 	{
; 20084: 		if ( lpObj->m_IfState.type  == 3 )

  000e1	8b c1		 mov	 eax, ecx
  000e3	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000e8	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000ed	75 18		 jne	 SHORT $LN8@CGWindowRe

; 20085: 		{
; 20086: 			lpObj->TargetShopNumber = -1;

  000ef	83 c8 ff	 or	 eax, -1

; 20087: 			lpObj->m_IfState.type = 0;
; 20088: 			lpObj->m_IfState.use = 0;

  000f2	81 e1 3c 00 ff
	ff		 and	 ecx, -65476		; ffff003cH
  000f8	66 89 84 1a 3a
	06 00 00	 mov	 WORD PTR [edx+ebx+1594], ax
  00100	89 8c 1a b8 11
	00 00		 mov	 DWORD PTR [edx+ebx+4536], ecx
$LN8@CGWindowRe:

; 20089: 		}
; 20090: 	}
; 20091: 
; 20092: 	if ( lpObj->m_IfState.use > 0 )

  00107	f6 84 1a b8 11
	00 00 03	 test	 BYTE PTR [edx+ebx+4536], 3
  0010f	77 b8		 ja	 SHORT $LN19@CGWindowRe

; 20093: 	{
; 20094: 		GCServerMsgStringSend(lMsg.Get(MSGGET(6, 68)), lpObj->m_Index, 1);
; 20095: 		return;
; 20096: 	}
; 20097: 			
; 20098: 	if ( lpObj->IsInBattleGround != false )

  00111	80 bc 1a de 13
	00 00 00	 cmp	 BYTE PTR [edx+ebx+5086], 0
  00119	75 ae		 jne	 SHORT $LN19@CGWindowRe

; 20099: 	{
; 20100: 		GCServerMsgStringSend(lMsg.Get(MSGGET(6, 68)), lpObj->m_Index, 1);
; 20101: 		return;
; 20102: 	}
; 20103: 
; 20104: 	if ( lpObj->m_PK_Level >= 6)

  0011b	80 bc 1a 19 01
	00 00 06	 cmp	 BYTE PTR [edx+ebx+281], 6
  00123	7c 0f		 jl	 SHORT $LN11@CGWindowRe

; 20105: 	{
; 20106: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 101)), lpObj->m_Index, 1);

  00125	6a 01		 push	 1
  00127	ff 34 1a	 push	 DWORD PTR [edx+ebx]
  0012a	68 65 04 00 00	 push	 1125			; 00000465H

; 20107: 		return;

  0012f	e9 3b ff ff ff	 jmp	 $LN18@CGWindowRe
$LN11@CGWindowRe:

; 20108: 	}
; 20109: 
; 20110: 	pMsg.btResult = gMoveCommand.Move(&gObj[aIndex], movereq);

  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00139	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  0013e	ff 75 fc	 push	 DWORD PTR _movereq$1$[ebp]
  00141	03 c2		 add	 eax, edx
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ?Move@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::Move
  00149	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 20111: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0014c	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00150	50		 push	 eax
  00151	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00154	50		 push	 eax
  00155	57		 push	 edi
  00156	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015e	5b		 pop	 ebx
$LN1@CGWindowRe:
  0015f	5f		 pop	 edi

; 20112: }

  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c3		 ret	 0
?CGWindowReqMove@@YAXPAUPMSG_MOVE_REQUEST@@H@Z ENDP	; CGWindowReqMove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqMoveAcheron@@YAXH@Z
_TEXT	SEGMENT
_pMsg$1 = -8						; size = 5
_aIndex$ = 8						; size = 4
?CGReqMoveAcheron@@YAXH@Z PROC				; CGReqMoveAcheron, COMDAT

; 19997: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 19998: 	if( !gObjIsConnected(aIndex) )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	53		 push	 ebx
  0000b	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	0f 84 a3 00 00
	00		 je	 $LN7@CGReqMoveA

; 19999: 		return;
; 20000: 
; 20001: 	LPOBJ lpObj = &gObj[aIndex];

  0001b	69 db 40 27 00
	00		 imul	 ebx, ebx, 10048
  00021	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 20002: 
; 20003: 	if( lpObj->m_IfState.use != 1 || lpObj->m_IfState.type != 21 )

  00027	8b 8b b8 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4536]
  0002d	8b c1		 mov	 eax, ecx
  0002f	24 03		 and	 al, 3
  00031	3c 01		 cmp	 al, 1
  00033	0f 85 85 00 00
	00		 jne	 $LN7@CGReqMoveA
  00039	8b c1		 mov	 eax, ecx
  0003b	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00040	3d 40 05 00 00	 cmp	 eax, 1344		; 00000540H
  00045	75 77		 jne	 SHORT $LN7@CGReqMoveA

; 20004: 		return;
; 20005: 	
; 20006: 	lpObj->m_IfState.use = 0;
; 20007: 	lpObj->m_IfState.type = 0;

  00047	56		 push	 esi
  00048	81 e1 3c 00 ff
	ff		 and	 ecx, -65476		; ffff003cH
  0004e	be f0 09 00 00	 mov	 esi, 2544		; 000009f0H
  00053	57		 push	 edi
  00054	89 8b b8 11 00
	00		 mov	 DWORD PTR [ebx+4536], ecx

; 20008: 
; 20009: 	int bSpiritMap = FALSE;
; 20010: 
; 20011: 	for(int i = INVETORY_WEAR_SIZE; i < MAIN_INVENTORY_SIZE; i++)	{

  0005a	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH
  0005f	90		 npad	 1
$LL4@CGReqMoveA:

; 20012: 		if( lpObj->pInventory[i].IsItem() &&

  00060	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  00066	03 ce		 add	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006d	85 c0		 test	 eax, eax
  0006f	74 12		 je	 SHORT $LN2@CGReqMoveA
  00071	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00077	b9 92 1a 00 00	 mov	 ecx, 6802		; 00001a92H
  0007c	66 39 4c 30 06	 cmp	 WORD PTR [eax+esi+6], cx
  00081	74 40		 je	 SHORT $LN12@CGReqMoveA
$LN2@CGReqMoveA:

; 20008: 
; 20009: 	int bSpiritMap = FALSE;
; 20010: 
; 20011: 	for(int i = INVETORY_WEAR_SIZE; i < MAIN_INVENTORY_SIZE; i++)	{

  00083	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00089	47		 inc	 edi
  0008a	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  00090	7c ce		 jl	 SHORT $LL4@CGReqMoveA

; 20020: 			break;
; 20021: 		}
; 20022: 	}
; 20023: 
; 20024: 
; 20025: 	if( !bSpiritMap )
; 20026: 	{
; 20027: 		PMSG_ANS_MOVEACHERON pMsg;
; 20028: 		PHeadSubSetB((LPBYTE)&pMsg,0xF8,0x21,sizeof(pMsg));

  00092	6a 05		 push	 5
  00094	6a 21		 push	 33			; 00000021H
  00096	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00099	68 f8 00 00 00	 push	 248			; 000000f8H
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 20029: 		pMsg.btResult = 1;
; 20030: 
; 20031: 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  000a4	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  000a8	50		 push	 eax
  000a9	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  000ac	c6 45 fc 01	 mov	 BYTE PTR _pMsg$1[ebp+4], 1
  000b0	50		 push	 eax
  000b1	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  000b4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000b9	83 c4 1c	 add	 esp, 28			; 0000001cH
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
$LN7@CGReqMoveA:
  000be	5b		 pop	 ebx

; 20036: 
; 20037: 
; 20038: 	/*if( gObj[aIndex].MapNumber == 79 )
; 20039: 	{
; 20040: 		gObjMoveGate(aIndex,17);
; 20041: 	}
; 20042: 	else
; 20043: 	{
; 20044: 		gObjMoveGate(aIndex,333);
; 20045: 	}*/
; 20046: }

  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
$LN12@CGReqMoveA:

; 20013: 			lpObj->pInventory[i].m_Type == ITEMGET(13,146) )
; 20014: 		{
; 20015: 			bSpiritMap = TRUE;
; 20016: 
; 20017: 			gObjInventoryItemSet(aIndex,i,(BYTE)-1);

  000c3	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  000c6	68 ff 00 00 00	 push	 255			; 000000ffH
  000cb	57		 push	 edi
  000cc	56		 push	 esi
  000cd	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 20018: 			lpObj->pInventory[i].Clear();

  000d2	69 cf d4 00 00
	00		 imul	 ecx, edi, 212
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  000e1	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 20019: 			GCInventoryItemDeleteSend(aIndex,i,1);

  000e6	6a 01		 push	 1
  000e8	57		 push	 edi
  000e9	56		 push	 esi
  000ea	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 20032: 		return;
; 20033: 	}
; 20034: 
; 20035: 	gObjMoveGate(aIndex,417);

  000ef	68 a1 01 00 00	 push	 417			; 000001a1H
  000f4	56		 push	 esi
  000f5	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000fa	83 c4 14	 add	 esp, 20			; 00000014H
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx

; 20036: 
; 20037: 
; 20038: 	/*if( gObj[aIndex].MapNumber == 79 )
; 20039: 	{
; 20040: 		gObjMoveGate(aIndex,17);
; 20041: 	}
; 20042: 	else
; 20043: 	{
; 20044: 		gObjMoveGate(aIndex,333);
; 20045: 	}*/
; 20046: }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
?CGReqMoveAcheron@@YAXH@Z ENDP				; CGReqMoveAcheron
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqmoveLorenMarket@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGReqmoveLorenMarket@@YAXH@Z PROC			; CGReqmoveLorenMarket, COMDAT

; 19967: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 19968: 	if( !gObjIsConnected(aIndex) )

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 64		 je	 SHORT $LN4@CGReqmoveL

; 19969: 		return;
; 19970: 
; 19971: 	LPOBJ lpObj = &gObj[aIndex];

  00014	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  0001a	57		 push	 edi
  0001b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 19972: 
; 19973: 	if( lpObj->m_IfState.use != 1 || lpObj->m_IfState.type != 21 )

  00021	8b 8c 17 b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+edx+4536]
  00028	8b c1		 mov	 eax, ecx
  0002a	24 03		 and	 al, 3
  0002c	3c 01		 cmp	 al, 1
  0002e	75 47		 jne	 SHORT $LN8@CGReqmoveL
  00030	8b c1		 mov	 eax, ecx
  00032	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00037	3d 40 05 00 00	 cmp	 eax, 1344		; 00000540H
  0003c	75 39		 jne	 SHORT $LN8@CGReqmoveL

; 19974: 		return;
; 19975: 	
; 19976: 	lpObj->m_IfState.use = 0;
; 19977: 	lpObj->m_IfState.type = 0;

  0003e	81 e1 3c 00 ff
	ff		 and	 ecx, -65476		; ffff003cH
  00044	89 8c 17 b8 11
	00 00		 mov	 DWORD PTR [edi+edx+4536], ecx

; 19978: 
; 19979: 
; 19980: 	if( gObj[aIndex].MapNumber == 79 )

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00050	80 bc 02 23 01
	00 00 4f	 cmp	 BYTE PTR [edx+eax+291], 79 ; 0000004fH
  00058	75 0f		 jne	 SHORT $LN5@CGReqmoveL

; 19981: 	{
; 19982: 		gObjMoveGate(aIndex,17);

  0005a	6a 11		 push	 17			; 00000011H

; 19983: 	}
; 19984: 	else
; 19985: 	{
; 19986: 		gObjMoveGate(aIndex,333);

  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00062	83 c4 08	 add	 esp, 8
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi

; 19987: 	}
; 19988: }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN5@CGReqmoveL:

; 19983: 	}
; 19984: 	else
; 19985: 	{
; 19986: 		gObjMoveGate(aIndex,333);

  00069	68 4d 01 00 00	 push	 333			; 0000014dH
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00074	83 c4 08	 add	 esp, 8
$LN8@CGReqmoveL:
  00077	5f		 pop	 edi
$LN4@CGReqmoveL:
  00078	5e		 pop	 esi

; 19987: 	}
; 19988: }

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?CGReqmoveLorenMarket@@YAXH@Z ENDP			; CGReqmoveLorenMarket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSendExp@@YAXHH_JHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_AttackIndex$ = 12					; size = 4
_Exp$ = 16						; size = 8
_Damage$ = 24						; size = 4
_Type$ = 28						; size = 4
?GCSendExp@@YAXHH_JHH@Z PROC				; GCSendExp, COMDAT

; 19870: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 19871: 	PMSG_KILLPLAYER_EXT pMsg;
; 19872: 	PHeadSetBE((LPBYTE)&pMsg,0x9C,sizeof(pMsg));

  00010	6a 0c		 push	 12			; 0000000cH
  00012	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	68 9c 00 00 00	 push	 156			; 0000009cH
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 19873: 
; 19874: 	pMsg.NumberH = SET_NUMBERH(AttackIndex);

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _AttackIndex$[ebp]
  00023	8b c1		 mov	 eax, ecx
  00025	c1 e8 08	 shr	 eax, 8
  00028	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 19875: 	pMsg.NumberL = SET_NUMBERL(AttackIndex);

  0002b	88 4d f4	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 19876: 	pMsg.ExpH = (DWORD)Exp >> 16;

  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _Exp$[ebp]
  00031	8b c1		 mov	 eax, ecx
  00033	c1 e8 10	 shr	 eax, 16			; 00000010H
  00036	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+6], ax

; 19877: 	pMsg.ExpL = (DWORD)Exp & 0xFFFF;

  0003a	66 89 4d f8	 mov	 WORD PTR _pMsg$[ebp+8], cx

; 19878: 
; 19879: #if (CUSTOM_DAMAGE==1)
; 19880: 	pMsg.DamageHW = SET_NUMBERHW(Damage);
; 19881: 	pMsg.DamageLW = SET_NUMBERLW(Damage);
; 19882: #else
; 19883: 	pMsg.DamageH = SET_NUMBERH(Damage);

  0003e	8b 4d 18	 mov	 ecx, DWORD PTR _Damage$[ebp]
  00041	8b c1		 mov	 eax, ecx
  00043	c1 e8 08	 shr	 eax, 8
  00046	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+10], al

; 19884: 	pMsg.DamageL = SET_NUMBERL(Damage);
; 19885: #endif
; 19886: 
; 19887: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00049	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0004d	50		 push	 eax
  0004e	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00051	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+11], cl
  00054	50		 push	 eax
  00055	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00058	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 19888: }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	83 c4 18	 add	 esp, 24			; 00000018H
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?GCSendExp@@YAXHH_JHH@Z ENDP				; GCSendExp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqEnterZone@@YAXPAUPMSG_REQ_ENTERZONE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqEnterZone@@YAXPAUPMSG_REQ_ENTERZONE@@H@Z PROC	; CGReqEnterZone, COMDAT

; 19953: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19954: 	if( !OBJMAX_RANGE(aIndex) )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 27		 js	 SHORT $LN7@CGReqEnter
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 18		 je	 SHORT $LN7@CGReqEnter

; 19957: 		return;
; 19958: 	}
; 19959: 
; 19960: 	if( lpMsg->btType == 1 )

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0001c	80 78 04 01	 cmp	 BYTE PTR [eax+4], 1
  00020	75 27		 jne	 SHORT $LN3@CGReqEnter

; 19961: 	{
; 19962: 		g_ImperialGuardian.CGEnterPortal(aIndex,0);

  00022	6a 00		 push	 0
  00024	51		 push	 ecx
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  0002a	e8 00 00 00 00	 call	 ?CGEnterPortal@CImperialGuardian@@QAEXHH@Z ; CImperialGuardian::CGEnterPortal

; 19963: 	}
; 19964: }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN7@CGReqEnter:

; 19955: 	{
; 19956: 		LogAdd("return %s %d",__FILE__,__LINE__);

  00031	68 f4 4d 00 00	 push	 19956			; 00004df4H
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@CGReqEnter:

; 19963: 	}
; 19964: }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?CGReqEnterZone@@YAXPAUPMSG_REQ_ENTERZONE@@H@Z ENDP	; CGReqEnterZone
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqmoveDoubleGoer@@YAXPAEH@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqmoveDoubleGoer@@YAXPAEH@Z PROC			; CGReqmoveDoubleGoer, COMDAT

; 19936: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19937: 	if( aRecv == NULL || !OBJMAX_RANGE(aIndex) )

  00003	83 7d 08 00	 cmp	 DWORD PTR _aRecv$[ebp], 0
  00007	56		 push	 esi
  00008	74 3b		 je	 SHORT $LN3@CGReqmoveD
  0000a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000d	85 f6		 test	 esi, esi
  0000f	78 34		 js	 SHORT $LN3@CGReqmoveD
  00011	33 c0		 xor	 eax, eax
  00013	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00019	0f 9e c0	 setle	 al
  0001c	85 c0		 test	 eax, eax
  0001e	74 25		 je	 SHORT $LN3@CGReqmoveD

; 19940: 		return;
; 19941: 	}
; 19942: 
; 19943: 	if( !gObjIsConnected(aIndex) )

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN4@CGReqmoveD

; 19944: 	{
; 19945: 		LogAdd("return %s %d",__FILE__,__LINE__);

  0002d	68 e9 4d 00 00	 push	 19945			; 00004de9H

; 19946: 		return;

  00032	eb 16		 jmp	 SHORT $LN8@CGReqmoveD
$LN4@CGReqmoveD:

; 19947: 	}
; 19948: 
; 19949: 	gDoubleGoer.EnterRequest((PMSG_DOUBLEGOER_REQ_ENTER*)aRecv,aIndex);

  00034	56		 push	 esi
  00035	ff 75 08	 push	 DWORD PTR _aRecv$[ebp]
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDoubleGoer@@3VCDoubleGoerEvent@@A ; gDoubleGoer
  0003d	e8 00 00 00 00	 call	 ?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z ; CDoubleGoerEvent::EnterRequest
  00042	5e		 pop	 esi

; 19950: }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN3@CGReqmoveD:

; 19938: 	{
; 19939: 		LogAdd("return %s %d",__FILE__,__LINE__);

  00045	68 e3 4d 00 00	 push	 19939			; 00004de3H
$LN8@CGReqmoveD:
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	5e		 pop	 esi

; 19950: }

  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?CGReqmoveDoubleGoer@@YAXPAEH@Z ENDP			; CGReqmoveDoubleGoer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z PROC		; PacketCheckTime, COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 117  : 	if ( ( GetTickCount() - lpObj->m_PacketCheckTime ) < 300 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0000d	2b 86 7c 05 00
	00		 sub	 eax, DWORD PTR [esi+1404]
  00013	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  00018	73 05		 jae	 SHORT $LN2@PacketChec

; 118  : 	{
; 119  : 		return FALSE;

  0001a	33 c0		 xor	 eax, eax
  0001c	5e		 pop	 esi

; 124  : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN2@PacketChec:

; 120  : 	}
; 121  : 
; 122  : 	lpObj->m_PacketCheckTime = GetTickCount();

  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00025	89 86 7c 05 00
	00		 mov	 DWORD PTR [esi+1404], eax

; 123  : 	return TRUE;

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	5e		 pop	 esi

; 124  : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; PacketCheckTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGBuyPCBangShop@@YAXPAEH@Z
_TEXT	SEGMENT
_pMsg$1 = -24						; size = 18
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGBuyPCBangShop@@YAXPAEH@Z PROC			; CGBuyPCBangShop, COMDAT

; 19919: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 19920: 	if( aRecv == NULL )

  00010	83 7d 08 00	 cmp	 DWORD PTR _aRecv$[ebp], 0
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00018	74 43		 je	 SHORT $LN3@CGBuyPCBan

; 19921: 		return;
; 19922: 
; 19923: 	if( PacketCheckTime(&gObj[aIndex]) == FALSE )

  0001a	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00020	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	75 2a		 jne	 SHORT $LN3@CGBuyPCBan

; 19924: 	{
; 19925: 		PMSB_PCBANG_BUYRESULT pMsg;
; 19926: 
; 19927: 		PHeadSubSetB((LPBYTE)&pMsg,0xD0,0x05,sizeof(pMsg));

  00033	6a 12		 push	 18			; 00000012H
  00035	6a 05		 push	 5
  00037	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0003a	68 d0 00 00 00	 push	 208			; 000000d0H
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19928: 		pMsg.btResult = 6;
; 19929: 		pMsg.btPos = 0xFF;
; 19930: 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00045	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00049	50		 push	 eax
  0004a	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0004d	66 c7 45 ec 06
	ff		 mov	 WORD PTR _pMsg$1[ebp+4], 65286 ; 0000ff06H
  00053	50		 push	 eax
  00054	56		 push	 esi
  00055	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005a	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN3@CGBuyPCBan:

; 19931: 		return;
; 19932: 	}
; 19933: }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	33 cd		 xor	 ecx, ebp
  00062	5e		 pop	 esi
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?CGBuyPCBangShop@@YAXPAEH@Z ENDP			; CGBuyPCBangShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGOpenPCBangShop@@YAXPAEH@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGOpenPCBangShop@@YAXPAEH@Z PROC			; CGOpenPCBangShop, COMDAT

; 19903: 	if( aRecv == NULL )
; 19904: 		return;
; 19905: 
; 19906: 	if( !OBJMAX_RANGE(aIndex) )
; 19907: 		return;
; 19908: }

  00000	c3		 ret	 0
?CGOpenPCBangShop@@YAXPAEH@Z ENDP			; CGOpenPCBangShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAttackSpeedSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCAttackSpeedSend@@YAXH@Z PROC				; GCAttackSpeedSend, COMDAT

; 20383: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 20384: 	if( !gObjIsConnected(aIndex) )

  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 42		 je	 SHORT $LN1@GCAttackSp

; 20385: 		return;
; 20386: 
; 20387: 	PMSG_ATTACKSPEED pMsg;
; 20388: 	PHeadSubSetB((LPBYTE)&pMsg,0xEC,0x30,sizeof(pMsg));

  00021	6a 0c		 push	 12			; 0000000cH
  00023	6a 30		 push	 48			; 00000030H
  00025	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00028	68 ec 00 00 00	 push	 236			; 000000ecH
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 20389: 
; 20390: 	pMsg.iAttackSpeed = gObj[aIndex].m_AttackSpeed;

  00033	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00039	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003f	8b 81 6c 06 00
	00		 mov	 eax, DWORD PTR [ecx+1644]
  00045	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 20391: 	pMsg.iMagicSpeed = gObj[aIndex].m_MagicSpeed;

  00048	8b 81 70 06 00
	00		 mov	 eax, DWORD PTR [ecx+1648]
  0004e	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 20392: 
; 20393: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00051	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00055	50		 push	 eax
  00056	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00059	50		 push	 eax
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00060	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@GCAttackSp:

; 20394: }

  00063	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00066	33 cd		 xor	 ecx, ebp
  00068	5e		 pop	 esi
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?GCAttackSpeedSend@@YAXH@Z ENDP				; GCAttackSpeedSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSendEffectInfo@@YAXPAUOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_bUseType$ = 12						; size = 4
_iOptionType$ = 16					; size = 4
_iEffectType$ = 20					; size = 4
_iTimeValue$ = 24					; size = 4
?GCSendEffectInfo@@YAXPAUOBJECTSTRUCT@@HHHH@Z PROC	; GCSendEffectInfo, COMDAT

; 19837: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 19838: 	PMSG_SENDEFFECT pMsg;
; 19839: 	PHeadSetB((LPBYTE)&pMsg,0x2D,sizeof(pMsg));

  00014	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 18		 push	 24			; 00000018H
  00019	6a 2d		 push	 45			; 0000002dH
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 19840: 
; 19841: 	pMsg.byEffectOption = bUseType;

  00021	8a 45 0c	 mov	 al, BYTE PTR _bUseType$[ebp]
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19842: 	pMsg.wOptionType = iOptionType;
; 19843: 	pMsg.wEffectType = iEffectType;
; 19844: 	pMsg.iLeftTime = iTimeValue;
; 19845: 	pMsg.iEffect = 0;
; 19846: 
; 19847: 	if( lpObj->Type == OBJ_USER )

  00027	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  0002b	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+8], al
  0002e	66 8b 45 10	 mov	 ax, WORD PTR _iOptionType$[ebp]
  00032	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+4], ax
  00036	66 8b 45 14	 mov	 ax, WORD PTR _iEffectType$[ebp]
  0003a	66 89 45 ea	 mov	 WORD PTR _pMsg$[ebp+6], ax
  0003e	8b 45 18	 mov	 eax, DWORD PTR _iTimeValue$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00044	c6 45 f4 00	 mov	 BYTE PTR _pMsg$[ebp+16], 0
  00048	75 13		 jne	 SHORT $LN2@GCSendEffe

; 19848: 	{
; 19849: 		DataSend(lpObj->m_Index,(LPBYTE)&pMsg,pMsg.h.size);

  0004a	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0004e	50		 push	 eax
  0004f	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00052	50		 push	 eax
  00053	ff 36		 push	 DWORD PTR [esi]
  00055	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCSendEffe:

; 19850: 	}
; 19851: }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	33 cd		 xor	 ecx, ebp
  00062	5e		 pop	 esi
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?GCSendEffectInfo@@YAXPAUOBJECTSTRUCT@@HHHH@Z ENDP	; GCSendEffectInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGIllusionTempleReward@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGIllusionTempleReward@@YAXH@Z PROC			; CGIllusionTempleReward, COMDAT

; 19891: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19892: 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1c		 js	 SHORT $LN6@CGIllusion
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0d		 je	 SHORT $LN6@CGIllusion

; 19895: 		return;
; 19896: 	}
; 19897: 
; 19898: 	g_IllusionTemple.DropReward(aIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  0001f	e8 00 00 00 00	 call	 ?DropReward@CIllusionTempleEvent@@QAEXH@Z ; CIllusionTempleEvent::DropReward

; 19899: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN6@CGIllusion:

; 19893: 	{
; 19894: 		LogAdd("return %s %d",__FILE__,__LINE__);

  00026	68 b6 4d 00 00	 push	 19894			; 00004db6H
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19899: }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?CGIllusionTempleReward@@YAXH@Z ENDP			; CGIllusionTempleReward
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCIllusionSendPoint@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_Point$ = 12						; size = 1
?GCIllusionSendPoint@@YAXHE@Z PROC			; GCIllusionSendPoint, COMDAT

; 19861: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19862: 	PMSG_ILLUSION_POINT_SEND pMsg;
; 19863: 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,6,sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 06		 push	 6
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 bf 00 00 00	 push	 191			; 000000bfH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19864: 	pMsg.Point = Point;

  00018	8a 45 0c	 mov	 al, BYTE PTR _Point$[ebp]
  0001b	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 19865: 
; 19866: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0001e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00022	50		 push	 eax
  00023	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00026	50		 push	 eax
  00027	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0002a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 19867: }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GCIllusionSendPoint@@YAXHE@Z ENDP			; GCIllusionSendPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCIllusionSkillUseSend@@YAXPAUPMSG_ILLUSION_REQ_SKILLUSE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCIllusionSkillUseSend@@YAXPAUPMSG_ILLUSION_REQ_SKILLUSE@@H@Z PROC ; GCIllusionSkillUseSend, COMDAT

; 19823: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 19824: 	if( OBJMAX_RANGE(aIndex) == FALSE )

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 4a		 js	 SHORT $LN6@GCIllusion
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 3b		 je	 SHORT $LN6@GCIllusion

; 19827: 		return;
; 19828: 	}
; 19829: 
; 19830: 	WORD TargetIndex = MAKE_NUMBERW(lpMsg->tIndexH,lpMsg->tIndexL);
; 19831: 
; 19832: 	g_IllusionTemple.UseSkill(aIndex,MAKE_NUMBERW(lpMsg->MagicH,lpMsg->MagicL),TargetIndex,lpMsg->State);

  0001a	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0001d	0f b6 42 08	 movzx	 eax, BYTE PTR [edx+8]
  00021	50		 push	 eax
  00022	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  00026	66 c1 e0 08	 shl	 ax, 8
  0002a	0f b7 c8	 movzx	 ecx, ax
  0002d	0f b6 42 07	 movzx	 eax, BYTE PTR [edx+7]
  00031	0b c8		 or	 ecx, eax
  00033	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00037	51		 push	 ecx
  00038	0f b6 4a 04	 movzx	 ecx, BYTE PTR [edx+4]
  0003c	66 c1 e1 08	 shl	 cx, 8
  00040	66 0b c8	 or	 cx, ax
  00043	0f b7 c1	 movzx	 eax, cx
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  0004b	50		 push	 eax
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ?UseSkill@CIllusionTempleEvent@@QAEXHGHE@Z ; CIllusionTempleEvent::UseSkill
  00052	5e		 pop	 esi

; 19833: }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN6@GCIllusion:

; 19825: 	{
; 19826: 		LogAdd("return %s %d",__FILE__,__LINE__);

  00055	68 72 4d 00 00	 push	 19826			; 00004d72H
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	5e		 pop	 esi

; 19833: }

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?GCIllusionSkillUseSend@@YAXPAUPMSG_ILLUSION_REQ_SKILLUSE@@H@Z ENDP ; GCIllusionSkillUseSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCReqmoveIllusionTemple@@YAXPAUPMSG_REQ_MOVEILLUSIONTEMPLE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?GCReqmoveIllusionTemple@@YAXPAUPMSG_REQ_MOVEILLUSIONTEMPLE@@H@Z PROC ; GCReqmoveIllusionTemple, COMDAT

; 19812: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19813: 	if( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 55 0c	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 2d		 js	 SHORT $LN6@GCReqmoveI
  0000a	33 c0		 xor	 eax, eax
  0000c	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 1e		 je	 SHORT $LN6@GCReqmoveI

; 19816: 		return;
; 19817: 	}
; 19818: 
; 19819: 	g_IllusionTemple.Enter(iIndex,lpMsg->iTempleNumber - 1,lpMsg->iItemPos);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0001c	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  00020	50		 push	 eax
  00021	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00029	fe c8		 dec	 al
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	50		 push	 eax
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ?Enter@CIllusionTempleEvent@@QAEHHEE@Z ; CIllusionTempleEvent::Enter

; 19820: }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
$LN6@GCReqmoveI:

; 19814: 	{
; 19815: 		LogAdd("return %s %d",__FILE__,__LINE__);

  00037	68 67 4d 00 00	 push	 19815			; 00004d67H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19820: }

  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?GCReqmoveIllusionTemple@@YAXPAUPMSG_REQ_MOVEILLUSIONTEMPLE@@H@Z ENDP ; GCReqmoveIllusionTemple
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCReqEnterBalgassLair@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GCReqEnterBalgassLair@@YAXH@Z PROC			; GCReqEnterBalgassLair, COMDAT

; 19798: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19799: 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1a		 js	 SHORT $LN1@GCReqEnter
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN1@GCReqEnter

; 19800: 		return;
; 19801: 
; 19802: 	g_QuestInfo.NotifyResultEnterRefuge(aIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0001f	e8 00 00 00 00	 call	 ?NotifyResultEnterRefuge@CQuestInfo@@QAEXH@Z ; CQuestInfo::NotifyResultEnterRefuge
$LN1@GCReqEnter:

; 19803: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GCReqEnterBalgassLair@@YAXH@Z ENDP			; GCReqEnterBalgassLair
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCReqEnterBarracks@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GCReqEnterBarracks@@YAXH@Z PROC			; GCReqEnterBarracks, COMDAT

; 19790: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19791: 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1a		 js	 SHORT $LN1@GCReqEnter
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN1@GCReqEnter

; 19792: 		return;
; 19793: 
; 19794: 	g_QuestInfo.NotifyResultEnterBarracks(aIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0001f	e8 00 00 00 00	 call	 ?NotifyResultEnterBarracks@CQuestInfo@@QAEXH@Z ; CQuestInfo::NotifyResultEnterBarracks
$LN1@GCReqEnter:

; 19795: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GCReqEnterBarracks@@YAXH@Z ENDP			; GCReqEnterBarracks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_lpMsg$ = 8						; size = 4
_iOldMoney$1$ = 12					; size = 4
_bPermission$ = 12					; size = 4
_iIndex$ = 12						; size = 4
?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z PROC ; CGReqCastleHuntZoneEntrance, COMDAT

; 19727: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi

; 19728: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  00007	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	0f 88 51 01 00
	00		 js	 $LN1@CGReqCastl
  00012	33 c0		 xor	 eax, eax
  00014	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 3e 01 00
	00		 je	 $LN1@CGReqCastl

; 19729: 		return;
; 19730: 
; 19731: 	LPOBJ lpObj = &gObj[iIndex];
; 19732: 
; 19733: 	PMSG_ANS_MOVE_TO_CASTLE_HUNTZONE pMsg = {0};
; 19734: 
; 19735: 	PHeadSubSetB((LPBYTE)&pMsg,0xB9,5,sizeof( pMsg ));

  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	6a 05		 push	 5
  00029	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00032	6a 05		 push	 5
  00034	68 b9 00 00 00	 push	 185			; 000000b9H
  00039	50		 push	 eax
  0003a	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0003e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00044	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
  0004b	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00050	83 c4 10	 add	 esp, 16			; 00000010H

; 19736: 
; 19737: 	pMsg.btResult = FALSE;

  00053	c6 45 fc 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0

; 19738: 
; 19739: 	int iEnterTaxMoney = 0;
; 19740: 	int bPermission;
; 19741: 
; 19742: 	iEnterTaxMoney = g_CastleSiegeSync.GetTaxHuntZone(lpObj->m_Index,TRUE);

  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0005c	6a 01		 push	 1
  0005e	ff 36		 push	 DWORD PTR [esi]
  00060	e8 00 00 00 00	 call	 ?GetTaxHuntZone@CCastleSiegeSync@@QAEHHH@Z ; CCastleSiegeSync::GetTaxHuntZone
  00065	8b d8		 mov	 ebx, eax

; 19743: 
; 19744: 	if(iEnterTaxMoney < 0)
; 19745: 		iEnterTaxMoney = 0;
; 19746: 
; 19747: 	if(g_CastleSiege.GetHuntZoneEnter() != FALSE)

  00067	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0006c	33 c0		 xor	 eax, eax
  0006e	85 db		 test	 ebx, ebx
  00070	0f 48 d8	 cmovs	 ebx, eax
  00073	e8 00 00 00 00	 call	 ?GetHuntZoneEnter@CCastleSiege@@QAEHXZ ; CCastleSiege::GetHuntZoneEnter
  00078	85 c0		 test	 eax, eax
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	8b 45 0c	 mov	 eax, DWORD PTR _bPermission$[ebp]
  00082	0f 45 c1	 cmovne	 eax, ecx

; 19748: 		bPermission = TRUE;
; 19749: 
; 19750: 	if(lpObj->lpGuild != NULL)

  00085	83 be 18 06 00
	00 00		 cmp	 DWORD PTR [esi+1560], 0
  0008c	89 45 0c	 mov	 DWORD PTR _bPermission$[ebp], eax

; 19751: 	{
; 19752: 		if(g_CastleSiege.CheckCastleOwnerUnionMember(lpObj->m_Index) != FALSE)

  0008f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00094	74 25		 je	 SHORT $LN5@CGReqCastl
  00096	ff 36		 push	 DWORD PTR [esi]
  00098	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _bPermission$[ebp]
  000a0	85 c0		 test	 eax, eax

; 19753: 			bPermission = TRUE;
; 19754: 
; 19755: 		if(g_CastleSiege.CheckCastleOwnerMember(lpObj->m_Index) != FALSE) 

  000a2	ff 36		 push	 DWORD PTR [esi]
  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	0f 45 c8	 cmovne	 ecx, eax
  000ac	89 4d 0c	 mov	 DWORD PTR _bPermission$[ebp], ecx
  000af	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b4	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember

; 19756: 			bPermission = TRUE;
; 19757: 	}

  000b9	eb 05		 jmp	 SHORT $LN19@CGReqCastl
$LN5@CGReqCastl:

; 19758: 	else if(g_CastleSiege.GetHuntZoneEnter() != FALSE)

  000bb	e8 00 00 00 00	 call	 ?GetHuntZoneEnter@CCastleSiege@@QAEHXZ ; CCastleSiege::GetHuntZoneEnter
$LN19@CGReqCastl:
  000c0	85 c0		 test	 eax, eax
  000c2	75 0a		 jne	 SHORT $LN17@CGReqCastl

; 19759: 	{
; 19760: 		bPermission = TRUE;
; 19761: 	}
; 19762: 
; 19763: 	if(bPermission == TRUE)

  000c4	83 7d 0c 01	 cmp	 DWORD PTR _bPermission$[ebp], 1
  000c8	0f 85 81 00 00
	00		 jne	 $LN12@CGReqCastl
$LN17@CGReqCastl:

; 19764: 	{
; 19765: 		if( lpObj->Money >= iEnterTaxMoney &&

  000ce	39 9e cc 00 00
	00		 cmp	 DWORD PTR [esi+204], ebx
  000d4	7c 79		 jl	 SHORT $LN12@CGReqCastl
  000d6	80 be 23 01 00
	00 1e		 cmp	 BYTE PTR [esi+291], 30	; 0000001eH
  000dd	75 70		 jne	 SHORT $LN12@CGReqCastl

; 19766: 			lpObj->MapNumber == MAP_INDEX_CASTLESIEGE)
; 19767: 		{
; 19768: 			if(gObjMoveGate(lpObj->m_Index,0x5F) == TRUE)

  000df	6a 5f		 push	 95			; 0000005fH
  000e1	ff 36		 push	 DWORD PTR [esi]
  000e3	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000e8	83 c4 08	 add	 esp, 8
  000eb	83 f8 01	 cmp	 eax, 1
  000ee	75 5f		 jne	 SHORT $LN12@CGReqCastl

; 19769: 			{
; 19770: 				pMsg.btResult = TRUE;

  000f0	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 19771: 				int iOldMoney = lpObj->Money;
; 19772: 				lpObj->Money -= iEnterTaxMoney;
; 19773: 
; 19774: 				g_CastleSiegeSync.AddTributeMoney(iEnterTaxMoney);

  000f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  000f8	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  000fe	89 45 0c	 mov	 DWORD PTR _iOldMoney$1$[ebp], eax
  00101	2b c3		 sub	 eax, ebx
  00103	53		 push	 ebx
  00104	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  0010a	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 19775: 
; 19776: 				if(lpObj->Money < 0)

  0010f	83 be cc 00 00
	00 00		 cmp	 DWORD PTR [esi+204], 0
  00116	7d 0a		 jge	 SHORT $LN13@CGReqCastl

; 19777: 					lpObj->Money = 0;

  00118	c7 86 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+204], 0
$LN13@CGReqCastl:

; 19778: 
; 19779: 				GCMoneySend(lpObj->m_Index,lpObj->Money);

  00122	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  00128	ff 36		 push	 DWORD PTR [esi]
  0012a	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 19780: 				LogAddTD("[Castle HuntZone] [%s][%s] - Entrance TAX : %d - %d = %d",

  0012f	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  00135	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00138	53		 push	 ebx
  00139	ff 75 0c	 push	 DWORD PTR _iOldMoney$1$[ebp]
  0013c	50		 push	 eax
  0013d	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00140	50		 push	 eax
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@POFOHDII@?$FLCastle?5HuntZone?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Ent@
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0014c	83 c4 20	 add	 esp, 32			; 00000020H
$LN12@CGReqCastl:

; 19781: 					lpObj->AccountID,lpObj->Name,iOldMoney,iEnterTaxMoney,lpObj->Money);
; 19782: 			}
; 19783: 		}
; 19784: 	}
; 19785: 
; 19786: 	DataSend(iIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0014f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00153	50		 push	 eax
  00154	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00157	50		 push	 eax
  00158	57		 push	 edi
  00159	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0015e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx
$LN1@CGReqCastl:
  00163	5f		 pop	 edi

; 19787: }

  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z ENDP ; CGReqCastleHuntZoneEntrance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSendObjectCreationState@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_iObjectIndex$ = 8					; size = 4
?GCSendObjectCreationState@@YAXH@Z PROC			; GCSendObjectCreationState, COMDAT

; 19706: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 19707: #if (GS_CASTLE == 1)
; 19708: 	if(OBJMAX_RANGE(iObjectIndex) == FALSE)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iObjectIndex$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	78 65		 js	 SHORT $LN3@GCSendObje
  0000e	33 c0		 xor	 eax, eax
  00010	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	74 56		 je	 SHORT $LN3@GCSendObje

; 19709: 		return;
; 19710: 
; 19711: 	LPOBJ lpObj = &gObj[iObjectIndex];

  0001d	56		 push	 esi
  0001e	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048

; 19712: 	PMSG_NOTIFY_OBJECT_CREATION_STATE pMsg = {0};

  00024	33 c0		 xor	 eax, eax
  00026	89 45 f9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  00029	66 89 45 fd	 mov	 WORD PTR _pMsg$[ebp+5], ax

; 19713: 
; 19714: 	if(lpObj->Class == 278)

  0002d	b8 16 01 00 00	 mov	 eax, 278		; 00000116H
  00032	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00036	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003c	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  00043	75 2d		 jne	 SHORT $LN7@GCSendObje

; 19715: 	{
; 19716: 		PHeadSubSetB((PBYTE)&pMsg,0xB9,0x01,sizeof(pMsg));

  00045	6a 07		 push	 7
  00047	6a 01		 push	 1
  00049	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004c	68 b9 00 00 00	 push	 185			; 000000b9H
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19717: 		pMsg.btObjIndexH = SET_NUMBERH(iObjectIndex);
; 19718: 		pMsg.btObjIndexH = SET_NUMBERL(iObjectIndex);

  00057	88 5d fc	 mov	 BYTE PTR _pMsg$[ebp+4], bl

; 19719: 		pMsg.btCreationState = lpObj->m_btCreationState;

  0005a	8a 86 6d 20 00
	00		 mov	 al, BYTE PTR [esi+8301]
  00060	88 45 fe	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 19720: 
; 19721: 		MsgSendV2(lpObj,(PBYTE)&pMsg,sizeof(pMsg));

  00063	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00066	6a 07		 push	 7
  00068	50		 push	 eax
  00069	56		 push	 esi
  0006a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0006f	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN7@GCSendObje:
  00072	5e		 pop	 esi
$LN3@GCSendObje:
  00073	5b		 pop	 ebx

; 19722: 	}
; 19723: #endif
; 19724: }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?GCSendObjectCreationState@@YAXH@Z ENDP			; GCSendObjectCreationState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_bGiveUp$ = 16						; size = 1
_iMarkCount$ = 20					; size = 4
_lpszGuildName$ = 24					; size = 4
?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z PROC		; GCAnsGiveUpCastleSiege, COMDAT

; 17878: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 18	 mov	 ecx, DWORD PTR _lpszGuildName$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 17879: #if (GS_CASTLE==1)
; 17880: 	if(lpszGuildName == NULL)

  00017	85 c9		 test	 ecx, ecx
  00019	0f 84 e0 00 00
	00		 je	 $LN6@GCAnsGiveU

; 17881: 		return;
; 17882: 
; 17883: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  0001f	85 f6		 test	 esi, esi
  00021	0f 88 d8 00 00
	00		 js	 $LN6@GCAnsGiveU
  00027	33 c0		 xor	 eax, eax
  00029	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0002f	0f 9e c0	 setle	 al
  00032	85 c0		 test	 eax, eax
  00034	0f 84 c5 00 00
	00		 je	 $LN6@GCAnsGiveU

; 17891: 	pMsgResult.btIsGiveUp = bGiveUp;

  0003a	8a 45 10	 mov	 al, BYTE PTR _bGiveUp$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 141  : 		lpBuf[1] = size;

  0003d	b2 0e		 mov	 dl, 14			; 0000000eH
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17891: 	pMsgResult.btIsGiveUp = bGiveUp;

  0003f	88 45 f1	 mov	 BYTE PTR _pMsgResult$[ebp+5], al

; 17892: 	memcpy(pMsgResult.szGuildName,lpszGuildName,sizeof(pMsgResult.szGuildName));

  00042	8b 01		 mov	 eax, DWORD PTR [ecx]
  00044	53		 push	 ebx
  00045	8b 5d 0c	 mov	 ebx, DWORD PTR _iResult$[ebp]
  00048	89 45 f2	 mov	 DWORD PTR _pMsgResult$[ebp+6], eax
  0004b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0004e	c7 45 ec c1 0e
	b2 02		 mov	 DWORD PTR _pMsgResult$[ebp], 45223617 ; 02b20ec1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17890: 	pMsgResult.btResult = iResult;

  00055	88 5d f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], bl

; 17892: 	memcpy(pMsgResult.szGuildName,lpszGuildName,sizeof(pMsgResult.szGuildName));

  00058	89 45 f6	 mov	 DWORD PTR _pMsgResult$[ebp+10], eax

; 17893: 
; 17894: 	if(pMsgResult.btResult == 1 && iMarkCount > 0)

  0005b	80 fb 01	 cmp	 bl, 1
  0005e	75 59		 jne	 SHORT $LN4@GCAnsGiveU
  00060	57		 push	 edi
  00061	8b 7d 14	 mov	 edi, DWORD PTR _iMarkCount$[ebp]
  00064	85 ff		 test	 edi, edi
  00066	7e 50		 jle	 SHORT $LN13@GCAnsGiveU

; 17895: 	{
; 17896: 		gObj[iIndex].Money += iMarkCount * 3000;

  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006e	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  00074	69 c7 b8 0b 00
	00		 imul	 eax, edi, 3000
  0007a	01 84 11 cc 00
	00 00		 add	 DWORD PTR [ecx+edx+204], eax

; 17897: 
; 17898: 		if(gObj[iIndex].Money > 2000000000)

  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00086	81 bc 02 cc 00
	00 00 00 94 35
	77		 cmp	 DWORD PTR [edx+eax+204], 2000000000 ; 77359400H
  00091	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  00094	7e 0f		 jle	 SHORT $LN5@GCAnsGiveU

; 17899: 		{
; 17900: 			gObj[iIndex].Money = 2000000000;

  00096	c7 81 cc 00 00
	00 00 94 35 77	 mov	 DWORD PTR [ecx+204], 2000000000 ; 77359400H
  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN5@GCAnsGiveU:

; 17901: 		}
; 17902: 
; 17903: 		GCMoneySend(iIndex,gObj[iIndex].Money);

  000a5	ff b4 02 cc 00
	00 00		 push	 DWORD PTR [edx+eax+204]
  000ac	56		 push	 esi
  000ad	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  000b2	8a 55 ed	 mov	 dl, BYTE PTR _pMsgResult$[ebp+1]
  000b5	83 c4 08	 add	 esp, 8
$LN13@GCAnsGiveU:
  000b8	5f		 pop	 edi
$LN4@GCAnsGiveU:

; 17904: 	}
; 17905: 
; 17906: 	DataSend(iIndex,(BYTE *)&pMsgResult,pMsgResult.h.size);

  000b9	0f b6 c2	 movzx	 eax, dl
  000bc	50		 push	 eax
  000bd	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  000c0	50		 push	 eax
  000c1	56		 push	 esi
  000c2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17907: 
; 17908: 	if(gObjIsConnected(iIndex))

  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000cd	83 c4 10	 add	 esp, 16			; 00000010H
  000d0	85 c0		 test	 eax, eax
  000d2	74 2a		 je	 SHORT $LN12@GCAnsGiveU

; 17909: 	{
; 17910: 		LogAddTD("[CastleSiege] [%s][%s] GiveUp Castle Siege (GUILD:%s) - Result:%d",

  000d4	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  000da	53		 push	 ebx
  000db	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e1	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  000e7	50		 push	 eax
  000e8	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000eb	50		 push	 eax
  000ec	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000ef	50		 push	 eax
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@MMKDCAAJ@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GiveUp?5Ca@
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000fb	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@GCAnsGiveU:
  000fe	5b		 pop	 ebx
$LN6@GCAnsGiveU:

; 17911: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,iResult);
; 17912: 	}
; 17913: #endif
; 17914: }

  000ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	5e		 pop	 esi
  00105	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z ENDP		; GCAnsGiveUpCastleSiege
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z PROC ; GCReqEnterKanturuBossMap, COMDAT

; 19690: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19691: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1a		 js	 SHORT $LN1@GCReqEnter
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN1@GCReqEnter

; 19692: 		return;
; 19693: 
; 19694: 	g_KanturuEntranceNPC.NotifyResultEnterKanturuBossMap(iIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KanturuEntranceNPC@@3VCKanturuEntranceNPC@@A ; g_KanturuEntranceNPC
  0001f	e8 00 00 00 00	 call	 ?NotifyResultEnterKanturuBossMap@CKanturuEntranceNPC@@QAEXH@Z ; CKanturuEntranceNPC::NotifyResultEnterKanturuBossMap
$LN1@GCReqEnter:

; 19695: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z ENDP ; GCReqEnterKanturuBossMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z PROC ; CGReqKanturuStateInfo, COMDAT

; 19680: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19681: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	78 1a		 js	 SHORT $LN1@CGReqKantu
  0000a	33 c0		 xor	 eax, eax
  0000c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00012	0f 9e c0	 setle	 al
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN1@CGReqKantu

; 19682: 		return;
; 19683: 
; 19684: 	g_KanturuEntranceNPC.NotifyEntranceInfo(iIndex);

  00019	51		 push	 ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KanturuEntranceNPC@@3VCKanturuEntranceNPC@@A ; g_KanturuEntranceNPC
  0001f	e8 00 00 00 00	 call	 ?NotifyEntranceInfo@CKanturuEntranceNPC@@QAEXH@Z ; CKanturuEntranceNPC::NotifyEntranceInfo
$LN1@CGReqKantu:

; 19685: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z ENDP ; CGReqKanturuStateInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z PROC ; CGReqPlusChaosRate, COMDAT

; 19666: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 19667: 	if ( OBJMAX_RANGE(iIndex) == FALSE )

  00007	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	78 4b		 js	 SHORT $LN1@CGReqPlusC
  0000e	33 c0		 xor	 eax, eax
  00010	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	74 3c		 je	 SHORT $LN1@CGReqPlusC

; 19668: 		return;
; 19669: 
; 19670: 	PMSG_ANS_CRYWOLF_BENEFIT_PLUS_CHAOSRATE pMsg={0};
; 19671: 
; 19672: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBD, 0x09, sizeof(pMsg));

  0001d	6a 05		 push	 5
  0001f	6a 09		 push	 9
  00021	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00024	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00028	68 bd 00 00 00	 push	 189			; 000000bdH
  0002d	50		 push	 eax
  0002e	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
  00035	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0003a	83 c4 10	 add	 esp, 16			; 00000010H

; 19673: 	pMsg.btPlusChaosRate = g_CrywolfSync.GetPlusChaosRate();

  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  00042	e8 00 00 00 00	 call	 ?GetPlusChaosRate@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetPlusChaosRate
  00047	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 19674: 
; 19675: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0004a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004d	6a 05		 push	 5
  0004f	50		 push	 eax
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGReqPlusC:
  00059	5e		 pop	 esi

; 19676: }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z ENDP ; CGReqPlusChaosRate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_lpMsg$ = 8						; size = 4
_lpAltarObj$1$ = 12					; size = 4
_iIndex$ = 12						; size = 4
?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z PROC ; CGReqAlatrContract, COMDAT

; 19612: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19613: 	int iAltarIndex = MAKE_NUMBERW(lpMsg->btObjIndexH, lpMsg->btObjIndexL);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  0000d	56		 push	 esi

; 19614: 
; 19615: 	if ( !OBJMAX_RANGE(iIndex))

  0000e	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00011	66 c1 e0 08	 shl	 ax, 8
  00015	57		 push	 edi
  00016	0f b7 f8	 movzx	 edi, ax
  00019	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  0001d	0b f8		 or	 edi, eax
  0001f	85 f6		 test	 esi, esi
  00021	0f 88 41 01 00
	00		 js	 $LN1@CGReqAlatr
  00027	33 c0		 xor	 eax, eax
  00029	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0002f	0f 9e c0	 setle	 al
  00032	85 c0		 test	 eax, eax
  00034	0f 84 2e 01 00
	00		 je	 $LN1@CGReqAlatr

; 19616: 		return;
; 19617: 
; 19618: 	if ( !OBJMAX_RANGE(iAltarIndex))

  0003a	85 ff		 test	 edi, edi
  0003c	0f 88 26 01 00
	00		 js	 $LN1@CGReqAlatr
  00042	33 c0		 xor	 eax, eax
  00044	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0004a	0f 9e c0	 setle	 al
  0004d	85 c0		 test	 eax, eax
  0004f	0f 84 13 01 00
	00		 je	 $LN1@CGReqAlatr

; 19619: 		return;
; 19620: 
; 19621: 	LPOBJ lpObj = &gObj[iIndex];
; 19622: 	LPOBJ lpAltarObj = &gObj[iAltarIndex];

  00055	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  0005b	53		 push	 ebx
  0005c	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00062	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00068	89 4d 0c	 mov	 DWORD PTR _lpAltarObj$1$[ebp], ecx
  0006b	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 19623: 
; 19624: 	if ( !CRYWOLF_ALTAR_CLASS_RANGE(lpAltarObj->Class))

  00071	0f b7 81 90 00
	00 00		 movzx	 eax, WORD PTR [ecx+144]
  00078	b9 cd 00 00 00	 mov	 ecx, 205		; 000000cdH
  0007d	66 3b c1	 cmp	 ax, cx
  00080	0f 82 e1 00 00
	00		 jb	 $LN16@CGReqAlatr
  00086	b9 d1 00 00 00	 mov	 ecx, 209		; 000000d1H
  0008b	66 3b c8	 cmp	 cx, ax
  0008e	1b c0		 sbb	 eax, eax
  00090	83 c0 01	 add	 eax, 1
  00093	0f 84 ce 00 00
	00		 je	 $LN16@CGReqAlatr

; 19625: 		return;
; 19626: 
; 19627: 	if ( !gObjIsConnected(lpObj))

  00099	53		 push	 ebx
  0009a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0009f	83 c4 04	 add	 esp, 4
  000a2	85 c0		 test	 eax, eax
  000a4	0f 84 bd 00 00
	00		 je	 $LN16@CGReqAlatr

; 19628: 		return;
; 19629: 
; 19630: 	PMSG_ANS_CRYWOLF_ALTAR_CONTRACT pMsg={0};

  000aa	33 c0		 xor	 eax, eax
  000ac	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0

; 19631: 
; 19632: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBD, 0x03, sizeof(pMsg));

  000b0	6a 08		 push	 8
  000b2	6a 03		 push	 3
  000b4	89 45 f9	 mov	 DWORD PTR _pMsg$[ebp+1], eax
  000b7	66 89 45 fd	 mov	 WORD PTR _pMsg$[ebp+5], ax
  000bb	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+7], al
  000be	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000c1	68 bd 00 00 00	 push	 189			; 000000bdH
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19633: 	pMsg.btResult = 0;
; 19634: 	pMsg.btAltarState = g_CrywolfNPC_Altar.GetAltarState(lpAltarObj->Class);

  000cc	8b 45 0c	 mov	 eax, DWORD PTR _lpAltarObj$1$[ebp]
  000cf	83 c4 10	 add	 esp, 16			; 00000010H
  000d2	c6 45 fc 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  000d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfNPC_Altar@@3VCCrywolfAltar@@A ; g_CrywolfNPC_Altar
  000db	0f b7 80 90 00
	00 00		 movzx	 eax, WORD PTR [eax+144]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ?GetAltarState@CCrywolfAltar@@QAEHH@Z ; CCrywolfAltar::GetAltarState

; 19635: 	pMsg.btObjIndexH = lpMsg->btObjIndexH;

  000e8	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  000eb	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  000ee	0f b6 4a 04	 movzx	 ecx, BYTE PTR [edx+4]
  000f2	88 4d fe	 mov	 BYTE PTR _pMsg$[ebp+6], cl

; 19636: 	pMsg.btObjIndexL = lpMsg->btObjIndexL;

  000f5	0f b6 4a 05	 movzx	 ecx, BYTE PTR [edx+5]
  000f9	88 4d ff	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 19637: 
; 19638: 	if ( pMsg.btAltarState == 0 && 
; 19639: 		 lpObj->Type == OBJ_USER &&
; 19640: 		 lpObj->Class == CLASS_ELF &&

  000fc	84 c0		 test	 al, al
  000fe	75 3f		 jne	 SHORT $LN6@CGReqAlatr
  00100	80 7b 50 01	 cmp	 BYTE PTR [ebx+80], 1
  00104	75 39		 jne	 SHORT $LN6@CGReqAlatr
  00106	66 83 bb 90 00
	00 00 02	 cmp	 WORD PTR [ebx+144], 2
  0010e	75 2f		 jne	 SHORT $LN6@CGReqAlatr
  00110	b8 04 01 00 00	 mov	 eax, 260		; 00000104H
  00115	66 39 83 96 00
	00 00		 cmp	 WORD PTR [ebx+150], ax
  0011c	7c 21		 jl	 SHORT $LN6@CGReqAlatr

; 19641: 		 lpObj->Level >= MIN_ELF_LEVEL_ALTAR )
; 19642: 	{
; 19643: 		if ( g_CrywolfNPC_Altar.SetAltarUserIndex(iAltarIndex, lpAltarObj->Class, iIndex) != FALSE )

  0011e	8b 45 0c	 mov	 eax, DWORD PTR _lpAltarObj$1$[ebp]
  00121	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfNPC_Altar@@3VCCrywolfAltar@@A ; g_CrywolfNPC_Altar
  00126	56		 push	 esi
  00127	0f b7 80 90 00
	00 00		 movzx	 eax, WORD PTR [eax+144]
  0012e	50		 push	 eax
  0012f	57		 push	 edi
  00130	e8 00 00 00 00	 call	 ?SetAltarUserIndex@CCrywolfAltar@@QAEHHHH@Z ; CCrywolfAltar::SetAltarUserIndex
  00135	85 c0		 test	 eax, eax
  00137	74 1f		 je	 SHORT $LN7@CGReqAlatr

; 19644: 		{
; 19645: 			pMsg.btResult = 1;

  00139	c6 45 fc 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 19646: 		}
; 19647: 	}
; 19648: 	else

  0013d	eb 19		 jmp	 SHORT $LN7@CGReqAlatr
$LN6@CGReqAlatr:

; 19649: 	{
; 19650: 		MsgOutput(iIndex, lMsg.Get(MSGGET(13, 9)));

  0013f	68 09 0d 00 00	 push	 3337			; 00000d09H
  00144	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00149	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0014e	50		 push	 eax
  0014f	56		 push	 esi
  00150	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00155	83 c4 08	 add	 esp, 8
$LN7@CGReqAlatr:

; 19651: 	}
; 19652: 
; 19653: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00158	6a 08		 push	 8
  0015a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0015d	50		 push	 eax
  0015e	56		 push	 esi
  0015f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00164	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@CGReqAlatr:
  00167	5b		 pop	 ebx
$LN1@CGReqAlatr:
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi

; 19654: }

  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z ENDP ; CGReqAlatrContract
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCrywolfInfo@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_iIndex$ = 8						; size = 4
_btOccupationState$ = 12				; size = 1
_btCrywolfState$ = 16					; size = 1
?GCAnsCrywolfInfo@@YAXHEE@Z PROC			; GCAnsCrywolfInfo, COMDAT

; 19589: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19590: 	PMSG_ANS_CRYWOLF_INFO pMsg={0};
; 19591: 
; 19592: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBD, 0x00, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	6a 00		 push	 0
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  00011	68 bd 00 00 00	 push	 189			; 000000bdH
  00016	50		 push	 eax
  00017	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
  0001e	c6 45 fd 00	 mov	 BYTE PTR _pMsg$[ebp+5], 0
  00022	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19593: 	pMsg.btOccupationState = btOccupationState;

  00027	8a 45 0c	 mov	 al, BYTE PTR _btOccupationState$[ebp]
  0002a	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 19594: 	pMsg.btCrywolfState = btCrywolfState;

  0002d	8a 45 10	 mov	 al, BYTE PTR _btCrywolfState$[ebp]
  00030	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 19595: 	
; 19596: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00033	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00036	6a 06		 push	 6
  00038	50		 push	 eax
  00039	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  0003c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00041	83 c4 1c	 add	 esp, 28			; 0000001cH

; 19597: }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?GCAnsCrywolfInfo@@YAXHEE@Z ENDP			; GCAnsCrywolfInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z PROC ; CGReqCrywolfInfo, COMDAT

; 19579: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 19580: 	if ( !OBJMAX_RANGE(iIndex))

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 2e		 js	 SHORT $LN1@CGReqCrywo
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 1f		 je	 SHORT $LN1@CGReqCrywo

; 19581: 		return;
; 19582: 
; 19583: 	LPOBJ lpObj = &gObj[iIndex];
; 19584: 	GCAnsCrywolfInfo(iIndex, g_CrywolfSync.GetOccupationState(), g_CrywolfSync.GetCrywolfState());

  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0001f	e8 00 00 00 00	 call	 ?GetCrywolfState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetCrywolfState
  00024	50		 push	 eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CrywolfSync@@3VCCrywolfSync@@A ; g_CrywolfSync
  0002a	e8 00 00 00 00	 call	 ?GetOccupationState@CCrywolfSync@@QAEHXZ ; CCrywolfSync::GetOccupationState
  0002f	50		 push	 eax
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ?GCAnsCrywolfInfo@@YAXHEE@Z ; GCAnsCrywolfInfo
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGReqCrywo:
  00039	5e		 pop	 esi

; 19585: }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z ENDP ; CGReqCrywolfInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsJewelUnMix@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
?GCAnsJewelUnMix@@YAXHH@Z PROC				; GCAnsJewelUnMix, COMDAT

; 19566: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19567: 	PMSG_ANS_JEWEL_UNMIX pMsg;
; 19568: 
; 19569: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBC, 0x01, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 bc 00 00 00	 push	 188			; 000000bcH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19570: 	pMsg.btResult = iResult;

  00018	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  0001b	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 19571: 
; 19572: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0001e	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00021	6a 05		 push	 5
  00023	50		 push	 eax
  00024	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00027	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 19573: }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?GCAnsJewelUnMix@@YAXHH@Z ENDP				; GCAnsJewelUnMix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z PROC	; CGReqJewelUnMix, COMDAT

; 19555: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19556: 	if ( lpMsg == NULL )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1a		 je	 SHORT $LN1@CGReqJewel

; 19557: 		return;
; 19558: 
; 19559: 	CJewelMixSystem::UnMixJewel(iIndex, lpMsg->btJewelType, lpMsg->btJewelLevel, lpMsg->btJewelPos);

  0000a	0f b6 41 06	 movzx	 eax, BYTE PTR [ecx+6]
  0000e	50		 push	 eax
  0000f	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  00013	50		 push	 eax
  00014	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00018	50		 push	 eax
  00019	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  0001c	e8 00 00 00 00	 call	 ?UnMixJewel@CJewelMixSystem@@SAHHHHH@Z ; CJewelMixSystem::UnMixJewel
  00021	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@CGReqJewel:

; 19560: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z ENDP	; CGReqJewelUnMix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsJewelMix@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
?GCAnsJewelMix@@YAXHH@Z PROC				; GCAnsJewelMix, COMDAT

; 19543: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19544: 	PMSG_ANS_JEWEL_UNMIX pMsg;
; 19545: 
; 19546: 	PHeadSubSetB((LPBYTE)&pMsg, 0xBC, 0x00, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 00		 push	 0
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 bc 00 00 00	 push	 188			; 000000bcH
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19547: 	pMsg.btResult = iResult;

  00018	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  0001b	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 19548: 
; 19549: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0001e	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00021	6a 05		 push	 5
  00023	50		 push	 eax
  00024	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00027	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 19550: }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?GCAnsJewelMix@@YAXHH@Z ENDP				; GCAnsJewelMix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z PROC	; CGReqJewelMix, COMDAT

; 19527: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19528: 	if ( lpMsg == NULL )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 15		 je	 SHORT $LN1@CGReqJewel

; 19529: 		return;
; 19530: 
; 19531: 	CJewelMixSystem::MixJewel(iIndex, lpMsg->btJewelType, lpMsg->btJewelMix);

  0000a	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  0000e	50		 push	 eax
  0000f	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00013	50		 push	 eax
  00014	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  00017	e8 00 00 00 00	 call	 ?MixJewel@CJewelMixSystem@@SAHHHH@Z ; CJewelMixSystem::MixJewel
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGReqJewel:

; 19532: }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z ENDP	; CGReqJewelMix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z
_TEXT	SEGMENT
_pMsg$1 = -52						; size = 36
_szGuildName$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z PROC ; CGReqGuildMarkOfCastleOwner, COMDAT

; 19499: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 19500: 	if ( !OBJMAX_RANGE(iIndex) )

  00014	85 f6		 test	 esi, esi
  00016	0f 88 80 00 00
	00		 js	 $LN4@CGReqGuild
  0001c	33 c0		 xor	 eax, eax
  0001e	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	74 71		 je	 SHORT $LN4@CGReqGuild

; 19501: 		return;
; 19502: 
; 19503: 	LPOBJ lpObj = &gObj[iIndex];
; 19504: 	char szGuildName[MAX_GUILD_LEN+1] = {0};
; 19505: 
; 19506: 	memcpy(szGuildName, g_CastleSiegeSync.GetCastleOwnerGuild(), MAX_GUILD_LEN);

  0002b	a1 18 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+24
  00030	0f 57 c0	 xorps	 xmm0, xmm0
  00033	66 0f d6 45 f1	 movq	 QWORD PTR _szGuildName$[ebp+1], xmm0

; 19507: 
; 19508: 	if ( szGuildName )
; 19509: 	{
; 19510: 		_GUILD_INFO_STRUCT * lpGuild = Guild.SearchGuild(szGuildName);

  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  0003d	89 45 f0	 mov	 DWORD PTR _szGuildName$[ebp], eax
  00040	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+28
  00045	89 45 f4	 mov	 DWORD PTR _szGuildName$[ebp+4], eax
  00048	8d 45 f0	 lea	 eax, DWORD PTR _szGuildName$[ebp]
  0004b	57		 push	 edi
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00052	8b f8		 mov	 edi, eax

; 19511: 
; 19512: 		if ( lpGuild != NULL )

  00054	85 ff		 test	 edi, edi
  00056	74 43		 je	 SHORT $LN10@CGReqGuild

; 19513: 		{
; 19514: 			PMSG_ANS_GUILDMARK_OF_CASTLEOWNER pMsg = {0};
; 19515: 
; 19516: 			PHeadSubSetB((LPBYTE)&pMsg, 0xB9, 0x02, sizeof(pMsg));

  00058	6a 24		 push	 36			; 00000024H
  0005a	6a 02		 push	 2
  0005c	0f 57 c0	 xorps	 xmm0, xmm0
  0005f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pMsg$1[ebp+32], 0
  00066	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00069	68 b9 00 00 00	 push	 185			; 000000b9H
  0006e	50		 push	 eax
  0006f	0f 11 45 cc	 movups	 XMMWORD PTR _pMsg$1[ebp], xmm0
  00073	0f 11 45 dc	 movups	 XMMWORD PTR _pMsg$1[ebp+16], xmm0
  00077	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19517: 			memcpy(pMsg.GuildMarkOfCastleOwner, lpGuild->Mark, sizeof(pMsg.GuildMarkOfCastleOwner));

  0007c	0f 10 47 0d	 movups	 xmm0, XMMWORD PTR [edi+13]

; 19518: 
; 19519: 			DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00080	6a 24		 push	 36			; 00000024H
  00082	8d 45 cc	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00085	0f 11 45 d0	 movups	 XMMWORD PTR _pMsg$1[ebp+4], xmm0
  00089	50		 push	 eax
  0008a	0f 10 47 1d	 movups	 xmm0, XMMWORD PTR [edi+29]
  0008e	56		 push	 esi
  0008f	0f 11 45 e0	 movups	 XMMWORD PTR _pMsg$1[ebp+20], xmm0
  00093	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00098	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN10@CGReqGuild:
  0009b	5f		 pop	 edi
$LN4@CGReqGuild:

; 19520: 		}
; 19521: 	}
; 19522: }

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	33 cd		 xor	 ecx, ebp
  000a1	5e		 pop	 esi
  000a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z ENDP ; CGReqGuildMarkOfCastleOwner
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z
_TEXT	SEGMENT
_btTargetX$ = -1					; size = 1
_aRecv$ = 8						; size = 4
_iIndex$ = 12						; size = 4
_btTargetY$ = 15					; size = 1
?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z PROC ; CGReqWeaponDamageValue, COMDAT

; 19469: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 19470: 	if ( !OBJMAX_RANGE(iIndex) )

  00005	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00008	85 f6		 test	 esi, esi
  0000a	0f 88 86 00 00
	00		 js	 $LN4@CGReqWeapo
  00010	33 c0		 xor	 eax, eax
  00012	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00018	0f 9e c0	 setle	 al
  0001b	85 c0		 test	 eax, eax
  0001d	74 77		 je	 SHORT $LN4@CGReqWeapo

; 19471: 		return;
; 19472: 
; 19473: 	BYTE btTargetX = 0;
; 19474: 	BYTE btTargetY = 0;
; 19475: 	WORD wObjIndex = MAKE_NUMBERW(aRecv->btObjIndexH, aRecv->btObjIndexL);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00022	57		 push	 edi
  00023	c6 45 ff 00	 mov	 BYTE PTR _btTargetX$[ebp], 0
  00027	c6 45 0f 00	 mov	 BYTE PTR _btTargetY$[ebp], 0
  0002b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0002f	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00033	66 c1 e1 08	 shl	 cx, 8
  00037	66 0b c8	 or	 cx, ax

; 19476: 
; 19477: 	if ( g_CsNPC_Weapon.GetWeaponCalDamageInfo(wObjIndex, btTargetX, btTargetY) == TRUE )

  0003a	8d 45 0f	 lea	 eax, DWORD PTR _btTargetY$[ebp]
  0003d	50		 push	 eax
  0003e	8d 45 ff	 lea	 eax, DWORD PTR _btTargetX$[ebp]
  00041	0f b7 f9	 movzx	 edi, cx
  00044	50		 push	 eax
  00045	57		 push	 edi
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  0004b	e8 00 00 00 00	 call	 ?GetWeaponCalDamageInfo@CWeapon@@QAEHGAAE0@Z ; CWeapon::GetWeaponCalDamageInfo
  00050	83 f8 01	 cmp	 eax, 1
  00053	75 27		 jne	 SHORT $LN3@CGReqWeapo

; 19478: 	{
; 19479: 		gObjNotifyUseWeaponDamage(&gObj[wObjIndex], btTargetX, btTargetY);

  00055	0f b6 45 0f	 movzx	 eax, BYTE PTR _btTargetY$[ebp]
  00059	50		 push	 eax
  0005a	0f b6 45 ff	 movzx	 eax, BYTE PTR _btTargetX$[ebp]
  0005e	50		 push	 eax
  0005f	8b c7		 mov	 eax, edi
  00061	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00067	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?gObjNotifyUseWeaponDamage@@YAXPAUOBJECTSTRUCT@@HH@Z ; gObjNotifyUseWeaponDamage
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi

; 19484: 	}
; 19485: }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN3@CGReqWeapo:

; 19480: 	}
; 19481: 	else
; 19482: 	{
; 19483: 		MsgOutput(iIndex, lMsg.Get(MSGGET(6, 112)));

  0007c	68 70 06 00 00	 push	 1648			; 00000670H
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00086	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0008b	50		 push	 eax
  0008c	56		 push	 esi
  0008d	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00092	83 c4 08	 add	 esp, 8
  00095	5f		 pop	 edi
$LN4@CGReqWeapo:
  00096	5e		 pop	 esi

; 19484: 	}
; 19485: }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z ENDP ; CGReqWeaponDamageValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z
_TEXT	SEGMENT
_lpWeaponObj$1$ = -32					; size = 4
_lpOwnerObj$1$ = -28					; size = 4
_wObjIndex$1$ = -24					; size = 4
_pMsg$ = -20						; size = 10
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z PROC	; CGReqWeaponUse, COMDAT

; 19404: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 19405: 	WORD wObjIndex = MAKE_NUMBERW(aRecv->btObjIndexH, aRecv->btObjIndexL);

  00018	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  0001c	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00020	66 c1 e1 08	 shl	 cx, 8
  00024	66 0b c8	 or	 cx, ax

; 19406: 
; 19407: 	if ( !OBJMAX_RANGE(wObjIndex))

  00027	b8 eb 2c 00 00	 mov	 eax, 11499		; 00002cebH
  0002c	0f b7 d1	 movzx	 edx, cx
  0002f	66 3b c2	 cmp	 ax, dx
  00032	89 55 e8	 mov	 DWORD PTR _wObjIndex$1$[ebp], edx
  00035	1b c0		 sbb	 eax, eax
  00037	83 c0 01	 add	 eax, 1
  0003a	0f 84 4b 01 00
	00		 je	 $LN1@CGReqWeapo

; 19408: 		return;
; 19409: 
; 19410: 	if ( !OBJMAX_RANGE(iIndex))

  00040	85 db		 test	 ebx, ebx
  00042	0f 88 43 01 00
	00		 js	 $LN1@CGReqWeapo
  00048	33 c0		 xor	 eax, eax
  0004a	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00050	0f 9e c0	 setle	 al
  00053	85 c0		 test	 eax, eax
  00055	0f 84 30 01 00
	00		 je	 $LN1@CGReqWeapo

; 19411: 		return;
; 19412: 
; 19413: 	LPOBJ lpOwnerObj = &gObj[iIndex];

  0005b	69 c3 40 27 00
	00		 imul	 eax, ebx, 10048
  00061	56		 push	 esi
  00062	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00068	89 45 e4	 mov	 DWORD PTR _lpOwnerObj$1$[ebp], eax

; 19414: 	LPOBJ lpWeaponObj = &gObj[wObjIndex];

  0006b	0f b7 c2	 movzx	 eax, dx
  0006e	69 f0 40 27 00
	00		 imul	 esi, eax, 10048

; 19415: 
; 19416: 	if ( lpOwnerObj->Type != OBJ_USER )

  00074	8b 45 e4	 mov	 eax, DWORD PTR _lpOwnerObj$1$[ebp]
  00077	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007d	80 78 50 01	 cmp	 BYTE PTR [eax+80], 1
  00081	89 75 e0	 mov	 DWORD PTR _lpWeaponObj$1$[ebp], esi
  00084	0f 85 00 01 00
	00		 jne	 $LN24@CGReqWeapo

; 19417: 		return;
; 19418: 
; 19419: 	if ( lpWeaponObj->Type != OBJ_NPC )

  0008a	80 7e 50 03	 cmp	 BYTE PTR [esi+80], 3
  0008e	0f 85 f6 00 00
	00		 jne	 $LN24@CGReqWeapo

; 19420: 		return;
; 19421: 
; 19422: 	PMSG_ANS_USEWEAPON pMsg = {0};
; 19423: 
; 19424: 	PHeadSubSetB((LPBYTE)&pMsg, 0xB7, 0x01, sizeof(pMsg));

  00094	6a 0a		 push	 10			; 0000000aH
  00096	6a 01		 push	 1
  00098	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009b	c6 45 ec 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  0009f	0f 57 c0	 xorps	 xmm0, xmm0
  000a2	c6 45 f5 00	 mov	 BYTE PTR _pMsg$[ebp+9], 0
  000a6	68 b7 00 00 00	 push	 183			; 000000b7H
  000ab	50		 push	 eax
  000ac	66 0f d6 45 ed	 movq	 QWORD PTR _pMsg$[ebp+1], xmm0
  000b1	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 19425: 	pMsg.btResult = 1;

  000b6	c6 45 f0 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 19426: 
; 19427: 	if ( lpWeaponObj->Class == 221 )	// Slingshot attack

  000ba	b9 dd 00 00 00	 mov	 ecx, 221		; 000000ddH
  000bf	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  000c6	83 c4 10	 add	 esp, 16			; 00000010H
  000c9	66 3b c1	 cmp	 ax, cx
  000cc	75 06		 jne	 SHORT $LN9@CGReqWeapo

; 19428: 	{
; 19429: 		pMsg.btWeaponType = 1;

  000ce	c6 45 f3 01	 mov	 BYTE PTR _pMsg$[ebp+7], 1

; 19430: 		pMsg.btObjIndexH = SET_NUMBERH(wObjIndex);
; 19431: 		pMsg.btObjIndexL = SET_NUMBERL(wObjIndex);
; 19432: 		g_CsNPC_Weapon.GetTargetPointXY(lpWeaponObj->Class, aRecv->btTargetIndex-1, pMsg.btPointX, pMsg.btPointY, TRUE);

  000d2	eb 0e		 jmp	 SHORT $LN25@CGReqWeapo
$LN9@CGReqWeapo:

; 19433: 	}
; 19434: 	else if( lpWeaponObj->Class == 222 )	// Slingshot defense

  000d4	b9 de 00 00 00	 mov	 ecx, 222		; 000000deH
  000d9	66 3b c1	 cmp	 ax, cx
  000dc	75 34		 jne	 SHORT $LN11@CGReqWeapo

; 19435: 	{
; 19436: 		pMsg.btWeaponType = 2;

  000de	c6 45 f3 02	 mov	 BYTE PTR _pMsg$[ebp+7], 2
$LN25@CGReqWeapo:

; 19437: 		pMsg.btObjIndexH = SET_NUMBERH(wObjIndex);

  000e2	8b 4d e8	 mov	 ecx, DWORD PTR _wObjIndex$1$[ebp]
  000e5	8b c1		 mov	 eax, ecx
  000e7	c1 e8 08	 shr	 eax, 8
  000ea	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 19438: 		pMsg.btObjIndexL = SET_NUMBERL(wObjIndex);
; 19439: 		g_CsNPC_Weapon.GetTargetPointXY(lpWeaponObj->Class, aRecv->btTargetIndex-1, pMsg.btPointX, pMsg.btPointY, TRUE);

  000ed	8d 45 f5	 lea	 eax, DWORD PTR _pMsg$[ebp+9]
  000f0	6a 01		 push	 1
  000f2	50		 push	 eax
  000f3	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp+8]
  000f6	88 4d f2	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  000f9	50		 push	 eax
  000fa	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  000fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  00103	48		 dec	 eax
  00104	50		 push	 eax
  00105	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ?GetTargetPointXY@CWeapon@@QAEHHHAAE0H@Z ; CWeapon::GetTargetPointXY
$LN11@CGReqWeapo:

; 19440: 	}
; 19441: 
; 19442: 	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00112	6a 0a		 push	 10			; 0000000aH
  00114	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00117	50		 push	 eax
  00118	53		 push	 ebx
  00119	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19443: 
; 19444: 	pMsg.btResult = 2;

  00121	c6 45 f0 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
  00125	81 c6 4a 0c 00
	00		 add	 esi, 3146		; 00000c4aH
  0012b	bf 4b 00 00 00	 mov	 edi, 75			; 0000004bH
$LL4@CGReqWeapo:

; 19447: 	{
; 19448: 		if ( lpWeaponObj->VpPlayer2[n].type == OBJ_USER )

  00130	80 7e 02 01	 cmp	 BYTE PTR [esi+2], 1
  00134	75 1c		 jne	 SHORT $LN2@CGReqWeapo

; 19449: 		{
; 19450: 			if ( lpWeaponObj->VpPlayer2[n].state )

  00136	80 7e fe 00	 cmp	 BYTE PTR [esi-2], 0
  0013a	74 16		 je	 SHORT $LN2@CGReqWeapo

; 19451: 			{
; 19452: 				if ( iIndex != lpWeaponObj->VpPlayer2[n].number )

  0013c	0f bf 06	 movsx	 eax, WORD PTR [esi]
  0013f	3b d8		 cmp	 ebx, eax
  00141	74 0f		 je	 SHORT $LN2@CGReqWeapo

; 19453: 				{
; 19454: 					DataSend(lpWeaponObj->VpPlayer2[n].number, (LPBYTE)&pMsg, sizeof(pMsg));

  00143	6a 0a		 push	 10			; 0000000aH
  00145	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00148	51		 push	 ecx
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGReqWeapo:

; 19445: 
; 19446: 	for ( int n=0;n<MAX_VIEWPORT;n++)

  00152	83 c6 0c	 add	 esi, 12			; 0000000cH
  00155	83 ef 01	 sub	 edi, 1
  00158	75 d6		 jne	 SHORT $LL4@CGReqWeapo

; 19455: 				}
; 19456: 			}
; 19457: 		}
; 19458: 	}
; 19459: 
; 19460: 	gObjNotifyUseWeaponV1(lpOwnerObj, lpWeaponObj, pMsg.btPointX, pMsg.btPointY);

  0015a	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMsg$[ebp+9]
  0015e	50		 push	 eax
  0015f	0f b6 45 f4	 movzx	 eax, BYTE PTR _pMsg$[ebp+8]
  00163	50		 push	 eax
  00164	ff 75 e0	 push	 DWORD PTR _lpWeaponObj$1$[ebp]
  00167	ff 75 e4	 push	 DWORD PTR _lpOwnerObj$1$[ebp]
  0016a	e8 00 00 00 00	 call	 ?gObjNotifyUseWeaponV1@@YAXPAUOBJECTSTRUCT@@0HH@Z ; gObjNotifyUseWeaponV1
  0016f	83 c4 10	 add	 esp, 16			; 00000010H

; 19461: 	g_CsNPC_Weapon.SetWeaponCalDamageInfo(wObjIndex, pMsg.btPointX, pMsg.btPointY, 10000);

  00172	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  00177	68 10 27 00 00	 push	 10000			; 00002710H
  0017c	ff 75 f5	 push	 DWORD PTR _pMsg$[ebp+9]
  0017f	ff 75 f4	 push	 DWORD PTR _pMsg$[ebp+8]
  00182	ff 75 e8	 push	 DWORD PTR _wObjIndex$1$[ebp]
  00185	e8 00 00 00 00	 call	 ?SetWeaponCalDamageInfo@CWeapon@@QAEHGEEH@Z ; CWeapon::SetWeaponCalDamageInfo
$LN24@CGReqWeapo:
  0018a	5e		 pop	 esi
$LN1@CGReqWeapo:

; 19462: }

  0018b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018e	5f		 pop	 edi
  0018f	33 cd		 xor	 ecx, ebp
  00191	5b		 pop	 ebx
  00192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c3		 ret	 0
?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z ENDP	; CGReqWeaponUse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z
_TEXT	SEGMENT
_iCount$ = -1032					; size = 4
_cBUFFER$ = -1028					; size = 1022
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z PROC ; CGReqCsAttkGuildList, COMDAT

; 19359: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 04 00
	00		 sub	 esp, 1032		; 00000408H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 19360: #if (GS_CASTLE==1)
; 19361: 
; 19362: 	if(lpMsg == NULL)

  00013	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00017	74 7e		 je	 SHORT $LN1@CGReqCsAtt

; 19363: 		return;
; 19364: 
; 19365: 	char cBUFFER[0x3FE];
; 19366: 
; 19367: 	PMSG_ANS_CSATTKGUILDLIST * lpMsgSend = (PMSG_ANS_CSATTKGUILDLIST *)cBUFFER;
; 19368: 	PMSG_CSATTKGUILDLIST * lpMsgSendBody = (PMSG_CSATTKGUILDLIST*)&cBUFFER[sizeof(PMSG_ANS_CSATTKGUILDLIST)];
; 19369: 
; 19370: 	int iCount = 0;
; 19371: 
; 19372: 	lpMsgSend->btResult = g_CastleSiege.GetCsAttkGuildList(lpMsgSendBody,&iCount);

  00019	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _iCount$[ebp]
  0001f	c7 85 f8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _iCount$[ebp], 0
  00029	50		 push	 eax
  0002a	8d 85 08 fc ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp+12]
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?GetCsAttkGuildList@CCastleSiege@@QAEHPAUPMSG_CSATTKGUILDLIST@@PAH@Z ; CCastleSiege::GetCsAttkGuildList

; 19373: 	lpMsgSend->iCount = iCount;

  0003b	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _iCount$[ebp]
  00041	88 85 00 fc ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+4], al

; 19374: 
; 19375: 	if(lpMsgSend->iCount < 0)

  00047	85 c9		 test	 ecx, ecx
  00049	79 04		 jns	 SHORT $LN3@CGReqCsAtt

; 19376: 		lpMsgSend->iCount = 0;

  0004b	33 c9		 xor	 ecx, ecx

; 19377: 
; 19378: 	if(lpMsgSend->iCount > 100)

  0004d	eb 0a		 jmp	 SHORT $LN8@CGReqCsAtt
$LN3@CGReqCsAtt:
  0004f	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00054	3b c8		 cmp	 ecx, eax
  00056	0f 4f c8	 cmovg	 ecx, eax
$LN8@CGReqCsAtt:
  00059	89 8d 04 fc ff
	ff		 mov	 DWORD PTR _cBUFFER$[ebp+8], ecx

; 19379: 		lpMsgSend->iCount = 100;
; 19380: 
; 19381: 	lpMsgSend->h.set((PBYTE)lpMsgSend,0xB5,sizeof(PMSG_CSATTKGUILDLIST) * lpMsgSend->iCount + sizeof(PMSG_ANS_CSATTKGUILDLIST));

  0005f	c1 e1 04	 shl	 ecx, 4
  00062	83 c1 0c	 add	 ecx, 12			; 0000000cH
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 111  : 		lpBuf[0] = 0xC2;

  00065	c6 85 fc fb ff
	ff c2		 mov	 BYTE PTR _cBUFFER$[ebp], 194 ; 000000c2H

; 112  : 		lpBuf[1] = SET_NUMBERH(size);

  0006c	8b c1		 mov	 eax, ecx

; 113  : 		lpBuf[2] = SET_NUMBERL(size);

  0006e	88 8d fe fb ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+2], cl
  00074	c1 e8 08	 shr	 eax, 8
  00077	88 85 fd fb ff
	ff		 mov	 BYTE PTR _cBUFFER$[ebp+1], al
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19382: 	DataSend(iIndex,(PBYTE)lpMsgSend,sizeof(PMSG_CSATTKGUILDLIST) * lpMsgSend->iCount + sizeof(PMSG_ANS_CSATTKGUILDLIST));

  0007d	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  00083	51		 push	 ecx
  00084	50		 push	 eax
  00085	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 114  : 		lpBuf[3] = head;

  00088	c6 85 ff fb ff
	ff b5		 mov	 BYTE PTR _cBUFFER$[ebp+3], 181 ; 000000b5H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19382: 	DataSend(iIndex,(PBYTE)lpMsgSend,sizeof(PMSG_CSATTKGUILDLIST) * lpMsgSend->iCount + sizeof(PMSG_ANS_CSATTKGUILDLIST));

  0008f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGReqCsAtt:

; 19383: 
; 19384: #endif
; 19385: }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	33 cd		 xor	 ecx, ebp
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z ENDP ; CGReqCsAttkGuildList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z PROC ; CGReqCsRegGuildList, COMDAT

; 19340: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19341: #if (GS_CASTLE==1)
; 19342: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	74 22		 je	 SHORT $LN1@CGReqCsReg
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  00009	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0000e	85 c0		 test	 eax, eax
  00010	74 0d		 je	 SHORT $LN5@CGReqCsReg

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00012	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19345: 	GS_GDReqAllGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

  00016	89 45 08	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 19346: #endif
; 19347: }

  00019	5d		 pop	 ebp

; 19345: 	GS_GDReqAllGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

  0001a	e9 00 00 00 00	 jmp	 ?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqAllGuildMarkRegInfo
$LN5@CGReqCsReg:
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 59   : 		return -1;

  0001f	83 c8 ff	 or	 eax, -1
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19345: 	GS_GDReqAllGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

  00022	89 45 08	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 19346: #endif
; 19347: }

  00025	5d		 pop	 ebp

; 19345: 	GS_GDReqAllGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

  00026	e9 00 00 00 00	 jmp	 ?GS_GDReqAllGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqAllGuildMarkRegInfo
$LN1@CGReqCsReg:

; 19346: #endif
; 19347: }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z ENDP ; CGReqCsRegGuildList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z
_TEXT	SEGMENT
tv140 = -20						; size = 4
_pMsgResult$1 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z PROC	; CGReqNpcDbList, COMDAT

; 19301: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00014	57		 push	 edi

; 19302: #if (GS_CASTLE==1)
; 19303: 	if(lpMsg == NULL)

  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00018	85 ff		 test	 edi, edi
  0001a	0f 84 16 01 00
	00		 je	 $LN2@CGReqNpcDb

; 19304: 		return;
; 19305: 
; 19306: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002a	53		 push	 ebx
  0002b	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00031	05 1c 06 00 00	 add	 eax, 1564		; 0000061cH
  00036	03 c3		 add	 eax, ebx
  00038	89 45 ec	 mov	 DWORD PTR tv140[ebp], eax
  0003b	0f 1f 44 00 00	 npad	 5
$LL13@CGReqNpcDb:
  00040	8a 10		 mov	 dl, BYTE PTR [eax]
  00042	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00044	75 1a		 jne	 SHORT $LN14@CGReqNpcDb
  00046	84 d2		 test	 dl, dl
  00048	74 12		 je	 SHORT $LN15@CGReqNpcDb
  0004a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0004d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00050	75 0e		 jne	 SHORT $LN14@CGReqNpcDb
  00052	83 c0 02	 add	 eax, 2
  00055	83 c1 02	 add	 ecx, 2
  00058	84 d2		 test	 dl, dl
  0005a	75 e4		 jne	 SHORT $LL13@CGReqNpcDb
$LN15@CGReqNpcDb:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 05		 jmp	 SHORT $LN16@CGReqNpcDb
$LN14@CGReqNpcDb:
  00060	1b c0		 sbb	 eax, eax
  00062	83 c8 01	 or	 eax, 1
$LN16@CGReqNpcDb:
  00065	85 c0		 test	 eax, eax
  00067	0f 84 c8 00 00
	00		 je	 $LN17@CGReqNpcDb

; 19307: 		return;
; 19308: 
; 19309: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE ||

  0006d	ff 75 ec	 push	 DWORD PTR tv140[ebp]
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00075	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00080	85 c0		 test	 eax, eax
  00082	74 67		 je	 SHORT $LN7@CGReqNpcDb
  00084	8b 84 0b 28 06
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+1576]
  0008b	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00090	74 05		 je	 SHORT $LN6@CGReqNpcDb
  00092	83 f8 40	 cmp	 eax, 64			; 00000040H
  00095	75 54		 jne	 SHORT $LN7@CGReqNpcDb
$LN6@CGReqNpcDb:

; 19321: 		return;
; 19322: 	}
; 19323: 
; 19324: 	switch(lpMsg->btMonsterCode)

  00097	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0009b	83 e8 01	 sub	 eax, 1
  0009e	74 2a		 je	 SHORT $LN8@CGReqNpcDb
  000a0	83 e8 01	 sub	 eax, 1
  000a3	0f 85 8c 00 00
	00		 jne	 $LN17@CGReqNpcDb

; 19328: 		break;
; 19329: 	case 2:
; 19330: 		g_CastleSiege.SendNpcStateList(iIndex,283);

  000a9	68 1b 01 00 00	 push	 283			; 0000011bH
  000ae	56		 push	 esi
  000af	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b4	e8 00 00 00 00	 call	 ?SendNpcStateList@CCastleSiege@@QAEXHH@Z ; CCastleSiege::SendNpcStateList
  000b9	5b		 pop	 ebx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi

; 19331: 		break;
; 19332: 	}
; 19333: 
; 19334: #endif
; 19335: }

  000bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bf	33 cd		 xor	 ecx, ebp
  000c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
$LN8@CGReqNpcDb:

; 19325: 	{
; 19326: 	case 1:
; 19327: 		g_CastleSiege.SendNpcStateList(iIndex,277);

  000ca	68 15 01 00 00	 push	 277			; 00000115H
  000cf	56		 push	 esi
  000d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000d5	e8 00 00 00 00	 call	 ?SendNpcStateList@CCastleSiege@@QAEXHH@Z ; CCastleSiege::SendNpcStateList
  000da	5b		 pop	 ebx
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi

; 19331: 		break;
; 19332: 	}
; 19333: 
; 19334: #endif
; 19335: }

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e0	33 cd		 xor	 ecx, ebp
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
$LN7@CGReqNpcDb:

; 19310: 		(gObj[iIndex].GuildStatus != G_MASTER && gObj[iIndex].GuildStatus != G_SUB_MASTER))
; 19311: 	{
; 19312: 		PMSG_ANS_NPCDBLIST pMsgResult;
; 19313: 
; 19314: 		LogAddC(2,"[CastleSiege] CGReqNpcDbList() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",

  000eb	ff b4 0b 28 06
	00 00		 push	 DWORD PTR [ebx+ecx+1576]
  000f2	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  000f8	03 c3		 add	 eax, ebx
  000fa	50		 push	 eax
  000fb	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000fe	03 c3		 add	 eax, ebx
  00100	50		 push	 eax
  00101	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00104	03 c3		 add	 eax, ebx
  00106	50		 push	 eax
  00107	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@MCHCDEEO@?$FLCastleSiege?$FN?5CGReqNpcDbList?$CI?$CJ?5E@
  0010c	6a 02		 push	 2
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 19320: 		DataSend(iIndex,(PBYTE)&pMsgResult,sizeof(pMsgResult));

  00114	6a 0c		 push	 12			; 0000000cH
  00116	8d 45 f0	 lea	 eax, DWORD PTR _pMsgResult$1[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 111  : 		lpBuf[0] = 0xC2;

  00119	c7 45 f0 c2 00
	0c b3		 mov	 DWORD PTR _pMsgResult$1[ebp], -1291059006 ; b30c00c2H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19320: 		DataSend(iIndex,(PBYTE)&pMsgResult,sizeof(pMsgResult));

  00120	50		 push	 eax
  00121	56		 push	 esi
  00122	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pMsgResult$1[ebp+8], 0
  00129	c6 45 f4 02	 mov	 BYTE PTR _pMsgResult$1[ebp+4], 2
  0012d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00132	83 c4 24	 add	 esp, 36			; 00000024H
$LN17@CGReqNpcDb:
  00135	5b		 pop	 ebx
$LN2@CGReqNpcDb:

; 19331: 		break;
; 19332: 	}
; 19333: 
; 19334: #endif
; 19335: }

  00136	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00139	5f		 pop	 edi
  0013a	33 cd		 xor	 ecx, ebp
  0013c	5e		 pop	 esi
  0013d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c3		 ret	 0
?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z ENDP	; CGReqNpcDbList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_iIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
_btEnterHuntZone$ = 16					; size = 1
?GCAnsCsSetEnterHuntZone@@YAXHEE@Z PROC			; GCAnsCsSetEnterHuntZone, COMDAT

; 19282: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19283: 	PMSG_ANS_CSHUNTZONEENTER pMsgResult;
; 19284: 
; 19285: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1F, sizeof(pMsgResult));
; 19286: 	pMsgResult.btResult = btResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]
  00009	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 19287: 	pMsgResult.btHuntZoneEnter = btEnterHuntZone;

  0000c	8a 45 10	 mov	 al, BYTE PTR _btEnterHuntZone$[ebp]
  0000f	88 45 fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], al

; 19289: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00012	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00015	6a 06		 push	 6
  00017	50		 push	 eax
  00018	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0001b	c7 45 f8 c1 06
	b2 1f		 mov	 DWORD PTR _pMsgResult$[ebp], 531760833 ; 1fb206c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19289: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00022	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19290: }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ENDP			; GCAnsCsSetEnterHuntZone
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z PROC ; CGReqCsSetEnterHuntZone, COMDAT

; 19249: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 19250: #if (GS_CASTLE==1)
; 19251: 	if(gObjIsConnected(iIndex) == FALSE)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 6e		 je	 SHORT $LN1@CGReqCsSet

; 19252: 		return;
; 19253: 
; 19254: 	if(g_CastleSiege.CheckCastleOwnerMember(iIndex) == FALSE)

  00014	57		 push	 edi
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0001a	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  0001f	85 c0		 test	 eax, eax
  00021	75 16		 jne	 SHORT $LN3@CGReqCsSet

; 19255: 	{
; 19256: 		GCAnsCsSetEnterHuntZone(iIndex,2,lpMsg->btHuntZoneEnter);

  00023	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00026	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0002a	50		 push	 eax
  0002b	6a 02		 push	 2
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ; GCAnsCsSetEnterHuntZone
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	5f		 pop	 edi

; 19268: #endif
; 19269: }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN3@CGReqCsSet:

; 19257: 		return;
; 19258: 	}
; 19259: 
; 19260: 	if(g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)

  00039	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0003e	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00043	83 f8 07	 cmp	 eax, 7
  00046	75 16		 jne	 SHORT $LN4@CGReqCsSet

; 19261: 	{
; 19262: 		GCAnsCsSetEnterHuntZone(iIndex,0,lpMsg->btHuntZoneEnter);

  00048	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0004b	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0004f	50		 push	 eax
  00050	6a 00		 push	 0
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ; GCAnsCsSetEnterHuntZone
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	5f		 pop	 edi

; 19268: #endif
; 19269: }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN4@CGReqCsSet:
  0005e	56		 push	 esi

; 19263: 		return;
; 19264: 	}
; 19265: 
; 19266: 	g_CastleSiege.SetHuntZoneEnter(lpMsg->btHuntZoneEnter);

  0005f	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00067	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?SetHuntZoneEnter@CCastleSiege@@QAEXH@Z ; CCastleSiege::SetHuntZoneEnter

; 19267: 	GCAnsCsSetEnterHuntZone(iIndex,1,lpMsg->btHuntZoneEnter);

  00071	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00075	50		 push	 eax
  00076	6a 01		 push	 1
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?GCAnsCsSetEnterHuntZone@@YAXHEE@Z ; GCAnsCsSetEnterHuntZone
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	5e		 pop	 esi
$LN1@CGReqCsSet:
  00082	5f		 pop	 edi

; 19268: #endif
; 19269: }

  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z ENDP ; CGReqCsSetEnterHuntZone
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_iIndex$ = 8						; size = 4
_btHour$ = 12						; size = 1
_btMinute$ = 16						; size = 1
?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z PROC		; GCAnsSelfCsLeftTimeAlarm, COMDAT

; 19228: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19229: 	PMSG_ANS_CSLEFTTIMEALARM pMsgResult;
; 19230: 
; 19231: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1E, sizeof(pMsgResult));
; 19232: 	pMsgResult.btHour = btHour;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btHour$[ebp]

; 19234: 
; 19235: 	if ( !gObjIsConnected(iIndex))

  00009	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  0000c	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0000f	8a 45 10	 mov	 al, BYTE PTR _btMinute$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00012	c7 45 f8 c1 06
	b2 1e		 mov	 DWORD PTR _pMsgResult$[ebp], 514983617 ; 1eb206c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19233: 	pMsgResult.btMinute = btMinute;

  00019	88 45 fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], al

; 19234: 
; 19235: 	if ( !gObjIsConnected(iIndex))

  0001c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	74 14		 je	 SHORT $LN1@GCAnsSelfC

; 19236: 	{
; 19237: 		return;
; 19238: 	}
; 19239: 
; 19240: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00028	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsgResult$[ebp+1]
  0002c	50		 push	 eax
  0002d	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00030	50		 push	 eax
  00031	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00034	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCAnsSelfC:

; 19241: }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?GCAnsSelfCsLeftTimeAlarm@@YAXHEE@Z ENDP		; GCAnsSelfCsLeftTimeAlarm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsLeftTimeAlarm@@YAXEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_btHour$ = 8						; size = 1
_btMinute$ = 12						; size = 1
?GCAnsCsLeftTimeAlarm@@YAXEE@Z PROC			; GCAnsCsLeftTimeAlarm, COMDAT

; 19203: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19204: 	PMSG_ANS_CSLEFTTIMEALARM pMsgResult;
; 19205: 
; 19206: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1E, sizeof(pMsgResult));
; 19207: 	pMsgResult.btHour = btHour;

  00006	8a 45 08	 mov	 al, BYTE PTR _btHour$[ebp]
  00009	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 19208: 	pMsgResult.btMinute = btMinute;

  0000c	8a 45 0c	 mov	 al, BYTE PTR _btMinute$[ebp]
  0000f	56		 push	 esi
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00010	c7 45 f8 c1 06
	b2 1e		 mov	 DWORD PTR _pMsgResult$[ebp], 514983617 ; 1eb206c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19210: 	for (int iIndex = OBJ_STARTUSERINDEX;iIndex < OBJMAX;iIndex++)

  00017	be 04 29 00 00	 mov	 esi, 10500		; 00002904H
  0001c	88 45 fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], al
  0001f	90		 npad	 1
$LL4@GCAnsCsLef:

; 19211: 	{
; 19212: 		if ( !gObjIsConnected(iIndex) )

  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	74 12		 je	 SHORT $LN2@GCAnsCsLef

; 19213: 		{
; 19214: 			continue;
; 19215: 		}
; 19216: 
; 19217: 		DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0002d	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsgResult$[ebp+1]
  00031	50		 push	 eax
  00032	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00035	50		 push	 eax
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCAnsCsLef:

; 19210: 	for (int iIndex = OBJ_STARTUSERINDEX;iIndex < OBJMAX;iIndex++)

  0003f	46		 inc	 esi
  00040	81 fe ec 2c 00
	00		 cmp	 esi, 11500		; 00002cecH
  00046	7c d8		 jl	 SHORT $LL4@GCAnsCsLef
  00048	5e		 pop	 esi

; 19218: 	}
; 19219: 
; 19220: }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?GCAnsCsLeftTimeAlarm@@YAXEE@Z ENDP			; GCAnsCsLeftTimeAlarm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsSendCommand@@YAXHEEEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 8
_iCsJoinSize$ = 8					; size = 4
_btTeam$ = 12						; size = 1
_btX$ = 16						; size = 1
_btY$ = 20						; size = 1
_btCommand$ = 24					; size = 1
?GCAnsCsSendCommand@@YAXHEEEE@Z PROC			; GCAnsCsSendCommand, COMDAT

; 19169: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19170: #if (GS_CASTLE==1)
; 19171: 	PMSG_ANS_CSCOMMAND pMsgResult;
; 19172: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1D, sizeof(pMsgResult));
; 19173: 
; 19174: 	pMsgResult.btTeam = btTeam;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btTeam$[ebp]
  00009	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 19175: 	pMsgResult.btX = btX;

  0000c	8a 45 10	 mov	 al, BYTE PTR _btX$[ebp]
  0000f	53		 push	 ebx
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00010	8b 5d 08	 mov	 ebx, DWORD PTR _iCsJoinSize$[ebp]
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19175: 	pMsgResult.btX = btX;

  00013	88 45 fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], al

; 19176: 	pMsgResult.btY = btY;

  00016	8a 45 14	 mov	 al, BYTE PTR _btY$[ebp]
  00019	56		 push	 esi
  0001a	88 45 fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], al

; 19178: 
; 19179: 	for(int iIndex = OBJ_STARTUSERINDEX; iIndex < OBJMAX; iIndex++)

  0001d	be 04 29 00 00	 mov	 esi, 10500		; 00002904H
  00022	8a 45 18	 mov	 al, BYTE PTR _btCommand$[ebp]
  00025	57		 push	 edi
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00026	c7 45 f8 c1 08
	b2 1d		 mov	 DWORD PTR _pMsgResult$[ebp], 498206913 ; 1db208c1H
  0002d	bf 00 dd 49 06	 mov	 edi, 105504000		; 0649dd00H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19177: 	pMsgResult.btCommand = btCommand;

  00032	88 45 ff	 mov	 BYTE PTR _pMsgResult$[ebp+7], al
$LL4@GCAnsCsSen:

; 19180: 	{
; 19181: 		if(gObjIsConnected(iIndex) == FALSE)

  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003b	83 c4 04	 add	 esp, 4
  0003e	85 c0		 test	 eax, eax
  00040	74 2e		 je	 SHORT $LN2@GCAnsCsSen

; 19182: 			continue;
; 19183: 
; 19184: 		if(gObj[iIndex].m_btCsJoinSide == iCsJoinSize && gObj[iIndex].MapNumber == MAP_INDEX_CASTLESIEGE)

  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00048	0f b6 84 39 5a
	20 00 00	 movzx	 eax, BYTE PTR [ecx+edi+8282]
  00050	3b c3		 cmp	 eax, ebx
  00052	75 1c		 jne	 SHORT $LN2@GCAnsCsSen
  00054	80 bc 39 23 01
	00 00 1e	 cmp	 BYTE PTR [ecx+edi+291], 30 ; 0000001eH
  0005c	75 12		 jne	 SHORT $LN2@GCAnsCsSen

; 19185: 		{
; 19186: 			DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0005e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsgResult$[ebp+1]
  00062	50		 push	 eax
  00063	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00066	50		 push	 eax
  00067	56		 push	 esi
  00068	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCAnsCsSen:

; 19178: 
; 19179: 	for(int iIndex = OBJ_STARTUSERINDEX; iIndex < OBJMAX; iIndex++)

  00070	81 c7 40 27 00
	00		 add	 edi, 10048		; 00002740H
  00076	46		 inc	 esi
  00077	81 ff 00 2f e3
	06		 cmp	 edi, 115552000		; 06e32f00H
  0007d	7c b6		 jl	 SHORT $LL4@GCAnsCsSen
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx

; 19187: 		}
; 19188: 	}
; 19189: #endif
; 19190: }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?GCAnsCsSendCommand@@YAXHEEEE@Z ENDP			; GCAnsCsSendCommand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z PROC	; CGReqCsSendCommand, COMDAT

; 19142: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 19143: #if (GS_CASTLE==1)
; 19144: 	if(gObjIsConnected(iIndex) == FALSE)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 62		 je	 SHORT $LN4@CGReqCsSen

; 19145: 		return;
; 19146: 
; 19147: 	if(gObj[iIndex].m_btCsJoinSide <= 0 || g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE)

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	57		 push	 edi
  0001a	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00020	80 bc 07 5a 20
	00 00 00	 cmp	 BYTE PTR [edi+eax+8282], 0
  00028	76 4b		 jbe	 SHORT $LN7@CGReqCsSen
  0002a	56		 push	 esi
  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00030	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00035	85 c0		 test	 eax, eax
  00037	74 3c		 je	 SHORT $LN7@CGReqCsSen

; 19148: 		return;
; 19149: 
; 19150: 	if(g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE)

  00039	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0003e	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00043	83 f8 07	 cmp	 eax, 7
  00046	75 2d		 jne	 SHORT $LN7@CGReqCsSen

; 19151: 		return;
; 19152: 
; 19153: 	GCAnsCsSendCommand(gObj[iIndex].m_btCsJoinSide,lpMsg->btTeam,lpMsg->btX,lpMsg->btY,lpMsg->btCommand);

  00048	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0004b	0f b6 41 07	 movzx	 eax, BYTE PTR [ecx+7]
  0004f	50		 push	 eax
  00050	0f b6 41 06	 movzx	 eax, BYTE PTR [ecx+6]
  00054	50		 push	 eax
  00055	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  00059	50		 push	 eax
  0005a	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  0005e	50		 push	 eax
  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	0f b6 84 07 5a
	20 00 00	 movzx	 eax, BYTE PTR [edi+eax+8282]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?GCAnsCsSendCommand@@YAXHEEEE@Z ; GCAnsCsSendCommand
  00072	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@CGReqCsSen:
  00075	5f		 pop	 edi
$LN4@CGReqCsSen:
  00076	5e		 pop	 esi

; 19154: 
; 19155: #endif
; 19156: }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z ENDP	; CGReqCsSendCommand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z PROC ; CGReqStopCsMiniMapData, COMDAT

; 19131: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 19132: #if (GS_CASTLE==1)
; 19133: 	if(gObjIsConnected(iIndex) == FALSE)

  00003	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  00006	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000b	83 c4 04	 add	 esp, 4
  0000e	85 c0		 test	 eax, eax
  00010	74 0d		 je	 SHORT $LN1@CGReqStopC

; 19134: 		return;
; 19135: 	g_CastleSiege.DelMiniMapDataReqUser(iIndex);

  00012	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0001a	e8 00 00 00 00	 call	 ?DelMiniMapDataReqUser@CCastleSiege@@QAEXH@Z ; CCastleSiege::DelMiniMapDataReqUser
$LN1@CGReqStopC:

; 19136: #endif
; 19137: }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z ENDP ; CGReqStopCsMiniMapData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsMiniMapData@@YAXHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 5
_iIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?GCAnsCsMiniMapData@@YAXHE@Z PROC			; GCAnsCsMiniMapData, COMDAT

; 19119: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19120: 	PMSG_ANS_MINIMAPDATA pMsgResult;
; 19121: 
; 19122: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1B, sizeof(pMsgResult));
; 19123: 	pMsgResult.btResult = btResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]
  00009	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 19125: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0000c	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0000f	6a 05		 push	 5
  00011	50		 push	 eax
  00012	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00015	c7 45 f8 c1 05
	b2 1b		 mov	 DWORD PTR _pMsgResult$[ebp], 464651713 ; 1bb205c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19125: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  0001c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19126: }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GCAnsCsMiniMapData@@YAXHE@Z ENDP			; GCAnsCsMiniMapData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z PROC ; CGReqCsMiniMapData, COMDAT

; 19088: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 19089: #if (GS_CASTLE==1)
; 19090: 	if(gObjIsConnected(iIndex) == FALSE)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 65		 je	 SHORT $LN7@CGReqCsMin

; 19091: 		return;
; 19092: 
; 19093: 	if(gObj[iIndex].m_btCsJoinSide <= 0 || g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE)

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0001f	80 bc 01 5a 20
	00 00 00	 cmp	 BYTE PTR [ecx+eax+8282], 0
  00027	76 45		 jbe	 SHORT $LN5@CGReqCsMin
  00029	56		 push	 esi
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0002f	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00034	85 c0		 test	 eax, eax
  00036	74 36		 je	 SHORT $LN5@CGReqCsMin

; 19096: 	}
; 19097: 	else if(g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE)

  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0003d	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00042	83 f8 07	 cmp	 eax, 7
  00045	74 0e		 je	 SHORT $LN6@CGReqCsMin

; 19098: 	{
; 19099: 		GCAnsCsMiniMapData(iIndex,2);

  00047	6a 02		 push	 2
  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ?GCAnsCsMiniMapData@@YAXHE@Z ; GCAnsCsMiniMapData
  0004f	83 c4 08	 add	 esp, 8
  00052	5e		 pop	 esi

; 19105: 	}
; 19106: #endif
; 19107: }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN6@CGReqCsMin:

; 19100: 	}
; 19101: 	else
; 19102: 	{
; 19103: 		g_CastleSiege.AddMiniMapDataReqUser(iIndex);

  00055	56		 push	 esi
  00056	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0005b	e8 00 00 00 00	 call	 ?AddMiniMapDataReqUser@CCastleSiege@@QAEXH@Z ; CCastleSiege::AddMiniMapDataReqUser

; 19104: 		GCAnsCsMiniMapData(iIndex,1);

  00060	6a 01		 push	 1
  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ?GCAnsCsMiniMapData@@YAXHE@Z ; GCAnsCsMiniMapData
  00068	83 c4 08	 add	 esp, 8
  0006b	5e		 pop	 esi

; 19105: 	}
; 19106: #endif
; 19107: }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN5@CGReqCsMin:

; 19094: 	{
; 19095: 		GCAnsCsMiniMapData(iIndex,3);

  0006e	6a 03		 push	 3
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ?GCAnsCsMiniMapData@@YAXHE@Z ; GCAnsCsMiniMapData
  00076	83 c4 08	 add	 esp, 8
$LN7@CGReqCsMin:
  00079	5e		 pop	 esi

; 19105: 	}
; 19106: #endif
; 19107: }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z ENDP ; CGReqCsMiniMapData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 6
_iIndex$ = 8						; size = 4
_btTaxType$ = 12					; size = 1
_btTaxRate$ = 16					; size = 1
?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z PROC			; GCAnsCsMapSvrTaxInfo, COMDAT

; 19073: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19074: 	PMSG_ANS_MAPSVRTAXINFO pMsgResult;
; 19075: 	
; 19076: 	pMsgResult.h.set((LPBYTE)&pMsgResult, 0xB2, 0x1A, sizeof(pMsgResult));
; 19077: 	pMsgResult.btTaxType = btTaxType;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btTaxType$[ebp]
  00009	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 19078: 	pMsgResult.btTaxRate = btTaxRate;

  0000c	8a 45 10	 mov	 al, BYTE PTR _btTaxRate$[ebp]
  0000f	88 45 fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], al

; 19080: 	DataSend(iIndex, (UCHAR*)&pMsgResult, pMsgResult.h.size);

  00012	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00015	6a 06		 push	 6
  00017	50		 push	 eax
  00018	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0001b	c7 45 f8 c1 06
	b2 1a		 mov	 DWORD PTR _pMsgResult$[ebp], 447874753 ; 1ab206c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19080: 	DataSend(iIndex, (UCHAR*)&pMsgResult, pMsgResult.h.size);

  00022	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19081: 
; 19082: }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z ENDP			; GCAnsCsMapSvrTaxInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsNotifyStart@@YAXHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 5
_iIndex$ = 8						; size = 4
_btStartState$ = 12					; size = 1
?GCAnsCsNotifyStart@@YAXHE@Z PROC			; GCAnsCsNotifyStart, COMDAT

; 19028: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 19029: #if (GS_CASTLE==1)
; 19030: 	PMSG_ANS_NOTIFYCSSTART pMsgResult;
; 19031: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x17,sizeof(pMsgResult));
; 19032: 	pMsgResult.btStartState = btStartState;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btStartState$[ebp]
  00009	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 19034: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0000c	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0000f	6a 05		 push	 5
  00011	50		 push	 eax
  00012	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00015	c7 45 f8 c1 05
	b2 17		 mov	 DWORD PTR _pMsgResult$[ebp], 397542849 ; 17b205c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 19034: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0001c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19035: #endif
; 19036: }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?GCAnsCsNotifyStart@@YAXHE@Z ENDP			; GCAnsCsNotifyStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsAccessCrownState@@YAXHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_btCrownState$ = 12					; size = 1
?GCAnsCsAccessCrownState@@YAXHE@Z PROC			; GCAnsCsAccessCrownState, COMDAT

; 18978: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18982: 	pMsgResult.btCrownState = btCrownState;

  00010	8a 45 0c	 mov	 al, BYTE PTR _btCrownState$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00013	c7 45 f0 c1 0c
	b2 15		 mov	 DWORD PTR _pMsgResult$[ebp], 363990209 ; 15b20cc1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18982: 	pMsgResult.btCrownState = btCrownState;

  0001a	88 45 f4	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8b 7d 08	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 18983: 
; 18984: 	if(btCrownState == 0)

  00022	84 c0		 test	 al, al
  00024	75 61		 jne	 SHORT $LN2@GCAnsCsAcc

; 18985: 	{
; 18986: 		if(gObj[iIndex].m_iAccumulatedCrownAccessTime < 0 || gObj[iIndex].m_iAccumulatedCrownAccessTime > 30000)

  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00032	8b 94 0e 74 20
	00 00		 mov	 edx, DWORD PTR [esi+ecx+8308]
  00039	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0003c	85 d2		 test	 edx, edx
  0003e	78 08		 js	 SHORT $LN4@GCAnsCsAcc
  00040	81 fa 30 75 00
	00		 cmp	 edx, 30000		; 00007530H
  00046	7e 10		 jle	 SHORT $LN3@GCAnsCsAcc
$LN4@GCAnsCsAcc:

; 18987: 		{
; 18988: 			gObj[iIndex].m_iAccumulatedCrownAccessTime = 0;

  00048	c7 80 74 20 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+8308], 0
  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN3@GCAnsCsAcc:

; 18989: 		}
; 18990: 
; 18991: 		LogAddTD("[CastleSiege] [Reg. Attempt] Accumulated Crown AccessTime : %d [%s](%s)(%s)",

  00058	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0005b	03 c1		 add	 eax, ecx
  0005d	50		 push	 eax
  0005e	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00061	03 c1		 add	 eax, ecx
  00063	50		 push	 eax
  00064	8d 86 1c 06 00
	00		 lea	 eax, DWORD PTR [esi+1564]
  0006a	03 c1		 add	 eax, ecx
  0006c	50		 push	 eax
  0006d	ff b4 0e 74 20
	00 00		 push	 DWORD PTR [esi+ecx+8308]
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@JNCLHJJ@?$FLCastleSiege?$FN?5?$FLReg?4?5Attempt?$FN?5Acc@
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0007f	83 c4 14	 add	 esp, 20			; 00000014H

; 18992: 			gObj[iIndex].m_iAccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].AccountID,gObj[iIndex].Name);
; 18993: 	}
; 18994: 
; 18995: 	if(btCrownState == 1)

  00082	e9 de 00 00 00	 jmp	 $LN6@GCAnsCsAcc
$LN2@GCAnsCsAcc:
  00087	3c 01		 cmp	 al, 1
  00089	75 46		 jne	 SHORT $LN5@GCAnsCsAcc

; 18996: 	{
; 18997: 		LogAddTD("[CastleSiege] [Reg. Success] Accumulated Crown AccessTime : %d [%s](%s)(%s)",

  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00091	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00097	03 ce		 add	 ecx, esi
  00099	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0009c	50		 push	 eax
  0009d	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000a0	50		 push	 eax
  000a1	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  000a7	50		 push	 eax
  000a8	ff b1 74 20 00
	00		 push	 DWORD PTR [ecx+8308]
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@IGJJMHPI@?$FLCastleSiege?$FN?5?$FLReg?4?5Success?$FN?5Acc@
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 18998: 			gObj[iIndex].m_iAccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].AccountID,gObj[iIndex].Name);
; 18999: 		gObj[iIndex].m_iAccumulatedCrownAccessTime = 0;

  000b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000be	83 c4 14	 add	 esp, 20			; 00000014H
  000c1	c7 84 06 74 20
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+8308], 0

; 19000: 	}
; 19001: 
; 19002: 	if(btCrownState == 2)

  000cc	e9 94 00 00 00	 jmp	 $LN6@GCAnsCsAcc
$LN5@GCAnsCsAcc:
  000d1	3c 02		 cmp	 al, 2
  000d3	0f 85 8c 00 00
	00		 jne	 $LN6@GCAnsCsAcc

; 19003: 	{
; 19004: 		gObj[iIndex].m_iAccumulatedCrownAccessTime += GetTickCount() - g_CastleSiege.GetCrownAccessTickCount();

  000d9	53		 push	 ebx
  000da	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000df	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  000e5	e8 00 00 00 00	 call	 ?GetCrownAccessTickCount@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCrownAccessTickCount
  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f0	8b b4 0b 74 20
	00 00		 mov	 esi, DWORD PTR [ebx+ecx+8308]
  000f7	2b f0		 sub	 esi, eax
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00105	03 c6		 add	 eax, esi
  00107	89 84 0b 74 20
	00 00		 mov	 DWORD PTR [ebx+ecx+8308], eax

; 19005: 
; 19006: 		if(gObj[iIndex].m_iAccumulatedCrownAccessTime < 0 || gObj[iIndex].m_iAccumulatedCrownAccessTime > 30000)

  0010e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00114	8b 94 0b 74 20
	00 00		 mov	 edx, DWORD PTR [ebx+ecx+8308]
  0011b	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  0011e	85 d2		 test	 edx, edx
  00120	78 08		 js	 SHORT $LN8@GCAnsCsAcc
  00122	81 fa 30 75 00
	00		 cmp	 edx, 30000		; 00007530H
  00128	7e 10		 jle	 SHORT $LN7@GCAnsCsAcc
$LN8@GCAnsCsAcc:

; 19007: 		{
; 19008: 			gObj[iIndex].m_iAccumulatedCrownAccessTime = 0;

  0012a	c7 80 74 20 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+8308], 0
  00134	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN7@GCAnsCsAcc:

; 19009: 		}
; 19010: 
; 19011: 		LogAddTD("[CastleSiege] [Reg. Fail] Accumulated Crown AccessTime : %d [%s](%s)(%s)",

  0013a	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  0013d	03 c1		 add	 eax, ecx
  0013f	50		 push	 eax
  00140	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00143	03 c1		 add	 eax, ecx
  00145	50		 push	 eax
  00146	8d 83 1c 06 00
	00		 lea	 eax, DWORD PTR [ebx+1564]
  0014c	03 c1		 add	 eax, ecx
  0014e	50		 push	 eax
  0014f	ff b4 0b 74 20
	00 00		 push	 DWORD PTR [ebx+ecx+8308]
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@JHNFCADN@?$FLCastleSiege?$FN?5?$FLReg?4?5Fail?$FN?5Accumu@
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00161	83 c4 14	 add	 esp, 20			; 00000014H
  00164	5b		 pop	 ebx
$LN6@GCAnsCsAcc:

; 19012: 			gObj[iIndex].m_iAccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].AccountID,gObj[iIndex].Name);
; 19013: 	}
; 19014: 
; 19015: 	pMsgResult.dwAccessTime = gObj[iIndex].m_iAccumulatedCrownAccessTime;

  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016a	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00170	8b 84 01 74 20
	00 00		 mov	 eax, DWORD PTR [ecx+eax+8308]
  00177	89 45 f8	 mov	 DWORD PTR _pMsgResult$[ebp+8], eax

; 19016: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0017a	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsgResult$[ebp+1]
  0017e	50		 push	 eax
  0017f	8d 45 f0	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00182	50		 push	 eax
  00183	57		 push	 edi
  00184	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 19017: #endif
; 19018: }

  00189	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018f	33 cd		 xor	 ecx, ebp
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi
  00193	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
?GCAnsCsAccessCrownState@@YAXHE@Z ENDP			; GCAnsCsAccessCrownState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsAccessSwitchState@@YAXHHHE@Z
_TEXT	SEGMENT
_pMsgResult$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iSwitchIndex$ = 12					; size = 4
_iSwitchUserIndex$ = 16					; size = 4
_btSwitchState$ = 20					; size = 1
?GCAnsCsAccessSwitchState@@YAXHHHE@Z PROC		; GCAnsCsAccessSwitchState, COMDAT

; 18952: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18953: #if (GS_CASTLE==1)
; 18954: 	PMSG_ANS_NOTIFYSWITCHPROC pMsgResult;
; 18955: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x14,sizeof(pMsgResult));
; 18956: 
; 18957: 	pMsgResult.btIndex1 = SET_NUMBERH(iSwitchIndex & 0xFFFF);

  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _iSwitchIndex$[ebp]
  00013	8b c1		 mov	 eax, ecx
  00015	c1 e8 08	 shr	 eax, 8
  00018	88 45 f4	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18958: 	pMsgResult.btIndex2 = SET_NUMBERL(iSwitchIndex & 0xFFFF);

  0001b	88 4d f5	 mov	 BYTE PTR _pMsgResult$[ebp+5], cl

; 18959: 
; 18960: 	pMsgResult.btUserIndex1 = SET_NUMBERH(iSwitchUserIndex & 0xFFFF);

  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _iSwitchUserIndex$[ebp]
  00021	8b c1		 mov	 eax, ecx
  00023	c1 e8 08	 shr	 eax, 8
  00026	88 45 f6	 mov	 BYTE PTR _pMsgResult$[ebp+6], al

; 18962: 
; 18963: 	pMsgResult.btSwitchState = btSwitchState;

  00029	8a 45 14	 mov	 al, BYTE PTR _btSwitchState$[ebp]
  0002c	88 45 f8	 mov	 BYTE PTR _pMsgResult$[ebp+8], al

; 18964: 
; 18965: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0002f	8d 45 f0	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00032	6a 09		 push	 9
  00034	50		 push	 eax
  00035	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00038	c7 45 f0 c1 09
	b2 14		 mov	 DWORD PTR _pMsgResult$[ebp], 347212225 ; 14b209c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18961: 	pMsgResult.btUserIndex2 = SET_NUMBERL(iSwitchUserIndex & 0xFFFF);

  0003f	88 4d f7	 mov	 BYTE PTR _pMsgResult$[ebp+7], cl

; 18964: 
; 18965: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00042	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18966: #endif
; 18967: }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004d	33 cd		 xor	 ecx, ebp
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?GCAnsCsAccessSwitchState@@YAXHHHE@Z ENDP		; GCAnsCsAccessSwitchState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsGateCurState@@YAXHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 7
_iIndex$ = 8						; size = 4
_iGateIndex$ = 12					; size = 4
_iGateOperate$ = 16					; size = 4
?GCAnsCsGateCurState@@YAXHHH@Z PROC			; GCAnsCsGateCurState, COMDAT

; 18927: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18928: #if (GS_CASTLE==1)
; 18929: 	PMSG_ANS_CSGATECURSTATE pMsgResult;
; 18930: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x13,sizeof(pMsgResult));
; 18931: 
; 18932: 	pMsgResult.btOperate = iGateOperate;

  00006	8a 45 10	 mov	 al, BYTE PTR _iGateOperate$[ebp]

; 18933: 	pMsgResult.btIndex1 = SET_NUMBERH(iGateIndex & 0xFFFF);

  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _iGateIndex$[ebp]
  0000c	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0000f	8b c1		 mov	 eax, ecx
  00011	c1 e8 08	 shr	 eax, 8
  00014	88 45 fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], al

; 18935: 
; 18936: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00017	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0001a	6a 07		 push	 7
  0001c	50		 push	 eax
  0001d	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00020	c7 45 f8 c1 07
	b2 13		 mov	 DWORD PTR _pMsgResult$[ebp], 330434497 ; 13b207c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18934: 	pMsgResult.btIndex2 = SET_NUMBERL(iGateIndex & 0xFFFF);

  00027	88 4d fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], cl

; 18935: 
; 18936: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0002a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18937: #endif
; 18938: }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GCAnsCsGateCurState@@YAXHHH@Z ENDP			; GCAnsCsGateCurState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsGateOperate@@YAXHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 8
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iGateIndex$ = 16					; size = 4
_iGateOperate$ = 20					; size = 4
?GCAnsCsGateOperate@@YAXHHHH@Z PROC			; GCAnsCsGateOperate, COMDAT

; 18902: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18903: #if (GS_CASTLE==1)
; 18904: 
; 18905: 	PMSG_ANS_CSGATEOPERATE pMsgResult;
; 18906: 
; 18907: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x12,sizeof(pMsgResult));
; 18908: 	pMsgResult.btResult = iResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18909: 	pMsgResult.btOperate = iGateOperate;
; 18910: 	pMsgResult.btIndex1 = SET_NUMBERH(iGateIndex & 0xFFFF);

  00009	8b 4d 10	 mov	 ecx, DWORD PTR _iGateIndex$[ebp]
  0000c	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0000f	8a 45 14	 mov	 al, BYTE PTR _iGateOperate$[ebp]
  00012	88 45 fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], al
  00015	8b c1		 mov	 eax, ecx
  00017	c1 e8 08	 shr	 eax, 8
  0001a	88 45 fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], al

; 18912: 
; 18913: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0001d	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00020	6a 08		 push	 8
  00022	50		 push	 eax
  00023	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00026	c7 45 f8 c1 08
	b2 12		 mov	 DWORD PTR _pMsgResult$[ebp], 313657537 ; 12b208c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18911: 	pMsgResult.btIndex2 = SET_NUMBERL(iGateIndex & 0xFFFF);

  0002d	88 4d ff	 mov	 BYTE PTR _pMsgResult$[ebp+7], cl

; 18912: 
; 18913: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00030	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18914: #endif
; 18915: }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?GCAnsCsGateOperate@@YAXHHHH@Z ENDP			; GCAnsCsGateOperate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
tv281 = 12						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z PROC ; CGReqCsGateOperate, COMDAT

; 18839: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18840: #if (GS_CASTLE==1)
; 18841: 
; 18842: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0000d	53		 push	 ebx
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00012	05 1c 06 00 00	 add	 eax, 1564		; 0000061cH
  00017	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  0001d	03 c3		 add	 eax, ebx
  0001f	90		 npad	 1
$LL11@CGReqCsGat:
  00020	8a 10		 mov	 dl, BYTE PTR [eax]
  00022	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00024	75 1a		 jne	 SHORT $LN12@CGReqCsGat
  00026	84 d2		 test	 dl, dl
  00028	74 12		 je	 SHORT $LN13@CGReqCsGat
  0002a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0002d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00030	75 0e		 jne	 SHORT $LN12@CGReqCsGat
  00032	83 c0 02	 add	 eax, 2
  00035	83 c1 02	 add	 ecx, 2
  00038	84 d2		 test	 dl, dl
  0003a	75 e4		 jne	 SHORT $LL11@CGReqCsGat
$LN13@CGReqCsGat:
  0003c	33 c0		 xor	 eax, eax
  0003e	eb 05		 jmp	 SHORT $LN14@CGReqCsGat
$LN12@CGReqCsGat:
  00040	1b c0		 sbb	 eax, eax
  00042	83 c8 01	 or	 eax, 1
$LN14@CGReqCsGat:
  00045	85 c0		 test	 eax, eax
  00047	0f 84 cc 01 00
	00		 je	 $LN8@CGReqCsGat

; 18843: 		return;
; 18844: 
; 18845: 	if(g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)

  0004d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00052	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00057	83 f8 07	 cmp	 eax, 7
  0005a	75 38		 jne	 SHORT $LN3@CGReqCsGat

; 18846: 	{
; 18847: 		if(gObj[iIndex].m_btCsJoinSide != 1)

  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00062	03 cb		 add	 ecx, ebx
  00064	80 b9 5a 20 00
	00 01		 cmp	 BYTE PTR [ecx+8282], 1
  0006b	74 74		 je	 SHORT $LN6@CGReqCsGat

; 18848: 		{
; 18849: 			LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",

  0006d	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  00073	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  00079	50		 push	 eax
  0007a	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0007d	50		 push	 eax
  0007e	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00081	50		 push	 eax
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0008d	83 c4 14	 add	 esp, 20			; 00000014H
  00090	5f		 pop	 edi
  00091	5b		 pop	 ebx

; 18885: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18886: 	}
; 18887: 
; 18888: #endif
; 18889: }

  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN3@CGReqCsGat:

; 18850: 				gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18851: 			return;
; 18852: 		}
; 18853: 	}
; 18854: 	else if(g_CastleSiege.CheckCastleOwnerMember(iIndex) == FALSE && g_CastleSiege.CheckCastleOwnerUnionMember(iIndex) == FALSE)

  00094	57		 push	 edi
  00095	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0009a	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  0009f	85 c0		 test	 eax, eax
  000a1	75 3e		 jne	 SHORT $LN6@CGReqCsGat
  000a3	57		 push	 edi
  000a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000a9	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  000ae	85 c0		 test	 eax, eax
  000b0	75 2f		 jne	 SHORT $LN6@CGReqCsGat

; 18855: 	{
; 18856: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",

  000b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b8	03 cb		 add	 ecx, ebx
  000ba	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  000c0	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  000c6	50		 push	 eax
  000c7	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000ca	50		 push	 eax
  000cb	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000ce	50		 push	 eax
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@CLDAEBMI@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000da	83 c4 14	 add	 esp, 20			; 00000014H
  000dd	5f		 pop	 edi
  000de	5b		 pop	 ebx

; 18885: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18886: 	}
; 18887: 
; 18888: #endif
; 18889: }

  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
$LN6@CGReqCsGat:

; 18857: 				gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18858: 		return;
; 18859: 	}
; 18860: 
; 18861: 	int iGateIndex = ( ((lpMsg->btIndex2 & 0xFF) & 0xFF) | ((lpMsg->btIndex1 & 0xFF) & 0xFF) << 8) & 0xFFFF;

  000e1	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 18862: 
; 18863: 	if(g_CastleSiege.CheckCsGateAlive(iGateIndex) == TRUE)

  000e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000e9	56		 push	 esi
  000ea	0f b6 70 05	 movzx	 esi, BYTE PTR [eax+5]
  000ee	0f b6 40 06	 movzx	 eax, BYTE PTR [eax+6]
  000f2	c1 e6 08	 shl	 esi, 8
  000f5	0b f0		 or	 esi, eax
  000f7	56		 push	 esi
  000f8	e8 00 00 00 00	 call	 ?CheckCsGateAlive@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCsGateAlive
  000fd	83 f8 01	 cmp	 eax, 1
  00100	0f 85 db 00 00
	00		 jne	 $LN7@CGReqCsGat

; 18864: 	{
; 18865: 		int bRETVAL = g_CastleSiege.OperateGate(iGateIndex,gObj[iGateIndex].m_iCsNpcExistVal,lpMsg->btOperate);

  00106	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00109	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0010f	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00113	50		 push	 eax
  00114	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00119	89 4d 0c	 mov	 DWORD PTR tv281[ebp], ecx
  0011c	ff b4 01 4c 20
	00 00		 push	 DWORD PTR [ecx+eax+8268]
  00123	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00128	56		 push	 esi
  00129	e8 00 00 00 00	 call	 ?OperateGate@CCastleSiege@@QAEHHHH@Z ; CCastleSiege::OperateGate

; 18866: 
; 18867: 		if(bRETVAL == FALSE)

  0012e	85 c0		 test	 eax, eax
  00130	75 3a		 jne	 SHORT $LN9@CGReqCsGat

; 18868: 		{
; 18869: 			GCAnsCsGateOperate(iIndex,0,-1,0);

  00132	50		 push	 eax
  00133	6a ff		 push	 -1
  00135	50		 push	 eax
  00136	57		 push	 edi
  00137	e8 00 00 00 00	 call	 ?GCAnsCsGateOperate@@YAXHHHH@Z ; GCAnsCsGateOperate

; 18870: 			LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Operate Gate Failed [%s][%s], Guild:(%s)(%d)",

  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00142	03 cb		 add	 ecx, ebx
  00144	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  0014a	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  00150	50		 push	 eax
  00151	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00154	50		 push	 eax
  00155	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00158	50		 push	 eax
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@ECEJELNH@?$FLCastleSiege?$FN?5CGReqCsGateOperate@

; 18884: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Gate Doesn't Exist [%s][%s], Guild:(%s)(%d)",

  0015e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00164	83 c4 24	 add	 esp, 36			; 00000024H
  00167	5e		 pop	 esi
  00168	5f		 pop	 edi
  00169	5b		 pop	 ebx

; 18885: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18886: 	}
; 18887: 
; 18888: #endif
; 18889: }

  0016a	5d		 pop	 ebp
  0016b	c3		 ret	 0
$LN9@CGReqCsGat:

; 18871: 				gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18872: 			return;
; 18873: 		}
; 18874: 
; 18875: 		GCAnsCsGateOperate(iIndex,1,iGateIndex,lpMsg->btOperate);

  0016c	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0016f	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00173	50		 push	 eax
  00174	56		 push	 esi
  00175	6a 01		 push	 1
  00177	57		 push	 edi
  00178	e8 00 00 00 00	 call	 ?GCAnsCsGateOperate@@YAXHHHH@Z ; GCAnsCsGateOperate

; 18876: 		g_CastleSiege.SendCsGateStateViewPort(iGateIndex,lpMsg->btOperate);

  0017d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00180	83 c4 10	 add	 esp, 16			; 00000010H
  00183	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00188	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0018c	50		 push	 eax
  0018d	56		 push	 esi
  0018e	e8 00 00 00 00	 call	 ?SendCsGateStateViewPort@CCastleSiege@@QAEXHE@Z ; CCastleSiege::SendCsGateStateViewPort

; 18877: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() OK - [%s][%s], Guild:(%s)(%d), DOOR:(%d)(X:%d,Y:%d)(STATUE:%d)",

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00198	8b 4d 0c	 mov	 ecx, DWORD PTR tv281[ebp]
  0019b	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]
  0019e	03 c8		 add	 ecx, eax
  001a0	0f b6 81 51 20
	00 00		 movzx	 eax, BYTE PTR [ecx+8273]
  001a7	50		 push	 eax
  001a8	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  001af	50		 push	 eax
  001b0	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  001b7	50		 push	 eax
  001b8	56		 push	 esi
  001b9	ff b2 28 06 00
	00		 push	 DWORD PTR [edx+1576]
  001bf	8d 82 1c 06 00
	00		 lea	 eax, DWORD PTR [edx+1564]
  001c5	50		 push	 eax
  001c6	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  001c9	50		 push	 eax
  001ca	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  001cd	50		 push	 eax
  001ce	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@PPNJMEKD@?$FLCastleSiege?$FN?5CGReqCsGateOperate@

; 18884: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Gate Doesn't Exist [%s][%s], Guild:(%s)(%d)",

  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001d9	83 c4 24	 add	 esp, 36			; 00000024H
  001dc	5e		 pop	 esi
  001dd	5f		 pop	 edi
  001de	5b		 pop	 ebx

; 18885: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18886: 	}
; 18887: 
; 18888: #endif
; 18889: }

  001df	5d		 pop	 ebp
  001e0	c3		 ret	 0
$LN7@CGReqCsGat:

; 18878: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iGateIndex,gObj[iGateIndex].X,gObj[iGateIndex].Y,gObj[iGateIndex].m_btCsGateOpen);
; 18879: 
; 18880: 	}
; 18881: 	else
; 18882: 	{
; 18883: 		GCAnsCsGateOperate(iIndex,2,-1,0);

  001e1	6a 00		 push	 0
  001e3	6a ff		 push	 -1
  001e5	6a 02		 push	 2
  001e7	57		 push	 edi
  001e8	e8 00 00 00 00	 call	 ?GCAnsCsGateOperate@@YAXHHHH@Z ; GCAnsCsGateOperate

; 18884: 		LogAddTD("[CastleSiege] CGReqCsGateOperate() ERROR - Gate Doesn't Exist [%s][%s], Guild:(%s)(%d)",

  001ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f3	03 cb		 add	 ecx, ebx
  001f5	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  001fb	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  00201	50		 push	 eax
  00202	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00205	50		 push	 eax
  00206	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00209	50		 push	 eax
  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@PFCGGCDO@?$FLCastleSiege?$FN?5CGReqCsGateOperate@
  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00215	83 c4 24	 add	 esp, 36			; 00000024H
  00218	5e		 pop	 esi
$LN8@CGReqCsGat:
  00219	5f		 pop	 edi
  0021a	5b		 pop	 ebx

; 18885: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18886: 	}
; 18887: 
; 18888: #endif
; 18889: }

  0021b	5d		 pop	 ebp
  0021c	c3		 ret	 0
?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z ENDP ; CGReqCsGateOperate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCsGateState@@YAXHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 7
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iGateIndex$ = 16					; size = 4
?GCAnsCsGateState@@YAXHHH@Z PROC			; GCAnsCsGateState, COMDAT

; 18820: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 18821: #if (GS_CASTLE==1)
; 18822: 
; 18823: 	PMSG_ANS_CSGATESTATE pMsgResult;
; 18824: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x11,sizeof(pMsgResult));
; 18825: 
; 18826: 	pMsgResult.btResult = iResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18827: 	pMsgResult.btIndex1 = SET_NUMBERH(iGateIndex & 0xFFFF);

  00009	8b 4d 10	 mov	 ecx, DWORD PTR _iGateIndex$[ebp]
  0000c	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  0000f	8b c1		 mov	 eax, ecx
  00011	c1 e8 08	 shr	 eax, 8
  00014	88 45 fd	 mov	 BYTE PTR _pMsgResult$[ebp+5], al

; 18829: 
; 18830: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00017	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0001a	6a 07		 push	 7
  0001c	50		 push	 eax
  0001d	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00020	c7 45 f8 c1 07
	b2 11		 mov	 DWORD PTR _pMsgResult$[ebp], 296880065 ; 11b207c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18828: 	pMsgResult.btIndex2 = SET_NUMBERL(iGateIndex & 0xFFFF);

  00027	88 4d fe	 mov	 BYTE PTR _pMsgResult$[ebp+6], cl

; 18829: 
; 18830: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0002a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18831: #endif
; 18832: }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GCAnsCsGateState@@YAXHHH@Z ENDP			; GCAnsCsGateState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsMoneyDrawOut@@YAXHH_J@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_i64Money$ = 16						; size = 8
?GCAnsMoneyDrawOut@@YAXHH_J@Z PROC			; GCAnsMoneyDrawOut, COMDAT

; 18789: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18790: #if (GS_CASTLE==1)
; 18791: 	PMSG_ANS_MONEYDRAWOUT pMsgResult;
; 18792: 
; 18793: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x10,sizeof(pMsgResult));
; 18794: 	pMsgResult.btResult = iResult;
; 18795: 
; 18796: 	pMsgResult.btMoney1 = DWORD((DWORD(i64Money >> 32) >> 16) & 0xFFFF) >> 8;

  00010	8b 4d 14	 mov	 ecx, DWORD PTR _i64Money$[ebp+4]
  00013	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  00016	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00019	8b c1		 mov	 eax, ecx
  0001b	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  0001e	8b c1		 mov	 eax, ecx

; 18797: 	pMsgResult.btMoney2 = DWORD((DWORD(i64Money >> 32) >> 16) & 0xFFFF) & 0xFF;
; 18798: 	pMsgResult.btMoney3 = DWORD((DWORD(i64Money >> 32) & 0xFFFF) & 0xFFFF) >> 8;
; 18799: 	pMsgResult.btMoney4 = DWORD((DWORD(i64Money >> 32) & 0xFFFF) & 0xFFFF) & 0xFF;

  00020	88 4d f4	 mov	 BYTE PTR _pMsgResult$[ebp+8], cl
  00023	c1 e8 18	 shr	 eax, 24			; 00000018H
  00026	88 45 f1	 mov	 BYTE PTR _pMsgResult$[ebp+5], al
  00029	8b c1		 mov	 eax, ecx
  0002b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0002e	88 45 f2	 mov	 BYTE PTR _pMsgResult$[ebp+6], al
  00031	8b c1		 mov	 eax, ecx

; 18800: 
; 18801: 	pMsgResult.btMoney5 = DWORD((DWORD(i64Money & 0xFFFFFFFF) >> 16) & 0xFFFF) >> 8;

  00033	8b 4d 10	 mov	 ecx, DWORD PTR _i64Money$[ebp]
  00036	c1 e8 08	 shr	 eax, 8
  00039	88 45 f3	 mov	 BYTE PTR _pMsgResult$[ebp+7], al
  0003c	8b c1		 mov	 eax, ecx
  0003e	c1 e8 18	 shr	 eax, 24			; 00000018H
  00041	88 45 f5	 mov	 BYTE PTR _pMsgResult$[ebp+9], al

; 18802: 	pMsgResult.btMoney6 = DWORD((DWORD(i64Money & 0xFFFFFFFF) >> 16) & 0xFFFF) & 0xFF;

  00044	8b c1		 mov	 eax, ecx
  00046	c1 e8 10	 shr	 eax, 16			; 00000010H
  00049	88 45 f6	 mov	 BYTE PTR _pMsgResult$[ebp+10], al

; 18803: 	pMsgResult.btMoney7 = DWORD((DWORD(i64Money & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) >> 8;

  0004c	8b c1		 mov	 eax, ecx
  0004e	c1 e8 08	 shr	 eax, 8
  00051	88 45 f7	 mov	 BYTE PTR _pMsgResult$[ebp+11], al

; 18805: 
; 18806: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00054	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00057	6a 0d		 push	 13			; 0000000dH
  00059	50		 push	 eax
  0005a	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0005d	c7 45 ec c1 0d
	b2 10		 mov	 DWORD PTR _pMsgResult$[ebp], 280104385 ; 10b20dc1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18804: 	pMsgResult.btMoney8 = DWORD((DWORD(i64Money & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) & 0xFF;

  00064	88 4d f8	 mov	 BYTE PTR _pMsgResult$[ebp+12], cl

; 18805: 
; 18806: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00067	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18807: #endif
; 18808: }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	33 cd		 xor	 ecx, ebp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?GCAnsMoneyDrawOut@@YAXHH_J@Z ENDP			; GCAnsMoneyDrawOut
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z PROC ; CGReqMoneyDrawOut, COMDAT

; 18724: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 18725: #if (GS_CASTLE==1)
; 18726: 
; 18727: 	if(lpMsg == NULL)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	0f 84 e3 01 00
	00		 je	 $LN1@CGReqMoney

; 18728: 		return;
; 18729: 
; 18730: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  0000f	56		 push	 esi
  00010	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0001b	57		 push	 edi
  0001c	69 7d 0c 40 27
	00 00		 imul	 edi, DWORD PTR _iIndex$[ebp], 10048
  00023	81 c6 1c 06 00
	00		 add	 esi, 1564		; 0000061cH
  00029	03 f7		 add	 esi, edi
  0002b	8b c6		 mov	 eax, esi
  0002d	0f 1f 00	 npad	 3
$LL13@CGReqMoney:
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 1a		 jne	 SHORT $LN14@CGReqMoney
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN15@CGReqMoney
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 0e		 jne	 SHORT $LN14@CGReqMoney
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL13@CGReqMoney
$LN15@CGReqMoney:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN16@CGReqMoney
$LN14@CGReqMoney:
  00050	1b c0		 sbb	 eax, eax
  00052	83 c8 01	 or	 eax, 1
$LN16@CGReqMoney:
  00055	85 c0		 test	 eax, eax
  00057	0f 84 93 01 00
	00		 je	 $LN17@CGReqMoney

; 18731: 		return;
; 18732: 
; 18733: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18734: 		|| gObj[iIndex].GuildStatus != G_MASTER)

  0005d	56		 push	 esi
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00063	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006e	85 c0		 test	 eax, eax
  00070	0f 84 4e 01 00
	00		 je	 $LN5@CGReqMoney
  00076	81 bc 0f 28 06
	00 00 80 00 00
	00		 cmp	 DWORD PTR [edi+ecx+1576], 128 ; 00000080H
  00081	0f 85 3d 01 00
	00		 jne	 $LN5@CGReqMoney

; 18737: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18738: 		return;
; 18739: 	}
; 18740: 
; 18741: 	int iMoneyChange = ((( ( ( (lpMsg->btMoney1 & 0xFF) & 0xFF | ((lpMsg->btMoney2 & 0xFF) & 0xFF ) << 8)) &0xFFFF) & 0xFFFF) & 0xFFFF) | ((( ( ( (lpMsg->btMoney3 & 0xFF) & 0xFF | ((lpMsg->btMoney4 & 0xFF) & 0xFF ) << 8)) &0xFFFF) & 0xFFFF) & 0xFFFF) << 16;

  00087	0f b6 73 07	 movzx	 esi, BYTE PTR [ebx+7]
  0008b	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  0008f	c1 e6 08	 shl	 esi, 8
  00092	0b f0		 or	 esi, eax
  00094	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  00098	c1 e6 08	 shl	 esi, 8
  0009b	0b f0		 or	 esi, eax
  0009d	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  000a1	c1 e6 08	 shl	 esi, 8
  000a4	0b f0		 or	 esi, eax

; 18742: 
; 18743: 	if(iMoneyChange <= 0)

  000a6	7f 45		 jg	 SHORT $LN6@CGReqMoney

; 18744: 	{
; 18745: 		GCAnsMoneyDrawOut(iIndex,0,0);

  000a8	6a 00		 push	 0
  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  000b1	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut

; 18746: 		LogAddTD("[CastleSiege] CGReqMoneyDrawOut() ERROR - Req Money < 0 [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d",

  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bc	03 cf		 add	 ecx, edi
  000be	ff b1 cc 00 00
	00		 push	 DWORD PTR [ecx+204]
  000c4	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  000ca	56		 push	 esi
  000cb	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  000d1	50		 push	 eax
  000d2	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000d5	50		 push	 eax
  000d6	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000d9	50		 push	 eax
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OMCJPOBC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e5	83 c4 2c	 add	 esp, 44			; 0000002cH
  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx

; 18769: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iMoneyChange,gObj[iIndex].Money);
; 18770: #endif
; 18771: }

  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
$LN6@CGReqMoney:

; 18747: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iMoneyChange,gObj[iIndex].Money);
; 18748: 		return;
; 18749: 	}
; 18750: 
; 18751: 	int bRETVAL = g_CastleSiege.CheckCastleHasMoney(iMoneyChange);

  000ed	8b c6		 mov	 eax, esi
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000f4	99		 cdq
  000f5	52		 push	 edx
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ?CheckCastleHasMoney@CCastleSiege@@QAEH_J@Z ; CCastleSiege::CheckCastleHasMoney

; 18752: 
; 18753: 	if(bRETVAL == FALSE)

  000fc	85 c0		 test	 eax, eax
  000fe	75 42		 jne	 SHORT $LN7@CGReqMoney

; 18754: 	{
; 18755: 		GCAnsMoneyDrawOut(iIndex,0,0);

  00100	50		 push	 eax
  00101	50		 push	 eax
  00102	50		 push	 eax
  00103	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  00106	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut

; 18756: 		LogAddTD("[CastleSiege] CGReqMoneyDrawOut() ERROR - Castle Money is Low [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d",

  0010b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00111	03 cf		 add	 ecx, edi
  00113	ff b1 cc 00 00
	00		 push	 DWORD PTR [ecx+204]
  00119	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  0011f	56		 push	 esi
  00120	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  00126	50		 push	 eax
  00127	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0012a	50		 push	 eax
  0012b	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0012e	50		 push	 eax
  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_0GO@PDPPHBEL@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0013a	83 c4 2c	 add	 esp, 44			; 0000002cH
  0013d	5f		 pop	 edi
  0013e	5e		 pop	 esi
  0013f	5b		 pop	 ebx

; 18769: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iMoneyChange,gObj[iIndex].Money);
; 18770: #endif
; 18771: }

  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
$LN7@CGReqMoney:

; 18757: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iMoneyChange,gObj[iIndex].Money);
; 18758: 		return;
; 18759: 	}
; 18760: 
; 18761: 	if(gObj[iIndex].Money + iMoneyChange > 2000000000)

  00142	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00147	8b 84 07 cc 00
	00 00		 mov	 eax, DWORD PTR [edi+eax+204]
  0014e	03 c6		 add	 eax, esi
  00150	3d 00 94 35 77	 cmp	 eax, 2000000000		; 77359400H
  00155	7e 16		 jle	 SHORT $LN8@CGReqMoney

; 18762: 	{
; 18763: 		GCAnsMoneyDrawOut(iIndex,0,0);

  00157	6a 00		 push	 0
  00159	6a 00		 push	 0
  0015b	6a 00		 push	 0
  0015d	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  00160	e8 00 00 00 00	 call	 ?GCAnsMoneyDrawOut@@YAXHH_J@Z ; GCAnsMoneyDrawOut
  00165	83 c4 10	 add	 esp, 16			; 00000010H
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx

; 18769: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iMoneyChange,gObj[iIndex].Money);
; 18770: #endif
; 18771: }

  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
$LN8@CGReqMoney:
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0016d	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00172	85 c0		 test	 eax, eax
  00174	74 06		 je	 SHORT $LN11@CGReqMoney

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00176	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0017a	eb 03		 jmp	 SHORT $LN10@CGReqMoney
$LN11@CGReqMoney:

; 58   : 		}
; 59   : 		return -1;

  0017c	83 c9 ff	 or	 ecx, -1
$LN10@CGReqMoney:
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18767: 	GS_GDReqCastleMoneyChange(g_MapServerManager.GetMapSvrGroup(),iIndex,-iMoneyChange);

  0017f	8b c6		 mov	 eax, esi
  00181	f7 d8		 neg	 eax
  00183	50		 push	 eax
  00184	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  00187	51		 push	 ecx
  00188	e8 00 00 00 00	 call	 ?GS_GDReqCastleMoneyChange@@YAXHHH@Z ; GS_GDReqCastleMoneyChange

; 18768: 	LogAddTD("[CastleSiege] CGReqMoneyDrawOut() REQ OK - [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d",

  0018d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00193	03 cf		 add	 ecx, edi
  00195	ff b1 cc 00 00
	00		 push	 DWORD PTR [ecx+204]
  0019b	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  001a1	56		 push	 esi
  001a2	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  001a8	50		 push	 eax
  001a9	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001ac	50		 push	 eax
  001ad	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001b0	50		 push	 eax
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@OCIHBNNC@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001bc	83 c4 28	 add	 esp, 40			; 00000028H
  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5b		 pop	 ebx

; 18769: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iMoneyChange,gObj[iIndex].Money);
; 18770: #endif
; 18771: }

  001c2	5d		 pop	 ebp
  001c3	c3		 ret	 0
$LN5@CGReqMoney:

; 18735: 	{
; 18736: 		LogAddC(2,"[CastleSiege] CGReqMoneyDrawOut() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",

  001c4	ff b4 0f 28 06
	00 00		 push	 DWORD PTR [edi+ecx+1576]
  001cb	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  001d1	03 c7		 add	 eax, edi
  001d3	50		 push	 eax
  001d4	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001d7	03 c7		 add	 eax, edi
  001d9	50		 push	 eax
  001da	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001dd	03 c7		 add	 eax, edi
  001df	50		 push	 eax
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@DGNKBDAH@?$FLCastleSiege?$FN?5CGReqMoneyDrawOut?$CI@
  001e5	6a 02		 push	 2
  001e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001ed	83 c4 18	 add	 esp, 24			; 00000018H
$LN17@CGReqMoney:
  001f0	5f		 pop	 edi
  001f1	5e		 pop	 esi
$LN1@CGReqMoney:
  001f2	5b		 pop	 ebx

; 18769: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,iMoneyChange,gObj[iIndex].Money);
; 18770: #endif
; 18771: }

  001f3	5d		 pop	 ebp
  001f4	c3		 ret	 0
?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z ENDP ; CGReqMoneyDrawOut
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsTaxRateChange@@YAXHHEH@Z
_TEXT	SEGMENT
_pMsgResult$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_btTaxType$ = 16					; size = 1
_iTaxRate$ = 20						; size = 4
?GCAnsTaxRateChange@@YAXHHEH@Z PROC			; GCAnsTaxRateChange, COMDAT

; 18703: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18704: #if (GS_CASTLE==1)
; 18705: 	PMSG_ANS_TAXRATECHANGE pMsgResult;
; 18706: 
; 18707: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x09,sizeof(pMsgResult));
; 18708: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18709: 	pMsgResult.btTaxType = btTaxType;
; 18710: 	
; 18711: 	pMsgResult.btTaxRate1 = DWORD((DWORD(iTaxRate) >> 16) &0xFFFF) >> 8;

  00013	8b 4d 14	 mov	 ecx, DWORD PTR _iTaxRate$[ebp]
  00016	88 45 f4	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00019	8a 45 10	 mov	 al, BYTE PTR _btTaxType$[ebp]
  0001c	88 45 f5	 mov	 BYTE PTR _pMsgResult$[ebp+5], al
  0001f	8b c1		 mov	 eax, ecx
  00021	c1 e8 18	 shr	 eax, 24			; 00000018H
  00024	88 45 f6	 mov	 BYTE PTR _pMsgResult$[ebp+6], al

; 18712: 	pMsgResult.btTaxRate2 = DWORD((DWORD(iTaxRate) >> 16) &0xFFFF) & 0xFF;

  00027	8b c1		 mov	 eax, ecx
  00029	c1 e8 10	 shr	 eax, 16			; 00000010H
  0002c	88 45 f7	 mov	 BYTE PTR _pMsgResult$[ebp+7], al

; 18713: 	pMsgResult.btTaxRate3 = DWORD((DWORD(iTaxRate) & 0xFFFF) &0xFFFF) >> 8;

  0002f	8b c1		 mov	 eax, ecx
  00031	c1 e8 08	 shr	 eax, 8
  00034	88 45 f8	 mov	 BYTE PTR _pMsgResult$[ebp+8], al

; 18715: 
; 18716: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00037	8d 45 f0	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0003a	6a 0a		 push	 10			; 0000000aH
  0003c	50		 push	 eax
  0003d	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00040	c7 45 f0 c1 0a
	b2 09		 mov	 DWORD PTR _pMsgResult$[ebp], 162663105 ; 09b20ac1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18714: 	pMsgResult.btTaxRate4 = DWORD((DWORD(iTaxRate) & 0xFFFF) &0xFFFF) & 0xFF;

  00047	88 4d f9	 mov	 BYTE PTR _pMsgResult$[ebp+9], cl

; 18715: 
; 18716: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0004a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18717: #endif
; 18718: }

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	33 cd		 xor	 ecx, ebp
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GCAnsTaxRateChange@@YAXHHEH@Z ENDP			; GCAnsTaxRateChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z PROC ; CGReqTaxRateChange, COMDAT

; 18642: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 18643: #if (GS_CASTLE==1)
; 18644: 	if(lpMsg == NULL)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	0f 84 85 01 00
	00		 je	 $LN1@CGReqTaxRa

; 18645: 		return;
; 18646: 
; 18647: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  0000f	53		 push	 ebx
  00010	69 5d 0c 40 27
	00 00		 imul	 ebx, DWORD PTR _iIndex$[ebp], 10048
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0001c	56		 push	 esi
  0001d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	81 c6 1c 06 00
	00		 add	 esi, 1564		; 0000061cH
  00029	03 f3		 add	 esi, ebx
  0002b	8b c6		 mov	 eax, esi
  0002d	0f 1f 00	 npad	 3
$LL17@CGReqTaxRa:
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 1a		 jne	 SHORT $LN18@CGReqTaxRa
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN19@CGReqTaxRa
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 0e		 jne	 SHORT $LN18@CGReqTaxRa
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL17@CGReqTaxRa
$LN19@CGReqTaxRa:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN20@CGReqTaxRa
$LN18@CGReqTaxRa:
  00050	1b c0		 sbb	 eax, eax
  00052	83 c8 01	 or	 eax, 1
$LN20@CGReqTaxRa:
  00055	85 c0		 test	 eax, eax
  00057	0f 84 35 01 00
	00		 je	 $LN21@CGReqTaxRa

; 18648: 		return;
; 18649: 
; 18650: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18651: 		|| gObj[iIndex].GuildStatus != G_MASTER)

  0005d	56		 push	 esi
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00063	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006e	85 c0		 test	 eax, eax
  00070	0f 84 f0 00 00
	00		 je	 $LN7@CGReqTaxRa
  00076	81 bc 0b 28 06
	00 00 80 00 00
	00		 cmp	 DWORD PTR [ebx+ecx+1576], 128 ; 00000080H
  00081	0f 85 df 00 00
	00		 jne	 $LN7@CGReqTaxRa

; 18654: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18655: 		return;
; 18656: 	}
; 18657: 
; 18658: 	int iMaxTaxRate =0;
; 18659: 
; 18660: 	switch(lpMsg->btTaxType)

  00087	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  0008b	33 c9		 xor	 ecx, ecx
  0008d	8b c2		 mov	 eax, edx
  0008f	83 e8 01	 sub	 eax, 1
  00092	74 11		 je	 SHORT $LN8@CGReqTaxRa
  00094	83 e8 01	 sub	 eax, 1
  00097	74 0c		 je	 SHORT $LN8@CGReqTaxRa
  00099	83 e8 01	 sub	 eax, 1
  0009c	75 0c		 jne	 SHORT $LN2@CGReqTaxRa

; 18664: 		break;
; 18665: 	case 2:
; 18666: 		iMaxTaxRate = 3;
; 18667: 		break;
; 18668: 	case 3:
; 18669: 		iMaxTaxRate = 300000;

  0009e	b9 e0 93 04 00	 mov	 ecx, 300000		; 000493e0H
  000a3	eb 05		 jmp	 SHORT $LN2@CGReqTaxRa
$LN8@CGReqTaxRa:

; 18661: 	{
; 18662: 	case 1:
; 18663: 		iMaxTaxRate = 3;

  000a5	b9 03 00 00 00	 mov	 ecx, 3
$LN2@CGReqTaxRa:

; 18670: 		break;
; 18671: 	}
; 18672: 
; 18673: 	int iTaxRate = (( ( ( (lpMsg->btTaxRate4 & 0xFF) & 0xFF | ((lpMsg->btTaxRate3 & 0xFF) & 0xFF ) << 8)) &0xFFFF) & 0xFFFF) & 0xFFFF | ((( ( ( (lpMsg->btTaxRate2 & 0xFF) & 0xFF | ((lpMsg->btTaxRate1 & 0xFF) & 0xFF ) << 8)) &0xFFFF) & 0xFFFF) & 0xFFFF) << 16;

  000aa	0f b6 77 05	 movzx	 esi, BYTE PTR [edi+5]
  000ae	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  000b2	c1 e6 08	 shl	 esi, 8
  000b5	0b f0		 or	 esi, eax
  000b7	0f b6 47 07	 movzx	 eax, BYTE PTR [edi+7]
  000bb	c1 e6 08	 shl	 esi, 8
  000be	0b f0		 or	 esi, eax
  000c0	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  000c4	c1 e6 08	 shl	 esi, 8
  000c7	0b f0		 or	 esi, eax

; 18674: 
; 18675: 	if(iTaxRate < 0 || iTaxRate > iMaxTaxRate)

  000c9	7c 57		 jl	 SHORT $LN12@CGReqTaxRa
  000cb	3b f1		 cmp	 esi, ecx
  000cd	7f 53		 jg	 SHORT $LN12@CGReqTaxRa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  000cf	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  000d4	85 c0		 test	 eax, eax
  000d6	74 06		 je	 SHORT $LN15@CGReqTaxRa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  000d8	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  000dc	eb 03		 jmp	 SHORT $LN14@CGReqTaxRa
$LN15@CGReqTaxRa:

; 58   : 		}
; 59   : 		return -1;

  000de	83 c8 ff	 or	 eax, -1
$LN14@CGReqTaxRa:
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18683: 	GS_GDReqTaxRateChange(g_MapServerManager.GetMapSvrGroup(),iIndex,lpMsg->btTaxType,iTaxRate);

  000e1	56		 push	 esi
  000e2	52		 push	 edx
  000e3	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ?GS_GDReqTaxRateChange@@YAXHHHH@Z ; GS_GDReqTaxRateChange

; 18684: 	LogAddTD("[CastleSiege] CGReqTaxRateChange() REQ OK - [%s][%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d",

  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f2	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  000f6	03 cb		 add	 ecx, ebx
  000f8	56		 push	 esi
  000f9	50		 push	 eax
  000fa	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  00100	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  00106	50		 push	 eax
  00107	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0010a	50		 push	 eax
  0010b	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0010e	50		 push	 eax
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@BAMHEEPO@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0011a	83 c4 2c	 add	 esp, 44			; 0000002cH
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	5f		 pop	 edi

; 18685: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->btTaxType,iTaxRate);
; 18686: 
; 18687: #endif
; 18688: }

  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN12@CGReqTaxRa:

; 18676: 	{
; 18677: 		GCAnsTaxRateChange(iIndex,0,0,0);

  00122	6a 00		 push	 0
  00124	6a 00		 push	 0
  00126	6a 00		 push	 0
  00128	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  0012b	e8 00 00 00 00	 call	 ?GCAnsTaxRateChange@@YAXHHEH@Z ; GCAnsTaxRateChange

; 18678: 		LogAddTD("[CastleSiege] CGReqTaxRateChange() ERROR - Tax Rate Out of Range [%s][%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d",

  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00136	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0013a	03 cb		 add	 ecx, ebx
  0013c	56		 push	 esi
  0013d	50		 push	 eax
  0013e	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  00144	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  0014a	50		 push	 eax
  0014b	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0014e	50		 push	 eax
  0014f	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00152	50		 push	 eax
  00153	68 00 00 00 00	 push	 OFFSET ??_C@_0HC@JOOCDJDK@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0015e	83 c4 2c	 add	 esp, 44			; 0000002cH
  00161	5e		 pop	 esi
  00162	5b		 pop	 ebx
  00163	5f		 pop	 edi

; 18685: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->btTaxType,iTaxRate);
; 18686: 
; 18687: #endif
; 18688: }

  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
$LN7@CGReqTaxRa:

; 18652: 	{
; 18653: 		LogAddC(2,"[CastleSiege] CGReqTaxRateChange() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",

  00166	ff b4 0b 28 06
	00 00		 push	 DWORD PTR [ebx+ecx+1576]
  0016d	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  00173	03 c3		 add	 eax, ebx
  00175	50		 push	 eax
  00176	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00179	03 c3		 add	 eax, ebx
  0017b	50		 push	 eax
  0017c	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0017f	03 c3		 add	 eax, ebx
  00181	50		 push	 eax
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@KBBNDHCP@?$FLCastleSiege?$FN?5CGReqTaxRateChange@
  00187	6a 02		 push	 2
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0018f	83 c4 18	 add	 esp, 24			; 00000018H
$LN21@CGReqTaxRa:
  00192	5e		 pop	 esi
  00193	5b		 pop	 ebx
$LN1@CGReqTaxRa:
  00194	5f		 pop	 edi

; 18685: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->btTaxType,iTaxRate);
; 18686: 
; 18687: #endif
; 18688: }

  00195	5d		 pop	 ebp
  00196	c3		 ret	 0
?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z ENDP ; CGReqTaxRateChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 15
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_btTaxRateChaos$ = 16					; size = 1
_btTaxRateStore$ = 20					; size = 1
_i64Money$ = 24						; size = 8
?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z PROC			; GCAnsTaxMoneyInfo, COMDAT

; 18615: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18616: #if (GS_CASTLE==1)
; 18617: 	PMSG_ANS_TAXMONEYINFO pMsgResult;
; 18618: 
; 18619: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x08,sizeof(pMsgResult));
; 18620: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18621: 	pMsgResult.btTaxRateChaos = btTaxRateChaos;
; 18622: 	pMsgResult.btTaxRateStore = btTaxRateStore;
; 18623: 
; 18624: 	pMsgResult.btMoney1 = DWORD((DWORD(i64Money >> 32) >> 16) & 0xFFFF) >> 8;

  00013	8b 4d 1c	 mov	 ecx, DWORD PTR _i64Money$[ebp+4]
  00016	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00019	8a 45 10	 mov	 al, BYTE PTR _btTaxRateChaos$[ebp]
  0001c	88 45 f1	 mov	 BYTE PTR _pMsgResult$[ebp+5], al
  0001f	8a 45 14	 mov	 al, BYTE PTR _btTaxRateStore$[ebp]
  00022	88 45 f2	 mov	 BYTE PTR _pMsgResult$[ebp+6], al
  00025	8b c1		 mov	 eax, ecx
  00027	c1 f8 1f	 sar	 eax, 31			; 0000001fH
  0002a	8b c1		 mov	 eax, ecx

; 18625: 	pMsgResult.btMoney2 = DWORD((DWORD(i64Money >> 32) >> 16) & 0xFFFF) & 0xFF;
; 18626: 	pMsgResult.btMoney3 = DWORD((DWORD(i64Money >> 32) & 0xFFFF) & 0xFFFF) >> 8;
; 18627: 	pMsgResult.btMoney4 = DWORD((DWORD(i64Money >> 32) & 0xFFFF) & 0xFFFF) & 0xFF;

  0002c	88 4d f6	 mov	 BYTE PTR _pMsgResult$[ebp+10], cl
  0002f	c1 e8 18	 shr	 eax, 24			; 00000018H
  00032	88 45 f3	 mov	 BYTE PTR _pMsgResult$[ebp+7], al
  00035	8b c1		 mov	 eax, ecx
  00037	c1 e8 10	 shr	 eax, 16			; 00000010H
  0003a	88 45 f4	 mov	 BYTE PTR _pMsgResult$[ebp+8], al
  0003d	8b c1		 mov	 eax, ecx

; 18628: 
; 18629: 	pMsgResult.btMoney5 = DWORD((DWORD(i64Money & 0xFFFFFFFF) >> 16) & 0xFFFF) >> 8;

  0003f	8b 4d 18	 mov	 ecx, DWORD PTR _i64Money$[ebp]
  00042	c1 e8 08	 shr	 eax, 8
  00045	88 45 f5	 mov	 BYTE PTR _pMsgResult$[ebp+9], al
  00048	8b c1		 mov	 eax, ecx
  0004a	c1 e8 18	 shr	 eax, 24			; 00000018H
  0004d	88 45 f7	 mov	 BYTE PTR _pMsgResult$[ebp+11], al

; 18630: 	pMsgResult.btMoney6 = DWORD((DWORD(i64Money & 0xFFFFFFFF) >> 16) & 0xFFFF) & 0xFF;

  00050	8b c1		 mov	 eax, ecx
  00052	c1 e8 10	 shr	 eax, 16			; 00000010H
  00055	88 45 f8	 mov	 BYTE PTR _pMsgResult$[ebp+12], al

; 18631: 	pMsgResult.btMoney7 = DWORD((DWORD(i64Money & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) >> 8;

  00058	8b c1		 mov	 eax, ecx
  0005a	c1 e8 08	 shr	 eax, 8
  0005d	88 45 f9	 mov	 BYTE PTR _pMsgResult$[ebp+13], al

; 18633: 
; 18634: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00060	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00063	6a 0f		 push	 15			; 0000000fH
  00065	50		 push	 eax
  00066	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00069	c7 45 ec c1 0f
	b2 08		 mov	 DWORD PTR _pMsgResult$[ebp], 145887169 ; 08b20fc1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18632: 	pMsgResult.btMoney8 = DWORD((DWORD(i64Money & 0xFFFFFFFF) & 0xFFFF) & 0xFFFF) & 0xFF;

  00070	88 4d fa	 mov	 BYTE PTR _pMsgResult$[ebp+14], cl

; 18633: 
; 18634: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  00073	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18635: #endif
; 18636: }

  00078	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	33 cd		 xor	 ecx, ebp
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?GCAnsTaxMoneyInfo@@YAXHHEE_J@Z ENDP			; GCAnsTaxMoneyInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z PROC ; CGReqTaxMoneyInfo, COMDAT

; 18574: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18575: #if (GS_CASTLE==1)
; 18576: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	0f 84 ea 00 00
	00		 je	 $LN1@CGReqTaxMo

; 18577: 		return;
; 18578: 
; 18579: 	if(strcmp(gObj[iIndex].GuildName,"")==NULL)

  0000d	53		 push	 ebx
  0000e	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001e	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00024	81 c7 1c 06 00
	00		 add	 edi, 1564		; 0000061cH
  0002a	03 fe		 add	 edi, esi
  0002c	8b c7		 mov	 eax, edi
  0002e	66 90		 npad	 2
$LL10@CGReqTaxMo:
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00034	75 1a		 jne	 SHORT $LN11@CGReqTaxMo
  00036	84 d2		 test	 dl, dl
  00038	74 12		 je	 SHORT $LN12@CGReqTaxMo
  0003a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0003d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00040	75 0e		 jne	 SHORT $LN11@CGReqTaxMo
  00042	83 c0 02	 add	 eax, 2
  00045	83 c1 02	 add	 ecx, 2
  00048	84 d2		 test	 dl, dl
  0004a	75 e4		 jne	 SHORT $LL10@CGReqTaxMo
$LN12@CGReqTaxMo:
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 05		 jmp	 SHORT $LN13@CGReqTaxMo
$LN11@CGReqTaxMo:
  00050	1b c0		 sbb	 eax, eax
  00052	83 c8 01	 or	 eax, 1
$LN13@CGReqTaxMo:
  00055	85 c0		 test	 eax, eax
  00057	0f 84 97 00 00
	00		 je	 $LN14@CGReqTaxMo

; 18580: 		return;
; 18581: 
; 18582: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18583: 		|| gObj[iIndex].GuildStatus != G_MASTER)

  0005d	57		 push	 edi
  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00063	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006e	85 c0		 test	 eax, eax
  00070	74 56		 je	 SHORT $LN5@CGReqTaxMo
  00072	81 bc 0e 28 06
	00 00 80 00 00
	00		 cmp	 DWORD PTR [esi+ecx+1576], 128 ; 00000080H
  0007d	75 49		 jne	 SHORT $LN5@CGReqTaxMo
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0007f	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00084	85 c0		 test	 eax, eax
  00086	74 06		 je	 SHORT $LN8@CGReqTaxMo

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00088	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  0008c	eb 03		 jmp	 SHORT $LN7@CGReqTaxMo
$LN8@CGReqTaxMo:

; 58   : 		}
; 59   : 		return -1;

  0008e	83 c8 ff	 or	 eax, -1
$LN7@CGReqTaxMo:
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18590: 	GS_GDReqTaxInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

  00091	53		 push	 ebx
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?GS_GDReqTaxInfo@@YAXHH@Z ; GS_GDReqTaxInfo

; 18591: 	LogAddTD("[CastleSiege] CGReqTaxMoneyInfo() REQ OK - [%s][%s], Guild:(%s)(%d)",

  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009e	03 ce		 add	 ecx, esi
  000a0	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  000a6	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  000ac	50		 push	 eax
  000ad	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000b0	50		 push	 eax
  000b1	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000b4	50		 push	 eax
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@COLPGPNH@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c0	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx

; 18592: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18593: 
; 18594: #endif
; 18595: }

  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
$LN5@CGReqTaxMo:

; 18584: 	{
; 18585: 		LogAddC(2,"[CastleSiege] CGReqTaxMoneyInfo() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",

  000c8	ff b4 0e 28 06
	00 00		 push	 DWORD PTR [esi+ecx+1576]
  000cf	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  000d5	03 c6		 add	 eax, esi
  000d7	50		 push	 eax
  000d8	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000db	03 c6		 add	 eax, esi
  000dd	50		 push	 eax
  000de	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000e1	03 c6		 add	 eax, esi
  000e3	50		 push	 eax
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@DCLHCCNM@?$FLCastleSiege?$FN?5CGReqTaxMoneyInfo?$CI@
  000e9	6a 02		 push	 2
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000f1	83 c4 18	 add	 esp, 24			; 00000018H
$LN14@CGReqTaxMo:
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx
$LN1@CGReqTaxMo:

; 18592: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18593: 
; 18594: #endif
; 18595: }

  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z ENDP ; CGReqTaxMoneyInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsNpcUpgrade@@YAXHHHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iNpcUpType$ = 24					; size = 4
_iNpcUpValue$ = 28					; size = 4
?GCAnsNpcUpgrade@@YAXHHHHHH@Z PROC			; GCAnsNpcUpgrade, COMDAT

; 18554: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18555: #if (GS_CASTLE==1)
; 18556: 
; 18557: 	PMSG_ANS_NPCUPGRADE pMsgResult;
; 18558: 
; 18559: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x07,sizeof(pMsgResult));
; 18560: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  00013	88 45 e8	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18561: 	pMsgResult.iNpcNumber = iNpcNumber;

  00016	8b 45 10	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  00019	89 45 ec	 mov	 DWORD PTR _pMsgResult$[ebp+8], eax

; 18562: 	pMsgResult.iNpcIndex = iNpcIndex;

  0001c	8b 45 14	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  0001f	89 45 f0	 mov	 DWORD PTR _pMsgResult$[ebp+12], eax

; 18563: 	pMsgResult.iNpcUpType = iNpcUpType;

  00022	8b 45 18	 mov	 eax, DWORD PTR _iNpcUpType$[ebp]
  00025	89 45 f4	 mov	 DWORD PTR _pMsgResult$[ebp+16], eax

; 18564: 	pMsgResult.iNpcUpValue = iNpcUpValue;

  00028	8b 45 1c	 mov	 eax, DWORD PTR _iNpcUpValue$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _pMsgResult$[ebp+20], eax

; 18566: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0002e	8d 45 e4	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00031	6a 18		 push	 24			; 00000018H
  00033	50		 push	 eax
  00034	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00037	c7 45 e4 c1 18
	b2 07		 mov	 DWORD PTR _pMsgResult$[ebp], 129112257 ; 07b218c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18566: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0003e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18567: #endif
; 18568: }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?GCAnsNpcUpgrade@@YAXHHHHHH@Z ENDP			; GCAnsNpcUpgrade
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
_TEXT	SEGMENT
_pNpcData$2 = -156					; size = 116
_pNpcData$3 = -156					; size = 116
_iCUR_UPLVL$8$ = -40					; size = 4
_iCUR_UPLVL$4$ = -40					; size = 4
tv1074 = -36						; size = 4
_iNXT_UPVALUE$1$ = -32					; size = 4
_iNEED_GEMOFDEFEND$1$ = -28				; size = 4
_iNEED_MONEY$1$ = -24					; size = 4
_iGEMOFDEFEND_COUNT$1$ = -20				; size = 4
_bENABLE_UPGRADE$1$ = -20				; size = 4
tv1068 = -16						; size = 4
_iNXT_UPLVL$5$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z PROC	; CGReqNpcUpgrade, COMDAT

; 18301: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 18302: #if (GS_CASTLE==1)
; 18303: 	if(lpMsg == NULL)

  0002b	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0002e	85 f6		 test	 esi, esi
  00030	0f 84 9f 06 00
	00		 je	 $LN1@CGReqNpcUp

; 18304: 		return;
; 18305: 
; 18306: 	if(gObjIsConnected(iIndex) == FALSE)

  00036	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003f	83 c4 04	 add	 esp, 4
  00042	85 c0		 test	 eax, eax
  00044	0f 84 8b 06 00
	00		 je	 $LN1@CGReqNpcUp

; 18307: 		return;
; 18308: 
; 18309: 	int iNEED_GEMOFDEFEND = 0;
; 18310: 	int iNEED_MONEY = 0;
; 18311: 	int iCUR_UPLVL = 0;
; 18312: 	int iNXT_UPLVL = 0;
; 18313: 	int iNXT_UPVALUE = 0;
; 18314: 	int bENABLE_UPGRADE = FALSE;
; 18315: 
; 18316: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00054	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  0005a	05 1c 06 00 00	 add	 eax, 1564		; 0000061cH
  0005f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iNEED_GEMOFDEFEND$1$[ebp], 0
  00066	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iNEED_MONEY$1$[ebp], 0
  0006d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _iNXT_UPVALUE$1$[ebp], 0
  00074	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bENABLE_UPGRADE$1$[ebp], 0
  0007b	03 c3		 add	 eax, ebx
  0007d	89 5d dc	 mov	 DWORD PTR tv1074[ebp], ebx
  00080	89 45 f0	 mov	 DWORD PTR tv1068[ebp], eax
$LL135@CGReqNpcUp:
  00083	8a 10		 mov	 dl, BYTE PTR [eax]
  00085	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00087	75 1a		 jne	 SHORT $LN136@CGReqNpcUp
  00089	84 d2		 test	 dl, dl
  0008b	74 12		 je	 SHORT $LN137@CGReqNpcUp
  0008d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00090	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00093	75 0e		 jne	 SHORT $LN136@CGReqNpcUp
  00095	83 c0 02	 add	 eax, 2
  00098	83 c1 02	 add	 ecx, 2
  0009b	84 d2		 test	 dl, dl
  0009d	75 e4		 jne	 SHORT $LL135@CGReqNpcUp
$LN137@CGReqNpcUp:
  0009f	33 c0		 xor	 eax, eax
  000a1	eb 05		 jmp	 SHORT $LN138@CGReqNpcUp
$LN136@CGReqNpcUp:
  000a3	1b c0		 sbb	 eax, eax
  000a5	83 c8 01	 or	 eax, 1
$LN138@CGReqNpcUp:
  000a8	85 c0		 test	 eax, eax
  000aa	0f 84 25 06 00
	00		 je	 $LN1@CGReqNpcUp

; 18317: 		return;
; 18318: 
; 18319: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18320: 		|| gObj[iIndex].GuildStatus != G_MASTER)

  000b0	ff 75 f0	 push	 DWORD PTR tv1068[ebp]
  000b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b8	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c3	85 c0		 test	 eax, eax
  000c5	0f 84 e0 05 00
	00		 je	 $LN27@CGReqNpcUp
  000cb	81 bc 0b 28 06
	00 00 80 00 00
	00		 cmp	 DWORD PTR [ebx+ecx+1576], 128 ; 00000080H
  000d6	0f 85 cf 05 00
	00		 jne	 $LN27@CGReqNpcUp

; 18323: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus);
; 18324: 		return;
; 18325: 	}
; 18326: 
; 18327: 	switch(lpMsg->iNpcNumber)

  000dc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000df	2d 15 01 00 00	 sub	 eax, 277		; 00000115H
  000e4	0f 84 17 02 00
	00		 je	 $LN28@CGReqNpcUp
  000ea	83 e8 06	 sub	 eax, 6
  000ed	0f 85 68 03 00
	00		 jne	 $LN130@CGReqNpcUp

; 18397: 			return;
; 18398: 		}
; 18399: 	}
; 18400: 		break;
; 18401: 	case 283:
; 18402: 	{
; 18403: 		_CS_NPC_DATA pNpcData;

  000f3	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$2[ebp]
  000f9	e8 00 00 00 00	 call	 ??0_CS_NPC_DATA@@QAE@XZ	; _CS_NPC_DATA::_CS_NPC_DATA

; 18404: 
; 18405: 		int bIsLive = g_CastleSiege.GetNpcData(lpMsg->iNpcNumber,lpMsg->iNpcIndex,(_CS_NPC_DATA &)pNpcData);

  000fe	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _pNpcData$2[ebp]
  00104	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0010b	50		 push	 eax
  0010c	ff 76 08	 push	 DWORD PTR [esi+8]
  0010f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00114	68 1b 01 00 00	 push	 283			; 0000011bH
  00119	e8 00 00 00 00	 call	 ?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z ; CCastleSiege::GetNpcData

; 18406: 
; 18407: 		if(bIsLive != FALSE)

  0011e	85 c0		 test	 eax, eax
  00120	0f 84 5c 05 00
	00		 je	 $LN29@CGReqNpcUp

; 18408: 		{
; 18409: 			switch(lpMsg->iNpcUpType)

  00126	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00129	8b c1		 mov	 eax, ecx
  0012b	83 e8 01	 sub	 eax, 1
  0012e	0f 84 71 01 00
	00		 je	 $LN43@CGReqNpcUp
  00134	83 e8 01	 sub	 eax, 1
  00137	0f 84 1c 01 00
	00		 je	 $LN46@CGReqNpcUp
  0013d	83 e8 01	 sub	 eax, 1
  00140	74 5b		 je	 SHORT $LN49@CGReqNpcUp

; 18479: 			default:
; 18480: 				GCAnsNpcUpgrade(iIndex,5,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  00142	ff 76 10	 push	 DWORD PTR [esi+16]
  00145	51		 push	 ecx
  00146	ff 76 08	 push	 DWORD PTR [esi+8]
  00149	ff 76 04	 push	 DWORD PTR [esi+4]
  0014c	6a 05		 push	 5
  0014e	57		 push	 edi
  0014f	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 18481: 				LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - UpType doesn't Exist [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d",

  00154	ff 76 10	 push	 DWORD PTR [esi+16]
  00157	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0015d	ff 76 0c	 push	 DWORD PTR [esi+12]
  00160	03 cb		 add	 ecx, ebx
  00162	ff 76 08	 push	 DWORD PTR [esi+8]
  00165	ff 76 04	 push	 DWORD PTR [esi+4]
  00168	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  0016e	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  00174	50		 push	 eax
  00175	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00178	50		 push	 eax
  00179	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0017c	50		 push	 eax
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@CCMCIINC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00188	83 c4 3c	 add	 esp, 60			; 0000003cH

; 18539: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);
; 18540: #endif
; 18541: }

  0018b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0018e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00195	59		 pop	 ecx
  00196	5f		 pop	 edi
  00197	5e		 pop	 esi
  00198	5b		 pop	 ebx
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
$LN49@CGReqNpcUp:

; 18442: 					}
; 18443: 				}
; 18444: 				break;
; 18445: 			case 3:
; 18446: 				{
; 18447: 					iCUR_UPLVL = 0;
; 18448: 					int iLV;
; 18449: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18450: 					{
; 18451: 						if(pNpcData.m_iNPC_MAXHP >= g_iNpcUpMaxHP_CSTATUE[iLV][0])

  0019d	8b 45 88	 mov	 eax, DWORD PTR _pNpcData$2[ebp+36]
  001a0	33 db		 xor	 ebx, ebx
  001a2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA
  001a8	b9 01 00 00 00	 mov	 ecx, 1

; 18452: 						{
; 18453: 							iCUR_UPLVL = iLV+1;
; 18454: 						}
; 18455: 					}
; 18456: 
; 18457: 					iNXT_UPLVL = 0;
; 18458: 
; 18459: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18460: 					{
; 18461: 						if(lpMsg->iNpcUpValue >= g_iNpcUpMaxHP_CSTATUE[iLV][0])

  001ad	bf 01 00 00 00	 mov	 edi, 1
  001b2	0f 4d d9	 cmovge	 ebx, ecx
  001b5	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA+12
  001bb	b9 02 00 00 00	 mov	 ecx, 2
  001c0	0f 4d d9	 cmovge	 ebx, ecx
  001c3	8b d1		 mov	 edx, ecx
  001c5	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA+24
  001cb	b8 03 00 00 00	 mov	 eax, 3
  001d0	0f 4d d8	 cmovge	 ebx, eax
  001d3	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  001d6	89 5d d8	 mov	 DWORD PTR _iCUR_UPLVL$4$[ebp], ebx
  001d9	33 db		 xor	 ebx, ebx
  001db	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA
  001e1	0f 4d df	 cmovge	 ebx, edi
  001e4	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA+12
  001ea	0f 4d da	 cmovge	 ebx, edx
  001ed	89 5d f0	 mov	 DWORD PTR _iNXT_UPLVL$5$[ebp], ebx
  001f0	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA+24
  001f6	7c 0a		 jl	 SHORT $LN114@CGReqNpcUp

; 18462: 						{
; 18463: 							iNXT_UPLVL = iLV+1;

  001f8	bb 03 00 00 00	 mov	 ebx, 3
  001fd	89 5d f0	 mov	 DWORD PTR _iNXT_UPLVL$5$[ebp], ebx

; 18464: 						}
; 18465: 					}
; 18466: 
; 18467: 					if(iNXT_UPLVL >= 1 && iNXT_UPLVL <= CS_MAX_UPGRADE)

  00200	eb 12		 jmp	 SHORT $LN132@CGReqNpcUp
$LN114@CGReqNpcUp:
  00202	83 fb 01	 cmp	 ebx, 1
  00205	0f 8c e2 00 00
	00		 jl	 $LN143@CGReqNpcUp
  0020b	83 fb 03	 cmp	 ebx, 3
  0020e	0f 8f d9 00 00
	00		 jg	 $LN143@CGReqNpcUp
$LN132@CGReqNpcUp:

; 18468: 					{
; 18469: 						if(iNXT_UPLVL == iCUR_UPLVL + 1)

  00214	8b 45 d8	 mov	 eax, DWORD PTR _iCUR_UPLVL$4$[ebp]

; 18475: 						}
; 18476: 					}
; 18477: 				}
; 18478: 				break;

  00217	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0021a	40		 inc	 eax
  0021b	3b d8		 cmp	 ebx, eax
  0021d	0f 85 cc 00 00
	00		 jne	 $LN144@CGReqNpcUp

; 18470: 						{
; 18471: 							bENABLE_UPGRADE = TRUE;

  00223	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00226	89 7d ec	 mov	 DWORD PTR _bENABLE_UPGRADE$1$[ebp], edi

; 18472: 							iNXT_UPVALUE = g_iNpcUpMaxHP_CSTATUE[iNXT_UPLVL - 1][0];

  00229	8b 0c 85 f4 ff
	ff ff		 mov	 ecx, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA[eax*4-12]
  00230	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00233	89 4d e0	 mov	 DWORD PTR _iNXT_UPVALUE$1$[ebp], ecx

; 18473: 							iNEED_GEMOFDEFEND = g_iNpcUpMaxHP_CSTATUE[iNXT_UPLVL - 1][1];

  00236	8b 0c 85 f8 ff
	ff ff		 mov	 ecx, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA[eax*4-8]

; 18474: 							iNEED_MONEY = g_iNpcUpMaxHP_CSTATUE[iNXT_UPLVL - 1][2];

  0023d	8b 04 85 fc ff
	ff ff		 mov	 eax, DWORD PTR ?g_iNpcUpMaxHP_CSTATUE@@3PAY02HA[eax*4-4]
  00244	89 4d e4	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$1$[ebp], ecx
  00247	89 45 e8	 mov	 DWORD PTR _iNEED_MONEY$1$[ebp], eax
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h

; 75   : 	{

  0024a	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pNpcData$2[ebp], OFFSET ??_7_CS_NPC_DATA@@6B@
  00254	e9 f5 01 00 00	 jmp	 $LN33@CGReqNpcUp
$LN46@CGReqNpcUp:
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18431: 				iNXT_UPLVL = lpMsg->iNpcUpValue;

  00259	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0025c	8b da		 mov	 ebx, edx
  0025e	89 5d f0	 mov	 DWORD PTR _iNXT_UPLVL$5$[ebp], ebx

; 18432: 
; 18433: 				if(iNXT_UPLVL >= 1 && iNXT_UPLVL <= CS_MAX_UPGRADE)

  00261	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00264	83 f8 02	 cmp	 eax, 2
  00267	0f 87 85 00 00
	00		 ja	 $LN45@CGReqNpcUp

; 18434: 				{
; 18435: 					if(iNXT_UPLVL == iCUR_UPLVL + 1)

  0026d	8b 45 84	 mov	 eax, DWORD PTR _pNpcData$2[ebp+32]
  00270	40		 inc	 eax
  00271	3b d8		 cmp	 ebx, eax
  00273	75 7d		 jne	 SHORT $LN45@CGReqNpcUp

; 18436: 					{
; 18437: 						bENABLE_UPGRADE = TRUE;
; 18438: 						iNXT_UPVALUE = iNXT_UPLVL;
; 18439: 
; 18440: 						iNEED_GEMOFDEFEND = g_iNpcUpRgLevel_CSTATUE[iNXT_UPLVL - 1][1];

  00275	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00278	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bENABLE_UPGRADE$1$[ebp], 1
  0027f	8b 0c 85 f8 ff
	ff ff		 mov	 ecx, DWORD PTR ?g_iNpcUpRgLevel_CSTATUE@@3PAY02HA[eax*4-8]

; 18441: 						iNEED_MONEY = g_iNpcUpRgLevel_CSTATUE[iNXT_UPLVL - 1][2];

  00286	8b 04 85 fc ff
	ff ff		 mov	 eax, DWORD PTR ?g_iNpcUpRgLevel_CSTATUE@@3PAY02HA[eax*4-4]
  0028d	89 5d e0	 mov	 DWORD PTR _iNXT_UPVALUE$1$[ebp], ebx
  00290	89 4d e4	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$1$[ebp], ecx
  00293	89 45 e8	 mov	 DWORD PTR _iNEED_MONEY$1$[ebp], eax
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h

; 75   : 	{

  00296	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pNpcData$2[ebp], OFFSET ??_7_CS_NPC_DATA@@6B@
  002a0	e9 a9 01 00 00	 jmp	 $LN33@CGReqNpcUp
$LN43@CGReqNpcUp:
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18414: 				iNXT_UPLVL = lpMsg->iNpcUpValue;

  002a5	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  002a8	8b da		 mov	 ebx, edx
  002aa	89 5d f0	 mov	 DWORD PTR _iNXT_UPLVL$5$[ebp], ebx

; 18415: 
; 18416: 				if(iNXT_UPLVL >= 1 && iNXT_UPLVL <= CS_MAX_UPGRADE)

  002ad	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  002b0	83 f8 02	 cmp	 eax, 2
  002b3	77 3d		 ja	 SHORT $LN45@CGReqNpcUp

; 18417: 				{
; 18418: 					if(iNXT_UPLVL == iCUR_UPLVL + 1)

  002b5	8b 45 80	 mov	 eax, DWORD PTR _pNpcData$2[ebp+28]
  002b8	40		 inc	 eax
  002b9	3b d8		 cmp	 ebx, eax
  002bb	75 35		 jne	 SHORT $LN45@CGReqNpcUp

; 18419: 					{
; 18420: 						bENABLE_UPGRADE = TRUE;
; 18421: 						iNXT_UPVALUE = iNXT_UPLVL;
; 18422: 
; 18423: 						iNEED_GEMOFDEFEND = g_iNpcUpDfLevel_CSTATUE[iNXT_UPLVL - 1][1];

  002bd	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  002c0	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bENABLE_UPGRADE$1$[ebp], 1
  002c7	8b 0c 85 f8 ff
	ff ff		 mov	 ecx, DWORD PTR ?g_iNpcUpDfLevel_CSTATUE@@3PAY02HA[eax*4-8]

; 18424: 						iNEED_MONEY = g_iNpcUpDfLevel_CSTATUE[iNXT_UPLVL - 1][2];

  002ce	8b 04 85 fc ff
	ff ff		 mov	 eax, DWORD PTR ?g_iNpcUpDfLevel_CSTATUE@@3PAY02HA[eax*4-4]
  002d5	89 5d e0	 mov	 DWORD PTR _iNXT_UPVALUE$1$[ebp], ebx
  002d8	89 4d e4	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$1$[ebp], ecx
  002db	89 45 e8	 mov	 DWORD PTR _iNEED_MONEY$1$[ebp], eax
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h

; 75   : 	{

  002de	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pNpcData$2[ebp], OFFSET ??_7_CS_NPC_DATA@@6B@
  002e8	e9 61 01 00 00	 jmp	 $LN33@CGReqNpcUp
$LN143@CGReqNpcUp:
  002ed	8b d0		 mov	 edx, eax
$LN144@CGReqNpcUp:
  002ef	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
$LN45@CGReqNpcUp:
  002f2	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _pNpcData$2[ebp], OFFSET ??_7_CS_NPC_DATA@@6B@
  002fc	e9 4d 01 00 00	 jmp	 $LN33@CGReqNpcUp
$LN28@CGReqNpcUp:
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18331: 		_CS_NPC_DATA pNpcData;

  00301	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$3[ebp]
  00307	e8 00 00 00 00	 call	 ??0_CS_NPC_DATA@@QAE@XZ	; _CS_NPC_DATA::_CS_NPC_DATA

; 18332: 
; 18333: 		int bIsLive = g_CastleSiege.GetNpcData(lpMsg->iNpcNumber,lpMsg->iNpcIndex,(_CS_NPC_DATA &)pNpcData);

  0030c	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _pNpcData$3[ebp]
  00312	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00319	50		 push	 eax
  0031a	ff 76 08	 push	 DWORD PTR [esi+8]
  0031d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00322	68 15 01 00 00	 push	 277			; 00000115H
  00327	e8 00 00 00 00	 call	 ?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z ; CCastleSiege::GetNpcData

; 18334: 
; 18335: 		if(bIsLive != FALSE)

  0032c	85 c0		 test	 eax, eax
  0032e	0f 84 4e 03 00
	00		 je	 $LN29@CGReqNpcUp

; 18336: 		{
; 18337: 			switch(lpMsg->iNpcUpType)

  00334	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00337	8b c1		 mov	 eax, ecx
  00339	83 e8 01	 sub	 eax, 1
  0033c	0f 84 cc 00 00
	00		 je	 $LN31@CGReqNpcUp
  00342	83 e8 02	 sub	 eax, 2
  00345	74 27		 je	 SHORT $LN34@CGReqNpcUp

; 18389: 			default:
; 18390: 				GCAnsNpcUpgrade(iIndex,5,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  00347	ff 76 10	 push	 DWORD PTR [esi+16]
  0034a	51		 push	 ecx
  0034b	ff 76 08	 push	 DWORD PTR [esi+8]
  0034e	ff 76 04	 push	 DWORD PTR [esi+4]
  00351	6a 05		 push	 5
  00353	57		 push	 edi
  00354	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade
  00359	83 c4 18	 add	 esp, 24			; 00000018H

; 18539: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);
; 18540: #endif
; 18541: }

  0035c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0035f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00366	59		 pop	 ecx
  00367	5f		 pop	 edi
  00368	5e		 pop	 esi
  00369	5b		 pop	 ebx
  0036a	8b e5		 mov	 esp, ebp
  0036c	5d		 pop	 ebp
  0036d	c3		 ret	 0
$LN34@CGReqNpcUp:

; 18351: 					}
; 18352: 				}
; 18353: 				break;
; 18354: 			case 3:
; 18355: 				{
; 18356: 					iCUR_UPLVL = 0;
; 18357: 					int iLV;
; 18358: 
; 18359: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18360: 					{
; 18361: 						if(pNpcData.m_iNPC_MAXHP >= g_iNpcUpMaxHP_CGATE[iLV][0])

  0036e	8b 45 88	 mov	 eax, DWORD PTR _pNpcData$3[ebp+36]
  00371	33 db		 xor	 ebx, ebx
  00373	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA
  00379	b9 01 00 00 00	 mov	 ecx, 1

; 18362: 						{
; 18363: 							iCUR_UPLVL = iLV+1;
; 18364: 						}
; 18365: 					}
; 18366: 
; 18367: 					iNXT_UPLVL = 0;
; 18368: 
; 18369: 					for(iLV = 0; iLV < CS_MAX_UPGRADE; iLV++)
; 18370: 					{
; 18371: 						if(lpMsg->iNpcUpValue >= g_iNpcUpMaxHP_CGATE[iLV][0])

  0037e	bf 01 00 00 00	 mov	 edi, 1
  00383	0f 4d d9	 cmovge	 ebx, ecx
  00386	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA+12
  0038c	b9 02 00 00 00	 mov	 ecx, 2
  00391	0f 4d d9	 cmovge	 ebx, ecx
  00394	8b d1		 mov	 edx, ecx
  00396	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA+24
  0039c	b8 03 00 00 00	 mov	 eax, 3
  003a1	0f 4d d8	 cmovge	 ebx, eax
  003a4	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  003a7	89 5d d8	 mov	 DWORD PTR _iCUR_UPLVL$8$[ebp], ebx
  003aa	33 db		 xor	 ebx, ebx
  003ac	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA
  003b2	0f 4d df	 cmovge	 ebx, edi
  003b5	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA+12
  003bb	0f 4d da	 cmovge	 ebx, edx
  003be	89 5d f0	 mov	 DWORD PTR _iNXT_UPLVL$5$[ebp], ebx
  003c1	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA+24
  003c7	7c 0a		 jl	 SHORT $LN128@CGReqNpcUp

; 18372: 						{
; 18373: 							iNXT_UPLVL = iLV+1;

  003c9	bb 03 00 00 00	 mov	 ebx, 3
  003ce	89 5d f0	 mov	 DWORD PTR _iNXT_UPLVL$5$[ebp], ebx

; 18374: 						}
; 18375: 					}
; 18376: 
; 18377: 					if(iNXT_UPLVL >= 1 && iNXT_UPLVL <= CS_MAX_UPGRADE)

  003d1	eb 0a		 jmp	 SHORT $LN134@CGReqNpcUp
$LN128@CGReqNpcUp:
  003d3	83 fb 01	 cmp	 ebx, 1
  003d6	7c 71		 jl	 SHORT $LN140@CGReqNpcUp
  003d8	83 fb 03	 cmp	 ebx, 3
  003db	7f 6c		 jg	 SHORT $LN140@CGReqNpcUp
$LN134@CGReqNpcUp:

; 18378: 					{
; 18379: 						if(iNXT_UPLVL == iCUR_UPLVL + 1)

  003dd	8b 45 d8	 mov	 eax, DWORD PTR _iCUR_UPLVL$8$[ebp]

; 18385: 						}
; 18386: 					}
; 18387: 				}
; 18388: 				break;

  003e0	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  003e3	40		 inc	 eax
  003e4	3b d8		 cmp	 ebx, eax
  003e6	75 63		 jne	 SHORT $LN141@CGReqNpcUp

; 18380: 						{
; 18381: 							bENABLE_UPGRADE = TRUE;

  003e8	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  003eb	89 7d ec	 mov	 DWORD PTR _bENABLE_UPGRADE$1$[ebp], edi

; 18382: 							iNXT_UPVALUE = g_iNpcUpMaxHP_CGATE[iNXT_UPLVL - 1][0];

  003ee	8b 0c 85 f4 ff
	ff ff		 mov	 ecx, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA[eax*4-12]
  003f5	89 4d e0	 mov	 DWORD PTR _iNXT_UPVALUE$1$[ebp], ecx

; 18383: 							iNEED_GEMOFDEFEND = g_iNpcUpMaxHP_CGATE[iNXT_UPLVL - 1][1];

  003f8	8b 0c 85 f8 ff
	ff ff		 mov	 ecx, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA[eax*4-8]

; 18384: 							iNEED_MONEY = g_iNpcUpMaxHP_CGATE[iNXT_UPLVL - 1][2];

  003ff	8b 04 85 fc ff
	ff ff		 mov	 eax, DWORD PTR ?g_iNpcUpMaxHP_CGATE@@3PAY02HA[eax*4-4]
  00406	89 4d e4	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$1$[ebp], ecx
  00409	89 45 e8	 mov	 DWORD PTR _iNEED_MONEY$1$[ebp], eax

; 18385: 						}
; 18386: 					}
; 18387: 				}
; 18388: 				break;

  0040c	eb 3d		 jmp	 SHORT $LN141@CGReqNpcUp
$LN31@CGReqNpcUp:

; 18338: 			{
; 18339: 			case 1:
; 18340: 				iCUR_UPLVL = pNpcData.m_iNPC_DF_LEVEL;
; 18341: 				iNXT_UPLVL = lpMsg->iNpcUpValue;

  0040e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00411	8b da		 mov	 ebx, edx
  00413	89 5d f0	 mov	 DWORD PTR _iNXT_UPLVL$5$[ebp], ebx

; 18342: 
; 18343: 				if(iNXT_UPLVL >= 1 && iNXT_UPLVL <= CS_MAX_UPGRADE)

  00416	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00419	83 f8 02	 cmp	 eax, 2
  0041c	77 30		 ja	 SHORT $LN33@CGReqNpcUp

; 18344: 				{
; 18345: 					if(iNXT_UPLVL == iCUR_UPLVL + 1)

  0041e	8b 45 80	 mov	 eax, DWORD PTR _pNpcData$3[ebp+28]
  00421	40		 inc	 eax
  00422	3b d8		 cmp	 ebx, eax
  00424	75 28		 jne	 SHORT $LN33@CGReqNpcUp

; 18346: 					{
; 18347: 						bENABLE_UPGRADE = TRUE;
; 18348: 						iNXT_UPVALUE = iNXT_UPLVL;
; 18349: 						iNEED_GEMOFDEFEND = g_iNpcUpDfLevel_CGATE[iNXT_UPLVL - 1][1];

  00426	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  00429	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bENABLE_UPGRADE$1$[ebp], 1
  00430	8b 0c 85 f8 ff
	ff ff		 mov	 ecx, DWORD PTR ?g_iNpcUpDfLevel_CGATE@@3PAY02HA[eax*4-8]

; 18350: 						iNEED_MONEY = g_iNpcUpDfLevel_CGATE[iNXT_UPLVL - 1][2];

  00437	8b 04 85 fc ff
	ff ff		 mov	 eax, DWORD PTR ?g_iNpcUpDfLevel_CGATE@@3PAY02HA[eax*4-4]
  0043e	89 5d e0	 mov	 DWORD PTR _iNXT_UPVALUE$1$[ebp], ebx
  00441	89 4d e4	 mov	 DWORD PTR _iNEED_GEMOFDEFEND$1$[ebp], ecx
  00444	89 45 e8	 mov	 DWORD PTR _iNEED_MONEY$1$[ebp], eax
  00447	eb 05		 jmp	 SHORT $LN33@CGReqNpcUp
$LN140@CGReqNpcUp:
  00449	8b d0		 mov	 edx, eax
$LN141@CGReqNpcUp:
  0044b	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
$LN33@CGReqNpcUp:

; 18482: 					gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);
; 18483: 				return;
; 18484: 			}
; 18485: 		}
; 18486: 		else
; 18487: 		{
; 18488: 			GCAnsNpcUpgrade(iIndex,7,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);
; 18489: 			return;
; 18490: 		}
; 18491: 	}
; 18492: 		break;
; 18493: 	}
; 18494: 
; 18495: 	if(bENABLE_UPGRADE == FALSE)

  0044e	83 7d ec 00	 cmp	 DWORD PTR _bENABLE_UPGRADE$1$[ebp], 0
  00452	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00459	75 29		 jne	 SHORT $LN55@CGReqNpcUp
$LN130@CGReqNpcUp:

; 18496: 	{
; 18497: 		GCAnsNpcUpgrade(iIndex,6,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  0045b	ff 76 10	 push	 DWORD PTR [esi+16]
  0045e	ff 76 0c	 push	 DWORD PTR [esi+12]
  00461	ff 76 08	 push	 DWORD PTR [esi+8]
  00464	ff 76 04	 push	 DWORD PTR [esi+4]
  00467	6a 06		 push	 6
  00469	57		 push	 edi
  0046a	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade
  0046f	83 c4 18	 add	 esp, 24			; 00000018H

; 18539: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);
; 18540: #endif
; 18541: }

  00472	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00475	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0047c	59		 pop	 ecx
  0047d	5f		 pop	 edi
  0047e	5e		 pop	 esi
  0047f	5b		 pop	 ebx
  00480	8b e5		 mov	 esp, ebp
  00482	5d		 pop	 ebp
  00483	c3		 ret	 0
$LN55@CGReqNpcUp:

; 18498: 		return;
; 18499: 	}
; 18500: 
; 18501: 	if(gObj[iIndex].Money < iNEED_MONEY)

  00484	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0048a	8b 45 dc	 mov	 eax, DWORD PTR tv1074[ebp]
  0048d	8b 5d e8	 mov	 ebx, DWORD PTR _iNEED_MONEY$1$[ebp]
  00490	39 9c 08 cc 00
	00 00		 cmp	 DWORD PTR [eax+ecx+204], ebx
  00497	8b 5d f0	 mov	 ebx, DWORD PTR _iNXT_UPLVL$5$[ebp]
  0049a	7d 66		 jge	 SHORT $LN56@CGReqNpcUp

; 18502: 	{
; 18503: 		GCAnsNpcUpgrade(iIndex,3,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  0049c	52		 push	 edx
  0049d	ff 76 0c	 push	 DWORD PTR [esi+12]
  004a0	ff 76 08	 push	 DWORD PTR [esi+8]
  004a3	ff 76 04	 push	 DWORD PTR [esi+4]
  004a6	6a 03		 push	 3
  004a8	57		 push	 edi
  004a9	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 18504: 		LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - Money is Low [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d, Money:%d, Need Money:%d",

  004ae	ff 75 e8	 push	 DWORD PTR _iNEED_MONEY$1$[ebp]
  004b1	8b 4d dc	 mov	 ecx, DWORD PTR tv1074[ebp]
  004b4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004ba	ff b1 cc 00 00
	00		 push	 DWORD PTR [ecx+204]
  004c0	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  004c6	53		 push	 ebx
  004c7	ff 76 10	 push	 DWORD PTR [esi+16]
  004ca	ff 76 0c	 push	 DWORD PTR [esi+12]
  004cd	ff 76 08	 push	 DWORD PTR [esi+8]
  004d0	ff 76 04	 push	 DWORD PTR [esi+4]
  004d3	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  004d9	50		 push	 eax
  004da	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  004dd	50		 push	 eax
  004de	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  004e1	50		 push	 eax
  004e2	68 00 00 00 00	 push	 OFFSET ??_C@_0JK@PKCLEPDN@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  004e7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004ed	83 c4 48	 add	 esp, 72			; 00000048H

; 18539: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);
; 18540: #endif
; 18541: }

  004f0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004f3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004fa	59		 pop	 ecx
  004fb	5f		 pop	 edi
  004fc	5e		 pop	 esi
  004fd	5b		 pop	 ebx
  004fe	8b e5		 mov	 esp, ebp
  00500	5d		 pop	 ebp
  00501	c3		 ret	 0
$LN56@CGReqNpcUp:

; 18505: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL,gObj[iIndex].Money,iNEED_MONEY);
; 18506: 		return;
; 18507: 	}
; 18508: 
; 18509: 	int iGEMOFDEFEND_COUNT = 0;

  00502	33 f6		 xor	 esi, esi
  00504	8b d8		 mov	 ebx, eax
  00506	33 ff		 xor	 edi, edi
  00508	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL22@CGReqNpcUp:

; 18512: 	{
; 18513: 		if(gObj[iIndex].pInventory[x].IsItem() == TRUE && gObj[iIndex].pInventory[x].m_Type == ITEMGET(14,31))

  00510	8b 8c 0b c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+ecx+4544]
  00517	03 cf		 add	 ecx, edi
  00519	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0051e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00524	83 f8 01	 cmp	 eax, 1
  00527	75 14		 jne	 SHORT $LN20@CGReqNpcUp
  00529	8b 84 0b c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+4544]
  00530	ba 1f 1c 00 00	 mov	 edx, 7199		; 00001c1fH
  00535	66 39 54 38 06	 cmp	 WORD PTR [eax+edi+6], dx
  0053a	75 01		 jne	 SHORT $LN20@CGReqNpcUp

; 18514: 		{
; 18515: 			iGEMOFDEFEND_COUNT++;

  0053c	46		 inc	 esi
$LN20@CGReqNpcUp:

; 18510: 
; 18511: 	for(int x = 0; x < INVENTORY_SIZE; x++)

  0053d	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00543	81 ff 44 c4 00
	00		 cmp	 edi, 50244		; 0000c444H
  00549	7c c5		 jl	 SHORT $LL22@CGReqNpcUp

; 18516: 		}
; 18517: 	}
; 18518: 
; 18519: 	if(iGEMOFDEFEND_COUNT < iNEED_GEMOFDEFEND)

  0054b	3b 75 e4	 cmp	 esi, DWORD PTR _iNEED_GEMOFDEFEND$1$[ebp]
  0054e	8b 5d f0	 mov	 ebx, DWORD PTR _iNXT_UPLVL$5$[ebp]

; 18520: 	{
; 18521: 		GCAnsNpcUpgrade(iIndex,4,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  00551	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]
  00554	89 75 ec	 mov	 DWORD PTR _iGEMOFDEFEND_COUNT$1$[ebp], esi
  00557	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0055a	7d 65		 jge	 SHORT $LN58@CGReqNpcUp
  0055c	ff 76 10	 push	 DWORD PTR [esi+16]
  0055f	ff 76 0c	 push	 DWORD PTR [esi+12]
  00562	ff 76 08	 push	 DWORD PTR [esi+8]
  00565	ff 76 04	 push	 DWORD PTR [esi+4]
  00568	6a 04		 push	 4
  0056a	57		 push	 edi
  0056b	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade

; 18522: 		LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - Gem is Low [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d, Gem:%d, Need Gem:%d",

  00570	ff 75 e4	 push	 DWORD PTR _iNEED_GEMOFDEFEND$1$[ebp]
  00573	8b 4d dc	 mov	 ecx, DWORD PTR tv1074[ebp]
  00576	ff 75 ec	 push	 DWORD PTR _iGEMOFDEFEND_COUNT$1$[ebp]
  00579	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0057f	53		 push	 ebx
  00580	ff 76 10	 push	 DWORD PTR [esi+16]
  00583	ff 76 0c	 push	 DWORD PTR [esi+12]
  00586	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  0058c	ff 76 08	 push	 DWORD PTR [esi+8]
  0058f	ff 76 04	 push	 DWORD PTR [esi+4]
  00592	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  00598	50		 push	 eax
  00599	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0059c	50		 push	 eax
  0059d	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  005a0	50		 push	 eax
  005a1	68 00 00 00 00	 push	 OFFSET ??_C@_0JE@MAAHAGJP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  005a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005ac	83 c4 48	 add	 esp, 72			; 00000048H

; 18539: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);
; 18540: #endif
; 18541: }

  005af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005b9	59		 pop	 ecx
  005ba	5f		 pop	 edi
  005bb	5e		 pop	 esi
  005bc	5b		 pop	 ebx
  005bd	8b e5		 mov	 esp, ebp
  005bf	5d		 pop	 ebp
  005c0	c3		 ret	 0
$LN58@CGReqNpcUp:

; 18523: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL,iGEMOFDEFEND_COUNT,iNEED_GEMOFDEFEND);
; 18524: 		return;
; 18525: 	}
; 18526: 
; 18527: 	int bRESULT = g_CastleSiege.PayForUpgradeDbNPC(iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL -1);

  005c1	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  005c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  005c9	50		 push	 eax
  005ca	ff 76 10	 push	 DWORD PTR [esi+16]
  005cd	ff 76 0c	 push	 DWORD PTR [esi+12]
  005d0	ff 76 08	 push	 DWORD PTR [esi+8]
  005d3	ff 76 04	 push	 DWORD PTR [esi+4]
  005d6	57		 push	 edi
  005d7	e8 00 00 00 00	 call	 ?PayForUpgradeDbNPC@CCastleSiege@@QAEHHHHHHH@Z ; CCastleSiege::PayForUpgradeDbNPC

; 18528: 
; 18529: 	if(bRESULT == FALSE)

  005dc	85 c0		 test	 eax, eax
  005de	0f 84 f1 00 00
	00		 je	 $LN1@CGReqNpcUp

; 18530: 		return;
; 18531: 
; 18532: 	gObj[iIndex].m_bIsCastleNPCUpgradeCompleted = TRUE;

  005e4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005e9	8b 4d dc	 mov	 ecx, DWORD PTR tv1074[ebp]

; 18534: 	LogAddTD("[CastleSiege] [0xB2][0x07] CGReqNpcUpgrade() - Pay For Npc Upgrade (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)",

  005ec	ff 75 e0	 push	 DWORD PTR _iNXT_UPVALUE$1$[ebp]
  005ef	c6 84 01 5c 20
	00 00 01	 mov	 BYTE PTR [ecx+eax+8284], 1
  005f7	ff 76 0c	 push	 DWORD PTR [esi+12]
  005fa	ff 76 08	 push	 DWORD PTR [esi+8]
  005fd	ff 76 04	 push	 DWORD PTR [esi+4]
  00600	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@BFDGFKFN@?$FLCastleSiege?$FN?5?$FL0xB2?$FN?$FL0x07?$FN?5CGReq@
  00605	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0060b	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18534: 	LogAddTD("[CastleSiege] [0xB2][0x07] CGReqNpcUpgrade() - Pay For Npc Upgrade (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)",

  00610	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  00613	85 c0		 test	 eax, eax
  00615	74 06		 je	 SHORT $LN84@CGReqNpcUp

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00617	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  0061b	eb 03		 jmp	 SHORT $LN83@CGReqNpcUp
$LN84@CGReqNpcUp:

; 58   : 		}
; 59   : 		return -1;

  0061d	83 c8 ff	 or	 eax, -1
$LN83@CGReqNpcUp:
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18537: 	GS_GDReqCastleNpcUpgrade(g_MapServerManager.GetMapSvrGroup(),iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,iNXT_UPVALUE,iNXT_UPLVL -1);

  00620	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  00623	51		 push	 ecx
  00624	ff 75 e0	 push	 DWORD PTR _iNXT_UPVALUE$1$[ebp]
  00627	ff 76 0c	 push	 DWORD PTR [esi+12]
  0062a	ff 76 08	 push	 DWORD PTR [esi+8]
  0062d	ff 76 04	 push	 DWORD PTR [esi+4]
  00630	57		 push	 edi
  00631	50		 push	 eax
  00632	e8 00 00 00 00	 call	 ?GS_GDReqCastleNpcUpgrade@@YAXHHHHHHH@Z ; GS_GDReqCastleNpcUpgrade

; 18538: 	LogAddTD("[CastleSiege] CGReqNpcUpgrade() REQ OK - [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d",

  00637	8b 4d dc	 mov	 ecx, DWORD PTR tv1074[ebp]
  0063a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00640	53		 push	 ebx
  00641	ff 76 10	 push	 DWORD PTR [esi+16]
  00644	ff 76 0c	 push	 DWORD PTR [esi+12]
  00647	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  0064d	ff 76 08	 push	 DWORD PTR [esi+8]
  00650	ff 76 04	 push	 DWORD PTR [esi+4]
  00653	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  00659	50		 push	 eax
  0065a	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0065d	50		 push	 eax
  0065e	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00661	50		 push	 eax
  00662	68 00 00 00 00	 push	 OFFSET ??_C@_0HF@MKGLJLP@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  00667	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0066d	83 c4 44	 add	 esp, 68			; 00000044H

; 18539: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);
; 18540: #endif
; 18541: }

  00670	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00673	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0067a	59		 pop	 ecx
  0067b	5f		 pop	 edi
  0067c	5e		 pop	 esi
  0067d	5b		 pop	 ebx
  0067e	8b e5		 mov	 esp, ebp
  00680	5d		 pop	 ebp
  00681	c3		 ret	 0
$LN29@CGReqNpcUp:

; 18391: 				return;
; 18392: 			}
; 18393: 		}
; 18394: 		else
; 18395: 		{
; 18396: 			GCAnsNpcUpgrade(iIndex,7,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);

  00682	ff 76 10	 push	 DWORD PTR [esi+16]
  00685	ff 76 0c	 push	 DWORD PTR [esi+12]
  00688	ff 76 08	 push	 DWORD PTR [esi+8]
  0068b	ff 76 04	 push	 DWORD PTR [esi+4]
  0068e	6a 07		 push	 7
  00690	57		 push	 edi
  00691	e8 00 00 00 00	 call	 ?GCAnsNpcUpgrade@@YAXHHHHHH@Z ; GCAnsNpcUpgrade
  00696	83 c4 18	 add	 esp, 24			; 00000018H

; 18539: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);
; 18540: #endif
; 18541: }

  00699	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0069c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006a3	59		 pop	 ecx
  006a4	5f		 pop	 edi
  006a5	5e		 pop	 esi
  006a6	5b		 pop	 ebx
  006a7	8b e5		 mov	 esp, ebp
  006a9	5d		 pop	 ebp
  006aa	c3		 ret	 0
$LN27@CGReqNpcUp:

; 18321: 	{
; 18322: 		LogAddTD("[CastleSiege] CGReqNpcUpgrade() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",

  006ab	ff b4 0b 28 06
	00 00		 push	 DWORD PTR [ebx+ecx+1576]
  006b2	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  006b8	03 c3		 add	 eax, ebx
  006ba	50		 push	 eax
  006bb	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  006be	03 c3		 add	 eax, ebx
  006c0	50		 push	 eax
  006c1	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  006c4	03 c3		 add	 eax, ebx
  006c6	50		 push	 eax
  006c7	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@FOFEAMPC@?$FLCastleSiege?$FN?5CGReqNpcUpgrade?$CI?$CJ?5@
  006cc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006d2	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@CGReqNpcUp:

; 18539: 		gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);
; 18540: #endif
; 18541: }

  006d5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006df	59		 pop	 ecx
  006e0	5f		 pop	 edi
  006e1	5e		 pop	 esi
  006e2	5b		 pop	 ebx
  006e3	8b e5		 mov	 esp, ebp
  006e5	5d		 pop	 ebp
  006e6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$1:
  00000	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA
__unwindfunclet$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z$0:
  0000b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _pNpcData$3[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA
__ehhandler$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 60 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-160]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z ENDP	; CGReqNpcUpgrade
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsNpcRepair@@YAXHHHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
_iNpcHP$ = 24						; size = 4
_iNpcMaxHP$ = 28					; size = 4
?GCAnsNpcRepair@@YAXHHHHHH@Z PROC			; GCAnsNpcRepair, COMDAT

; 18282: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18283: #if (GS_CASTLE==1)
; 18284: 	PMSG_ANS_NPCREPAIR pMsgResult;
; 18285: 
; 18286: 	pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x06,sizeof(pMsgResult));
; 18287: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  00013	88 45 e8	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18288: 	pMsgResult.iNpcNumber = iNpcNumber;

  00016	8b 45 10	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  00019	89 45 ec	 mov	 DWORD PTR _pMsgResult$[ebp+8], eax

; 18289: 	pMsgResult.iNpcIndex = iNpcIndex;

  0001c	8b 45 14	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  0001f	89 45 f0	 mov	 DWORD PTR _pMsgResult$[ebp+12], eax

; 18290: 	pMsgResult.iNpcHP = iNpcHP;

  00022	8b 45 18	 mov	 eax, DWORD PTR _iNpcHP$[ebp]
  00025	89 45 f4	 mov	 DWORD PTR _pMsgResult$[ebp+16], eax

; 18291: 	pMsgResult.iNpcMaxHP = iNpcMaxHP;

  00028	8b 45 1c	 mov	 eax, DWORD PTR _iNpcMaxHP$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _pMsgResult$[ebp+20], eax

; 18293: 	DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  0002e	8d 45 e4	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00031	6a 18		 push	 24			; 00000018H
  00033	50		 push	 eax
  00034	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00037	c7 45 e4 c1 18
	b2 06		 mov	 DWORD PTR _pMsgResult$[ebp], 112335041 ; 06b218c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18293: 	DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  0003e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18294: #endif
; 18295: }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?GCAnsNpcRepair@@YAXHHHHHH@Z ENDP			; GCAnsNpcRepair
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
_TEXT	SEGMENT
_pNpcData$ = -128					; size = 116
__$EHRec$ = -12						; size = 12
tv403 = 8						; size = 4
tv281 = 8						; size = 4
_iRepairCost$1$ = 8					; size = 4
_iNpcIndex$1$ = 8					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z PROC	; CGReqNpcRepair, COMDAT

; 18185: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 74	 sub	 esp, 116		; 00000074H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 18186: #if (GS_CASTLE==1)
; 18187: 	if(lpMsg == NULL)

  00028	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0002b	85 ff		 test	 edi, edi
  0002d	0f 84 5d 03 00
	00		 je	 $LN50@CGReqNpcRe

; 18188: 		return;
; 18189: 
; 18190: 	if(gObjIsConnected(iIndex) == FALSE)

  00033	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00036	53		 push	 ebx
  00037	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003c	83 c4 04	 add	 esp, 4
  0003f	85 c0		 test	 eax, eax
  00041	0f 84 49 03 00
	00		 je	 $LN50@CGReqNpcRe

; 18191: 		return;
; 18192: 
; 18193: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00051	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00057	05 1c 06 00 00	 add	 eax, 1564		; 0000061cH
  0005c	03 c6		 add	 eax, esi
  0005e	89 45 08	 mov	 DWORD PTR tv403[ebp], eax
$LL52@CGReqNpcRe:
  00061	8a 10		 mov	 dl, BYTE PTR [eax]
  00063	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00065	75 1a		 jne	 SHORT $LN53@CGReqNpcRe
  00067	84 d2		 test	 dl, dl
  00069	74 12		 je	 SHORT $LN54@CGReqNpcRe
  0006b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0006e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00071	75 0e		 jne	 SHORT $LN53@CGReqNpcRe
  00073	83 c0 02	 add	 eax, 2
  00076	83 c1 02	 add	 ecx, 2
  00079	84 d2		 test	 dl, dl
  0007b	75 e4		 jne	 SHORT $LL52@CGReqNpcRe
$LN54@CGReqNpcRe:
  0007d	33 c0		 xor	 eax, eax
  0007f	eb 05		 jmp	 SHORT $LN55@CGReqNpcRe
$LN53@CGReqNpcRe:
  00081	1b c0		 sbb	 eax, eax
  00083	83 c8 01	 or	 eax, 1
$LN55@CGReqNpcRe:
  00086	85 c0		 test	 eax, eax
  00088	0f 84 02 03 00
	00		 je	 $LN50@CGReqNpcRe

; 18194: 		return;
; 18195: 
; 18196: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18197: 		|| (gObj[iIndex].GuildStatus != G_MASTER && gObj[iIndex].GuildStatus != G_SUB_MASTER))

  0008e	ff 75 08	 push	 DWORD PTR tv403[ebp]
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00096	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  0009b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a1	85 c0		 test	 eax, eax
  000a3	0f 84 bb 02 00
	00		 je	 $LN8@CGReqNpcRe
  000a9	8b 84 0e 28 06
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1576]
  000b0	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000b5	74 09		 je	 SHORT $LN7@CGReqNpcRe
  000b7	83 f8 40	 cmp	 eax, 64			; 00000040H
  000ba	0f 85 a4 02 00
	00		 jne	 $LN8@CGReqNpcRe
$LN7@CGReqNpcRe:
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h

; 70   : 		Clear();

  000c0	8d 4d 80	 lea	 ecx, DWORD PTR _pNpcData$[ebp]
  000c3	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _pNpcData$[ebp], OFFSET ??_7_CS_NPC_DATA@@6B@
  000ca	e8 00 00 00 00	 call	 ?Clear@_CS_NPC_DATA@@QAEXXZ ; _CS_NPC_DATA::Clear

; 71   : 		m_iCS_GATE_LEVER_INDEX = -1;

  000cf	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _pNpcData$[ebp+100], -1
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18206: 	int bRETVAL = g_CastleSiege.GetNpcData(lpMsg->iNpcNumber,lpMsg->iNpcIndex,(_CS_NPC_DATA &)pNpcData);

  000d6	8d 45 80	 lea	 eax, DWORD PTR _pNpcData$[ebp]
  000d9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000e0	50		 push	 eax
  000e1	ff 77 08	 push	 DWORD PTR [edi+8]
  000e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000e9	ff 77 04	 push	 DWORD PTR [edi+4]
  000ec	e8 00 00 00 00	 call	 ?GetNpcData@CCastleSiege@@QAEHHHAAU_CS_NPC_DATA@@@Z ; CCastleSiege::GetNpcData

; 18207: 
; 18208: 	if(bRETVAL == FALSE)

  000f1	85 c0		 test	 eax, eax
  000f3	75 59		 jne	 SHORT $LN9@CGReqNpcRe

; 18209: 	{
; 18210: 		GCAnsNpcRepair(iIndex,0,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  000f5	50		 push	 eax
  000f6	50		 push	 eax
  000f7	ff 77 08	 push	 DWORD PTR [edi+8]
  000fa	ff 77 04	 push	 DWORD PTR [edi+4]
  000fd	50		 push	 eax
  000fe	53		 push	 ebx
  000ff	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 18211: 		LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - CL Request Fail [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",

  00104	ff 77 08	 push	 DWORD PTR [edi+8]
  00107	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010d	ff 77 04	 push	 DWORD PTR [edi+4]
  00110	ff b4 0e 28 06
	00 00		 push	 DWORD PTR [esi+ecx+1576]
  00117	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  0011d	03 c6		 add	 eax, esi
  0011f	50		 push	 eax
  00120	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00123	03 c6		 add	 eax, esi
  00125	50		 push	 eax
  00126	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00129	03 c6		 add	 eax, esi
  0012b	50		 push	 eax
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@EJLCHNOA@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
  00131	6a 02		 push	 2
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00139	83 c4 38	 add	 esp, 56			; 00000038H

; 18268: #endif
; 18269: }

  0013c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00146	59		 pop	 ecx
  00147	5f		 pop	 edi
  00148	5e		 pop	 esi
  00149	5b		 pop	 ebx
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
$LN9@CGReqNpcRe:

; 18212: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 18213: 		return;
; 18214: 	}
; 18215: 
; 18216: 	int iNpcIndex = pNpcData.m_iNPC_OBJINDEX;

  0014e	8b 45 98	 mov	 eax, DWORD PTR _pNpcData$[ebp+24]

; 18217: 
; 18218: 	if(gObjIsConnected(iNpcIndex) == FALSE)

  00151	50		 push	 eax
  00152	89 45 08	 mov	 DWORD PTR _iNpcIndex$1$[ebp], eax
  00155	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0015a	83 c4 04	 add	 esp, 4
  0015d	85 c0		 test	 eax, eax
  0015f	74 17		 je	 SHORT $LN59@CGReqNpcRe

; 18219: 	{
; 18220: 		GCAnsNpcRepair(iIndex,0,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);
; 18221: 		LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",
; 18222: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,pNpcData.m_iNPC_NUM,pNpcData.m_iNPC_INDEX);
; 18223: 		return;
; 18224: 	}
; 18225: 
; 18226: 	if(gObj[iNpcIndex].Live == FALSE)

  00161	69 4d 08 40 27
	00 00		 imul	 ecx, DWORD PTR _iNpcIndex$1$[ebp], 10048
  00168	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016e	89 4d 08	 mov	 DWORD PTR tv281[ebp], ecx
  00171	80 7c 11 51 00	 cmp	 BYTE PTR [ecx+edx+81], 0
  00176	75 5c		 jne	 SHORT $LN11@CGReqNpcRe
$LN59@CGReqNpcRe:

; 18227: 	{
; 18228: 		GCAnsNpcRepair(iIndex,0,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  00178	6a 00		 push	 0
  0017a	6a 00		 push	 0
  0017c	ff 77 08	 push	 DWORD PTR [edi+8]
  0017f	ff 77 04	 push	 DWORD PTR [edi+4]
  00182	6a 00		 push	 0
  00184	53		 push	 ebx
  00185	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 18229: 		LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",

  0018a	ff 75 8c	 push	 DWORD PTR _pNpcData$[ebp+12]
  0018d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00193	ff 75 88	 push	 DWORD PTR _pNpcData$[ebp+8]
  00196	ff b4 0e 28 06
	00 00		 push	 DWORD PTR [esi+ecx+1576]
  0019d	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  001a3	03 c6		 add	 eax, esi
  001a5	50		 push	 eax
  001a6	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001a9	03 c6		 add	 eax, esi
  001ab	50		 push	 eax
  001ac	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001af	03 c6		 add	 eax, esi
  001b1	50		 push	 eax
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_0GO@OKDMDNNG@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
  001b7	6a 02		 push	 2
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001bf	83 c4 38	 add	 esp, 56			; 00000038H

; 18268: #endif
; 18269: }

  001c2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001cc	59		 pop	 ecx
  001cd	5f		 pop	 edi
  001ce	5e		 pop	 esi
  001cf	5b		 pop	 ebx
  001d0	8b e5		 mov	 esp, ebp
  001d2	5d		 pop	 ebp
  001d3	c3		 ret	 0
$LN11@CGReqNpcRe:

; 18230: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,pNpcData.m_iNPC_NUM,pNpcData.m_iNPC_INDEX);
; 18231: 		return;
; 18232: 	}
; 18233: 
; 18234: 	if(gObj[iNpcIndex].MaxLife == gObj[iNpcIndex].Life || gObj[iNpcIndex].MaxLife < gObj[iNpcIndex].Life)

  001d4	f3 0f 10 8c 11
	dc 00 00 00	 movss	 xmm1, DWORD PTR [ecx+edx+220]
  001dd	f3 0f 10 94 11
	d8 00 00 00	 movss	 xmm2, DWORD PTR [ecx+edx+216]
  001e6	0f 2e ca	 ucomiss xmm1, xmm2
  001e9	9f		 lahf
  001ea	f6 c4 44	 test	 ah, 68			; 00000044H
  001ed	0f 8b 54 01 00
	00		 jnp	 $LN13@CGReqNpcRe
  001f3	0f 2f d1	 comiss	 xmm2, xmm1
  001f6	0f 87 4b 01 00
	00		 ja	 $LN13@CGReqNpcRe

; 18238: 		return;
; 18239: 	}
; 18240: 
; 18241: 	int iRepairCost = 0;
; 18242: 
; 18243: 	switch(lpMsg->iNpcNumber)

  001fc	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001ff	2d 15 01 00 00	 sub	 eax, 277		; 00000115H
  00204	74 46		 je	 SHORT $LN14@CGReqNpcRe
  00206	83 e8 06	 sub	 eax, 6
  00209	74 18		 je	 SHORT $LN15@CGReqNpcRe

; 18251: 	default:
; 18252: 		GCAnsNpcRepair(iIndex,0,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  0020b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0020e	6a 00		 push	 0
  00210	6a 00		 push	 0
  00212	ff 77 08	 push	 DWORD PTR [edi+8]
  00215	50		 push	 eax
  00216	6a 00		 push	 0
  00218	53		 push	 ebx
  00219	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair
  0021e	e9 6a 01 00 00	 jmp	 $LN57@CGReqNpcRe
$LN15@CGReqNpcRe:

; 18247: 		break;
; 18248: 	case 283:
; 18249: 		iRepairCost = (int)((gObj[iNpcIndex].MaxLife - gObj[iNpcIndex].Life) * 3.0f +  (gObj[iNpcIndex].m_btCsNpcDfLevel + gObj[iNpcIndex].m_btCsNpcRgLevel) * 1000000);

  00223	8b 45 08	 mov	 eax, DWORD PTR tv281[ebp]
  00226	f3 0f 5c ca	 subss	 xmm1, xmm2
  0022a	0f b6 8c 11 59
	20 00 00	 movzx	 ecx, BYTE PTR [ecx+edx+8281]
  00232	0f b6 84 10 58
	20 00 00	 movzx	 eax, BYTE PTR [eax+edx+8280]
  0023a	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40400000
  00242	03 c8		 add	 ecx, eax
  00244	69 c1 40 42 0f
	00		 imul	 eax, ecx, 1000000

; 18250: 		break;

  0024a	eb 1a		 jmp	 SHORT $LN58@CGReqNpcRe
$LN14@CGReqNpcRe:

; 18244: 	{
; 18245: 	case 277:
; 18246: 		iRepairCost = (int)((gObj[iNpcIndex].MaxLife - gObj[iNpcIndex].Life) * 5.0f +  gObj[iNpcIndex].m_btCsNpcDfLevel * 1000000);

  0024c	0f b6 84 11 58
	20 00 00	 movzx	 eax, BYTE PTR [ecx+edx+8280]
  00254	f3 0f 5c ca	 subss	 xmm1, xmm2
  00258	69 c0 40 42 0f
	00		 imul	 eax, eax, 1000000
  0025e	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40a00000
$LN58@CGReqNpcRe:
  00266	66 0f 6e c0	 movd	 xmm0, eax
  0026a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0026d	f3 0f 58 c1	 addss	 xmm0, xmm1
  00271	f3 0f 2c c0	 cvttss2si eax, xmm0
  00275	89 45 08	 mov	 DWORD PTR _iRepairCost$1$[ebp], eax

; 18253: 		return;
; 18254: 	}
; 18255: 
; 18256: 	if(gObj[iIndex].Money < iRepairCost)

  00278	39 84 16 cc 00
	00 00		 cmp	 DWORD PTR [esi+edx+204], eax
  0027f	7d 5d		 jge	 SHORT $LN17@CGReqNpcRe

; 18257: 	{
; 18258: 		GCAnsNpcRepair(iIndex,3,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  00281	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00284	6a 00		 push	 0
  00286	6a 00		 push	 0
  00288	ff 77 08	 push	 DWORD PTR [edi+8]
  0028b	50		 push	 eax
  0028c	6a 03		 push	 3
  0028e	53		 push	 ebx
  0028f	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair

; 18259: 		LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - Money isn't enough [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",

  00294	ff 75 8c	 push	 DWORD PTR _pNpcData$[ebp+12]
  00297	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029d	ff 75 88	 push	 DWORD PTR _pNpcData$[ebp+8]
  002a0	ff b4 0e 28 06
	00 00		 push	 DWORD PTR [esi+ecx+1576]
  002a7	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  002ad	03 c6		 add	 eax, esi
  002af	50		 push	 eax
  002b0	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002b3	03 c6		 add	 eax, esi
  002b5	50		 push	 eax
  002b6	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  002b9	03 c6		 add	 eax, esi
  002bb	50		 push	 eax
  002bc	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@EAKLGMOB@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
  002c1	6a 02		 push	 2
  002c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002c9	83 c4 38	 add	 esp, 56			; 00000038H

; 18268: #endif
; 18269: }

  002cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002d6	59		 pop	 ecx
  002d7	5f		 pop	 edi
  002d8	5e		 pop	 esi
  002d9	5b		 pop	 ebx
  002da	8b e5		 mov	 esp, ebp
  002dc	5d		 pop	 ebp
  002dd	c3		 ret	 0
$LN17@CGReqNpcRe:

; 18264: 	LogAddC(2,"[CastleSiege] CGReqNpcRepair() OK - [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",

  002de	ff 75 8c	 push	 DWORD PTR _pNpcData$[ebp+12]
  002e1	8d 82 1c 06 00
	00		 lea	 eax, DWORD PTR [edx+1564]
  002e7	ff 75 88	 push	 DWORD PTR _pNpcData$[ebp+8]
  002ea	03 c6		 add	 eax, esi
  002ec	ff b4 16 28 06
	00 00		 push	 DWORD PTR [esi+edx+1576]
  002f3	50		 push	 eax
  002f4	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  002f7	03 c6		 add	 eax, esi
  002f9	50		 push	 eax
  002fa	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  002fd	03 c6		 add	 eax, esi
  002ff	50		 push	 eax
  00300	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@DOALANGE@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5O@
  00305	6a 02		 push	 2
  00307	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0030d	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18264: 	LogAddC(2,"[CastleSiege] CGReqNpcRepair() OK - [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",

  00312	83 c4 20	 add	 esp, 32			; 00000020H
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  00315	85 c0		 test	 eax, eax
  00317	74 06		 je	 SHORT $LN47@CGReqNpcRe

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00319	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  0031d	eb 03		 jmp	 SHORT $LN46@CGReqNpcRe
$LN47@CGReqNpcRe:

; 58   : 		}
; 59   : 		return -1;

  0031f	83 c8 ff	 or	 eax, -1
$LN46@CGReqNpcRe:
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18267: 	GS_GDReqCastleNpcRepair(g_MapServerManager.GetMapSvrGroup(),iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,iRepairCost);

  00322	ff 75 08	 push	 DWORD PTR _iRepairCost$1$[ebp]
  00325	ff 77 08	 push	 DWORD PTR [edi+8]
  00328	ff 77 04	 push	 DWORD PTR [edi+4]
  0032b	53		 push	 ebx
  0032c	50		 push	 eax
  0032d	e8 00 00 00 00	 call	 ?GS_GDReqCastleNpcRepair@@YAXHHHHH@Z ; GS_GDReqCastleNpcRepair
  00332	83 c4 14	 add	 esp, 20			; 00000014H

; 18268: #endif
; 18269: }

  00335	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00338	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0033f	59		 pop	 ecx
  00340	5f		 pop	 edi
  00341	5e		 pop	 esi
  00342	5b		 pop	 ebx
  00343	8b e5		 mov	 esp, ebp
  00345	5d		 pop	 ebp
  00346	c3		 ret	 0
$LN13@CGReqNpcRe:

; 18235: 	{
; 18236: 		gObj[iNpcIndex].Life = gObj[iNpcIndex].MaxLife;
; 18237: 		GCAnsNpcRepair(iIndex,0,lpMsg->iNpcNumber,lpMsg->iNpcIndex,0,0);

  00347	6a 00		 push	 0
  00349	6a 00		 push	 0
  0034b	f3 0f 11 8c 11
	d8 00 00 00	 movss	 DWORD PTR [ecx+edx+216], xmm1
  00354	ff 77 08	 push	 DWORD PTR [edi+8]
  00357	ff 77 04	 push	 DWORD PTR [edi+4]
  0035a	6a 00		 push	 0
  0035c	53		 push	 ebx
  0035d	e8 00 00 00 00	 call	 ?GCAnsNpcRepair@@YAXHHHHHH@Z ; GCAnsNpcRepair
; File c:\users\michel\desktop\source\gameserver\source\castlesiege.h

; 75   : 	{

  00362	eb 29		 jmp	 SHORT $LN57@CGReqNpcRe
$LN8@CGReqNpcRe:
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18199: 		LogAddC(2,"[CastleSiege] CGReqNpcRepair() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",

  00364	ff b4 0e 28 06
	00 00		 push	 DWORD PTR [esi+ecx+1576]
  0036b	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  00371	03 c6		 add	 eax, esi
  00373	50		 push	 eax
  00374	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00377	03 c6		 add	 eax, esi
  00379	50		 push	 eax
  0037a	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0037d	03 c6		 add	 eax, esi
  0037f	50		 push	 eax
  00380	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@JKAOCMDF@?$FLCastleSiege?$FN?5CGReqNpcRepair?$CI?$CJ?5E@
  00385	6a 02		 push	 2
  00387	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
$LN57@CGReqNpcRe:
  0038d	83 c4 18	 add	 esp, 24			; 00000018H
$LN50@CGReqNpcRe:

; 18268: #endif
; 18269: }

  00390	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00393	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0039a	59		 pop	 ecx
  0039b	5f		 pop	 edi
  0039c	5e		 pop	 esi
  0039d	5b		 pop	 ebx
  0039e	8b e5		 mov	 esp, ebp
  003a0	5d		 pop	 ebp
  003a1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z$0:
  00000	8d 4d 80	 lea	 ecx, DWORD PTR _pNpcData$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_CS_NPC_DATA@@UAE@XZ	; _CS_NPC_DATA::~_CS_NPC_DATA
__ehhandler$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z ENDP	; CGReqNpcRepair
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsNpcBuy@@YAXHHHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_iNpcNumber$ = 16					; size = 4
_iNpcIndex$ = 20					; size = 4
?GCAnsNpcBuy@@YAXHHHH@Z PROC				; GCAnsNpcBuy, COMDAT

; 18169: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 18170: #if (GS_CASTLE==1)
; 18171: 	PMSG_ANS_NPCBUY pMsgResult;
; 18172: 
; 18173: 	pMsgResult.h.set((BYTE *)&pMsgResult,0xB2,0x05,sizeof(pMsgResult));
; 18174: 	pMsgResult.btResult = iResult;

  00010	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  00013	88 45 f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 18175: 	pMsgResult.iNpcNumber = iNpcNumber;

  00016	8b 45 10	 mov	 eax, DWORD PTR _iNpcNumber$[ebp]
  00019	89 45 f4	 mov	 DWORD PTR _pMsgResult$[ebp+8], eax

; 18176: 	pMsgResult.iNpcIndex = iNpcIndex;

  0001c	8b 45 14	 mov	 eax, DWORD PTR _iNpcIndex$[ebp]
  0001f	89 45 f8	 mov	 DWORD PTR _pMsgResult$[ebp+12], eax

; 18178: 	DataSend(iIndex,(BYTE *)&pMsgResult,pMsgResult.h.size);

  00022	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00025	6a 10		 push	 16			; 00000010H
  00027	50		 push	 eax
  00028	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0002b	c7 45 ec c1 10
	b2 05		 mov	 DWORD PTR _pMsgResult$[ebp], 95555777 ; 05b210c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18178: 	DataSend(iIndex,(BYTE *)&pMsgResult,pMsgResult.h.size);

  00032	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18179: #endif
; 18180: }

  00037	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	33 cd		 xor	 ecx, ebp
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?GCAnsNpcBuy@@YAXHHHH@Z ENDP				; GCAnsNpcBuy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z
_TEXT	SEGMENT
tv174 = -4						; size = 4
_lpMsg$ = 8						; size = 4
_btResult$ = 11						; size = 1
_iIndex$ = 12						; size = 4
?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z PROC		; CGReqNpcBuy, COMDAT

; 18122: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 18123: #if (GS_CASTLE==1)
; 18124: 	if(lpMsg == NULL)

  00005	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00008	85 f6		 test	 esi, esi
  0000a	0f 84 5f 01 00
	00		 je	 $LN8@CGReqNpcBu

; 18125: 		return;
; 18126: 
; 18127: 	if(gObjIsConnected(iIndex) == FALSE)

  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _iIndex$[ebp]
  00014	53		 push	 ebx
  00015	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 49 01 00
	00		 je	 $LN14@CGReqNpcBu

; 18128: 		return;
; 18129: 	
; 18130: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002f	57		 push	 edi
  00030	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  00036	05 1c 06 00 00	 add	 eax, 1564		; 0000061cH
  0003b	03 c7		 add	 eax, edi
  0003d	89 45 fc	 mov	 DWORD PTR tv174[ebp], eax
$LL10@CGReqNpcBu:
  00040	8a 10		 mov	 dl, BYTE PTR [eax]
  00042	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00044	75 1a		 jne	 SHORT $LN11@CGReqNpcBu
  00046	84 d2		 test	 dl, dl
  00048	74 12		 je	 SHORT $LN12@CGReqNpcBu
  0004a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0004d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00050	75 0e		 jne	 SHORT $LN11@CGReqNpcBu
  00052	83 c0 02	 add	 eax, 2
  00055	83 c1 02	 add	 ecx, 2
  00058	84 d2		 test	 dl, dl
  0005a	75 e4		 jne	 SHORT $LL10@CGReqNpcBu
$LN12@CGReqNpcBu:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 05		 jmp	 SHORT $LN13@CGReqNpcBu
$LN11@CGReqNpcBu:
  00060	1b c0		 sbb	 eax, eax
  00062	83 c8 01	 or	 eax, 1
$LN13@CGReqNpcBu:
  00065	85 c0		 test	 eax, eax
  00067	0f 84 00 01 00
	00		 je	 $LN15@CGReqNpcBu

; 18131: 		return;
; 18132: 
; 18133: 	if(g_CastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE
; 18134: 		|| (gObj[iIndex].GuildStatus != G_MASTER && gObj[iIndex].GuildStatus != G_SUB_MASTER))

  0006d	ff 75 fc	 push	 DWORD PTR tv174[ebp]
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00075	e8 00 00 00 00	 call	 ?CheckGuildOwnCastle@CCastleSiege@@QAEHPAD@Z ; CCastleSiege::CheckGuildOwnCastle
  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00080	85 c0		 test	 eax, eax
  00082	0f 84 b3 00 00
	00		 je	 $LN6@CGReqNpcBu
  00088	8b 84 0f 28 06
	00 00		 mov	 eax, DWORD PTR [edi+ecx+1576]
  0008f	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00094	74 09		 je	 SHORT $LN5@CGReqNpcBu
  00096	83 f8 40	 cmp	 eax, 64			; 00000040H
  00099	0f 85 9c 00 00
	00		 jne	 $LN6@CGReqNpcBu
$LN5@CGReqNpcBu:

; 18137: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 18138: 		return;
; 18139: 	}
; 18140: 
; 18141: 	BYTE btResult = NULL;
; 18142: 
; 18143: 	int bRETVAL = g_CastleSiege.CheckAddDbNPC(iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,&btResult);

  0009f	8d 45 0b	 lea	 eax, DWORD PTR _btResult$[ebp]
  000a2	c6 45 0b 00	 mov	 BYTE PTR _btResult$[ebp], 0
  000a6	50		 push	 eax
  000a7	ff 76 08	 push	 DWORD PTR [esi+8]
  000aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000af	ff 76 04	 push	 DWORD PTR [esi+4]
  000b2	53		 push	 ebx
  000b3	e8 00 00 00 00	 call	 ?CheckAddDbNPC@CCastleSiege@@QAEHHHHPAE@Z ; CCastleSiege::CheckAddDbNPC

; 18144: 
; 18145: 	if(bRETVAL == FALSE)
; 18146: 	{
; 18147: 		GCAnsNpcBuy(iIndex,btResult,lpMsg->iNpcNumber,lpMsg->iNpcIndex);

  000b8	ff 76 08	 push	 DWORD PTR [esi+8]
  000bb	ff 76 04	 push	 DWORD PTR [esi+4]
  000be	85 c0		 test	 eax, eax
  000c0	75 45		 jne	 SHORT $LN7@CGReqNpcBu
  000c2	0f b6 45 0b	 movzx	 eax, BYTE PTR _btResult$[ebp]
  000c6	50		 push	 eax
  000c7	53		 push	 ebx
  000c8	e8 00 00 00 00	 call	 ?GCAnsNpcBuy@@YAXHHHH@Z	; GCAnsNpcBuy

; 18148: 		LogAddC(2,"[CastleSiege] CGReqNpcBuy() ERROR - CCastleSiege::CheckAddDbNPC() [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",

  000cd	ff 76 08	 push	 DWORD PTR [esi+8]
  000d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d6	ff 76 04	 push	 DWORD PTR [esi+4]
  000d9	03 cf		 add	 ecx, edi
  000db	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  000e1	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  000e7	50		 push	 eax
  000e8	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000eb	50		 push	 eax
  000ec	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000ef	50		 push	 eax
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0HB@FHABJKFG@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
  000f5	6a 02		 push	 2
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000fd	83 c4 30	 add	 esp, 48			; 00000030H
  00100	5f		 pop	 edi
  00101	5b		 pop	 ebx
  00102	5e		 pop	 esi

; 18154: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 18155: 	}
; 18156: #endif
; 18157: }

  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
$LN7@CGReqNpcBu:

; 18149: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 18150: 	}
; 18151: 	else
; 18152: 	{
; 18153: 		LogAddC(2,"[CastleSiege] CGReqNpcBuy() OK - [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",

  00107	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010d	03 cf		 add	 ecx, edi
  0010f	ff b1 28 06 00
	00		 push	 DWORD PTR [ecx+1576]
  00115	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  0011b	50		 push	 eax
  0011c	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0011f	50		 push	 eax
  00120	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00123	50		 push	 eax
  00124	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NJFDHFJL@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5OK?5?9@
  00129	6a 02		 push	 2
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00131	83 c4 20	 add	 esp, 32			; 00000020H
  00134	5f		 pop	 edi
  00135	5b		 pop	 ebx
  00136	5e		 pop	 esi

; 18154: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 18155: 	}
; 18156: #endif
; 18157: }

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
$LN6@CGReqNpcBu:

; 18135: 	{
; 18136: 		LogAddC(2,"[CastleSiege] CGReqNpcBuy() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",

  0013b	ff 76 08	 push	 DWORD PTR [esi+8]
  0013e	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  00144	ff 76 04	 push	 DWORD PTR [esi+4]
  00147	03 c7		 add	 eax, edi
  00149	ff b4 0f 28 06
	00 00		 push	 DWORD PTR [edi+ecx+1576]
  00150	50		 push	 eax
  00151	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00154	03 c7		 add	 eax, edi
  00156	50		 push	 eax
  00157	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0015a	03 c7		 add	 eax, edi
  0015c	50		 push	 eax
  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@FDJJPEIB@?$FLCastleSiege?$FN?5CGReqNpcBuy?$CI?$CJ?5ERRO@
  00162	6a 02		 push	 2
  00164	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0016a	83 c4 20	 add	 esp, 32			; 00000020H
$LN15@CGReqNpcBu:
  0016d	5f		 pop	 edi
$LN14@CGReqNpcBu:
  0016e	5b		 pop	 ebx
$LN8@CGReqNpcBu:
  0016f	5e		 pop	 esi

; 18154: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
; 18155: 	}
; 18156: #endif
; 18157: }

  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c3		 ret	 0
?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z ENDP		; CGReqNpcBuy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z
_TEXT	SEGMENT
_pMsgResult$ = -44					; size = 17
_pMsgResult$1 = -24					; size = 17
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpMsgResult$ = 16					; size = 4
?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z PROC ; GCAnsRegGuildMark, COMDAT

; 18055: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 10	 mov	 edi, DWORD PTR _lpMsgResult$[ebp]

; 18056: #if (GS_CASTLE==1)
; 18057: 	if(lpMsgResult == NULL)

  00018	85 ff		 test	 edi, edi
  0001a	0f 84 43 01 00
	00		 je	 $LN1@GCAnsRegGu

; 18058: 		return;
; 18059: 
; 18060: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  00020	85 f6		 test	 esi, esi
  00022	0f 88 3b 01 00
	00		 js	 $LN1@GCAnsRegGu
  00028	33 c0		 xor	 eax, eax
  0002a	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00030	0f 9e c0	 setle	 al
  00033	85 c0		 test	 eax, eax
  00035	0f 84 28 01 00
	00		 je	 $LN1@GCAnsRegGu

; 18061: 		return;
; 18062: 
; 18063: 	if(gObj[iIndex].pInventory[lpMsgResult->iItemPos].IsItem() == FALSE)

  0003b	69 4f 18 d4 00
	00 00		 imul	 ecx, DWORD PTR [edi+24], 212
  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00047	53		 push	 ebx
  00048	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  0004e	03 8c 03 c0 11
	00 00		 add	 ecx, DWORD PTR [ebx+eax+4544]
  00055	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005a	85 c0		 test	 eax, eax
  0005c	75 1a		 jne	 SHORT $LN4@GCAnsRegGu
$LN6@GCAnsRegGu:
  0005e	0f 57 c0	 xorps	 xmm0, xmm0

; 18069: 
; 18070: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  00061	8d 45 e8	 lea	 eax, DWORD PTR _pMsgResult$1[ebp]
  00064	0f 11 45 e9	 movups	 XMMWORD PTR _pMsgResult$1[ebp+1], xmm0
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00068	c7 45 e8 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$1[ebp], 78778817 ; 04b211c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18068: 		pMsgResult.btResult = 3;

  0006f	c6 45 ec 03	 mov	 BYTE PTR _pMsgResult$1[ebp+4], 3

; 18071: 		gObj[iIndex].UseEventServer = FALSE;
; 18072: 		return;

  00073	e9 ce 00 00 00	 jmp	 $LN20@GCAnsRegGu
$LN4@GCAnsRegGu:

; 18073: 	}
; 18074: 
; 18075: 	if((gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Type != ITEMGET(14,21)
; 18076: 		&& gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Level == 3)
; 18077: 		|| gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability <= 0.0f)

  00078	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007d	ba 15 1c 00 00	 mov	 edx, 7189		; 00001c15H
  00082	69 4f 18 d4 00
	00 00		 imul	 ecx, DWORD PTR [edi+24], 212
  00089	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00090	66 39 54 08 06	 cmp	 WORD PTR [eax+ecx+6], dx
  00095	74 08		 je	 SHORT $LN7@GCAnsRegGu
  00097	66 83 7c 08 08
	03		 cmp	 WORD PTR [eax+ecx+8], 3
  0009d	74 bf		 je	 SHORT $LN6@GCAnsRegGu
$LN7@GCAnsRegGu:
  0009f	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  000a5	0f 57 c9	 xorps	 xmm1, xmm1
  000a8	0f 2f c8	 comiss	 xmm1, xmm0
  000ab	73 b1		 jae	 SHORT $LN6@GCAnsRegGu

; 18078: 	{
; 18079: 		PMSG_ANS_REGGUILDMARK pMsgResult = {0};
; 18080: 
; 18081: 		pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x04,sizeof(pMsgResult));
; 18082: 		pMsgResult.btResult = 3;
; 18083: 
; 18084: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);
; 18085: 		gObj[iIndex].UseEventServer = FALSE;
; 18086: 		return;
; 18087: 	}
; 18088: 
; 18089: 	gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability -= 1.0f;

  000ad	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  000b5	f3 0f 11 44 08
	24		 movss	 DWORD PTR [eax+ecx+36], xmm0

; 18090: 
; 18091: 	if(gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability > 0.0f)

  000bb	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c3	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  000c9	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  000d0	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  000d6	0f 2f c1	 comiss	 xmm0, xmm1
  000d9	76 19		 jbe	 SHORT $LN8@GCAnsRegGu

; 18092: 	{
; 18093: 		GCItemDurSend(iIndex,lpMsgResult->iItemPos,(BYTE)gObj[iIndex].pInventory[lpMsgResult->iItemPos].m_Durability,0);

  000db	f3 0f 2c c0	 cvttss2si eax, xmm0
  000df	6a 00		 push	 0
  000e1	0f b6 c0	 movzx	 eax, al
  000e4	50		 push	 eax
  000e5	0f b6 c2	 movzx	 eax, dl
  000e8	50		 push	 eax
  000e9	56		 push	 esi
  000ea	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  000ef	83 c4 10	 add	 esp, 16			; 00000010H

; 18094: 	}
; 18095: 	else

  000f2	eb 17		 jmp	 SHORT $LN9@GCAnsRegGu
$LN8@GCAnsRegGu:

; 18096: 	{
; 18097: 		gObjInventoryDeleteItem(iIndex,lpMsgResult->iItemPos);

  000f4	52		 push	 edx
  000f5	56		 push	 esi
  000f6	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 18098: 		GCInventoryItemDeleteSend(iIndex,lpMsgResult->iItemPos,1);

  000fb	0f b6 47 18	 movzx	 eax, BYTE PTR [edi+24]
  000ff	6a 01		 push	 1
  00101	50		 push	 eax
  00102	56		 push	 esi
  00103	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00108	83 c4 14	 add	 esp, 20			; 00000014H
$LN9@GCAnsRegGu:

; 18099: 	}
; 18100: 
; 18101: 	PMSG_ANS_REGGUILDMARK pMsgResult;
; 18102: 
; 18103: 	pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x04,sizeof(pMsgResult));
; 18104: 	pMsgResult.btResult = iResult;

  0010b	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 18105: 
; 18106: 	pMsgResult.btGuildMark1 = DWORD((DWORD(lpMsgResult->iRegMarkCount) >> 16) &0xFFFF) >> 8;
; 18107: 	pMsgResult.btGuildMark2 = DWORD((DWORD(lpMsgResult->iRegMarkCount) >> 16) &0xFFFF) & 0xFF;

  0010e	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00111	88 45 d8	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00114	0f b6 47 1f	 movzx	 eax, BYTE PTR [edi+31]
  00118	88 45 e1	 mov	 BYTE PTR _pMsgResult$[ebp+13], al
  0011b	8b c1		 mov	 eax, ecx
  0011d	c1 e8 10	 shr	 eax, 16			; 00000010H
  00120	88 45 e2	 mov	 BYTE PTR _pMsgResult$[ebp+14], al

; 18109: 	pMsgResult.btGuildMark4 = DWORD((DWORD(lpMsgResult->iRegMarkCount) & 0xFFFF) &0xFFFF) & 0xFF;

  00123	0f b6 47 1c	 movzx	 eax, BYTE PTR [edi+28]
  00127	88 45 e4	 mov	 BYTE PTR _pMsgResult$[ebp+16], al

; 18110: 
; 18111: 	memcpy(pMsgResult.szGuildName,lpMsgResult->szGuildName,sizeof(pMsgResult.szGuildName));

  0012a	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0012d	89 45 d9	 mov	 DWORD PTR _pMsgResult$[ebp+5], eax
  00130	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00133	c1 e9 08	 shr	 ecx, 8
  00136	89 45 dd	 mov	 DWORD PTR _pMsgResult$[ebp+9], eax

; 18112: 	DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  00139	8d 45 d4	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  0013c	c7 45 d4 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$[ebp], 78778817 ; 04b211c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18108: 	pMsgResult.btGuildMark3 = DWORD((DWORD(lpMsgResult->iRegMarkCount) & 0xFFFF) &0xFFFF) >> 8;

  00143	88 4d e3	 mov	 BYTE PTR _pMsgResult$[ebp+15], cl
$LN20@GCAnsRegGu:

; 18112: 	DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  00146	6a 11		 push	 17			; 00000011H
  00148	50		 push	 eax
  00149	56		 push	 esi
  0014a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18113: 
; 18114: 	gObj[iIndex].UseEventServer = FALSE;

  0014f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00154	83 c4 0c	 add	 esp, 12			; 0000000cH
  00157	c7 84 03 e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [ebx+eax+5096], 0
  00162	5b		 pop	 ebx
$LN1@GCAnsRegGu:

; 18115: #endif
; 18116: }

  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	5f		 pop	 edi
  00167	33 cd		 xor	 ecx, ebp
  00169	5e		 pop	 esi
  0016a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
?GCAnsRegGuildMark@@YAXHHPAUCSP_ANS_GUILDREGMARK@@@Z ENDP ; GCAnsRegGuildMark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z
_TEXT	SEGMENT
tv222 = -32						; size = 4
_lpMsg$GSCopy$1$ = -28					; size = 4
_iItemPos$1$ = -28					; size = 4
_pMsgResult$1 = -24					; size = 17
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z PROC ; CGReqRegGuildMark, COMDAT

; 17982: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00013	89 45 e4	 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], eax
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _iIndex$[ebp]

; 17983: #if (GS_CASTLE==1)
; 17984: 	if(lpMsg == NULL)

  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 a9 01 00
	00		 je	 $LN1@CGReqRegGu

; 17985: 		return;
; 17986: 
; 17987: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  00022	85 ff		 test	 edi, edi
  00024	0f 88 a1 01 00
	00		 js	 $LN1@CGReqRegGu
  0002a	33 c0		 xor	 eax, eax
  0002c	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00032	0f 9e c0	 setle	 al
  00035	85 c0		 test	 eax, eax
  00037	0f 84 8e 01 00
	00		 je	 $LN1@CGReqRegGu

; 17988: 		return;
; 17989: 
; 17990: 	if(gObj[iIndex].UseEventServer == TRUE)

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00042	56		 push	 esi
  00043	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00049	83 bc 06 e8 13
	00 00 01	 cmp	 DWORD PTR [esi+eax+5096], 1
  00051	0f 84 73 01 00
	00		 je	 $LN29@CGReqRegGu

; 17991: 		return;
; 17992: 
; 17993: 	gObj[iIndex].UseEventServer = TRUE;
; 17994: 
; 17995: 	if(g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_REGMARK)

  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0005c	c7 84 06 e8 13
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+5096], 1
  00067	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  0006c	83 f8 03	 cmp	 eax, 3
  0006f	74 20		 je	 SHORT $LN5@CGReqRegGu

; 17996: 	{
; 17997: 		gObj[iIndex].UseEventServer = FALSE;

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00076	c7 84 06 e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+5096], 0
  00081	5e		 pop	 esi
  00082	5f		 pop	 edi

; 18048: #endif
; 18049: }

  00083	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00086	33 cd		 xor	 ecx, ebp
  00088	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
$LN5@CGReqRegGu:
  00091	53		 push	 ebx

; 17998: 		return;
; 17999: 	}
; 18000: 
; 18001: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00092	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00098	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0009d	8d 83 1c 06 00
	00		 lea	 eax, DWORD PTR [ebx+1564]
  000a3	03 c6		 add	 eax, esi
$LL25@CGReqRegGu:
  000a5	8a 10		 mov	 dl, BYTE PTR [eax]
  000a7	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000a9	75 1a		 jne	 SHORT $LN26@CGReqRegGu
  000ab	84 d2		 test	 dl, dl
  000ad	74 12		 je	 SHORT $LN27@CGReqRegGu
  000af	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000b2	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000b5	75 0e		 jne	 SHORT $LN26@CGReqRegGu
  000b7	83 c0 02	 add	 eax, 2
  000ba	83 c1 02	 add	 ecx, 2
  000bd	84 d2		 test	 dl, dl
  000bf	75 e4		 jne	 SHORT $LL25@CGReqRegGu
$LN27@CGReqRegGu:
  000c1	33 c0		 xor	 eax, eax
  000c3	eb 05		 jmp	 SHORT $LN28@CGReqRegGu
$LN26@CGReqRegGu:
  000c5	1b c0		 sbb	 eax, eax
  000c7	83 c8 01	 or	 eax, 1
$LN28@CGReqRegGu:
  000ca	85 c0		 test	 eax, eax
  000cc	75 18		 jne	 SHORT $LN6@CGReqRegGu

; 18002: 	{
; 18003: 		gObj[iIndex].UseEventServer = FALSE;

  000ce	89 84 1e e8 13
	00 00		 mov	 DWORD PTR [esi+ebx+5096], eax
  000d5	5b		 pop	 ebx
  000d6	5e		 pop	 esi
  000d7	5f		 pop	 edi

; 18048: #endif
; 18049: }

  000d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN6@CGReqRegGu:

; 18004: 		return;
; 18005: 	}
; 18006: 
; 18007: 	if(CHECK_INV_POS(lpMsg->btItemPos) == FALSE)

  000e6	8b 45 e4	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  000e9	8a 48 04	 mov	 cl, BYTE PTR [eax+4]
  000ec	b0 3f		 mov	 al, 63			; 0000003fH
  000ee	3a c1		 cmp	 al, cl
  000f0	1b c0		 sbb	 eax, eax
  000f2	83 c0 01	 add	 eax, 1
  000f5	0f 84 9d 00 00
	00		 je	 $LN10@CGReqRegGu

; 18008: 	{
; 18009: 		PMSG_ANS_REGGUILDMARK pMsgResult = {0};
; 18010: 
; 18011: 		pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x04,sizeof(pMsgResult));
; 18012: 		pMsgResult.btResult = 3;
; 18013: 
; 18014: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);
; 18015: 		gObj[iIndex].UseEventServer = FALSE;
; 18016: 		return;
; 18017: 	}
; 18018: 
; 18019: 	int iItemPos = lpMsg->btItemPos + 12;

  000fb	0f b6 c1	 movzx	 eax, cl

; 18020: 
; 18021: 	if(gObj[iIndex].pInventory[iItemPos].IsItem() == FALSE)

  000fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00104	83 c0 0c	 add	 eax, 12			; 0000000cH
  00107	69 d8 d4 00 00
	00		 imul	 ebx, eax, 212
  0010d	89 45 e4	 mov	 DWORD PTR _iItemPos$1$[ebp], eax
  00110	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  00117	03 cb		 add	 ecx, ebx
  00119	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0011e	85 c0		 test	 eax, eax
  00120	74 76		 je	 SHORT $LN10@CGReqRegGu

; 18022: 	{
; 18023: 		PMSG_ANS_REGGUILDMARK pMsgResult = {0};
; 18024: 
; 18025: 		pMsgResult.h.set((BYTE*)&pMsgResult,0xB2,0x04,sizeof(pMsgResult));
; 18026: 		pMsgResult.btResult = 3;
; 18027: 
; 18028: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);
; 18029: 		gObj[iIndex].UseEventServer = FALSE;
; 18030: 		return;
; 18031: 	}
; 18032: 
; 18033: 	if(gObj[iIndex].pInventory[iItemPos].m_Type != ITEMGET(14,21)
; 18034: 		|| gObj[iIndex].pInventory[iItemPos].m_Level != 3
; 18035: 		|| gObj[iIndex].pInventory[iItemPos].m_Durability <= 0.0f)

  00122	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00127	b9 15 1c 00 00	 mov	 ecx, 7189		; 00001c15H
  0012c	8b 84 06 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+eax+4544]
  00133	66 39 4c 18 06	 cmp	 WORD PTR [eax+ebx+6], cx
  00138	75 5e		 jne	 SHORT $LN10@CGReqRegGu
  0013a	66 83 7c 18 08
	03		 cmp	 WORD PTR [eax+ebx+8], 3
  00140	75 56		 jne	 SHORT $LN10@CGReqRegGu
  00142	0f 57 c0	 xorps	 xmm0, xmm0
  00145	0f 2f 44 18 24	 comiss	 xmm0, DWORD PTR [eax+ebx+36]
  0014a	73 4c		 jae	 SHORT $LN10@CGReqRegGu
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0014c	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00151	85 c0		 test	 eax, eax
  00153	74 22		 je	 SHORT $LN23@CGReqRegGu
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18047: 	GS_GDReqRegGuildMark(g_MapServerManager.GetMapSvrGroup(),iIndex,iItemPos);

  00155	ff 75 e4	 push	 DWORD PTR _iItemPos$1$[ebp]
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00158	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18047: 	GS_GDReqRegGuildMark(g_MapServerManager.GetMapSvrGroup(),iIndex,iItemPos);

  0015c	57		 push	 edi
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 ?GS_GDReqRegGuildMark@@YAXHHH@Z ; GS_GDReqRegGuildMark
  00163	83 c4 0c	 add	 esp, 12			; 0000000cH
  00166	5b		 pop	 ebx
  00167	5e		 pop	 esi
  00168	5f		 pop	 edi

; 18048: #endif
; 18049: }

  00169	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016c	33 cd		 xor	 ecx, ebp
  0016e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00173	8b e5		 mov	 esp, ebp
  00175	5d		 pop	 ebp
  00176	c3		 ret	 0
$LN23@CGReqRegGu:

; 18047: 	GS_GDReqRegGuildMark(g_MapServerManager.GetMapSvrGroup(),iIndex,iItemPos);

  00177	ff 75 e4	 push	 DWORD PTR _iItemPos$1$[ebp]
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 59   : 		return -1;

  0017a	83 c8 ff	 or	 eax, -1
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18047: 	GS_GDReqRegGuildMark(g_MapServerManager.GetMapSvrGroup(),iIndex,iItemPos);

  0017d	57		 push	 edi
  0017e	50		 push	 eax
  0017f	e8 00 00 00 00	 call	 ?GS_GDReqRegGuildMark@@YAXHHH@Z ; GS_GDReqRegGuildMark
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH
  00187	5b		 pop	 ebx
  00188	5e		 pop	 esi
  00189	5f		 pop	 edi

; 18048: #endif
; 18049: }

  0018a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018d	33 cd		 xor	 ecx, ebp
  0018f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c3		 ret	 0
$LN10@CGReqRegGu:

; 18041: 
; 18042: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  00198	6a 11		 push	 17			; 00000011H
  0019a	8d 45 e8	 lea	 eax, DWORD PTR _pMsgResult$1[ebp]
  0019d	0f 57 c0	 xorps	 xmm0, xmm0
  001a0	50		 push	 eax
  001a1	0f 11 45 e9	 movups	 XMMWORD PTR _pMsgResult$1[ebp+1], xmm0
  001a5	57		 push	 edi
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  001a6	c7 45 e8 c1 11
	b2 04		 mov	 DWORD PTR _pMsgResult$1[ebp], 78778817 ; 04b211c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 18040: 		pMsgResult.btResult = 3;

  001ad	c6 45 ec 03	 mov	 BYTE PTR _pMsgResult$1[ebp+4], 3

; 18041: 
; 18042: 		DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  001b1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 18043: 		gObj[iIndex].UseEventServer = FALSE;

  001b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001be	c7 84 06 e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+5096], 0
  001c9	5b		 pop	 ebx
$LN29@CGReqRegGu:
  001ca	5e		 pop	 esi
$LN1@CGReqRegGu:

; 18048: #endif
; 18049: }

  001cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ce	33 cd		 xor	 ecx, ebp
  001d0	5f		 pop	 edi
  001d1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d6	8b e5		 mov	 esp, ebp
  001d8	5d		 pop	 ebp
  001d9	c3		 ret	 0
?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z ENDP ; CGReqRegGuildMark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z
_TEXT	SEGMENT
_pMsgResult$ = -24					; size = 19
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpMsgResult$ = 16					; size = 4
?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z PROC ; GCAnsGuildRegInfo, COMDAT

; 17943: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 10	 mov	 edx, DWORD PTR _lpMsgResult$[ebp]

; 17944: #if (GS_CASTLE==1)
; 17945: 	if(lpMsgResult == NULL)

  00013	85 d2		 test	 edx, edx
  00015	74 6d		 je	 SHORT $LN1@GCAnsGuild

; 17946: 		return;
; 17947: 
; 17948: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0001b	85 f6		 test	 esi, esi
  0001d	78 64		 js	 SHORT $LN9@GCAnsGuild
  0001f	33 c0		 xor	 eax, eax
  00021	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	74 55		 je	 SHORT $LN9@GCAnsGuild

; 17949: 		return;
; 17950: 
; 17951: 	PMSG_ANS_GUILDREGINFO pMsgResult;
; 17952: 
; 17953: 	pMsgResult.h.set((BYTE *)&pMsgResult,0xB2,3,sizeof(pMsgResult));
; 17954: 	pMsgResult.btResult = iResult;

  0002e	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 17955: 	pMsgResult.btGuildMark1 = DWORD((DWORD(lpMsgResult->iRegMarkCount) >> 16) &0xFFFF) >> 8;
; 17956: 	pMsgResult.btGuildMark2 = DWORD((DWORD(lpMsgResult->iRegMarkCount) >> 16) &0xFFFF) & 0xFF;

  00031	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00034	88 45 ec	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00037	0f b6 42 1b	 movzx	 eax, BYTE PTR [edx+27]
  0003b	88 45 f5	 mov	 BYTE PTR _pMsgResult$[ebp+13], al
  0003e	8b c1		 mov	 eax, ecx
  00040	c1 e8 10	 shr	 eax, 16			; 00000010H
  00043	88 45 f6	 mov	 BYTE PTR _pMsgResult$[ebp+14], al

; 17958: 	pMsgResult.btGuildMark4 = DWORD((DWORD(lpMsgResult->iRegMarkCount) & 0xFFFF) &0xFFFF) & 0xFF;

  00046	0f b6 42 18	 movzx	 eax, BYTE PTR [edx+24]
  0004a	88 45 f8	 mov	 BYTE PTR _pMsgResult$[ebp+16], al

; 17959: 
; 17960: 	pMsgResult.btRegRank = lpMsgResult->btRegRank;

  0004d	0f b6 42 1d	 movzx	 eax, BYTE PTR [edx+29]
  00051	88 45 fa	 mov	 BYTE PTR _pMsgResult$[ebp+18], al

; 17961: 	pMsgResult.btIsGiveUp = lpMsgResult->bIsGiveUp;

  00054	0f b6 42 1c	 movzx	 eax, BYTE PTR [edx+28]
  00058	88 45 f9	 mov	 BYTE PTR _pMsgResult$[ebp+17], al

; 17962: 	memcpy(pMsgResult.szGuildName,lpMsgResult->szGuildName,sizeof(pMsgResult.szGuildName));

  0005b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0005e	89 45 ed	 mov	 DWORD PTR _pMsgResult$[ebp+5], eax
  00061	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00064	89 45 f1	 mov	 DWORD PTR _pMsgResult$[ebp+9], eax

; 17963: 
; 17964: 	DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  00067	8d 45 e8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0006a	6a 13		 push	 19			; 00000013H
  0006c	50		 push	 eax
  0006d	c1 e9 08	 shr	 ecx, 8
  00070	56		 push	 esi
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00071	c7 45 e8 c1 13
	b2 03		 mov	 DWORD PTR _pMsgResult$[ebp], 62002113 ; 03b213c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17957: 	pMsgResult.btGuildMark3 = DWORD((DWORD(lpMsgResult->iRegMarkCount) & 0xFFFF) &0xFFFF) >> 8;

  00078	88 4d f7	 mov	 BYTE PTR _pMsgResult$[ebp+15], cl

; 17963: 
; 17964: 	DataSend(iIndex,(BYTE*)&pMsgResult,pMsgResult.h.size);

  0007b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@GCAnsGuild:
  00083	5e		 pop	 esi
$LN1@GCAnsGuild:

; 17965: #endif
; 17966: }

  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	33 cd		 xor	 ecx, ebp
  00089	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?GCAnsGuildRegInfo@@YAXHHPAUCSP_ANS_GUILDREGINFO@@@Z ENDP ; GCAnsGuildRegInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z PROC ; CGReqGuildRegInfo, COMDAT

; 17917: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17918: #if (GS_CASTLE==1)
; 17919: 	if(lpMsg == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _lpMsg$[ebp], 0
  00007	74 6c		 je	 SHORT $LN1@CGReqGuild

; 17920: 		return;
; 17921: 
; 17922: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00017	05 1c 06 00 00	 add	 eax, 1564		; 0000061cH
  0001c	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00022	03 c1		 add	 eax, ecx
$LL8@CGReqGuild:
  00024	8a 08		 mov	 cl, BYTE PTR [eax]
  00026	3a 0a		 cmp	 cl, BYTE PTR [edx]
  00028	75 1a		 jne	 SHORT $LN9@CGReqGuild
  0002a	84 c9		 test	 cl, cl
  0002c	74 12		 je	 SHORT $LN10@CGReqGuild
  0002e	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00031	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  00034	75 0e		 jne	 SHORT $LN9@CGReqGuild
  00036	83 c0 02	 add	 eax, 2
  00039	83 c2 02	 add	 edx, 2
  0003c	84 c9		 test	 cl, cl
  0003e	75 e4		 jne	 SHORT $LL8@CGReqGuild
$LN10@CGReqGuild:
  00040	33 c0		 xor	 eax, eax
  00042	eb 05		 jmp	 SHORT $LN11@CGReqGuild
$LN9@CGReqGuild:
  00044	1b c0		 sbb	 eax, eax
  00046	83 c8 01	 or	 eax, 1
$LN11@CGReqGuild:
  00049	85 c0		 test	 eax, eax
  0004b	74 27		 je	 SHORT $LN12@CGReqGuild
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  0004d	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00052	85 c0		 test	 eax, eax
  00054	74 11		 je	 SHORT $LN6@CGReqGuild

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00056	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17925: 	GS_GDReqGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

  0005a	56		 push	 esi
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?GS_GDReqGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqGuildMarkRegInfo
  00061	83 c4 08	 add	 esp, 8
  00064	5e		 pop	 esi

; 17926: #endif
; 17927: }

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
$LN6@CGReqGuild:
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 59   : 		return -1;

  00067	83 c8 ff	 or	 eax, -1
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17925: 	GS_GDReqGuildMarkRegInfo(g_MapServerManager.GetMapSvrGroup(),iIndex);

  0006a	56		 push	 esi
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?GS_GDReqGuildMarkRegInfo@@YAXHH@Z ; GS_GDReqGuildMarkRegInfo
  00071	83 c4 08	 add	 esp, 8
$LN12@CGReqGuild:
  00074	5e		 pop	 esi
$LN1@CGReqGuild:

; 17926: #endif
; 17927: }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z ENDP ; CGReqGuildRegInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z PROC ; CGReqGiveUpCastleSiege, COMDAT

; 17850: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17851: #if (GS_CASTLE==1)
; 17852: 
; 17853: 	if(g_CastleSiege.GetCastleState() < CASTLESIEGE_STATE_REGSIEGE || g_CastleSiege.GetCastleState() > CASTLESIEGE_STATE_REGMARK)

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00008	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  0000d	83 f8 01	 cmp	 eax, 1
  00010	0f 8c 89 00 00
	00		 jl	 $LN3@CGReqGiveU
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0001b	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00020	83 f8 03	 cmp	 eax, 3
  00023	7f 7a		 jg	 SHORT $LN3@CGReqGiveU

; 17856: 		return;
; 17857: 	}
; 17858: 
; 17859: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002f	56		 push	 esi
  00030	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00033	05 1c 06 00 00	 add	 eax, 1564		; 0000061cH
  00038	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0003e	03 c1		 add	 eax, ecx
$LL10@CGReqGiveU:
  00040	8a 08		 mov	 cl, BYTE PTR [eax]
  00042	3a 0a		 cmp	 cl, BYTE PTR [edx]
  00044	75 1a		 jne	 SHORT $LN11@CGReqGiveU
  00046	84 c9		 test	 cl, cl
  00048	74 12		 je	 SHORT $LN12@CGReqGiveU
  0004a	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0004d	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  00050	75 0e		 jne	 SHORT $LN11@CGReqGiveU
  00052	83 c0 02	 add	 eax, 2
  00055	83 c2 02	 add	 edx, 2
  00058	84 c9		 test	 cl, cl
  0005a	75 e4		 jne	 SHORT $LL10@CGReqGiveU
$LN12@CGReqGiveU:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 05		 jmp	 SHORT $LN13@CGReqGiveU
$LN11@CGReqGiveU:
  00060	1b c0		 sbb	 eax, eax
  00062	83 c8 01	 or	 eax, 1
$LN13@CGReqGiveU:
  00065	85 c0		 test	 eax, eax
  00067	74 33		 je	 SHORT $LN14@CGReqGiveU

; 17860: 		return;
; 17861: 
; 17862: 	if(g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE)

  00069	56		 push	 esi
  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0006f	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00074	85 c0		 test	 eax, eax
  00076	74 24		 je	 SHORT $LN14@CGReqGiveU
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  00078	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  0007d	85 c0		 test	 eax, eax
  0007f	74 06		 je	 SHORT $LN8@CGReqGiveU

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  00081	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00085	eb 03		 jmp	 SHORT $LN7@CGReqGiveU
$LN8@CGReqGiveU:

; 58   : 		}
; 59   : 		return -1;

  00087	83 c9 ff	 or	 ecx, -1
$LN7@CGReqGiveU:
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17865: 	GS_GDReqGuildSetGiveUp(g_MapServerManager.GetMapSvrGroup(),iIndex,lpMsg->btGiveUp);

  0008a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0008d	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00091	50		 push	 eax
  00092	56		 push	 esi
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 ?GS_GDReqGuildSetGiveUp@@YAXHHH@Z ; GS_GDReqGuildSetGiveUp
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@CGReqGiveU:
  0009c	5e		 pop	 esi

; 17866: #endif
; 17867: }

  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN3@CGReqGiveU:

; 17854: 	{
; 17855: 		GCAnsGiveUpCastleSiege(iIndex,3,0,0,"");

  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000a4	6a 00		 push	 0
  000a6	6a 00		 push	 0
  000a8	6a 03		 push	 3
  000aa	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  000ad	e8 00 00 00 00	 call	 ?GCAnsGiveUpCastleSiege@@YAXHH_NHPAD@Z ; GCAnsGiveUpCastleSiege
  000b2	83 c4 14	 add	 esp, 20			; 00000014H

; 17866: #endif
; 17867: }

  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z ENDP ; CGReqGiveUpCastleSiege
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsRegCastleSiege@@YAXHHPAD@Z
_TEXT	SEGMENT
_pMsgResult$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpszGuildName$ = 16					; size = 4
?GCAnsRegCastleSiege@@YAXHHPAD@Z PROC			; GCAnsRegCastleSiege, COMDAT

; 17823: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _lpszGuildName$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 17824: #if (GS_CASTLE==1)
; 17825: 	if(lpszGuildName == NULL)

  00017	85 c9		 test	 ecx, ecx
  00019	74 70		 je	 SHORT $LN4@GCAnsRegCa

; 17826: 		return;
; 17827: 
; 17828: 	if(OBJMAX_RANGE(iIndex) == FALSE)

  0001b	85 f6		 test	 esi, esi
  0001d	78 6c		 js	 SHORT $LN4@GCAnsRegCa
  0001f	33 c0		 xor	 eax, eax
  00021	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00027	0f 9e c0	 setle	 al
  0002a	85 c0		 test	 eax, eax
  0002c	74 5d		 je	 SHORT $LN4@GCAnsRegCa

; 17835: 
; 17836: 	memcpy(pMsgResult.szGuildName,lpszGuildName,sizeof(pMsgResult.szGuildName));

  0002e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00030	53		 push	 ebx
  00031	8b 5d 0c	 mov	 ebx, DWORD PTR _iResult$[ebp]
  00034	89 45 f1	 mov	 DWORD PTR _pMsgResult$[ebp+5], eax
  00037	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003a	89 45 f5	 mov	 DWORD PTR _pMsgResult$[ebp+9], eax

; 17837: 
; 17838: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0003d	8d 45 ec	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00040	6a 0d		 push	 13			; 0000000dH
  00042	50		 push	 eax
  00043	56		 push	 esi
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00044	c7 45 ec c1 0d
	b2 01		 mov	 DWORD PTR _pMsgResult$[ebp], 28446145 ; 01b20dc1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17834: 	pMsgResult.btResult = iResult;

  0004b	88 5d f0	 mov	 BYTE PTR _pMsgResult$[ebp+4], bl

; 17837: 
; 17838: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0004e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 17839: 
; 17840: 	if(gObjIsConnected(iIndex))

  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	85 c0		 test	 eax, eax
  0005e	74 2a		 je	 SHORT $LN10@GCAnsRegCa

; 17841: 	{
; 17842: 		LogAddTD("[CastleSiege] [%s][%s] Registered Castle Siege (GUILD:%s) - Result:%d",

  00060	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00066	53		 push	 ebx
  00067	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006d	8d 81 1c 06 00
	00		 lea	 eax, DWORD PTR [ecx+1564]
  00073	50		 push	 eax
  00074	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00077	50		 push	 eax
  00078	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@CHMKLDIE@?$FLCastleSiege?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registere@
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00087	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@GCAnsRegCa:
  0008a	5b		 pop	 ebx
$LN4@GCAnsRegCa:

; 17843: 			gObj[iIndex].AccountID,gObj[iIndex].Name,gObj[iIndex].GuildName,iResult);
; 17844: 	}
; 17845: #endif
; 17846: }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	5e		 pop	 esi
  00091	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?GCAnsRegCastleSiege@@YAXHHPAD@Z ENDP			; GCAnsRegCastleSiege
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z PROC ; CGReqRegCastleSiege, COMDAT

; 17784: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 17785: #if (GS_CASTLE==1)
; 17786: 
; 17787: 	if(g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_REGSIEGE)

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00008	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  0000d	83 f8 01	 cmp	 eax, 1
  00010	74 14		 je	 SHORT $LN2@CGReqRegCa

; 17788: 	{
; 17789: 		GCAnsRegCastleSiege(iIndex,7,"");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00017	6a 07		 push	 7
  00019	ff 75 0c	 push	 DWORD PTR _iIndex$[ebp]
  0001c	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17812: #endif
; 17813: }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN2@CGReqRegCa:

; 17790: 		return;
; 17791: 	}
; 17792: 
; 17793: 	if(strcmp(gObj[iIndex].GuildName,"") == NULL)

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
  00030	56		 push	 esi
  00031	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  00034	05 1c 06 00 00	 add	 eax, 1564		; 0000061cH
  00039	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0003f	03 c1		 add	 eax, ecx
$LL11@CGReqRegCa:
  00041	8a 08		 mov	 cl, BYTE PTR [eax]
  00043	3a 0a		 cmp	 cl, BYTE PTR [edx]
  00045	75 1a		 jne	 SHORT $LN12@CGReqRegCa
  00047	84 c9		 test	 cl, cl
  00049	74 12		 je	 SHORT $LN13@CGReqRegCa
  0004b	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0004e	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  00051	75 0e		 jne	 SHORT $LN12@CGReqRegCa
  00053	83 c0 02	 add	 eax, 2
  00056	83 c2 02	 add	 edx, 2
  00059	84 c9		 test	 cl, cl
  0005b	75 e4		 jne	 SHORT $LL11@CGReqRegCa
$LN13@CGReqRegCa:
  0005d	33 c0		 xor	 eax, eax
  0005f	eb 05		 jmp	 SHORT $LN14@CGReqRegCa
$LN12@CGReqRegCa:
  00061	1b c0		 sbb	 eax, eax
  00063	83 c8 01	 or	 eax, 1
$LN14@CGReqRegCa:
  00066	85 c0		 test	 eax, eax
  00068	75 13		 jne	 SHORT $LN3@CGReqRegCa

; 17794: 	{
; 17795: 		GCAnsRegCastleSiege(iIndex,6,"");

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0006f	6a 06		 push	 6

; 17806: 	{
; 17807: 		GCAnsRegCastleSiege(iIndex,3,"");

  00071	56		 push	 esi
  00072	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	5e		 pop	 esi

; 17812: #endif
; 17813: }

  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN3@CGReqRegCa:

; 17796: 		return;
; 17797: 	}
; 17798: 
; 17799: 	if(g_CastleSiege.CheckUnionGuildMaster(iIndex) == FALSE)

  0007d	56		 push	 esi
  0007e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00083	e8 00 00 00 00	 call	 ?CheckUnionGuildMaster@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckUnionGuildMaster
  00088	85 c0		 test	 eax, eax
  0008a	75 12		 jne	 SHORT $LN4@CGReqRegCa

; 17800: 	{
; 17801: 		GCAnsRegCastleSiege(iIndex,0,"");

  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  00091	50		 push	 eax

; 17806: 	{
; 17807: 		GCAnsRegCastleSiege(iIndex,3,"");

  00092	56		 push	 esi
  00093	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	5e		 pop	 esi

; 17812: #endif
; 17813: }

  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
$LN4@CGReqRegCa:

; 17802: 		return;
; 17803: 	}
; 17804: 
; 17805: 	if(g_CastleSiege.CheckCastleOwnerMember(iIndex) != FALSE || g_CastleSiege.CheckCastleOwnerUnionMember(iIndex) != FALSE)

  0009e	56		 push	 esi
  0009f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000a4	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  000a9	85 c0		 test	 eax, eax
  000ab	75 39		 jne	 SHORT $LN6@CGReqRegCa
  000ad	56		 push	 esi
  000ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b3	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  000b8	85 c0		 test	 eax, eax
  000ba	75 2a		 jne	 SHORT $LN6@CGReqRegCa
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  000bc	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  000c1	85 c0		 test	 eax, eax
  000c3	74 11		 je	 SHORT $LN9@CGReqRegCa

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  000c5	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17811: 	GS_GDReqRegAttackGuild(g_MapServerManager.GetMapSvrGroup(),iIndex);

  000c9	56		 push	 esi
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?GS_GDReqRegAttackGuild@@YAXHH@Z ; GS_GDReqRegAttackGuild
  000d0	83 c4 08	 add	 esp, 8
  000d3	5e		 pop	 esi

; 17812: #endif
; 17813: }

  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
$LN9@CGReqRegCa:
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 59   : 		return -1;

  000d6	83 c8 ff	 or	 eax, -1
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17811: 	GS_GDReqRegAttackGuild(g_MapServerManager.GetMapSvrGroup(),iIndex);

  000d9	56		 push	 esi
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?GS_GDReqRegAttackGuild@@YAXHH@Z ; GS_GDReqRegAttackGuild
  000e0	83 c4 08	 add	 esp, 8
  000e3	5e		 pop	 esi

; 17812: #endif
; 17813: }

  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
$LN6@CGReqRegCa:

; 17806: 	{
; 17807: 		GCAnsRegCastleSiege(iIndex,3,"");

  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  000eb	6a 03		 push	 3
  000ed	56		 push	 esi
  000ee	e8 00 00 00 00	 call	 ?GCAnsRegCastleSiege@@YAXHHPAD@Z ; GCAnsRegCastleSiege
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f6	5e		 pop	 esi

; 17812: #endif
; 17813: }

  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z ENDP ; CGReqRegCastleSiege
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsCastleSiegeState@@YAXHHPAD0@Z
_TEXT	SEGMENT
_tmSiegeStartDate$6$ = -100				; size = 16
$T1 = -100						; size = 16
_tmStateEndDate$ = -84					; size = 16
_tmStateStartDate$ = -68				; size = 16
_pMsgResult$ = -52					; size = 46
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
_lpszGuildName$ = 16					; size = 4
_lpszGuildMaster$ = 20					; size = 4
?GCAnsCastleSiegeState@@YAXHHPAD0@Z PROC		; GCAnsCastleSiegeState, COMDAT

; 17720: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 10	 mov	 edx, DWORD PTR _lpszGuildName$[ebp]
  00013	8b 4d 14	 mov	 ecx, DWORD PTR _lpszGuildMaster$[ebp]

; 17721: #if (GS_CASTLE==1)
; 17722: 
; 17723: 	if(lpszGuildName == NULL || lpszGuildMaster == NULL)

  00016	85 d2		 test	 edx, edx
  00018	0f 84 52 01 00
	00		 je	 $LN3@GCAnsCastl
  0001e	85 c9		 test	 ecx, ecx
  00020	0f 84 4a 01 00
	00		 je	 $LN3@GCAnsCastl

; 17724: 		return;
; 17725: 
; 17726: 	PMSG_ANS_CASTLESIEGESTATE pMsgResult;
; 17727: 
; 17728: 	pMsgResult.h.set((PBYTE)&pMsgResult,0xB2,0x00,sizeof(pMsgResult));
; 17729: 	pMsgResult.btResult = iResult;

  00026	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]

; 17730: 
; 17731: 	memcpy(pMsgResult.cOwnerGuild,lpszGuildName,sizeof(pMsgResult.cOwnerGuild));
; 17732: 	memcpy(pMsgResult.cOwnerGuildMaster,lpszGuildMaster,sizeof(pMsgResult.cOwnerGuildMaster));

  00029	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  0002d	88 45 d0	 mov	 BYTE PTR _pMsgResult$[ebp+4], al
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	89 45 e4	 mov	 DWORD PTR _pMsgResult$[ebp+24], eax
  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00038	89 45 e8	 mov	 DWORD PTR _pMsgResult$[ebp+28], eax
  0003b	66 8b 41 08	 mov	 ax, WORD PTR [ecx+8]

; 17736: 	_SYSTEMTIME tmSiegeStartDate = {0};
; 17737: 
; 17738: 	int iCastleState = g_CastleSiege.GetCastleState();

  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00044	53		 push	 ebx
  00045	66 0f d6 45 ec	 movq	 QWORD PTR _pMsgResult$[ebp+32], xmm0
  0004a	0f 57 c0	 xorps	 xmm0, xmm0
  0004d	66 89 45 f4	 mov	 WORD PTR _pMsgResult$[ebp+40], ax
  00051	33 c0		 xor	 eax, eax
  00053	56		 push	 esi
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 140  : 		lpBuf[0] = 0xC1;

  00054	c7 45 cc c1 2e
	b2 00		 mov	 DWORD PTR _pMsgResult$[ebp], 11677377 ; 00b22ec1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17734: 	_SYSTEMTIME tmStateStartDate = {0};

  0005b	66 89 45 bc	 mov	 WORD PTR _tmStateStartDate$[ebp], ax
  0005f	66 0f d6 45 be	 movq	 QWORD PTR _tmStateStartDate$[ebp+2], xmm0
  00064	89 45 c6	 mov	 DWORD PTR _tmStateStartDate$[ebp+10], eax
  00067	66 89 45 ca	 mov	 WORD PTR _tmStateStartDate$[ebp+14], ax

; 17735: 	_SYSTEMTIME tmStateEndDate = {0};

  0006b	66 89 45 ac	 mov	 WORD PTR _tmStateEndDate$[ebp], ax
  0006f	66 0f d6 45 ae	 movq	 QWORD PTR _tmStateEndDate$[ebp+2], xmm0
  00074	89 45 b6	 mov	 DWORD PTR _tmStateEndDate$[ebp+10], eax
  00077	66 89 45 ba	 mov	 WORD PTR _tmStateEndDate$[ebp+14], ax

; 17736: 	_SYSTEMTIME tmSiegeStartDate = {0};
; 17737: 
; 17738: 	int iCastleState = g_CastleSiege.GetCastleState();

  0007b	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  00080	8b d8		 mov	 ebx, eax

; 17739: 
; 17740: 	int bRETVAL = g_CastleSiege.GetCastleStateTerm(&tmStateStartDate,&tmStateEndDate);

  00082	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  00087	8d 45 ac	 lea	 eax, DWORD PTR _tmStateEndDate$[ebp]
  0008a	50		 push	 eax
  0008b	8d 45 bc	 lea	 eax, DWORD PTR _tmStateStartDate$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?GetCastleStateTerm@CCastleSiege@@QAEHPAU_SYSTEMTIME@@0@Z ; CCastleSiege::GetCastleStateTerm
  00094	8b f0		 mov	 esi, eax

; 17741: 
; 17742: 	tmSiegeStartDate = g_CastleSiege.GetCastleLeftSiegeDate();

  00096	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0009b	8d 45 9c	 lea	 eax, DWORD PTR $T1[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ?GetCastleLeftSiegeDate@CCastleSiege@@QAE?AU_SYSTEMTIME@@XZ ; CCastleSiege::GetCastleLeftSiegeDate

; 17743: 
; 17744: 	if(bRETVAL == 0)
; 17745: 		iCastleState = -1;
; 17746: 
; 17747: 	int iRemainTime = g_CastleSiege.GetCurRemainSec();

  000a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000a9	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000ac	83 c8 ff	 or	 eax, -1
  000af	85 f6		 test	 esi, esi
  000b1	0f 11 45 9c	 movups	 XMMWORD PTR _tmSiegeStartDate$6$[ebp], xmm0
  000b5	0f 44 d8	 cmove	 ebx, eax
  000b8	e8 00 00 00 00	 call	 ?GetCurRemainSec@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCurRemainSec

; 17748: 	pMsgResult.cCastleSiegeState = iCastleState;
; 17749: 
; 17750: 	pMsgResult.btStartYearH = SET_NUMBERH(tmStateStartDate.wYear);

  000bd	8b 4d bc	 mov	 ecx, DWORD PTR _tmStateStartDate$[ebp]
  000c0	8b d0		 mov	 edx, eax

; 17751: 	pMsgResult.btStartYearL = SET_NUMBERL(tmStateStartDate.wYear);
; 17752: 	pMsgResult.btStartMonth = (BYTE)tmStateStartDate.wMonth;
; 17753: 	pMsgResult.btStartDay = (BYTE)tmStateStartDate.wDay;
; 17754: 	pMsgResult.btStartHour = (BYTE)tmStateStartDate.wHour;

  000c2	0f b6 45 c4	 movzx	 eax, BYTE PTR _tmStateStartDate$[ebp+8]

; 17755: 	pMsgResult.btStartMinute = (BYTE)tmStateStartDate.wMinute;
; 17756: 
; 17757: 	pMsgResult.btEndYearH = SET_NUMBERH(tmStateEndDate.wYear);
; 17758: 	pMsgResult.btEndYearL = SET_NUMBERL(tmStateEndDate.wYear);
; 17759: 	pMsgResult.btEndMonth = (BYTE)tmStateEndDate.wMonth;
; 17760: 	pMsgResult.btEndDay = (BYTE)tmStateEndDate.wDay;
; 17761: 	pMsgResult.btEndHour = (BYTE)tmStateEndDate.wHour;
; 17762: 	pMsgResult.btEndMinute = (BYTE)tmStateEndDate.wMinute;
; 17763: 
; 17764: 	pMsgResult.btSiegeStartYearH = SET_NUMBERH(tmSiegeStartDate.wYear);

  000c6	0f 10 45 9c	 movups	 xmm0, XMMWORD PTR _tmSiegeStartDate$6$[ebp]
  000ca	88 45 d6	 mov	 BYTE PTR _pMsgResult$[ebp+10], al
  000cd	0f b6 45 c6	 movzx	 eax, BYTE PTR _tmStateStartDate$[ebp+10]
  000d1	88 45 d7	 mov	 BYTE PTR _pMsgResult$[ebp+11], al
  000d4	8b 45 ac	 mov	 eax, DWORD PTR _tmStateEndDate$[ebp]
  000d7	c1 e8 08	 shr	 eax, 8
  000da	88 45 d8	 mov	 BYTE PTR _pMsgResult$[ebp+12], al
  000dd	0f b6 45 ac	 movzx	 eax, BYTE PTR _tmStateEndDate$[ebp]
  000e1	c1 e9 08	 shr	 ecx, 8
  000e4	88 45 d9	 mov	 BYTE PTR _pMsgResult$[ebp+13], al
  000e7	0f b6 45 ae	 movzx	 eax, BYTE PTR _tmStateEndDate$[ebp+2]
  000eb	88 4d d2	 mov	 BYTE PTR _pMsgResult$[ebp+6], cl
  000ee	0f b6 4d bc	 movzx	 ecx, BYTE PTR _tmStateStartDate$[ebp]
  000f2	88 45 da	 mov	 BYTE PTR _pMsgResult$[ebp+14], al
  000f5	0f b6 45 b2	 movzx	 eax, BYTE PTR _tmStateEndDate$[ebp+6]
  000f9	88 4d d3	 mov	 BYTE PTR _pMsgResult$[ebp+7], cl
  000fc	0f b6 4d be	 movzx	 ecx, BYTE PTR _tmStateStartDate$[ebp+2]
  00100	88 45 db	 mov	 BYTE PTR _pMsgResult$[ebp+15], al
  00103	0f b6 45 b4	 movzx	 eax, BYTE PTR _tmStateEndDate$[ebp+8]
  00107	88 4d d4	 mov	 BYTE PTR _pMsgResult$[ebp+8], cl
  0010a	0f b6 4d c2	 movzx	 ecx, BYTE PTR _tmStateStartDate$[ebp+6]
  0010e	88 45 dc	 mov	 BYTE PTR _pMsgResult$[ebp+16], al
  00111	0f b6 45 b6	 movzx	 eax, BYTE PTR _tmStateEndDate$[ebp+10]
  00115	88 4d d5	 mov	 BYTE PTR _pMsgResult$[ebp+9], cl
  00118	66 0f 7e c1	 movd	 ecx, xmm0
  0011c	88 45 dd	 mov	 BYTE PTR _pMsgResult$[ebp+17], al
  0011f	88 5d d1	 mov	 BYTE PTR _pMsgResult$[ebp+5], bl
  00122	8b c1		 mov	 eax, ecx

; 17765: 	pMsgResult.btSiegeStartYearL = SET_NUMBERL(tmSiegeStartDate.wYear);

  00124	88 4d df	 mov	 BYTE PTR _pMsgResult$[ebp+19], cl
  00127	c1 e8 08	 shr	 eax, 8
  0012a	88 45 de	 mov	 BYTE PTR _pMsgResult$[ebp+18], al

; 17766: 	pMsgResult.btSiegeStartMonth = (BYTE)tmSiegeStartDate.wMonth;

  0012d	66 0f c5 c0 01	 pextrw	 ax, xmm0, 1
  00132	88 45 e0	 mov	 BYTE PTR _pMsgResult$[ebp+20], al

; 17767: 	pMsgResult.btSiegeStartDay = (BYTE)tmSiegeStartDate.wDay;

  00135	66 0f c5 c0 03	 pextrw	 ax, xmm0, 3
  0013a	88 45 e1	 mov	 BYTE PTR _pMsgResult$[ebp+21], al

; 17768: 	pMsgResult.btSiegeStartHour = (BYTE)tmSiegeStartDate.wHour;

  0013d	66 0f c5 c0 04	 pextrw	 ax, xmm0, 4

; 17769: 	pMsgResult.btSiegeStartMinute = (BYTE)tmSiegeStartDate.wMinute;
; 17770: 
; 17771: 	pMsgResult.btCurRemainTime[0] = ((iRemainTime << 16) & 0xFFFF) << 8;

  00142	66 c7 45 f6 00
	00		 mov	 WORD PTR _pMsgResult$[ebp+42], 0

; 17772: 	pMsgResult.btCurRemainTime[1] = ((iRemainTime << 16) & 0xFFFF) & 0xFF;
; 17773: 	pMsgResult.btCurRemainTime[2] = ((iRemainTime & 0xFFFF) & 0xFFFF) << 8;

  00148	c6 45 f8 00	 mov	 BYTE PTR _pMsgResult$[ebp+44], 0

; 17774: 	pMsgResult.btCurRemainTime[3] = ((iRemainTime & 0xFFFF) & 0xFFFF) & 0xFF;

  0014c	88 55 f9	 mov	 BYTE PTR _pMsgResult$[ebp+45], dl
  0014f	88 45 e2	 mov	 BYTE PTR _pMsgResult$[ebp+22], al
  00152	66 0f c5 c0 05	 pextrw	 ax, xmm0, 5
  00157	88 45 e3	 mov	 BYTE PTR _pMsgResult$[ebp+23], al

; 17775: 
; 17776: 	DataSend(iIndex,(PBYTE)&pMsgResult,pMsgResult.h.size);

  0015a	0f b6 45 cd	 movzx	 eax, BYTE PTR _pMsgResult$[ebp+1]
  0015e	50		 push	 eax
  0015f	8d 45 cc	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00162	50		 push	 eax
  00163	ff 75 08	 push	 DWORD PTR _iIndex$[ebp]
  00166	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016e	5e		 pop	 esi
  0016f	5b		 pop	 ebx
$LN3@GCAnsCastl:

; 17777: #endif
; 17778: }

  00170	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	33 cd		 xor	 ecx, ebp
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
?GCAnsCastleSiegeState@@YAXHHPAD0@Z ENDP		; GCAnsCastleSiegeState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z PROC ; CGReqCastleSiegeState, COMDAT

; 17685: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 55   : 		if ( this->m_lpThisMapSvrData != NULL )

  00003	a1 f8 6a 01 00	 mov	 eax, DWORD PTR ?g_MapServerManager@@3VCMapServerManager@@A+92920
  00008	85 c0		 test	 eax, eax
  0000a	74 0d		 je	 SHORT $LN4@CGReqCastl

; 56   : 		{
; 57   : 			return m_lpThisMapSvrData->m_btMAPSVR_GROUP;

  0000c	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17687: 	GS_GDReqOwnerGuildMaster(g_MapServerManager.GetMapSvrGroup(),iIndex);

  00010	89 45 08	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 17688: #endif
; 17689: }

  00013	5d		 pop	 ebp

; 17687: 	GS_GDReqOwnerGuildMaster(g_MapServerManager.GetMapSvrGroup(),iIndex);

  00014	e9 00 00 00 00	 jmp	 ?GS_GDReqOwnerGuildMaster@@YAXHH@Z ; GS_GDReqOwnerGuildMaster
$LN4@CGReqCastl:
; File c:\users\michel\desktop\source\gameserver\source\mapservermanager.h

; 59   : 		return -1;

  00019	83 c8 ff	 or	 eax, -1
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17687: 	GS_GDReqOwnerGuildMaster(g_MapServerManager.GetMapSvrGroup(),iIndex);

  0001c	89 45 08	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 17688: #endif
; 17689: }

  0001f	5d		 pop	 ebp

; 17687: 	GS_GDReqOwnerGuildMaster(g_MapServerManager.GetMapSvrGroup(),iIndex);

  00020	e9 00 00 00 00	 jmp	 ?GS_GDReqOwnerGuildMaster@@YAXHH@Z ; GS_GDReqOwnerGuildMaster
?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z ENDP ; CGReqCastleSiegeState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCAnsMapSvrAuth@@YAXHH@Z
_TEXT	SEGMENT
_pMsgResult$ = -8					; size = 5
_iIndex$ = 8						; size = 4
_iResult$ = 12						; size = 4
?GCAnsMapSvrAuth@@YAXHH@Z PROC				; GCAnsMapSvrAuth, COMDAT

; 17667: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 17668: 	if ( !OBJMAX_RANGE(iIndex) )

  00007	8b 75 08	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	78 3e		 js	 SHORT $LN6@GCAnsMapSv
  0000e	33 c0		 xor	 eax, eax
  00010	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	74 2f		 je	 SHORT $LN6@GCAnsMapSv

; 17671: 		return;
; 17672: 	}
; 17673: 
; 17674: 	PMSG_ANS_MAPSERVERAUTH pMsgResult;
; 17675: 
; 17676: 	PHeadSubSetB((LPBYTE)&pMsgResult, 0xB1, 0x01, sizeof(pMsgResult));

  0001d	6a 05		 push	 5
  0001f	6a 01		 push	 1
  00021	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  00024	68 b1 00 00 00	 push	 177			; 000000b1H
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 17677: 	pMsgResult.iResult = iResult;

  0002f	8a 45 0c	 mov	 al, BYTE PTR _iResult$[ebp]
  00032	88 45 fc	 mov	 BYTE PTR _pMsgResult$[ebp+4], al

; 17678: 
; 17679: 	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

  00035	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsgResult$[ebp+1]
  00039	50		 push	 eax
  0003a	8d 45 f8	 lea	 eax, DWORD PTR _pMsgResult$[ebp]
  0003d	50		 push	 eax
  0003e	56		 push	 esi
  0003f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00044	83 c4 1c	 add	 esp, 28			; 0000001cH
  00047	5e		 pop	 esi

; 17680: }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN6@GCAnsMapSv:

; 17669: 	{
; 17670: 		LogAddC(2,"[MapServerMng] Packet Error JG [0x7B] - Index out of bound : %d",iIndex);

  0004c	56		 push	 esi
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@IPNBBDAL@?$FLMapServerMng?$FN?5Packet?5Error?5JG?5?$FL@
  00052	6a 02		 push	 2
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	5e		 pop	 esi

; 17680: }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?GCAnsMapSvrAuth@@YAXHH@Z ENDP				; GCAnsMapSvrAuth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z
_TEXT	SEGMENT
_btSerial$ = -36					; size = 17
_id$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z PROC ; CGReqMapSvrAuth, COMDAT

; 17569: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 17570: 	if ( lpMsg->btCliVersion[0] != szClientVersion[0] ||
; 17571: 		 lpMsg->btCliVersion[1] != szClientVersion[1] ||
; 17572: 		 lpMsg->btCliVersion[2] != szClientVersion[2] ||
; 17573: 		 lpMsg->btCliVersion[3] != szClientVersion[3] ||

  00010	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001f	0f b6 4f 30	 movzx	 ecx, BYTE PTR [edi+48]
  00023	3b c8		 cmp	 ecx, eax
  00025	0f 85 94 02 00
	00		 jne	 $LN3@CGReqMapSv
  0002b	0f b6 4f 31	 movzx	 ecx, BYTE PTR [edi+49]
  0002f	0f be 05 01 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+1
  00036	3b c8		 cmp	 ecx, eax
  00038	0f 85 81 02 00
	00		 jne	 $LN3@CGReqMapSv
  0003e	0f b6 4f 32	 movzx	 ecx, BYTE PTR [edi+50]
  00042	0f be 05 02 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+2
  00049	3b c8		 cmp	 ecx, eax
  0004b	0f 85 6e 02 00
	00		 jne	 $LN3@CGReqMapSv
  00051	0f b6 4f 33	 movzx	 ecx, BYTE PTR [edi+51]
  00055	0f be 05 03 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+3
  0005c	3b c8		 cmp	 ecx, eax
  0005e	0f 85 5b 02 00
	00		 jne	 $LN3@CGReqMapSv
  00064	0f b6 4f 34	 movzx	 ecx, BYTE PTR [edi+52]
  00068	0f be 05 04 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+4
  0006f	3b c8		 cmp	 ecx, eax
  00071	0f 85 48 02 00
	00		 jne	 $LN3@CGReqMapSv

; 17578: 
; 17579: 		return;
; 17580: 	}
; 17581: 
; 17582: 	BYTE btSerial[17];
; 17583: 
; 17584: 	btSerial[16]=0;
; 17585: 	memcpy(btSerial, lpMsg->btCliSerial, sizeof(lpMsg->btCliSerial));

  00077	0f 10 47 35	 movups	 xmm0, XMMWORD PTR [edi+53]

; 17586: 	char id[MAX_ACCOUNT_LEN+1];
; 17587: 	id[MAX_ACCOUNT_LEN] = 0;
; 17588: 	memcpy(id, lpMsg->szAccountID, MAX_ACCOUNT_LEN);

  0007b	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]
  0007f	66 89 45 f8	 mov	 WORD PTR _id$[ebp+8], ax

; 17589: 	BuxConvert(id, MAX_ACCOUNT_LEN);

  00083	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  00086	0f 11 45 dc	 movups	 XMMWORD PTR _btSerial$[ebp], xmm0
  0008a	6a 0a		 push	 10			; 0000000aH
  0008c	f3 0f 7e 47 04	 movq	 xmm0, QWORD PTR [edi+4]
  00091	50		 push	 eax
  00092	c6 45 ec 00	 mov	 BYTE PTR _btSerial$[ebp+16], 0
  00096	c6 45 fa 00	 mov	 BYTE PTR _id$[ebp+10], 0
  0009a	66 0f d6 45 f0	 movq	 QWORD PTR _id$[ebp], xmm0
  0009f	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  000a4	83 c4 08	 add	 esp, 8

; 17590: 
; 17591: 	if ( strcmp((char*)btSerial, szGameServerExeSerial) )

  000a7	8d 45 dc	 lea	 eax, DWORD PTR _btSerial$[ebp]
  000aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?szGameServerExeSerial@@3PADA ; szGameServerExeSerial
  000af	90		 npad	 1
$LL17@CGReqMapSv:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN18@CGReqMapSv
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN19@CGReqMapSv
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN18@CGReqMapSv
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL17@CGReqMapSv
$LN19@CGReqMapSv:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN20@CGReqMapSv
$LN18@CGReqMapSv:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 c8 01	 or	 eax, 1
$LN20@CGReqMapSv:
  000d5	85 c0		 test	 eax, eax
  000d7	74 36		 je	 SHORT $LN4@CGReqMapSv

; 17592: 	{
; 17593: 		LogAddC(2, "error-L1: Serial error [%s] [%s]", id, btSerial);

  000d9	8d 45 dc	 lea	 eax, DWORD PTR _btSerial$[ebp]
  000dc	50		 push	 eax
  000dd	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  000e0	50		 push	 eax
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@
  000e6	6a 02		 push	 2
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 17594: 		GCAnsMapSvrAuth(iIndex, 6);

  000ee	6a 06		 push	 6
  000f0	56		 push	 esi
  000f1	e8 00 00 00 00	 call	 ?GCAnsMapSvrAuth@@YAXHH@Z ; GCAnsMapSvrAuth

; 17595: 		CloseClient(iIndex);

  000f6	56		 push	 esi
  000f7	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000fc	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi

; 17653: 		gObj[iIndex].AccountID, gObj[iIndex].Name, iIndex);
; 17654: 
; 17655: 
; 17656: }

  00101	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00104	33 cd		 xor	 ecx, ebp
  00106	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
$LN4@CGReqMapSv:

; 17596: 		return;
; 17597: 	}
; 17598: 
; 17599: 	if ( g_ConnectMemberLoad == TRUE )

  0010f	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?g_ConnectMemberLoad@@3_NA, 1 ; g_ConnectMemberLoad
  00116	75 2d		 jne	 SHORT $LN6@CGReqMapSv

; 17600: 	{
; 17601: 		if ( ConMember.IsMember(id) == FALSE )

  00118	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  0011b	b9 00 00 00 00	 mov	 ecx, OFFSET ?ConMember@@3VCConMember@@A ; ConMember
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ?IsMember@CConMember@@QAEHPAD@Z ; CConMember::IsMember
  00126	85 c0		 test	 eax, eax
  00128	75 1b		 jne	 SHORT $LN6@CGReqMapSv

; 17602: 		{
; 17603: 			GCAnsMapSvrAuth(iIndex, 2);	

  0012a	6a 02		 push	 2
  0012c	56		 push	 esi
  0012d	e8 00 00 00 00	 call	 ?GCAnsMapSvrAuth@@YAXHH@Z ; GCAnsMapSvrAuth
  00132	83 c4 08	 add	 esp, 8
  00135	5f		 pop	 edi
  00136	5e		 pop	 esi

; 17653: 		gObj[iIndex].AccountID, gObj[iIndex].Name, iIndex);
; 17654: 
; 17655: 
; 17656: }

  00137	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013a	33 cd		 xor	 ecx, ebp
  0013c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
$LN6@CGReqMapSv:

; 17604: 			return;
; 17605: 		}
; 17606: 	}
; 17607: 
; 17608: 	LPOBJ lpObj = &gObj[iIndex];

  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014a	53		 push	 ebx
  0014b	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00151	03 c3		 add	 eax, ebx

; 17609: 
; 17610: 	if ( PacketCheckTime(lpObj) == FALSE )

  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00159	83 c4 04	 add	 esp, 4
  0015c	85 c0		 test	 eax, eax
  0015e	75 0c		 jne	 SHORT $LN7@CGReqMapSv

; 17611: 	{
; 17612: 		LogAdd(lMsg.Get(MSGGET(1, 217)), iIndex, id);

  00160	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  00163	50		 push	 eax
  00164	56		 push	 esi
  00165	68 d9 01 00 00	 push	 473			; 000001d9H

; 17613: 		CloseClient(iIndex);
; 17614: 
; 17615: 		return;

  0016a	eb 19		 jmp	 SHORT $LN22@CGReqMapSv
$LN7@CGReqMapSv:

; 17616: 	}
; 17617: 
; 17618: 	if ( gObj[iIndex].Connected != PLAYER_CONNECTED )

  0016c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00171	83 7c 03 04 01	 cmp	 DWORD PTR [ebx+eax+4], 1
  00176	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  00179	74 35		 je	 SHORT $LN8@CGReqMapSv

; 17619: 	{
; 17620: 		LogAdd(lMsg.Get(MSGGET(1, 218)), iIndex, id);

  0017b	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  0017e	50		 push	 eax
  0017f	56		 push	 esi
  00180	68 da 01 00 00	 push	 474			; 000001daH
$LN22@CGReqMapSv:
  00185	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0018a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0018f	50		 push	 eax
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 17621: 		CloseClient(iIndex);

  00196	56		 push	 esi
  00197	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 17629: 		{
; 17630: 			LogAdd(lMsg.Get(MSGGET(1, 219)), iIndex, id, gObj[iIndex].Ip_addr);

  0019c	83 c4 10	 add	 esp, 16			; 00000010H
  0019f	5b		 pop	 ebx
  001a0	5f		 pop	 edi
  001a1	5e		 pop	 esi

; 17653: 		gObj[iIndex].AccountID, gObj[iIndex].Name, iIndex);
; 17654: 
; 17655: 
; 17656: }

  001a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a5	33 cd		 xor	 ecx, ebp
  001a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ac	8b e5		 mov	 esp, ebp
  001ae	5d		 pop	 ebp
  001af	c3		 ret	 0
$LN8@CGReqMapSv:

; 17622: 
; 17623: 		return;
; 17624: 	}
; 17625: 
; 17626: 	if ( gObj[iIndex].LoginMsgSnd != 0 )

  001b0	8a 41 0a	 mov	 al, BYTE PTR [ecx+10]
  001b3	84 c0		 test	 al, al
  001b5	74 4c		 je	 SHORT $LN9@CGReqMapSv

; 17627: 	{
; 17628: 		if ( gObj[iIndex].LoginMsgSnd == 1 )

  001b7	3c 01		 cmp	 al, 1
  001b9	75 33		 jne	 SHORT $LN10@CGReqMapSv

; 17629: 		{
; 17630: 			LogAdd(lMsg.Get(MSGGET(1, 219)), iIndex, id, gObj[iIndex].Ip_addr);

  001bb	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  001be	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001c3	50		 push	 eax
  001c4	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  001c7	50		 push	 eax
  001c8	56		 push	 esi
  001c9	68 db 01 00 00	 push	 475			; 000001dbH
  001ce	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001d3	50		 push	 eax
$LN23@CGReqMapSv:
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001da	83 c4 10	 add	 esp, 16			; 00000010H
  001dd	5b		 pop	 ebx
  001de	5f		 pop	 edi
  001df	5e		 pop	 esi

; 17653: 		gObj[iIndex].AccountID, gObj[iIndex].Name, iIndex);
; 17654: 
; 17655: 
; 17656: }

  001e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e3	33 cd		 xor	 ecx, ebp
  001e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c3		 ret	 0
$LN10@CGReqMapSv:

; 17631: 		}
; 17632: 		else
; 17633: 		{
; 17634: 			LogAdd("error : %d %s %d", gObj[iIndex].LoginMsgSnd, __FILE__, __LINE__);

  001ee	68 e2 44 00 00	 push	 17634			; 000044e2H
  001f3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001f8	0f be c0	 movsx	 eax, al
  001fb	50		 push	 eax
  001fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@

; 17635: 		}
; 17636: 
; 17637: 		return;

  00201	eb d1		 jmp	 SHORT $LN23@CGReqMapSv
$LN9@CGReqMapSv:

; 17638: 	}
; 17639: 
; 17640: 	gObj[iIndex].ConnectCheckTime = GetTickCount(); 

  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00209	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020f	89 44 0b 3c	 mov	 DWORD PTR [ebx+ecx+60], eax

; 17641: 
; 17642: 	gObj[iIndex].LoginMsgSnd = 1;

  00213	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00218	c6 44 03 0a 01	 mov	 BYTE PTR [ebx+eax+10], 1

; 17643: 	gObj[iIndex].LoginMsgCount++;

  0021d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00222	fe 44 03 0b	 inc	 BYTE PTR [ebx+eax+11]

; 17644: 	gObj[iIndex].AccountID[MAX_ACCOUNT_LEN] = 0;

  00226	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022b	c6 44 03 5c 00	 mov	 BYTE PTR [ebx+eax+92], 0

; 17645: 	memcpy(gObj[iIndex].AccountID, id, MAX_ACCOUNT_LEN);

  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00236	f3 0f 7e 45 f0	 movq	 xmm0, QWORD PTR _id$[ebp]
  0023b	66 0f d6 44 19
	52		 movq	 QWORD PTR [ecx+ebx+82], xmm0
  00241	0f 57 c0	 xorps	 xmm0, xmm0
  00244	66 8b 45 f8	 mov	 ax, WORD PTR _id$[ebp+8]
  00248	66 89 44 19 5a	 mov	 WORD PTR [ecx+ebx+90], ax

; 17646: 	memset(gObj[iIndex].Name, 0, MAX_ACCOUNT_LEN);

  0024d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00252	66 0f d6 44 03
	5d		 movq	 QWORD PTR [ebx+eax+93], xmm0
  00258	66 c7 44 03 65
	00 00		 mov	 WORD PTR [ebx+eax+101], 0

; 17647: 	gObj[iIndex].m_cAccountItemBlock = 0;

  0025f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00264	c6 84 03 c4 01
	00 00 00	 mov	 BYTE PTR [ebx+eax+452], 0

; 17648: 	GJReqMapSvrAuth(iIndex, gObj[iIndex].AccountID, lpMsg->szCharName,

  0026c	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  0026f	ff 77 28	 push	 DWORD PTR [edi+40]
  00272	ff 77 24	 push	 DWORD PTR [edi+36]
  00275	ff 77 20	 push	 DWORD PTR [edi+32]
  00278	ff 77 1c	 push	 DWORD PTR [edi+28]
  0027b	50		 push	 eax
  0027c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00281	83 c0 52	 add	 eax, 82			; 00000052H
  00284	03 c3		 add	 eax, ebx
  00286	50		 push	 eax
  00287	56		 push	 esi
  00288	e8 00 00 00 00	 call	 ?GJReqMapSvrAuth@@YAXHPAD0HHHH@Z ; GJReqMapSvrAuth

; 17649: 		lpMsg->iJoinAuthCode1, lpMsg->iJoinAuthCode2,
; 17650: 		lpMsg->iJoinAuthCode3, lpMsg->iJoinAuthCode4);
; 17651: 
; 17652: 	LogAddTD("[MapServerMng] Map Server Join Send : [%s][%s](%d)",

  0028d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00293	56		 push	 esi
  00294	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00297	03 c3		 add	 eax, ebx
  00299	50		 push	 eax
  0029a	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0029d	03 c3		 add	 eax, ebx
  0029f	50		 push	 eax
  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@OALOABGE@?$FLMapServerMng?$FN?5Map?5Server?5Join?5S@
  002a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002ab	83 c4 2c	 add	 esp, 44			; 0000002cH
  002ae	5b		 pop	 ebx
  002af	5f		 pop	 edi
  002b0	5e		 pop	 esi

; 17653: 		gObj[iIndex].AccountID, gObj[iIndex].Name, iIndex);
; 17654: 
; 17655: 
; 17656: }

  002b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b4	33 cd		 xor	 ecx, ebp
  002b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c3		 ret	 0
$LN3@CGReqMapSv:

; 17574: 		 lpMsg->btCliVersion[4] != szClientVersion[4] )
; 17575: 	{
; 17576: 		GCAnsMapSvrAuth(iIndex, 6);

  002bf	6a 06		 push	 6
  002c1	56		 push	 esi
  002c2	e8 00 00 00 00	 call	 ?GCAnsMapSvrAuth@@YAXHH@Z ; GCAnsMapSvrAuth

; 17577: 		CloseClient(iIndex);

  002c7	56		 push	 esi
  002c8	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 17653: 		gObj[iIndex].AccountID, gObj[iIndex].Name, iIndex);
; 17654: 
; 17655: 
; 17656: }

  002cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d3	33 cd		 xor	 ecx, ebp
  002d5	5f		 pop	 edi
  002d6	5e		 pop	 esi
  002d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002dc	8b e5		 mov	 esp, ebp
  002de	5d		 pop	 ebp
  002df	c3		 ret	 0
?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z ENDP ; CGReqMapSvrAuth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z
_TEXT	SEGMENT
_ErrMsg$ = -24						; size = 8
_szUnionMemberGuildName$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z PROC ; CGRelationShipReqKickOutUnionMember, COMDAT

; 17489: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _aRecv$[ebp]
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 17490: 	if ( !OBJMAX_RANGE(aIndex))

  00018	85 f6		 test	 esi, esi
  0001a	0f 88 7e 01 00
	00		 js	 $LN1@CGRelation
  00020	33 c0		 xor	 eax, eax
  00022	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00028	0f 9e c0	 setle	 al
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 6b 01 00
	00		 je	 $LN1@CGRelation

; 17491: 		return;
; 17492: 
; 17493: 	if ( ::PacketCheckTime(&gObj[aIndex]) == FALSE )

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	57		 push	 edi
  00039	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  0003f	03 c7		 add	 eax, edi
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00047	83 c4 04	 add	 esp, 4
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 4b 01 00
	00		 je	 $LN18@CGRelation

; 17494: 		return;
; 17495: 
; 17496: 	LPOBJ lpObj = &gObj[aIndex];

  00052	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17497: 
; 17498: 	if ( lpObj == NULL )

  00058	0f 84 3f 01 00
	00		 je	 $LN18@CGRelation

; 17499: 		return;
; 17500: 
; 17501: 	if ( gObjIsConnected(&gObj[aIndex]) == FALSE )

  0005e	57		 push	 edi
  0005f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00064	83 c4 04	 add	 esp, 4
  00067	85 c0		 test	 eax, eax
  00069	75 29		 jne	 SHORT $LN5@CGRelation

; 17502: 	{
; 17503: 		GCResultSend(aIndex, 0x51, 3);

  0006b	6a 03		 push	 3
  0006d	6a 51		 push	 81			; 00000051H
  0006f	56		 push	 esi
  00070	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 17504: 		MsgOutput(aIndex, " Terminated User.");

  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PGBMBNEJ@?$KB?Z?5Terminated?5User?4?$AA@
  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx

; 17563: }

  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN5@CGRelation:

; 17505: 		return;
; 17506: 	}
; 17507: 
; 17508: 	if ( lpObj->lpGuild == NULL )

  00094	83 bf 18 06 00
	00 00		 cmp	 DWORD PTR [edi+1560], 0
  0009b	75 29		 jne	 SHORT $LN6@CGRelation

; 17509: 	{
; 17510: 		GCResultSend(aIndex, 0x51, 3);

  0009d	6a 03		 push	 3
  0009f	6a 51		 push	 81			; 00000051H
  000a1	56		 push	 esi
  000a2	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 17511: 		MsgOutput(aIndex, " Terminated Guild.");

  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IFHLAKIO@?$KB?Y?5Terminated?5Guild?4?$AA@
  000ac	56		 push	 esi
  000ad	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000b2	83 c4 14	 add	 esp, 20			; 00000014H
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx

; 17563: }

  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bb	33 cd		 xor	 ecx, ebp
  000bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
$LN6@CGRelation:

; 17512: 		return;
; 17513: 	}
; 17514: 
; 17515: 	PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS ErrMsg = {0};

  000c6	33 c0		 xor	 eax, eax
  000c8	c6 45 e8 00	 mov	 BYTE PTR _ErrMsg$[ebp], 0

; 17516: 
; 17517: 	PHeadSetB((LPBYTE)&ErrMsg, 0xE6, sizeof(ErrMsg));

  000cc	6a 08		 push	 8
  000ce	89 45 e9	 mov	 DWORD PTR _ErrMsg$[ebp+1], eax
  000d1	66 89 45 ed	 mov	 WORD PTR _ErrMsg$[ebp+5], ax
  000d5	88 45 ef	 mov	 BYTE PTR _ErrMsg$[ebp+7], al
  000d8	8d 45 e8	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  000db	68 e6 00 00 00	 push	 230			; 000000e6H
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17518: 	ErrMsg.btResult = 0;
; 17519: 	ErrMsg.btRequestType = 2;

  000e6	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _ErrMsg$[ebp+4], 2
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17520: 	ErrMsg.btRelationShipType = 1;

  000f0	c6 45 eb 01	 mov	 BYTE PTR _ErrMsg$[ebp+3], 1

; 17521: 	ErrMsg.btTargetUserIndexH = 0;
; 17522: 	ErrMsg.btTargetUserIndexL = 0;
; 17523: 
; 17524: #if (ENABLETEST_ARCA == 1)
; 17525: 	int iArcaBattleState = g_ArcaBattle.GetState();
; 17526: 
; 17527: 	if( iArcaBattleState > AB_STATE_CLOSED && iArcaBattleState < AB_STATE_CLOSE )
; 17528: 	{
; 17529: 		ErrMsg.btResult = 33;
; 17530: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17531: 		return;
; 17532: 	}
; 17533: #endif
; 17534: 
; 17535: 	if ( lpObj->lpGuild->iGuildUnion == 0 )

  000f4	8b 87 18 06 00
	00		 mov	 eax, DWORD PTR [edi+1560]
  000fa	8b 88 44 07 00
	00		 mov	 ecx, DWORD PTR [eax+1860]
  00100	85 c9		 test	 ecx, ecx
  00102	75 09		 jne	 SHORT $LN7@CGRelation

; 17536: 	{
; 17537: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_UNION;

  00104	c6 45 ed 19	 mov	 BYTE PTR _ErrMsg$[ebp+5], 25 ; 00000019H

; 17538: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17539: 
; 17540: 		return;

  00108	e9 7e 00 00 00	 jmp	 $LN19@CGRelation
$LN7@CGRelation:

; 17541: 	}
; 17542: 
; 17543: 	if ( lpObj->GuildStatus != GUILD_MASTER || lpObj->lpGuild->Number != lpObj->lpGuild->iGuildUnion)

  0010d	81 bf 28 06 00
	00 80 00 00 00	 cmp	 DWORD PTR [edi+1576], 128 ; 00000080H
  00117	75 6e		 jne	 SHORT $LN9@CGRelation
  00119	39 08		 cmp	 DWORD PTR [eax], ecx
  0011b	75 6a		 jne	 SHORT $LN9@CGRelation

; 17547: 
; 17548: 		return;
; 17549: 	}
; 17550: 
; 17551: 	char szUnionMemberGuildName[MAX_GUILD_LEN+1] = {0};
; 17552: 	memcpy(szUnionMemberGuildName, aRecv->szTargetGuildName, MAX_GUILD_LEN);

  0011d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 17553: 
; 17554: 	if ( !strcmp(lpObj->lpGuild->Name, szUnionMemberGuildName))

  00120	8d 4d f0	 lea	 ecx, DWORD PTR _szUnionMemberGuildName$[ebp]
  00123	0f 57 c0	 xorps	 xmm0, xmm0
  00126	66 0f d6 45 f1	 movq	 QWORD PTR _szUnionMemberGuildName$[ebp+1], xmm0
  0012b	89 45 f0	 mov	 DWORD PTR _szUnionMemberGuildName$[ebp], eax
  0012e	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00131	89 45 f4	 mov	 DWORD PTR _szUnionMemberGuildName$[ebp+4], eax
  00134	8b 87 18 06 00
	00		 mov	 eax, DWORD PTR [edi+1560]
  0013a	83 c0 04	 add	 eax, 4
  0013d	0f 1f 00	 npad	 3
$LL14@CGRelation:
  00140	8a 10		 mov	 dl, BYTE PTR [eax]
  00142	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00144	75 1a		 jne	 SHORT $LN15@CGRelation
  00146	84 d2		 test	 dl, dl
  00148	74 12		 je	 SHORT $LN16@CGRelation
  0014a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0014d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00150	75 0e		 jne	 SHORT $LN15@CGRelation
  00152	83 c0 02	 add	 eax, 2
  00155	83 c1 02	 add	 ecx, 2
  00158	84 d2		 test	 dl, dl
  0015a	75 e4		 jne	 SHORT $LL14@CGRelation
$LN16@CGRelation:
  0015c	33 c0		 xor	 eax, eax
  0015e	eb 05		 jmp	 SHORT $LN17@CGRelation
$LN15@CGRelation:
  00160	1b c0		 sbb	 eax, eax
  00162	83 c8 01	 or	 eax, 1
$LN17@CGRelation:
  00165	85 c0		 test	 eax, eax
  00167	74 1e		 je	 SHORT $LN9@CGRelation

; 17555: 	{
; 17556: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 17557: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17558: 
; 17559: 		return;
; 17560: 	}
; 17561: 
; 17562: 	GDRelationShipReqKickOutUnionMember(aIndex, szUnionMemberGuildName);

  00169	8d 45 f0	 lea	 eax, DWORD PTR _szUnionMemberGuildName$[ebp]
  0016c	50		 push	 eax
  0016d	56		 push	 esi
  0016e	e8 00 00 00 00	 call	 ?GDRelationShipReqKickOutUnionMember@@YAXHPAD@Z ; GDRelationShipReqKickOutUnionMember
  00173	83 c4 08	 add	 esp, 8
  00176	5f		 pop	 edi
  00177	5e		 pop	 esi
  00178	5b		 pop	 ebx

; 17563: }

  00179	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017c	33 cd		 xor	 ecx, ebp
  0017e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c3		 ret	 0
$LN9@CGRelation:

; 17544: 	{
; 17545: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;

  00187	c6 45 ed 11	 mov	 BYTE PTR _ErrMsg$[ebp+5], 17 ; 00000011H
$LN19@CGRelation:

; 17546: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0018b	0f b6 45 e9	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  0018f	50		 push	 eax
  00190	8d 45 e8	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00193	50		 push	 eax
  00194	56		 push	 esi
  00195	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0019a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@CGRelation:
  0019d	5f		 pop	 edi
$LN1@CGRelation:

; 17563: }

  0019e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a1	5e		 pop	 esi
  001a2	33 cd		 xor	 ecx, ebp
  001a4	5b		 pop	 ebx
  001a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z ENDP ; CGRelationShipReqKickOutUnionMember
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z PROC	; CGUnionList, COMDAT

; 17450: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 17451: 	if ( !OBJMAX_RANGE(aIndex))

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	78 6f		 js	 SHORT $LN1@CGUnionLis
  0000b	33 c0		 xor	 eax, eax
  0000d	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	74 60		 je	 SHORT $LN1@CGUnionLis

; 17452: 		return;
; 17453: 
; 17454: 	if ( !PacketCheckTime(&gObj[aIndex]))

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001f	57		 push	 edi
  00020	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00026	03 c7		 add	 eax, edi
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	74 44		 je	 SHORT $LN11@CGUnionLis

; 17455: 		return;
; 17456: 
; 17457: 	LPOBJ lpObj = &gObj[aIndex];

  00035	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17458: 
; 17459: 	if ( lpObj == NULL )

  0003b	74 3c		 je	 SHORT $LN11@CGUnionLis

; 17460: 	{
; 17461: 		return;
; 17462: 	}
; 17463: 
; 17464: 	if ( gObjIsConnected(&gObj[aIndex]) == FALSE )

  0003d	57		 push	 edi
  0003e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00043	83 c4 04	 add	 esp, 4
  00046	85 c0		 test	 eax, eax
  00048	74 14		 je	 SHORT $LN12@CGUnionLis

; 17465: 	{
; 17466: 		GCResultSend(aIndex, 0x51, 3);
; 17467: 		return;
; 17468: 	}
; 17469: 
; 17470: 	if ( lpObj->lpGuild == NULL )

  0004a	8b 87 18 06 00
	00		 mov	 eax, DWORD PTR [edi+1560]
  00050	85 c0		 test	 eax, eax
  00052	74 0a		 je	 SHORT $LN12@CGUnionLis

; 17471: 	{
; 17472: 		GCResultSend(aIndex, 0x51, 3);
; 17473: 		return;
; 17474: 	}
; 17475: 
; 17476: 	if ( lpObj->lpGuild->iGuildUnion == 0 )

  00054	8b 80 44 07 00
	00		 mov	 eax, DWORD PTR [eax+1860]
  0005a	85 c0		 test	 eax, eax
  0005c	75 11		 jne	 SHORT $LN7@CGUnionLis
$LN12@CGUnionLis:

; 17477: 	{
; 17478: 		GCResultSend(aIndex, 0x51, 3);

  0005e	6a 03		 push	 3
  00060	6a 51		 push	 81			; 00000051H
  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi

; 17483: 
; 17484: }

  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
$LN7@CGUnionLis:

; 17479: 		return;
; 17480: 	}
; 17481: 
; 17482: 	GDUnionListSend(aIndex, lpObj->lpGuild->iGuildUnion);

  0006f	50		 push	 eax
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ?GDUnionListSend@@YAXHH@Z ; GDUnionListSend
  00076	83 c4 08	 add	 esp, 8
$LN11@CGUnionLis:
  00079	5f		 pop	 edi
$LN1@CGUnionLis:
  0007a	5e		 pop	 esi

; 17483: 
; 17484: }

  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z ENDP	; CGUnionList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z
_TEXT	SEGMENT
_ErrMsg$1 = -8						; size = 8
tv297 = 8						; size = 4
_aRecv$ = 8						; size = 4
tv296 = 12						; size = 4
_aIndex$ = 12						; size = 4
?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z PROC ; CGRelationShipAnsJoinBreakOff, COMDAT

; 17388: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 17389: 	int iTargetUserIndex = MAKE_NUMBERW(aRecv->btTargetUserIndexH, aRecv->btTargetUserIndexL);
; 17390: 
; 17391: 	if ( !OBJMAX_RANGE(aIndex) || !OBJMAX_RANGE(iTargetUserIndex))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  0000e	57		 push	 edi
  0000f	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  00013	66 c1 e0 08	 shl	 ax, 8
  00017	0f b7 f8	 movzx	 edi, ax
  0001a	0f b6 46 07	 movzx	 eax, BYTE PTR [esi+7]
  0001e	0b f8		 or	 edi, eax
  00020	85 db		 test	 ebx, ebx
  00022	0f 88 5f 01 00
	00		 js	 $LN3@CGRelation
  00028	33 c0		 xor	 eax, eax
  0002a	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00030	0f 9e c0	 setle	 al
  00033	85 c0		 test	 eax, eax
  00035	0f 84 4c 01 00
	00		 je	 $LN3@CGRelation
  0003b	85 ff		 test	 edi, edi
  0003d	0f 88 44 01 00
	00		 js	 $LN3@CGRelation
  00043	33 c0		 xor	 eax, eax
  00045	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0004b	0f 9e c0	 setle	 al
  0004e	85 c0		 test	 eax, eax
  00050	0f 84 31 01 00
	00		 je	 $LN3@CGRelation

; 17392: 		return;
; 17393: 
; 17394: 	if ( !PacketCheckTime(&gObj[aIndex]))

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005b	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  00061	03 c1		 add	 eax, ecx
  00063	89 4d 08	 mov	 DWORD PTR tv297[ebp], ecx
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0006c	83 c4 04	 add	 esp, 4
  0006f	85 c0		 test	 eax, eax
  00071	0f 84 10 01 00
	00		 je	 $LN3@CGRelation

; 17395: 		return;
; 17396: 
; 17397: 	if ( gObjIsConnected(&gObj[iTargetUserIndex]) == FALSE )

  00077	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007c	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00082	03 c1		 add	 eax, ecx
  00084	89 4d 0c	 mov	 DWORD PTR tv296[ebp], ecx
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0008d	83 c4 04	 add	 esp, 4
  00090	85 c0		 test	 eax, eax
  00092	75 14		 jne	 SHORT $LN5@CGRelation

; 17398: 	{
; 17399: 		GCResultSend(aIndex, 0x51, 3);

  00094	6a 03		 push	 3
  00096	6a 51		 push	 81			; 00000051H
  00098	53		 push	 ebx
  00099	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx

; 17442: 		}
; 17443: 	}
; 17444: }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
$LN5@CGRelation:

; 17400: 		return;
; 17401: 	}
; 17402: 
; 17403: 	if ( aRecv->btResult == 1 )

  000a8	80 7e 05 01	 cmp	 BYTE PTR [esi+5], 1
  000ac	75 2d		 jne	 SHORT $LN6@CGRelation

; 17404: 	{
; 17405: 		if ( aRecv->btRequestType == 1 )

  000ae	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  000b1	3c 01		 cmp	 al, 1
  000b3	75 11		 jne	 SHORT $LN8@CGRelation

; 17406: 		{
; 17407: 			GDRelationShipReqJoin(iTargetUserIndex, aIndex, aRecv->btRelationShipType);

  000b5	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  000b9	50		 push	 eax
  000ba	53		 push	 ebx
  000bb	57		 push	 edi
  000bc	e8 00 00 00 00	 call	 ?GDRelationShipReqJoin@@YAXHHH@Z ; GDRelationShipReqJoin
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c4	eb 67		 jmp	 SHORT $LN7@CGRelation
$LN8@CGRelation:

; 17408: 		}
; 17409: 		else if ( aRecv->btRequestType == 2 )

  000c6	3c 02		 cmp	 al, 2
  000c8	75 63		 jne	 SHORT $LN7@CGRelation

; 17410: 		{
; 17411: 			GDRelationShipReqBreakOff(aIndex, iTargetUserIndex, aRecv->btRelationShipType);

  000ca	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  000ce	50		 push	 eax
  000cf	57		 push	 edi
  000d0	53		 push	 ebx
  000d1	e8 00 00 00 00	 call	 ?GDRelationShipReqBreakOff@@YAXHHH@Z ; GDRelationShipReqBreakOff
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17412: 		}
; 17413: 	}
; 17414: 	else

  000d9	eb 52		 jmp	 SHORT $LN7@CGRelation
$LN6@CGRelation:

; 17415: 	{
; 17416: 		PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS ErrMsg ={0};

  000db	33 c0		 xor	 eax, eax
  000dd	c6 45 f8 00	 mov	 BYTE PTR _ErrMsg$1[ebp], 0

; 17417: 
; 17418: 		PHeadSetB((LPBYTE)&ErrMsg, 0xE6, sizeof(ErrMsg));

  000e1	6a 08		 push	 8
  000e3	89 45 f9	 mov	 DWORD PTR _ErrMsg$1[ebp+1], eax
  000e6	66 89 45 fd	 mov	 WORD PTR _ErrMsg$1[ebp+5], ax
  000ea	88 45 ff	 mov	 BYTE PTR _ErrMsg$1[ebp+7], al
  000ed	8d 45 f8	 lea	 eax, DWORD PTR _ErrMsg$1[ebp]
  000f0	68 e6 00 00 00	 push	 230			; 000000e6H
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17419: 		ErrMsg.btResult = 0;
; 17420: 		ErrMsg.btRequestType = aRecv->btRequestType;

  000fb	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  000ff	88 45 fc	 mov	 BYTE PTR _ErrMsg$1[ebp+4], al

; 17421: 		ErrMsg.btRelationShipType = aRecv->btRelationShipType;

  00102	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00106	88 45 fb	 mov	 BYTE PTR _ErrMsg$1[ebp+3], al

; 17422: 		ErrMsg.btTargetUserIndexH = aRecv->btTargetUserIndexH;

  00109	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  0010d	88 45 fe	 mov	 BYTE PTR _ErrMsg$1[ebp+6], al

; 17423: 		ErrMsg.btTargetUserIndexL = aRecv->btTargetUserIndexL;

  00110	0f b6 46 07	 movzx	 eax, BYTE PTR [esi+7]
  00114	88 45 ff	 mov	 BYTE PTR _ErrMsg$1[ebp+7], al

; 17424: 		ErrMsg.btResult = GUILD_ANS_CANCLE_REQUEST;
; 17425: 
; 17426: 		DataSend(iTargetUserIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00117	0f b6 45 f9	 movzx	 eax, BYTE PTR _ErrMsg$1[ebp+1]
  0011b	50		 push	 eax
  0011c	8d 45 f8	 lea	 eax, DWORD PTR _ErrMsg$1[ebp]
  0011f	c6 45 fd 20	 mov	 BYTE PTR _ErrMsg$1[ebp+5], 32 ; 00000020H
  00123	50		 push	 eax
  00124	57		 push	 edi
  00125	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0012a	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@CGRelation:

; 17427: 	}
; 17428: 
; 17429: 	if ( gObj[aIndex].m_IfState.use )

  0012d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00133	8b 75 08	 mov	 esi, DWORD PTR tv297[ebp]
  00136	8b 8c 16 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4536]
  0013d	f6 c1 03	 test	 cl, 3
  00140	74 1e		 je	 SHORT $LN12@CGRelation

; 17430: 	{
; 17431: 		if ( gObj[aIndex].m_IfState.type == 14 )

  00142	8b c1		 mov	 eax, ecx
  00144	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00149	3d 80 03 00 00	 cmp	 eax, 896		; 00000380H
  0014e	75 10		 jne	 SHORT $LN12@CGRelation

; 17432: 		{
; 17433: 			gObj[aIndex].m_IfState.use = 0;

  00150	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00153	89 8c 16 b8 11
	00 00		 mov	 DWORD PTR [esi+edx+4536], ecx
  0015a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN12@CGRelation:

; 17434: 		}
; 17435: 	}
; 17436: 
; 17437: 	if ( gObj[iTargetUserIndex].m_IfState.use )

  00160	8b 75 0c	 mov	 esi, DWORD PTR tv296[ebp]
  00163	8b 8c 16 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4536]
  0016a	f6 c1 03	 test	 cl, 3
  0016d	74 18		 je	 SHORT $LN3@CGRelation

; 17438: 	{
; 17439: 		if ( gObj[iTargetUserIndex].m_IfState.type == 14 )

  0016f	8b c1		 mov	 eax, ecx
  00171	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00176	3d 80 03 00 00	 cmp	 eax, 896		; 00000380H
  0017b	75 0a		 jne	 SHORT $LN3@CGRelation

; 17440: 		{
; 17441: 			gObj[iTargetUserIndex].m_IfState.use = 0;

  0017d	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00180	89 8c 16 b8 11
	00 00		 mov	 DWORD PTR [esi+edx+4536], ecx
$LN3@CGRelation:
  00187	5f		 pop	 edi
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx

; 17442: 		}
; 17443: 	}
; 17444: }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z ENDP ; CGRelationShipAnsJoinBreakOff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z
_TEXT	SEGMENT
_szCastleOwnerGuildName$1 = -60				; size = 9
_iTargetUserIndex$1$ = -48				; size = 4
_obj$1$ = -44						; size = 4
_lpTargetObj$1$ = -44					; size = 4
_btRelationShip$1$ = -37				; size = 1
tv716 = -36						; size = 4
_lpObj$1$ = -36						; size = 4
_lpGuildInfo$1$ = -32					; size = 4
_ErrMsg$ = -28						; size = 8
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z PROC ; CGRelationShipReqJoinBreakOff, COMDAT

; 17121: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 17122: 	if ( g_CastleSiegeSync.GetCastleState() >= 5 && g_CastleSiegeSync.GetCastleState() <= 7 )

  00010	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+4
  00015	53		 push	 ebx
  00016	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00019	83 c0 fb	 add	 eax, -5			; fffffffbH
  0001c	57		 push	 edi
  0001d	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]
  00020	83 f8 02	 cmp	 eax, 2
  00023	77 29		 ja	 SHORT $LN2@CGRelation

; 17123: 	{
; 17124: 		MsgOutput(aIndex, lMsg.Get(MSGGET(6, 196)));

  00025	68 c4 06 00 00	 push	 1732			; 000006c4H
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0002f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00034	50		 push	 eax
  00035	53		 push	 ebx
  00036	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0003b	83 c4 08	 add	 esp, 8
  0003e	5f		 pop	 edi
  0003f	5b		 pop	 ebx

; 17382: }

  00040	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00043	33 cd		 xor	 ecx, ebp
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN2@CGRelation:

; 17125: 		return;
; 17126: 	}
; 17127: 
; 17128: #if (ENABLETEST_ARCA == 1)
; 17129: 	int iArcaBattleState = g_ArcaBattle.GetState();
; 17130: 
; 17131: 	if( iArcaBattleState > AB_STATE_CLOSED && iArcaBattleState < AB_STATE_CLOSE )
; 17132: 	{
; 17133: #if( AB_DEBUG_TRACE == 1 )
; 17134: 		TRACE_LOG("aIndex, 0x51, 0xA5");
; 17135: #endif
; 17136: 		GCResultSend(aIndex, 0x51, 0xA4);
; 17137: 		return;
; 17138: 	}
; 17139: #endif
; 17140: 
; 17141: 	int iTargetUserIndex = -1;
; 17142: 	
; 17143: 	/*if( aRecv->btRelationShipType == 2 && aRecv->btRequestType == 2 )
; 17144: 	{
; 17145: 		char szGuild[9]={0};
; 17146: 		memcpy(szGuild,aRecv->szGuild,8);
; 17147: 
; 17148: 		_GUILD_INFO_STRUCT* lpGuild = Guild.SearchGuild(szGuild);
; 17149: 
; 17150: 		if( lpGuild )
; 17151: 		{
; 17152: 			iTargetUserIndex = lpGuild->Index[0];
; 17153: 		}
; 17154: 	}
; 17155: 	else
; 17156: 	{*/
; 17157: 		iTargetUserIndex = MAKE_NUMBERW(aRecv->btTargetUserIndexH, aRecv->btTargetUserIndexL);

  0004e	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00052	66 c1 e0 08	 shl	 ax, 8
  00056	56		 push	 esi
  00057	0f b7 f0	 movzx	 esi, ax
  0005a	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  0005e	0b f0		 or	 esi, eax
  00060	89 75 d0	 mov	 DWORD PTR _iTargetUserIndex$1$[ebp], esi

; 17158: 	//}
; 17159: 
; 17160: 	if ( !OBJMAX_RANGE(aIndex) )

  00063	85 db		 test	 ebx, ebx
  00065	0f 88 20 06 00
	00		 js	 $LN72@CGRelation
  0006b	33 c0		 xor	 eax, eax
  0006d	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00073	0f 9e c0	 setle	 al
  00076	85 c0		 test	 eax, eax
  00078	0f 84 0d 06 00
	00		 je	 $LN72@CGRelation

; 17161: 		return;
; 17162: 
; 17163: 	if ( !PacketCheckTime(&gObj[aIndex]))

  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00083	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  00089	03 c1		 add	 eax, ecx
  0008b	89 4d dc	 mov	 DWORD PTR tv716[ebp], ecx
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00094	83 c4 04	 add	 esp, 4
  00097	85 c0		 test	 eax, eax
  00099	0f 84 ec 05 00
	00		 je	 $LN72@CGRelation

; 17164: 		return;
; 17165: 
; 17166: 	if ( !OBJMAX_RANGE(iTargetUserIndex) || gObjIsConnected(&gObj[iTargetUserIndex]) == FALSE )

  0009f	85 f6		 test	 esi, esi
  000a1	0f 88 d7 05 00
	00		 js	 $LN6@CGRelation
  000a7	33 c0		 xor	 eax, eax
  000a9	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  000af	0f 9e c0	 setle	 al
  000b2	85 c0		 test	 eax, eax
  000b4	0f 84 c4 05 00
	00		 je	 $LN6@CGRelation
  000ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bf	69 f6 40 27 00
	00		 imul	 esi, esi, 10048
  000c5	03 c6		 add	 eax, esi
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000cd	83 c4 04	 add	 esp, 4
  000d0	85 c0		 test	 eax, eax
  000d2	0f 84 a6 05 00
	00		 je	 $LN6@CGRelation

; 17173: 	if( g_NewPVP.IsDuel(gObj[aIndex]) || g_NewPVP.IsDuel(gObj[iTargetUserIndex]) )

  000d8	8b 45 dc	 mov	 eax, DWORD PTR tv716[ebp]
  000db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e1	03 c2		 add	 eax, edx
  000e3	89 45 d4	 mov	 DWORD PTR _obj$1$[ebp], eax
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h

; 297  : 		return CHECK_LIMIT(obj.m_iDuelUser, OBJMAX);

  000e6	8b 88 50 12 00
	00		 mov	 ecx, DWORD PTR [eax+4688]
  000ec	85 c9		 test	 ecx, ecx
  000ee	78 13		 js	 SHORT $LN63@CGRelation
  000f0	33 c0		 xor	 eax, eax
  000f2	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  000f8	0f 9e c0	 setle	 al
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17173: 	if( g_NewPVP.IsDuel(gObj[aIndex]) || g_NewPVP.IsDuel(gObj[iTargetUserIndex]) )

  000fb	85 c0		 test	 eax, eax
  000fd	0f 85 71 05 00
	00		 jne	 $LN8@CGRelation
$LN63@CGRelation:
  00103	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00106	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  00111	85 c0		 test	 eax, eax
  00113	0f 85 5b 05 00
	00		 jne	 $LN8@CGRelation

; 17177: 	}
; 17178: 	// ----
; 17179: 	if( g_NewPVP.IsObserver(gObj[aIndex]) || g_NewPVP.IsObserver(gObj[iTargetUserIndex]) )

  00119	ff 75 d4	 push	 DWORD PTR _obj$1$[ebp]
  0011c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00121	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00126	85 c0		 test	 eax, eax
  00128	0f 85 1a 05 00
	00		 jne	 $LN10@CGRelation
  0012e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00133	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00138	03 c6		 add	 eax, esi
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00140	85 c0		 test	 eax, eax
  00142	0f 85 00 05 00
	00		 jne	 $LN10@CGRelation

; 17182: 		 return;
; 17183: 	}
; 17184: #endif
; 17185: 
; 17186: 	if ( !gObj[aIndex].lpGuild || !gObj[iTargetUserIndex].lpGuild )

  00148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014e	8b 45 dc	 mov	 eax, DWORD PTR tv716[ebp]
  00151	83 bc 08 18 06
	00 00 00	 cmp	 DWORD PTR [eax+ecx+1560], 0
  00159	0f 84 e5 04 00
	00		 je	 $LN12@CGRelation
  0015f	83 bc 0e 18 06
	00 00 00	 cmp	 DWORD PTR [esi+ecx+1560], 0
  00167	0f 84 d7 04 00
	00		 je	 $LN12@CGRelation

; 17190: 	}
; 17191: 
; 17192: 	if ( gObj[aIndex].GuildStatus != G_MASTER && gObj[iTargetUserIndex].GuildStatus != G_MASTER)

  0016d	81 bc 08 28 06
	00 00 80 00 00
	00		 cmp	 DWORD PTR [eax+ecx+1576], 128 ; 00000080H
  00178	74 14		 je	 SHORT $LN13@CGRelation
  0017a	81 bc 0e 28 06
	00 00 80 00 00
	00		 cmp	 DWORD PTR [esi+ecx+1576], 128 ; 00000080H
  00185	74 07		 je	 SHORT $LN13@CGRelation

; 17193: 	{
; 17194: 		GCResultSend(aIndex, 0x51, 4);

  00187	6a 04		 push	 4

; 17195: 		return;

  00189	e9 f2 04 00 00	 jmp	 $LN73@CGRelation
$LN13@CGRelation:

; 17196: 	}
; 17197: 
; 17198: 	if ( gObj[aIndex].m_IfState.use > 0 )

  0018e	f6 84 08 b8 11
	00 00 03	 test	 BYTE PTR [eax+ecx+4536], 3
  00196	76 07		 jbe	 SHORT $LN14@CGRelation
$LN75@CGRelation:

; 17199: 	{
; 17200: 		GCResultSend(aIndex, 0x51, 6);

  00198	6a 06		 push	 6

; 17201: 		return;

  0019a	e9 e1 04 00 00	 jmp	 $LN73@CGRelation
$LN14@CGRelation:

; 17202: 	}
; 17203: 
; 17204: 	if ( gObj[iTargetUserIndex].m_IfState.use > 0 )

  0019f	f6 84 0e b8 11
	00 00 03	 test	 BYTE PTR [esi+ecx+4536], 3
  001a7	77 ef		 ja	 SHORT $LN75@CGRelation

; 17205: 	{
; 17206: 		GCResultSend(aIndex, 0x51, 6);
; 17207: 		return;
; 17208: 	}
; 17209: 
; 17210: 	PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS ErrMsg={0};

  001a9	33 c0		 xor	 eax, eax
  001ab	c6 45 e4 00	 mov	 BYTE PTR _ErrMsg$[ebp], 0

; 17211: 
; 17212: 	PHeadSetB((LPBYTE)&ErrMsg, 0xE6, sizeof(ErrMsg));

  001af	6a 08		 push	 8
  001b1	89 45 e5	 mov	 DWORD PTR _ErrMsg$[ebp+1], eax
  001b4	66 89 45 e9	 mov	 WORD PTR _ErrMsg$[ebp+5], ax
  001b8	88 45 eb	 mov	 BYTE PTR _ErrMsg$[ebp+7], al
  001bb	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  001be	68 e6 00 00 00	 push	 230			; 000000e6H
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17213: 	ErrMsg.btResult = 0;
; 17214: 	ErrMsg.btRequestType = aRecv->btRequestType;

  001c9	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17215: 	ErrMsg.btRelationShipType = aRecv->btRelationShipType;
; 17216: 	ErrMsg.btTargetUserIndexH = aRecv->btTargetUserIndexH;
; 17217: 	ErrMsg.btTargetUserIndexL = aRecv->btTargetUserIndexL;
; 17218: 
; 17219: 	LPOBJ lpObj = &gObj[aIndex];

  001d0	8b 4d dc	 mov	 ecx, DWORD PTR tv716[ebp]
  001d3	8a 57 03	 mov	 dl, BYTE PTR [edi+3]
  001d6	88 45 e8	 mov	 BYTE PTR _ErrMsg$[ebp+4], al
  001d9	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  001dd	88 45 ea	 mov	 BYTE PTR _ErrMsg$[ebp+6], al
  001e0	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  001e4	88 45 eb	 mov	 BYTE PTR _ErrMsg$[ebp+7], al
  001e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ec	03 c8		 add	 ecx, eax
  001ee	89 4d dc	 mov	 DWORD PTR _lpObj$1$[ebp], ecx
  001f1	c6 45 e9 00	 mov	 BYTE PTR _ErrMsg$[ebp+5], 0
  001f5	88 55 e7	 mov	 BYTE PTR _ErrMsg$[ebp+3], dl

; 17220: 	LPOBJ lpTargetObj = &gObj[iTargetUserIndex];

  001f8	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]

; 17221: 
; 17222: 	if ( lpObj->GuildStatus != G_MASTER || lpTargetObj->GuildStatus != G_MASTER)

  001fb	8b 75 dc	 mov	 esi, DWORD PTR _lpObj$1$[ebp]
  001fe	89 4d d4	 mov	 DWORD PTR _lpTargetObj$1$[ebp], ecx
  00201	81 be 28 06 00
	00 80 00 00 00	 cmp	 DWORD PTR [esi+1576], 128 ; 00000080H
  0020b	0f 85 0c 04 00
	00		 jne	 $LN17@CGRelation
  00211	81 b9 28 06 00
	00 80 00 00 00	 cmp	 DWORD PTR [ecx+1576], 128 ; 00000080H
  0021b	0f 85 fc 03 00
	00		 jne	 $LN17@CGRelation

; 17226: 		return;
; 17227: 	}
; 17228: 
; 17229: #if (__GENS_SYSTEM__ == 1)
; 17230: 
; 17231: 	if( gGensSystem.m_CheckForAlliance )

  00221	80 3d 4a 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VCGensSystem@@A+74, 0
  00228	74 65		 je	 SHORT $LN21@CGRelation

; 17232: 	{
; 17233: 		if( aRecv->btRelationShipType != 2 )

  0022a	80 fa 02	 cmp	 dl, 2
  0022d	74 60		 je	 SHORT $LN21@CGRelation

; 17234: 		{
; 17235: 			if ( lpTargetObj->m_GensInfo.btFamily == GENS_NONE )

  0022f	8a 81 ac 26 00
	00		 mov	 al, BYTE PTR [ecx+9900]
  00235	84 c0		 test	 al, al
  00237	75 27		 jne	 SHORT $LN20@CGRelation

; 17236: 			{
; 17237: 				ErrMsg.btResult = GUILD_ANS_ALLYMASTER_NOGENS;
; 17238: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00239	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  0023d	50		 push	 eax
  0023e	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00241	c6 45 e9 a1	 mov	 BYTE PTR _ErrMsg$[ebp+5], 161 ; 000000a1H
  00245	50		 push	 eax
  00246	53		 push	 ebx
  00247	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0024c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0024f	5e		 pop	 esi
  00250	5f		 pop	 edi
  00251	5b		 pop	 ebx

; 17382: }

  00252	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00255	33 cd		 xor	 ecx, ebp
  00257	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025c	8b e5		 mov	 esp, ebp
  0025e	5d		 pop	 ebp
  0025f	c3		 ret	 0
$LN20@CGRelation:

; 17239: 				return;
; 17240: 			}
; 17241: 
; 17242: 			if ( lpObj->m_GensInfo.btFamily != lpTargetObj->m_GensInfo.btFamily )

  00260	38 86 ac 26 00
	00		 cmp	 BYTE PTR [esi+9900], al
  00266	74 27		 je	 SHORT $LN21@CGRelation

; 17243: 			{
; 17244: 				ErrMsg.btResult = GUILD_ANS_DIFFERENT_GENS;
; 17245: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00268	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  0026c	50		 push	 eax
  0026d	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00270	c6 45 e9 a3	 mov	 BYTE PTR _ErrMsg$[ebp+5], 163 ; 000000a3H
  00274	50		 push	 eax
  00275	53		 push	 ebx
  00276	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0027b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027e	5e		 pop	 esi
  0027f	5f		 pop	 edi
  00280	5b		 pop	 ebx

; 17382: }

  00281	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00284	33 cd		 xor	 ecx, ebp
  00286	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028b	8b e5		 mov	 esp, ebp
  0028d	5d		 pop	 ebp
  0028e	c3		 ret	 0
$LN21@CGRelation:

; 17246: 				return;
; 17247: 			}
; 17248: 		}
; 17249: 	}
; 17250: #endif
; 17251: 
; 17252: 	_GUILD_INFO_STRUCT * lpGuildInfo = gObj[aIndex].lpGuild;

  0028f	8b 86 18 06 00
	00		 mov	 eax, DWORD PTR [esi+1560]

; 17253: 	_GUILD_INFO_STRUCT * lpTargetGuildInfo = gObj[iTargetUserIndex].lpGuild;

  00295	8b b1 18 06 00
	00		 mov	 esi, DWORD PTR [ecx+1560]

; 17254: 	BYTE btRelationShip = gObjGetRelationShip(lpObj, lpTargetObj);

  0029b	51		 push	 ecx
  0029c	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$1$[ebp]
  0029f	51		 push	 ecx
  002a0	89 45 e0	 mov	 DWORD PTR _lpGuildInfo$1$[ebp], eax
  002a3	e8 00 00 00 00	 call	 ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGetRelationShip

; 17255: 
; 17256: 	if ( aRecv->btRequestType == 1 )

  002a8	8a 4f 04	 mov	 cl, BYTE PTR [edi+4]
  002ab	83 c4 08	 add	 esp, 8
  002ae	8a f0		 mov	 dh, al
  002b0	88 75 db	 mov	 BYTE PTR _btRelationShip$1$[ebp], dh
  002b3	80 f9 01	 cmp	 cl, 1
  002b6	0f 85 ee 01 00
	00		 jne	 $LN22@CGRelation

; 17257: 	{
; 17258: 		if ( aRecv->btRelationShipType == 1 )

  002bc	8a 4f 03	 mov	 cl, BYTE PTR [edi+3]
  002bf	80 f9 01	 cmp	 cl, 1
  002c2	0f 85 6d 01 00
	00		 jne	 $LN24@CGRelation

; 17259: 		{
; 17260: 			if ( lpTargetGuildInfo->Count < g_CastleMinGuildMember )

  002c8	0f b6 4e 2d	 movzx	 ecx, BYTE PTR [esi+45]
  002cc	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?g_CastleMinGuildMember@@3HA ; g_CastleMinGuildMember
  002d2	7d 27		 jge	 SHORT $LN26@CGRelation

; 17261: 			{
; 17262: 				ErrMsg.btResult = GUILD_ANS_CANNOT_BE_UNION_MASTER;
; 17263: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  002d4	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  002d8	50		 push	 eax
  002d9	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  002dc	c6 45 e9 1d	 mov	 BYTE PTR _ErrMsg$[ebp+5], 29 ; 0000001dH
  002e0	50		 push	 eax
  002e1	53		 push	 ebx
  002e2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ea	5e		 pop	 esi
  002eb	5f		 pop	 edi
  002ec	5b		 pop	 ebx

; 17382: }

  002ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f0	33 cd		 xor	 ecx, ebp
  002f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f7	8b e5		 mov	 esp, ebp
  002f9	5d		 pop	 ebp
  002fa	c3		 ret	 0
$LN26@CGRelation:

; 17264: 				return;
; 17265: 			}
; 17266: 
; 17267: 			if ( lpTargetGuildInfo->iGuildUnion != 0 && lpTargetGuildInfo->iGuildUnion == lpTargetGuildInfo->Number )

  002fb	8b 86 44 07 00
	00		 mov	 eax, DWORD PTR [esi+1860]
  00301	85 c0		 test	 eax, eax
  00303	74 43		 je	 SHORT $LN28@CGRelation
  00305	3b 06		 cmp	 eax, DWORD PTR [esi]
  00307	75 3f		 jne	 SHORT $LN28@CGRelation

; 17268: 			{
; 17269: 				if ( UnionManager.GetGuildRelationShipCount(lpTargetGuildInfo->iGuildUnion, 1) >= g_GuildMaxAllianceMember  )

  00309	6a 01		 push	 1
  0030b	50		 push	 eax
  0030c	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  00311	e8 00 00 00 00	 call	 ?GetGuildRelationShipCount@TUnion@@QAEHHH@Z ; TUnion::GetGuildRelationShipCount
  00316	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_GuildMaxAllianceMember@@3HA ; g_GuildMaxAllianceMember
  0031c	7c 27		 jl	 SHORT $LN71@CGRelation

; 17270: 				{
; 17271: 					ErrMsg.btResult = GUILD_ANS_EXCEED_MAX_UNION_MEMBER;
; 17272: 					DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0031e	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  00322	50		 push	 eax
  00323	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00326	c6 45 e9 1e	 mov	 BYTE PTR _ErrMsg$[ebp+5], 30 ; 0000001eH
  0032a	50		 push	 eax
  0032b	53		 push	 ebx
  0032c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00331	83 c4 0c	 add	 esp, 12			; 0000000cH
  00334	5e		 pop	 esi
  00335	5f		 pop	 edi
  00336	5b		 pop	 ebx

; 17382: }

  00337	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033a	33 cd		 xor	 ecx, ebp
  0033c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00341	8b e5		 mov	 esp, ebp
  00343	5d		 pop	 ebp
  00344	c3		 ret	 0
$LN71@CGRelation:
  00345	8a 75 db	 mov	 dh, BYTE PTR _btRelationShip$1$[ebp]
$LN28@CGRelation:

; 17273: 					return;
; 17274: 				}
; 17275: 			}
; 17276: 		
; 17277: 			char szCastleOwnerGuildName[MAX_GUILD_LEN+1]={0};
; 17278: 			memcpy(szCastleOwnerGuildName, g_CastleSiegeSync.GetCastleOwnerGuild(), MAX_GUILD_LEN);

  00348	a1 18 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+24

; 17279: 
; 17280: 			if ( !strcmp(lpGuildInfo->Name, szCastleOwnerGuildName))

  0034d	8d 4d c4	 lea	 ecx, DWORD PTR _szCastleOwnerGuildName$1[ebp]
  00350	0f 57 c0	 xorps	 xmm0, xmm0
  00353	66 0f d6 45 c5	 movq	 QWORD PTR _szCastleOwnerGuildName$1[ebp+1], xmm0
  00358	89 45 c4	 mov	 DWORD PTR _szCastleOwnerGuildName$1[ebp], eax
  0035b	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A+28
  00360	89 45 c8	 mov	 DWORD PTR _szCastleOwnerGuildName$1[ebp+4], eax
  00363	8b 45 e0	 mov	 eax, DWORD PTR _lpGuildInfo$1$[ebp]
  00366	83 c0 04	 add	 eax, 4
  00369	0f 1f 80 00 00
	00 00		 npad	 7
$LL64@CGRelation:
  00370	8a 10		 mov	 dl, BYTE PTR [eax]
  00372	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00374	75 1a		 jne	 SHORT $LN65@CGRelation
  00376	84 d2		 test	 dl, dl
  00378	74 12		 je	 SHORT $LN66@CGRelation
  0037a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0037d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00380	75 0e		 jne	 SHORT $LN65@CGRelation
  00382	83 c0 02	 add	 eax, 2
  00385	83 c1 02	 add	 ecx, 2
  00388	84 d2		 test	 dl, dl
  0038a	75 e4		 jne	 SHORT $LL64@CGRelation
$LN66@CGRelation:
  0038c	33 c0		 xor	 eax, eax
  0038e	eb 05		 jmp	 SHORT $LN67@CGRelation
$LN65@CGRelation:
  00390	1b c0		 sbb	 eax, eax
  00392	83 c8 01	 or	 eax, 1
$LN67@CGRelation:
  00395	85 c0		 test	 eax, eax
  00397	75 27		 jne	 SHORT $LN29@CGRelation
$LN76@CGRelation:

; 17281: 			{
; 17282: 				ErrMsg.btResult = GUILD_ANS_EXIST_UNION;
; 17283: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00399	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  0039d	50		 push	 eax
  0039e	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  003a1	c6 45 e9 17	 mov	 BYTE PTR _ErrMsg$[ebp+5], 23 ; 00000017H
  003a5	50		 push	 eax
  003a6	53		 push	 ebx
  003a7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  003af	5e		 pop	 esi
  003b0	5f		 pop	 edi
  003b1	5b		 pop	 ebx

; 17382: }

  003b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b5	33 cd		 xor	 ecx, ebp
  003b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003bc	8b e5		 mov	 esp, ebp
  003be	5d		 pop	 ebp
  003bf	c3		 ret	 0
$LN29@CGRelation:

; 17284: 				return;
; 17285: 			}
; 17286: 
; 17287: 			if ( lpGuildInfo->iGuildUnion )

  003c0	8b 45 e0	 mov	 eax, DWORD PTR _lpGuildInfo$1$[ebp]
  003c3	83 b8 44 07 00
	00 00		 cmp	 DWORD PTR [eax+1860], 0
  003ca	75 cd		 jne	 SHORT $LN76@CGRelation

; 17288: 			{
; 17289: 				ErrMsg.btResult = GUILD_ANS_EXIST_UNION;
; 17290: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17291: 				return;
; 17292: 			}
; 17293: 
; 17294: 			if ( btRelationShip == 2 )

  003cc	80 fe 02	 cmp	 dh, 2
  003cf	75 27		 jne	 SHORT $LN31@CGRelation

; 17295: 			{
; 17296: 				ErrMsg.btResult = GUILD_ANS_EXIST_RELATIONSHIP_RIVAL;
; 17297: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  003d1	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  003d5	50		 push	 eax
  003d6	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  003d9	c6 45 e9 16	 mov	 BYTE PTR _ErrMsg$[ebp+5], 22 ; 00000016H
  003dd	50		 push	 eax
  003de	53		 push	 ebx
  003df	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e7	5e		 pop	 esi
  003e8	5f		 pop	 edi
  003e9	5b		 pop	 ebx

; 17382: }

  003ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ed	33 cd		 xor	 ecx, ebp
  003ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f4	8b e5		 mov	 esp, ebp
  003f6	5d		 pop	 ebp
  003f7	c3		 ret	 0
$LN31@CGRelation:

; 17298: 				return;
; 17299: 			}
; 17300: 
; 17301: 			if ( lpTargetGuildInfo->iGuildUnion && lpTargetGuildInfo->Number != lpTargetGuildInfo->iGuildUnion )

  003f8	8b 8e 44 07 00
	00		 mov	 ecx, DWORD PTR [esi+1860]
  003fe	85 c9		 test	 ecx, ecx
  00400	0f 84 34 01 00
	00		 je	 $LN44@CGRelation
  00406	39 0e		 cmp	 DWORD PTR [esi], ecx
  00408	0f 84 2c 01 00
	00		 je	 $LN44@CGRelation

; 17302: 			{
; 17303: 				ErrMsg.btResult = GUIDL_ANS_NOT_UNION_MASTER;
; 17304: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0040e	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  00412	50		 push	 eax
  00413	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00416	c6 45 e9 1b	 mov	 BYTE PTR _ErrMsg$[ebp+5], 27 ; 0000001bH
  0041a	50		 push	 eax
  0041b	53		 push	 ebx
  0041c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00421	83 c4 0c	 add	 esp, 12			; 0000000cH
  00424	5e		 pop	 esi
  00425	5f		 pop	 edi
  00426	5b		 pop	 ebx

; 17382: }

  00427	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0042a	33 cd		 xor	 ecx, ebp
  0042c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00431	8b e5		 mov	 esp, ebp
  00433	5d		 pop	 ebp
  00434	c3		 ret	 0
$LN24@CGRelation:

; 17305: 				return;
; 17306: 			}
; 17307: 		}
; 17308: 		else if ( aRecv->btRelationShipType == 2 )
; 17309: 		{
; 17310: 			if ( lpGuildInfo->iGuildRival || lpTargetGuildInfo->iGuildRival )

  00435	8b 45 e0	 mov	 eax, DWORD PTR _lpGuildInfo$1$[ebp]
  00438	80 f9 02	 cmp	 cl, 2
  0043b	0f 85 f9 00 00
	00		 jne	 $LN44@CGRelation
  00441	83 b8 48 07 00
	00 00		 cmp	 DWORD PTR [eax+1864], 0
  00448	75 39		 jne	 SHORT $LN35@CGRelation
  0044a	83 be 48 07 00
	00 00		 cmp	 DWORD PTR [esi+1864], 0
  00451	75 30		 jne	 SHORT $LN35@CGRelation

; 17314: 				return;
; 17315: 			}
; 17316: 
; 17317: 			if ( btRelationShip == 1 )

  00453	80 fe 01	 cmp	 dh, 1
  00456	0f 85 de 00 00
	00		 jne	 $LN44@CGRelation

; 17318: 			{
; 17319: 				ErrMsg.btResult = GUILD_ANS_EXIST_RELATIONSHIP_UNION;
; 17320: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0045c	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  00460	50		 push	 eax
  00461	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00464	c6 45 e9 15	 mov	 BYTE PTR _ErrMsg$[ebp+5], 21 ; 00000015H
  00468	50		 push	 eax
  00469	53		 push	 ebx
  0046a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0046f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00472	5e		 pop	 esi
  00473	5f		 pop	 edi
  00474	5b		 pop	 ebx

; 17382: }

  00475	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00478	33 cd		 xor	 ecx, ebp
  0047a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0047f	8b e5		 mov	 esp, ebp
  00481	5d		 pop	 ebp
  00482	c3		 ret	 0
$LN35@CGRelation:

; 17311: 			{
; 17312: 				ErrMsg.btResult = GUILD_ANS_EXIST_RIVAL;
; 17313: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00483	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  00487	50		 push	 eax
  00488	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  0048b	c6 45 e9 18	 mov	 BYTE PTR _ErrMsg$[ebp+5], 24 ; 00000018H
  0048f	50		 push	 eax
  00490	53		 push	 ebx
  00491	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00496	83 c4 0c	 add	 esp, 12			; 0000000cH
  00499	5e		 pop	 esi
  0049a	5f		 pop	 edi
  0049b	5b		 pop	 ebx

; 17382: }

  0049c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0049f	33 cd		 xor	 ecx, ebp
  004a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a6	8b e5		 mov	 esp, ebp
  004a8	5d		 pop	 ebp
  004a9	c3		 ret	 0
$LN22@CGRelation:

; 17321: 				return;
; 17322: 			}
; 17323: 		}
; 17324: 	}
; 17325: 	else if ( aRecv->btRequestType == 2 )

  004aa	80 f9 02	 cmp	 cl, 2
  004ad	0f 85 84 00 00
	00		 jne	 $LN69@CGRelation

; 17326: 	{
; 17327: 		if ( aRecv->btRelationShipType == 1 )

  004b3	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  004b6	3c 01		 cmp	 al, 1
  004b8	75 33		 jne	 SHORT $LN38@CGRelation

; 17328: 		{
; 17329: 			if ( lpGuildInfo->iGuildUnion == 0 )

  004ba	8b 45 e0	 mov	 eax, DWORD PTR _lpGuildInfo$1$[ebp]
  004bd	83 b8 44 07 00
	00 00		 cmp	 DWORD PTR [eax+1860], 0
  004c4	75 74		 jne	 SHORT $LN44@CGRelation
$LN43@CGRelation:

; 17330: 			{
; 17331: 				ErrMsg.btResult = GUILD_ANS_NOTEXIST_UNION;
; 17332: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  004c6	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  004ca	50		 push	 eax
  004cb	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  004ce	c6 45 e9 19	 mov	 BYTE PTR _ErrMsg$[ebp+5], 25 ; 00000019H
  004d2	50		 push	 eax
  004d3	53		 push	 ebx
  004d4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  004dc	5e		 pop	 esi
  004dd	5f		 pop	 edi
  004de	5b		 pop	 ebx

; 17382: }

  004df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004e2	33 cd		 xor	 ecx, ebp
  004e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004e9	8b e5		 mov	 esp, ebp
  004eb	5d		 pop	 ebp
  004ec	c3		 ret	 0
$LN38@CGRelation:

; 17333: 				return;
; 17334: 			}
; 17335: 		}
; 17336: 		else if ( aRecv->btRelationShipType == 2 )

  004ed	3c 02		 cmp	 al, 2

; 17337: 		{
; 17338: 			if ( !lpGuildInfo->iGuildRival || !lpTargetGuildInfo->iGuildRival )

  004ef	8b 45 e0	 mov	 eax, DWORD PTR _lpGuildInfo$1$[ebp]
  004f2	75 46		 jne	 SHORT $LN44@CGRelation
  004f4	8b 88 48 07 00
	00		 mov	 ecx, DWORD PTR [eax+1864]
  004fa	85 c9		 test	 ecx, ecx
  004fc	74 c8		 je	 SHORT $LN43@CGRelation
  004fe	8b 96 48 07 00
	00		 mov	 edx, DWORD PTR [esi+1864]
  00504	85 d2		 test	 edx, edx
  00506	74 be		 je	 SHORT $LN43@CGRelation

; 17339: 			{
; 17340: 				ErrMsg.btResult = GUILD_ANS_NOTEXIST_UNION;
; 17341: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);
; 17342: 				return;
; 17343: 			}
; 17344: 
; 17345: 			if ( lpGuildInfo->iGuildRival != lpTargetGuildInfo->Number || lpGuildInfo->Number != lpTargetGuildInfo->iGuildRival )

  00508	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  0050a	75 04		 jne	 SHORT $LN45@CGRelation
  0050c	39 10		 cmp	 DWORD PTR [eax], edx
  0050e	74 2a		 je	 SHORT $LN44@CGRelation
$LN45@CGRelation:

; 17346: 			{
; 17347: 				ErrMsg.btResult = GUILD_ANS_NOT_GUILD_RIVAL;
; 17348: 				DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  00510	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  00514	50		 push	 eax
  00515	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00518	c6 45 e9 1c	 mov	 BYTE PTR _ErrMsg$[ebp+5], 28 ; 0000001cH
  0051c	50		 push	 eax
  0051d	53		 push	 ebx
  0051e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00523	83 c4 0c	 add	 esp, 12			; 0000000cH
  00526	5e		 pop	 esi
  00527	5f		 pop	 edi
  00528	5b		 pop	 ebx

; 17382: }

  00529	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0052c	33 cd		 xor	 ecx, ebp
  0052e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00533	8b e5		 mov	 esp, ebp
  00535	5d		 pop	 ebp
  00536	c3		 ret	 0
$LN69@CGRelation:
  00537	8b 45 e0	 mov	 eax, DWORD PTR _lpGuildInfo$1$[ebp]
$LN44@CGRelation:

; 17349: 				return;
; 17350: 			}
; 17351: 		}
; 17352: 	}		
; 17353: 	
; 17354: 	if ( aRecv->btRequestType == 2 )

  0053a	80 7f 04 02	 cmp	 BYTE PTR [edi+4], 2
  0053e	75 26		 jne	 SHORT $LN47@CGRelation

; 17355: 	{
; 17356: 		if ( aRecv->btRelationShipType == 1 )

  00540	80 7f 03 01	 cmp	 BYTE PTR [edi+3], 1
  00544	75 20		 jne	 SHORT $LN47@CGRelation

; 17357: 		{
; 17358: 			GDUnionBreakOff(aIndex, lpGuildInfo->iGuildUnion);

  00546	ff b0 44 07 00
	00		 push	 DWORD PTR [eax+1860]
  0054c	53		 push	 ebx
  0054d	e8 00 00 00 00	 call	 ?GDUnionBreakOff@@YAXHH@Z ; GDUnionBreakOff
  00552	83 c4 08	 add	 esp, 8
  00555	5e		 pop	 esi
  00556	5f		 pop	 edi
  00557	5b		 pop	 ebx

; 17382: }

  00558	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0055b	33 cd		 xor	 ecx, ebp
  0055d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00562	8b e5		 mov	 esp, ebp
  00564	5d		 pop	 ebp
  00565	c3		 ret	 0
$LN47@CGRelation:

; 17359: 			return;
; 17360: 		}
; 17361: 	}
; 17362: 
; 17363: 	lpObj->m_IfState.use = 1;
; 17364: 	lpObj->m_IfState.type = 14;
; 17365: 	lpObj->m_IfState.state = 0;

  00566	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$1$[ebp]

; 17366: 	lpObj->m_InterfaceTime = GetTickCount();

  00569	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  0056f	8b 81 b8 11 00
	00		 mov	 eax, DWORD PTR [ecx+4536]
  00575	25 81 03 ff ff	 and	 eax, -64639		; ffff0381H
  0057a	0d 81 03 00 00	 or	 eax, 897		; 00000381H
  0057f	89 81 b8 11 00
	00		 mov	 DWORD PTR [ecx+4536], eax
  00585	ff d6		 call	 esi
  00587	8b 4d dc	 mov	 ecx, DWORD PTR _lpObj$1$[ebp]
  0058a	89 81 bc 11 00
	00		 mov	 DWORD PTR [ecx+4540], eax

; 17367: 
; 17368: 	lpTargetObj->m_IfState.use = 1;
; 17369: 	lpTargetObj->m_IfState.type = 14;
; 17370: 	lpTargetObj->m_IfState.state = 0;

  00590	8b 4d d4	 mov	 ecx, DWORD PTR _lpTargetObj$1$[ebp]
  00593	8b 81 b8 11 00
	00		 mov	 eax, DWORD PTR [ecx+4536]
  00599	25 81 03 ff ff	 and	 eax, -64639		; ffff0381H
  0059e	0d 81 03 00 00	 or	 eax, 897		; 00000381H
  005a3	89 81 b8 11 00
	00		 mov	 DWORD PTR [ecx+4536], eax

; 17371: 	lpTargetObj->m_InterfaceTime = GetTickCount();

  005a9	ff d6		 call	 esi
  005ab	8b 4d d4	 mov	 ecx, DWORD PTR _lpTargetObj$1$[ebp]
  005ae	0f 57 c0	 xorps	 xmm0, xmm0

; 17372: 
; 17373: 	PMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ pMsg={0};
; 17374: 
; 17375: 	PHeadSetB((LPBYTE)&pMsg, 0xE5, sizeof(pMsg));

  005b1	6a 10		 push	 16			; 00000010H
  005b3	68 e5 00 00 00	 push	 229			; 000000e5H
  005b8	89 81 bc 11 00
	00		 mov	 DWORD PTR [ecx+4540], eax
  005be	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  005c1	50		 push	 eax
  005c2	c6 45 ec 00	 mov	 BYTE PTR _pMsg$[ebp], 0
  005c6	66 0f d6 45 ed	 movq	 QWORD PTR _pMsg$[ebp+1], xmm0
  005cb	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+9], 0
  005d2	66 c7 45 f9 00
	00		 mov	 WORD PTR _pMsg$[ebp+13], 0
  005d8	c6 45 fb 00	 mov	 BYTE PTR _pMsg$[ebp+15], 0
  005dc	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 17376: 	pMsg.btTargetUserIndexL = SET_NUMBERL(aIndex);
; 17377: 	pMsg.btTargetUserIndexH = SET_NUMBERH(aIndex);
; 17378: 	pMsg.btRequestType = aRecv->btRequestType;

  005e1	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  005e5	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 17379: 	pMsg.btRelationShipType = aRecv->btRelationShipType;

  005e8	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  005ec	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 17380: 	
; 17381: 	DataSend(iTargetUserIndex, (LPBYTE)&pMsg, pMsg.h.size);

  005ef	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  005f3	50		 push	 eax
  005f4	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  005f7	88 5d f2	 mov	 BYTE PTR _pMsg$[ebp+6], bl
  005fa	50		 push	 eax
  005fb	ff 75 d0	 push	 DWORD PTR _iTargetUserIndex$1$[ebp]
  005fe	c1 eb 08	 shr	 ebx, 8
  00601	88 5d f1	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  00604	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00609	83 c4 18	 add	 esp, 24			; 00000018H
  0060c	5e		 pop	 esi
  0060d	5f		 pop	 edi
  0060e	5b		 pop	 ebx

; 17382: }

  0060f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00612	33 cd		 xor	 ecx, ebp
  00614	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00619	8b e5		 mov	 esp, ebp
  0061b	5d		 pop	 ebp
  0061c	c3		 ret	 0
$LN17@CGRelation:

; 17223: 	{
; 17224: 		ErrMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 17225: 		DataSend(aIndex, (LPBYTE)&ErrMsg, ErrMsg.h.size);

  0061d	0f b6 45 e5	 movzx	 eax, BYTE PTR _ErrMsg$[ebp+1]
  00621	50		 push	 eax
  00622	8d 45 e4	 lea	 eax, DWORD PTR _ErrMsg$[ebp]
  00625	c6 45 e9 11	 mov	 BYTE PTR _ErrMsg$[ebp+5], 17 ; 00000011H
  00629	50		 push	 eax
  0062a	53		 push	 ebx
  0062b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00630	83 c4 0c	 add	 esp, 12			; 0000000cH
  00633	5e		 pop	 esi
  00634	5f		 pop	 edi
  00635	5b		 pop	 ebx

; 17382: }

  00636	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00639	33 cd		 xor	 ecx, ebp
  0063b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00640	8b e5		 mov	 esp, ebp
  00642	5d		 pop	 ebp
  00643	c3		 ret	 0
$LN12@CGRelation:

; 17187: 	{
; 17188: 		GCResultSend(aIndex, 0x51, 5);

  00644	6a 05		 push	 5

; 17189: 		return;

  00646	eb 38		 jmp	 SHORT $LN73@CGRelation
$LN10@CGRelation:

; 17180: 	{
; 17181: 		 GCServerMsgStringSend(lMsg.Get(3432), aIndex, 1);

  00648	6a 01		 push	 1
  0064a	53		 push	 ebx
  0064b	68 68 0d 00 00	 push	 3432			; 00000d68H
$LN77@CGRelation:
  00650	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00655	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0065a	50		 push	 eax
  0065b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00660	83 c4 0c	 add	 esp, 12			; 0000000cH
  00663	5e		 pop	 esi
  00664	5f		 pop	 edi
  00665	5b		 pop	 ebx

; 17382: }

  00666	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00669	33 cd		 xor	 ecx, ebp
  0066b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00670	8b e5		 mov	 esp, ebp
  00672	5d		 pop	 ebp
  00673	c3		 ret	 0
$LN8@CGRelation:

; 17174: 	{
; 17175: 		 GCServerMsgStringSend(lMsg.Get(3431), aIndex, 1);

  00674	6a 01		 push	 1
  00676	53		 push	 ebx
  00677	68 67 0d 00 00	 push	 3431			; 00000d67H

; 17176: 		 return;

  0067c	eb d2		 jmp	 SHORT $LN77@CGRelation
$LN6@CGRelation:

; 17167: 	{
; 17168: 		GCResultSend(aIndex, 0x51, 3);

  0067e	6a 03		 push	 3
$LN73@CGRelation:
  00680	6a 51		 push	 81			; 00000051H
  00682	53		 push	 ebx
  00683	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00688	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN72@CGRelation:

; 17382: }

  0068b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0068e	5e		 pop	 esi
  0068f	5f		 pop	 edi
  00690	33 cd		 xor	 ecx, ebp
  00692	5b		 pop	 ebx
  00693	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00698	8b e5		 mov	 esp, ebp
  0069a	5d		 pop	 ebp
  0069b	c3		 ret	 0
?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z ENDP ; CGRelationShipReqJoinBreakOff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z PROC ; CGGuildAssignType, COMDAT

; 17084: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 17085: 	if ( !gObjIsConnectedGP(aIndex))

  00007	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	75 1d		 jne	 SHORT $LN2@CGGuildAss

; 17086: 	{
; 17087: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00017	68 bf 42 00 00	 push	 17087			; 000042bfH
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 17101: 	{
; 17102: 		pMsg.btResult = GUILD_ANS_NOTEXIST_GUILD;
; 17103: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	5e		 pop	 esi

; 17115: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN2@CGGuildAss:

; 17088: 		return;
; 17089: 	}
; 17090: 
; 17091: 	if ( !OBJMAX_RANGE(aIndex))

  00034	85 f6		 test	 esi, esi
  00036	0f 88 94 00 00
	00		 js	 $LN1@CGGuildAss
  0003c	33 c0		 xor	 eax, eax
  0003e	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00044	0f 9e c0	 setle	 al
  00047	85 c0		 test	 eax, eax
  00049	0f 84 81 00 00
	00		 je	 $LN1@CGGuildAss

; 17098: 	pMsg.btGuildType = aRecv->btGuildType;

  0004f	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00052	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00058	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+1], 0
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  0005f	66 c7 45 f8 c1
	05		 mov	 WORD PTR _pMsg$[ebp], 1473 ; 000005c1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17098: 	pMsg.btGuildType = aRecv->btGuildType;

  00065	8a 40 03	 mov	 al, BYTE PTR [eax+3]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 88   : 		lpBuf[2] = head;

  00068	c6 45 fa e2	 mov	 BYTE PTR _pMsg$[ebp+2], 226 ; 000000e2H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 17094: 	LPOBJ lpObj = &gObj[aIndex];

  0006c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 17098: 	pMsg.btGuildType = aRecv->btGuildType;

  00072	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 17099: 	
; 17100: 	if ( lpObj->GuildNumber <= 0 || lpObj->lpGuild == NULL )

  00075	83 b9 14 06 00
	00 00		 cmp	 DWORD PTR [ecx+1556], 0
  0007c	7e 3f		 jle	 SHORT $LN5@CGGuildAss
  0007e	83 b9 18 06 00
	00 00		 cmp	 DWORD PTR [ecx+1560], 0
  00085	74 36		 je	 SHORT $LN5@CGGuildAss

; 17104: 		return;
; 17105: 	}
; 17106: 
; 17107: 	if ( gObj[aIndex].GuildStatus != G_MASTER )

  00087	81 b9 28 06 00
	00 80 00 00 00	 cmp	 DWORD PTR [ecx+1576], 128 ; 00000080H
  00091	74 18		 je	 SHORT $LN6@CGGuildAss

; 17101: 	{
; 17102: 		pMsg.btResult = GUILD_ANS_NOTEXIST_GUILD;
; 17103: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00093	6a 05		 push	 5
  00095	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]

; 17108: 	{
; 17109: 		pMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;

  00098	c6 45 fc 11	 mov	 BYTE PTR _pMsg$[ebp+4], 17 ; 00000011H
  0009c	50		 push	 eax
  0009d	56		 push	 esi
  0009e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	5e		 pop	 esi

; 17115: }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
$LN6@CGGuildAss:

; 17110: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 17111: 		return;
; 17112: 	}
; 17113: 	
; 17114: 	GDGuildReqAssignType(aIndex, aRecv->btGuildType);

  000ab	0f b6 c0	 movzx	 eax, al
  000ae	50		 push	 eax
  000af	56		 push	 esi
  000b0	e8 00 00 00 00	 call	 ?GDGuildReqAssignType@@YAXHH@Z ; GDGuildReqAssignType
  000b5	83 c4 08	 add	 esp, 8
  000b8	5e		 pop	 esi

; 17115: }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
$LN5@CGGuildAss:

; 17101: 	{
; 17102: 		pMsg.btResult = GUILD_ANS_NOTEXIST_GUILD;
; 17103: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  000bd	6a 05		 push	 5
  000bf	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000c2	c6 45 fc 10	 mov	 BYTE PTR _pMsg$[ebp+4], 16 ; 00000010H
  000c6	50		 push	 eax
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGGuildAss:
  000d0	5e		 pop	 esi

; 17115: }

  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z ENDP ; CGGuildAssignType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z
_TEXT	SEGMENT
_szTargetName$ = -48					; size = 11
_lpObj$1$ = -36						; size = 4
_aRecv$GSCopy$1$ = -32					; size = 4
$T1 = -28						; size = 4
tv404 = -21						; size = 1
_pMsg$ = -20						; size = 15
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z PROC ; CGGuildAssignStatus, COMDAT

; 16965: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 16966: 	if ( !gObjIsConnectedGP(aIndex))

  00018	56		 push	 esi
  00019	89 7d e0	 mov	 DWORD PTR _aRecv$GSCopy$1$[ebp], edi
  0001c	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	75 28		 jne	 SHORT $LN5@CGGuildAss

; 16967: 	{
; 16968: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00028	68 48 42 00 00	 push	 16968			; 00004248H
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 17077: 	}
; 17078: }

  00042	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00045	33 cd		 xor	 ecx, ebp
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN5@CGGuildAss:

; 16969: 		return;
; 16970: 	}
; 16971: 
; 16972: 	if ( !OBJMAX_RANGE(aIndex))

  00050	85 f6		 test	 esi, esi
  00052	0f 88 f2 01 00
	00		 js	 $LN26@CGGuildAss
  00058	33 c0		 xor	 eax, eax
  0005a	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00060	0f 9e c0	 setle	 al
  00063	85 c0		 test	 eax, eax
  00065	0f 84 df 01 00
	00		 je	 $LN26@CGGuildAss

; 16980: 	memcpy(pMsg.szTagetName, aRecv->szTagetName, sizeof(pMsg.szTagetName));

  0006b	66 8b 47 0d	 mov	 ax, WORD PTR [edi+13]
  0006f	0f 57 c0	 xorps	 xmm0, xmm0
  00072	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  00078	53		 push	 ebx
  00079	8a 5f 03	 mov	 bl, BYTE PTR [edi+3]
  0007c	83 c7 05	 add	 edi, 5
  0007f	66 0f d6 45 ed	 movq	 QWORD PTR _pMsg$[ebp+1], xmm0
  00084	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp+9], 0
  0008b	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00091	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00095	66 c7 45 f9 00
	00		 mov	 WORD PTR _pMsg$[ebp+13], 0
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  0009b	66 c7 45 ec c1
	0f		 mov	 WORD PTR _pMsg$[ebp], 4033 ; 00000fc1H

; 87   : 		lpBuf[1] = size;
; 88   : 		lpBuf[2] = head;

  000a1	c6 45 ee e1	 mov	 BYTE PTR _pMsg$[ebp+2], 225 ; 000000e1H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 16979: 	pMsg.btType = aRecv->btType;

  000a5	88 5d ef	 mov	 BYTE PTR _pMsg$[ebp+3], bl

; 16980: 	memcpy(pMsg.szTagetName, aRecv->szTagetName, sizeof(pMsg.szTagetName));

  000a8	66 0f d6 45 f1	 movq	 QWORD PTR _pMsg$[ebp+5], xmm0
  000ad	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+13], ax

; 16981: 
; 16982: #if (ENABLETEST_ARCA == 1)
; 16983: 	int iArcaBattleState = g_ArcaBattle.GetState();
; 16984: 	if( iArcaBattleState > AB_STATE_CLOSED && iArcaBattleState < AB_STATE_CLOSE )
; 16985: 	{
; 16986: 		pMsg.btResult = 33;	//Define me
; 16987:         DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 16988: 		return;
; 16989: 	}
; 16990: #endif
; 16991: 
; 16992: 	if ( lpObj->GuildNumber <= 0 || lpObj->lpGuild == NULL )

  000b1	83 ba 14 06 00
	00 00		 cmp	 DWORD PTR [edx+1556], 0
  000b8	89 55 dc	 mov	 DWORD PTR _lpObj$1$[ebp], edx
  000bb	88 5d eb	 mov	 BYTE PTR tv404[ebp], bl
  000be	0f 8e 72 01 00
	00		 jle	 $LN8@CGGuildAss
  000c4	8b 82 18 06 00
	00		 mov	 eax, DWORD PTR [edx+1560]
  000ca	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  000cd	85 c0		 test	 eax, eax
  000cf	0f 84 61 01 00
	00		 je	 $LN8@CGGuildAss

; 16996: 		return;
; 16997: 	}
; 16998: 
; 16999: 	if ( gObj[aIndex].GuildStatus != G_MASTER )

  000d5	81 ba 28 06 00
	00 80 00 00 00	 cmp	 DWORD PTR [edx+1576], 128 ; 00000080H
  000df	74 09		 je	 SHORT $LN9@CGGuildAss
$LN43@CGGuildAss:

; 17000: 	{
; 17001: 		pMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;

  000e1	c6 45 f0 11	 mov	 BYTE PTR _pMsg$[ebp+4], 17 ; 00000011H

; 17002: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 17003: 		return;

  000e5	e9 50 01 00 00	 jmp	 $LN42@CGGuildAss
$LN9@CGGuildAss:

; 17004: 	}
; 17005: 
; 17006: 	char szTargetName[MAX_ACCOUNT_LEN+1]={0};
; 17007: 	memcpy(szTargetName, aRecv->szTagetName, MAX_ACCOUNT_LEN);

  000ea	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]

; 17008: 
; 17009: 	if ( !strcmp(gObj[aIndex].Name, szTargetName))

  000ee	8d 4d d0	 lea	 ecx, DWORD PTR _szTargetName$[ebp]
  000f1	0f 57 c0	 xorps	 xmm0, xmm0
  000f4	66 c7 45 d9 00
	00		 mov	 WORD PTR _szTargetName$[ebp+9], 0
  000fa	66 0f d6 45 d1	 movq	 QWORD PTR _szTargetName$[ebp+1], xmm0
  000ff	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  00103	66 89 45 d8	 mov	 WORD PTR _szTargetName$[ebp+8], ax
  00107	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  0010a	66 0f d6 45 d0	 movq	 QWORD PTR _szTargetName$[ebp], xmm0
  0010f	90		 npad	 1
$LL36@CGGuildAss:
  00110	8a 10		 mov	 dl, BYTE PTR [eax]
  00112	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00114	75 1a		 jne	 SHORT $LN37@CGGuildAss
  00116	84 d2		 test	 dl, dl
  00118	74 12		 je	 SHORT $LN38@CGGuildAss
  0011a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0011d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00120	75 0e		 jne	 SHORT $LN37@CGGuildAss
  00122	83 c0 02	 add	 eax, 2
  00125	83 c1 02	 add	 ecx, 2
  00128	84 d2		 test	 dl, dl
  0012a	75 e4		 jne	 SHORT $LL36@CGGuildAss
$LN38@CGGuildAss:
  0012c	33 c0		 xor	 eax, eax
  0012e	eb 05		 jmp	 SHORT $LN39@CGGuildAss
$LN37@CGGuildAss:
  00130	1b c0		 sbb	 eax, eax
  00132	83 c8 01	 or	 eax, 1
$LN39@CGGuildAss:
  00135	85 c0		 test	 eax, eax
  00137	74 a8		 je	 SHORT $LN43@CGGuildAss

; 17010: 	{
; 17011: 		pMsg.btResult = GUILD_ANS_NOTEXIST_PERMISSION;
; 17012: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 17013: 		return;
; 17014: 	}
; 17015: 
; 17016: 	if ( lpObj->lpGuild == NULL )
; 17017: 		return;
; 17018: 
; 17019: 	if ( aRecv->btType == 1 || aRecv->btType == 2 )

  00139	80 fb 01	 cmp	 bl, 1
  0013c	74 33		 je	 SHORT $LN13@CGGuildAss
  0013e	80 fb 02	 cmp	 bl, 2
  00141	74 2e		 je	 SHORT $LN13@CGGuildAss

; 17066: 			return;
; 17067: 		}
; 17068: 		else
; 17069: 		{
; 17070: 			return;
; 17071: 		}
; 17072: 	}
; 17073: 	
; 17074: 	if ( aRecv->btType == 3 )

  00143	80 fb 03	 cmp	 bl, 3
  00146	0f 85 fd 00 00
	00		 jne	 $LN41@CGGuildAss

; 17075: 	{
; 17076: 		GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  0014c	8b 4d e0	 mov	 ecx, DWORD PTR _aRecv$GSCopy$1$[ebp]
  0014f	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00153	50		 push	 eax
  00154	57		 push	 edi
  00155	6a 03		 push	 3
  00157	56		 push	 esi
  00158	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  0015d	83 c4 10	 add	 esp, 16			; 00000010H
  00160	5b		 pop	 ebx
  00161	5f		 pop	 edi
  00162	5e		 pop	 esi

; 17077: 	}
; 17078: }

  00163	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00166	33 cd		 xor	 ecx, ebp
  00168	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
$LN13@CGGuildAss:

; 17020: 	{
; 17021: 		int iSubMasterCount = 0;

  00171	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  00174	33 ff		 xor	 edi, edi

; 17022: 		int iBattleMasterCount = 0;

  00176	33 db		 xor	 ebx, ebx

; 17023: 
; 17024: 		for ( int n=0;n<MAX_USER_GUILD;n++)

  00178	33 c0		 xor	 eax, eax
  0017a	8d 91 00 06 00
	00		 lea	 edx, DWORD PTR [ecx+1536]
$LL4@CGGuildAss:

; 17025: 		{
; 17026: 			if ( lpObj->lpGuild->Use[n] > 0 )

  00180	80 bc 01 40 04
	00 00 00	 cmp	 BYTE PTR [ecx+eax+1088], 0
  00188	76 13		 jbe	 SHORT $LN2@CGGuildAss

; 17027: 			{
; 17028: 				if ( lpObj->lpGuild->GuildStatus[n] == G_SUB_MASTER )

  0018a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0018c	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0018f	75 03		 jne	 SHORT $LN15@CGGuildAss

; 17029: 				{
; 17030: 					iSubMasterCount++;

  00191	47		 inc	 edi
  00192	eb 06		 jmp	 SHORT $LN40@CGGuildAss
$LN15@CGGuildAss:

; 17031: 				}
; 17032: 				else if ( lpObj->lpGuild->GuildStatus[n] == G_BATTLE_MASTER )

  00194	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00197	75 01		 jne	 SHORT $LN40@CGGuildAss

; 17033: 				{
; 17034: 					iBattleMasterCount++;

  00199	43		 inc	 ebx
$LN40@CGGuildAss:
  0019a	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
$LN2@CGGuildAss:

; 17023: 
; 17024: 		for ( int n=0;n<MAX_USER_GUILD;n++)

  0019d	40		 inc	 eax
  0019e	83 c2 04	 add	 edx, 4
  001a1	83 f8 50	 cmp	 eax, 80			; 00000050H
  001a4	7c da		 jl	 SHORT $LL4@CGGuildAss

; 17035: 				}
; 17036: 			}
; 17037: 		}
; 17038: 
; 17039: 		if ( aRecv->btGuildStatus == G_SUB_MASTER )

  001a6	8b 4d e0	 mov	 ecx, DWORD PTR _aRecv$GSCopy$1$[ebp]
  001a9	8a 41 04	 mov	 al, BYTE PTR [ecx+4]
  001ac	3c 40		 cmp	 al, 64			; 00000040H
  001ae	75 11		 jne	 SHORT $LN18@CGGuildAss

; 17040: 		{
; 17041: 			if ( iSubMasterCount == 0 )

  001b0	85 ff		 test	 edi, edi
  001b2	75 04		 jne	 SHORT $LN20@CGGuildAss

; 17042: 			{
; 17043: 				GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  001b4	6a 40		 push	 64			; 00000040H

; 17044: 				return;

  001b6	eb 5b		 jmp	 SHORT $LN44@CGGuildAss
$LN20@CGGuildAss:

; 17045: 			}
; 17046: 
; 17047: 			pMsg.btResult = GUILD_ANS_NOTEXIST_EXTRA_STATUS;

  001b8	c6 45 f0 12	 mov	 BYTE PTR _pMsg$[ebp+4], 18 ; 00000012H

; 17048: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 17049: 			return;

  001bc	e9 79 00 00 00	 jmp	 $LN42@CGGuildAss
$LN18@CGGuildAss:

; 17050: 		}
; 17051: 		else if ( aRecv->btGuildStatus == G_BATTLE_MASTER )

  001c1	3c 20		 cmp	 al, 32			; 00000020H
  001c3	75 48		 jne	 SHORT $LN21@CGGuildAss

; 17052: 		{
; 17053: 			if ( iBattleMasterCount < ((lpObj->Level / 200 ) +1) )

  001c5	8b 45 dc	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  001c8	0f bf 88 96 00
	00 00		 movsx	 ecx, WORD PTR [eax+150]
  001cf	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  001d4	f7 e9		 imul	 ecx
  001d6	c1 fa 06	 sar	 edx, 6
  001d9	8b c2		 mov	 eax, edx
  001db	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001de	40		 inc	 eax
  001df	03 c2		 add	 eax, edx
  001e1	3b d8		 cmp	 ebx, eax
  001e3	7d d3		 jge	 SHORT $LN20@CGGuildAss

; 17054: 			{
; 17055: 				GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  001e5	8b 45 e0	 mov	 eax, DWORD PTR _aRecv$GSCopy$1$[ebp]
  001e8	6a 20		 push	 32			; 00000020H
  001ea	83 c0 05	 add	 eax, 5
  001ed	50		 push	 eax
  001ee	0f b6 45 eb	 movzx	 eax, BYTE PTR tv404[ebp]
  001f2	50		 push	 eax
  001f3	56		 push	 esi
  001f4	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  001f9	83 c4 10	 add	 esp, 16			; 00000010H
  001fc	5b		 pop	 ebx
  001fd	5f		 pop	 edi
  001fe	5e		 pop	 esi

; 17077: 	}
; 17078: }

  001ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00202	33 cd		 xor	 ecx, ebp
  00204	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c3		 ret	 0
$LN21@CGGuildAss:

; 17056: 				return;
; 17057: 			}
; 17058: 
; 17059: 			pMsg.btResult = GUILD_ANS_NOTEXIST_EXTRA_STATUS;
; 17060: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 17061: 			return;
; 17062: 		}
; 17063: 		else if ( aRecv->btGuildStatus == G_PERSON )

  0020d	84 c0		 test	 al, al
  0020f	75 38		 jne	 SHORT $LN41@CGGuildAss

; 17064: 		{
; 17065: 			GDGuildReqAssignStatus(aIndex, aRecv->btType, aRecv->szTagetName, aRecv->btGuildStatus);

  00211	6a 00		 push	 0
$LN44@CGGuildAss:
  00213	8d 41 05	 lea	 eax, DWORD PTR [ecx+5]
  00216	50		 push	 eax
  00217	0f b6 45 eb	 movzx	 eax, BYTE PTR tv404[ebp]
  0021b	50		 push	 eax
  0021c	56		 push	 esi
  0021d	e8 00 00 00 00	 call	 ?GDGuildReqAssignStatus@@YAXHHPADH@Z ; GDGuildReqAssignStatus
  00222	83 c4 10	 add	 esp, 16			; 00000010H
  00225	5b		 pop	 ebx
  00226	5f		 pop	 edi
  00227	5e		 pop	 esi

; 17077: 	}
; 17078: }

  00228	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022b	33 cd		 xor	 ecx, ebp
  0022d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00232	8b e5		 mov	 esp, ebp
  00234	5d		 pop	 ebp
  00235	c3		 ret	 0
$LN8@CGGuildAss:

; 16993: 	{
; 16994: 		pMsg.btResult = GUILD_ANS_NOTEXIST_GUILD;

  00236	c6 45 f0 10	 mov	 BYTE PTR _pMsg$[ebp+4], 16 ; 00000010H
$LN42@CGGuildAss:

; 16995: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0023a	6a 0f		 push	 15			; 0000000fH
  0023c	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0023f	50		 push	 eax
  00240	56		 push	 esi
  00241	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00246	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@CGGuildAss:
  00249	5b		 pop	 ebx
$LN26@CGGuildAss:

; 17077: 	}
; 17078: }

  0024a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024d	5f		 pop	 edi
  0024e	33 cd		 xor	 ecx, ebp
  00250	5e		 pop	 esi
  00251	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00256	8b e5		 mov	 esp, ebp
  00258	5d		 pop	 ebp
  00259	c3		 ret	 0
?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z ENDP ; CGGuildAssignStatus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z
_TEXT	SEGMENT
_dwGuildNumber$1$ = -68					; size = 4
_pMsg$1 = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z PROC ; GCGuildViewportInfo, COMDAT

; 16915: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 16916: 	if ( !gObjIsConnectedGP(aIndex))

  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	75 28		 jne	 SHORT $LN2@GCGuildVie

; 16917: 	{
; 16918: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00025	68 16 42 00 00	 push	 16918			; 00004216H
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 16954: 			lpObj->Name, dwGuildNumber);
; 16955: 	}
; 16956: }

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN2@GCGuildVie:

; 16919: 		return;
; 16920: 	}
; 16921: 
; 16922: 	if ( !OBJMAX_RANGE(aIndex))

  0004d	85 f6		 test	 esi, esi
  0004f	0f 88 d4 00 00
	00		 js	 $LN5@GCGuildVie
  00055	33 c0		 xor	 eax, eax
  00057	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0005d	0f 9e c0	 setle	 al
  00060	85 c0		 test	 eax, eax
  00062	0f 84 c1 00 00
	00		 je	 $LN5@GCGuildVie

; 16923: 		return;
; 16924: 
; 16925: 	LPOBJ lpObj = &gObj[aIndex];
; 16926: 	DWORD dwGuildNumber = aRecv->GuildNumber;

  00068	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 16927: 	_GUILD_INFO_STRUCT * lpGuildInfo = Guild.SearchGuild_Number(dwGuildNumber);

  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00070	53		 push	 ebx
  00071	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00077	50		 push	 eax
  00078	89 45 bc	 mov	 DWORD PTR _dwGuildNumber$1$[ebp], eax
  0007b	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00081	e8 00 00 00 00	 call	 ?SearchGuild_Number@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@H@Z ; CGuildClass::SearchGuild_Number
  00086	8b f8		 mov	 edi, eax

; 16928: 
; 16929: 	if ( lpGuildInfo )

  00088	85 ff		 test	 edi, edi
  0008a	0f 84 83 00 00
	00		 je	 $LN4@GCGuildVie

; 16930: 	{
; 16931: 		PMSG_ANS_GUILDVIEWPORT pMsg;
; 16932: 
; 16933: 		pMsg.h.c = 0xC1;
; 16934: 		pMsg.h.headcode = 0x66;
; 16935: 		pMsg.h.size = sizeof(pMsg);
; 16936: 		pMsg.GuildNumber = lpGuildInfo->Number;

  00090	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 16937: 		pMsg.btGuildType = lpGuildInfo->btGuildType;
; 16938: 
; 16939: 		TUnionInfo * pUnionInfo = UnionManager.SearchUnion(lpGuildInfo->iGuildUnion);

  00092	ff b7 44 07 00
	00		 push	 DWORD PTR [edi+1860]
  00098	89 4d c4	 mov	 DWORD PTR _pMsg$1[ebp+4], ecx
  0009b	8a 8f 40 07 00
	00		 mov	 cl, BYTE PTR [edi+1856]
  000a1	88 4d c8	 mov	 BYTE PTR _pMsg$1[ebp+8], cl
  000a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  000a9	66 c7 45 c0 c1
	3c		 mov	 WORD PTR _pMsg$1[ebp], 15553 ; 00003cc1H
  000af	c6 45 c2 66	 mov	 BYTE PTR _pMsg$1[ebp+2], 102 ; 00000066H
  000b3	e8 00 00 00 00	 call	 ?SearchUnion@TUnion@@QAEPAVTUnionInfo@@H@Z ; TUnion::SearchUnion

; 16940: 
; 16941: 		if ( pUnionInfo )

  000b8	85 c0		 test	 eax, eax
  000ba	74 0e		 je	 SHORT $LN6@GCGuildVie

; 16942: 			memcpy(pMsg.UnionName, pUnionInfo->m_szMasterGuild, MAX_GUILD_LEN);

  000bc	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000bf	89 4d c9	 mov	 DWORD PTR _pMsg$1[ebp+9], ecx
  000c2	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000c5	89 45 cd	 mov	 DWORD PTR _pMsg$1[ebp+13], eax

; 16943: 		else

  000c8	eb 04		 jmp	 SHORT $LN7@GCGuildVie
$LN6@GCGuildVie:

; 16944: 			pMsg.UnionName[0] = '\0';

  000ca	c6 45 c9 00	 mov	 BYTE PTR _pMsg$1[ebp+9], 0
$LN7@GCGuildVie:

; 16945: 
; 16946: 		strcpy(pMsg.GuildName, lpGuildInfo->Name);

  000ce	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000d1	8d 55 d1	 lea	 edx, DWORD PTR _pMsg$1[ebp+17]
  000d4	2b d1		 sub	 edx, ecx
$LL11@GCGuildVie:
  000d6	8a 01		 mov	 al, BYTE PTR [ecx]
  000d8	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000db	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  000df	84 c0		 test	 al, al
  000e1	75 f3		 jne	 SHORT $LL11@GCGuildVie

; 16947: 		memcpy(pMsg.Mark, lpGuildInfo->Mark, sizeof(pMsg.Mark));

  000e3	0f 10 47 0d	 movups	 xmm0, XMMWORD PTR [edi+13]

; 16948: 
; 16949: 		DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  000e7	6a 3c		 push	 60			; 0000003cH
  000e9	8d 45 c0	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  000ec	0f 11 45 d9	 movups	 XMMWORD PTR _pMsg$1[ebp+25], xmm0
  000f0	50		 push	 eax
  000f1	0f 10 47 1d	 movups	 xmm0, XMMWORD PTR [edi+29]
  000f5	56		 push	 esi
  000f6	0f 11 45 e9	 movups	 XMMWORD PTR _pMsg$1[ebp+41], xmm0
  000fa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16950: 	}
; 16951: 	else
; 16952: 	{
; 16953: 		LogAddTD("    .  : [%s]  : %d",

  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00102	5b		 pop	 ebx
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi

; 16954: 			lpObj->Name, dwGuildNumber);
; 16955: 	}
; 16956: }

  00105	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00108	33 cd		 xor	 ecx, ebp
  0010a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
$LN4@GCGuildVie:

; 16950: 	}
; 16951: 	else
; 16952: 	{
; 16953: 		LogAddTD("    .  : [%s]  : %d",

  00113	ff 75 bc	 push	 DWORD PTR _dwGuildNumber$1$[ebp]
  00116	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00119	50		 push	 eax
  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@DNMHOFNM@?$KB?Z?$KB?Z?$KB?Y?5?$LB?f?$LF?e?5?A?$KE?$LK?$LI?5?C?$KD?$MA?$LL?$LM?v?5?$LO?x?$MA?$LN?4?5?$MA?L@
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH
  00128	5b		 pop	 ebx
$LN5@GCGuildVie:

; 16954: 			lpObj->Name, dwGuildNumber);
; 16955: 	}
; 16956: }

  00129	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012c	5f		 pop	 edi
  0012d	33 cd		 xor	 ecx, ebp
  0012f	5e		 pop	 esi
  00130	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z ENDP ; GCGuildViewportInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z
_TEXT	SEGMENT
tv848 = -28						; size = 4
_lpMsg$GSCopy$1$ = -24					; size = 4
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z PROC ; CGRequestPetItemInfo, COMDAT

; 16733: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 16734: 	if ( !gObjIsConnectedGP(aIndex))

  00017	53		 push	 ebx
  00018	89 45 e8	 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], eax
  0001b	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	75 27		 jne	 SHORT $LN2@CGRequestP

; 16735: 	{
; 16736: 		LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);

  00027	68 60 41 00 00	 push	 16736			; 00004160H
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCDOHCGD@error?9L2?5?3?5Index?5?$CFs?5?$CFd?$AA@
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003f	5b		 pop	 ebx

; 16891: 				}
; 16892: 			}
; 16893: 		}
; 16894: 	}	
; 16895: }

  00040	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00043	33 cd		 xor	 ecx, ebp
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN2@CGRequestP:

; 16737: 		return;
; 16738: 	}
; 16739: 
; 16740: 	if ( !OBJMAX_RANGE(aIndex))

  0004e	85 db		 test	 ebx, ebx
  00050	0f 88 e9 04 00
	00		 js	 $LN38@CGRequestP
  00056	33 c0		 xor	 eax, eax
  00058	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  0005e	0f 9e c0	 setle	 al
  00061	85 c0		 test	 eax, eax
  00063	0f 84 d6 04 00
	00		 je	 $LN38@CGRequestP

; 16741: 		return;
; 16742: 
; 16743: 	LPOBJ lpObj = &gObj[aIndex];
; 16744: 
; 16745: 	if ( lpMsg->PetType != 0 && lpMsg->PetType != 1 )

  00069	8b 4d e8	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  0006c	56		 push	 esi
  0006d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00073	57		 push	 edi
  00074	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00077	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  0007d	84 c0		 test	 al, al
  0007f	74 08		 je	 SHORT $LN4@CGRequestP
  00081	3c 01		 cmp	 al, 1
  00083	0f 85 b4 04 00
	00		 jne	 $LN60@CGRequestP
$LN4@CGRequestP:

; 16746: 		return;
; 16747: 	
; 16748: 	PMSG_SEND_PET_ITEMINFO pMsg;
; 16749: 
; 16750: 	pMsg.h.set((LPBYTE)&pMsg, 0xA9, sizeof(pMsg));
; 16751: 	pMsg.PetType = lpMsg->PetType;

  00089	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 16752: 	pMsg.InvenType = lpMsg->InvenType;

  0008c	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 16753: 	pMsg.nPos = lpMsg->nPos;

  0008f	8a 49 05	 mov	 cl, BYTE PTR [ecx+5]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 86   : 		lpBuf[0] = 0xC1;

  00092	66 c7 45 ec c1
	10		 mov	 WORD PTR _pMsg$[ebp], 4289 ; 000010c1H

; 87   : 		lpBuf[1] = size;
; 88   : 		lpBuf[2] = head;

  00098	c6 45 ee a9	 mov	 BYTE PTR _pMsg$[ebp+2], 169 ; 000000a9H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 16752: 	pMsg.InvenType = lpMsg->InvenType;

  0009c	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 16753: 	pMsg.nPos = lpMsg->nPos;

  0009f	88 4d f1	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 16754: 
; 16755: 	if ( lpMsg->InvenType == 0 )	// Inventory

  000a2	84 c0		 test	 al, al
  000a4	75 70		 jne	 SHORT $LN5@CGRequestP

; 16756: 	{
; 16757: 		if ( !INVENTORY_RANGE(lpMsg->nPos))

  000a6	b8 ec 00 00 00	 mov	 eax, 236		; 000000ecH
  000ab	3a c1		 cmp	 al, cl
  000ad	1b c0		 sbb	 eax, eax
  000af	83 c0 01	 add	 eax, 1

; 16758: 		{
; 16759: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d",

  000b2	0f b6 c1	 movzx	 eax, cl
  000b5	0f 84 97 03 00
	00		 je	 $LN63@CGRequestP

; 16760: 				lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 16761: 
; 16762: 			return;
; 16763: 		}
; 16764: 
; 16765: 		if ( lpObj->pInventory[lpMsg->nPos].IsItem() )

  000bb	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  000c1	03 8c 37 c0 11
	00 00		 add	 ecx, DWORD PTR [edi+esi+4544]
  000c8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000cd	85 c0		 test	 eax, eax
  000cf	0f 84 68 04 00
	00		 je	 $LN60@CGRequestP

; 16766: 		{
; 16767: 			pMsg.Exp = lpObj->pInventory[lpMsg->nPos].m_PetItem_Exp;

  000d5	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  000d8	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  000dc	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  000e2	8b 84 37 c0 11
	00 00		 mov	 eax, DWORD PTR [edi+esi+4544]
  000e9	8b 84 01 bc 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax+188]
  000f0	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 16768: 			pMsg.Level = lpObj->pInventory[lpMsg->nPos].m_PetItem_Level;

  000f3	8b 84 37 c0 11
	00 00		 mov	 eax, DWORD PTR [edi+esi+4544]
  000fa	8a 84 01 b8 00
	00 00		 mov	 al, BYTE PTR [ecx+eax+184]
  00101	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 16769: 			pMsg.Life = (BYTE)(lpObj->pInventory[lpMsg->nPos].m_Durability);

  00104	8b 84 37 c0 11
	00 00		 mov	 eax, DWORD PTR [edi+esi+4544]
  0010b	f3 0f 2c 44 01
	24		 cvttss2si eax, DWORD PTR [ecx+eax+36]

; 16770: 
; 16771: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 16772: 		}
; 16773: 	}

  00111	e9 15 04 00 00	 jmp	 $LN62@CGRequestP
$LN5@CGRequestP:

; 16774: 	else if ( lpMsg->InvenType == 1 )	// Warehouse

  00116	3c 01		 cmp	 al, 1
  00118	0f 85 a6 00 00
	00		 jne	 $LN9@CGRequestP

; 16775: 	{
; 16776: 		if ( lpObj->LoadWareHouseInfo != false )

  0011e	80 bc 37 ec 13
	00 00 00	 cmp	 BYTE PTR [edi+esi+5100], 0
  00126	0f 84 11 04 00
	00		 je	 $LN60@CGRequestP

; 16777: 		{
; 16778: 			if ( !WAREHOUSE_RANGE(lpMsg->nPos))

  0012c	b8 ef 00 00 00	 mov	 eax, 239		; 000000efH
  00131	3a c1		 cmp	 al, cl
  00133	1b c0		 sbb	 eax, eax
  00135	83 c0 01	 add	 eax, 1

; 16779: 			{
; 16780: 				LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid WareHouse nPos %d",

  00138	0f b6 c1	 movzx	 eax, cl
  0013b	75 2c		 jne	 SHORT $LN12@CGRequestP
  0013d	50		 push	 eax
  0013e	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00141	03 c7		 add	 eax, edi
  00143	50		 push	 eax
  00144	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00147	03 c7		 add	 eax, edi
  00149	50		 push	 eax
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BLGKOALL@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00155	83 c4 10	 add	 esp, 16			; 00000010H
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx

; 16891: 				}
; 16892: 			}
; 16893: 		}
; 16894: 	}	
; 16895: }

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015e	33 cd		 xor	 ecx, ebp
  00160	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
$LN12@CGRequestP:

; 16781: 					lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 16782: 
; 16783: 				return;
; 16784: 			}
; 16785: 
; 16786: 			if ( lpObj->pWarehouse[lpMsg->nPos].IsItem() )

  00169	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0016f	03 8c 37 f8 11
	00 00		 add	 ecx, DWORD PTR [edi+esi+4600]
  00176	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0017b	85 c0		 test	 eax, eax
  0017d	0f 84 ba 03 00
	00		 je	 $LN60@CGRequestP

; 16787: 			{
; 16788: 				pMsg.Exp = lpObj->pWarehouse[lpMsg->nPos].m_PetItem_Exp;

  00183	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00186	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  0018a	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00190	8b 84 37 f8 11
	00 00		 mov	 eax, DWORD PTR [edi+esi+4600]
  00197	8b 84 01 bc 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax+188]
  0019e	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 16789: 				pMsg.Level = lpObj->pWarehouse[lpMsg->nPos].m_PetItem_Level;

  001a1	8b 84 37 f8 11
	00 00		 mov	 eax, DWORD PTR [edi+esi+4600]
  001a8	8a 84 01 b8 00
	00 00		 mov	 al, BYTE PTR [ecx+eax+184]
  001af	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 16790: 				pMsg.Life = (BYTE)lpObj->pWarehouse[lpMsg->nPos].m_Durability;

  001b2	8b 84 37 f8 11
	00 00		 mov	 eax, DWORD PTR [edi+esi+4600]
  001b9	f3 0f 2c 44 01
	24		 cvttss2si eax, DWORD PTR [ecx+eax+36]

; 16791: 
; 16792: 				DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 16793: 			}
; 16794: 		}
; 16795: 	}

  001bf	e9 67 03 00 00	 jmp	 $LN62@CGRequestP
$LN9@CGRequestP:

; 16796: 	else if ( lpMsg->InvenType == 2 )	// Trade

  001c4	3c 02		 cmp	 al, 2
  001c6	0f 85 b7 00 00
	00		 jne	 $LN14@CGRequestP

; 16797: 	{
; 16798: 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 1 )

  001cc	8b 94 37 b8 11
	00 00		 mov	 edx, DWORD PTR [edi+esi+4536]
  001d3	8b c2		 mov	 eax, edx
  001d5	24 03		 and	 al, 3
  001d7	3c 01		 cmp	 al, 1
  001d9	0f 82 5e 03 00
	00		 jb	 $LN60@CGRequestP
  001df	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  001e5	83 fa 40	 cmp	 edx, 64			; 00000040H
  001e8	0f 85 4f 03 00
	00		 jne	 $LN60@CGRequestP

; 16799: 			return;
; 16800: 
; 16801: 		if ( !TRADE_BOX_RANGE(lpMsg->nPos))

  001ee	b0 1f		 mov	 al, 31			; 0000001fH
  001f0	3a c1		 cmp	 al, cl
  001f2	1b c0		 sbb	 eax, eax
  001f4	83 c0 01	 add	 eax, 1

; 16802: 		{
; 16803: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Trade nPos %d",

  001f7	0f b6 c1	 movzx	 eax, cl
  001fa	75 2c		 jne	 SHORT $LN18@CGRequestP
  001fc	50		 push	 eax
  001fd	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00200	03 c7		 add	 eax, edi
  00202	50		 push	 eax
  00203	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00206	03 c7		 add	 eax, edi
  00208	50		 push	 eax
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@LFOOFHNO@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00214	83 c4 10	 add	 esp, 16			; 00000010H
  00217	5f		 pop	 edi
  00218	5e		 pop	 esi
  00219	5b		 pop	 ebx

; 16891: 				}
; 16892: 			}
; 16893: 		}
; 16894: 	}	
; 16895: }

  0021a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021d	33 cd		 xor	 ecx, ebp
  0021f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
$LN18@CGRequestP:

; 16804: 				lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 16805: 
; 16806: 			return;
; 16807: 		}
; 16808: 
; 16809: 		if ( lpObj->Trade[lpMsg->nPos].IsItem() )

  00228	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0022e	03 8c 37 e8 11
	00 00		 add	 ecx, DWORD PTR [edi+esi+4584]
  00235	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0023a	85 c0		 test	 eax, eax
  0023c	0f 84 fb 02 00
	00		 je	 $LN60@CGRequestP

; 16810: 		{
; 16811: 			pMsg.Exp = lpObj->Trade[lpMsg->nPos].m_PetItem_Exp;

  00242	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00245	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00249	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0024f	8b 84 37 e8 11
	00 00		 mov	 eax, DWORD PTR [edi+esi+4584]
  00256	8b 84 01 bc 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax+188]
  0025d	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 16812: 			pMsg.Level = lpObj->Trade[lpMsg->nPos].m_PetItem_Level;

  00260	8b 84 37 e8 11
	00 00		 mov	 eax, DWORD PTR [edi+esi+4584]
  00267	8a 84 01 b8 00
	00 00		 mov	 al, BYTE PTR [ecx+eax+184]
  0026e	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 16813: 			pMsg.Life = (BYTE)lpObj->Trade[lpMsg->nPos].m_Durability;

  00271	8b 84 37 e8 11
	00 00		 mov	 eax, DWORD PTR [edi+esi+4584]
  00278	f3 0f 2c 44 01
	24		 cvttss2si eax, DWORD PTR [ecx+eax+36]

; 16814: 
; 16815: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 16816: 		}
; 16817: 	}

  0027e	e9 a8 02 00 00	 jmp	 $LN62@CGRequestP
$LN14@CGRequestP:

; 16818: 	else if ( lpMsg->InvenType == 3 )	// Target Trade

  00283	3c 03		 cmp	 al, 3
  00285	0f 85 0e 01 00
	00		 jne	 $LN20@CGRequestP

; 16819: 	{
; 16820: 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 1 )

  0028b	8b 94 37 b8 11
	00 00		 mov	 edx, DWORD PTR [edi+esi+4536]
  00292	8b c2		 mov	 eax, edx
  00294	24 03		 and	 al, 3
  00296	3c 01		 cmp	 al, 1
  00298	0f 82 9f 02 00
	00		 jb	 $LN60@CGRequestP
  0029e	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  002a4	83 fa 40	 cmp	 edx, 64			; 00000040H
  002a7	0f 85 90 02 00
	00		 jne	 $LN60@CGRequestP

; 16821: 			return;
; 16822: 
; 16823: 		int iTargetIndex = gObj[aIndex].TargetNumber;

  002ad	0f bf 94 37 38
	06 00 00	 movsx	 edx, WORD PTR [edi+esi+1592]

; 16824: 
; 16825: 		if ( iTargetIndex < 0 )

  002b5	85 d2		 test	 edx, edx
  002b7	0f 88 80 02 00
	00		 js	 $LN60@CGRequestP

; 16826: 			return;
; 16827: 
; 16828: 		if ( !OBJMAX_RANGE(iTargetIndex) )

  002bd	33 c0		 xor	 eax, eax
  002bf	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  002c5	0f 9e c0	 setle	 al
  002c8	85 c0		 test	 eax, eax
  002ca	0f 84 6d 02 00
	00		 je	 $LN60@CGRequestP

; 16829: 			return;
; 16830: 
; 16831: 		if ( gObj[iTargetIndex].m_IfState.use < 1 || gObj[iTargetIndex].m_IfState.type != 1 )

  002d0	69 d2 40 27 00
	00		 imul	 edx, edx, 10048
  002d6	89 55 e4	 mov	 DWORD PTR tv848[ebp], edx
  002d9	8b 94 32 b8 11
	00 00		 mov	 edx, DWORD PTR [edx+esi+4536]
  002e0	8b c2		 mov	 eax, edx
  002e2	24 03		 and	 al, 3
  002e4	3c 01		 cmp	 al, 1
  002e6	0f 82 51 02 00
	00		 jb	 $LN60@CGRequestP
  002ec	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  002f2	83 fa 40	 cmp	 edx, 64			; 00000040H
  002f5	0f 85 42 02 00
	00		 jne	 $LN60@CGRequestP

; 16832: 			return;
; 16833: 
; 16834: 		if ( !TRADE_BOX_RANGE(lpMsg->nPos))

  002fb	b0 1f		 mov	 al, 31			; 0000001fH
  002fd	3a c1		 cmp	 al, cl
  002ff	1b c0		 sbb	 eax, eax
  00301	83 c0 01	 add	 eax, 1

; 16835: 		{
; 16836: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid TargetTrade nPos %d",

  00304	0f b6 c1	 movzx	 eax, cl
  00307	75 2c		 jne	 SHORT $LN28@CGRequestP
  00309	50		 push	 eax
  0030a	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0030d	03 c7		 add	 eax, edi
  0030f	50		 push	 eax
  00310	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00313	03 c7		 add	 eax, edi
  00315	50		 push	 eax
  00316	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@OIKHDOGN@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  0031b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00321	83 c4 10	 add	 esp, 16			; 00000010H
  00324	5f		 pop	 edi
  00325	5e		 pop	 esi
  00326	5b		 pop	 ebx

; 16891: 				}
; 16892: 			}
; 16893: 		}
; 16894: 	}	
; 16895: }

  00327	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032a	33 cd		 xor	 ecx, ebp
  0032c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00331	8b e5		 mov	 esp, ebp
  00333	5d		 pop	 ebp
  00334	c3		 ret	 0
$LN28@CGRequestP:

; 16837: 				lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 16838: 
; 16839: 			return;
; 16840: 		}
; 16841: 
; 16842: 		if ( gObj[iTargetIndex].Trade[lpMsg->nPos].IsItem() )

  00335	8b 7d e4	 mov	 edi, DWORD PTR tv848[ebp]
  00338	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0033e	03 8c 37 e8 11
	00 00		 add	 ecx, DWORD PTR [edi+esi+4584]
  00345	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0034a	85 c0		 test	 eax, eax
  0034c	0f 84 eb 01 00
	00		 je	 $LN60@CGRequestP

; 16843: 		{
; 16844: 			pMsg.Exp = gObj[iTargetIndex].Trade[lpMsg->nPos].m_PetItem_Exp;

  00352	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00355	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0035b	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  0035f	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00365	8b 84 17 e8 11
	00 00		 mov	 eax, DWORD PTR [edi+edx+4584]
  0036c	8b 84 01 bc 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax+188]
  00373	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 16845: 			pMsg.Level = gObj[iTargetIndex].Trade[lpMsg->nPos].m_PetItem_Level;

  00376	8b 84 17 e8 11
	00 00		 mov	 eax, DWORD PTR [edi+edx+4584]
  0037d	8a 84 01 b8 00
	00 00		 mov	 al, BYTE PTR [ecx+eax+184]
  00384	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 16846: 			pMsg.Life = (BYTE)gObj[iTargetIndex].Trade[lpMsg->nPos].m_Durability;

  00387	8b 84 17 e8 11
	00 00		 mov	 eax, DWORD PTR [edi+edx+4584]
  0038e	f3 0f 2c 44 01
	24		 cvttss2si eax, DWORD PTR [ecx+eax+36]

; 16847: 
; 16848: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 16849: 		}
; 16850: 	}

  00394	e9 92 01 00 00	 jmp	 $LN62@CGRequestP
$LN20@CGRequestP:

; 16851: 	else if ( lpMsg->InvenType == 4 )	// Chaos

  00399	3c 04		 cmp	 al, 4
  0039b	0f 85 98 00 00
	00		 jne	 $LN30@CGRequestP

; 16852: 	{
; 16853: 		if ( !CHAOS_BOX_RANGE(lpMsg->nPos) )

  003a1	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  003a6	3a c1		 cmp	 al, cl
  003a8	1b c0		 sbb	 eax, eax
  003aa	83 c0 01	 add	 eax, 1

; 16854: 		{
; 16855: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Chaos nPos %d",

  003ad	0f b6 c1	 movzx	 eax, cl
  003b0	75 2c		 jne	 SHORT $LN32@CGRequestP
  003b2	50		 push	 eax
  003b3	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  003b6	03 c7		 add	 eax, edi
  003b8	50		 push	 eax
  003b9	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  003bc	03 c7		 add	 eax, edi
  003be	50		 push	 eax
  003bf	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DBFIHHGF@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  003c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003ca	83 c4 10	 add	 esp, 16			; 00000010H
  003cd	5f		 pop	 edi
  003ce	5e		 pop	 esi
  003cf	5b		 pop	 ebx

; 16891: 				}
; 16892: 			}
; 16893: 		}
; 16894: 	}	
; 16895: }

  003d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d3	33 cd		 xor	 ecx, ebp
  003d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003da	8b e5		 mov	 esp, ebp
  003dc	5d		 pop	 ebp
  003dd	c3		 ret	 0
$LN32@CGRequestP:

; 16856: 				lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 16857: 
; 16858: 			return;
; 16859: 		}
; 16860: 
; 16861: 		if ( lpObj->pChaosBox[lpMsg->nPos].IsItem() )

  003de	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  003e4	03 8c 37 10 12
	00 00		 add	 ecx, DWORD PTR [edi+esi+4624]
  003eb	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003f0	85 c0		 test	 eax, eax
  003f2	0f 84 45 01 00
	00		 je	 $LN60@CGRequestP

; 16862: 		{
; 16863: 			pMsg.Exp = lpObj->pChaosBox[lpMsg->nPos].m_PetItem_Exp;

  003f8	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  003fb	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  003ff	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00405	8b 84 37 10 12
	00 00		 mov	 eax, DWORD PTR [edi+esi+4624]
  0040c	8b 84 01 bc 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax+188]
  00413	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 16864: 			pMsg.Level = lpObj->pChaosBox[lpMsg->nPos].m_PetItem_Level;

  00416	8b 84 37 10 12
	00 00		 mov	 eax, DWORD PTR [edi+esi+4624]
  0041d	8a 84 01 b8 00
	00 00		 mov	 al, BYTE PTR [ecx+eax+184]
  00424	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 16865: 			pMsg.Life = (BYTE)lpObj->pChaosBox[lpMsg->nPos].m_Durability;

  00427	8b 84 37 10 12
	00 00		 mov	 eax, DWORD PTR [edi+esi+4624]
  0042e	f3 0f 2c 44 01
	24		 cvttss2si eax, DWORD PTR [ecx+eax+36]

; 16866: 
; 16867: 			DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));
; 16868: 		}
; 16869: 	}

  00434	e9 f2 00 00 00	 jmp	 $LN62@CGRequestP
$LN30@CGRequestP:

; 16870: 	else if ( lpMsg->InvenType == 5 )	// Personal Shop

  00439	3c 05		 cmp	 al, 5
  0043b	0f 85 fc 00 00
	00		 jne	 $LN60@CGRequestP

; 16871: 	{
; 16872: 		if ( !INVENTORY_RANGE(lpMsg->nPos) )

  00441	b8 ec 00 00 00	 mov	 eax, 236		; 000000ecH
  00446	3a c1		 cmp	 al, cl
  00448	1b c0		 sbb	 eax, eax
  0044a	83 c0 01	 add	 eax, 1
  0044d	75 2f		 jne	 SHORT $LN35@CGRequestP

; 16873: 		{
; 16874: 			LogAddTD("[PetItem] [%s][%s] RequestPetItem Invalid Iventory nPos %d",

  0044f	0f b6 c1	 movzx	 eax, cl
$LN63@CGRequestP:
  00452	50		 push	 eax
  00453	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00456	03 c7		 add	 eax, edi
  00458	50		 push	 eax
  00459	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0045c	03 c7		 add	 eax, edi
  0045e	50		 push	 eax
  0045f	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GJNDCDLC@?$FLPetItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5RequestPetIte@
  00464	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0046a	83 c4 10	 add	 esp, 16			; 00000010H
  0046d	5f		 pop	 edi
  0046e	5e		 pop	 esi
  0046f	5b		 pop	 ebx

; 16891: 				}
; 16892: 			}
; 16893: 		}
; 16894: 	}	
; 16895: }

  00470	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00473	33 cd		 xor	 ecx, ebp
  00475	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0047a	8b e5		 mov	 esp, ebp
  0047c	5d		 pop	 ebp
  0047d	c3		 ret	 0
$LN35@CGRequestP:

; 16875: 				lpObj->AccountID, lpObj->Name, lpMsg->nPos);
; 16876: 
; 16877: 			return;
; 16878: 		}
; 16879: 
; 16880: 		if ( lpObj->m_iPShopDealerIndex != -1 )

  0047e	8b 94 37 88 12
	00 00		 mov	 edx, DWORD PTR [edi+esi+4744]
  00485	83 fa ff	 cmp	 edx, -1
  00488	0f 84 af 00 00
	00		 je	 $LN60@CGRequestP

; 16881: 		{
; 16882: 			if ( OBJMAX_RANGE(lpObj->m_iPShopDealerIndex))

  0048e	85 d2		 test	 edx, edx
  00490	0f 88 a7 00 00
	00		 js	 $LN60@CGRequestP
  00496	33 c0		 xor	 eax, eax
  00498	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  0049e	0f 9e c0	 setle	 al
  004a1	85 c0		 test	 eax, eax
  004a3	0f 84 94 00 00
	00		 je	 $LN60@CGRequestP

; 16883: 			{
; 16884: 				if ( gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].IsItem() )

  004a9	69 d2 40 27 00
	00		 imul	 edx, edx, 10048
  004af	0f b6 c1	 movzx	 eax, cl
  004b2	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  004b8	03 8c 32 c0 11
	00 00		 add	 ecx, DWORD PTR [edx+esi+4544]
  004bf	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  004c4	85 c0		 test	 eax, eax
  004c6	74 75		 je	 SHORT $LN60@CGRequestP

; 16885: 				{
; 16886: 					pMsg.Exp = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Exp;

  004c8	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  004cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004d1	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  004d5	69 d0 d4 00 00
	00		 imul	 edx, eax, 212
  004db	69 84 37 88 12
	00 00 40 27 00
	00		 imul	 eax, DWORD PTR [edi+esi+4744], 10048
  004e6	8b 84 08 c0 11
	00 00		 mov	 eax, DWORD PTR [eax+ecx+4544]
  004ed	8b 84 10 bc 00
	00 00		 mov	 eax, DWORD PTR [eax+edx+188]
  004f4	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 16887: 					pMsg.Level = gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_PetItem_Level;

  004f7	69 84 37 88 12
	00 00 40 27 00
	00		 imul	 eax, DWORD PTR [edi+esi+4744], 10048
  00502	8b 84 08 c0 11
	00 00		 mov	 eax, DWORD PTR [eax+ecx+4544]
  00509	8a 84 10 b8 00
	00 00		 mov	 al, BYTE PTR [eax+edx+184]
  00510	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 16888: 					pMsg.Life = (BYTE)gObj[lpObj->m_iPShopDealerIndex].pInventory[lpMsg->nPos].m_Durability;

  00513	69 84 37 88 12
	00 00 40 27 00
	00		 imul	 eax, DWORD PTR [edi+esi+4744], 10048
  0051e	8b 84 08 c0 11
	00 00		 mov	 eax, DWORD PTR [eax+ecx+4544]
  00525	f3 0f 2c 44 10
	24		 cvttss2si eax, DWORD PTR [eax+edx+36]
$LN62@CGRequestP:
  0052b	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 16889: 
; 16890: 					DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0052e	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00531	6a 10		 push	 16			; 00000010H
  00533	50		 push	 eax
  00534	53		 push	 ebx
  00535	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0053a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN60@CGRequestP:
  0053d	5f		 pop	 edi
  0053e	5e		 pop	 esi
$LN38@CGRequestP:

; 16891: 				}
; 16892: 			}
; 16893: 		}
; 16894: 	}	
; 16895: }

  0053f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00542	33 cd		 xor	 ecx, ebp
  00544	5b		 pop	 ebx
  00545	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0054a	8b e5		 mov	 esp, ebp
  0054c	5d		 pop	 ebp
  0054d	c3		 ret	 0
?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ENDP ; CGRequestPetItemInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z PROC ; CGRequestPetItemCommand, COMDAT

; 16710: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 16711: 	if ( !gObjIsConnectedGP(aIndex))

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 44		 je	 SHORT $LN1@CGRequestP

; 16712: 	{
; 16713: 		//LogAddTD("error-L2 : Index %s %d", __FILE__, __LINE__);
; 16714: 		return;
; 16715: 	}
; 16716: 
; 16717: 	if ( !OBJMAX_RANGE(aIndex))

  00014	85 f6		 test	 esi, esi
  00016	78 40		 js	 SHORT $LN1@CGRequestP
  00018	33 c0		 xor	 eax, eax
  0001a	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00020	0f 9e c0	 setle	 al
  00023	85 c0		 test	 eax, eax
  00025	74 31		 je	 SHORT $LN1@CGRequestP

; 16718: 		return;
; 16719: 
; 16720: 	LPOBJ lpObj = &gObj[aIndex];
; 16721: 
; 16722: 	if ( lpMsg->PetType )

  00027	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0002a	80 7a 03 00	 cmp	 BYTE PTR [edx+3], 0
  0002e	75 28		 jne	 SHORT $LN1@CGRequestP

; 16723: 		return;
; 16724: 
; 16725: 	int iTargetIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00030	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00034	66 c1 e0 08	 shl	 ax, 8

; 16726: 	gDarkSpirit[aIndex].ChangeCommand(lpMsg->Command, iTargetIndex);

  00038	0f b7 c8	 movzx	 ecx, ax
  0003b	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  0003f	0b c8		 or	 ecx, eax
  00041	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00045	51		 push	 ecx
  00046	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00049	c1 e1 04	 shl	 ecx, 4
  0004c	50		 push	 eax
  0004d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  00053	e8 00 00 00 00	 call	 ?ChangeCommand@CDarkSpirit@@QAEXHH@Z ; CDarkSpirit::ChangeCommand
$LN1@CGRequestP:
  00058	5e		 pop	 esi

; 16727: }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ENDP ; CGRequestPetItemCommand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSendEffectInfo@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_btType$ = 12						; size = 1
?GCSendEffectInfo@@YAXHE@Z PROC				; GCSendEffectInfo, COMDAT

; 16682: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16683: 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c9		 test	 ecx, ecx
  0000b	78 61		 js	 SHORT $LN1@GCSendEffe
  0000d	33 c0		 xor	 eax, eax
  0000f	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00015	0f 9e c0	 setle	 al
  00018	85 c0		 test	 eax, eax
  0001a	74 52		 je	 SHORT $LN1@GCSendEffe

; 16684: 	{
; 16685: 		return;
; 16686: 	}
; 16687: 
; 16688: 	LPOBJ lpObj = &gObj[aIndex];

  0001c	56		 push	 esi
  0001d	69 f1 40 27 00
	00		 imul	 esi, ecx, 10048

; 16689: 	PMSG_EFFECTINFO pMsg;
; 16690: 
; 16691: 	pMsg.h.c = 0xC1;
; 16692: 	pMsg.h.headcode = 0x48;
; 16693: 	pMsg.h.size = sizeof(pMsg);
; 16694: 	pMsg.NumberH = SET_NUMBERH(aIndex);

  00023	8b c1		 mov	 eax, ecx
  00025	c1 e8 08	 shr	 eax, 8
  00028	b2 06		 mov	 dl, 6
  0002a	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 16695: 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 16696: 	pMsg.btType = btType;

  0002d	8a 45 0c	 mov	 al, BYTE PTR _btType$[ebp]
  00030	66 c7 45 f8 c1
	06		 mov	 WORD PTR _pMsg$[ebp], 1729 ; 000006c1H
  00036	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003c	c6 45 fa 48	 mov	 BYTE PTR _pMsg$[ebp+2], 72 ; 00000048H
  00040	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00043	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 16697: 
; 16698: 	if ( btType == 17 )

  00046	3c 11		 cmp	 al, 17			; 00000011H
  00048	75 12		 jne	 SHORT $LN3@GCSendEffe

; 16699: 	{
; 16700: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0004a	6a 06		 push	 6
  0004c	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004f	50		 push	 eax
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00056	8a 55 f9	 mov	 dl, BYTE PTR _pMsg$[ebp+1]
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCSendEffe:

; 16701: 	}
; 16702: 
; 16703: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  0005c	0f b6 c2	 movzx	 eax, dl
  0005f	50		 push	 eax
  00060	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00063	50		 push	 eax
  00064	56		 push	 esi
  00065	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	5e		 pop	 esi
$LN1@GCSendEffe:

; 16704: }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?GCSendEffectInfo@@YAXHE@Z ENDP				; GCSendEffectInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z
_TEXT	SEGMENT
_pMsg$1 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpItem$ = 12						; size = 4
?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z PROC	; GCSendGetItemInfoForParty, COMDAT

; 16619: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _lpItem$[ebp]
  00017	57		 push	 edi

; 16620: 	LPOBJ lpObj = &gObj[aIndex];

  00018	69 f9 40 27 00
	00		 imul	 edi, ecx, 10048
  0001e	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16621: 
; 16622: 	if ( lpObj->PartyNumber >= 0)

  00024	83 bf 0c 06 00
	00 00		 cmp	 DWORD PTR [edi+1548], 0
  0002b	0f 8c e1 00 00
	00		 jl	 $LN3@GCSendGetI

; 16623: 	{
; 16624: 		PMSG_GETITEMINFO_FOR_PARTY pMsg;
; 16625: 
; 16626: 		pMsg.h.c = 0xC1;
; 16627: 		pMsg.h.headcode = 0x47;
; 16628: 		pMsg.h.size = sizeof(pMsg);
; 16629: 		pMsg.NumberH = SET_NUMBERH(aIndex);

  00031	8b c1		 mov	 eax, ecx
  00033	66 c7 45 ec c1
	10		 mov	 WORD PTR _pMsg$1[ebp], 4289 ; 000010c1H
  00039	c1 e8 08	 shr	 eax, 8
  0003c	88 45 ef	 mov	 BYTE PTR _pMsg$1[ebp+3], al

; 16630: 		pMsg.NumberL = SET_NUMBERL(aIndex);
; 16631: 		pMsg.ItemInfo = lpItem->m_Type & (ITEMGET(MAX_TYPE_ITEMS-1, MAX_SUBTYPE_ITEMS-1));

  0003f	0f bf 46 0a	 movsx	 eax, WORD PTR [esi+10]
  00043	25 ff 1f 00 00	 and	 eax, 8191		; 00001fffH
  00048	c6 45 ee 47	 mov	 BYTE PTR _pMsg$1[ebp+2], 71 ; 00000047H

; 16632: 
; 16633: 		if ( lpItem->m_Option1 )

  0004c	80 be 94 00 00
	00 00		 cmp	 BYTE PTR [esi+148], 0
  00053	88 4d f0	 mov	 BYTE PTR _pMsg$1[ebp+4], cl
  00056	89 45 f4	 mov	 DWORD PTR _pMsg$1[ebp+8], eax
  00059	74 08		 je	 SHORT $LN6@GCSendGetI

; 16634: 			pMsg.ItemInfo |= 0x2000;

  0005b	0d 00 20 00 00	 or	 eax, 8192		; 00002000H
  00060	89 45 f4	 mov	 DWORD PTR _pMsg$1[ebp+8], eax
$LN6@GCSendGetI:

; 16635: 
; 16636: 		if ( lpItem->m_Option2 )

  00063	80 be 95 00 00
	00 00		 cmp	 BYTE PTR [esi+149], 0
  0006a	74 08		 je	 SHORT $LN7@GCSendGetI

; 16637: 			pMsg.ItemInfo |= 0x4000;

  0006c	0d 00 40 00 00	 or	 eax, 16384		; 00004000H
  00071	89 45 f4	 mov	 DWORD PTR _pMsg$1[ebp+8], eax
$LN7@GCSendGetI:

; 16638: 
; 16639: 		if ( lpItem->m_Option3 )

  00074	80 be 96 00 00
	00 00		 cmp	 BYTE PTR [esi+150], 0
  0007b	74 08		 je	 SHORT $LN8@GCSendGetI

; 16640: 			pMsg.ItemInfo |= 0x8000;

  0007d	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00082	89 45 f4	 mov	 DWORD PTR _pMsg$1[ebp+8], eax
$LN8@GCSendGetI:

; 16641: 
; 16642: 		if ( lpItem->m_NewOption )

  00085	80 be 97 00 00
	00 00		 cmp	 BYTE PTR [esi+151], 0
  0008c	74 08		 je	 SHORT $LN9@GCSendGetI

; 16643: 			pMsg.ItemInfo |= 0x10000;

  0008e	0d 00 00 01 00	 or	 eax, 65536		; 00010000H
  00093	89 45 f4	 mov	 DWORD PTR _pMsg$1[ebp+8], eax
$LN9@GCSendGetI:

; 16644: 
; 16645: 		if ( lpItem->m_SetOption )

  00096	80 be ae 00 00
	00 00		 cmp	 BYTE PTR [esi+174], 0
  0009d	74 08		 je	 SHORT $LN10@GCSendGetI

; 16646: 			pMsg.ItemInfo |= 0x20000;

  0009f	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  000a4	89 45 f4	 mov	 DWORD PTR _pMsg$1[ebp+8], eax
$LN10@GCSendGetI:

; 16647: 
; 16648: 		if ( g_kItemSystemFor380.Is380OptionItem( (lpItem != NULL)?((CItem *)&lpItem->m_Number):NULL) == TRUE )

  000a7	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ?Is380OptionItem@CItemSystemFor380@@QAEHPBVCItem@@@Z ; CItemSystemFor380::Is380OptionItem
  000b5	83 f8 01	 cmp	 eax, 1
  000b8	75 07		 jne	 SHORT $LN11@GCSendGetI

; 16649: 			pMsg.ItemInfo |= 0x40000;

  000ba	81 4d f4 00 00
	04 00		 or	 DWORD PTR _pMsg$1[ebp+8], 262144 ; 00040000H
$LN11@GCSendGetI:

; 16650: 
; 16651: 		pMsg.Level = lpItem->m_Level;

  000c1	8a 46 0c	 mov	 al, BYTE PTR [esi+12]

; 16652: 		
; 16653: 		int partycount = gParty.GetPartyCount(lpObj->PartyNumber);

  000c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000c9	ff b7 0c 06 00
	00		 push	 DWORD PTR [edi+1548]
  000cf	88 45 f8	 mov	 BYTE PTR _pMsg$1[ebp+12], al
  000d2	e8 00 00 00 00	 call	 ?GetPartyCount@PartyClass@@QAEHH@Z ; PartyClass::GetPartyCount

; 16654: 
; 16655: 		if ( partycount >= 0 )

  000d7	85 c0		 test	 eax, eax
  000d9	78 37		 js	 SHORT $LN3@GCSendGetI

; 16656: 		{
; 16657: 			for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  000db	33 f6		 xor	 esi, esi
  000dd	0f 1f 00	 npad	 3
$LL4@GCSendGetI:

; 16658: 			{
; 16659: 				int number = gParty.m_PartyS[lpObj->PartyNumber].Number[n];

  000e0	8b 87 0c 06 00
	00		 mov	 eax, DWORD PTR [edi+1548]
  000e6	8b c8		 mov	 ecx, eax
  000e8	c1 e1 04	 shl	 ecx, 4
  000eb	2b c8		 sub	 ecx, eax
  000ed	03 ce		 add	 ecx, esi
  000ef	8b 0c 8d 0c 00
	00 00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[ecx*4+12]

; 16660: 
; 16661: 				if ( number >= 0 )

  000f6	85 c9		 test	 ecx, ecx
  000f8	78 12		 js	 SHORT $LN2@GCSendGetI

; 16662: 				{
; 16663: 					DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  000fa	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  000fe	50		 push	 eax
  000ff	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00102	50		 push	 eax
  00103	51		 push	 ecx
  00104	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCSendGetI:

; 16656: 		{
; 16657: 			for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  0010c	46		 inc	 esi
  0010d	83 fe 05	 cmp	 esi, 5
  00110	7c ce		 jl	 SHORT $LL4@GCSendGetI
$LN3@GCSendGetI:

; 16664: 				}
; 16665: 			}
; 16666: 		}
; 16667: 	}
; 16668: }

  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	5f		 pop	 edi
  00116	33 cd		 xor	 ecx, ebp
  00118	5e		 pop	 esi
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z ENDP	; GCSendGetItemInfoForParty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z PROC	; CGDuelOkRequestRecv, COMDAT

; 16430: 	/*int iDuelIndex = -1;
; 16431: 
; 16432: 	PMSG_ANS_START_DUEL pMsgSend;
; 16433: 	
; 16434: 	pMsgSend.h.c = 0xC1;
; 16435: 	pMsgSend.h.headcode = 0xAA;
; 16436: 	pMsgSend.h.size = sizeof(pMsgSend);
; 16437: 
; 16438: 	if ( gObj[aIndex].CloseType != -1 ) 
; 16439: 		return;
; 16440: 	
; 16441: 	iDuelIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);
; 16442: 
; 16443: 	if ( OBJMAX_RANGE(iDuelIndex) )
; 16444: 	{
; 16445: 		if ( !gObjIsConnected(iDuelIndex) )
; 16446: 			return;
; 16447: 
; 16448: 		if ( gObj[iDuelIndex].Type == OBJ_MONSTER )
; 16449: 			return;
; 16450: 
; 16451: 		if ( gObj[iDuelIndex].CloseCount >= 0 )
; 16452: 			return;
; 16453: 
; 16454: 		if ( lpMsg->bDuelOK )
; 16455: 		{
; 16456: 			if ( BC_MAP_RANGE(gObj[iDuelIndex].MapNumber) ||
; 16457: 				 CC_MAP_RANGE(gObj[iDuelIndex].MapNumber) ||
; 16458: 				 DS_MAP_RANGE(gObj[iDuelIndex].MapNumber) )
; 16459: 			{
; 16460: 				GCServerMsgStringSend(lMsg.Get(MSGGET(4, 207)), aIndex, 1);
; 16461: 				gObj[aIndex].m_iDuelUserRequested = -1;
; 16462: 				gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16463: 				memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 16464: 				pMsgSend.bDuelStart = false;
; 16465: 
; 16466: 				DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16467: 				return;
; 16468: 			}
; 16469: 		}
; 16470: 
; 16471: 		if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUser ) )
; 16472: 		{
; 16473: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 160)), aIndex, 1);
; 16474: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), aIndex, 1);
; 16475: 			gObj[aIndex].m_iDuelUserRequested = -1;
; 16476: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16477: 			memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 16478: 			pMsgSend.bDuelStart = false;
; 16479: 
; 16480: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16481: 			return;
; 16482: 		}
; 16483: 
; 16484: 		if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUserReserved) )
; 16485: 		{
; 16486: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 173)), aIndex, 1);
; 16487: 			gObj[aIndex].m_iDuelUserRequested = -1;
; 16488: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16489: 			memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 16490: 			pMsgSend.bDuelStart = false;
; 16491: 
; 16492: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16493: 			return;
; 16494: 		}
; 16495: 
; 16496: 		if ( gObj[iDuelIndex].m_iDuelUserReserved == aIndex )
; 16497: 		{
; 16498: 			char szDuelName[MAX_ACCOUNT_LEN+1]={0};
; 16499: 			char szDuelName2[MAX_ACCOUNT_LEN+1]={0};
; 16500: 			memcpy(szDuelName, gObj[iDuelIndex].Name, MAX_ACCOUNT_LEN);
; 16501: 			szDuelName[MAX_ACCOUNT_LEN] = 0;
; 16502: 			memcpy(szDuelName2, lpMsg->szName, MAX_ACCOUNT_LEN);
; 16503: 			szDuelName2[MAX_ACCOUNT_LEN] = 0;
; 16504: 
; 16505: 			if ( !strcmp(szDuelName, szDuelName2))
; 16506: 			{
; 16507: 				if ( lpMsg->bDuelOK == false)
; 16508: 				{
; 16509: 					gObj[aIndex].m_iDuelUserRequested = -1;
; 16510: 					gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16511: 					memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 16512: 					pMsgSend.bDuelStart = false;
; 16513: 
; 16514: 					DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16515: 				}
; 16516: 				else if ( lpMsg->bDuelOK == true )
; 16517: 				{
; 16518: 					gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16519: 					gObj[iDuelIndex].m_btDuelScore = 0;
; 16520: 					gObj[iDuelIndex].m_iDuelUser = aIndex;
; 16521: 					gObj[iDuelIndex].m_iDuelTickCount = GetTickCount();
; 16522: 					gObj[aIndex].m_iDuelUserRequested = -1;
; 16523: 					gObj[aIndex].m_iDuelUserReserved = -1;
; 16524: 					gObj[aIndex].m_btDuelScore = 0;
; 16525: 					gObj[aIndex].m_iDuelUser = iDuelIndex;
; 16526: 					gObj[aIndex].m_iDuelTickCount = GetTickCount();
; 16527: 
; 16528: 					pMsgSend.bDuelStart = true;
; 16529: 					pMsgSend.NumberH = SET_NUMBERH(iDuelIndex);
; 16530: 					pMsgSend.NumberL = SET_NUMBERL(iDuelIndex);
; 16531: 					memcpy(pMsgSend.szName, szDuelName, sizeof(pMsgSend.szName));
; 16532: 
; 16533: 					DataSend(aIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16534: 
; 16535: 					pMsgSend.NumberH = SET_NUMBERH(aIndex);
; 16536: 					pMsgSend.NumberL = SET_NUMBERL(aIndex);
; 16537: 					memcpy(pMsgSend.szName, gObj[aIndex].Name, sizeof(pMsgSend.szName));
; 16538: 
; 16539: 					DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16540: 
; 16541: 					GCSendDuelScore(gObj[aIndex].m_Index, gObj[iDuelIndex].m_Index);
; 16542: 
; 16543: 					LogAddTD("[Duel] [%s][%s] Duel Started [%s][%s]", gObj[aIndex].AccountID, gObj[aIndex].Name,gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 16544: 				}
; 16545: 			}
; 16546: 			else
; 16547: 			{
; 16548: 				gObj[aIndex].m_iDuelUserRequested = -1;
; 16549: 				gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16550: 				pMsgSend.bDuelStart = false;
; 16551: 
; 16552: 				DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16553: 				return;
; 16554: 			}
; 16555: 		}
; 16556: 		else
; 16557: 		{
; 16558: 			gObj[aIndex].m_iDuelUserRequested = -1;
; 16559: 			gObj[iDuelIndex].m_iDuelUserReserved = -1;
; 16560: 			pMsgSend.bDuelStart = false;
; 16561: 
; 16562: 			DataSend(iDuelIndex, (LPBYTE)&pMsgSend, pMsgSend.h.size);
; 16563: 			return;
; 16564: 		}
; 16565: 	}*/
; 16566: }

  00000	c3		 ret	 0
?CGDuelOkRequestRecv@@YAXPAUPMSG_ANS_DUEL_OK@@H@Z ENDP	; CGDuelOkRequestRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z
_TEXT	SEGMENT
tv300 = -48						; size = 4
_aIndex$GSCopy$1$ = -48					; size = 4
_pMsg$1 = -44						; size = 17
_pMsg$2 = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z PROC ; CGDuelEndRequestRecv, COMDAT

; 16349: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]

; 16350: 	int iDuelIndex = -1;
; 16351: 
; 16352: 	if ( gObj[aIndex].CloseType != -1 ) 

  00013	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	69 f9 40 27 00
	00		 imul	 edi, ecx, 10048
  00021	80 7c 17 0d ff	 cmp	 BYTE PTR [edi+edx+13], -1
  00026	89 4d d0	 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], ecx
  00029	8d 34 17	 lea	 esi, DWORD PTR [edi+edx]
  0002c	0f 85 73 01 00
	00		 jne	 $LN8@CGDuelEndR

; 16353: 		return;
; 16354: 
; 16355: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUserReserved) )

  00032	53		 push	 ebx
  00033	8b 9e 48 12 00
	00		 mov	 ebx, DWORD PTR [esi+4680]
  00039	85 db		 test	 ebx, ebx
  0003b	78 1f		 js	 SHORT $LN3@CGDuelEndR
  0003d	33 c0		 xor	 eax, eax
  0003f	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00045	0f 9e c0	 setle	 al
  00048	85 c0		 test	 eax, eax
  0004a	74 10		 je	 SHORT $LN3@CGDuelEndR

; 16356: 	{
; 16357: 		gObj[aIndex].m_iDuelUserReserved = -1;

  0004c	c7 86 48 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+4680], -1
  00056	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN3@CGDuelEndR:

; 16358: 	}
; 16359: 
; 16360: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUser) )

  0005c	8b 9c 17 50 12
	00 00		 mov	 ebx, DWORD PTR [edi+edx+4688]
  00063	85 db		 test	 ebx, ebx
  00065	0f 88 1f 01 00
	00		 js	 $LN4@CGDuelEndR
  0006b	33 c0		 xor	 eax, eax
  0006d	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00073	0f 9e c0	 setle	 al
  00076	85 c0		 test	 eax, eax
  00078	0f 84 0c 01 00
	00		 je	 $LN4@CGDuelEndR

; 16361: 	{
; 16362: 		iDuelIndex = gObj[aIndex].m_iDuelUser;
; 16363: 		gObj[aIndex].m_iDuelUser = -1;
; 16364: 
; 16365: 		PMSG_ANS_END_DUEL pMsg;
; 16366: 
; 16367: 		pMsg.h.c = 0xC1;
; 16368: 		pMsg.h.headcode = 0xAA;
; 16369: 		pMsg.h.size = sizeof(pMsg);
; 16370: 		pMsg.h.subcode = 0x03;
; 16371: 		pMsg.bResult = 0;
; 16372: 		
; 16373: 		pMsg.NumberH = SET_NUMBERH(iDuelIndex);

  0007e	8b c3		 mov	 eax, ebx

; 16374: 		pMsg.NumberL = SET_NUMBERL(iDuelIndex);
; 16375: 		memcpy(pMsg.szName, gObj[iDuelIndex].Name, sizeof(pMsg.szName));

  00080	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00086	c1 e8 08	 shr	 eax, 8
  00089	88 45 ed	 mov	 BYTE PTR _pMsg$2[ebp+5], al
  0008c	c7 84 17 50 12
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edi+edx+4688], -1
  00097	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009c	c7 45 e8 c1 11
	aa 03		 mov	 DWORD PTR _pMsg$2[ebp], 61477313 ; 03aa11c1H
  000a3	c6 45 ec 00	 mov	 BYTE PTR _pMsg$2[ebp+4], 0
  000a7	88 5d ee	 mov	 BYTE PTR _pMsg$2[ebp+6], bl
  000aa	f3 0f 7e 44 06
	5d		 movq	 xmm0, QWORD PTR [esi+eax+93]
  000b0	66 0f d6 45 ef	 movq	 QWORD PTR _pMsg$2[ebp+7], xmm0
  000b5	66 8b 44 06 65	 mov	 ax, WORD PTR [esi+eax+101]
  000ba	66 89 45 f7	 mov	 WORD PTR _pMsg$2[ebp+15], ax

; 16376: 
; 16377: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000be	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$2[ebp]
  000c1	6a 11		 push	 17			; 00000011H
  000c3	50		 push	 eax
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16378: 
; 16379: 		if ( iDuelIndex == aIndex )

  000ca	8b 4d d0	 mov	 ecx, DWORD PTR _aIndex$GSCopy$1$[ebp]
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d0	3b d9		 cmp	 ebx, ecx
  000d2	0f 84 cc 00 00
	00		 je	 $LN16@CGDuelEndR

; 16387: 		return;
; 16388: 	}
; 16389: 
; 16390: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUser) )

  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000dd	05 50 12 00 00	 add	 eax, 4688		; 00001250H
  000e2	03 c6		 add	 eax, esi
  000e4	89 45 d0	 mov	 DWORD PTR tv300[ebp], eax
  000e7	8b 10		 mov	 edx, DWORD PTR [eax]
  000e9	85 d2		 test	 edx, edx
  000eb	0f 88 b3 00 00
	00		 js	 $LN16@CGDuelEndR
  000f1	33 c0		 xor	 eax, eax
  000f3	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  000f9	0f 9e c0	 setle	 al
  000fc	85 c0		 test	 eax, eax
  000fe	0f 84 a0 00 00
	00		 je	 $LN16@CGDuelEndR

; 16391: 	{
; 16392: 		if ( gObj[iDuelIndex].m_iDuelUser == aIndex )

  00104	3b d1		 cmp	 edx, ecx
  00106	0f 85 98 00 00
	00		 jne	 $LN16@CGDuelEndR

; 16393: 		{
; 16394: 			gObj[iDuelIndex].m_iDuelUser = -1;

  0010c	8b 45 d0	 mov	 eax, DWORD PTR tv300[ebp]

; 16395: 
; 16396: 			PMSG_ANS_END_DUEL pMsg;
; 16397: 
; 16398: 			pMsg.h.c = 0xC1;

  0010f	c7 45 d4 c1 11
	aa 03		 mov	 DWORD PTR _pMsg$1[ebp], 61477313 ; 03aa11c1H

; 16399: 			pMsg.h.headcode = 0xAA;
; 16400: 			pMsg.h.size = sizeof(pMsg);
; 16401: 			pMsg.h.subcode = 0x03;
; 16402: 			pMsg.bResult = 0;

  00116	c6 45 d8 00	 mov	 BYTE PTR _pMsg$1[ebp+4], 0

; 16403: 			pMsg.NumberH = SET_NUMBERH(aIndex);
; 16404: 			pMsg.NumberL = SET_NUMBERL(aIndex);

  0011a	88 4d da	 mov	 BYTE PTR _pMsg$1[ebp+6], cl
  0011d	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00123	8b c1		 mov	 eax, ecx
  00125	c1 e8 08	 shr	 eax, 8
  00128	88 45 d9	 mov	 BYTE PTR _pMsg$1[ebp+5], al

; 16405: 			memcpy(pMsg.szName, gObj[aIndex].Name, sizeof(pMsg.szName));

  0012b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16406: 
; 16407: 			DataSend(iDuelIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00130	6a 11		 push	 17			; 00000011H
  00132	f3 0f 7e 44 07
	5d		 movq	 xmm0, QWORD PTR [edi+eax+93]
  00138	66 0f d6 45 db	 movq	 QWORD PTR _pMsg$1[ebp+7], xmm0
  0013d	66 8b 44 07 65	 mov	 ax, WORD PTR [edi+eax+101]
  00142	66 89 45 e3	 mov	 WORD PTR _pMsg$1[ebp+15], ax
  00146	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00149	50		 push	 eax
  0014a	53		 push	 ebx
  0014b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16408: 
; 16409: 			LogAddTD("[Duel] [%s][%s] Duel Ended [%s][%s]",

  00150	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00155	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00158	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  0015b	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0015e	50		 push	 eax
  0015f	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00162	50		 push	 eax
  00163	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00166	50		 push	 eax
  00167	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  0016a	50		 push	 eax
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@OCKCINJI@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Ended?5?$FL?$CFs?$FN?$FL@
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00176	83 c4 20	 add	 esp, 32			; 00000020H
  00179	5b		 pop	 ebx
  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi

; 16410: 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 16411: 				gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 16412: 		}
; 16413: 	}
; 16414: }

  0017c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017f	33 cd		 xor	 ecx, ebp
  00181	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c3		 ret	 0
$LN4@CGDuelEndR:

; 16380: 		{
; 16381: 			return;
; 16382: 		}
; 16383: 	}
; 16384: 	else
; 16385: 	{
; 16386: 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, iDuelIndex);

  0018a	6a ff		 push	 -1
  0018c	68 02 40 00 00	 push	 16386			; 00004002H
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001a1	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@CGDuelEndR:
  001a4	5b		 pop	 ebx
$LN8@CGDuelEndR:

; 16410: 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 16411: 				gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 16412: 		}
; 16413: 	}
; 16414: }

  001a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a8	5f		 pop	 edi
  001a9	33 cd		 xor	 ecx, ebp
  001ab	5e		 pop	 esi
  001ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b1	8b e5		 mov	 esp, ebp
  001b3	5d		 pop	 ebp
  001b4	c3		 ret	 0
?CGDuelEndRequestRecv@@YAXPAUPMSG_REQ_END_DUEL@@H@Z ENDP ; CGDuelEndRequestRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z
_TEXT	SEGMENT
tv843 = -308						; size = 4
tv837 = -304						; size = 4
_lpMsg$GSCopy$1$ = -304					; size = 4
_pMsg$ = -300						; size = 15
_szTempText$ = -284					; size = 256
_szDuelName$ = -28					; size = 11
_szDuelName2$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z PROC ; CGDuelStartRequestRecv, COMDAT

; 16140: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 16141: 	int iDuelIndex = -1;
; 16142: 	char szTempText[256];
; 16143: 
; 16144: 	if ( gObj[aIndex].CloseType != -1 )

  0001a	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  00020	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	80 7c 01 0d ff	 cmp	 BYTE PTR [ecx+eax+13], -1
  00030	56		 push	 esi
  00031	89 8d cc fe ff
	ff		 mov	 DWORD PTR tv843[ebp], ecx
  00037	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
  0003a	0f 85 e7 03 00
	00		 jne	 $LN1@CGDuelStar

; 16145: 		return;
; 16146: 	
; 16147: 	if ( gNonPK )

  00040	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gNonPK@@3HA, 0 ; gNonPK
  00047	74 2b		 je	 SHORT $LN9@CGDuelStar

; 16148: 	{
; 16149: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 174)), aIndex, 1);

  00049	6a 01		 push	 1
  0004b	53		 push	 ebx
  0004c	68 ae 04 00 00	 push	 1198			; 000004aeH
$LN90@CGDuelStar:
  00051	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00056	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx

; 16345: 		lpObj->AccountID, lpObj->Name, gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 16346: }

  00066	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00069	33 cd		 xor	 ecx, ebp
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN9@CGDuelStar:

; 16150: 		return;
; 16151: 	}
; 16152: 
; 16153: 	if ( !gPkLimitFree )

  00074	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  0007b	75 13		 jne	 SHORT $LN11@CGDuelStar

; 16154: 	{
; 16155: 		if ( gObj[aIndex].m_PK_Level >= 6 )

  0007d	80 be 19 01 00
	00 06		 cmp	 BYTE PTR [esi+281], 6
  00084	7c 0a		 jl	 SHORT $LN11@CGDuelStar

; 16156: 		{
; 16157: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 175)), aIndex, 1);

  00086	6a 01		 push	 1
  00088	53		 push	 ebx
  00089	68 af 04 00 00	 push	 1199			; 000004afH

; 16158: 			return;

  0008e	eb c1		 jmp	 SHORT $LN90@CGDuelStar
$LN11@CGDuelStar:

; 16159: 		}
; 16160: 	}
; 16161: 
; 16162: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUserReserved) )

  00090	8b 8e 48 12 00
	00		 mov	 ecx, DWORD PTR [esi+4680]
  00096	85 c9		 test	 ecx, ecx
  00098	78 34		 js	 SHORT $LN12@CGDuelStar
  0009a	33 c0		 xor	 eax, eax
  0009c	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  000a2	0f 9e c0	 setle	 al
  000a5	85 c0		 test	 eax, eax
  000a7	74 25		 je	 SHORT $LN12@CGDuelStar

; 16163: 	{
; 16164: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 159)), aIndex, 1);

  000a9	6a 01		 push	 1
  000ab	53		 push	 ebx
  000ac	68 9f 04 00 00	 push	 1183			; 0000049fH
$LN91@CGDuelStar:
  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000b6	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16165: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), aIndex, 1);

  000c4	6a 01		 push	 1
  000c6	53		 push	 ebx
  000c7	68 a1 04 00 00	 push	 1185			; 000004a1H

; 16166: 		return;

  000cc	eb 83		 jmp	 SHORT $LN90@CGDuelStar
$LN12@CGDuelStar:

; 16167: 	}
; 16168: 
; 16169: 	if ( OBJMAX_RANGE(gObj[aIndex].m_iDuelUser ) )

  000ce	8b 8e 50 12 00
	00		 mov	 ecx, DWORD PTR [esi+4688]
  000d4	85 c9		 test	 ecx, ecx
  000d6	78 19		 js	 SHORT $LN13@CGDuelStar
  000d8	33 c0		 xor	 eax, eax
  000da	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  000e0	0f 9e c0	 setle	 al
  000e3	85 c0		 test	 eax, eax
  000e5	74 0a		 je	 SHORT $LN13@CGDuelStar

; 16170: 	{
; 16171: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 160)), aIndex, 1);

  000e7	6a 01		 push	 1
  000e9	53		 push	 ebx
  000ea	68 a0 04 00 00	 push	 1184			; 000004a0H

; 16172: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 161)), aIndex, 1);
; 16173: 		return;

  000ef	eb c0		 jmp	 SHORT $LN91@CGDuelStar
$LN13@CGDuelStar:

; 16174: 	}
; 16175: 
; 16176: 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  000f1	8a 86 23 01 00
	00		 mov	 al, BYTE PTR [esi+291]
  000f7	3c 35		 cmp	 al, 53			; 00000035H
  000f9	0f 84 94 04 00
	00		 je	 $LN75@CGDuelStar
  000ff	3c 12		 cmp	 al, 18			; 00000012H
  00101	72 0f		 jb	 SHORT $LN14@CGDuelStar
  00103	b1 17		 mov	 cl, 23			; 00000017H
  00105	3a c8		 cmp	 cl, al
  00107	1b c0		 sbb	 eax, eax
  00109	83 c0 01	 add	 eax, 1
  0010c	0f 85 81 04 00
	00		 jne	 $LN75@CGDuelStar
$LN14@CGDuelStar:

; 16179: 		return;
; 16180: 	}
; 16181: 
; 16182: 	LPOBJ lpObj = &gObj[aIndex];
; 16183: 
; 16184: 	if ( !PacketCheckTime(lpObj ) )

  00112	56		 push	 esi
  00113	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00118	83 c4 04	 add	 esp, 4
  0011b	85 c0		 test	 eax, eax
  0011d	0f 84 04 03 00
	00		 je	 $LN1@CGDuelStar

; 16185: 		return;
; 16186: 
; 16187: 	iDuelIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00123	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00129	57		 push	 edi
  0012a	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0012e	66 c1 e0 08	 shl	 ax, 8
  00132	0f b7 f8	 movzx	 edi, ax
  00135	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00139	0b f8		 or	 edi, eax

; 16188: 
; 16189: 	if ( !OBJMAX_RANGE(iDuelIndex) )

  0013b	0f 8c 28 04 00
	00		 jl	 $LN76@CGDuelStar
  00141	33 c0		 xor	 eax, eax
  00143	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00149	0f 9e c0	 setle	 al
  0014c	85 c0		 test	 eax, eax
  0014e	0f 84 15 04 00
	00		 je	 $LN76@CGDuelStar

; 16192: 		return;
; 16193: 	}
; 16194: 
; 16195: 	if ( iDuelIndex == aIndex  )

  00154	3b fb		 cmp	 edi, ebx
  00156	0f 84 ca 02 00
	00		 je	 $LN87@CGDuelStar

; 16196: 		return;
; 16197: 
; 16198: 	if ( !gPkLimitFree )

  0015c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00163	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00169	75 1d		 jne	 SHORT $LN19@CGDuelStar

; 16199: 	{
; 16200: 		if ( gObj[iDuelIndex].m_PK_Level >= 6 )

  0016b	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  00171	80 bc 10 19 01
	00 00 06	 cmp	 BYTE PTR [eax+edx+281], 6
  00179	7c 0d		 jl	 SHORT $LN19@CGDuelStar

; 16201: 		{
; 16202: 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 176)), aIndex, 1);

  0017b	6a 01		 push	 1
  0017d	53		 push	 ebx
  0017e	68 b0 04 00 00	 push	 1200			; 000004b0H

; 16203: 			return;

  00183	e9 bd 03 00 00	 jmp	 $LN88@CGDuelStar
$LN19@CGDuelStar:

; 16204: 		}
; 16205: 	}
; 16206: 
; 16207: 	char szDuelName[MAX_ACCOUNT_LEN+1]={0};
; 16208: 	char szDuelName2[MAX_ACCOUNT_LEN+1]={0};
; 16209: 	memcpy(szDuelName, gObj[iDuelIndex].Name, MAX_ACCOUNT_LEN);

  00188	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  0018e	0f 57 c0	 xorps	 xmm0, xmm0
  00191	66 0f d6 45 e5	 movq	 QWORD PTR _szDuelName$[ebp+1], xmm0
  00196	66 0f d6 45 f1	 movq	 QWORD PTR _szDuelName2$[ebp+1], xmm0
  0019b	66 c7 45 ed 00
	00		 mov	 WORD PTR _szDuelName$[ebp+9], 0
  001a1	66 c7 45 f9 00
	00		 mov	 WORD PTR _szDuelName2$[ebp+9], 0
  001a7	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv837[ebp], eax

; 16210: 	szDuelName[MAX_ACCOUNT_LEN] = 0;

  001ad	c6 45 ee 00	 mov	 BYTE PTR _szDuelName$[ebp+10], 0

; 16211: 	memcpy(szDuelName2, lpMsg->szName, MAX_ACCOUNT_LEN);
; 16212: 	szDuelName2[MAX_ACCOUNT_LEN] = 0;

  001b1	c6 45 fa 00	 mov	 BYTE PTR _szDuelName2$[ebp+10], 0
  001b5	f3 0f 7e 44 10
	5d		 movq	 xmm0, QWORD PTR [eax+edx+93]
  001bb	0f b7 44 10 65	 movzx	 eax, WORD PTR [eax+edx+101]
  001c0	66 89 45 ec	 mov	 WORD PTR _szDuelName$[ebp+8], ax
  001c4	0f b7 41 0d	 movzx	 eax, WORD PTR [ecx+13]
  001c8	66 0f d6 45 e4	 movq	 QWORD PTR _szDuelName$[ebp], xmm0
  001cd	f3 0f 7e 41 05	 movq	 xmm0, QWORD PTR [ecx+5]

; 16213: 
; 16214: 	if ( strcmp(szDuelName, szDuelName2) )

  001d2	8d 4d f0	 lea	 ecx, DWORD PTR _szDuelName2$[ebp]
  001d5	66 89 45 f8	 mov	 WORD PTR _szDuelName2$[ebp+8], ax
  001d9	8d 45 e4	 lea	 eax, DWORD PTR _szDuelName$[ebp]
  001dc	66 0f d6 45 f0	 movq	 QWORD PTR _szDuelName2$[ebp], xmm0
$LL81@CGDuelStar:
  001e1	8a 10		 mov	 dl, BYTE PTR [eax]
  001e3	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001e5	75 1a		 jne	 SHORT $LN82@CGDuelStar
  001e7	84 d2		 test	 dl, dl
  001e9	74 12		 je	 SHORT $LN83@CGDuelStar
  001eb	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001ee	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001f1	75 0e		 jne	 SHORT $LN82@CGDuelStar
  001f3	83 c0 02	 add	 eax, 2
  001f6	83 c1 02	 add	 ecx, 2
  001f9	84 d2		 test	 dl, dl
  001fb	75 e4		 jne	 SHORT $LL81@CGDuelStar
$LN83@CGDuelStar:
  001fd	33 c0		 xor	 eax, eax
  001ff	eb 05		 jmp	 SHORT $LN84@CGDuelStar
$LN82@CGDuelStar:
  00201	1b c0		 sbb	 eax, eax
  00203	83 c8 01	 or	 eax, 1
$LN84@CGDuelStar:
  00206	85 c0		 test	 eax, eax
  00208	74 0d		 je	 SHORT $LN20@CGDuelStar

; 16215: 	{
; 16216: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 162)), aIndex, 1);

  0020a	6a 01		 push	 1
  0020c	53		 push	 ebx
  0020d	68 a2 04 00 00	 push	 1186			; 000004a2H

; 16217: 		return;

  00212	e9 2e 03 00 00	 jmp	 $LN88@CGDuelStar
$LN20@CGDuelStar:

; 16218: 	}
; 16219: 
; 16220: 	if ( IsDuelEnable(iDuelIndex) == FALSE )

  00217	57		 push	 edi
  00218	e8 00 00 00 00	 call	 ?IsDuelEnable@@YA_NH@Z	; IsDuelEnable
  0021d	83 c4 04	 add	 esp, 4
  00220	84 c0		 test	 al, al
  00222	75 0d		 jne	 SHORT $LN21@CGDuelStar

; 16221: 	{
; 16222: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 163)), aIndex, 1);

  00224	6a 01		 push	 1
  00226	53		 push	 ebx
  00227	68 a3 04 00 00	 push	 1187			; 000004a3H

; 16223: 		return;

  0022c	e9 14 03 00 00	 jmp	 $LN88@CGDuelStar
$LN21@CGDuelStar:

; 16224: 	}
; 16225: 
; 16226: 	if ( lpObj->lpGuild && lpObj->lpGuild->WarState == 1 )

  00231	8b 86 18 06 00
	00		 mov	 eax, DWORD PTR [esi+1560]
  00237	85 c0		 test	 eax, eax
  00239	74 16		 je	 SHORT $LN22@CGDuelStar
  0023b	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  00242	75 0d		 jne	 SHORT $LN22@CGDuelStar

; 16227: 	{
; 16228: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 164)), aIndex, 1);

  00244	6a 01		 push	 1
  00246	53		 push	 ebx
  00247	68 a4 04 00 00	 push	 1188			; 000004a4H

; 16229: 		return;

  0024c	e9 f4 02 00 00	 jmp	 $LN88@CGDuelStar
$LN22@CGDuelStar:

; 16230: 	}
; 16231: 
; 16232: 	if ( gObj[iDuelIndex].lpGuild && gObj[iDuelIndex].lpGuild->WarState == 1 )

  00251	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00256	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv837[ebp]
  0025c	8b 84 01 18 06
	00 00		 mov	 eax, DWORD PTR [ecx+eax+1560]
  00263	85 c0		 test	 eax, eax
  00265	74 16		 je	 SHORT $LN23@CGDuelStar
  00267	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  0026e	75 0d		 jne	 SHORT $LN23@CGDuelStar

; 16233: 	{
; 16234: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 165)), aIndex, 1);

  00270	6a 01		 push	 1
  00272	53		 push	 ebx
  00273	68 a5 04 00 00	 push	 1189			; 000004a5H

; 16235: 		return;

  00278	e9 c8 02 00 00	 jmp	 $LN88@CGDuelStar
$LN23@CGDuelStar:

; 16236: 	}
; 16237: 
; 16238: 	if ( gObjIsConnected(iDuelIndex) == FALSE )

  0027d	57		 push	 edi
  0027e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00283	83 c4 04	 add	 esp, 4
  00286	85 c0		 test	 eax, eax
  00288	0f 84 98 01 00
	00		 je	 $LN87@CGDuelStar

; 16239: 		return;
; 16240: 
; 16241: 	if ( gObj[iDuelIndex].Type == OBJ_MONSTER )

  0028e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00294	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv837[ebp]
  0029a	80 7c 10 50 02	 cmp	 BYTE PTR [eax+edx+80], 2
  0029f	0f 84 81 01 00
	00		 je	 $LN87@CGDuelStar

; 16242: 		return;
; 16243: 
; 16244: 	if ( gObj[iDuelIndex].CloseCount >= 0 )

  002a5	80 7c 10 0c 00	 cmp	 BYTE PTR [eax+edx+12], 0
  002aa	0f 8d 76 01 00
	00		 jge	 $LN87@CGDuelStar

; 16245: 		return;
; 16246: 
; 16247: 	BOOL bRetVal = FALSE;
; 16248: 
; 16249: 	int n;
; 16250: 	for (n=0;n<MAX_SELF_DEFENSE;n++)

  002b0	33 c9		 xor	 ecx, ecx
  002b2	8d 86 c4 05 00
	00		 lea	 eax, DWORD PTR [esi+1476]
  002b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@CGDuelStar:

; 16251: 	{
; 16252: 		if ( lpObj->SelfDefense[n] >= 0 )

  002c0	83 38 00	 cmp	 DWORD PTR [eax], 0
  002c3	0f 8d 74 02 00
	00		 jge	 $LN67@CGDuelStar

; 16245: 		return;
; 16246: 
; 16247: 	BOOL bRetVal = FALSE;
; 16248: 
; 16249: 	int n;
; 16250: 	for (n=0;n<MAX_SELF_DEFENSE;n++)

  002c9	41		 inc	 ecx
  002ca	83 c0 04	 add	 eax, 4
  002cd	83 f9 07	 cmp	 ecx, 7
  002d0	7c ee		 jl	 SHORT $LL4@CGDuelStar

; 16262: 		return;
; 16263: 	}
; 16264: 
; 16265: 	for (n=0;n<MAX_SELF_DEFENSE;n++)

  002d2	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv837[ebp]
  002d8	33 c9		 xor	 ecx, ecx
  002da	05 c4 05 00 00	 add	 eax, 1476		; 000005c4H
  002df	03 c2		 add	 eax, edx
$LL7@CGDuelStar:

; 16266: 	{
; 16267: 		if ( gObj[iDuelIndex].SelfDefense[n] >= 0 )

  002e1	83 38 00	 cmp	 DWORD PTR [eax], 0
  002e4	0f 8d 53 02 00
	00		 jge	 $LN67@CGDuelStar

; 16262: 		return;
; 16263: 	}
; 16264: 
; 16265: 	for (n=0;n<MAX_SELF_DEFENSE;n++)

  002ea	41		 inc	 ecx
  002eb	83 c0 04	 add	 eax, 4
  002ee	83 f9 07	 cmp	 ecx, 7
  002f1	7c ee		 jl	 SHORT $LL7@CGDuelStar

; 16268: 		{
; 16269: 			bRetVal = TRUE;
; 16270: 			break;
; 16271: 		}
; 16272: 	}
; 16273: 
; 16274: 	if ( bRetVal )
; 16275: 	{
; 16276: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 189)), aIndex, 1);
; 16277: 		return;
; 16278: 	}
; 16279: 
; 16280: 	if ( DS_MAP_RANGE(gObj[iDuelIndex].MapNumber ) )

  002f3	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv837[ebp]
  002f9	8a 8c 10 23 01
	00 00		 mov	 cl, BYTE PTR [eax+edx+291]
  00300	80 f9 09	 cmp	 cl, 9
  00303	0f 84 2a 02 00
	00		 je	 $LN79@CGDuelStar
  00309	33 c0		 xor	 eax, eax
  0030b	80 f9 20	 cmp	 cl, 32			; 00000020H
  0030e	0f 94 c0	 sete	 al
  00311	85 c0		 test	 eax, eax
  00313	0f 85 1a 02 00
	00		 jne	 $LN79@CGDuelStar

; 16284: 	}
; 16285: 
; 16286: 	if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) )

  00319	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR tv843[ebp]
  0031f	8a 84 10 23 01
	00 00		 mov	 al, BYTE PTR [eax+edx+291]
  00326	3c 34		 cmp	 al, 52			; 00000034H
  00328	0f 84 fb 01 00
	00		 je	 $LN80@CGDuelStar
  0032e	3c 0b		 cmp	 al, 11			; 0000000bH
  00330	72 0f		 jb	 SHORT $LN32@CGDuelStar
  00332	b1 11		 mov	 cl, 17			; 00000011H
  00334	3a c8		 cmp	 cl, al
  00336	1b c0		 sbb	 eax, eax
  00338	83 c0 01	 add	 eax, 1
  0033b	0f 85 e8 01 00
	00		 jne	 $LN80@CGDuelStar
$LN32@CGDuelStar:

; 16290: 	}
; 16291: 
; 16292: 	if ( lpObj->m_IfState.use > 0 )

  00341	f6 86 b8 11 00
	00 03		 test	 BYTE PTR [esi+4536], 3
  00348	76 0d		 jbe	 SHORT $LN33@CGDuelStar

; 16293: 	{
; 16294: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 167)), aIndex, 1);

  0034a	6a 01		 push	 1
  0034c	53		 push	 ebx
  0034d	68 a7 04 00 00	 push	 1191			; 000004a7H

; 16295: 		return;

  00352	e9 ee 01 00 00	 jmp	 $LN88@CGDuelStar
$LN33@CGDuelStar:

; 16296: 	}
; 16297: 
; 16298: 	if ( gObj[iDuelIndex].m_IfState.use > 0 )

  00357	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv837[ebp]
  0035d	f6 84 10 b8 11
	00 00 03	 test	 BYTE PTR [eax+edx+4536], 3
  00365	76 10		 jbe	 SHORT $LN34@CGDuelStar

; 16299: 	{
; 16300: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 168)), gObj[iDuelIndex].Name);

  00367	83 c0 5d	 add	 eax, 93			; 0000005dH
  0036a	03 c2		 add	 eax, edx
  0036c	50		 push	 eax
  0036d	68 a8 04 00 00	 push	 1192			; 000004a8H

; 16301: 		GCServerMsgStringSend(szTempText, aIndex, 1);
; 16302: 		return;

  00372	e9 85 00 00 00	 jmp	 $LN89@CGDuelStar
$LN34@CGDuelStar:

; 16303: 	}
; 16304: 
; 16305: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUserRequested) )

  00377	8b 8c 10 4c 12
	00 00		 mov	 ecx, DWORD PTR [eax+edx+4684]
  0037e	85 c9		 test	 ecx, ecx
  00380	78 22		 js	 SHORT $LN35@CGDuelStar
  00382	33 c0		 xor	 eax, eax
  00384	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0038a	0f 9e c0	 setle	 al
  0038d	85 c0		 test	 eax, eax

; 16306: 	{
; 16307: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 169)), gObj[iDuelIndex].Name);

  0038f	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv837[ebp]
  00395	74 0d		 je	 SHORT $LN35@CGDuelStar
  00397	83 c0 5d	 add	 eax, 93			; 0000005dH
  0039a	03 c2		 add	 eax, edx
  0039c	50		 push	 eax
  0039d	68 a9 04 00 00	 push	 1193			; 000004a9H

; 16308: 		GCServerMsgStringSend(szTempText, aIndex, 1);
; 16309: 		return;

  003a2	eb 58		 jmp	 SHORT $LN89@CGDuelStar
$LN35@CGDuelStar:

; 16310: 	}
; 16311: 
; 16312: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUserReserved) )

  003a4	8b 8c 10 48 12
	00 00		 mov	 ecx, DWORD PTR [eax+edx+4680]
  003ab	85 c9		 test	 ecx, ecx
  003ad	78 22		 js	 SHORT $LN36@CGDuelStar
  003af	33 c0		 xor	 eax, eax
  003b1	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  003b7	0f 9e c0	 setle	 al
  003ba	85 c0		 test	 eax, eax

; 16313: 	{
; 16314: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 170)), gObj[iDuelIndex].Name);

  003bc	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv837[ebp]
  003c2	74 0d		 je	 SHORT $LN36@CGDuelStar
  003c4	83 c0 5d	 add	 eax, 93			; 0000005dH
  003c7	03 c2		 add	 eax, edx
  003c9	50		 push	 eax
  003ca	68 aa 04 00 00	 push	 1194			; 000004aaH

; 16315: 		GCServerMsgStringSend(szTempText, aIndex, 1);
; 16316: 		return;

  003cf	eb 2b		 jmp	 SHORT $LN89@CGDuelStar
$LN36@CGDuelStar:

; 16317: 	}
; 16318: 
; 16319: 	if ( OBJMAX_RANGE(gObj[iDuelIndex].m_iDuelUser) )

  003d1	8b 8c 10 50 12
	00 00		 mov	 ecx, DWORD PTR [eax+edx+4688]
  003d8	85 c9		 test	 ecx, ecx
  003da	78 5b		 js	 SHORT $LN37@CGDuelStar
  003dc	33 c0		 xor	 eax, eax
  003de	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  003e4	0f 9e c0	 setle	 al
  003e7	85 c0		 test	 eax, eax
  003e9	74 4c		 je	 SHORT $LN37@CGDuelStar

; 16320: 	{
; 16321: 		wsprintf(szTempText, lMsg.Get(MSGGET(4, 171)), gObj[iDuelIndex].Name);

  003eb	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv837[ebp]
  003f1	83 c0 5d	 add	 eax, 93			; 0000005dH
  003f4	03 c2		 add	 eax, edx
  003f6	50		 push	 eax
  003f7	68 ab 04 00 00	 push	 1195			; 000004abH
$LN89@CGDuelStar:
  003fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00401	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00406	50		 push	 eax
  00407	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  0040d	50		 push	 eax
  0040e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 16322: 		GCServerMsgStringSend(szTempText, aIndex, 1);

  00414	6a 01		 push	 1
  00416	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  0041c	53		 push	 ebx
  0041d	50		 push	 eax
  0041e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00423	83 c4 18	 add	 esp, 24			; 00000018H
$LN87@CGDuelStar:
  00426	5f		 pop	 edi
$LN1@CGDuelStar:
  00427	5e		 pop	 esi
  00428	5b		 pop	 ebx

; 16345: 		lpObj->AccountID, lpObj->Name, gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 16346: }

  00429	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0042c	33 cd		 xor	 ecx, ebp
  0042e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00433	8b e5		 mov	 esp, ebp
  00435	5d		 pop	 ebp
  00436	c3		 ret	 0
$LN37@CGDuelStar:

; 16323: 		return;
; 16324: 	}
; 16325: 
; 16326: 	lpObj->m_iDuelUserReserved = iDuelIndex;
; 16327: 	lpObj->m_iDuelUser = -1;
; 16328: 	gObj[iDuelIndex].m_iDuelUserRequested = aIndex;

  00437	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv837[ebp]
  0043d	89 be 48 12 00
	00		 mov	 DWORD PTR [esi+4680], edi
  00443	c7 86 50 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+4688], -1
  0044d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16329: 
; 16330: 	PMSG_REQ_DUEL_OK pMsg;
; 16331: 
; 16332: 	pMsg.h.c = 0xC1;
; 16333: 	pMsg.h.headcode = 0xAC;
; 16334: 	pMsg.h.size = sizeof(pMsg);
; 16335: 	pMsg.NumberH = SET_NUMBERH(aIndex);
; 16336: 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 16337: 	memcpy(pMsg.szName, gObj[aIndex].Name, sizeof(pMsg.szName));
; 16338: 
; 16339: 	DataSend(iDuelIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00452	6a 0f		 push	 15			; 0000000fH
  00454	89 9c 01 4c 12
	00 00		 mov	 DWORD PTR [ecx+eax+4684], ebx
  0045b	8b c3		 mov	 eax, ebx
  0045d	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv843[ebp]
  00463	c1 e8 08	 shr	 eax, 8
  00466	88 85 d7 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+3], al
  0046c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00471	66 c7 85 d4 fe
	ff ff c1 0f	 mov	 WORD PTR _pMsg$[ebp], 4033 ; 00000fc1H
  0047a	c6 85 d6 fe ff
	ff ac		 mov	 BYTE PTR _pMsg$[ebp+2], 172 ; 000000acH
  00481	88 9d d8 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], bl
  00487	f3 0f 7e 44 01
	5d		 movq	 xmm0, QWORD PTR [ecx+eax+93]
  0048d	66 0f d6 85 d9
	fe ff ff	 movq	 QWORD PTR _pMsg$[ebp+5], xmm0
  00495	66 8b 44 01 65	 mov	 ax, WORD PTR [ecx+eax+101]
  0049a	66 89 85 e1 fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+13], ax
  004a1	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  004a7	50		 push	 eax
  004a8	57		 push	 edi
  004a9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16340: 
; 16341: 	wsprintf(szTempText, lMsg.Get(MSGGET(4, 172)), gObj[iDuelIndex].Name);

  004ae	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b6	8b bd d0 fe ff
	ff		 mov	 edi, DWORD PTR tv837[ebp]
  004bc	83 c0 5d	 add	 eax, 93			; 0000005dH
  004bf	03 c7		 add	 eax, edi
  004c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004c6	50		 push	 eax
  004c7	68 ac 04 00 00	 push	 1196			; 000004acH
  004cc	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  004d1	50		 push	 eax
  004d2	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  004d8	50		 push	 eax
  004d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 16342: 	GCServerMsgStringSend(szTempText, aIndex, 1);

  004df	6a 01		 push	 1
  004e1	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szTempText$[ebp]
  004e7	53		 push	 ebx
  004e8	50		 push	 eax
  004e9	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 16343: 
; 16344: 	LogAddTD("[Duel] [%s][%s] Requested to Start Duel to [%s][%s]",

  004ee	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  004f1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004f7	50		 push	 eax
  004f8	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  004fb	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00501	50		 push	 eax
  00502	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00505	50		 push	 eax
  00506	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00509	50		 push	 eax
  0050a	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@
  0050f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00515	83 c4 2c	 add	 esp, 44			; 0000002cH
  00518	5f		 pop	 edi
  00519	5e		 pop	 esi
  0051a	5b		 pop	 ebx

; 16345: 		lpObj->AccountID, lpObj->Name, gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 16346: }

  0051b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0051e	33 cd		 xor	 ecx, ebp
  00520	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00525	8b e5		 mov	 esp, ebp
  00527	5d		 pop	 ebp
  00528	c3		 ret	 0
$LN80@CGDuelStar:

; 16287: 	{
; 16288: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 166)), aIndex, 1);

  00529	6a 01		 push	 1
  0052b	53		 push	 ebx
  0052c	68 a6 04 00 00	 push	 1190			; 000004a6H

; 16289: 		return;

  00531	eb 12		 jmp	 SHORT $LN88@CGDuelStar
$LN79@CGDuelStar:

; 16281: 	{
; 16282: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 180)), aIndex, 1);

  00533	6a 01		 push	 1
  00535	53		 push	 ebx
  00536	68 b4 04 00 00	 push	 1204			; 000004b4H

; 16283: 		return;

  0053b	eb 08		 jmp	 SHORT $LN88@CGDuelStar
$LN67@CGDuelStar:

; 16253: 		{
; 16254: 			bRetVal = TRUE;
; 16255: 			break;
; 16256: 		}
; 16257: 	}
; 16258: 
; 16259: 	if ( bRetVal )
; 16260: 	{
; 16261: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 189)), aIndex, 1);

  0053d	6a 01		 push	 1
  0053f	53		 push	 ebx
  00540	68 bd 04 00 00	 push	 1213			; 000004bdH
$LN88@CGDuelStar:
  00545	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0054a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0054f	50		 push	 eax
  00550	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00555	83 c4 0c	 add	 esp, 12			; 0000000cH
  00558	5f		 pop	 edi
  00559	5e		 pop	 esi
  0055a	5b		 pop	 ebx

; 16345: 		lpObj->AccountID, lpObj->Name, gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 16346: }

  0055b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0055e	33 cd		 xor	 ecx, ebp
  00560	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00565	8b e5		 mov	 esp, ebp
  00567	5d		 pop	 ebp
  00568	c3		 ret	 0
$LN76@CGDuelStar:

; 16190: 	{
; 16191: 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, iDuelIndex);

  00569	57		 push	 edi
  0056a	68 3f 3f 00 00	 push	 16191			; 00003f3fH
  0056f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00574	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  00579	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 16345: 		lpObj->AccountID, lpObj->Name, gObj[iDuelIndex].AccountID, gObj[iDuelIndex].Name);
; 16346: }

  0057f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00582	83 c4 10	 add	 esp, 16			; 00000010H
  00585	33 cd		 xor	 ecx, ebp
  00587	5f		 pop	 edi
  00588	5e		 pop	 esi
  00589	5b		 pop	 ebx
  0058a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0058f	8b e5		 mov	 esp, ebp
  00591	5d		 pop	 ebp
  00592	c3		 ret	 0
$LN75@CGDuelStar:

; 16177: 	{
; 16178: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 207)), aIndex, 1);

  00593	6a 01		 push	 1
  00595	53		 push	 ebx
  00596	68 cf 04 00 00	 push	 1231			; 000004cfH
  0059b	e9 b1 fa ff ff	 jmp	 $LN90@CGDuelStar
?CGDuelStartRequestRecv@@YAXPAUPMSG_REQ_START_DUEL@@H@Z ENDP ; CGDuelStartRequestRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCNPggCheckSumRecv@@YAXPAUPMSG_NPROTECTGGCHECKSUM@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCNPggCheckSumRecv@@YAXPAUPMSG_NPROTECTGGCHECKSUM@@H@Z PROC ; GCNPggCheckSumRecv, COMDAT

; 16092: 	/*LPOBJ lpObj = &gObj[aIndex];
; 16093: 
; 16094: 	if ( !gObjIsConnected(aIndex))
; 16095: 		return;
; 16096: 
; 16097: 	LogAddTD("[NPgg] Recv Checksum = %x,AuthValue = %x [%s][%s]",
; 16098: 		lpMsg->m_ggadCheckSum.dwIndex, lpObj->NPggCSAuth.m_AuthAnswer.dwIndex,
; 16099: 		lpObj->AccountID, lpObj->Name);
; 16100: 
; 16101: 	memcpy(&gObj[aIndex].NPggCSAuth.m_AuthAnswer, &lpMsg->m_ggadCheckSum, sizeof(lpObj->NPggCSAuth.m_AuthAnswer));
; 16102: 
; 16103: 	DWORD dwGGErrCode = gObj[aIndex].NPggCSAuth.CheckAuthAnswer();
; 16104: 
; 16105: 	if ( dwGGErrCode )
; 16106: 	{
; 16107: 		LogAddTD("[NPgg] Invalid Checksum Detect Checksum = %x,AuthValue = %x [%s][%s]",
; 16108: 			lpMsg->m_ggadCheckSum.dwIndex, lpObj->NPggCSAuth.m_AuthAnswer.dwIndex,
; 16109: 			lpObj->AccountID, lpObj->Name);
; 16110: 
; 16111: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 177)), aIndex, 0);
; 16112: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 178)), aIndex, 0);
; 16113: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 179)), aIndex, 0);
; 16114: 
; 16115: 		CloseClient(aIndex);
; 16116: 
; 16117: 		return;
; 16118: 	}
; 16119: 
; 16120: 	lpObj->m_NPggCheckSumSendTime = GetTickCount();
; 16121: 	lpObj->m_bSentGGAuth = false;
; 16122: 
; 16123: 	LogAddTD("[NPgg] Checksum Clear %x [%s][%s]",
; 16124: 		lpMsg->m_ggadCheckSum.dwIndex, lpObj->AccountID, lpObj->Name);
; 16125: 		*/
; 16126: }

  00000	c3		 ret	 0
?GCNPggCheckSumRecv@@YAXPAUPMSG_NPROTECTGGCHECKSUM@@H@Z ENDP ; GCNPggCheckSumRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pggAuthData$ = 12					; size = 4
?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z PROC	; GCNPggSendCheckSum, COMDAT

; 16078: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _pggAuthData$[ebp]

; 16079: 	PMSG_NPROTECTGGCHECKSUM pMsg;
; 16080: 
; 16081: 	PHeadSetBE((LPBYTE)&pMsg, 0x73, sizeof(pMsg));

  00014	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 14		 push	 20			; 00000014H
  00019	6a 73		 push	 115			; 00000073H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 16082: 	memcpy(&pMsg.m_ggadCheckSum, pggAuthData, sizeof(pMsg.m_ggadCheckSum));

  00021	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]

; 16083: 
; 16084: 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00024	6a 14		 push	 20			; 00000014H
  00026	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	50		 push	 eax
  0002a	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0002d	0f 11 45 ec	 movups	 XMMWORD PTR _pMsg$[ebp+4], xmm0
  00031	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16085: }

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00039	83 c4 18	 add	 esp, 24			; 00000018H
  0003c	33 cd		 xor	 ecx, ebp
  0003e	5e		 pop	 esi
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?GCNPggSendCheckSum@@YAXHPAU_GG_AUTH_DATA@@@Z ENDP	; GCNPggSendCheckSum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z PROC ; GCPacketCheckSumRecv, COMDAT

; 16070: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16071: 	gPacketCheckSum.AddCheckSum(aIndex, aRecv->funcindex, aRecv->CheckSum);

  00003	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?gPacketCheckSum@@3VCPacketCheckSum@@A ; gPacketCheckSum
  0000b	ff 70 04	 push	 DWORD PTR [eax+4]
  0000e	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00012	50		 push	 eax
  00013	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  00016	e8 00 00 00 00	 call	 ?AddCheckSum@CPacketCheckSum@@QAEXHHK@Z ; CPacketCheckSum::AddCheckSum

; 16072: }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ENDP ; GCPacketCheckSumRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z
_TEXT	SEGMENT
_pResult$ = -24						; size = 4
_pCharTransfer$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z PROC ; CGReqMoveOtherServer, COMDAT

; 16018: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 16019: 	if ( !gEnableServerDivision)

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gEnableServerDivision@@3HA, 0 ; gEnableServerDivision
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  0001b	56		 push	 esi
  0001c	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001f	0f 84 23 01 00
	00		 je	 $LN1@CGReqMoveO

; 16020: 		return;
; 16021: 
; 16022: 	if ( !gObjIsConnectedGP(aIndex))

  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	75 2a		 jne	 SHORT $LN3@CGReqMoveO

; 16023: 	{
; 16024: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00032	68 98 3e 00 00	 push	 16024			; 00003e98H
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00041	6a 02		 push	 2
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00049	83 c4 10	 add	 esp, 16			; 00000010H
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx

; 16063: 		lpObj->AccountID, lpObj->Name);
; 16064: }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	33 cd		 xor	 ecx, ebp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN3@CGReqMoveO:
  0005c	57		 push	 edi

; 16025: 		return;
; 16026: 	}
; 16027: 
; 16028: 	LPOBJ lpObj = &gObj[aIndex];

  0005d	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00063	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 16029: 
; 16030: 	if ( lpObj->m_MoveOtherServer )

  00069	80 bf 68 14 00
	00 00		 cmp	 BYTE PTR [edi+5224], 0
  00070	0f 85 d1 00 00
	00		 jne	 $LN7@CGReqMoveO

; 16031: 		return;
; 16032: 
; 16033: 	lpObj->m_MoveOtherServer = true;
; 16034: 
; 16035: 	PMSG_DEFRESULT pResult;
; 16036: 	PHeadSetB((LPBYTE)&pResult, 0x99, sizeof(pResult));

  00076	6a 04		 push	 4
  00078	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0007b	c6 87 68 14 00
	00 01		 mov	 BYTE PTR [edi+5224], 1
  00082	68 99 00 00 00	 push	 153			; 00000099H
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16037: 	
; 16038: 	if ( !gObjJoominCheck(aIndex, lpMsg->LastJoominNumber))

  0008d	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  00090	50		 push	 eax
  00091	56		 push	 esi
  00092	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	85 c0		 test	 eax, eax
  0009c	75 4e		 jne	 SHORT $LN5@CGReqMoveO

; 16039: 	{
; 16040: 		pResult.result = 0;

  0009e	88 45 eb	 mov	 BYTE PTR _pResult$[ebp+3], al

; 16041: 
; 16042: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000a1	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000a5	50		 push	 eax
  000a6	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  000a9	50		 push	 eax
  000aa	56		 push	 esi
  000ab	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 16043: 		lpObj->m_MoveOtherServer = false;
; 16044: 
; 16045: 		LogAddTD("[CharTrasfer] Fail (JoominNumber) [%s][%s]",

  000b0	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  000b3	c6 87 68 14 00
	00 00		 mov	 BYTE PTR [edi+5224], 0
  000ba	50		 push	 eax
  000bb	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  000be	50		 push	 eax
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NFPFJCOO@?$FLCharTrasfer?$FN?5Fail?5?$CIJoominNumber@
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 16046: 			lpObj->AccountID, lpObj->Name);
; 16047: 
; 16048: 		GCServerMsgStringSend("  change@webzen.co.kr  ", lpObj->m_Index, 1);

  000ca	6a 01		 push	 1
  000cc	ff 37		 push	 DWORD PTR [edi]
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@PPPCGFPL@?$LJ?$KO?A?$KG?5?$LJ?$NP?$LL?$PN?$LN?C?5change?$EAwebzen?4co?4kr?$LH@
  000d3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000d8	83 c4 24	 add	 esp, 36			; 00000024H
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx

; 16063: 		lpObj->AccountID, lpObj->Name);
; 16064: }

  000de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e1	33 cd		 xor	 ecx, ebp
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
$LN5@CGReqMoveO:

; 16049: 
; 16050: 		return;
; 16051: 	}
; 16052: 
; 16053: 	SDHP_CHARACTER_TRANSFER pCharTransfer;
; 16054: 
; 16055: 	GJSetCharacterInfo(lpObj, lpObj->m_Index, FALSE);

  000ec	6a 01		 push	 1
  000ee	6a 00		 push	 0
  000f0	ff 37		 push	 DWORD PTR [edi]
  000f2	57		 push	 edi
  000f3	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAUOBJECTSTRUCT@@HHH@Z ; GJSetCharacterInfo

; 16056: 	PHeadSetB((LPBYTE)&pCharTransfer, 0xCF, sizeof(pCharTransfer));

  000f8	6a 10		 push	 16			; 00000010H
  000fa	8d 45 ec	 lea	 eax, DWORD PTR _pCharTransfer$[ebp]
  000fd	68 cf 00 00 00	 push	 207			; 000000cfH
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 16057: 	pCharTransfer.Number = aIndex;

  00108	66 89 75 fa	 mov	 WORD PTR _pCharTransfer$[ebp+14], si
  0010c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 16058: 	memcpy(pCharTransfer.Account, lpObj->AccountID, sizeof(pCharTransfer.Account));

  0010f	f3 0f 7e 47 52	 movq	 xmm0, QWORD PTR [edi+82]
  00114	8d 77 52	 lea	 esi, DWORD PTR [edi+82]
  00117	66 0f d6 45 ef	 movq	 QWORD PTR _pCharTransfer$[ebp+3], xmm0

; 16059: 
; 16060: 	cDBSMng.Send((PCHAR)&pCharTransfer, sizeof(pCharTransfer));

  0011c	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00121	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  00125	66 89 45 f7	 mov	 WORD PTR _pCharTransfer$[ebp+11], ax
  00129	8d 45 ec	 lea	 eax, DWORD PTR _pCharTransfer$[ebp]
  0012c	6a 10		 push	 16			; 00000010H
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 16061: 
; 16062: 	LogAddTD("[CharTrasfer] Request Character Trasfer [%s][%s]",

  00134	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00137	50		 push	 eax
  00138	56		 push	 esi
  00139	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HNLHIMNJ@?$FLCharTrasfer?$FN?5Request?5Character?5@
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00144	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CGReqMoveO:
  00147	5f		 pop	 edi
$LN1@CGReqMoveO:

; 16063: 		lpObj->AccountID, lpObj->Name);
; 16064: }

  00148	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014b	5e		 pop	 esi
  0014c	33 cd		 xor	 ecx, ebp
  0014e	5b		 pop	 ebx
  0014f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z ENDP ; CGReqMoveOtherServer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z PROC ; CGRequestLottoRegister, COMDAT

; 15981: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]

; 15982: 	PMSG_REQ_2ANIV_SERIAL pMsg;
; 15983: 
; 15984: 	PHeadSetB((LPBYTE)&pMsg, 0x08, sizeof(pMsg));

  00014	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001c	6a 28		 push	 40			; 00000028H
  0001e	6a 08		 push	 8
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15985: 
; 15986: 	if ( gObj[aIndex].UseEventServer )

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00034	83 bc 06 e8 13
	00 00 00	 cmp	 DWORD PTR [esi+eax+5096], 0
  0003c	0f 85 88 00 00
	00		 jne	 $LN1@CGRequestL

; 15987: 		return;
; 15988: 
; 15989: 	gObj[aIndex].UseEventServer = TRUE;

  00042	c7 84 06 e8 13
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+5096], 1

; 15990: 	pMsg.iINDEX = aIndex;
; 15991: 	pMsg.iMEMB_GUID = gObj[aIndex].DBNumber;

  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00053	89 7d d8	 mov	 DWORD PTR _pMsg$[ebp+4], edi

; 15992: 	memcpy(pMsg.szUID, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);
; 15993: 	pMsg.szUID[MAX_ACCOUNT_LEN] = 0;
; 15994: 	memcpy(pMsg.SERIAL1, lpMsg->SERIAL1, 4);
; 15995: 	pMsg.SERIAL1[4] = 0;
; 15996: 	memcpy(pMsg.SERIAL2, lpMsg->SERIAL2, 4);
; 15997: 	pMsg.SERIAL2[4] = 0;
; 15998: 	memcpy(pMsg.SERIAL3, lpMsg->SERIAL3, 4);
; 15999: 	pMsg.SERIAL3[4] = 0;
; 16000: 
; 16001: 	DataSendEventChip((PCHAR)&pMsg, sizeof(pMsg));

  00056	6a 28		 push	 40			; 00000028H
  00058	8b 44 31 30	 mov	 eax, DWORD PTR [ecx+esi+48]
  0005c	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+36], eax
  0005f	f3 0f 7e 44 31
	52		 movq	 xmm0, QWORD PTR [ecx+esi+82]
  00065	66 0f d6 45 dc	 movq	 QWORD PTR _pMsg$[ebp+8], xmm0
  0006a	66 8b 44 31 5a	 mov	 ax, WORD PTR [ecx+esi+90]
  0006f	66 89 45 e4	 mov	 WORD PTR _pMsg$[ebp+16], ax
  00073	8b 43 03	 mov	 eax, DWORD PTR [ebx+3]
  00076	89 45 e7	 mov	 DWORD PTR _pMsg$[ebp+19], eax
  00079	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0007c	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  0007f	8b 43 0d	 mov	 eax, DWORD PTR [ebx+13]
  00082	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+29], eax
  00085	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00088	50		 push	 eax
  00089	c6 45 e6 00	 mov	 BYTE PTR _pMsg$[ebp+18], 0
  0008d	c6 45 eb 00	 mov	 BYTE PTR _pMsg$[ebp+23], 0
  00091	c6 45 f0 00	 mov	 BYTE PTR _pMsg$[ebp+28], 0
  00095	c6 45 f5 00	 mov	 BYTE PTR _pMsg$[ebp+33], 0
  00099	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 16002: 
; 16003: 	LogAddTD("[Mu_2Anv_Event] [%s][%s] Register Lotto Number (Serial: %s-%s-%s)",

  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a4	8d 45 f1	 lea	 eax, DWORD PTR _pMsg$[ebp+29]
  000a7	50		 push	 eax
  000a8	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp+24]
  000ab	50		 push	 eax
  000ac	8d 45 e7	 lea	 eax, DWORD PTR _pMsg$[ebp+19]
  000af	50		 push	 eax
  000b0	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000b3	03 c6		 add	 eax, esi
  000b5	50		 push	 eax
  000b6	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000b9	03 c6		 add	 eax, esi
  000bb	50		 push	 eax
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@MLMNLDLI@?$FLMu_2Anv_Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Registe@
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c7	83 c4 20	 add	 esp, 32			; 00000020H
$LN1@CGRequestL:

; 16004: 		gObj[aIndex].AccountID, gObj[aIndex].Name, pMsg.SERIAL1, pMsg.SERIAL2, pMsg.SERIAL3);
; 16005: }

  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	33 cd		 xor	 ecx, ebp
  000d1	5b		 pop	 ebx
  000d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ENDP ; CGRequestLottoRegister
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z PROC ; CGRequestEventEnterCount, COMDAT

; 15956: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15957: 	if ( !lpMsg )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 14		 je	 SHORT $LN2@CGRequestE

; 15958: 		return;
; 15959: 
; 15960: 	switch ( lpMsg->btEventType )

  0000a	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  0000e	83 e8 02	 sub	 eax, 2
  00011	75 0b		 jne	 SHORT $LN2@CGRequestE

; 15961: 	{
; 15962: 		case 0x02:
; 15963: 			EGReqBloodCastleEnterCount(aIndex);

  00013	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  00016	e8 00 00 00 00	 call	 ?EGReqBloodCastleEnterCount@@YAXH@Z ; EGReqBloodCastleEnterCount
  0001b	83 c4 04	 add	 esp, 4
$LN2@CGRequestE:

; 15964: 			break;
; 15965: 	}
; 15966: }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ENDP ; CGRequestEventEnterCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z PROC ; CGRequestRepositionUserInChaosCastle, COMDAT

; 15940: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 15941: 	if ( !gObjIsConnected(aIndex) )

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 5c		 je	 SHORT $LN4@CGRequestR

; 15942: 		return;
; 15943: 
; 15944: 	if ( !CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	57		 push	 edi
  0001a	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00020	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00023	8a 81 23 01 00
	00		 mov	 al, BYTE PTR [ecx+291]
  00029	3c 35		 cmp	 al, 53			; 00000035H
  0002b	74 0f		 je	 SHORT $LN10@CGRequestR
  0002d	3c 12		 cmp	 al, 18			; 00000012H
  0002f	72 3e		 jb	 SHORT $LN11@CGRequestR
  00031	b2 17		 mov	 dl, 23			; 00000017H
  00033	3a d0		 cmp	 dl, al
  00035	1b c0		 sbb	 eax, eax
  00037	83 c0 01	 add	 eax, 1
  0003a	74 33		 je	 SHORT $LN11@CGRequestR
$LN10@CGRequestR:

; 15945: 		return;
; 15946: 
; 15947: 	if ( g_ChaosCastle.ObjSetPosition(aIndex, gObj[aIndex].X, gObj[aIndex].Y) == TRUE )

  0003c	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  00043	50		 push	 eax
  00044	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  0004b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00050	50		 push	 eax
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ?ObjSetPosition@CChaosCastle@@QAEHHHH@Z ; CChaosCastle::ObjSetPosition
  00057	83 f8 01	 cmp	 eax, 1
  0005a	75 13		 jne	 SHORT $LN11@CGRequestR

; 15948: 		gObj[aIndex].m_iChaosCastleBlowTime = GetTickCount();

  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00068	89 84 0f 40 12
	00 00		 mov	 DWORD PTR [edi+ecx+4672], eax
$LN11@CGRequestR:
  0006f	5f		 pop	 edi
$LN4@CGRequestR:
  00070	5e		 pop	 esi

; 15949: }

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ENDP ; CGRequestRepositionUserInChaosCastle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z
_TEXT	SEGMENT
_dwITEM_SERIAL$1$ = -556				; size = 4
_btGuardMailSetItemPos$ = -552				; size = 1
tv824 = -548						; size = 4
_iCC_INDEX$1$ = -548					; size = 4
tv825 = -544						; size = 4
tv822 = -544						; size = 4
_pMsg$1 = -544						; size = 4
_pResult$ = -540					; size = 5
_pNotice$2 = -532					; size = 272
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z PROC ; CGRequestEnterChaosCastle, COMDAT

; 15683: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 02 00
	00		 sub	 esp, 556		; 0000022cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 15684: 	if ( !OBJMAX_RANGE(iIndex))

  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 58 05 00
	00		 js	 $LN62@CGRequestE
  00022	33 c0		 xor	 eax, eax
  00024	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 45 05 00
	00		 je	 $LN62@CGRequestE

; 15687: 		return;
; 15688: 	}
; 15689: 
; 15690: 	BYTE btChaosCastleNumber = lpMsg->iChaosCastleNumber-1;
; 15691: 	BYTE btGuardMailSetItemPos = lpMsg->iItemPos;

  00035	8a 41 05	 mov	 al, BYTE PTR [ecx+5]
  00038	57		 push	 edi

; 15692: 	int iITEM_LEVEL=0;
; 15693: 	DWORD dwITEM_SERIAL=0;
; 15694: 	PMSG_RESULT_MOVECHAOSCASTLE pResult;
; 15695: 
; 15696: 	PHeadSubSetB((LPBYTE)&pResult, 0xAF, 0x01, sizeof(pResult));

  00039	6a 05		 push	 5
  0003b	6a 01		 push	 1
  0003d	88 85 d8 fd ff
	ff		 mov	 BYTE PTR _btGuardMailSetItemPos$[ebp], al
  00043	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00049	68 af 00 00 00	 push	 175			; 000000afH
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 15697: 	pResult.Result = 0;
; 15698: 
; 15699: 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00054	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005a	83 c4 10	 add	 esp, 16			; 00000010H
  0005d	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00063	c6 85 e8 fd ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+4], 0
  0006a	80 7c 17 50 01	 cmp	 BYTE PTR [edi+edx+80], 1
  0006f	0f 85 ef 02 00
	00		 jne	 $LN69@CGRequestE
  00075	83 7c 17 04 02	 cmp	 DWORD PTR [edi+edx+4], 2
  0007a	0f 8e e4 02 00
	00		 jle	 $LN69@CGRequestE

; 15700: 		return;
; 15701: 
; 15702: 	if ( BC_MAP_RANGE(gObj[iIndex].MapNumber) ||
; 15703: 	 	 CC_MAP_RANGE(gObj[iIndex].MapNumber) ||

  00080	8a 8c 17 23 01
	00 00		 mov	 cl, BYTE PTR [edi+edx+291]
  00087	80 f9 34	 cmp	 cl, 52			; 00000034H
  0008a	0f 84 a4 04 00
	00		 je	 $LN8@CGRequestE
  00090	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00093	72 12		 jb	 SHORT $LN63@CGRequestE
  00095	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0009a	3a c1		 cmp	 al, cl
  0009c	1b c0		 sbb	 eax, eax
  0009e	83 c0 01	 add	 eax, 1
  000a1	0f 85 8d 04 00
	00		 jne	 $LN8@CGRequestE
$LN63@CGRequestE:
  000a7	80 f9 35	 cmp	 cl, 53			; 00000035H
  000aa	0f 84 84 04 00
	00		 je	 $LN8@CGRequestE
  000b0	80 f9 12	 cmp	 cl, 18			; 00000012H
  000b3	72 0f		 jb	 SHORT $LN64@CGRequestE
  000b5	b0 17		 mov	 al, 23			; 00000017H
  000b7	3a c1		 cmp	 al, cl
  000b9	1b c0		 sbb	 eax, eax
  000bb	83 c0 01	 add	 eax, 1
  000be	0f 85 70 04 00
	00		 jne	 $LN8@CGRequestE
$LN64@CGRequestE:
  000c4	80 f9 09	 cmp	 cl, 9
  000c7	0f 84 67 04 00
	00		 je	 $LN8@CGRequestE
  000cd	33 c0		 xor	 eax, eax
  000cf	80 f9 20	 cmp	 cl, 32			; 00000020H
  000d2	0f 94 c0	 sete	 al
  000d5	85 c0		 test	 eax, eax
  000d7	0f 85 57 04 00
	00		 jne	 $LN8@CGRequestE

; 15709: 		return;
; 15710: 	}
; 15711: 
; 15712: 	if ( gObj[iIndex].m_IfState.use && gObj[iIndex].m_IfState.type != 12 )

  000dd	8b 84 17 b8 11
	00 00		 mov	 eax, DWORD PTR [edi+edx+4536]
  000e4	a8 03		 test	 al, 3
  000e6	74 10		 je	 SHORT $LN9@CGRequestE
  000e8	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000ed	3d 00 03 00 00	 cmp	 eax, 768		; 00000300H
  000f2	0f 85 6c 02 00
	00		 jne	 $LN69@CGRequestE
$LN9@CGRequestE:

; 15713: 		return;
; 15714: 
; 15715: 	if ( gPkLimitFree == FALSE )

  000f8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  000ff	75 20		 jne	 SHORT $LN15@CGRequestE

; 15716: 	{
; 15717: 		int bIsPk = FALSE;
; 15718: 
; 15719: 		if ( gObj[iIndex].PartyNumber >= 0 )

  00101	8b 84 17 0c 06
	00 00		 mov	 eax, DWORD PTR [edi+edx+1548]
  00108	85 c0		 test	 eax, eax
  0010a	78 30		 js	 SHORT $LN11@CGRequestE

; 15720: 		{
; 15721: 			if( gParty.GetPartyPkLevel(gObj[iIndex].PartyNumber) >= 6 )

  0010c	50		 push	 eax
  0010d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00112	e8 00 00 00 00	 call	 ?GetPartyPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPartyPkLevel
  00117	3c 06		 cmp	 al, 6
  00119	7d 2b		 jge	 SHORT $LN65@CGRequestE

; 15736: 			DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 15737: 			return;

  0011b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN15@CGRequestE:

; 15738: 		}
; 15739: 	}
; 15740: 
; 15741: 	if ( gObjDuelCheck(&gObj[iIndex]) == TRUE )

  00121	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjDuelCheck
  0012a	83 c4 04	 add	 esp, 4
  0012d	83 f8 01	 cmp	 eax, 1
  00130	75 1e		 jne	 SHORT $LN16@CGRequestE

; 15742: 	{
; 15743: 		PMSG_NOTICE pNotice;
; 15744: 		TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 202)));

  00132	68 ca 04 00 00	 push	 1226			; 000004caH

; 15745: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 15746: 		return;

  00137	e9 fd 03 00 00	 jmp	 $LN76@CGRequestE
$LN11@CGRequestE:

; 15722: 			{
; 15723: 				bIsPk = TRUE;
; 15724: 			}
; 15725: 		}
; 15726: 		else if( gObj[iIndex].m_PK_Level >= 6 )

  0013c	80 bc 17 19 01
	00 00 06	 cmp	 BYTE PTR [edi+edx+281], 6
  00144	7c db		 jl	 SHORT $LN15@CGRequestE
$LN65@CGRequestE:

; 15727: 		{
; 15728: 			bIsPk = TRUE;
; 15729: 		}
; 15730: 		
; 15731: 		
; 15732: 		if ( bIsPk == TRUE )
; 15733: 		{
; 15734: 			PMSG_NOTICE pNotice;
; 15735: 			TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 201)));

  00146	68 c9 04 00 00	 push	 1225			; 000004c9H

; 15736: 			DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 15737: 			return;

  0014b	e9 e9 03 00 00	 jmp	 $LN76@CGRequestE
$LN16@CGRequestE:

; 15747: 	}
; 15748: 
; 15749: 	if ( gObj[iIndex].lpGuild )

  00150	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00156	03 cf		 add	 ecx, edi
  00158	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  0015e	85 c0		 test	 eax, eax
  00160	74 13		 je	 SHORT $LN18@CGRequestE

; 15750: 	{
; 15751: 		if ( gObj[iIndex].lpGuild->WarState == 1 )

  00162	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  00169	75 0a		 jne	 SHORT $LN18@CGRequestE

; 15752: 		{
; 15753: 			PMSG_NOTICE pNotice;
; 15754: 			TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 203)));

  0016b	68 cb 04 00 00	 push	 1227			; 000004cbH

; 15755: 			DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 15756: 			return;

  00170	e9 c4 03 00 00	 jmp	 $LN76@CGRequestE
$LN18@CGRequestE:

; 15757: 		}
; 15758: 	}
; 15759: 
; 15760: 	if ( gObj[iIndex].pInventory[8].m_Type == ITEMGET(13,3) ||	// Dino
; 15761: 		 gObj[iIndex].pInventory[8].m_Type == ITEMGET(13,2) ||	// Uniria

  00175	8b 81 c0 11 00
	00		 mov	 eax, DWORD PTR [ecx+4544]
  0017b	ba 03 1a 00 00	 mov	 edx, 6659		; 00001a03H
  00180	0f b7 80 a6 06
	00 00		 movzx	 eax, WORD PTR [eax+1702]
  00187	66 3b c2	 cmp	 ax, dx
  0018a	0f 84 9d 03 00
	00		 je	 $LN20@CGRequestE
  00190	ba 02 1a 00 00	 mov	 edx, 6658		; 00001a02H
  00195	66 3b c2	 cmp	 ax, dx
  00198	0f 84 8f 03 00
	00		 je	 $LN20@CGRequestE
  0019e	ba 25 1a 00 00	 mov	 edx, 6693		; 00001a25H
  001a3	66 3b c2	 cmp	 ax, dx
  001a6	0f 84 81 03 00
	00		 je	 $LN20@CGRequestE

; 15768: 	}
; 15769: 
; 15770: 	int bIsPk = FALSE;
; 15771: 
; 15772: 	if ( gObj[iIndex].PartyNumber >= 0 )

  001ac	8b 81 0c 06 00
	00		 mov	 eax, DWORD PTR [ecx+1548]
  001b2	85 c0		 test	 eax, eax
  001b4	78 0f		 js	 SHORT $LN21@CGRequestE

; 15773: 	{
; 15774: 		if( gParty.GetPartyPkLevel(gObj[iIndex].PartyNumber) >= 5 )

  001b6	50		 push	 eax
  001b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001bc	e8 00 00 00 00	 call	 ?GetPartyPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPartyPkLevel
  001c1	3c 05		 cmp	 al, 5

; 15775: 		{
; 15776: 			bIsPk = TRUE;
; 15777: 		}
; 15778: 	}

  001c3	eb 07		 jmp	 SHORT $LN71@CGRequestE
$LN21@CGRequestE:

; 15779: 	else if ( gObj[iIndex].m_PK_Level >= 4 )

  001c5	80 b9 19 01 00
	00 04		 cmp	 BYTE PTR [ecx+281], 4
$LN71@CGRequestE:
  001cc	7c 2f		 jl	 SHORT $LN25@CGRequestE

; 15780: 	{
; 15781: 		bIsPk = TRUE;
; 15782: 	}
; 15783: 
; 15784: 	if ( bIsPk == TRUE )
; 15785: 	{
; 15786: 		pResult.Result = 8;
; 15787: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  001ce	0f b6 85 e5 fd
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001d5	50		 push	 eax
  001d6	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  001dc	c6 85 e8 fd ff
	ff 08		 mov	 BYTE PTR _pResult$[ebp+4], 8
  001e3	50		 push	 eax
  001e4	56		 push	 esi
  001e5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ed	5f		 pop	 edi
  001ee	5e		 pop	 esi

; 15933: 		iENTER_LEVEL+1, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);
; 15934: }

  001ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f2	33 cd		 xor	 ecx, ebp
  001f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c3		 ret	 0
$LN25@CGRequestE:
  001fd	53		 push	 ebx

; 15788: 		return;
; 15789: 	}
; 15790: 
; 15791: 	int iENTER_LEVEL = g_ChaosCastle.GetUserLevelToEnter(iIndex);

  001fe	56		 push	 esi
  001ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00204	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetUserLevelToEnter
  00209	8b d8		 mov	 ebx, eax

; 15792: 
; 15793: 	if ( iENTER_LEVEL == -1 )

  0020b	83 fb ff	 cmp	 ebx, -1
  0020e	0f 84 0d 03 00
	00		 je	 $LN30@CGRequestE

; 15794: 	{
; 15795: 		pResult.Result = 1;
; 15796: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15797: 		return;
; 15798: 	}
; 15799: 
; 15800: 	if ( g_ChaosCastle.CheckCanEnter(iENTER_LEVEL) == false )

  00214	53		 push	 ebx
  00215	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0021a	e8 00 00 00 00	 call	 ?CheckCanEnter@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanEnter
  0021f	84 c0		 test	 al, al
  00221	75 0c		 jne	 SHORT $LN27@CGRequestE

; 15801: 	{
; 15802: 		pResult.Result = 2;

  00223	c6 85 e8 fd ff
	ff 02		 mov	 BYTE PTR _pResult$[ebp+4], 2

; 15803: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15804: 		return;

  0022a	e9 1c 01 00 00	 jmp	 $LN74@CGRequestE
$LN27@CGRequestE:

; 15805: 	}
; 15806: 
; 15807: 	if ( gObj[iIndex].pInventory[btGuardMailSetItemPos].IsItem() == TRUE )

  0022f	0f b6 85 d8 fd
	ff ff		 movzx	 eax, BYTE PTR _btGuardMailSetItemPos$[ebp]
  00236	69 d0 d4 00 00
	00		 imul	 edx, eax, 212
  0023c	89 85 e0 fd ff
	ff		 mov	 DWORD PTR tv825[ebp], eax
  00242	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00247	89 95 dc fd ff
	ff		 mov	 DWORD PTR tv824[ebp], edx
  0024d	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  00254	03 ca		 add	 ecx, edx
  00256	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0025b	83 f8 01	 cmp	 eax, 1
  0025e	0f 85 bd 02 00
	00		 jne	 $LN30@CGRequestE

; 15808: 	{
; 15809: 		if ( gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Type == ITEMGET(13,29) ) // Armor of Guardman

  00264	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00269	ba 1d 1a 00 00	 mov	 edx, 6685		; 00001a1dH
  0026e	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR tv824[ebp]
  00274	8b 84 07 c0 11
	00 00		 mov	 eax, DWORD PTR [edi+eax+4544]
  0027b	66 39 54 08 06	 cmp	 WORD PTR [eax+ecx+6], dx
  00280	0f 85 9b 02 00
	00		 jne	 $LN30@CGRequestE

; 15810: 		{
; 15811: 			iITEM_LEVEL = gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Level;
; 15812: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btGuardMailSetItemPos].m_Number;

  00286	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]

; 15819: 		}
; 15820: 	}
; 15821: 	else
; 15822: 	{
; 15823: 		pResult.Result = 1;
; 15824: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15825: 		return;
; 15826: 	}
; 15827: 
; 15828: 	if( IsTransformEquipment(iIndex) )

  00289	56		 push	 esi
  0028a	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _dwITEM_SERIAL$1$[ebp], eax
  00290	e8 00 00 00 00	 call	 ?IsTransformEquipment@@YA_NH@Z ; IsTransformEquipment
  00295	83 c4 04	 add	 esp, 4
  00298	84 c0		 test	 al, al
  0029a	74 2c		 je	 SHORT $LN32@CGRequestE

; 15829: 	{
; 15830: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 205)), iIndex, 1);

  0029c	6a 01		 push	 1
  0029e	56		 push	 esi
  0029f	68 cd 04 00 00	 push	 1229			; 000004cdH
  002a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002a9	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002ae	50		 push	 eax
  002af	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 15867: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  002b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b7	5b		 pop	 ebx
  002b8	5f		 pop	 edi
  002b9	5e		 pop	 esi

; 15933: 		iENTER_LEVEL+1, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);
; 15934: }

  002ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002bd	33 cd		 xor	 ecx, ebp
  002bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c4	8b e5		 mov	 esp, ebp
  002c6	5d		 pop	 ebp
  002c7	c3		 ret	 0
$LN32@CGRequestE:

; 15831: 		return;
; 15832: 	}
; 15833: 
; 15834: 	BYTE btAttr = MapC[gObj[iIndex].MapNumber].GetAttr(gObj[iIndex].X,gObj[iIndex].Y);

  002c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ce	0f b6 84 39 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+edi+289]
  002d6	50		 push	 eax
  002d7	0f b6 84 39 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+edi+288]
  002df	50		 push	 eax
  002e0	0f b6 84 39 23
	01 00 00	 movzx	 eax, BYTE PTR [ecx+edi+291]
  002e8	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  002ee	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  002f4	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 15835: 
; 15836: 	if( (btAttr & 1) != 1 )

  002f9	a8 01		 test	 al, 1
  002fb	74 66		 je	 SHORT $LN70@CGRequestE

; 15837: 	{
; 15838: 		return;
; 15839: 	}
; 15840: 
; 15841: 	int iCC_INDEX = -1;
; 15842: 
; 15843: 	if ( g_ChaosCastle.CheckUserEnterMoney(iIndex, iENTER_LEVEL) )

  002fd	53		 push	 ebx
  002fe	56		 push	 esi
  002ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00304	e8 00 00 00 00	 call	 ?CheckUserEnterMoney@CChaosCastle@@QAEHHH@Z ; CChaosCastle::CheckUserEnterMoney
  00309	85 c0		 test	 eax, eax
  0030b	0f 84 04 02 00
	00		 je	 $LN34@CGRequestE

; 15844: 	{
; 15845: 		iCC_INDEX = g_ChaosCastle.EnterUserChaosCastle(iENTER_LEVEL, iIndex);

  00311	56		 push	 esi
  00312	53		 push	 ebx
  00313	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00318	e8 00 00 00 00	 call	 ?EnterUserChaosCastle@CChaosCastle@@QAEHHH@Z ; CChaosCastle::EnterUserChaosCastle
  0031d	89 85 dc fd ff
	ff		 mov	 DWORD PTR _iCC_INDEX$1$[ebp], eax

; 15846: 
; 15847: 		if ( iCC_INDEX == -1 )

  00323	83 f8 ff	 cmp	 eax, -1
  00326	74 1c		 je	 SHORT $LN73@CGRequestE

; 15859: 	}
; 15860: 
; 15861: 	BOOL bRES = g_ChaosCastle.PayUserEnterMoney(iIndex, iENTER_LEVEL);

  00328	53		 push	 ebx
  00329	56		 push	 esi
  0032a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0032f	e8 00 00 00 00	 call	 ?PayUserEnterMoney@CChaosCastle@@QAEHHH@Z ; CChaosCastle::PayUserEnterMoney

; 15862: 
; 15863: 	if ( bRES == FALSE )

  00334	85 c0		 test	 eax, eax
  00336	75 3c		 jne	 SHORT $LN37@CGRequestE

; 15864: 	{
; 15865: 		g_ChaosCastle.LeaveUserChaosCastle(iENTER_LEVEL, iIndex);

  00338	56		 push	 esi
  00339	53		 push	 ebx
  0033a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0033f	e8 00 00 00 00	 call	 ?LeaveUserChaosCastle@CChaosCastle@@QAEHHH@Z ; CChaosCastle::LeaveUserChaosCastle
$LN73@CGRequestE:

; 15866: 		pResult.Result = 5;

  00344	c6 85 e8 fd ff
	ff 05		 mov	 BYTE PTR _pResult$[ebp+4], 5
$LN74@CGRequestE:

; 15867: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0034b	0f b6 85 e5 fd
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00352	50		 push	 eax
  00353	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00359	50		 push	 eax
  0035a	56		 push	 esi
  0035b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00360	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN70@CGRequestE:
  00363	5b		 pop	 ebx
$LN69@CGRequestE:
  00364	5f		 pop	 edi
  00365	5e		 pop	 esi

; 15933: 		iENTER_LEVEL+1, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);
; 15934: }

  00366	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00369	33 cd		 xor	 ecx, ebp
  0036b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00370	8b e5		 mov	 esp, ebp
  00372	5d		 pop	 ebp
  00373	c3		 ret	 0
$LN37@CGRequestE:

; 15868: 		return;
; 15869: 	}
; 15870: 
; 15871: 	gObjInventoryDeleteItem(iIndex, btGuardMailSetItemPos);

  00374	ff b5 e0 fd ff
	ff		 push	 DWORD PTR tv825[ebp]
  0037a	56		 push	 esi
  0037b	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 15872: 	GCInventoryItemDeleteSend(iIndex, btGuardMailSetItemPos, 1);

  00380	6a 01		 push	 1
  00382	ff b5 d8 fd ff
	ff		 push	 DWORD PTR _btGuardMailSetItemPos$[ebp]
  00388	56		 push	 esi
  00389	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 15873: 
; 15874: 	DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  0038e	0f b6 85 e5 fd
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00395	50		 push	 eax
  00396	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  0039c	50		 push	 eax
  0039d	56		 push	 esi
  0039e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 15875: 
; 15876: 	gObj[iIndex].m_cChaosCastleIndex = iENTER_LEVEL;

  003a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a8	83 c4 20	 add	 esp, 32			; 00000020H

; 15877: 	gObj[iIndex].m_cChaosCastleSubIndex = iCC_INDEX;

  003ab	8b 8d dc fd ff
	ff		 mov	 ecx, DWORD PTR _iCC_INDEX$1$[ebp]
  003b1	88 9c 07 3d 12
	00 00		 mov	 BYTE PTR [edi+eax+4669], bl
  003b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003bd	88 8c 07 3e 12
	00 00		 mov	 BYTE PTR [edi+eax+4670], cl

; 15878: 	gObj[iIndex].m_IfState.state = 0;

  003c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003c9	83 a4 07 b8 11
	00 00 c3	 and	 DWORD PTR [edi+eax+4536], -61 ; ffffffc3H

; 15879: 	gObj[iIndex].m_IfState.type = 0;

  003d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003d6	81 a4 07 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [edi+eax+4536], -65473 ; ffff003fH

; 15880: 	gObj[iIndex].m_IfState.use = 0;

  003e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003e6	83 a4 07 b8 11
	00 00 fc	 and	 DWORD PTR [edi+eax+4536], -4 ; fffffffcH

; 15881: 
; 15882: 	if ( gObj[iIndex].m_bPShopOpen == true )

  003ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003f3	80 bc 07 5c 12
	00 00 01	 cmp	 BYTE PTR [edi+eax+4700], 1
  003fb	75 09		 jne	 SHORT $LN38@CGRequestE

; 15883: 		CGPShopReqClose(iIndex);

  003fd	56		 push	 esi
  003fe	e8 00 00 00 00	 call	 ?CGPShopReqClose@@YAXH@Z ; CGPShopReqClose
  00403	83 c4 04	 add	 esp, 4
$LN38@CGRequestE:

; 15884: 
; 15885: 	if ( gObj[iIndex].PartyNumber >= 0 )

  00406	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0040b	8b 94 07 0c 06
	00 00		 mov	 edx, DWORD PTR [edi+eax+1548]
  00412	85 d2		 test	 edx, edx
  00414	78 2a		 js	 SHORT $LN68@CGRequestE

; 15886: 	{
; 15887: 		PMSG_PARTYDELUSER pMsg;
; 15888: 		int pindex = gParty.GetIndex(gObj[iIndex].PartyNumber, iIndex, gObj[iIndex].DBNumber);

  00416	ff 74 07 30	 push	 DWORD PTR [edi+eax+48]
  0041a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0041f	56		 push	 esi
  00420	52		 push	 edx
  00421	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex

; 15889: 
; 15890: 		if ( pindex >= 0 )

  00426	85 c0		 test	 eax, eax
  00428	78 16		 js	 SHORT $LN68@CGRequestE

; 15891: 		{
; 15892: 			pMsg.Number = pindex;

  0042a	88 85 e3 fd ff
	ff		 mov	 BYTE PTR _pMsg$1[ebp+3], al

; 15893: 			CGPartyDelUser(&pMsg, iIndex);

  00430	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00436	56		 push	 esi
  00437	50		 push	 eax
  00438	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  0043d	83 c4 08	 add	 esp, 8
$LN68@CGRequestE:

; 15894: 		}
; 15895: 	}
; 15896: 
; 15897: 	if ( gObj[iIndex].Class == CLASS_ELF && gObj[iIndex].m_RecallMon >= 0)

  00440	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00445	66 83 bc 07 90
	00 00 00 02	 cmp	 WORD PTR [edi+eax+144], 2
  0044e	75 1d		 jne	 SHORT $LN41@CGRequestE
  00450	83 bc 07 30 06
	00 00 00	 cmp	 DWORD PTR [edi+eax+1584], 0
  00458	7c 13		 jl	 SHORT $LN41@CGRequestE

; 15898: 	{
; 15899: 		GCRecallMonLife(iIndex, 60, 0);

  0045a	6a 00		 push	 0
  0045c	6a 3c		 push	 60			; 0000003cH
  0045e	56		 push	 esi
  0045f	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife

; 15900: 		gObjMonsterCallKill(iIndex);

  00464	56		 push	 esi
  00465	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  0046a	83 c4 10	 add	 esp, 16			; 00000010H
$LN41@CGRequestE:

; 15901: 	}
; 15902: 
; 15903: 	char szTemp[256];
; 15904: 	wsprintf(szTemp, lMsg.Get(MSGGET(4, 206)), iENTER_LEVEL+1);

  0046d	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00470	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00475	50		 push	 eax
  00476	68 ce 04 00 00	 push	 1230			; 000004ceH
  0047b	89 85 e0 fd ff
	ff		 mov	 DWORD PTR tv822[ebp], eax
  00481	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00486	50		 push	 eax
  00487	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0048d	50		 push	 eax
  0048e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 15905: 	GCServerMsgStringSend(szTemp, iIndex, 1);

  00494	6a 01		 push	 1
  00496	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0049c	56		 push	 esi
  0049d	50		 push	 eax
  0049e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004a3	83 c4 18	 add	 esp, 24			; 00000018H

; 15906: 
; 15907: 	switch ( iENTER_LEVEL+1 )

  004a6	83 fb 06	 cmp	 ebx, 6
  004a9	77 2d		 ja	 SHORT $LN2@CGRequestE
  004ab	ff 24 9d 00 00
	00 00		 jmp	 DWORD PTR $LN78@CGRequestE[ebx*4]
$LN42@CGRequestE:

; 15908: 	{
; 15909: 		case 1:
; 15910: 			gObjMoveGate(iIndex, 82);

  004b2	6a 52		 push	 82			; 00000052H

; 15911: 			break;

  004b4	eb 19		 jmp	 SHORT $LN72@CGRequestE
$LN43@CGRequestE:

; 15912: 		case 2:
; 15913: 			gObjMoveGate(iIndex, 83);

  004b6	6a 53		 push	 83			; 00000053H

; 15914: 			break;

  004b8	eb 15		 jmp	 SHORT $LN72@CGRequestE
$LN44@CGRequestE:

; 15915: 		case 3:
; 15916: 			gObjMoveGate(iIndex, 84);

  004ba	6a 54		 push	 84			; 00000054H

; 15917: 			break;

  004bc	eb 11		 jmp	 SHORT $LN72@CGRequestE
$LN45@CGRequestE:

; 15918: 		case 4:
; 15919: 			gObjMoveGate(iIndex, 85);

  004be	6a 55		 push	 85			; 00000055H

; 15920: 			break;

  004c0	eb 0d		 jmp	 SHORT $LN72@CGRequestE
$LN46@CGRequestE:

; 15921: 		case 5:
; 15922: 			gObjMoveGate(iIndex, 86);

  004c2	6a 56		 push	 86			; 00000056H

; 15923: 			break;

  004c4	eb 09		 jmp	 SHORT $LN72@CGRequestE
$LN47@CGRequestE:

; 15924: 		case 6:
; 15925: 			gObjMoveGate(iIndex, 87);

  004c6	6a 57		 push	 87			; 00000057H

; 15926: 			break;

  004c8	eb 05		 jmp	 SHORT $LN72@CGRequestE
$LN48@CGRequestE:

; 15927: 		case 7:
; 15928: 			gObjMoveGate(iIndex, 272);

  004ca	68 10 01 00 00	 push	 272			; 00000110H
$LN72@CGRequestE:
  004cf	56		 push	 esi
  004d0	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  004d5	83 c4 08	 add	 esp, 8
$LN2@CGRequestE:

; 15929: 			break;
; 15930: 	}
; 15931: 
; 15932: 	LogAddTD("[Chaos Castle] (%d) (Account:%s, Name:%s) Entered Chaos Castle (Guard Mail Set Serial:%d)",

  004d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004de	ff b5 d4 fd ff
	ff		 push	 DWORD PTR _dwITEM_SERIAL$1$[ebp]
  004e4	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  004e7	03 c7		 add	 eax, edi
  004e9	50		 push	 eax
  004ea	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  004ed	03 c7		 add	 eax, edi
  004ef	50		 push	 eax
  004f0	ff b5 e0 fd ff
	ff		 push	 DWORD PTR tv822[ebp]
  004f6	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@NPJPMFON@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  004fb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00501	83 c4 14	 add	 esp, 20			; 00000014H
  00504	5b		 pop	 ebx
  00505	5f		 pop	 edi
  00506	5e		 pop	 esi

; 15933: 		iENTER_LEVEL+1, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);
; 15934: }

  00507	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0050a	33 cd		 xor	 ecx, ebp
  0050c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00511	8b e5		 mov	 esp, ebp
  00513	5d		 pop	 ebp
  00514	c3		 ret	 0
$LN34@CGRequestE:

; 15848: 		{
; 15849: 			pResult.Result = 5;
; 15850: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15851: 			return;
; 15852: 		}
; 15853: 	}
; 15854: 	else
; 15855: 	{
; 15856: 		pResult.Result = 7;

  00515	c6 85 e8 fd ff
	ff 07		 mov	 BYTE PTR _pResult$[ebp+4], 7

; 15857: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15858: 		return;

  0051c	e9 2a fe ff ff	 jmp	 $LN74@CGRequestE
$LN30@CGRequestE:

; 15813: 		}
; 15814: 		else
; 15815: 		{
; 15816: 			pResult.Result = 1;

  00521	c6 85 e8 fd ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+4], 1

; 15817: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15818: 			return;

  00528	e9 1e fe ff ff	 jmp	 $LN74@CGRequestE
$LN20@CGRequestE:

; 15762: 		 gObj[iIndex].pInventory[8].m_Type == ITEMGET(13,37) )	// Fenrir
; 15763: 	{
; 15764: 		PMSG_NOTICE pNotice;
; 15765: 		TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 204)));

  0052d	68 cc 04 00 00	 push	 1228			; 000004ccH

; 15766: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);
; 15767: 		return;

  00532	eb 05		 jmp	 SHORT $LN76@CGRequestE
$LN8@CGRequestE:

; 15704: 		 DS_MAP_RANGE(gObj[iIndex].MapNumber) )
; 15705: 	{
; 15706: 		PMSG_NOTICE pNotice;
; 15707: 		TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 200)));

  00534	68 c8 04 00 00	 push	 1224			; 000004c8H
$LN76@CGRequestE:
  00539	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0053e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00543	50		 push	 eax
  00544	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$2[ebp]
  0054a	6a 01		 push	 1
  0054c	50		 push	 eax
  0054d	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 15708: 		DataSend(iIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00552	0f b6 85 ed fd
	ff ff		 movzx	 eax, BYTE PTR _pNotice$2[ebp+1]
  00559	50		 push	 eax
  0055a	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pNotice$2[ebp]
  00560	50		 push	 eax
  00561	56		 push	 esi
  00562	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00567	83 c4 18	 add	 esp, 24			; 00000018H
  0056a	5f		 pop	 edi
  0056b	5e		 pop	 esi

; 15933: 		iENTER_LEVEL+1, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);
; 15934: }

  0056c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0056f	33 cd		 xor	 ecx, ebp
  00571	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00576	8b e5		 mov	 esp, ebp
  00578	5d		 pop	 ebp
  00579	c3		 ret	 0
$LN62@CGRequestE:

; 15685: 	{
; 15686: 		LogAdd("return %s %d", __FILE__, __LINE__);

  0057a	68 46 3d 00 00	 push	 15686			; 00003d46H
  0057f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00584	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  00589	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 15933: 		iENTER_LEVEL+1, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);
; 15934: }

  0058f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00592	83 c4 0c	 add	 esp, 12			; 0000000cH
  00595	33 cd		 xor	 ecx, ebp
  00597	5e		 pop	 esi
  00598	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0059d	8b e5		 mov	 esp, ebp
  0059f	5d		 pop	 ebp
  005a0	c3		 ret	 0
  005a1	0f 1f 00	 npad	 3
$LN78@CGRequestE:
  005a4	00 00 00 00	 DD	 $LN42@CGRequestE
  005a8	00 00 00 00	 DD	 $LN43@CGRequestE
  005ac	00 00 00 00	 DD	 $LN44@CGRequestE
  005b0	00 00 00 00	 DD	 $LN45@CGRequestE
  005b4	00 00 00 00	 DD	 $LN46@CGRequestE
  005b8	00 00 00 00	 DD	 $LN47@CGRequestE
  005bc	00 00 00 00	 DD	 $LN48@CGRequestE
?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ENDP ; CGRequestEnterChaosCastle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z
_TEXT	SEGMENT
tv679 = -300						; size = 4
tv685 = -296						; size = 4
tv631 = -292						; size = 4
tv680 = -288						; size = 4
_iBC_INDEX$1$ = -288					; size = 4
_btInvisibleCourtItemPos$ = -284			; size = 1
tv638 = -280						; size = 4
tv684 = -276						; size = 4
_dwITEM_SERIAL$1$ = -276				; size = 4
_iITEM_LEVEL$1$ = -272					; size = 4
_btBridgeNumber$1$ = -265				; size = 1
_pResult$ = -264					; size = 4
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_iIndex$ = 12						; size = 4
?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z PROC ; CGRequestEnterBloodCastle, COMDAT

; 15479: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00016	56		 push	 esi
  00017	8b 75 0c	 mov	 esi, DWORD PTR _iIndex$[ebp]

; 15480: 	if ( !OBJMAX_RANGE(iIndex))

  0001a	85 f6		 test	 esi, esi
  0001c	0f 88 8e 04 00
	00		 js	 $LN53@CGRequestE
  00022	33 c0		 xor	 eax, eax
  00024	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0002a	0f 9e c0	 setle	 al
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 7b 04 00
	00		 je	 $LN53@CGRequestE

; 15483: 		return;
; 15484: 	}
; 15485: 	
; 15486: 	BYTE btBridgeNumber = lpMsg->iBridgeNumber - 1;

  00035	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00038	fe c8		 dec	 al

; 15487: 	BYTE btInvisibleCourtItemPos = lpMsg->iItemPos;
; 15488: 	int iITEM_LEVEL = 0;

  0003a	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iITEM_LEVEL$1$[ebp], 0
  00044	53		 push	 ebx
  00045	88 85 f7 fe ff
	ff		 mov	 BYTE PTR _btBridgeNumber$1$[ebp], al
  0004b	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 15489: 	DWORD dwITEM_SERIAL = 0;
; 15490: 	PMSG_RESULT_MOVEBLOODCASTLE pResult;
; 15491: 
; 15492: 	PHeadSetB((LPBYTE)&pResult, 0x9A, sizeof(pResult));

  0004e	6a 04		 push	 4
  00050	88 85 e4 fe ff
	ff		 mov	 BYTE PTR _btInvisibleCourtItemPos$[ebp], al
  00056	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  0005c	68 9a 00 00 00	 push	 154			; 0000009aH
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15493: 	pResult.Result = 0;
; 15494: 
; 15495: 	if ( gObj[iIndex].Type != OBJ_USER || gObj[iIndex].Connected <= PLAYER_LOGGED )

  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00070	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00076	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _pResult$[ebp+3], 0
  0007d	80 7c 0b 50 01	 cmp	 BYTE PTR [ebx+ecx+80], 1
  00082	0f 85 27 01 00
	00		 jne	 $LN56@CGRequestE
  00088	83 7c 0b 04 02	 cmp	 DWORD PTR [ebx+ecx+4], 2
  0008d	0f 8e 1c 01 00
	00		 jle	 $LN56@CGRequestE

; 15496: 		return;
; 15497: 
; 15498: 	if ( gObj[iIndex].m_IfState.use && gObj[iIndex].m_IfState.type != 12 )

  00093	8b 84 0b b8 11
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+4536]
  0009a	a8 03		 test	 al, 3
  0009c	74 10		 je	 SHORT $LN10@CGRequestE
  0009e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000a3	3d 00 03 00 00	 cmp	 eax, 768		; 00000300H
  000a8	0f 85 01 01 00
	00		 jne	 $LN56@CGRequestE
$LN10@CGRequestE:

; 15499: 		return;
; 15500: 
; 15501: #ifndef BEREZNUK
; 15502: 	if( gObj[iIndex].m_PK_Level >= 4 )

  000ae	80 bc 0b 19 01
	00 00 04	 cmp	 BYTE PTR [ebx+ecx+281], 4
  000b6	7c 09		 jl	 SHORT $LN11@CGRequestE

; 15503: 	{
; 15504: 		pResult.Result = 7;

  000b8	c6 85 fb fe ff
	ff 07		 mov	 BYTE PTR _pResult$[ebp+3], 7

; 15505: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15506: 		return;

  000bf	eb 1d		 jmp	 SHORT $LN62@CGRequestE
$LN11@CGRequestE:

; 15507: 	}
; 15508: #endif
; 15509: 
; 15510: 	if ( g_BloodCastle.CheckCanEnter(btBridgeNumber) == false )

  000c1	0f b6 85 f7 fe
	ff ff		 movzx	 eax, BYTE PTR _btBridgeNumber$1$[ebp]
  000c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  000d3	84 c0		 test	 al, al
  000d5	75 2f		 jne	 SHORT $LN12@CGRequestE

; 15511: 	{
; 15512: 		pResult.Result = 2;

  000d7	c6 85 fb fe ff
	ff 02		 mov	 BYTE PTR _pResult$[ebp+3], 2
$LN62@CGRequestE:

; 15513: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  000de	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000e5	50		 push	 eax
  000e6	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  000ec	50		 push	 eax
  000ed	56		 push	 esi
  000ee	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f6	5b		 pop	 ebx
  000f7	5e		 pop	 esi

; 15669: 		iITEM_LEVEL, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);
; 15670: }

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fb	33 cd		 xor	 ecx, ebp
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
$LN12@CGRequestE:

; 15514: 		return;
; 15515: 	}
; 15516: 
; 15517: 	if ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].IsItem() == TRUE )

  00106	0f b6 85 e4 fe
	ff ff		 movzx	 eax, BYTE PTR _btInvisibleCourtItemPos$[ebp]
  0010d	57		 push	 edi
  0010e	69 f8 d4 00 00
	00		 imul	 edi, eax, 212
  00114	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv685[ebp], eax
  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011f	89 bd ec fe ff
	ff		 mov	 DWORD PTR tv684[ebp], edi
  00125	8b 8c 03 c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4544]
  0012c	03 cf		 add	 ecx, edi
  0012e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00133	83 f8 01	 cmp	 eax, 1
  00136	75 57		 jne	 SHORT $LN54@CGRequestE

; 15518: 	{
; 15519: 		if ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,18) )

  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013e	c7 85 dc fe ff
	ff 12 1a 00 00	 mov	 DWORD PTR tv631[ebp], 6674 ; 00001a12H
  00148	c7 85 e8 fe ff
	ff 2f 1a 00 00	 mov	 DWORD PTR tv638[ebp], 6703 ; 00001a2fH
  00152	8b 84 0b c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+4544]
  00159	0f b7 54 38 06	 movzx	 edx, WORD PTR [eax+edi+6]
  0015e	66 3b 95 dc fe
	ff ff		 cmp	 dx, WORD PTR tv631[ebp]
  00165	75 58		 jne	 SHORT $LN15@CGRequestE

; 15520: 		{
; 15521: 			iITEM_LEVEL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Level;

  00167	0f bf 4c 38 08	 movsx	 ecx, WORD PTR [eax+edi+8]

; 15522: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Number;

  0016c	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  0016f	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _iITEM_LEVEL$1$[ebp], ecx
  00175	89 85 ec fe ff
	ff		 mov	 DWORD PTR _dwITEM_SERIAL$1$[ebp], eax

; 15523: 			
; 15524: 			if ( BC_CLOACK_LEVEL_RANGE(iITEM_LEVEL)==FALSE)

  0017b	85 c9		 test	 ecx, ecx
  0017d	78 10		 js	 SHORT $LN54@CGRequestE
  0017f	33 c0		 xor	 eax, eax
  00181	83 f9 08	 cmp	 ecx, 8
  00184	0f 9e c0	 setle	 al
  00187	85 c0		 test	 eax, eax
  00189	0f 85 cb 00 00
	00		 jne	 $LN23@CGRequestE
$LN54@CGRequestE:

; 15525: 			{
; 15526: 				pResult.Result = 1;

  0018f	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR _pResult$[ebp+3], 1
$LN61@CGRequestE:

; 15527: 				DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00196	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0019d	50		 push	 eax
  0019e	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  001a4	50		 push	 eax
  001a5	56		 push	 esi
  001a6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN57@CGRequestE:
  001ae	5f		 pop	 edi
$LN56@CGRequestE:
  001af	5b		 pop	 ebx
  001b0	5e		 pop	 esi

; 15669: 		iITEM_LEVEL, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);
; 15670: }

  001b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b4	33 cd		 xor	 ecx, ebp
  001b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bb	8b e5		 mov	 esp, ebp
  001bd	5d		 pop	 ebp
  001be	c3		 ret	 0
$LN15@CGRequestE:

; 15528: 				return;
; 15529: 			}
; 15530: 		}
; 15531: 		else if ( gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47) &&

  001bf	66 3b 95 e8 fe
	ff ff		 cmp	 dx, WORD PTR tv638[ebp]
  001c6	75 c7		 jne	 SHORT $LN54@CGRequestE
  001c8	f3 0f 10 44 38
	24		 movss	 xmm0, DWORD PTR [eax+edi+36]
  001ce	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  001d5	76 b8		 jbe	 SHORT $LN54@CGRequestE

; 15532: 				  gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 0.0f ) //#unk
; 15533: 		{
; 15534: #if (__CUSTOM__ == 1)
; 15535: 			if ( gObj[iIndex].ChangeUP2 == TRUE )

  001d7	80 bc 0b 94 00
	00 00 01	 cmp	 BYTE PTR [ebx+ecx+148], 1
  001df	75 07		 jne	 SHORT $LN20@CGRequestE

; 15536: #else
; 15537: 			if ( g_MasterExp.IsEnabled(&gObj[iIndex]) )
; 15538: #endif
; 15539: 			{
; 15540: 				iITEM_LEVEL = 8;

  001e1	b9 08 00 00 00	 mov	 ecx, 8

; 15541: 			}
; 15542: 			else

  001e6	eb 3f		 jmp	 SHORT $LN58@CGRequestE
$LN20@CGRequestE:

; 15543: 			{
; 15544: 				for ( int i=0;i<MAX_CLOACK_LEVEL;i++)

  001e8	33 ff		 xor	 edi, edi
  001ea	66 0f 1f 44 00
	00		 npad	 6
$LL4@CGRequestE:

; 15545: 				{
; 15546: 					if ( g_BloodCastle.CheckEnterLevel(iIndex, i+1) == 0 )

  001f0	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  001f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001f8	50		 push	 eax
  001f9	56		 push	 esi
  001fa	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv680[ebp], eax
  00200	e8 00 00 00 00	 call	 ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CheckEnterLevel
  00205	85 c0		 test	 eax, eax
  00207	74 15		 je	 SHORT $LN49@CGRequestE

; 15543: 			{
; 15544: 				for ( int i=0;i<MAX_CLOACK_LEVEL;i++)

  00209	8b bd e0 fe ff
	ff		 mov	 edi, DWORD PTR tv680[ebp]
  0020f	83 ff 09	 cmp	 edi, 9
  00212	7c dc		 jl	 SHORT $LL4@CGRequestE

; 15545: 				{
; 15546: 					if ( g_BloodCastle.CheckEnterLevel(iIndex, i+1) == 0 )

  00214	8b bd ec fe ff
	ff		 mov	 edi, DWORD PTR tv684[ebp]
  0021a	33 c9		 xor	 ecx, ecx
  0021c	eb 0f		 jmp	 SHORT $LN3@CGRequestE
$LN49@CGRequestE:

; 15547: 					{
; 15548: 						iITEM_LEVEL = i+1;

  0021e	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00221	8b bd ec fe ff
	ff		 mov	 edi, DWORD PTR tv684[ebp]
$LN58@CGRequestE:
  00227	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _iITEM_LEVEL$1$[ebp], ecx
$LN3@CGRequestE:

; 15549: 						break;
; 15550: 					}
; 15551: 				}
; 15552: 			}
; 15553: 
; 15554: 			dwITEM_SERIAL = gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Number;

  0022d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00232	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00239	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  0023c	89 85 ec fe ff
	ff		 mov	 DWORD PTR _dwITEM_SERIAL$1$[ebp], eax

; 15555: 
; 15556: 			if ( BC_CLOACK_LEVEL_RANGE(iITEM_LEVEL) == FALSE )

  00242	85 c9		 test	 ecx, ecx
  00244	0f 88 45 ff ff
	ff		 js	 $LN54@CGRequestE
  0024a	33 c0		 xor	 eax, eax
  0024c	83 f9 08	 cmp	 ecx, 8
  0024f	0f 9e c0	 setle	 al
  00252	85 c0		 test	 eax, eax
  00254	0f 84 35 ff ff
	ff		 je	 $LN54@CGRequestE
$LN23@CGRequestE:

; 15557: 			{
; 15558: 				pResult.Result = 1;
; 15559: 				DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15560: 				return;
; 15561: 			}
; 15562: 		}
; 15563: 		else
; 15564: 		{
; 15565: 			pResult.Result = 1;
; 15566: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15567: 			return;
; 15568: 		}
; 15569: 	}
; 15570: 	else
; 15571: 	{
; 15572: 		pResult.Result = 1;
; 15573: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15574: 		return;
; 15575: 	}
; 15576: 
; 15577: //#endif
; 15578: 	
; 15579: 	int iRESULT = g_BloodCastle.CheckEnterLevel(iIndex, iITEM_LEVEL);

  0025a	51		 push	 ecx
  0025b	56		 push	 esi
  0025c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00261	e8 00 00 00 00	 call	 ?CheckEnterLevel@CBloodCastle@@QAEHHH@Z ; CBloodCastle::CheckEnterLevel

; 15580: 
; 15581: 	if ( iRESULT== 0 )

  00266	85 c0		 test	 eax, eax
  00268	0f 85 1c 02 00
	00		 jne	 $LN24@CGRequestE

; 15582: 	{
; 15583: 		pResult.Result = 0;

  0026e	88 85 fb fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al

; 15584: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00274	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0027b	50		 push	 eax
  0027c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00282	50		 push	 eax
  00283	56		 push	 esi
  00284	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 15600: 		}
; 15601: 
; 15602: 		return;
; 15603: 	}
; 15604: 		
; 15605: 	int iBC_INDEX = g_BloodCastle.EnterUserBridge(iITEM_LEVEL-1, iIndex);

  00289	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iITEM_LEVEL$1$[ebp]
  0028f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00292	48		 dec	 eax
  00293	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00298	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv679[ebp], eax
  0029e	56		 push	 esi
  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 ?EnterUserBridge@CBloodCastle@@QAEHHH@Z ; CBloodCastle::EnterUserBridge
  002a5	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _iBC_INDEX$1$[ebp], eax

; 15606: 
; 15607: 	if ( iBC_INDEX == -1 )

  002ab	83 f8 ff	 cmp	 eax, -1
  002ae	75 0c		 jne	 SHORT $LN28@CGRequestE

; 15608: 	{
; 15609: 		pResult.Result = 5;

  002b0	c6 85 fb fe ff
	ff 05		 mov	 BYTE PTR _pResult$[ebp+3], 5

; 15610: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15611: 		return;

  002b7	e9 da fe ff ff	 jmp	 $LN61@CGRequestE
$LN28@CGRequestE:

; 15612: 	}
; 15613: 
; 15614: 	if ( (gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,18) ||

  002bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c1	8b 8c 03 c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4544]
  002c8	0f b7 54 39 06	 movzx	 edx, WORD PTR [ecx+edi+6]
  002cd	66 3b 95 dc fe
	ff ff		 cmp	 dx, WORD PTR tv631[ebp]
  002d4	74 69		 je	 SHORT $LN31@CGRequestE
  002d6	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv638[ebp]
  002dc	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  002e4	66 3b d0	 cmp	 dx, ax
  002e7	0f 85 84 00 00
	00		 jne	 $LN32@CGRequestE
  002ed	f3 0f 10 44 39
	24		 movss	 xmm0, DWORD PTR [ecx+edi+36]
  002f3	0f 2e c1	 ucomiss xmm0, xmm1
  002f6	9f		 lahf
  002f7	f6 c4 44	 test	 ah, 68			; 00000044H
  002fa	7b 43		 jnp	 SHORT $LN31@CGRequestE

; 15621: 	}
; 15622: 	else if (gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47) && gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability > 1.0f )

  002fc	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv638[ebp]
  00302	66 3b d0	 cmp	 dx, ax
  00305	75 6a		 jne	 SHORT $LN32@CGRequestE
  00307	0f 2f c1	 comiss	 xmm0, xmm1
  0030a	76 65		 jbe	 SHORT $LN32@CGRequestE

; 15623: 	{
; 15624: 		gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability -= 1.0f;

  0030c	f3 0f 5c c1	 subss	 xmm0, xmm1

; 15625: 		GCItemDurSend2(iIndex, btInvisibleCourtItemPos,(BYTE)gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability, 0);

  00310	6a 00		 push	 0
  00312	f3 0f 11 44 39
	24		 movss	 DWORD PTR [ecx+edi+36], xmm0
  00318	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0031d	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00324	f3 0f 2c 44 38
	24		 cvttss2si eax, DWORD PTR [eax+edi+36]
  0032a	0f b6 c0	 movzx	 eax, al
  0032d	50		 push	 eax
  0032e	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _btInvisibleCourtItemPos$[ebp]
  00334	56		 push	 esi
  00335	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  0033a	83 c4 10	 add	 esp, 16			; 00000010H
  0033d	eb 32		 jmp	 SHORT $LN32@CGRequestE
$LN31@CGRequestE:

; 15615: 		(gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Type == ITEMGET(13,47)) &&
; 15616: 		gObj[iIndex].pInventory[btInvisibleCourtItemPos].m_Durability == 1.0f ))
; 15617: 	{
; 15618: 		gObjInventoryDeleteItem(iIndex, btInvisibleCourtItemPos);

  0033f	ff b5 d8 fe ff
	ff		 push	 DWORD PTR tv685[ebp]
  00345	56		 push	 esi
  00346	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 15619: 		GCInventoryItemDeleteSend(iIndex, btInvisibleCourtItemPos, 1);

  0034b	6a 01		 push	 1
  0034d	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _btInvisibleCourtItemPos$[ebp]
  00353	56		 push	 esi
  00354	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 15620: 		DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);

  00359	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00360	50		 push	 eax
  00361	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00367	50		 push	 eax
  00368	56		 push	 esi
  00369	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0036e	83 c4 20	 add	 esp, 32			; 00000020H
$LN32@CGRequestE:

; 15626: 	}
; 15627: 
; 15628: 	gObj[iIndex].m_cBloodCastleIndex = iITEM_LEVEL-1;

  00371	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00376	8a 8d f0 fe ff
	ff		 mov	 cl, BYTE PTR _iITEM_LEVEL$1$[ebp]
  0037c	fe c9		 dec	 cl

; 15629: 	gObj[iIndex].m_cBloodCastleSubIndex = iBC_INDEX;
; 15630: 	gObj[iIndex].m_iBloodCastleEXP = 0;
; 15631: 	gObj[iIndex].m_IfState.state = 0;
; 15632: 	gObj[iIndex].m_IfState.type = 0;
; 15633: 	gObj[iIndex].m_IfState.use = 0;
; 15634: 
; 15635: 	g_BloodCastle.SearchUserDeleteQuestItem(iIndex);

  0037e	56		 push	 esi
  0037f	88 8c 03 36 12
	00 00		 mov	 BYTE PTR [ebx+eax+4662], cl
  00386	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0038b	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _iBC_INDEX$1$[ebp]
  00391	88 8c 03 37 12
	00 00		 mov	 BYTE PTR [ebx+eax+4663], cl
  00398	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0039d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a2	c7 84 03 38 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [ebx+eax+4664], 0
  003ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003b2	83 a4 03 b8 11
	00 00 c3	 and	 DWORD PTR [ebx+eax+4536], -61 ; ffffffc3H
  003ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003bf	81 a4 03 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [ebx+eax+4536], -65473 ; ffff003fH
  003ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003cf	83 a4 03 b8 11
	00 00 fc	 and	 DWORD PTR [ebx+eax+4536], -4 ; fffffffcH
  003d7	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem

; 15636: 	char szTemp[256];
; 15637: 	wsprintf(szTemp, lMsg.Get(MSGGET(4, 147)), iITEM_LEVEL);

  003dc	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _iITEM_LEVEL$1$[ebp]
  003e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003e7	68 93 04 00 00	 push	 1171			; 00000493H
  003ec	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003f1	50		 push	 eax
  003f2	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  003f8	50		 push	 eax
  003f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 15638: 	GCServerMsgStringSend(szTemp, iIndex, 1);

  003ff	6a 01		 push	 1
  00401	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00407	56		 push	 esi
  00408	50		 push	 eax
  00409	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 15639: 
; 15640: 	switch ( iITEM_LEVEL )

  0040e	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv679[ebp]
  00414	83 c4 18	 add	 esp, 24			; 00000018H
  00417	83 f8 07	 cmp	 eax, 7
  0041a	77 31		 ja	 SHORT $LN5@CGRequestE
  0041c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN64@CGRequestE[eax*4]
$LN33@CGRequestE:

; 15641: 	{
; 15642: 		case 1:
; 15643: 			gObjMoveGate(iIndex, 66);

  00423	6a 42		 push	 66			; 00000042H

; 15644: 			break;

  00425	eb 1d		 jmp	 SHORT $LN60@CGRequestE
$LN34@CGRequestE:

; 15645: 		case 2:
; 15646: 			gObjMoveGate(iIndex, 67);

  00427	6a 43		 push	 67			; 00000043H

; 15647: 			break;

  00429	eb 19		 jmp	 SHORT $LN60@CGRequestE
$LN35@CGRequestE:

; 15648: 		case 3:
; 15649: 			gObjMoveGate(iIndex, 68);

  0042b	6a 44		 push	 68			; 00000044H

; 15650: 			break;

  0042d	eb 15		 jmp	 SHORT $LN60@CGRequestE
$LN36@CGRequestE:

; 15651: 		case 4:
; 15652: 			gObjMoveGate(iIndex, 69);

  0042f	6a 45		 push	 69			; 00000045H

; 15653: 			break;

  00431	eb 11		 jmp	 SHORT $LN60@CGRequestE
$LN37@CGRequestE:

; 15654: 		case 5:
; 15655: 			gObjMoveGate(iIndex, 70);

  00433	6a 46		 push	 70			; 00000046H

; 15656: 			break;

  00435	eb 0d		 jmp	 SHORT $LN60@CGRequestE
$LN38@CGRequestE:

; 15657: 		case 6:
; 15658: 			gObjMoveGate(iIndex, 71);

  00437	6a 47		 push	 71			; 00000047H

; 15659: 			break;

  00439	eb 09		 jmp	 SHORT $LN60@CGRequestE
$LN39@CGRequestE:

; 15660: 		case 7:
; 15661: 			gObjMoveGate(iIndex, 80);

  0043b	6a 50		 push	 80			; 00000050H

; 15662: 			break;

  0043d	eb 05		 jmp	 SHORT $LN60@CGRequestE
$LN40@CGRequestE:

; 15663: 		case 8:
; 15664: 			gObjMoveGate(iIndex,271);

  0043f	68 0f 01 00 00	 push	 271			; 0000010fH
$LN60@CGRequestE:
  00444	56		 push	 esi
  00445	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0044a	83 c4 08	 add	 esp, 8
$LN5@CGRequestE:

; 15665: 			break;
; 15666: 	}
; 15667: 
; 15668: 	LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) Entered Blood Castle (Invisible Cloak Serial:%d)",

  0044d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00453	ff b5 ec fe ff
	ff		 push	 DWORD PTR _dwITEM_SERIAL$1$[ebp]
  00459	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0045c	03 c3		 add	 eax, ebx
  0045e	50		 push	 eax
  0045f	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00462	03 c3		 add	 eax, ebx
  00464	50		 push	 eax
  00465	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _iITEM_LEVEL$1$[ebp]
  0046b	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@KOIEBFHD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  00470	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00476	83 c4 14	 add	 esp, 20			; 00000014H
  00479	5f		 pop	 edi
  0047a	5b		 pop	 ebx
  0047b	5e		 pop	 esi

; 15669: 		iITEM_LEVEL, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);
; 15670: }

  0047c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0047f	33 cd		 xor	 ecx, ebp
  00481	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00486	8b e5		 mov	 esp, ebp
  00488	5d		 pop	 ebp
  00489	c3		 ret	 0
$LN24@CGRequestE:

; 15585: 	}
; 15586: 	else 
; 15587: 	{
; 15588: 		if ( iRESULT == -1 )

  0048a	83 f8 ff	 cmp	 eax, -1
  0048d	75 0c		 jne	 SHORT $LN26@CGRequestE

; 15589: 		{
; 15590: 			pResult.Result = 4;

  0048f	c6 85 fb fe ff
	ff 04		 mov	 BYTE PTR _pResult$[ebp+3], 4

; 15591: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15592: 			return;

  00496	e9 fb fc ff ff	 jmp	 $LN61@CGRequestE
$LN26@CGRequestE:

; 15593: 		}
; 15594: 
; 15595: 		if ( iRESULT == 1 )

  0049b	83 f8 01	 cmp	 eax, 1
  0049e	0f 85 0a fd ff
	ff		 jne	 $LN57@CGRequestE

; 15596: 		{
; 15597: 			pResult.Result = 3;

  004a4	c6 85 fb fe ff
	ff 03		 mov	 BYTE PTR _pResult$[ebp+3], 3

; 15598: 			DataSend(iIndex, (LPBYTE)&pResult, pResult.h.size);
; 15599: 			return;

  004ab	e9 e6 fc ff ff	 jmp	 $LN61@CGRequestE
$LN53@CGRequestE:

; 15481: 	{
; 15482: 		LogAdd("return %s %d", __FILE__, __LINE__);

  004b0	68 7a 3c 00 00	 push	 15482			; 00003c7aH
  004b5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  004ba	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  004bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 15669: 		iITEM_LEVEL, gObj[iIndex].AccountID, gObj[iIndex].Name, dwITEM_SERIAL);
; 15670: }

  004c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  004cb	33 cd		 xor	 ecx, ebp
  004cd	5e		 pop	 esi
  004ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d3	8b e5		 mov	 esp, ebp
  004d5	5d		 pop	 ebp
  004d6	c3		 ret	 0
  004d7	90		 npad	 1
$LN64@CGRequestE:
  004d8	00 00 00 00	 DD	 $LN33@CGRequestE
  004dc	00 00 00 00	 DD	 $LN34@CGRequestE
  004e0	00 00 00 00	 DD	 $LN35@CGRequestE
  004e4	00 00 00 00	 DD	 $LN36@CGRequestE
  004e8	00 00 00 00	 DD	 $LN37@CGRequestE
  004ec	00 00 00 00	 DD	 $LN38@CGRequestE
  004f0	00 00 00 00	 DD	 $LN39@CGRequestE
  004f4	00 00 00 00	 DD	 $LN40@CGRequestE
?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ENDP ; CGRequestEnterBloodCastle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGCloseWindow@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGCloseWindow@@YAXH@Z PROC				; CGCloseWindow, COMDAT

; 15438: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15439: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type )

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000e	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00014	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  0001b	a8 03		 test	 al, 3
  0001d	0f 84 07 01 00
	00		 je	 $LN2@CGCloseWin
  00023	c1 e8 06	 shr	 eax, 6
  00026	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0002b	0f 84 f9 00 00
	00		 je	 $LN2@CGCloseWin

; 15440: 	{
; 15441: 		if ( gObj[aIndex].m_IfState.type == 7 )

  00031	83 f8 07	 cmp	 eax, 7
  00034	0f 84 f0 00 00
	00		 je	 $LN2@CGCloseWin

; 15442: 			return;
; 15443: 
; 15444: 		if ( gObj[aIndex].m_IfState.type == 10 && gObj[aIndex].TargetShopNumber == 229 )	// Marlon

  0003a	53		 push	 ebx
  0003b	83 cb ff	 or	 ebx, -1
  0003e	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00041	75 2c		 jne	 SHORT $LN4@CGCloseWin
  00043	b8 e5 00 00 00	 mov	 eax, 229		; 000000e5H
  00048	66 39 84 0e 3a
	06 00 00	 cmp	 WORD PTR [esi+ecx+1594], ax
  00050	75 1d		 jne	 SHORT $LN4@CGCloseWin

; 15445: 		{
; 15446: 			gQeustNpcTeleport.TalkRefDel();

  00052	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  00057	e8 00 00 00 00	 call	 ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ; CQeustNpcTeleport::TalkRefDel

; 15447: 			gObj[aIndex].TargetShopNumber = -1;

  0005c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00061	66 89 9c 06 3a
	06 00 00	 mov	 WORD PTR [esi+eax+1594], bx
  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN4@CGCloseWin:

; 15448: 		}
; 15449: 
; 15450: 		if ( gObj[aIndex].m_IfState.type == 3 )

  0006f	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  00076	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00079	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0007e	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00083	75 0d		 jne	 SHORT $LN5@CGCloseWin

; 15451: 		{
; 15452: 			gObj[aIndex].TargetShopNumber = -1;

  00085	66 89 9a 3a 06
	00 00		 mov	 WORD PTR [edx+1594], bx
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN5@CGCloseWin:

; 15453: 		}
; 15454: 
; 15455: 		if ( gObj[aIndex].m_IfState.type == 1 )

  00092	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  00099	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0009e	5b		 pop	 ebx
  0009f	83 f8 40	 cmp	 eax, 64			; 00000040H
  000a2	75 0f		 jne	 SHORT $LN6@CGCloseWin

; 15456: 		{
; 15457: 			CGTradeCancelButtonRecv(aIndex);

  000a4	57		 push	 edi
  000a5	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b0	83 c4 04	 add	 esp, 4
$LN6@CGCloseWin:

; 15458: 		}
; 15459: 
; 15460: 		if ( gObj[aIndex].m_IfState.type == 6 )

  000b3	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  000ba	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000bf	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  000c4	75 0f		 jne	 SHORT $LN7@CGCloseWin

; 15461: 		{
; 15462: 			CGWarehouseUseEnd(aIndex);

  000c6	57		 push	 edi
  000c7	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d2	83 c4 04	 add	 esp, 4
$LN7@CGCloseWin:

; 15463: 		}
; 15464: 
; 15465: 		if ( gObj[aIndex].m_IfState.type == 13 )

  000d5	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  000dc	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  000df	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000e4	3d 40 03 00 00	 cmp	 eax, 832		; 00000340H
  000e9	75 1a		 jne	 SHORT $LN8@CGCloseWin

; 15466: 		{
; 15467: 			g_ChaosBox.ChaosBoxInit(&gObj[aIndex]);

  000eb	52		 push	 edx
  000ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  000f1	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 15468: 			gObjInventoryCommit(aIndex);

  000f6	57		 push	 edi
  000f7	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00102	83 c4 04	 add	 esp, 4
$LN8@CGCloseWin:

; 15469: 		}
; 15470: 
; 15471: 		gObj[aIndex].m_IfState.state = 0;

  00105	83 a4 0e b8 11
	00 00 c3	 and	 DWORD PTR [esi+ecx+4536], -61 ; ffffffc3H

; 15472: 		gObj[aIndex].m_IfState.type = 0;

  0010d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00112	81 a4 06 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [esi+eax+4536], -65473 ; ffff003fH

; 15473: 		gObj[aIndex].m_IfState.use = 0;

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00122	83 a4 06 b8 11
	00 00 fc	 and	 DWORD PTR [esi+eax+4536], -4 ; fffffffcH
$LN2@CGCloseWin:
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi

; 15474: 	}
; 15475: }

  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
?CGCloseWindow@@YAXH@Z ENDP				; CGCloseWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSendQuestPrize@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_Type$ = 12						; size = 1
_Count$ = 16						; size = 1
?GCSendQuestPrize@@YAXHEE@Z PROC			; GCSendQuestPrize, COMDAT

; 15418: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 15419: 	CGRequestQuestInfo(aIndex);

  00007	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000a	57		 push	 edi
  0000b	56		 push	 esi
  0000c	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo

; 15420: 	LPOBJ lpObj = &gObj[aIndex];

  00011	69 fe 40 27 00
	00		 imul	 edi, esi, 10048

; 15421: 
; 15422: 	PMSG_SETQUEST_PRIZE pMsg;
; 15423: 
; 15424: 	PHeadSetB((LPBYTE)&pMsg, 0xA3, sizeof(pMsg));

  00017	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	6a 07		 push	 7
  0001c	68 a3 00 00 00	 push	 163			; 000000a3H
  00021	50		 push	 eax
  00022	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15425: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0002d	8b 07		 mov	 eax, DWORD PTR [edi]
  0002f	c1 e8 08	 shr	 eax, 8
  00032	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 15426: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);

  00035	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00038	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 15427: 	pMsg.Type = Type;

  0003b	8a 45 0c	 mov	 al, BYTE PTR _Type$[ebp]
  0003e	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 15428: 	pMsg.Count = Count;

  00041	8a 45 10	 mov	 al, BYTE PTR _Count$[ebp]
  00044	88 45 fe	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 15429: 
; 15430: 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00047	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004a	6a 07		 push	 7
  0004c	50		 push	 eax
  0004d	56		 push	 esi
  0004e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 15431: 	MsgSendV2(lpObj, (LPBYTE)&pMsg, sizeof(pMsg));

  00053	6a 07		 push	 7
  00055	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00058	50		 push	 eax
  00059	57		 push	 edi
  0005a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0005f	83 c4 28	 add	 esp, 40			; 00000028H
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 15432: }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?GCSendQuestPrize@@YAXHEE@Z ENDP			; GCSendQuestPrize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z PROC		; CGSetQuestState, COMDAT

; 15392: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 15393: 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 15394: 	PMSG_SETQUEST_RESULT pMsg;
; 15395: 
; 15396: 	PHeadSetB((LPBYTE)&pMsg, 0xA2, sizeof(pMsg));

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  00015	6a 06		 push	 6
  00017	68 a2 00 00 00	 push	 162			; 000000a2H
  0001c	50		 push	 eax
  0001d	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15397: 	pMsg.QuestIndex = lpMsg->QuestIndex;

  00028	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]

; 15398: 	pMsg.Result = g_QuestInfo.SetQuestState(lpObj, lpMsg->QuestIndex, lpMsg->State);

  00031	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00035	50		 push	 eax
  00036	0f b6 c1	 movzx	 eax, cl
  00039	50		 push	 eax
  0003a	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+3], cl
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 ?SetQuestState@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@HH@Z ; CQuestInfo::SetQuestState
  00048	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 15399: 	pMsg.State = g_QuestInfo.GetQuestStateBYTE(lpObj, lpMsg->QuestIndex);

  0004b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00050	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00054	50		 push	 eax
  00055	57		 push	 edi
  00056	e8 00 00 00 00	 call	 ?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestStateBYTE
  0005b	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 15400: 
; 15401: 	DataSend(aIndex, (UCHAR*)&pMsg, sizeof(pMsg));

  0005e	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00061	6a 06		 push	 6
  00063	50		 push	 eax
  00064	53		 push	 ebx
  00065	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx

; 15402: }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z ENDP		; CGSetQuestState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSendQuestInfo@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_QuestIndex$ = 12					; size = 4
?GCSendQuestInfo@@YAXHH@Z PROC				; GCSendQuestInfo, COMDAT

; 15365: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 15366: 	CGRequestQuestInfo(aIndex);

  00008	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo

; 15367: 
; 15368: 	LPOBJ lpObj = &gObj[aIndex];

  00011	69 f7 40 27 00
	00		 imul	 esi, edi, 10048

; 15369: 	PMSG_SETQUEST pMsg;
; 15370: 
; 15371: 	PHeadSetB((LPBYTE)&pMsg, 0xA1, sizeof(pMsg));

  00017	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	6a 05		 push	 5
  0001c	68 a1 00 00 00	 push	 161			; 000000a1H
  00021	50		 push	 eax
  00022	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15372: 	pMsg.QuestIndex = QuestIndex;

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _QuestIndex$[ebp]
  00030	83 c4 10	 add	 esp, 16			; 00000010H

; 15373: 	pMsg.State = g_QuestInfo.GetQuestStateBYTE(lpObj, QuestIndex);

  00033	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00038	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  0003b	50		 push	 eax
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 ?GetQuestStateBYTE@CQuestInfo@@QAEEPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestStateBYTE
  00042	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 15374: 
; 15375: 	if ( pMsg.State != 0 )

  00045	84 c0		 test	 al, al
  00047	74 0f		 je	 SHORT $LN2@GCSendQues

; 15376: 		DataSend(aIndex, (UCHAR*)&pMsg, sizeof(pMsg));

  00049	6a 05		 push	 5
  0004b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004e	50		 push	 eax
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCSendQues:
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi

; 15377: }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?GCSendQuestInfo@@YAXHH@Z ENDP				; GCSendQuestInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\questinfo.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\questinfo.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGRequestQuestInfo@@YAXH@Z
_TEXT	SEGMENT
_lpObj$1$ = -72						; size = 4
_aIndex$GSCopy$1$ = -68					; size = 4
_questcount$1$ = -64					; size = 4
_pMsg$ = -60						; size = 54
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?CGRequestQuestInfo@@YAXH@Z PROC			; CGRequestQuestInfo, COMDAT

; 15311: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00013	57		 push	 edi

; 15312: 	LPOBJ lpObj = &gObj[aIndex];

  00014	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  0001a	89 45 bc	 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], eax
  0001d	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00023	89 7d b8	 mov	 DWORD PTR _lpObj$1$[ebp], edi

; 15313: 
; 15314: 	if ( lpObj->m_SendQuestInfo != 0 )

  00026	80 bf 56 14 00
	00 00		 cmp	 BYTE PTR [edi+5206], 0
  0002d	0f 85 97 00 00
	00		 jne	 $LN1@CGRequestQ

; 15323: 	memcpy(pMsg.State, lpObj->m_Quest, sizeof(pMsg.State));

  00033	0f 10 87 24 14
	00 00		 movups	 xmm0, XMMWORD PTR [edi+5156]
; File c:\users\michel\desktop\source\gameserver\source\questinfo.h

; 84   : 	int GetQeustCount(){return m_QuestCount;}

  0003a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_QuestInfo@@3VCQuestInfo@@A+4
  0003f	53		 push	 ebx
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 15323: 	memcpy(pMsg.State, lpObj->m_Quest, sizeof(pMsg.State));

  00040	0f 11 45 c8	 movups	 XMMWORD PTR _pMsg$[ebp+4], xmm0
; File c:\users\michel\desktop\source\gameserver\source\questinfo.h

; 84   : 	int GetQeustCount(){return m_QuestCount;}

  00044	89 45 c0	 mov	 DWORD PTR _questcount$1$[ebp], eax
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 15323: 	memcpy(pMsg.State, lpObj->m_Quest, sizeof(pMsg.State));

  00047	0f 10 87 34 14
	00 00		 movups	 xmm0, XMMWORD PTR [edi+5172]
  0004e	56		 push	 esi
  0004f	33 f6		 xor	 esi, esi

; 15324: 
; 15325: 	int i;
; 15326: 	for (i=0;i<MAX_QUEST_INFO;i++)

  00051	33 db		 xor	 ebx, ebx
  00053	0f 11 45 d8	 movups	 XMMWORD PTR _pMsg$[ebp+20], xmm0
  00057	0f 10 87 44 14
	00 00		 movups	 xmm0, XMMWORD PTR [edi+5188]
  0005e	0f 11 45 e8	 movups	 XMMWORD PTR _pMsg$[ebp+36], xmm0
  00062	66 8b 87 54 14
	00 00		 mov	 ax, WORD PTR [edi+5204]
  00069	8b 7d c0	 mov	 edi, DWORD PTR _questcount$1$[ebp]
  0006c	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+52], ax
$LL4@CGRequestQ:

; 15327: 	{
; 15328: 		lpQuestInfo = g_QuestInfo.GetQuestInfo(i);

  00070	53		 push	 ebx
  00071	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00076	e8 00 00 00 00	 call	 ?GetQuestInfo@CQuestInfo@@QAEPAUQUEST_INFO@@H@Z ; CQuestInfo::GetQuestInfo

; 15329: 
; 15330: 		if ( lpQuestInfo )

  0007b	85 c0		 test	 eax, eax
  0007d	74 05		 je	 SHORT $LN2@CGRequestQ

; 15331: 		{
; 15332: 			foundquest++;

  0007f	46		 inc	 esi

; 15333: 
; 15334: 			if ( foundquest == questcount )

  00080	3b f7		 cmp	 esi, edi
  00082	74 09		 je	 SHORT $LN12@CGRequestQ
$LN2@CGRequestQ:

; 15324: 
; 15325: 	int i;
; 15326: 	for (i=0;i<MAX_QUEST_INFO;i++)

  00084	43		 inc	 ebx
  00085	81 fb c8 00 00
	00		 cmp	 ebx, 200		; 000000c8H
  0008b	7c e3		 jl	 SHORT $LL4@CGRequestQ
$LN12@CGRequestQ:

; 15335: 			{
; 15336: 				break;
; 15337: 			}
; 15338: 		}
; 15339: 	}
; 15340: 
; 15341: 	int iSize = i/4+5;

  0008d	8b c3		 mov	 eax, ebx
  0008f	99		 cdq
  00090	83 e2 03	 and	 edx, 3
  00093	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]
  00096	c1 fe 02	 sar	 esi, 2

; 15342: 
; 15343: 	PHeadSetB((LPBYTE)&pMsg, 0xA0, iSize);

  00099	8d 45 c4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009c	83 c6 05	 add	 esi, 5
  0009f	56		 push	 esi
  000a0	68 a0 00 00 00	 push	 160			; 000000a0H
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15344: 	pMsg.Count = i;
; 15345: 	DataSend(aIndex, (LPBYTE)&pMsg, iSize);

  000ab	56		 push	 esi
  000ac	8d 45 c4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000af	88 5d c7	 mov	 BYTE PTR _pMsg$[ebp+3], bl
  000b2	50		 push	 eax
  000b3	ff 75 bc	 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  000b6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 15346: 	lpObj->m_SendQuestInfo = true;

  000bb	8b 7d b8	 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  000be	83 c4 18	 add	 esp, 24			; 00000018H
  000c1	5e		 pop	 esi
  000c2	c6 87 56 14 00
	00 01		 mov	 BYTE PTR [edi+5206], 1
  000c9	5b		 pop	 ebx
$LN1@CGRequestQ:

; 15347: 
; 15348: }

  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cd	33 cd		 xor	 ecx, ebp
  000cf	5f		 pop	 edi
  000d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?CGRequestQuestInfo@@YAXH@Z ENDP			; CGRequestQuestInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z PROC ; GCUseRenaChangeZenRecv, COMDAT

; 15277: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 15278: 	if ( gObj[aIndex].UseEventServer )

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001a	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00020	83 bc 06 e8 13
	00 00 00	 cmp	 DWORD PTR [esi+eax+5096], 0
  00028	0f 85 94 00 00
	00		 jne	 $LN6@GCUseRenaC

; 15279: 		return;
; 15280: 
; 15281: 	gObj[aIndex].UseEventServer = TRUE;
; 15282: 
; 15283: 	PMSG_REQ_RESET_EVENTCHIP pMsg;
; 15284: 
; 15285: 	if ( lpMsg->btType == 1 )	// Stone?

  0002e	53		 push	 ebx
  0002f	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00032	c7 84 06 e8 13
	00 00 01 00 00
	00		 mov	 DWORD PTR [esi+eax+5096], 1

; 15286: 		PHeadSetB((LPBYTE)&pMsg, 0x09, sizeof(pMsg));

  0003d	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00040	6a 14		 push	 20			; 00000014H
  00042	80 7b 03 01	 cmp	 BYTE PTR [ebx+3], 1
  00046	75 04		 jne	 SHORT $LN3@GCUseRenaC
  00048	6a 09		 push	 9

; 15287: 	else

  0004a	eb 02		 jmp	 SHORT $LN12@GCUseRenaC
$LN3@GCUseRenaC:

; 15288: 		PHeadSetB((LPBYTE)&pMsg, 0x04, sizeof(pMsg));

  0004c	6a 04		 push	 4
$LN12@GCUseRenaC:
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15289: 
; 15290: 	pMsg.iINDEX = aIndex;
; 15291: 	strcpy(pMsg.szUID, gObj[aIndex].AccountID);

  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005a	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp+8]
  0005d	83 c1 52	 add	 ecx, 82			; 00000052H
  00060	89 7d ec	 mov	 DWORD PTR _pMsg$[ebp+4], edi
  00063	03 ce		 add	 ecx, esi
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	2b d1		 sub	 edx, ecx
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL8@GCUseRenaC:
  00070	8a 01		 mov	 al, BYTE PTR [ecx]
  00072	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00075	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00079	84 c0		 test	 al, al
  0007b	75 f3		 jne	 SHORT $LL8@GCUseRenaC

; 15292: 
; 15293: 	DataSendEventChip((PCHAR)&pMsg, sizeof(pMsg));

  0007d	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00080	6a 14		 push	 20			; 00000014H
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 15294: 
; 15295: 	if ( lpMsg->btType == 0x01 )
; 15296: 		LogAddTD("[EventChip] [%s][%s] Request Change Stones", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008e	83 c4 08	 add	 esp, 8
  00091	80 7b 03 01	 cmp	 BYTE PTR [ebx+3], 1
  00095	5b		 pop	 ebx
  00096	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00099	75 10		 jne	 SHORT $LN5@GCUseRenaC
  0009b	03 c6		 add	 eax, esi
  0009d	50		 push	 eax
  0009e	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000a1	03 c6		 add	 eax, esi
  000a3	50		 push	 eax
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LPOFFCFH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@

; 15297: 	else

  000a9	eb 0e		 jmp	 SHORT $LN13@GCUseRenaC
$LN5@GCUseRenaC:

; 15298: 		LogAddTD("[EventChip] [%s][%s] Request Change Rena", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000ab	03 c6		 add	 eax, esi
  000ad	50		 push	 eax
  000ae	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000b1	03 c6		 add	 eax, esi
  000b3	50		 push	 eax
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@OIKODDDO@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Cha@
$LN13@GCUseRenaC:
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@GCUseRenaC:

; 15299: }

  000c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c5	5f		 pop	 edi
  000c6	33 cd		 xor	 ecx, ebp
  000c8	5e		 pop	 esi
  000c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ENDP ; GCUseRenaChangeZenRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCUseEndEventChipRescv@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?GCUseEndEventChipRescv@@YAXH@Z PROC			; GCUseEndEventChipRescv, COMDAT

; 15252: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 15253: 	if ( !gObjIsConnectedGP(aIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 1d		 jne	 SHORT $LN2@GCUseEndEv

; 15254: 	{
; 15255: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00014	68 97 3b 00 00	 push	 15255			; 00003b97H
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00023	6a 02		 push	 2
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	5e		 pop	 esi

; 15264: 	}
; 15265: }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN2@GCUseEndEv:

; 15256: 		return;
; 15257: 	}
; 15258: 
; 15259: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 9 )

  00031	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  00037	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	8b 8c 16 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4536]
  00044	f6 c1 03	 test	 cl, 3
  00047	74 35		 je	 SHORT $LN3@GCUseEndEv
  00049	8b c1		 mov	 eax, ecx
  0004b	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00050	3d 40 02 00 00	 cmp	 eax, 576		; 00000240H
  00055	75 27		 jne	 SHORT $LN3@GCUseEndEv

; 15260: 	{
; 15261: 		gObj[aIndex].m_IfState.state = 0;

  00057	83 e1 c3	 and	 ecx, -61		; ffffffc3H
  0005a	89 8c 16 b8 11
	00 00		 mov	 DWORD PTR [esi+edx+4536], ecx

; 15262: 		gObj[aIndex].m_IfState.type = 0;

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	81 a4 02 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [edx+eax+4536], -65473 ; ffff003fH

; 15263: 		gObj[aIndex].m_IfState.use = 0;

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00076	83 a4 02 b8 11
	00 00 fc	 and	 DWORD PTR [edx+eax+4536], -4 ; fffffffcH
$LN3@GCUseEndEv:
  0007e	5e		 pop	 esi

; 15264: 	}
; 15265: }

  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?GCUseEndEventChipRescv@@YAXH@Z ENDP			; GCUseEndEventChipRescv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z
_TEXT	SEGMENT
_pMsg$ = -292						; size = 20
_Result$1 = -272					; size = 10
_msg$2 = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z PROC	; GCGetMutoNumRecv, COMDAT

; 15207: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 15208: 	if ( gObj[aIndex].MutoNumber != 0 )

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	56		 push	 esi
  00019	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001c	57		 push	 edi
  0001d	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00023	83 bc 38 e4 13
	00 00 00	 cmp	 DWORD PTR [eax+edi+5092], 0
  0002b	74 34		 je	 SHORT $LN2@GCGetMutoN

; 15209: 	{
; 15210: 		char msg[255];
; 15211: 		wsprintf(msg, "   ");

  0002d	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$2[ebp]
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DNEDNODE@?$MA?L?$LJ?L?5?$LH?g?$LA?$KB?$LF?e?$MA?G?5?$LM?$PN?$MA?Z?$LA?$KB?5?$MA?V?$LN?$MA?$LE?O?$LE?Y?$AA@
  00038	50		 push	 eax
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 15212: 		GCServerMsgStringSend(msg, aIndex, 1);

  0003f	6a 01		 push	 1
  00041	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$2[ebp]
  00047	56		 push	 esi
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 15243: 
; 15244: 	LogAddTD("[EventChip] [%s][%s] Request MutoNumber",

  0004e	83 c4 14	 add	 esp, 20			; 00000014H
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 15245: 		gObj[aIndex].AccountID, gObj[aIndex].Name);
; 15246: }

  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	33 cd		 xor	 ecx, ebp
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN2@GCGetMutoN:

; 15213: 		return;
; 15214: 	}
; 15215: 
; 15216: 	if ( gObj[aIndex].UseEventServer != FALSE )

  00061	83 bc 38 e8 13
	00 00 00	 cmp	 DWORD PTR [eax+edi+5096], 0
  00069	0f 85 dc 00 00
	00		 jne	 $LN1@GCGetMutoN

; 15217: 		return;
; 15218: 
; 15219: 	gObj[aIndex].UseEventServer = TRUE;
; 15220: 
; 15221: 	if ( !gObjFind10EventChip(aIndex) )

  0006f	56		 push	 esi
  00070	c7 84 38 e8 13
	00 00 01 00 00
	00		 mov	 DWORD PTR [eax+edi+5096], 1
  0007b	e8 00 00 00 00	 call	 ?gObjFind10EventChip@@YAHH@Z ; gObjFind10EventChip
  00080	83 c4 04	 add	 esp, 4
  00083	85 c0		 test	 eax, eax
  00085	75 5d		 jne	 SHORT $LN4@GCGetMutoN

; 15222: 	{
; 15223: 		PMSG_GETMUTONUMBER_RESULT Result;
; 15224: 
; 15225: 		PHeadSetB((LPBYTE)&Result, 0x96, sizeof(Result));

  00087	6a 0a		 push	 10			; 0000000aH
  00089	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _Result$1[ebp]
  0008f	68 96 00 00 00	 push	 150			; 00000096H
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15226: 		Result.MutoNum[0] = -1;

  0009a	83 c8 ff	 or	 eax, -1
  0009d	66 89 85 f4 fe
	ff ff		 mov	 WORD PTR _Result$1[ebp+4], ax

; 15227: 		Result.MutoNum[1] = 0;

  000a4	33 c0		 xor	 eax, eax
  000a6	89 85 f6 fe ff
	ff		 mov	 DWORD PTR _Result$1[ebp+6], eax

; 15228: 		Result.MutoNum[2] = 0;
; 15229: 
; 15230: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  000ac	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _Result$1[ebp+1]
  000b3	50		 push	 eax
  000b4	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _Result$1[ebp]
  000ba	50		 push	 eax
  000bb	56		 push	 esi
  000bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 15231: 		gObj[aIndex].UseEventServer = FALSE;

  000c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c6	83 c4 18	 add	 esp, 24			; 00000018H
  000c9	c7 84 07 e8 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax+5096], 0
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi

; 15245: 		gObj[aIndex].AccountID, gObj[aIndex].Name);
; 15246: }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN4@GCGetMutoN:

; 15232: 
; 15233: 		return;
; 15234: 	}
; 15235: 
; 15236: 	PMSG_REQ_REGISTER_MUTONUM pMsg;
; 15237: 
; 15238: 	PHeadSetB((LPBYTE)&pMsg, 0x03, sizeof(pMsg));

  000e4	6a 14		 push	 20			; 00000014H
  000e6	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ec	6a 03		 push	 3
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15239: 	pMsg.iINDEX = aIndex;
; 15240: 	strcpy(pMsg.szUID, gObj[aIndex].AccountID);

  000f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000fa	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp+8]
  00100	83 c1 52	 add	 ecx, 82			; 00000052H
  00103	89 b5 e0 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+4], esi
  00109	03 cf		 add	 ecx, edi
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010e	2b d1		 sub	 edx, ecx
$LL6@GCGetMutoN:
  00110	8a 01		 mov	 al, BYTE PTR [ecx]
  00112	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00115	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00119	84 c0		 test	 al, al
  0011b	75 f3		 jne	 SHORT $LL6@GCGetMutoN

; 15241: 
; 15242: 	DataSendEventChip((PCHAR)&pMsg, sizeof(pMsg));

  0011d	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00123	6a 14		 push	 20			; 00000014H
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip

; 15243: 
; 15244: 	LogAddTD("[EventChip] [%s][%s] Request MutoNumber",

  0012b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00131	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00134	03 c7		 add	 eax, edi
  00136	50		 push	 eax
  00137	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0013a	03 c7		 add	 eax, edi
  0013c	50		 push	 eax
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@GJEFDNKH@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5Mut@
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00148	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@GCGetMutoN:

; 15245: 		gObj[aIndex].AccountID, gObj[aIndex].Name);
; 15246: }

  0014b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014e	5f		 pop	 edi
  0014f	33 cd		 xor	 ecx, ebp
  00151	5e		 pop	 esi
  00152	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ENDP	; GCGetMutoNumRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z
_TEXT	SEGMENT
_Result$1 = -8						; size = 6
_Result$2 = -8						; size = 6
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z PROC	; GCRegEventChipRecv, COMDAT

; 15098: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 15099: #if (__CUSTOM__ == 1)
; 15100: 	if ( !EVENCHIP_TYPE_RANGE(lpMsg->Type) )

  00006	b8 04 00 00 00	 mov	 eax, 4
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0000f	3a 47 03	 cmp	 al, BYTE PTR [edi+3]
  00012	1b c0		 sbb	 eax, eax
  00014	83 c0 01	 add	 eax, 1
  00017	0f 84 bf 01 00
	00		 je	 $LN1@GCRegEvent

; 15101: 		return;
; 15102: 
; 15103: 	LPOBJ lpObj = &gObj[aIndex];

  0001d	53		 push	 ebx
  0001e	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00021	56		 push	 esi
  00022	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00028	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 15104: 
; 15105: 	if ( lpObj->m_IfState.type == 1 )

  0002e	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  00034	c1 e8 06	 shr	 eax, 6
  00037	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0003c	83 f8 01	 cmp	 eax, 1
  0003f	75 1d		 jne	 SHORT $LN5@GCRegEvent

; 15106: 	{
; 15107: 		LogAddTD("[EventChip] [%s][%s] Attempted ItemCopy using Trade Window",

  00041	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00044	50		 push	 eax
  00045	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00048	50		 push	 eax
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@CMJKPIPK@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	5f		 pop	 edi

; 15193: 
; 15194: #endif
; 15195: }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN5@GCRegEvent:

; 15108: 			lpObj->AccountID, lpObj->Name);
; 15109: 
; 15110: 		return;
; 15111: 	}
; 15112: 
; 15113: 	if ( lpObj->m_IfState.type == 7 )

  0005e	83 f8 07	 cmp	 eax, 7
  00061	75 1d		 jne	 SHORT $LN6@GCRegEvent

; 15114: 	{
; 15115: 		LogAddTD("[EventChip] [%s][%s] Attempted ItemCopy using ChaosBox Window",

  00063	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00066	50		 push	 eax
  00067	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0006a	50		 push	 eax
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@JBAPFEJ@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Attempted?5I@
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	5f		 pop	 edi

; 15193: 
; 15194: #endif
; 15195: }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN6@GCRegEvent:

; 15116: 			lpObj->AccountID, lpObj->Name);
; 15117: 
; 15118: 		return;
; 15119: 	}
; 15120: 
; 15121: 	if ( lpObj->UseEventServer != FALSE )

  00080	83 be e8 13 00
	00 00		 cmp	 DWORD PTR [esi+5096], 0
  00087	74 31		 je	 SHORT $LN7@GCRegEvent

; 15122: 	{
; 15123: 		PMSG_REGEVENTCHIP_RESULT Result;
; 15124: 
; 15125: 		PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  00089	6a 06		 push	 6
  0008b	8d 45 f8	 lea	 eax, DWORD PTR _Result$2[ebp]
  0008e	68 95 00 00 00	 push	 149			; 00000095H
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15126: 		Result.ChipCount = -1;

  00099	83 c8 ff	 or	 eax, -1
  0009c	66 89 45 fc	 mov	 WORD PTR _Result$2[ebp+4], ax

; 15127: 		Result.Type = lpMsg->Type;

  000a0	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  000a3	88 45 fb	 mov	 BYTE PTR _Result$2[ebp+3], al

; 15128: 
; 15129: 		LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #1 %d",

  000a6	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  000aa	50		 push	 eax
  000ab	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000ae	50		 push	 eax
  000af	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  000b2	50		 push	 eax
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@JJFBLCKD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@

; 15130: 			lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);
; 15131: 
; 15132: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);
; 15133: 
; 15134: 		return;

  000b8	eb 4b		 jmp	 SHORT $LN21@GCRegEvent
$LN7@GCRegEvent:

; 15135: 	}
; 15136: 
; 15137: 	int Pos = lpMsg->ChipPos + INVENTORY_BAG_START;

  000ba	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]

; 15138: 	CItem * sitem = &lpObj->pInventory[Pos];

  000be	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c1	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  000c7	03 8e c0 11 00
	00		 add	 ecx, DWORD PTR [esi+4544]

; 15139: 
; 15140: 	if ( !sitem->IsItem() )

  000cd	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000d2	85 c0		 test	 eax, eax
  000d4	75 4e		 jne	 SHORT $LN8@GCRegEvent

; 15141: 	{
; 15142: 		PMSG_REGEVENTCHIP_RESULT Result;
; 15143: 
; 15144: 		PHeadSetB((LPBYTE)&Result, 0x95, sizeof(Result));

  000d6	6a 06		 push	 6
  000d8	8d 45 f8	 lea	 eax, DWORD PTR _Result$1[ebp]
  000db	68 95 00 00 00	 push	 149			; 00000095H
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 15145: 		Result.ChipCount = -1;

  000e6	83 c8 ff	 or	 eax, -1
  000e9	66 89 45 fc	 mov	 WORD PTR _Result$1[ebp+4], ax

; 15146: 		Result.Type = lpMsg->Type;

  000ed	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  000f0	88 45 fb	 mov	 BYTE PTR _Result$1[ebp+3], al

; 15147: 
; 15148: 		LogAddTD("[EventChip] [%s][%s] Not Found EventChip (RegEventchip) #2 %d",

  000f3	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  000f7	50		 push	 eax
  000f8	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000fb	50		 push	 eax
  000fc	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  000ff	50		 push	 eax
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@NOPBMIHD@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Found?5E@
$LN21@GCRegEvent:
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 15149: 			lpObj->AccountID, lpObj->Name, lpMsg->ChipPos);
; 15150: 
; 15151: 		DataSend(aIndex, (LPBYTE)&Result, Result.h.size);

  0010b	0f b6 45 f9	 movzx	 eax, BYTE PTR _Result$1[ebp+1]
  0010f	50		 push	 eax
  00110	8d 45 f8	 lea	 eax, DWORD PTR _Result$1[ebp]
  00113	50		 push	 eax
  00114	53		 push	 ebx
  00115	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0011a	83 c4 28	 add	 esp, 40			; 00000028H
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	5f		 pop	 edi

; 15193: 
; 15194: #endif
; 15195: }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c3		 ret	 0
$LN8@GCRegEvent:

; 15152: 
; 15153: 		return;
; 15154: 	}
; 15155: 
; 15156: 	lpObj->UseEventServer = TRUE;

  00124	c7 86 e8 13 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+5096], 1

; 15157: 
; 15158: 	switch ( lpMsg->Type )

  0012e	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00132	83 e8 00	 sub	 eax, 0
  00135	74 28		 je	 SHORT $LN9@GCRegEvent
  00137	83 e8 01	 sub	 eax, 1
  0013a	0f 85 90 00 00
	00		 jne	 $LN11@GCRegEvent

; 15172: 				}
; 15173: 			}
; 15174: 			break;
; 15175: 		case 0x01:
; 15176: 			{
; 15177: 				int count = gObjGetItemCountInIventory(lpObj->m_Index,14,21,1);	// Stone

  00140	6a 01		 push	 1
  00142	6a 15		 push	 21			; 00000015H
  00144	6a 0e		 push	 14			; 0000000eH
  00146	ff 36		 push	 DWORD PTR [esi]
  00148	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory

; 15178: 
; 15179: 				if(count >= g_StoneCount)

  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_StoneCount@@3HA ; g_StoneCount
  00153	83 c4 10	 add	 esp, 16			; 00000010H
  00156	3b c1		 cmp	 eax, ecx
  00158	7c 67		 jl	 SHORT $LN10@GCRegEvent

; 15180: 				{
; 15181: 					gObjDelteItemCountInInventory(lpObj->m_Index,14,21,1,g_StoneCount);

  0015a	51		 push	 ecx
  0015b	6a 01		 push	 1

; 15182: 					g_EventItemBagManager.OpenSpecial(EventBagSpecial::GoldenArcher, lpObj->m_Index, lpObj->MapNumber, lpObj->X, lpObj->Y);
; 15183: 				}
; 15184: 				else
; 15185: 				{
; 15186: 					MsgOutput(lpObj->m_Index,"You lack items to exchange!");

  0015d	eb 1d		 jmp	 SHORT $LN20@GCRegEvent
$LN9@GCRegEvent:

; 15159: 	{
; 15160: 		case 0x00:
; 15161: 			{
; 15162: 				int count = gObjGetItemCountInIventory(lpObj->m_Index,14,21,0);	// Rena

  0015f	6a 00		 push	 0
  00161	6a 15		 push	 21			; 00000015H
  00163	6a 0e		 push	 14			; 0000000eH
  00165	ff 36		 push	 DWORD PTR [esi]
  00167	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory

; 15163: 
; 15164: 				if(count >= g_RenaCount)

  0016c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_RenaCount@@3HA ; g_RenaCount
  00172	83 c4 10	 add	 esp, 16			; 00000010H
  00175	3b c1		 cmp	 eax, ecx
  00177	7c 48		 jl	 SHORT $LN10@GCRegEvent

; 15165: 				{
; 15166: 					gObjDelteItemCountInInventory(lpObj->m_Index,14,21,0,g_RenaCount);

  00179	51		 push	 ecx
  0017a	6a 00		 push	 0
$LN20@GCRegEvent:
  0017c	6a 15		 push	 21			; 00000015H
  0017e	6a 0e		 push	 14			; 0000000eH
  00180	ff 36		 push	 DWORD PTR [esi]
  00182	e8 00 00 00 00	 call	 ?gObjDelteItemCountInInventory@@YAXHHHHH@Z ; gObjDelteItemCountInInventory

; 15167: 					g_EventItemBagManager.OpenSpecial(EventBagSpecial::GoldenArcher, lpObj->m_Index, lpObj->MapNumber, lpObj->X, lpObj->Y);

  00187	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0018e	83 c4 14	 add	 esp, 20			; 00000014H
  00191	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  00196	50		 push	 eax
  00197	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  0019e	50		 push	 eax
  0019f	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  001a6	50		 push	 eax
  001a7	ff 36		 push	 DWORD PTR [esi]
  001a9	6a 12		 push	 18			; 00000012H
  001ab	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial

; 15187: 				}
; 15188: 			}
; 15189: 			break;
; 15190: 	}
; 15191: 
; 15192: 	lpObj->UseEventServer = FALSE;

  001b0	c7 86 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5096], 0
  001ba	5e		 pop	 esi
  001bb	5b		 pop	 ebx
  001bc	5f		 pop	 edi

; 15193: 
; 15194: #endif
; 15195: }

  001bd	8b e5		 mov	 esp, ebp
  001bf	5d		 pop	 ebp
  001c0	c3		 ret	 0
$LN10@GCRegEvent:

; 15168: 				}
; 15169: 				else
; 15170: 				{
; 15171: 					MsgOutput(lpObj->m_Index,"You lack items to exchange!");

  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JDNCDNDO@You?5lack?5items?5to?5exchange?$CB?$AA@
  001c6	ff 36		 push	 DWORD PTR [esi]
  001c8	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  001cd	83 c4 08	 add	 esp, 8
$LN11@GCRegEvent:

; 15187: 				}
; 15188: 			}
; 15189: 			break;
; 15190: 	}
; 15191: 
; 15192: 	lpObj->UseEventServer = FALSE;

  001d0	c7 86 e8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5096], 0
  001da	5e		 pop	 esi
  001db	5b		 pop	 ebx
$LN1@GCRegEvent:
  001dc	5f		 pop	 edi

; 15193: 
; 15194: #endif
; 15195: }

  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c3		 ret	 0
?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ENDP	; GCRegEventChipRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?AllSendSameMapMsg@@YAXPAEHE@Z
_TEXT	SEGMENT
_Msg$ = 8						; size = 4
_size$ = 12						; size = 4
_mapnumber$ = 16					; size = 1
?AllSendSameMapMsg@@YAXPAEHE@Z PROC			; AllSendSameMapMsg, COMDAT

; 15061: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 15062: 	for ( int n=0;n<OBJMAX;n++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	33 f6		 xor	 esi, esi
  0000d	0f 1f 00	 npad	 3
$LL4@AllSendSam:

; 15063: 	{
; 15064: 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0001a	75 20		 jne	 SHORT $LN2@AllSendSam

; 15065: 		{
; 15066: 			if ( gObj[n].Type == OBJ_USER )

  0001c	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00021	75 19		 jne	 SHORT $LN2@AllSendSam

; 15067: 			{
; 15068: 				if ( gObj[n].MapNumber == mapnumber )

  00023	8a 4d 10	 mov	 cl, BYTE PTR _mapnumber$[ebp]
  00026	38 8c 06 23 01
	00 00		 cmp	 BYTE PTR [esi+eax+291], cl
  0002d	75 0d		 jne	 SHORT $LN2@AllSendSam

; 15069: 				{
; 15070: 					DataSend(n, Msg, size);

  0002f	53		 push	 ebx
  00030	ff 75 08	 push	 DWORD PTR _Msg$[ebp]
  00033	57		 push	 edi
  00034	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@AllSendSam:

; 15062: 	for ( int n=0;n<OBJMAX;n++)

  0003c	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00042	47		 inc	 edi
  00043	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00049	7c c5		 jl	 SHORT $LL4@AllSendSam
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx

; 15071: 				}
; 15072: 			}
; 15073: 		}
; 15074: 	}
; 15075: }

  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?AllSendSameMapMsg@@YAXPAEHE@Z ENDP			; AllSendSameMapMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?AllSendMsg@@YAXPAEH@Z
_TEXT	SEGMENT
_Msg$ = 8						; size = 4
_size$ = 12						; size = 4
?AllSendMsg@@YAXPAEH@Z PROC				; AllSendMsg, COMDAT

; 15044: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 15045: 	for ( int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  0000e	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL4@AllSendMsg:

; 15046: 	{
; 15047: 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0001d	75 14		 jne	 SHORT $LN2@AllSendMsg

; 15048: 		{
; 15049: 			if ( gObj[n].Type == OBJ_USER )

  0001f	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00024	75 0d		 jne	 SHORT $LN2@AllSendMsg

; 15050: 			{
; 15051: 				DataSend(n, Msg, size);

  00026	53		 push	 ebx
  00027	ff 75 08	 push	 DWORD PTR _Msg$[ebp]
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@AllSendMsg:

; 15045: 	for ( int n=OBJ_STARTUSERINDEX;n<OBJMAX;n++)

  00033	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00039	47		 inc	 edi
  0003a	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00040	7c d1		 jl	 SHORT $LL4@AllSendMsg
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 15052: 			}
; 15053: 		}
; 15054: 	}
; 15055: }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?AllSendMsg@@YAXPAEH@Z ENDP				; AllSendMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 7
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z PROC ; GCReqDevilSquareRemainTime, COMDAT

; 14911: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14912: 	PMSG_RESULT_DEVILSQUARE_REMAINTIME pResult;
; 14913: 
; 14914: 	PHeadSetB((LPBYTE)&pResult, 0x91, sizeof(pResult));

  00009	6a 07		 push	 7
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000e	68 91 00 00 00	 push	 145			; 00000091H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14915: 	pResult.RemainTime = 0;
; 14916: 
; 14917: 	switch ( lpMsg->hEventType )

  00019	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00022	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  00026	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  0002a	48		 dec	 eax
  0002b	83 f8 04	 cmp	 eax, 4
  0002e	0f 87 c5 01 00
	00		 ja	 $LN2@GCReqDevil
  00034	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN31@GCReqDevil[eax*4]
$LN4@GCReqDevil:

; 14918: 	{
; 14919: 		case 1:
; 14920: #if (ENABLE_FIX_EVENTPK == 1)
; 14921: 			if ( gObj[aIndex].m_PK_Level >= 4 )

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00040	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00046	80 bc 06 19 01
	00 00 04	 cmp	 BYTE PTR [esi+eax+281], 4
  0004e	7c 3c		 jl	 SHORT $LN5@GCReqDevil

; 14922: 			{
; 14923: 				GCServerCmd(aIndex, 0x37, 0, 0);

  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	6a 37		 push	 55			; 00000037H
  00056	57		 push	 edi
  00057	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd

; 14924: 
; 14925: 				LogAddTD("[PK User][DevilSquare] [%s][%s] Move Fail [PK Level:%d]",

  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00062	0f be 84 31 19
	01 00 00	 movsx	 eax, BYTE PTR [ecx+esi+281]
  0006a	50		 push	 eax
  0006b	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0006e	03 c6		 add	 eax, esi
  00070	50		 push	 eax
  00071	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00074	03 c6		 add	 eax, esi
  00076	50		 push	 eax
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DOLGONFI@?$FLPK?5User?$FN?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00082	83 c4 20	 add	 esp, 32			; 00000020H
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx

; 15038: }

  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
$LN5@GCReqDevil:

; 14926: 					gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level);
; 14927: 
; 14928: 				return;
; 14929: 			}
; 14930: #endif
; 14931: 
; 14932: 			pResult.hEventType = 1;
; 14933: 
; 14934: 			if ( g_DevilSquare.GetState() == DevilSquare_CLOSE )

  0008c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?g_DevilSquare@@3VCDevilSquare@@A+4
  00091	c6 45 fb 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00095	85 c0		 test	 eax, eax
  00097	75 0f		 jne	 SHORT $LN6@GCReqDevil

; 14935: 			{
; 14936: 				pResult.RemainTime = g_DevilSquare.GetRemainTime();

  00099	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0009e	e8 00 00 00 00	 call	 ?GetRemainTime@CDevilSquare@@QAEHXZ ; CDevilSquare::GetRemainTime

; 14937: 			}
; 14938: 			else if ( g_DevilSquare.GetState() == DevilSquare_OPEN )

  000a3	e9 4e 01 00 00	 jmp	 $LN28@GCReqDevil
$LN6@GCReqDevil:
  000a8	83 f8 01	 cmp	 eax, 1
  000ab	75 09		 jne	 SHORT $LN8@GCReqDevil
$LN29@GCReqDevil:

; 14939: 			{
; 14940: 				pResult.RemainTime = 0;

  000ad	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 14941: 			}
; 14942: 			else

  000b1	e9 43 01 00 00	 jmp	 $LN2@GCReqDevil
$LN8@GCReqDevil:

; 14943: 			{
; 14944: 				pResult.RemainTime = g_DevilSquare.GetRemainTime() + g_DevilSquare.m_iCloseTime;

  000b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  000bb	e8 00 00 00 00	 call	 ?GetRemainTime@CDevilSquare@@QAEHXZ ; CDevilSquare::GetRemainTime
  000c0	02 05 2c 00 00
	00		 add	 al, BYTE PTR ?g_DevilSquare@@3VCDevilSquare@@A+44

; 14945: 			}
; 14946: 			break;

  000c6	e9 2b 01 00 00	 jmp	 $LN28@GCReqDevil
$LN10@GCReqDevil:

; 14947: 
; 14948: 		case 2:
; 14949: #if( ENABLE_FIX_EVENTPK == 1 )
; 14950: 			if ( gObj[aIndex].m_PK_Level >= 4 )

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d0	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  000d6	80 bc 03 19 01
	00 00 04	 cmp	 BYTE PTR [ebx+eax+281], 4
  000de	7c 3c		 jl	 SHORT $LN11@GCReqDevil

; 14951: 			{
; 14952: 				GCServerCmd(aIndex, 0x38, 0, 0);

  000e0	6a 00		 push	 0
  000e2	6a 00		 push	 0
  000e4	6a 38		 push	 56			; 00000038H
  000e6	57		 push	 edi
  000e7	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd

; 14953: 
; 14954: 				LogAddTD("[PK User][BloodCastle] [%s][%s] Move Fail [PK Level:%d]",

  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f2	0f be 84 19 19
	01 00 00	 movsx	 eax, BYTE PTR [ecx+ebx+281]
  000fa	50		 push	 eax
  000fb	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000fe	03 c3		 add	 eax, ebx
  00100	50		 push	 eax
  00101	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00104	03 c3		 add	 eax, ebx
  00106	50		 push	 eax
  00107	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@MOALMGDC@?$FLPK?5User?$FN?$FLBloodCastle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00112	83 c4 20	 add	 esp, 32			; 00000020H
  00115	5f		 pop	 edi
  00116	5e		 pop	 esi
  00117	5b		 pop	 ebx

; 15038: }

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
$LN11@GCReqDevil:

; 14955: 					gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level);
; 14956: 
; 14957: 				return;
; 14958: 			}
; 14959: #endif
; 14960: 
; 14961: 			pResult.hEventType = 2;
; 14962: 
; 14963: 			if ( g_BloodCastle.GetCurrentState(lpMsg->btItemLevel-1) == 1 )

  0011c	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00120	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00125	48		 dec	 eax
  00126	c6 45 fb 02	 mov	 BYTE PTR _pResult$[ebp+3], 2
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00130	83 f8 01	 cmp	 eax, 1

; 14964: 			{
; 14965: 				if ( g_BloodCastle.CheckCanEnter(lpMsg->btItemLevel-1) != false )

  00133	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00138	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  0013c	75 24		 jne	 SHORT $LN12@GCReqDevil
  0013e	48		 dec	 eax
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  00145	84 c0		 test	 al, al
  00147	0f 85 60 ff ff
	ff		 jne	 $LN29@GCReqDevil

; 14966: 				{
; 14967: 					pResult.RemainTime = 0;
; 14968: 				}
; 14969: 				else
; 14970: 				{
; 14971: 					pResult.RemainTime = g_BloodCastle.GetRemainTime(lpMsg->btItemLevel-1);

  0014d	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00151	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00156	48		 dec	 eax
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 ?GetRemainTime@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetRemainTime

; 14972: 				}
; 14973: 			}
; 14974: 			else

  0015d	e9 94 00 00 00	 jmp	 $LN28@GCReqDevil
$LN12@GCReqDevil:

; 14975: 			{
; 14976: 				pResult.RemainTime = g_BloodCastle.GetRemainTime(lpMsg->btItemLevel-1);

  00162	48		 dec	 eax
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 ?GetRemainTime@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetRemainTime

; 14977: 			}
; 14978: 			break;

  00169	e9 88 00 00 00	 jmp	 $LN28@GCReqDevil
$LN16@GCReqDevil:

; 14979: 
; 14980: 		case 4:
; 14981: 			{
; 14982: #if( ENABLE_FIX_EVENTPK == 1 )
; 14983: #else
; 14984: 			if ( gObj[aIndex].m_PK_Level >= 4 )
; 14985: 			{
; 14986: 				GCServerCmd(aIndex, 0x39, 0, 0);
; 14987: 
; 14988: 				LogAddTD("[PK User][ChaosCastle] [%s][%s] Move Fail [PK Level:%d]",
; 14989: 					gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_PK_Level);
; 14990: 
; 14991: 				return;
; 14992: 			}
; 14993: #endif
; 14994: 
; 14995: 			int iENTER_LEVEL =  g_ChaosCastle.GetUserLevelToEnter(aIndex);

  0016e	57		 push	 edi
  0016f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00174	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetUserLevelToEnter
  00179	8b f0		 mov	 esi, eax

; 14996: 
; 14997: 			if ( iENTER_LEVEL == -1 )

  0017b	83 fe ff	 cmp	 esi, -1
  0017e	0f 84 87 00 00
	00		 je	 $LN1@GCReqDevil

; 14998: 				return;
; 14999: 
; 15000: 			pResult.hEventType = 4;
; 15001: 
; 15002: 			if ( g_ChaosCastle.GetCurrentState(iENTER_LEVEL) == 1 )

  00184	56		 push	 esi
  00185	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0018a	c6 45 fb 04	 mov	 BYTE PTR _pResult$[ebp+3], 4
  0018e	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState

; 15003: 			{
; 15004: 				if ( g_ChaosCastle.CheckCanEnter(iENTER_LEVEL) != false )

  00193	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00198	56		 push	 esi
  00199	83 f8 01	 cmp	 eax, 1
  0019c	75 21		 jne	 SHORT $LN18@GCReqDevil
  0019e	e8 00 00 00 00	 call	 ?CheckCanEnter@CChaosCastle@@QAE_NH@Z ; CChaosCastle::CheckCanEnter

; 15008: 					pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  001a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  001a8	56		 push	 esi
  001a9	84 c0		 test	 al, al
  001ab	74 12		 je	 SHORT $LN18@GCReqDevil

; 15005: 				{
; 15006: 					pResult.RemainTime = 0;
; 15007: 					pResult.RemainTime_LOW = 0;

  001ad	c6 45 fc 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  001b1	c6 45 fe 00	 mov	 BYTE PTR _pResult$[ebp+6], 0

; 15008: 					pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  001b5	e8 00 00 00 00	 call	 ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurEnteredUser
  001ba	88 45 fd	 mov	 BYTE PTR _pResult$[ebp+5], al

; 15009: 				}
; 15010: 				else

  001bd	eb 3a		 jmp	 SHORT $LN2@GCReqDevil
$LN18@GCReqDevil:

; 15011: 				{
; 15012: 					WORD wREMAIN_TIME = g_ChaosCastle.GetRemainTime(iENTER_LEVEL);
; 15013: 					pResult.RemainTime = SET_NUMBERH(wREMAIN_TIME);
; 15014: 					pResult.RemainTime_LOW = SET_NUMBERL(wREMAIN_TIME);
; 15015: 					pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);
; 15016: 				}
; 15017: 			}
; 15018: 			else
; 15019: 			{
; 15020: 				WORD wREMAIN_TIME = g_ChaosCastle.GetRemainTime(iENTER_LEVEL);

  001bf	e8 00 00 00 00	 call	 ?GetRemainTime@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetRemainTime
  001c4	0f b7 c8	 movzx	 ecx, ax

; 15021: 				pResult.RemainTime = SET_NUMBERH(wREMAIN_TIME);

  001c7	8b c1		 mov	 eax, ecx

; 15022: 				pResult.RemainTime_LOW = SET_NUMBERL(wREMAIN_TIME);

  001c9	88 4d fe	 mov	 BYTE PTR _pResult$[ebp+6], cl
  001cc	c1 e8 08	 shr	 eax, 8

; 15023: 				pResult.EnteredUser = g_ChaosCastle.GetCurEnteredUser(iENTER_LEVEL);

  001cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  001d4	56		 push	 esi
  001d5	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al
  001d8	e8 00 00 00 00	 call	 ?GetCurEnteredUser@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurEnteredUser
  001dd	88 45 fd	 mov	 BYTE PTR _pResult$[ebp+5], al

; 15024: 			}
; 15025: 			}
; 15026: 			break;

  001e0	eb 17		 jmp	 SHORT $LN2@GCReqDevil
$LN22@GCReqDevil:

; 15027: 
; 15028: 		case 5:
; 15029: 
; 15030: 			pResult.hEventType = 5;
; 15031: 			pResult.RemainTime = g_IllusionTemple.GetLeftTime();

  001e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  001e7	c6 45 fb 05	 mov	 BYTE PTR _pResult$[ebp+3], 5
  001eb	e8 00 00 00 00	 call	 ?GetLeftTime@CIllusionTempleEvent@@QAEEXZ ; CIllusionTempleEvent::GetLeftTime

; 15032: 			pResult.EnteredUser = 0;

  001f0	66 c7 45 fd 00
	00		 mov	 WORD PTR _pResult$[ebp+5], 0
$LN28@GCReqDevil:

; 15027: 
; 15028: 		case 5:
; 15029: 
; 15030: 			pResult.hEventType = 5;
; 15031: 			pResult.RemainTime = g_IllusionTemple.GetLeftTime();

  001f6	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al
$LN2@GCReqDevil:

; 15033: 			pResult.RemainTime_LOW = 0;
; 15034: 			break;
; 15035: 	}
; 15036: 
; 15037: 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001f9	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001fd	50		 push	 eax
  001fe	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00201	50		 push	 eax
  00202	57		 push	 edi
  00203	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCReqDevil:
  0020b	5f		 pop	 edi
  0020c	5e		 pop	 esi
  0020d	5b		 pop	 ebx

; 15038: }

  0020e	8b e5		 mov	 esp, ebp
  00210	5d		 pop	 ebp
  00211	c3		 ret	 0
  00212	66 90		 npad	 2
$LN31@GCReqDevil:
  00214	00 00 00 00	 DD	 $LN4@GCReqDevil
  00218	00 00 00 00	 DD	 $LN10@GCReqDevil
  0021c	00 00 00 00	 DD	 $LN2@GCReqDevil
  00220	00 00 00 00	 DD	 $LN16@GCReqDevil
  00224	00 00 00 00	 DD	 $LN22@GCReqDevil
?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ENDP ; GCReqDevilSquareRemainTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z
_TEXT	SEGMENT
_sitem$1$ = -32						; size = 4
tv618 = -28						; size = 4
tv619 = -24						; size = 4
_movegateindex$ = -20					; size = 4
_cInvitationItemPos$ = -16				; size = 1
tv576 = -12						; size = 4
_ItemLevel$1$ = -12					; size = 4
tv632 = -8						; size = 4
_iENTER_LEVEL$1$ = -8					; size = 4
_pResult$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
tv630 = 12						; size = 4
_aIndex$ = 12						; size = 4
_cSquareNumber$1$ = 15					; size = 1
?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z PROC ; GCReqmoveDevilSquare, COMDAT

; 14681: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx

; 14682: 	if ( aIndex < 0 || aIndex > OBJMAX-1 )

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00010	0f 87 d4 04 00
	00		 ja	 $LN3@GCReqmoveD

; 14685: 		return;
; 14686: 	}
; 14687: 
; 14688: 	BYTE cSquareNumber = lpMsg->SquareNumber;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00019	56		 push	 esi

; 14689: 	BYTE cInvitationItemPos = lpMsg->InvitationItemPos - INVENTORY_BAG_START;
; 14690: 
; 14691: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type != 12 )

  0001a	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00020	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00023	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00026	2c 0c		 sub	 al, 12			; 0000000cH
  00028	88 4d 0f	 mov	 BYTE PTR _cSquareNumber$1$[ebp], cl
  0002b	88 45 f0	 mov	 BYTE PTR _cInvitationItemPos$[ebp], al
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	8b 84 06 b8 11
	00 00		 mov	 eax, DWORD PTR [esi+eax+4536]
  0003a	a8 03		 test	 al, 3
  0003c	74 0c		 je	 SHORT $LN4@GCReqmoveD
  0003e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00043	3d 00 03 00 00	 cmp	 eax, 768		; 00000300H
  00048	75 71		 jne	 SHORT $LN44@GCReqmoveD
$LN4@GCReqmoveD:
  0004a	57		 push	 edi

; 14692: 		return;
; 14693: 
; 14694: 	PMSG_RESULT_MOVEDEVILSQUARE pResult;
; 14695: 
; 14696: 	PHeadSetB((LPBYTE)&pResult, 0x90, sizeof(pResult));

  0004b	6a 04		 push	 4
  0004d	8d 45 fc	 lea	 eax, DWORD PTR _pResult$[ebp]
  00050	68 90 00 00 00	 push	 144			; 00000090H
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14697: 	pResult.Result = 0;
; 14698: 
; 14699: 	LPOBJ lpObj = &gObj[aIndex];

  0005b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 14700: 
; 14701: 	LogAddTD("[DevilSquare] [%s][%s] Request Move DevilSquare [%d][%d][%d]",

  00061	0f b6 45 0f	 movzx	 eax, BYTE PTR _cSquareNumber$1$[ebp]
  00065	89 45 f8	 mov	 DWORD PTR tv632[ebp], eax
  00068	40		 inc	 eax
  00069	50		 push	 eax
  0006a	c6 45 ff 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  0006e	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
  00071	0f bf 84 3e 96
	00 00 00	 movsx	 eax, WORD PTR [esi+edi+150]
  00079	8d 57 52	 lea	 edx, DWORD PTR [edi+82]
  0007c	50		 push	 eax
  0007d	0f b7 84 3e 90
	00 00 00	 movzx	 eax, WORD PTR [esi+edi+144]
  00085	03 ce		 add	 ecx, esi
  00087	50		 push	 eax
  00088	51		 push	 ecx
  00089	03 d6		 add	 edx, esi
  0008b	52		 push	 edx
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@EDDIPEJF@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5M@
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00097	83 c4 24	 add	 esp, 36			; 00000024H

; 14702: 		lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 14703: 
; 14704: 	int bIsPk = FALSE;
; 14705: 
; 14706: #if( ENABLE_FIX_PARTYPK == 1 )
; 14707: 	if ( lpObj->m_PK_Level >= 4 )

  0009a	80 bc 3e 19 01
	00 00 04	 cmp	 BYTE PTR [esi+edi+281], 4
  000a2	7c 1d		 jl	 SHORT $LN6@GCReqmoveD

; 14708: 	{
; 14709: 		bIsPk = TRUE;
; 14710: 	}
; 14711: #else
; 14712: 	if ( lpObj->PartyNumber >= 0 )
; 14713: 	{
; 14714: 		if( gParty.GetPartyPkLevel(lpObj->PartyNumber) >= 5 )
; 14715: 		{
; 14716: 			bIsPk = TRUE;
; 14717: 		}
; 14718: 	}
; 14719: 	else if ( lpObj->m_PK_Level >= 4 )
; 14720: 	{
; 14721: 		bIsPk = TRUE;
; 14722: 	}
; 14723: #endif
; 14724: 
; 14725: #if( ENABLE_FIX_EVENTPK == 1 )
; 14726: 	if ( bIsPk == TRUE )
; 14727: 	{
; 14728: 		pResult.Result = 6;
; 14729: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000a4	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000a8	50		 push	 eax
  000a9	8d 45 fc	 lea	 eax, DWORD PTR _pResult$[ebp]
  000ac	c6 45 ff 06	 mov	 BYTE PTR _pResult$[ebp+3], 6
  000b0	50		 push	 eax
  000b1	53		 push	 ebx
  000b2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ba	5f		 pop	 edi
$LN44@GCReqmoveD:
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx

; 14896: }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
$LN6@GCReqmoveD:

; 14730: 		return;
; 14731: 	}
; 14732: #endif
; 14733: 
; 14734: 	if ( MAIN_INVENTORY_RANGE(cInvitationItemPos) == FALSE )

  000c1	b8 cb 00 00 00	 mov	 eax, 203		; 000000cbH
  000c6	3a 45 f0	 cmp	 al, BYTE PTR _cInvitationItemPos$[ebp]
  000c9	1b c0		 sbb	 eax, eax
  000cb	83 c0 01	 add	 eax, 1
  000ce	0f 84 09 01 00
	00		 je	 $LN12@GCReqmoveD

; 14735: 	{
; 14736: 		pResult.Result = 1;
; 14737: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 14738: 
; 14739: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]",
; 14740: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 14741: 
; 14742: 		return;
; 14743: 	}
; 14744: 
; 14745: 	if ( DS_LEVEL_RANGE(cSquareNumber) == FALSE )

  000d4	b8 06 00 00 00	 mov	 eax, 6
  000d9	3a 45 0f	 cmp	 al, BYTE PTR _cSquareNumber$1$[ebp]
  000dc	1b c0		 sbb	 eax, eax
  000de	83 c0 01	 add	 eax, 1
  000e1	0f 84 f6 00 00
	00		 je	 $LN12@GCReqmoveD

; 14746: 	{
; 14747: 		pResult.Result = 1;
; 14748: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 14749: 
; 14750: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]",
; 14751: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 14752: 
; 14753: 		return;
; 14754: 	}
; 14755: 
; 14756: 	if ( g_DevilSquare.GetState() != DevilSquare_OPEN )

  000e7	83 3d 04 00 00
	00 01		 cmp	 DWORD PTR ?g_DevilSquare@@3VCDevilSquare@@A+4, 1
  000ee	74 4b		 je	 SHORT $LN9@GCReqmoveD

; 14757: 	{
; 14758: 		pResult.Result = 2;
; 14759: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000f0	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000f4	50		 push	 eax
  000f5	8d 45 fc	 lea	 eax, DWORD PTR _pResult$[ebp]
  000f8	c6 45 ff 02	 mov	 BYTE PTR _pResult$[ebp+3], 2
  000fc	50		 push	 eax
  000fd	53		 push	 ebx
  000fe	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14760: 
; 14761: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]",

  00103	8b 45 f8	 mov	 eax, DWORD PTR tv632[ebp]
  00106	40		 inc	 eax
  00107	50		 push	 eax
  00108	0f bf 84 3e 96
	00 00 00	 movsx	 eax, WORD PTR [esi+edi+150]
  00110	50		 push	 eax
  00111	0f b7 84 3e 90
	00 00 00	 movzx	 eax, WORD PTR [esi+edi+144]
  00119	50		 push	 eax
  0011a	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0011d	03 c6		 add	 eax, esi
  0011f	50		 push	 eax
  00120	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00123	03 c6		 add	 eax, esi
  00125	50		 push	 eax
  00126	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00131	83 c4 24	 add	 esp, 36			; 00000024H
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
  00136	5b		 pop	 ebx

; 14896: }

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
$LN9@GCReqmoveD:

; 14762: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 14763: 
; 14764: 		return;
; 14765: 	}
; 14766: 
; 14767: 	if ( g_DevilSquare.m_DevilSquareGround[cSquareNumber].GetObjCount() >= MAX_DEVILSQUARE_USER )

  0013b	69 4d f8 1c 05
	00 00		 imul	 ecx, DWORD PTR tv632[ebp], 1308
  00142	81 c1 38 00 00
	00		 add	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A+56
  00148	e8 00 00 00 00	 call	 ?GetObjCount@CDevilSquareGround@@QAEJXZ ; CDevilSquareGround::GetObjCount
  0014d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00150	7c 4b		 jl	 SHORT $LN10@GCReqmoveD

; 14768: 	{
; 14769: 		pResult.Result = 5;
; 14770: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00152	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00156	50		 push	 eax
  00157	8d 45 fc	 lea	 eax, DWORD PTR _pResult$[ebp]
  0015a	c6 45 ff 05	 mov	 BYTE PTR _pResult$[ebp+3], 5
  0015e	50		 push	 eax
  0015f	53		 push	 ebx
  00160	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14771: 
; 14772: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]",

  00165	8b 45 f8	 mov	 eax, DWORD PTR tv632[ebp]
  00168	40		 inc	 eax
  00169	50		 push	 eax
  0016a	0f bf 84 3e 96
	00 00 00	 movsx	 eax, WORD PTR [esi+edi+150]
  00172	50		 push	 eax
  00173	0f b7 84 3e 90
	00 00 00	 movzx	 eax, WORD PTR [esi+edi+144]
  0017b	50		 push	 eax
  0017c	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0017f	03 c6		 add	 eax, esi
  00181	50		 push	 eax
  00182	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00185	03 c6		 add	 eax, esi
  00187	50		 push	 eax
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00193	83 c4 24	 add	 esp, 36			; 00000024H
  00196	5f		 pop	 edi
  00197	5e		 pop	 esi
  00198	5b		 pop	 ebx

; 14896: }

  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
$LN10@GCReqmoveD:

; 14773: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 14774: 
; 14775: 		return;
; 14776: 	}
; 14777: 
; 14778: 	CItem * sitem = &lpObj->pInventory[cInvitationItemPos];

  0019d	0f b6 45 f0	 movzx	 eax, BYTE PTR _cInvitationItemPos$[ebp]
  001a1	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  001a7	89 45 e8	 mov	 DWORD PTR tv619[ebp], eax
  001aa	8b 84 3e c0 11
	00 00		 mov	 eax, DWORD PTR [esi+edi+4544]
  001b1	03 c1		 add	 eax, ecx

; 14779: 
; 14780: 	if ( sitem->m_Type != ITEMGET(14,19) && ( sitem->m_Type != ITEMGET(13,46) || sitem->m_Durability <= 0.0f ) )	// Devil's Invitation

  001b3	c7 45 f4 13 1c
	00 00		 mov	 DWORD PTR tv576[ebp], 7187 ; 00001c13H
  001ba	89 45 e0	 mov	 DWORD PTR _sitem$1$[ebp], eax
  001bd	89 4d e4	 mov	 DWORD PTR tv618[ebp], ecx
  001c0	b9 2e 1a 00 00	 mov	 ecx, 6702		; 00001a2eH
  001c5	0f b7 50 06	 movzx	 edx, WORD PTR [eax+6]
  001c9	66 3b 55 f4	 cmp	 dx, WORD PTR tv576[ebp]
  001cd	74 59		 je	 SHORT $LN11@GCReqmoveD
  001cf	66 3b d1	 cmp	 dx, cx
  001d2	75 09		 jne	 SHORT $LN12@GCReqmoveD
  001d4	0f 57 c0	 xorps	 xmm0, xmm0
  001d7	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  001db	72 4b		 jb	 SHORT $LN11@GCReqmoveD
$LN12@GCReqmoveD:

; 14781: 	{
; 14782: 		pResult.Result = 1;
; 14783: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001dd	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  001e1	50		 push	 eax
  001e2	8d 45 fc	 lea	 eax, DWORD PTR _pResult$[ebp]
  001e5	c6 45 ff 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  001e9	50		 push	 eax
  001ea	53		 push	 ebx
  001eb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14784: 
; 14785: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d]",

  001f0	8b 45 f8	 mov	 eax, DWORD PTR tv632[ebp]
  001f3	40		 inc	 eax
  001f4	50		 push	 eax
  001f5	0f bf 84 3e 96
	00 00 00	 movsx	 eax, WORD PTR [esi+edi+150]
  001fd	50		 push	 eax
  001fe	0f b7 84 3e 90
	00 00 00	 movzx	 eax, WORD PTR [esi+edi+144]
  00206	50		 push	 eax
  00207	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0020a	03 c6		 add	 eax, esi
  0020c	50		 push	 eax
  0020d	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00210	03 c6		 add	 eax, esi
  00212	50		 push	 eax
  00213	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HAACDBFD@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0021e	83 c4 24	 add	 esp, 36			; 00000024H
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	5b		 pop	 ebx

; 14896: }

  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
$LN11@GCReqmoveD:

; 14786: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1);
; 14787: 
; 14788: 		return;
; 14789: 	}
; 14790: 
; 14791: 	int ItemLevel = sitem->m_Level;

  00228	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]

; 14792: 
; 14793: 	if ( sitem->m_Type == ITEMGET(13,46) )

  0022c	b8 2e 1a 00 00	 mov	 eax, 6702		; 00001a2eH
  00231	89 4d f4	 mov	 DWORD PTR _ItemLevel$1$[ebp], ecx
  00234	66 3b d0	 cmp	 dx, ax
  00237	0f 85 ab 00 00
	00		 jne	 $LN13@GCReqmoveD

; 14794: 		ItemLevel = 10;

  0023d	c7 45 f4 0a 00
	00 00		 mov	 DWORD PTR _ItemLevel$1$[ebp], 10 ; 0000000aH
$LN18@GCReqmoveD:

; 14813: 					lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber+1, ItemLevel);
; 14814: 
; 14815: 				return;
; 14816: 			}
; 14817: 		}
; 14818: 	}
; 14819: 
; 14820: 	BOOL bEnterCheck = FALSE;
; 14821: 	int movegateindex = 61;	// #gate
; 14822: 	int iENTER_LEVEL = g_DevilSquare.GetUserLevelToEnter(aIndex, movegateindex);

  00244	8d 45 ec	 lea	 eax, DWORD PTR _movegateindex$[ebp]
  00247	c7 45 ec 3d 00
	00 00		 mov	 DWORD PTR _movegateindex$[ebp], 61 ; 0000003dH
  0024e	50		 push	 eax
  0024f	53		 push	 ebx
  00250	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  00255	e8 00 00 00 00	 call	 ?GetUserLevelToEnter@CDevilSquare@@QAEHHAAH@Z ; CDevilSquare::GetUserLevelToEnter
  0025a	89 45 f8	 mov	 DWORD PTR _iENTER_LEVEL$1$[ebp], eax

; 14823: 
; 14824: 	if ( DS_LEVEL_RANGE(iENTER_LEVEL) == FALSE )

  0025d	85 c0		 test	 eax, eax
  0025f	0f 88 64 02 00
	00		 js	 $LN41@GCReqmoveD
  00265	33 c9		 xor	 ecx, ecx
  00267	83 f8 06	 cmp	 eax, 6
  0026a	0f 9e c1	 setle	 cl
  0026d	85 c9		 test	 ecx, ecx
  0026f	0f 84 54 02 00
	00		 je	 $LN41@GCReqmoveD

; 14827: 			lpObj->AccountID, lpObj->Name);
; 14828: 
; 14829: 		return;
; 14830: 	}
; 14831: 
; 14832: 	if ( ItemLevel == 10 )

  00275	8b 55 f4	 mov	 edx, DWORD PTR _ItemLevel$1$[ebp]
  00278	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  0027b	0f b6 4d 0f	 movzx	 ecx, BYTE PTR _cSquareNumber$1$[ebp]
  0027f	0f b6 c0	 movzx	 eax, al
  00282	0f 44 c8	 cmove	 ecx, eax

; 14833: 		cSquareNumber = iENTER_LEVEL;
; 14834: 
; 14835: 	if ( cSquareNumber != iENTER_LEVEL )

  00285	0f b6 c1	 movzx	 eax, cl
  00288	8b 4d f8	 mov	 ecx, DWORD PTR _iENTER_LEVEL$1$[ebp]
  0028b	89 45 0c	 mov	 DWORD PTR tv630[ebp], eax
  0028e	3b c1		 cmp	 eax, ecx
  00290	0f 84 ff 00 00
	00		 je	 $LN25@GCReqmoveD

; 14836: 	{
; 14837: 		if ( cSquareNumber > iENTER_LEVEL )
; 14838: 		{
; 14839: 			bEnterCheck = 2;
; 14840: 		}
; 14841: 		else
; 14842: 		{
; 14843: 			bEnterCheck = 1;
; 14844: 		}
; 14845: 	}
; 14846: 
; 14847: 	if ( bEnterCheck == 1 )
; 14848: 	{
; 14849: 		pResult.Result = 3;
; 14850: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00296	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0029a	50		 push	 eax
  0029b	8d 45 fc	 lea	 eax, DWORD PTR _pResult$[ebp]
  0029e	50		 push	 eax
  0029f	53		 push	 ebx
  002a0	0f 8f ad 00 00
	00		 jg	 $LN42@GCReqmoveD
  002a6	c6 45 ff 03	 mov	 BYTE PTR _pResult$[ebp+3], 3
  002aa	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14851: 
; 14852: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]",

  002af	ff 75 f4	 push	 DWORD PTR _ItemLevel$1$[ebp]
  002b2	0f bf 84 3e 96
	00 00 00	 movsx	 eax, WORD PTR [esi+edi+150]
  002ba	ff 75 0c	 push	 DWORD PTR tv630[ebp]
  002bd	50		 push	 eax
  002be	0f b7 84 3e 90
	00 00 00	 movzx	 eax, WORD PTR [esi+edi+144]
  002c6	50		 push	 eax
  002c7	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  002ca	03 c6		 add	 eax, esi
  002cc	50		 push	 eax
  002cd	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  002d0	03 c6		 add	 eax, esi
  002d2	50		 push	 eax
  002d3	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  002d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002de	83 c4 28	 add	 esp, 40			; 00000028H
  002e1	5f		 pop	 edi
  002e2	5e		 pop	 esi
  002e3	5b		 pop	 ebx

; 14896: }

  002e4	8b e5		 mov	 esp, ebp
  002e6	5d		 pop	 ebp
  002e7	c3		 ret	 0
$LN13@GCReqmoveD:

; 14795: 
; 14796: 	int level = lpObj->Level;
; 14797: 
; 14798: 	if ( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA )
; 14799: 	{
; 14800: 		level = (level+1)/2*3;
; 14801: 	}
; 14802: 
; 14803: 	if ( ItemLevel != 0 )

  002e8	85 c9		 test	 ecx, ecx
  002ea	0f 84 54 ff ff
	ff		 je	 $LN18@GCReqmoveD

; 14804: 	{
; 14805: 		if ( ItemLevel != 10 )

  002f0	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  002f3	0f 84 4b ff ff
	ff		 je	 $LN18@GCReqmoveD

; 14806: 		{
; 14807: 			if ( ItemLevel != (cSquareNumber+1) )

  002f9	8b 45 f8	 mov	 eax, DWORD PTR tv632[ebp]
  002fc	40		 inc	 eax
  002fd	3b c8		 cmp	 ecx, eax
  002ff	0f 84 3f ff ff
	ff		 je	 $LN18@GCReqmoveD

; 14808: 			{
; 14809: 				pResult.Result = 1;
; 14810: 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00305	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00309	50		 push	 eax
  0030a	8d 45 fc	 lea	 eax, DWORD PTR _pResult$[ebp]
  0030d	c6 45 ff 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00311	50		 push	 eax
  00312	53		 push	 ebx
  00313	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14811: 
; 14812: 				LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Invitation LevelError [%d][%d][%d][%d]",

  00318	ff 75 f4	 push	 DWORD PTR _ItemLevel$1$[ebp]
  0031b	8b 45 f8	 mov	 eax, DWORD PTR tv632[ebp]
  0031e	40		 inc	 eax
  0031f	50		 push	 eax
  00320	0f bf 84 3e 96
	00 00 00	 movsx	 eax, WORD PTR [esi+edi+150]
  00328	50		 push	 eax
  00329	0f b7 84 3e 90
	00 00 00	 movzx	 eax, WORD PTR [esi+edi+144]
  00331	50		 push	 eax
  00332	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00335	03 c6		 add	 eax, esi
  00337	50		 push	 eax
  00338	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  0033b	03 c6		 add	 eax, esi
  0033d	50		 push	 eax
  0033e	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@OANDGE@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  00343	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00349	83 c4 28	 add	 esp, 40			; 00000028H
  0034c	5f		 pop	 edi
  0034d	5e		 pop	 esi
  0034e	5b		 pop	 ebx

; 14896: }

  0034f	8b e5		 mov	 esp, ebp
  00351	5d		 pop	 ebp
  00352	c3		 ret	 0
$LN42@GCReqmoveD:

; 14853: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber, ItemLevel);
; 14854: 
; 14855: 		return;
; 14856: 	}
; 14857: 
; 14858: 	if ( bEnterCheck == 2 )
; 14859: 	{
; 14860: 		pResult.Result = 4;

  00353	c6 45 ff 04	 mov	 BYTE PTR _pResult$[ebp+3], 4

; 14861: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00357	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14862: 
; 14863: 		LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare Fail [%d][%d][%d][%d]",

  0035c	ff 75 f4	 push	 DWORD PTR _ItemLevel$1$[ebp]
  0035f	0f bf 84 3e 96
	00 00 00	 movsx	 eax, WORD PTR [esi+edi+150]
  00367	ff 75 0c	 push	 DWORD PTR tv630[ebp]
  0036a	50		 push	 eax
  0036b	0f b7 84 3e 90
	00 00 00	 movzx	 eax, WORD PTR [esi+edi+144]
  00373	50		 push	 eax
  00374	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00377	03 c6		 add	 eax, esi
  00379	50		 push	 eax
  0037a	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  0037d	03 c6		 add	 eax, esi
  0037f	50		 push	 eax
  00380	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@GMGNNGG@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  00385	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0038b	83 c4 28	 add	 esp, 40			; 00000028H
  0038e	5f		 pop	 edi
  0038f	5e		 pop	 esi
  00390	5b		 pop	 ebx

; 14896: }

  00391	8b e5		 mov	 esp, ebp
  00393	5d		 pop	 ebp
  00394	c3		 ret	 0
$LN25@GCReqmoveD:

; 14864: 			lpObj->AccountID, lpObj->Name, lpObj->Class, lpObj->Level, cSquareNumber, ItemLevel);
; 14865: 
; 14866: 		return;
; 14867: 	}
; 14868: 
; 14869: 	LogAddTD("[DevilSquare] [%s][%s] Move DevilSquare success [%d][%d] RemoveItem[%s][%d][%d][%d]",

  00395	8b 4d e4	 mov	 ecx, DWORD PTR tv618[ebp]
  00398	03 8c 3e c0 11
	00 00		 add	 ecx, DWORD PTR [esi+edi+4544]
  0039f	ff 31		 push	 DWORD PTR [ecx]
  003a1	52		 push	 edx
  003a2	ff 75 e8	 push	 DWORD PTR tv619[ebp]
  003a5	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  003aa	50		 push	 eax
  003ab	ff 75 0c	 push	 DWORD PTR tv630[ebp]
  003ae	0f bf 84 3e 96
	00 00 00	 movsx	 eax, WORD PTR [esi+edi+150]
  003b6	50		 push	 eax
  003b7	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  003ba	03 c6		 add	 eax, esi
  003bc	50		 push	 eax
  003bd	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  003c0	03 c6		 add	 eax, esi
  003c2	50		 push	 eax
  003c3	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@INNDGJO@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Move?5Devi@
  003c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14870: 		lpObj->AccountID, lpObj->Name, lpObj->Level, cSquareNumber, lpObj->pInventory[cInvitationItemPos].GetName(),
; 14871: 		cInvitationItemPos, ItemLevel, lpObj->pInventory[cInvitationItemPos].m_Number);
; 14872: 
; 14873: 	if ( sitem->m_Type == ITEMGET(14,19) || (sitem->m_Type == ITEMGET(13,46) && sitem->m_Durability == 1.0f) )

  003ce	8b 4d e0	 mov	 ecx, DWORD PTR _sitem$1$[ebp]
  003d1	b8 13 1c 00 00	 mov	 eax, 7187		; 00001c13H
  003d6	83 c4 24	 add	 esp, 36			; 00000024H
  003d9	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  003dd	66 3b d0	 cmp	 dx, ax
  003e0	74 52		 je	 SHORT $LN28@GCReqmoveD
  003e2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  003ea	b8 2e 1a 00 00	 mov	 eax, 6702		; 00001a2eH
  003ef	66 3b d0	 cmp	 dx, ax
  003f2	75 66		 jne	 SHORT $LN29@GCReqmoveD
  003f4	f3 0f 10 41 24	 movss	 xmm0, DWORD PTR [ecx+36]
  003f9	0f 2e c1	 ucomiss xmm0, xmm1
  003fc	9f		 lahf
  003fd	f6 c4 44	 test	 ah, 68			; 00000044H
  00400	7b 32		 jnp	 SHORT $LN28@GCReqmoveD

; 14878: 	}
; 14879: 	else if ( sitem->m_Type == ITEMGET(13,46) && sitem->m_Durability > 1.0f )

  00402	b8 2e 1a 00 00	 mov	 eax, 6702		; 00001a2eH
  00407	66 3b d0	 cmp	 dx, ax
  0040a	75 4e		 jne	 SHORT $LN29@GCReqmoveD
  0040c	0f 2f c1	 comiss	 xmm0, xmm1
  0040f	76 49		 jbe	 SHORT $LN29@GCReqmoveD

; 14880: 	{
; 14881: 		sitem->m_Durability -= 1.0f;

  00411	f3 0f 5c c1	 subss	 xmm0, xmm1

; 14882: 		GCItemDurSend2(lpObj->m_Index, cInvitationItemPos,(BYTE)sitem->m_Durability, 0);

  00415	6a 00		 push	 0
  00417	f3 0f 2c c0	 cvttss2si eax, xmm0
  0041b	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0
  00420	0f b6 c0	 movzx	 eax, al
  00423	50		 push	 eax
  00424	ff 75 f0	 push	 DWORD PTR _cInvitationItemPos$[ebp]
  00427	ff 34 3e	 push	 DWORD PTR [esi+edi]
  0042a	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  0042f	83 c4 10	 add	 esp, 16			; 00000010H
  00432	eb 26		 jmp	 SHORT $LN29@GCReqmoveD
$LN28@GCReqmoveD:

; 14874: 	{
; 14875: 		gObjInventoryDeleteItem(aIndex, cInvitationItemPos);

  00434	ff 75 e8	 push	 DWORD PTR tv619[ebp]
  00437	53		 push	 ebx
  00438	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 14876: 		GCInventoryItemDeleteSend(aIndex, cInvitationItemPos, 1);

  0043d	6a 01		 push	 1
  0043f	ff 75 f0	 push	 DWORD PTR _cInvitationItemPos$[ebp]
  00442	53		 push	 ebx
  00443	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 14877: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00448	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0044c	50		 push	 eax
  0044d	8d 45 fc	 lea	 eax, DWORD PTR _pResult$[ebp]
  00450	50		 push	 eax
  00451	53		 push	 ebx
  00452	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00457	83 c4 20	 add	 esp, 32			; 00000020H
$LN29@GCReqmoveD:

; 14883: 	}
; 14884: 
; 14885: 	lpObj->m_nEventExp = 0;

  0045a	c7 84 3e 2c 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edi+4652], 0

; 14886: 	lpObj->m_nEventScore = 0;
; 14887: 	lpObj->m_nEventMoney = 0;
; 14888: 	lpObj->m_bDevilSquareIndex = g_DevilSquare.GetDevilSquareIndex(movegateindex);

  00465	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0046a	c7 84 3e 28 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edi+4648], 0
  00475	c7 84 3e 30 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edi+4656], 0
  00480	ff 75 ec	 push	 DWORD PTR _movegateindex$[ebp]
  00483	e8 00 00 00 00	 call	 ?GetDevilSquareIndex@CDevilSquare@@QAEHH@Z ; CDevilSquare::GetDevilSquareIndex

; 14889: 	lpObj->m_bDevilSquareAuth = true;
; 14890: 	lpObj->m_IfState.state = 0;
; 14891: 	lpObj->m_IfState.type = 0;
; 14892: 	lpObj->m_IfState.use = 0;

  00488	81 a4 3e b8 11
	00 00 00 00 ff
	ff		 and	 DWORD PTR [esi+edi+4536], -65536 ; ffff0000H
  00493	88 84 3e 34 12
	00 00		 mov	 BYTE PTR [esi+edi+4660], al
  0049a	c6 84 3e 35 12
	00 00 01	 mov	 BYTE PTR [esi+edi+4661], 1

; 14893: 
; 14894: 	gObjMoveGate(lpObj->m_Index, movegateindex);

  004a2	ff 75 ec	 push	 DWORD PTR _movegateindex$[ebp]
  004a5	ff 34 3e	 push	 DWORD PTR [esi+edi]
  004a8	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14895: 	g_DevilSquare.m_DevilSquareGround[cSquareNumber].IncObjCount();

  004ad	69 4d 0c 1c 05
	00 00		 imul	 ecx, DWORD PTR tv630[ebp], 1308
  004b4	83 c4 08	 add	 esp, 8
  004b7	81 c1 38 00 00
	00		 add	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A+56
  004bd	e8 00 00 00 00	 call	 ?IncObjCount@CDevilSquareGround@@QAEXXZ ; CDevilSquareGround::IncObjCount
  004c2	5f		 pop	 edi
  004c3	5e		 pop	 esi
  004c4	5b		 pop	 ebx

; 14896: }

  004c5	8b e5		 mov	 esp, ebp
  004c7	5d		 pop	 ebp
  004c8	c3		 ret	 0
$LN41@GCReqmoveD:

; 14825: 	{
; 14826: 		LogAddTD("[DevilSquare] [%s][%s] GetUserLevelToEnter() failed",

  004c9	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  004cc	03 c6		 add	 eax, esi
  004ce	50		 push	 eax
  004cf	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  004d2	03 c6		 add	 eax, esi
  004d4	50		 push	 eax
  004d5	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@NILIJDCN@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5GetUserLe@
  004da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e3	5f		 pop	 edi
  004e4	5e		 pop	 esi
  004e5	5b		 pop	 ebx

; 14896: }

  004e6	8b e5		 mov	 esp, ebp
  004e8	5d		 pop	 ebp
  004e9	c3		 ret	 0
$LN3@GCReqmoveD:

; 14683: 	{
; 14684: 		LogAdd("return %s %d", __FILE__, __LINE__);

  004ea	68 5c 39 00 00	 push	 14684			; 0000395cH
  004ef	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  004f4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GGPGOPEN@return?5?$CFs?5?$CFd?$AA@
  004f9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00502	5b		 pop	 ebx

; 14896: }

  00503	8b e5		 mov	 esp, ebp
  00505	5d		 pop	 ebp
  00506	c3		 ret	 0
?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ENDP ; GCReqmoveDevilSquare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCServerCmd@@YAXHEEE@Z
_TEXT	SEGMENT
_ServerCmd$ = -8					; size = 7
_aIndex$ = 8						; size = 4
_type$ = 12						; size = 1
_Cmd1$ = 16						; size = 1
_Cmd2$ = 20						; size = 1
?GCServerCmd@@YAXHEEE@Z PROC				; GCServerCmd, COMDAT

; 14660: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 14661: 	PMSG_SERVERCMD ServerCmd;
; 14662: 
; 14663: 	PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  00006	6a 07		 push	 7
  00008	6a 40		 push	 64			; 00000040H
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _ServerCmd$[ebp]
  0000d	68 f3 00 00 00	 push	 243			; 000000f3H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 14664: 	ServerCmd.CmdType = type;

  00018	8a 45 0c	 mov	 al, BYTE PTR _type$[ebp]
  0001b	88 45 fc	 mov	 BYTE PTR _ServerCmd$[ebp+4], al

; 14665: 	ServerCmd.X = Cmd1;

  0001e	8a 45 10	 mov	 al, BYTE PTR _Cmd1$[ebp]
  00021	88 45 fd	 mov	 BYTE PTR _ServerCmd$[ebp+5], al

; 14666: 	ServerCmd.Y = Cmd2;

  00024	8a 45 14	 mov	 al, BYTE PTR _Cmd2$[ebp]
  00027	88 45 fe	 mov	 BYTE PTR _ServerCmd$[ebp+6], al

; 14667: 
; 14668: 	DataSend(aIndex, (UCHAR*)&ServerCmd, ServerCmd.h.size);

  0002a	0f b6 45 f9	 movzx	 eax, BYTE PTR _ServerCmd$[ebp+1]
  0002e	50		 push	 eax
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _ServerCmd$[ebp]
  00032	50		 push	 eax
  00033	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00036	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 14669: }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?GCServerCmd@@YAXHEEE@Z ENDP				; GCServerCmd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGWeatherSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_weather$ = 12						; size = 1
?CGWeatherSend@@YAXHE@Z PROC				; CGWeatherSend, COMDAT

; 14646: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 14647: 	PMSG_WEATHER pMsg;
; 14648: 
; 14649: 	PHeadSetB((LPBYTE)&pMsg, 0x0F, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14650: 	pMsg.Weather = weather;

  00011	8a 45 0c	 mov	 al, BYTE PTR _weather$[ebp]
  00014	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 14651: 
; 14652: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00017	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001b	50		 push	 eax
  0001c	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00023	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00028	83 c4 18	 add	 esp, 24			; 00000018H

; 14653: }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?CGWeatherSend@@YAXHE@Z ENDP				; CGWeatherSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCItemDurSend2@@YAXHEEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_dur$ = 16						; size = 1
_flag$ = 20						; size = 1
?GCItemDurSend2@@YAXHEEE@Z PROC				; GCItemDurSend2, COMDAT

; 14625: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 14626: 	PMSG_ITEMDUR pMsg;
; 14627: 
; 14628: 	PHeadSetB((LPBYTE)&pMsg, 0x2A, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 2a		 push	 42			; 0000002aH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14629: 	pMsg.IPos = pos;

  00013	8a 45 0c	 mov	 al, BYTE PTR _pos$[ebp]
  00016	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 14630: 	pMsg.Dur = dur;

  00019	8a 45 10	 mov	 al, BYTE PTR _dur$[ebp]
  0001c	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 14631: 	pMsg.Flag = flag;

  0001f	8a 45 14	 mov	 al, BYTE PTR _flag$[ebp]
  00022	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 14632: 
; 14633: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00025	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00029	50		 push	 eax
  0002a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002d	50		 push	 eax
  0002e	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00031	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00036	83 c4 18	 add	 esp, 24			; 00000018H

; 14634: }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?GCItemDurSend2@@YAXHEEE@Z ENDP				; GCItemDurSend2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCItemDurSend@@YAXHEEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_dur$ = 16						; size = 1
_flag$ = 20						; size = 1
?GCItemDurSend@@YAXHEEE@Z PROC				; GCItemDurSend, COMDAT

; 14610: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 14611: 	PMSG_ITEMDUR pMsg;
; 14612: 
; 14613: 	PHeadSetB((LPBYTE)&pMsg, 0x2A, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 2a		 push	 42			; 0000002aH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14614: 	pMsg.IPos = pos;

  00013	8a 45 0c	 mov	 al, BYTE PTR _pos$[ebp]
  00016	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 14615: 	pMsg.Dur = dur;

  00019	8a 45 10	 mov	 al, BYTE PTR _dur$[ebp]
  0001c	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 14616: 	pMsg.Flag = flag;

  0001f	8a 45 14	 mov	 al, BYTE PTR _flag$[ebp]
  00022	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 14617: 
; 14618: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00025	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00029	50		 push	 eax
  0002a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002d	50		 push	 eax
  0002e	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00031	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00036	83 c4 18	 add	 esp, 24			; 00000018H

; 14619: }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?GCItemDurSend@@YAXHEEE@Z ENDP				; GCItemDurSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCItemUseSpecialTimeSend@@YAXHEH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_number$ = 12						; size = 1
_time$ = 16						; size = 4
?GCItemUseSpecialTimeSend@@YAXHEH@Z PROC		; GCItemUseSpecialTimeSend, COMDAT

; 14583: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 14584: 	if ( time > 65535 )

  00007	8b 75 10	 mov	 esi, DWORD PTR _time$[ebp]
  0000a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000f	3b f0		 cmp	 esi, eax

; 14585: 	{
; 14586: 		time = 65535;
; 14587: 	}
; 14588: 
; 14589: 	PMSG_ITEMUSESPECIALTIME pMsg;
; 14590: 
; 14591: 	PHeadSetBE((LPBYTE)&pMsg, 0x29, sizeof(pMsg));

  00011	6a 06		 push	 6
  00013	0f 4f f0	 cmovg	 esi, eax
  00016	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	6a 29		 push	 41			; 00000029H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 14592: 	pMsg.Number = number;

  00021	8a 45 0c	 mov	 al, BYTE PTR _number$[ebp]
  00024	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 14593: 	pMsg.Time = time;
; 14594: 
; 14595: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00027	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0002b	50		 push	 eax
  0002c	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002f	66 89 75 fc	 mov	 WORD PTR _pMsg$[ebp+4], si
  00033	50		 push	 eax
  00034	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00037	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003c	83 c4 18	 add	 esp, 24			; 00000018H
  0003f	5e		 pop	 esi

; 14596: }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?GCItemUseSpecialTimeSend@@YAXHEH@Z ENDP		; GCItemUseSpecialTimeSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCInventoryItemDeleteSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 1
_flag$ = 16						; size = 1
?GCInventoryItemDeleteSend@@YAXHEE@Z PROC		; GCInventoryItemDeleteSend, COMDAT

; 14563: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 14564: 	PMSG_INVENTORYDELETE pMsg;
; 14565: 	
; 14566: 	PHeadSetB((LPBYTE)&pMsg, 0x28, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 28		 push	 40			; 00000028H
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14567: 	pMsg.IPos = pos;

  00013	8a 45 0c	 mov	 al, BYTE PTR _pos$[ebp]
  00016	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 14568: 	pMsg.Flag = flag;

  00019	8a 45 10	 mov	 al, BYTE PTR _flag$[ebp]
  0001c	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 14569: 
; 14570: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0001f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00023	50		 push	 eax
  00024	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00027	50		 push	 eax
  00028	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 18	 add	 esp, 24			; 00000018H

; 14571: }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCInventoryItemDeleteSend@@YAXHEE@Z ENDP		; GCInventoryItemDeleteSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCManaSend@@YAXHFEEG@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Mana$ = 12						; size = 2
_Ipos$ = 16						; size = 1
_flag$ = 20						; size = 1
_BP$ = 24						; size = 2
?GCManaSend@@YAXHFEEG@Z PROC				; GCManaSend, COMDAT

; 14521: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 14522: 	if ( aIndex < 0 || aIndex > OBJMAX-1)

  00014	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0001a	0f 87 98 00 00
	00		 ja	 $LN3@GCManaSend

; 14525: 		return;
; 14526: 	}
; 14527: 
; 14528: 	if ( gObj[aIndex].Type != OBJ_USER )

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00025	57		 push	 edi
  00026	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  0002c	80 7c 07 50 01	 cmp	 BYTE PTR [edi+eax+80], 1
  00031	75 75		 jne	 SHORT $LN8@GCManaSend

; 14529: 	{
; 14530: 		return;
; 14531: 	}
; 14532: 
; 14533: 	PMSG_MANASEND pMsg;
; 14534: 
; 14535: 	PHeadSetB((LPBYTE)&pMsg, 0x27, sizeof(pMsg));

  00033	6a 0c		 push	 12			; 0000000cH
  00035	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00038	6a 27		 push	 39			; 00000027H
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14536: 	pMsg.IPos = Ipos;
; 14537: 	pMsg.ManaH = SET_NUMBERH(Mana);

  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _Mana$[ebp]
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	8a 55 10	 mov	 dl, BYTE PTR _Ipos$[ebp]
  00049	8b c1		 mov	 eax, ecx
  0004b	c1 e8 08	 shr	 eax, 8
  0004e	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 14538: 	pMsg.ManaL = SET_NUMBERL(Mana);

  00051	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 14539: 	pMsg.BPH = SET_NUMBERH(BP);

  00054	8b 4d 18	 mov	 ecx, DWORD PTR _BP$[ebp]
  00057	8b c1		 mov	 eax, ecx
  00059	c1 e8 08	 shr	 eax, 8
  0005c	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 14540: 	pMsg.BPL = SET_NUMBERL(BP);
; 14541: 
; 14542: #if (FIX_HP==1)
; 14543: 	if( Ipos == 0xFF )
; 14544: 		pMsg.MP = (int)gObj[aIndex].Mana;

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00064	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  00067	88 4d f7	 mov	 BYTE PTR _pMsg$[ebp+7], cl
  0006a	80 fa ff	 cmp	 dl, 255			; 000000ffH
  0006d	75 0b		 jne	 SHORT $LN5@GCManaSend
  0006f	f3 0f 2c 84 07
	ec 00 00 00	 cvttss2si eax, DWORD PTR [edi+eax+236]

; 14545: 	else

  00078	eb 19		 jmp	 SHORT $LN9@GCManaSend
$LN5@GCManaSend:
  0007a	66 0f 6e 84 07
	28 01 00 00	 movd	 xmm0, DWORD PTR [edi+eax+296]

; 14546: 		pMsg.MP = (int)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana);

  00083	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00086	f3 0f 58 84 07
	f0 00 00 00	 addss	 xmm0, DWORD PTR [edi+eax+240]
  0008f	f3 0f 2c c0	 cvttss2si eax, xmm0
$LN9@GCManaSend:
  00093	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 14547: #endif
; 14548: 
; 14549: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00096	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0009a	50		 push	 eax
  0009b	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0009e	50		 push	 eax
  0009f	56		 push	 esi
  000a0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@GCManaSend:
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi

; 14550: }

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	33 cd		 xor	 ecx, ebp
  000af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c3		 ret	 0
$LN3@GCManaSend:

; 14523: 	{
; 14524: 		LogAdd("GCManaSend() return %s %d", __FILE__, __LINE__);

  000b8	68 bc 38 00 00	 push	 14524			; 000038bcH
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CHOMIMBC@GCManaSend?$CI?$CJ?5return?5?$CFs?5?$CFd?$AA@
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 14550: }

  000cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	33 cd		 xor	 ecx, ebp
  000d5	5e		 pop	 esi
  000d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
?GCManaSend@@YAXHFEEG@Z ENDP				; GCManaSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCReFillSend@@YAXHGEEG@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Life$ = 12						; size = 2
_Ipos$ = 16						; size = 1
_flag$ = 20						; size = 1
_wShield$ = 24						; size = 2
?GCReFillSend@@YAXHGEEG@Z PROC				; GCReFillSend, COMDAT

; 14477: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 14478: 	PMSG_REFILL pMsg;
; 14479: 
; 14480: 	PHeadSetB((LPBYTE)&pMsg, 0x26, sizeof(pMsg));

  00014	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 14		 push	 20			; 00000014H
  00019	6a 26		 push	 38			; 00000026H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14481: 	pMsg.IPos = Ipos;
; 14482: 	pMsg.LifeH = SET_NUMBERH(Life);

  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _Life$[ebp]
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	8a 55 10	 mov	 dl, BYTE PTR _Ipos$[ebp]
  0002a	8b c1		 mov	 eax, ecx
  0002c	c1 e8 08	 shr	 eax, 8

; 14483: 	pMsg.LifeL = SET_NUMBERL(Life);

  0002f	88 4d ed	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 14484: 	pMsg.btShieldH = SET_NUMBERH(wShield);

  00032	8b 4d 18	 mov	 ecx, DWORD PTR _wShield$[ebp]
  00035	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00038	8b c1		 mov	 eax, ecx
  0003a	c1 e8 08	 shr	 eax, 8

; 14485: 	pMsg.btShieldL = SET_NUMBERL(wShield);

  0003d	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+8], cl

; 14486: 	pMsg.Flag = 0;
; 14487: 
; 14488: #if (FIX_HP==1)
; 14489: 	if( Ipos == 0xFF )
; 14490: 	{
; 14491: 		pMsg.HP = (int)gObj[aIndex].Life;

  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00046	88 55 eb	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  00049	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+7], al
  0004c	c6 45 ee 00	 mov	 BYTE PTR _pMsg$[ebp+6], 0
  00050	80 fa ff	 cmp	 dl, 255			; 000000ffH
  00053	75 1b		 jne	 SHORT $LN2@GCReFillSe
  00055	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  0005b	f3 0f 2c 84 0a
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edx+ecx+216]
  00064	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 14492: 		pMsg.SD = gObj[aIndex].iShield;

  00067	8b 84 0a 2c 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx+300]

; 14493: 	}
; 14494: 	else

  0006e	eb 30		 jmp	 SHORT $LN5@GCReFillSe
$LN2@GCReFillSe:

; 14495: 	{
; 14496: 		pMsg.HP = (int)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife);

  00070	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  00076	66 0f 6e 84 0a
	24 01 00 00	 movd	 xmm0, DWORD PTR [edx+ecx+292]
  0007f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00082	f3 0f 58 84 0a
	dc 00 00 00	 addss	 xmm0, DWORD PTR [edx+ecx+220]
  0008b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0008f	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+12], eax

; 14497: 		pMsg.SD = gObj[aIndex].iAddShield + gObj[aIndex].iMaxShield;

  00092	8b 84 0a 34 01
	00 00		 mov	 eax, DWORD PTR [edx+ecx+308]
  00099	03 84 0a 30 01
	00 00		 add	 eax, DWORD PTR [edx+ecx+304]
$LN5@GCReFillSe:
  000a0	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax

; 14498: 	}
; 14499: #endif
; 14500: 
; 14501: 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  000a3	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000a7	50		 push	 eax
  000a8	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ab	50		 push	 eax
  000ac	56		 push	 esi
  000ad	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 14502: }

  000b2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b8	33 cd		 xor	 ecx, ebp
  000ba	5e		 pop	 esi
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?GCReFillSend@@YAXHGEEG@Z ENDP				; GCReFillSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z
_TEXT	SEGMENT
_iItemUseType$1$ = -292					; size = 4
_addskill$1$ = -292					; size = 4
_aIndex$GSCopy$1$ = -288				; size = 4
_bMove$1$ = -288					; size = 4
_bMove$1$ = -288					; size = 4
_skillnumber$1 = -288					; size = 2
_citem$1$ = -284					; size = 4
?gObj@@3PAUOBJECTSTRUCT@@A$6 = -280			; size = 4
?gObj@@3PAUOBJECTSTRUCT@@A$5 = -280			; size = 4
?gObj@@3PAUOBJECTSTRUCT@@A$4 = -280			; size = 4
?gObj@@3PAUOBJECTSTRUCT@@A$3 = -280			; size = 4
?gObj@@3PAUOBJECTSTRUCT@@A$2 = -280			; size = 4
?gObj@@3PAUOBJECTSTRUCT@@A$1 = -280			; size = 4
tv1264 = -280						; size = 4
tv743 = -280						; size = 4
tv577 = -280						; size = 4
_lpMsg$GSCopy$1$ = -276					; size = 4
_nAddRate$1$ = -276					; size = 4
_tMana$1$ = -276					; size = 4
_iSerial$1$ = -276					; size = 4
_iHPGage$1$ = -272					; size = 4
_tLife$1$ = -272					; size = 4
_iHPGage$1$ = -272					; size = 4
_iShieldGage$1$ = -272					; size = 4
_iHPGage$1$ = -272					; size = 4
_iLevel$1$ = -272					; size = 4
_BuffNumber$1$ = -272					; size = 4
tv749 = -272						; size = 4
tv556 = -272						; size = 4
tv2050 = -268						; size = 4
?gObj@@3PAUOBJECTSTRUCT@@A$10 = -264			; size = 4
_iShieldGage$1$ = -264					; size = 4
_pos$1$ = -264						; size = 4
_iShieldGage$1$ = -264					; size = 4
_iShieldGage$1$ = -264					; size = 4
_iDur$1$ = -264						; size = 4
_pMsg$2 = -264						; size = 4
_pMsg$3 = -264						; size = 4
tv2423 = -264						; size = 4
tv982 = -264						; size = 4
_szMsg$4 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z PROC		; CGUseItemRecv, COMDAT

; 13098: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 13099: 	int pos;
; 13100: 	CItem * citem;
; 13101: 	int iItemUseType = lpMsg->btItemUseType;
; 13102: 
; 13103: 
; 13104: 	// Check User States
; 13105: 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type != 3 )

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	53		 push	 ebx
  0001a	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001d	56		 push	 esi
  0001e	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00021	57		 push	 edi
  00022	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  00028	89 b5 ec fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], esi
  0002e	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00032	89 85 dc fe ff
	ff		 mov	 DWORD PTR _iItemUseType$1$[ebp], eax
  00038	89 9d e0 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], ebx
  0003e	8b 84 0f b8 11
	00 00		 mov	 eax, DWORD PTR [edi+ecx+4536]
  00045	a8 03		 test	 al, 3
  00047	74 55		 je	 SHORT $LN8@CGUseItemR
  00049	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0004e	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00053	74 49		 je	 SHORT $LN8@CGUseItemR

; 13106: 	{
; 13107: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, TRUE, gObj[aIndex].iShield);

  00055	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  0005d	50		 push	 eax
  0005e	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  00067	6a 01		 push	 1
  00069	68 fd 00 00 00	 push	 253			; 000000fdH
  0006e	0f b7 c0	 movzx	 eax, ax
  00071	50		 push	 eax
  00072	53		 push	 ebx
  00073	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13108: 
; 13109: 		LogAdd("[%s][%s] CGUseItemRecv()_If return %s %d",

  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007e	68 38 33 00 00	 push	 13112			; 00003338H
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00088	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0008b	03 c7		 add	 eax, edi
  0008d	50		 push	 eax
  0008e	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00091	03 c7		 add	 eax, edi
  00093	50		 push	 eax
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@BOAIHIHD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_If?5retu@

; 13110: 			gObj[aIndex].AccountID,
; 13111: 			gObj[aIndex].Name,
; 13112: 			__FILE__, __LINE__);
; 13113: 
; 13114: 		return;

  00099	e9 b4 29 00 00	 jmp	 $LN346@CGUseItemR
$LN8@CGUseItemR:

; 13115: 	}
; 13116: 
; 13117: 	// Check if User is exiting
; 13118: 	if ( gObj[aIndex].CloseType != -1 )

  0009e	80 7c 0f 0d ff	 cmp	 BYTE PTR [edi+ecx+13], -1
  000a3	74 49		 je	 SHORT $LN9@CGUseItemR

; 13119: 	{
; 13120: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, TRUE, gObj[aIndex].iShield);

  000a5	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  000ad	50		 push	 eax
  000ae	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  000b7	6a 01		 push	 1
  000b9	68 fd 00 00 00	 push	 253			; 000000fdH
  000be	0f b7 c0	 movzx	 eax, ax
  000c1	50		 push	 eax
  000c2	53		 push	 ebx
  000c3	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13121: 
; 13122: 		LogAdd("[%s][%s] CGUseItemRecv()_CloseType return %s %d",

  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ce	68 45 33 00 00	 push	 13125			; 00003345H
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000d8	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000db	03 c7		 add	 eax, edi
  000dd	50		 push	 eax
  000de	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000e1	03 c7		 add	 eax, edi
  000e3	50		 push	 eax
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@MJHNJBGE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_CloseTy@

; 13123: 			gObj[aIndex].AccountID, 
; 13124: 			gObj[aIndex].Name,
; 13125: 			__FILE__, __LINE__);
; 13126: 
; 13127: 		return;

  000e9	e9 64 29 00 00	 jmp	 $LN346@CGUseItemR
$LN9@CGUseItemR:

; 13128: 	}
; 13129: 
; 13130: 	// Fix Inventory Pointer
; 13131: 	if ( gObjFixInventoryPointer(aIndex) == false )

  000ee	53		 push	 ebx
  000ef	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  000f4	83 c4 04	 add	 esp, 4
  000f7	84 c0		 test	 al, al
  000f9	75 18		 jne	 SHORT $LN10@CGUseItemR

; 13132: 	{
; 13133: 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d",

  000fb	68 4e 33 00 00	 push	 13134			; 0000334eH
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00110	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@CGUseItemR:

; 13134: 			__FILE__, __LINE__);
; 13135: 		//return;
; 13136: 	}
; 13137: 
; 13138: 	// Check if there is a Transaction
; 13139: 	// Dupe
; 13140: 	if ( gObj[aIndex].pTransaction == 1 )

  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00119	03 cf		 add	 ecx, edi
  0011b	80 b9 cc 11 00
	00 01		 cmp	 BYTE PTR [ecx+4556], 1
  00122	75 36		 jne	 SHORT $LN11@CGUseItemR

; 13141: 	{
; 13142: 		LogAddTD("[%s][%s] CGUseItemRecv() Failed : Transaction == 1, IF_TYPE : %d",

  00124	8b 81 b8 11 00
	00		 mov	 eax, DWORD PTR [ecx+4536]
  0012a	c1 e8 06	 shr	 eax, 6
  0012d	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00132	50		 push	 eax
  00133	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00136	50		 push	 eax
  00137	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0013a	50		 push	 eax
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@BNHHPHMK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ?5Failed?5@
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00146	83 c4 10	 add	 esp, 16			; 00000010H
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  0014c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014f	33 cd		 xor	 ecx, ebp
  00151	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c3		 ret	 0
$LN11@CGUseItemR:

; 13143: 			gObj[aIndex].AccountID,
; 13144: 			gObj[aIndex].Name,
; 13145: 			gObj[aIndex].m_IfState.type);
; 13146: 
; 13147: 		return;
; 13148: 	}
; 13149: 
; 13150: #if (ENABLETEST_NEWPVP == 1)
; 13151: 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  0015a	51		 push	 ecx
  0015b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00160	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00165	85 c0		 test	 eax, eax
  00167	74 2c		 je	 SHORT $LN12@CGUseItemR

; 13152: 		 GCServerMsgStringSend(lMsg.Get(3428), aIndex, 1);

  00169	6a 01		 push	 1
  0016b	53		 push	 ebx
  0016c	68 64 0d 00 00	 push	 3428			; 00000d64H
  00171	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00176	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH
  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  00187	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018a	33 cd		 xor	 ecx, ebp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	8b e5		 mov	 esp, ebp
  00193	5d		 pop	 ebp
  00194	c3		 ret	 0
$LN12@CGUseItemR:

; 13153: 		 return;
; 13154: 	}
; 13155: #endif
; 13156: 
; 13157: 	// Set Var Pos
; 13158: 	pos = lpMsg->inventoryPos;

  00195	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  00198	0f b6 f0	 movzx	 esi, al
  0019b	89 b5 f8 fe ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], esi

; 13159: 
; 13160: 	// Check if the pos is in bounds
; 13161: 	if ( pos > MAIN_INVENTORY_SIZE-1 )

  001a1	81 fe cb 00 00
	00		 cmp	 esi, 203		; 000000cbH
  001a7	0f 8e 84 00 00
	00		 jle	 $LN13@CGUseItemR

; 13162: 	{
; 13163: 		// error : Location is over the range. %s/%d
; 13164: 		LogAdd(lMsg.Get(MSGGET(1, 241)), __FILE__, __LINE__);

  001ad	68 6c 33 00 00	 push	 13164			; 0000336cH
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001b7	68 f1 01 00 00	 push	 497			; 000001f1H
  001bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001c1	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001c6	50		 push	 eax
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 13165: 
; 13166: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  001cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d3	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  001db	50		 push	 eax
  001dc	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  001e5	6a 01		 push	 1
  001e7	68 fd 00 00 00	 push	 253			; 000000fdH
  001ec	0f b7 c0	 movzx	 eax, ax
  001ef	50		 push	 eax
  001f0	53		 push	 ebx
  001f1	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13167: 
; 13168: 		LogAdd("[%s][%s] CGUseItemRecv()_Inventory return %s %d",

  001f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001fc	68 73 33 00 00	 push	 13171			; 00003373H
  00201	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00206	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00209	03 c7		 add	 eax, edi
  0020b	50		 push	 eax
  0020c	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0020f	03 c7		 add	 eax, edi
  00211	50		 push	 eax
  00212	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@FOMIHIHO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRecv?$CI?$CJ_Invento@
  00217	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0021d	83 c4 34	 add	 esp, 52			; 00000034H
  00220	5f		 pop	 edi
  00221	5e		 pop	 esi
  00222	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  00223	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00226	33 cd		 xor	 ecx, ebp
  00228	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022d	8b e5		 mov	 esp, ebp
  0022f	5d		 pop	 ebp
  00230	c3		 ret	 0
$LN13@CGUseItemR:

; 13169: 			gObj[aIndex].AccountID,
; 13170: 			gObj[aIndex].Name,
; 13171: 			__FILE__, __LINE__);
; 13172: 
; 13173: 		return;
; 13174: 	}
; 13175: 
; 13176: 
; 13177: 	// check if the item
; 13178: 	// have the same position
; 13179: 	// as the new position
; 13180: 	if ( lpMsg->inventoryPos == lpMsg->invenrotyTarget )

  00231	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00237	3a 41 04	 cmp	 al, BYTE PTR [ecx+4]
  0023a	75 4f		 jne	 SHORT $LN14@CGUseItemR

; 13181: 	{
; 13182: 		GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  0023c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00242	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  0024a	50		 push	 eax
  0024b	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  00254	6a 01		 push	 1
  00256	68 fd 00 00 00	 push	 253			; 000000fdH
  0025b	0f b7 c0	 movzx	 eax, ax
  0025e	50		 push	 eax
  0025f	53		 push	 ebx
  00260	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13183: 
; 13184: 		LogAdd("error-L1 : [%s][%s] CGUseItemRecv()_Pos return %s %d",

  00265	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026b	68 83 33 00 00	 push	 13187			; 00003383H
  00270	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00275	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00278	03 c7		 add	 eax, edi
  0027a	50		 push	 eax
  0027b	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0027e	03 c7		 add	 eax, edi
  00280	50		 push	 eax
  00281	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@KEJKEDMK@error?9L1?5?3?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGUseItemRec@

; 13185: 			gObj[aIndex].AccountID,
; 13186: 			gObj[aIndex].Name,
; 13187: 			__FILE__, __LINE__);
; 13188: 
; 13189: 		return;

  00286	e9 c7 27 00 00	 jmp	 $LN346@CGUseItemR
$LN14@CGUseItemR:

; 13190: 	}
; 13191: 
; 13192: 	// Set Pointer
; 13193: 	citem = &gObj[aIndex].pInventory[pos];

  0028b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00290	69 ce d4 00 00
	00		 imul	 ecx, esi, 212
  00296	8b 84 07 c0 11
	00 00		 mov	 eax, DWORD PTR [edi+eax+4544]
  0029d	03 c1		 add	 eax, ecx
  0029f	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv2050[ebp], ecx

; 13194: 
; 13195: 
; 13196: 	// The item is ITEM
; 13197: 	if ( citem->IsItem() )

  002a5	8b c8		 mov	 ecx, eax
  002a7	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _citem$1$[ebp], eax
  002ad	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002b2	85 c0		 test	 eax, eax
  002b4	0f 84 54 27 00
	00		 je	 $LN15@CGUseItemR

; 13198: 	{
; 13199: 		// Check if item have 0 as Serial
; 13200: 		if ( gObjCheckSerial0ItemList(citem) )

  002ba	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$1$[ebp]
  002c0	51		 push	 ecx
  002c1	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  002c6	83 c4 04	 add	 esp, 4
  002c9	85 c0		 test	 eax, eax
  002cb	0f 84 85 00 00
	00		 je	 $LN17@CGUseItemR

; 13201: 		{
; 13202: 			MsgOutput(aIndex, lMsg.Get(MSGGET(13, 26)));

  002d1	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  002d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002db	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002e0	50		 push	 eax
  002e1	53		 push	 ebx
  002e2	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 13203: 
; 13204: 			GCReFillSend(aIndex,

  002e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ed	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  002f5	50		 push	 eax
  002f6	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  002ff	6a 01		 push	 1
  00301	68 fd 00 00 00	 push	 253			; 000000fdH
  00306	0f b7 c0	 movzx	 eax, ax
  00309	50		 push	 eax
  0030a	53		 push	 ebx
  0030b	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13205: 					(WORD)gObj[aIndex].Life,
; 13206: 					0xFD,
; 13207: 					1,
; 13208: 					gObj[aIndex].iShield);
; 13209: 
; 13210: 
; 13211: 			LogAddTD("[ANTI-HACK][Serial 0 Item] [UseItem] (%s)(%s) Item(%s) Pos(%d)",

  00310	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$1$[ebp]
  00316	83 c4 1c	 add	 esp, 28			; 0000001cH
  00319	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0031f	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _pos$1$[ebp]
  00325	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0032a	50		 push	 eax
  0032b	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0032e	03 c7		 add	 eax, edi
  00330	50		 push	 eax
  00331	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00334	03 c7		 add	 eax, edi
  00336	50		 push	 eax
  00337	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@BFNIJADP@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLUseI@
  0033c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00342	83 c4 14	 add	 esp, 20			; 00000014H
  00345	5f		 pop	 edi
  00346	5e		 pop	 esi
  00347	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  00348	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0034b	33 cd		 xor	 ecx, ebp
  0034d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00352	8b e5		 mov	 esp, ebp
  00354	5d		 pop	 ebp
  00355	c3		 ret	 0
$LN17@CGUseItemR:

; 13212: 				gObj[aIndex].AccountID,
; 13213: 				gObj[aIndex].Name,
; 13214: 				citem->GetName(),
; 13215: 				pos);
; 13216: 
; 13217: 			return;
; 13218: 		}
; 13219: 
; 13220: 		// Check the item Serial
; 13221: 		if ( gObjInventorySearchSerialNumber(&gObj[aIndex],
; 13222: 												citem->GetNumber()) == FALSE )

  00356	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$1$[ebp]
  0035c	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00361	50		 push	 eax
  00362	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00367	03 c7		 add	 eax, edi
  00369	50		 push	 eax
  0036a	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  0036f	83 c4 08	 add	 esp, 8
  00372	85 c0		 test	 eax, eax
  00374	75 4f		 jne	 SHORT $LN18@CGUseItemR

; 13223: 		{
; 13224: 			GCReFillSend(aIndex,

  00376	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0037c	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  00384	50		 push	 eax
  00385	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  0038e	6a 01		 push	 1
  00390	68 fd 00 00 00	 push	 253			; 000000fdH
  00395	0f b7 c0	 movzx	 eax, ax
  00398	50		 push	 eax
  00399	53		 push	 ebx
  0039a	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 13225: 					(WORD)gObj[aIndex].Life,
; 13226: 					0xFD,
; 13227: 					1,
; 13228: 					gObj[aIndex].iShield);
; 13229: 		
; 13230: 			
; 13231: 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d",

  0039f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a5	68 b2 33 00 00	 push	 13234			; 000033b2H
  003aa	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  003af	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  003b2	03 c7		 add	 eax, edi
  003b4	50		 push	 eax
  003b5	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  003b8	03 c7		 add	 eax, edi
  003ba	50		 push	 eax
  003bb	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@

; 13232: 				gObj[aIndex].AccountID,
; 13233: 				gObj[aIndex].Name,
; 13234: 				__FILE__, __LINE__);
; 13235: 
; 13236: 			return;

  003c0	e9 8d 26 00 00	 jmp	 $LN346@CGUseItemR
$LN18@CGUseItemR:

; 13237: 		}
; 13238: 
; 13239: 		if ( citem->m_serial && !gObjCanItemTouch(&gObj[aIndex], 1) )

  003c5	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
  003cb	80 78 04 00	 cmp	 BYTE PTR [eax+4], 0
  003cf	74 59		 je	 SHORT $LN19@CGUseItemR
  003d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003d6	03 c7		 add	 eax, edi
  003d8	6a 01		 push	 1
  003da	50		 push	 eax
  003db	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  003e0	83 c4 08	 add	 esp, 8
  003e3	85 c0		 test	 eax, eax
  003e5	75 3d		 jne	 SHORT $LN342@CGUseItemR
$LN355@CGUseItemR:

; 13240: 		{
; 13241: 			GCReFillSend(aIndex, (WORD)

  003e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ed	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  003f5	50		 push	 eax
  003f6	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  003ff	6a 01		 push	 1
  00401	68 fd 00 00 00	 push	 253			; 000000fdH
  00406	0f b7 c0	 movzx	 eax, ax
  00409	50		 push	 eax
  0040a	53		 push	 ebx
  0040b	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  00410	83 c4 14	 add	 esp, 20			; 00000014H
  00413	5f		 pop	 edi
  00414	5e		 pop	 esi
  00415	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  00416	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00419	33 cd		 xor	 ecx, ebp
  0041b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00420	8b e5		 mov	 esp, ebp
  00422	5d		 pop	 ebp
  00423	c3		 ret	 0
$LN342@CGUseItemR:
  00424	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
$LN19@CGUseItemR:

; 13242: 				gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13243: 			return;
; 13244: 		}
; 13245: 
; 13246: 		if ( citem->m_Type == ITEMGET(14,0) || // Apple
; 13247: 			 citem->m_Type == ITEMGET(14,1) ||
; 13248: 			 citem->m_Type == ITEMGET(14,2) ||

  0042a	0f b7 50 06	 movzx	 edx, WORD PTR [eax+6]
  0042e	b9 00 1c 00 00	 mov	 ecx, 7168		; 00001c00H
  00433	89 8d e8 fe ff
	ff		 mov	 DWORD PTR tv1264[ebp], ecx
  00439	66 3b d1	 cmp	 dx, cx
  0043c	0f 84 6e 23 00
	00		 je	 $LN22@CGUseItemR
  00442	b9 01 1c 00 00	 mov	 ecx, 7169		; 00001c01H
  00447	66 3b d1	 cmp	 dx, cx
  0044a	0f 84 60 23 00
	00		 je	 $LN22@CGUseItemR
  00450	b9 02 1c 00 00	 mov	 ecx, 7170		; 00001c02H
  00455	66 3b d1	 cmp	 dx, cx
  00458	0f 84 52 23 00
	00		 je	 $LN22@CGUseItemR
  0045e	b9 03 1c 00 00	 mov	 ecx, 7171		; 00001c03H
  00463	66 3b d1	 cmp	 dx, cx
  00466	0f 84 44 23 00
	00		 je	 $LN22@CGUseItemR

; 13326: 			}
; 13327: 		}
; 13328: 		else if (citem->m_Type == ITEMGET(14,4) ||	// Small Mana Potion
; 13329: 				 citem->m_Type == ITEMGET(14,5) ||

  0046c	b9 04 1c 00 00	 mov	 ecx, 7172		; 00001c04H
  00471	66 3b d1	 cmp	 dx, cx
  00474	0f 84 cb 21 00
	00		 je	 $LN40@CGUseItemR
  0047a	b9 05 1c 00 00	 mov	 ecx, 7173		; 00001c05H
  0047f	66 3b d1	 cmp	 dx, cx
  00482	0f 84 bd 21 00
	00		 je	 $LN40@CGUseItemR
  00488	b9 06 1c 00 00	 mov	 ecx, 7174		; 00001c06H
  0048d	66 3b d1	 cmp	 dx, cx
  00490	0f 84 af 21 00
	00		 je	 $LN40@CGUseItemR

; 13366: 		else if ( citem->m_Type == ITEMGET(14,38) )	// Small Compound Potion 

  00496	b8 26 1c 00 00	 mov	 eax, 7206		; 00001c26H
  0049b	66 3b d0	 cmp	 dx, ax
  0049e	0f 85 3f 02 00
	00		 jne	 $LN47@CGUseItemR

; 13367: 		{
; 13368: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 5/100;	// #formula

  004a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004aa	89 8d e8 fe ff
	ff		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$5[ebp], ecx
  004b0	8b 84 0f 34 01
	00 00		 mov	 eax, DWORD PTR [edi+ecx+308]
  004b7	03 84 0f 30 01
	00 00		 add	 eax, DWORD PTR [edi+ecx+304]
  004be	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  004c1	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  004c6	f7 e9		 imul	 ecx
  004c8	c1 fa 05	 sar	 edx, 5
  004cb	8b c2		 mov	 eax, edx
  004cd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  004d0	03 c2		 add	 eax, edx

; 13369: 			int iHPGage = (int)((gObj[aIndex].MaxLife + gObj[aIndex].AddLife) * 10.0f / 100.0f );	// #formula

  004d2	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$5[ebp]
  004d8	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iShieldGage$1$[ebp], eax

; 13370: 
; 13371: 			if ( gObj[aIndex].iShield < 0 )

  004de	83 bc 17 2c 01
	00 00 00	 cmp	 DWORD PTR [edi+edx+300], 0
  004e6	66 0f 6e 84 17
	24 01 00 00	 movd	 xmm0, DWORD PTR [edi+edx+292]
  004ef	0f 5b c0	 cvtdq2ps xmm0, xmm0
  004f2	f3 0f 58 84 17
	dc 00 00 00	 addss	 xmm0, DWORD PTR [edi+edx+220]
  004fb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41200000
  00503	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0050b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0050f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iHPGage$1$[ebp], eax
  00515	7d 11		 jge	 SHORT $LN49@CGUseItemR

; 13372: 				gObj[aIndex].iShield = 0;

  00517	c7 84 17 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+edx+300], 0
  00522	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN49@CGUseItemR:

; 13373: 
; 13374: 			if ( gObj[aIndex].FillLife > 0.0f )

  00528	f3 0f 10 84 17
	e4 00 00 00	 movss	 xmm0, DWORD PTR [edi+edx+228]
  00531	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00538	76 4a		 jbe	 SHORT $LN51@CGUseItemR

; 13375: 			{
; 13376: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  0053a	f3 0f 58 84 17
	d8 00 00 00	 addss	 xmm0, DWORD PTR [edi+edx+216]
  00543	f3 0f 11 84 17
	d8 00 00 00	 movss	 DWORD PTR [edi+edx+216], xmm0

; 13377: 
; 13378: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )

  0054c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00552	66 0f 6e 8c 17
	24 01 00 00	 movd	 xmm1, DWORD PTR [edi+edx+292]
  0055b	f3 0f 10 84 17
	d8 00 00 00	 movss	 xmm0, DWORD PTR [edi+edx+216]
  00564	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00567	f3 0f 58 8c 17
	dc 00 00 00	 addss	 xmm1, DWORD PTR [edi+edx+220]
  00570	0f 2f c1	 comiss	 xmm0, xmm1
  00573	76 0f		 jbe	 SHORT $LN51@CGUseItemR

; 13379: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  00575	f3 0f 11 8c 17
	d8 00 00 00	 movss	 DWORD PTR [edi+edx+216], xmm1
  0057e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN51@CGUseItemR:

; 13380: 			}
; 13381: 
; 13382: 			if ( gObj[aIndex].iFillShield > 0 )

  00584	8b 84 17 3c 01
	00 00		 mov	 eax, DWORD PTR [edi+edx+316]
  0058b	85 c0		 test	 eax, eax
  0058d	7e 31		 jle	 SHORT $LN53@CGUseItemR

; 13383: 			{
; 13384: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  0058f	01 84 17 2c 01
	00 00		 add	 DWORD PTR [edi+edx+300], eax

; 13385: 
; 13386: 				if (  gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield )  )

  00596	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0059c	8b 84 17 30 01
	00 00		 mov	 eax, DWORD PTR [edi+edx+304]
  005a3	03 84 17 34 01
	00 00		 add	 eax, DWORD PTR [edi+edx+308]
  005aa	39 84 17 2c 01
	00 00		 cmp	 DWORD PTR [edi+edx+300], eax
  005b1	7e 0d		 jle	 SHORT $LN53@CGUseItemR

; 13387: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  005b3	89 84 17 2c 01
	00 00		 mov	 DWORD PTR [edi+edx+300], eax
  005ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN53@CGUseItemR:

; 13388: 			}
; 13389: 
; 13390: 			gObj[aIndex].FillLife = (float)iHPGage;
; 13391: 			gObj[aIndex].FillLifeMax = (float)iHPGage;
; 13392: 			gObj[aIndex].FillLifeCount = 4;
; 13393: 			gObj[aIndex].iFillShield = iShieldGage;

  005c0	66 0f 6e 85 f0
	fe ff ff	 movd	 xmm0, DWORD PTR _iHPGage$1$[ebp]
  005c8	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iShieldGage$1$[ebp]
  005ce	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 13394: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13395: 			gObj[aIndex].iFillShieldCount = 4;
; 13396: 
; 13397: 			GCSendEffectInfo(aIndex, 3);

  005d1	6a 03		 push	 3
  005d3	53		 push	 ebx
  005d4	f3 0f 11 84 17
	e4 00 00 00	 movss	 DWORD PTR [edi+edx+228], xmm0
  005dd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005e2	f3 0f 11 84 07
	e8 00 00 00	 movss	 DWORD PTR [edi+eax+232], xmm0
  005eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005f0	c6 84 07 fb 00
	00 00 04	 mov	 BYTE PTR [edi+eax+251], 4
  005f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005fd	89 8c 07 3c 01
	00 00		 mov	 DWORD PTR [edi+eax+316], ecx
  00604	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00609	89 8c 07 38 01
	00 00		 mov	 DWORD PTR [edi+eax+312], ecx
  00610	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00615	c7 84 07 40 01
	00 00 04 00 00
	00		 mov	 DWORD PTR [edi+eax+320], 4
  00620	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 13398: 
; 13399: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00625	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0062a	6a 01		 push	 1
  0062c	03 c7		 add	 eax, edi
  0062e	56		 push	 esi
  0062f	50		 push	 eax
  00630	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00635	83 c4 14	 add	 esp, 20			; 00000014H
  00638	85 c0		 test	 eax, eax
  0063a	75 32		 jne	 SHORT $LN54@CGUseItemR

; 13400: 			{
; 13401: 				gObjInventoryItemSet(aIndex, pos, -1);

  0063c	68 ff 00 00 00	 push	 255			; 000000ffH
  00641	56		 push	 esi
  00642	53		 push	 ebx
  00643	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13402: 				gObj[aIndex].pInventory[pos].Clear();

  00648	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0064d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00650	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  00657	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  0065d	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13403: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00662	6a 01		 push	 1
  00664	56		 push	 esi
  00665	53		 push	 ebx
  00666	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0066b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@CGUseItemR:

; 13404: 			}
; 13405: 
; 13406: 			LogAddTD("[%s][%s]Use Compound Potion Lv1 - SD[%d] HP[%f] -> SD[%d] HP[%f]",

  0066e	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iHPGage$1$[ebp]
  00674	83 ec 08	 sub	 esp, 8
  00677	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0067d	66 0f 6e d0	 movd	 xmm2, eax
  00681	f3 0f 10 8c 17
	d8 00 00 00	 movss	 xmm1, DWORD PTR [edi+edx+216]
  0068a	8b 8c 17 2c 01
	00 00		 mov	 ecx, DWORD PTR [edi+edx+300]
  00691	0f 28 c1	 movaps	 xmm0, xmm1
  00694	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _iShieldGage$1$[ebp]
  0069a	0f 5b d2	 cvtdq2ps xmm2, xmm2
  0069d	03 c1		 add	 eax, ecx
  0069f	f3 0f 58 c2	 addss	 xmm0, xmm2
  006a3	0f 5a c0	 cvtps2pd xmm0, xmm0
  006a6	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  006ab	50		 push	 eax
  006ac	0f 5a c1	 cvtps2pd xmm0, xmm1
  006af	83 ec 08	 sub	 esp, 8
  006b2	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  006b5	03 c7		 add	 eax, edi
  006b7	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  006bc	51		 push	 ecx
  006bd	50		 push	 eax
  006be	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  006c1	03 c7		 add	 eax, edi
  006c3	50		 push	 eax
  006c4	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@CKLOJJGD@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv1?5@
  006c9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006cf	83 c4 24	 add	 esp, 36			; 00000024H
  006d2	5f		 pop	 edi
  006d3	5e		 pop	 esi
  006d4	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  006d5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006d8	33 cd		 xor	 ecx, ebp
  006da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006df	8b e5		 mov	 esp, ebp
  006e1	5d		 pop	 ebp
  006e2	c3		 ret	 0
$LN47@CGUseItemR:

; 13407: 				gObj[aIndex].AccountID, gObj[aIndex].Name, 
; 13408: 				gObj[aIndex].iShield, gObj[aIndex].Life,
; 13409: 				gObj[aIndex].iShield+iShieldGage, (double)(gObj[aIndex].Life+(float)iHPGage));
; 13410: 		}
; 13411: 		else if ( citem->m_Type == ITEMGET(14,39) )	// Compound Potion 

  006e3	b8 27 1c 00 00	 mov	 eax, 7207		; 00001c27H
  006e8	66 3b d0	 cmp	 dx, ax
  006eb	0f 85 41 02 00
	00		 jne	 $LN55@CGUseItemR

; 13412: 		{
; 13413: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 10/100;	// #formula

  006f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006f7	89 8d e8 fe ff
	ff		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$1[ebp], ecx
  006fd	8b 84 0f 34 01
	00 00		 mov	 eax, DWORD PTR [edi+ecx+308]
  00704	03 84 0f 30 01
	00 00		 add	 eax, DWORD PTR [edi+ecx+304]
  0070b	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0070e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00713	03 c9		 add	 ecx, ecx
  00715	f7 e9		 imul	 ecx
  00717	c1 fa 05	 sar	 edx, 5
  0071a	8b c2		 mov	 eax, edx
  0071c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0071f	03 c2		 add	 eax, edx

; 13414: 			int iHPGage = (int)((gObj[aIndex].MaxLife + gObj[aIndex].AddLife) * 25.0f / 100.0f );	// #formula

  00721	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$1[ebp]
  00727	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iShieldGage$1$[ebp], eax

; 13415: 
; 13416: 			if ( gObj[aIndex].iShield < 0 )

  0072d	83 bc 17 2c 01
	00 00 00	 cmp	 DWORD PTR [edi+edx+300], 0
  00735	66 0f 6e 84 17
	24 01 00 00	 movd	 xmm0, DWORD PTR [edi+edx+292]
  0073e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00741	f3 0f 58 84 17
	dc 00 00 00	 addss	 xmm0, DWORD PTR [edi+edx+220]
  0074a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@41c80000
  00752	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0075a	f3 0f 2c c0	 cvttss2si eax, xmm0
  0075e	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iHPGage$1$[ebp], eax
  00764	7d 11		 jge	 SHORT $LN57@CGUseItemR

; 13417: 				gObj[aIndex].iShield = 0;

  00766	c7 84 17 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+edx+300], 0
  00771	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN57@CGUseItemR:

; 13418: 
; 13419: 			if ( gObj[aIndex].FillLife > 0.0f )

  00777	f3 0f 10 84 17
	e4 00 00 00	 movss	 xmm0, DWORD PTR [edi+edx+228]
  00780	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00787	76 4a		 jbe	 SHORT $LN59@CGUseItemR

; 13420: 			{
; 13421: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  00789	f3 0f 58 84 17
	d8 00 00 00	 addss	 xmm0, DWORD PTR [edi+edx+216]
  00792	f3 0f 11 84 17
	d8 00 00 00	 movss	 DWORD PTR [edi+edx+216], xmm0

; 13422: 
; 13423: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )

  0079b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007a1	66 0f 6e 8c 17
	24 01 00 00	 movd	 xmm1, DWORD PTR [edi+edx+292]
  007aa	f3 0f 10 84 17
	d8 00 00 00	 movss	 xmm0, DWORD PTR [edi+edx+216]
  007b3	0f 5b c9	 cvtdq2ps xmm1, xmm1
  007b6	f3 0f 58 8c 17
	dc 00 00 00	 addss	 xmm1, DWORD PTR [edi+edx+220]
  007bf	0f 2f c1	 comiss	 xmm0, xmm1
  007c2	76 0f		 jbe	 SHORT $LN59@CGUseItemR

; 13424: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  007c4	f3 0f 11 8c 17
	d8 00 00 00	 movss	 DWORD PTR [edi+edx+216], xmm1
  007cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN59@CGUseItemR:

; 13425: 			}
; 13426: 
; 13427: 			if ( gObj[aIndex].iFillShield > 0 )

  007d3	8b 84 17 3c 01
	00 00		 mov	 eax, DWORD PTR [edi+edx+316]
  007da	85 c0		 test	 eax, eax
  007dc	7e 31		 jle	 SHORT $LN61@CGUseItemR

; 13428: 			{
; 13429: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  007de	01 84 17 2c 01
	00 00		 add	 DWORD PTR [edi+edx+300], eax

; 13430: 
; 13431: 				if (  gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield )  )

  007e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007eb	8b 84 17 30 01
	00 00		 mov	 eax, DWORD PTR [edi+edx+304]
  007f2	03 84 17 34 01
	00 00		 add	 eax, DWORD PTR [edi+edx+308]
  007f9	39 84 17 2c 01
	00 00		 cmp	 DWORD PTR [edi+edx+300], eax
  00800	7e 0d		 jle	 SHORT $LN61@CGUseItemR

; 13432: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00802	89 84 17 2c 01
	00 00		 mov	 DWORD PTR [edi+edx+300], eax
  00809	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN61@CGUseItemR:

; 13433: 			}
; 13434: 
; 13435: 			gObj[aIndex].FillLife = (float)iHPGage;
; 13436: 			gObj[aIndex].FillLifeMax = (float)iHPGage;
; 13437: 			gObj[aIndex].FillLifeCount = 4;
; 13438: 			gObj[aIndex].iFillShield = iShieldGage;

  0080f	66 0f 6e 85 f0
	fe ff ff	 movd	 xmm0, DWORD PTR _iHPGage$1$[ebp]
  00817	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iShieldGage$1$[ebp]
  0081d	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 13439: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13440: 			gObj[aIndex].iFillShieldCount = 4;
; 13441: 
; 13442: 			GCSendEffectInfo(aIndex, 3);

  00820	6a 03		 push	 3
  00822	53		 push	 ebx
  00823	f3 0f 11 84 17
	e4 00 00 00	 movss	 DWORD PTR [edi+edx+228], xmm0
  0082c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00831	f3 0f 11 84 07
	e8 00 00 00	 movss	 DWORD PTR [edi+eax+232], xmm0
  0083a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0083f	c6 84 07 fb 00
	00 00 04	 mov	 BYTE PTR [edi+eax+251], 4
  00847	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0084c	89 8c 07 3c 01
	00 00		 mov	 DWORD PTR [edi+eax+316], ecx
  00853	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00858	89 8c 07 38 01
	00 00		 mov	 DWORD PTR [edi+eax+312], ecx
  0085f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00864	c7 84 07 40 01
	00 00 04 00 00
	00		 mov	 DWORD PTR [edi+eax+320], 4
  0086f	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 13443: 
; 13444: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00874	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00879	6a 01		 push	 1
  0087b	03 c7		 add	 eax, edi
  0087d	56		 push	 esi
  0087e	50		 push	 eax
  0087f	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00884	83 c4 14	 add	 esp, 20			; 00000014H
  00887	85 c0		 test	 eax, eax
  00889	75 32		 jne	 SHORT $LN62@CGUseItemR

; 13445: 			{
; 13446: 				gObjInventoryItemSet(aIndex, pos, -1);

  0088b	68 ff 00 00 00	 push	 255			; 000000ffH
  00890	56		 push	 esi
  00891	53		 push	 ebx
  00892	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13447: 				gObj[aIndex].pInventory[pos].Clear();

  00897	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0089c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0089f	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  008a6	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  008ac	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13448: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  008b1	6a 01		 push	 1
  008b3	56		 push	 esi
  008b4	53		 push	 ebx
  008b5	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  008ba	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN62@CGUseItemR:

; 13449: 			}
; 13450: 
; 13451: 			LogAddTD("[%s][%s]Use Compound Potion Lv2 - SD[%d] HP[%f] -> SD[%d] HP[%f]",

  008bd	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iHPGage$1$[ebp]
  008c3	83 ec 08	 sub	 esp, 8
  008c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008cc	66 0f 6e d0	 movd	 xmm2, eax
  008d0	f3 0f 10 8c 17
	d8 00 00 00	 movss	 xmm1, DWORD PTR [edi+edx+216]
  008d9	8b 8c 17 2c 01
	00 00		 mov	 ecx, DWORD PTR [edi+edx+300]
  008e0	0f 28 c1	 movaps	 xmm0, xmm1
  008e3	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _iShieldGage$1$[ebp]
  008e9	0f 5b d2	 cvtdq2ps xmm2, xmm2
  008ec	03 c1		 add	 eax, ecx
  008ee	f3 0f 58 c2	 addss	 xmm0, xmm2
  008f2	0f 5a c0	 cvtps2pd xmm0, xmm0
  008f5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  008fa	50		 push	 eax
  008fb	0f 5a c1	 cvtps2pd xmm0, xmm1
  008fe	83 ec 08	 sub	 esp, 8
  00901	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00904	03 c7		 add	 eax, edi
  00906	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0090b	51		 push	 ecx
  0090c	50		 push	 eax
  0090d	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  00910	03 c7		 add	 eax, edi
  00912	50		 push	 eax
  00913	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@KBGNKHHK@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv2?5@
  00918	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0091e	83 c4 24	 add	 esp, 36			; 00000024H
  00921	5f		 pop	 edi
  00922	5e		 pop	 esi
  00923	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  00924	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00927	33 cd		 xor	 ecx, ebp
  00929	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0092e	8b e5		 mov	 esp, ebp
  00930	5d		 pop	 ebp
  00931	c3		 ret	 0
$LN55@CGUseItemR:

; 13452: 				gObj[aIndex].AccountID, gObj[aIndex].Name, 
; 13453: 				gObj[aIndex].iShield, gObj[aIndex].Life,
; 13454: 				gObj[aIndex].iShield+iShieldGage, (double)(gObj[aIndex].Life+(float)iHPGage));
; 13455: 		}
; 13456: 		else if ( citem->m_Type == ITEMGET(14,40) )	// Large Compound Potion 

  00932	b8 28 1c 00 00	 mov	 eax, 7208		; 00001c28H
  00937	66 3b d0	 cmp	 dx, ax
  0093a	0f 85 42 02 00
	00		 jne	 $LN63@CGUseItemR

; 13457: 		{
; 13458: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 20/100;	// #formula

  00940	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00946	89 8d e8 fe ff
	ff		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$6[ebp], ecx
  0094c	8b 84 0f 34 01
	00 00		 mov	 eax, DWORD PTR [edi+ecx+308]
  00953	03 84 0f 30 01
	00 00		 add	 eax, DWORD PTR [edi+ecx+304]
  0095a	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0095d	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00962	c1 e1 02	 shl	 ecx, 2
  00965	f7 e9		 imul	 ecx
  00967	c1 fa 05	 sar	 edx, 5
  0096a	8b c2		 mov	 eax, edx
  0096c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0096f	03 c2		 add	 eax, edx

; 13459: 			int iHPGage = (int)((gObj[aIndex].MaxLife + gObj[aIndex].AddLife) * 45.0f / 100.0f );	// #formula

  00971	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$6[ebp]
  00977	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iShieldGage$1$[ebp], eax

; 13460: 
; 13461: 			if ( gObj[aIndex].iShield < 0 )

  0097d	83 bc 17 2c 01
	00 00 00	 cmp	 DWORD PTR [edi+edx+300], 0
  00985	66 0f 6e 84 17
	24 01 00 00	 movd	 xmm0, DWORD PTR [edi+edx+292]
  0098e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00991	f3 0f 58 84 17
	dc 00 00 00	 addss	 xmm0, DWORD PTR [edi+edx+220]
  0099a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42340000
  009a2	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  009aa	f3 0f 2c c0	 cvttss2si eax, xmm0
  009ae	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iHPGage$1$[ebp], eax
  009b4	7d 11		 jge	 SHORT $LN65@CGUseItemR

; 13462: 				gObj[aIndex].iShield = 0;

  009b6	c7 84 17 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+edx+300], 0
  009c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN65@CGUseItemR:

; 13463: 
; 13464: 			if ( gObj[aIndex].FillLife > 0.0f )

  009c7	f3 0f 10 84 17
	e4 00 00 00	 movss	 xmm0, DWORD PTR [edi+edx+228]
  009d0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  009d7	76 4a		 jbe	 SHORT $LN67@CGUseItemR

; 13465: 			{
; 13466: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  009d9	f3 0f 58 84 17
	d8 00 00 00	 addss	 xmm0, DWORD PTR [edi+edx+216]
  009e2	f3 0f 11 84 17
	d8 00 00 00	 movss	 DWORD PTR [edi+edx+216], xmm0

; 13467: 
; 13468: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife + gObj[aIndex].AddLife ) )

  009eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009f1	66 0f 6e 8c 17
	24 01 00 00	 movd	 xmm1, DWORD PTR [edi+edx+292]
  009fa	f3 0f 10 84 17
	d8 00 00 00	 movss	 xmm0, DWORD PTR [edi+edx+216]
  00a03	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00a06	f3 0f 58 8c 17
	dc 00 00 00	 addss	 xmm1, DWORD PTR [edi+edx+220]
  00a0f	0f 2f c1	 comiss	 xmm0, xmm1
  00a12	76 0f		 jbe	 SHORT $LN67@CGUseItemR

; 13469: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  00a14	f3 0f 11 8c 17
	d8 00 00 00	 movss	 DWORD PTR [edi+edx+216], xmm1
  00a1d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN67@CGUseItemR:

; 13470: 			}
; 13471: 
; 13472: 			if ( gObj[aIndex].iFillShield > 0 )

  00a23	8b 84 17 3c 01
	00 00		 mov	 eax, DWORD PTR [edi+edx+316]
  00a2a	85 c0		 test	 eax, eax
  00a2c	7e 31		 jle	 SHORT $LN69@CGUseItemR

; 13473: 			{
; 13474: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  00a2e	01 84 17 2c 01
	00 00		 add	 DWORD PTR [edi+edx+300], eax

; 13475: 
; 13476: 				if (  gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield )  )

  00a35	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a3b	8b 84 17 30 01
	00 00		 mov	 eax, DWORD PTR [edi+edx+304]
  00a42	03 84 17 34 01
	00 00		 add	 eax, DWORD PTR [edi+edx+308]
  00a49	39 84 17 2c 01
	00 00		 cmp	 DWORD PTR [edi+edx+300], eax
  00a50	7e 0d		 jle	 SHORT $LN69@CGUseItemR

; 13477: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00a52	89 84 17 2c 01
	00 00		 mov	 DWORD PTR [edi+edx+300], eax
  00a59	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN69@CGUseItemR:

; 13478: 			}
; 13479: 
; 13480: 			gObj[aIndex].FillLife = (float)iHPGage;
; 13481: 			gObj[aIndex].FillLifeMax = (float)iHPGage;
; 13482: 			gObj[aIndex].FillLifeCount = 4;
; 13483: 			gObj[aIndex].iFillShield = iShieldGage;

  00a5f	66 0f 6e 85 f0
	fe ff ff	 movd	 xmm0, DWORD PTR _iHPGage$1$[ebp]
  00a67	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _iShieldGage$1$[ebp]
  00a6d	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 13484: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13485: 			gObj[aIndex].iFillShieldCount = 4;
; 13486: 
; 13487: 			GCSendEffectInfo(aIndex, 3);

  00a70	6a 03		 push	 3
  00a72	53		 push	 ebx
  00a73	f3 0f 11 84 17
	e4 00 00 00	 movss	 DWORD PTR [edi+edx+228], xmm0
  00a7c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a81	f3 0f 11 84 07
	e8 00 00 00	 movss	 DWORD PTR [edi+eax+232], xmm0
  00a8a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a8f	c6 84 07 fb 00
	00 00 04	 mov	 BYTE PTR [edi+eax+251], 4
  00a97	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a9c	89 8c 07 3c 01
	00 00		 mov	 DWORD PTR [edi+eax+316], ecx
  00aa3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00aa8	89 8c 07 38 01
	00 00		 mov	 DWORD PTR [edi+eax+312], ecx
  00aaf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ab4	c7 84 07 40 01
	00 00 04 00 00
	00		 mov	 DWORD PTR [edi+eax+320], 4
  00abf	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 13488: 
; 13489: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00ac4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ac9	6a 01		 push	 1
  00acb	03 c7		 add	 eax, edi
  00acd	56		 push	 esi
  00ace	50		 push	 eax
  00acf	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00ad4	83 c4 14	 add	 esp, 20			; 00000014H
  00ad7	85 c0		 test	 eax, eax
  00ad9	75 32		 jne	 SHORT $LN70@CGUseItemR

; 13490: 			{
; 13491: 				gObjInventoryItemSet(aIndex, pos, -1);

  00adb	68 ff 00 00 00	 push	 255			; 000000ffH
  00ae0	56		 push	 esi
  00ae1	53		 push	 ebx
  00ae2	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13492: 				gObj[aIndex].pInventory[pos].Clear();

  00ae7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00aec	83 c4 0c	 add	 esp, 12			; 0000000cH
  00aef	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  00af6	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  00afc	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13493: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00b01	6a 01		 push	 1
  00b03	56		 push	 esi
  00b04	53		 push	 ebx
  00b05	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00b0a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN70@CGUseItemR:

; 13494: 			}
; 13495: 
; 13496: 			LogAddTD("[%s][%s]Use Compound Potion Lv3 - SD[%d] HP[%f] -> SD[%d] HP[%f]",

  00b0d	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iHPGage$1$[ebp]
  00b13	83 ec 08	 sub	 esp, 8
  00b16	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b1c	66 0f 6e d0	 movd	 xmm2, eax
  00b20	f3 0f 10 8c 17
	d8 00 00 00	 movss	 xmm1, DWORD PTR [edi+edx+216]
  00b29	8b 8c 17 2c 01
	00 00		 mov	 ecx, DWORD PTR [edi+edx+300]
  00b30	0f 28 c1	 movaps	 xmm0, xmm1
  00b33	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _iShieldGage$1$[ebp]
  00b39	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00b3c	03 c1		 add	 eax, ecx
  00b3e	f3 0f 58 c2	 addss	 xmm0, xmm2
  00b42	0f 5a c0	 cvtps2pd xmm0, xmm0
  00b45	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00b4a	50		 push	 eax
  00b4b	0f 5a c1	 cvtps2pd xmm0, xmm1
  00b4e	83 ec 08	 sub	 esp, 8
  00b51	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00b54	03 c7		 add	 eax, edi
  00b56	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00b5b	51		 push	 ecx
  00b5c	50		 push	 eax
  00b5d	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  00b60	03 c7		 add	 eax, edi
  00b62	50		 push	 eax
  00b63	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@GOPDLALC@?$FL?$CFs?$FN?$FL?$CFs?$FNUse?5Compound?5Potion?5Lv3?5@
  00b68	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b6e	83 c4 24	 add	 esp, 36			; 00000024H
  00b71	5f		 pop	 edi
  00b72	5e		 pop	 esi
  00b73	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  00b74	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b77	33 cd		 xor	 ecx, ebp
  00b79	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b7e	8b e5		 mov	 esp, ebp
  00b80	5d		 pop	 ebp
  00b81	c3		 ret	 0
$LN63@CGUseItemR:

; 13497: 				gObj[aIndex].AccountID, gObj[aIndex].Name, 
; 13498: 				gObj[aIndex].iShield, gObj[aIndex].Life,
; 13499: 				gObj[aIndex].iShield+iShieldGage, (double)(gObj[aIndex].Life+(float)iHPGage));
; 13500: 		}
; 13501: 		else if ( citem->m_Type == ITEMGET(14,35) )

  00b82	b8 23 1c 00 00	 mov	 eax, 7203		; 00001c23H
  00b87	66 3b d0	 cmp	 dx, ax
  00b8a	75 1f		 jne	 SHORT $LN71@CGUseItemR

; 13502: 		{
; 13503: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 25 / 100;	// #formula

  00b8c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b92	89 8d e8 fe ff
	ff		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$4[ebp], ecx
  00b98	8b 84 0f 34 01
	00 00		 mov	 eax, DWORD PTR [edi+ecx+308]
  00b9f	03 84 0f 30 01
	00 00		 add	 eax, DWORD PTR [edi+ecx+304]
  00ba6	6b c8 19	 imul	 ecx, eax, 25

; 13504: 
; 13505: 			if ( gObj[aIndex].iShield < 0 )
; 13506: 				gObj[aIndex].iShield = 0;
; 13507: 
; 13508: 			if ( gObj[aIndex].iFillShield > 0 )
; 13509: 			{
; 13510: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;
; 13511: 
; 13512: 				if ( gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 13513: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 13514: 			}
; 13515: 
; 13516: 			gObj[aIndex].iFillShieldCount = 2;
; 13517: 			gObj[aIndex].iFillShield = iShieldGage;
; 13518: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13519: 
; 13520: 			GCSendEffectInfo(aIndex, 3);
; 13521: 
; 13522: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )
; 13523: 			{
; 13524: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13525: 				gObj[aIndex].pInventory[pos].Clear();
; 13526: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13527: 			}
; 13528: 		}

  00ba9	eb 54		 jmp	 SHORT $LN373@CGUseItemR
$LN71@CGUseItemR:

; 13529: 		else if ( citem->m_Type == ITEMGET(14,36) )

  00bab	b8 24 1c 00 00	 mov	 eax, 7204		; 00001c24H
  00bb0	66 3b d0	 cmp	 dx, ax
  00bb3	75 1f		 jne	 SHORT $LN77@CGUseItemR

; 13530: 		{
; 13531: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 35 / 100;	// #formula

  00bb5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bbb	89 8d e8 fe ff
	ff		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$2[ebp], ecx
  00bc1	8b 84 0f 34 01
	00 00		 mov	 eax, DWORD PTR [edi+ecx+308]
  00bc8	03 84 0f 30 01
	00 00		 add	 eax, DWORD PTR [edi+ecx+304]
  00bcf	6b c8 23	 imul	 ecx, eax, 35

; 13532: 
; 13533: 			if ( gObj[aIndex].iShield < 0 )
; 13534: 				gObj[aIndex].iShield = 0;
; 13535: 
; 13536: 			if ( gObj[aIndex].iFillShield > 0 )
; 13537: 			{
; 13538: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;
; 13539: 
; 13540: 				if ( gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )
; 13541: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;
; 13542: 			}
; 13543: 
; 13544: 			gObj[aIndex].iFillShieldCount = 2;
; 13545: 			gObj[aIndex].iFillShield = iShieldGage;
; 13546: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13547: 
; 13548: 			GCSendEffectInfo(aIndex, 3);
; 13549: 
; 13550: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )
; 13551: 			{
; 13552: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13553: 				gObj[aIndex].pInventory[pos].Clear();
; 13554: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13555: 			}
; 13556: 		}

  00bd2	eb 2b		 jmp	 SHORT $LN373@CGUseItemR
$LN77@CGUseItemR:

; 13557: 		else if ( citem->m_Type == ITEMGET(14,37) )

  00bd4	b8 25 1c 00 00	 mov	 eax, 7205		; 00001c25H
  00bd9	66 3b d0	 cmp	 dx, ax
  00bdc	0f 85 da 00 00
	00		 jne	 $LN83@CGUseItemR

; 13558: 		{
; 13559: 			int iShieldGage = (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield) * 45 / 100; // #formula

  00be2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00be8	89 8d e8 fe ff
	ff		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$3[ebp], ecx
  00bee	8b 84 0f 34 01
	00 00		 mov	 eax, DWORD PTR [edi+ecx+308]
  00bf5	03 84 0f 30 01
	00 00		 add	 eax, DWORD PTR [edi+ecx+304]
  00bfc	6b c8 2d	 imul	 ecx, eax, 45
$LN373@CGUseItemR:
  00bff	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00c04	f7 e9		 imul	 ecx
  00c06	c1 fa 05	 sar	 edx, 5
  00c09	8b c2		 mov	 eax, edx
  00c0b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00c0e	03 c2		 add	 eax, edx

; 13560: 
; 13561: 			if ( gObj[aIndex].iShield < 0 )

  00c10	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$3[ebp]
  00c16	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _iShieldGage$1$[ebp], eax
  00c1c	83 bc 17 2c 01
	00 00 00	 cmp	 DWORD PTR [edi+edx+300], 0
  00c24	7d 11		 jge	 SHORT $LN85@CGUseItemR

; 13562: 				gObj[aIndex].iShield = 0;

  00c26	c7 84 17 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+edx+300], 0
  00c31	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN85@CGUseItemR:

; 13563: 
; 13564: 			if ( gObj[aIndex].iFillShield > 0 )

  00c37	8b 84 17 3c 01
	00 00		 mov	 eax, DWORD PTR [edi+edx+316]
  00c3e	85 c0		 test	 eax, eax
  00c40	7e 31		 jle	 SHORT $LN87@CGUseItemR

; 13565: 			{
; 13566: 				gObj[aIndex].iShield += gObj[aIndex].iFillShield;

  00c42	01 84 17 2c 01
	00 00		 add	 DWORD PTR [edi+edx+300], eax

; 13567: 
; 13568: 				if ( gObj[aIndex].iShield > (gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield ) )

  00c49	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c4f	8b 84 17 30 01
	00 00		 mov	 eax, DWORD PTR [edi+edx+304]
  00c56	03 84 17 34 01
	00 00		 add	 eax, DWORD PTR [edi+edx+308]
  00c5d	39 84 17 2c 01
	00 00		 cmp	 DWORD PTR [edi+edx+300], eax
  00c64	7e 0d		 jle	 SHORT $LN87@CGUseItemR

; 13569: 					gObj[aIndex].iShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00c66	89 84 17 2c 01
	00 00		 mov	 DWORD PTR [edi+edx+300], eax
  00c6d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN87@CGUseItemR:

; 13570: 			}
; 13571: 
; 13572: 			gObj[aIndex].iFillShieldCount = 2;
; 13573: 			gObj[aIndex].iFillShield = iShieldGage;

  00c73	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR _iShieldGage$1$[ebp]
  00c79	c7 84 17 40 01
	00 00 02 00 00
	00		 mov	 DWORD PTR [edi+edx+320], 2
  00c84	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13574: 			gObj[aIndex].iFillShieldMax = iShieldGage;
; 13575: 
; 13576: 			GCSendEffectInfo(aIndex, 3);

  00c89	6a 03		 push	 3
  00c8b	53		 push	 ebx
  00c8c	89 8c 07 3c 01
	00 00		 mov	 DWORD PTR [edi+eax+316], ecx
  00c93	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c98	89 8c 07 38 01
	00 00		 mov	 DWORD PTR [edi+eax+312], ecx
  00c9f	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo

; 13577: 
; 13578: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00ca4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ca9	6a 01		 push	 1
  00cab	03 c7		 add	 eax, edi
  00cad	56		 push	 esi
  00cae	50		 push	 eax
  00caf	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00cb4	83 c4 14	 add	 esp, 20			; 00000014H

; 13579: 			{
; 13580: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13581: 				gObj[aIndex].pInventory[pos].Clear();
; 13582: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13583: 			}
; 13584: 		}

  00cb7	e9 07 1d 00 00	 jmp	 $LN351@CGUseItemR
$LN83@CGUseItemR:

; 13585: 		else if ( citem->m_Type == ITEMGET(14,8) ) // Antidote

  00cbc	b8 08 1c 00 00	 mov	 eax, 7176		; 00001c08H
  00cc1	66 3b d0	 cmp	 dx, ax
  00cc4	0f 85 e6 00 00
	00		 jne	 $LN89@CGUseItemR

; 13586: 		{
; 13587: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00cca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ccf	6a 01		 push	 1
  00cd1	03 c7		 add	 eax, edi
  00cd3	56		 push	 esi
  00cd4	50		 push	 eax
  00cd5	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00cda	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cdd	85 c0		 test	 eax, eax
  00cdf	75 32		 jne	 SHORT $LN91@CGUseItemR

; 13588: 			{
; 13589: 				gObjInventoryItemSet(aIndex, pos, -1);

  00ce1	68 ff 00 00 00	 push	 255			; 000000ffH
  00ce6	56		 push	 esi
  00ce7	53		 push	 ebx
  00ce8	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13590: 				gObj[aIndex].pInventory[pos].Clear();

  00ced	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cf2	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cf5	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  00cfc	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  00d02	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13591: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00d07	6a 01		 push	 1
  00d09	56		 push	 esi
  00d0a	53		 push	 ebx
  00d0b	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00d10	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN91@CGUseItemR:

; 13592: 			}
; 13593: 			
; 13594: 			if ( gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_POISON) == TRUE )

  00d13	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d18	03 c7		 add	 eax, edi
  00d1a	6a 37		 push	 55			; 00000037H
  00d1c	50		 push	 eax
  00d1d	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00d22	83 c4 08	 add	 esp, 8
  00d25	3c 01		 cmp	 al, 1

; 13595: 			{
; 13596: 				gObjRemoveBuffEffect(&gObj[aIndex],BUFF_POISON);

  00d27	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d2c	75 0e		 jne	 SHORT $LN92@CGUseItemR
  00d2e	03 c7		 add	 eax, edi
  00d30	6a 37		 push	 55			; 00000037H
  00d32	50		 push	 eax
  00d33	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 13597: 				gObj[aIndex].lpAttackObj = NULL;
; 13598: 				GCMagicCancelSend(&gObj[aIndex],1);

  00d38	6a 01		 push	 1
  00d3a	eb 43		 jmp	 SHORT $LN365@CGUseItemR
$LN92@CGUseItemR:

; 13599: 			}
; 13600: 			else if ( gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_DEFENSEDOWN) == TRUE )

  00d3c	03 c7		 add	 eax, edi
  00d3e	6a 3a		 push	 58			; 0000003aH
  00d40	50		 push	 eax
  00d41	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00d46	83 c4 08	 add	 esp, 8
  00d49	3c 01		 cmp	 al, 1
  00d4b	0f 85 0a 1d 00
	00		 jne	 $LN16@CGUseItemR

; 13601: 			{
; 13602: 				gObjRemoveBuffEffect(&gObj[aIndex],BUFF_DEFENSEDOWN);

  00d51	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d56	03 c7		 add	 eax, edi
  00d58	6a 3a		 push	 58			; 0000003aH
  00d5a	50		 push	 eax
  00d5b	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 13603: 				gObj[aIndex].DelayActionTime = 0;

  00d60	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 13606: 				GCMagicCancelSend(&gObj[aIndex], 7);

  00d65	6a 07		 push	 7
  00d67	c7 84 07 a4 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax+1444], 0
  00d72	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d77	c6 84 07 a8 05
	00 00 00	 mov	 BYTE PTR [edi+eax+1448], 0
$LN365@CGUseItemR:

; 13604: 				gObj[aIndex].DelayLevel = 0;
; 13605: 				gObj[aIndex].lpAttackObj = NULL;

  00d7f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d84	c7 84 07 b4 05
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax+1460], 0

; 13606: 				GCMagicCancelSend(&gObj[aIndex], 7);

  00d8f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d94	03 c7		 add	 eax, edi
  00d96	50		 push	 eax
  00d97	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GCMagicCancelSend
  00d9c	83 c4 10	 add	 esp, 16			; 00000010H
  00d9f	5f		 pop	 edi
  00da0	5e		 pop	 esi
  00da1	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  00da2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00da5	33 cd		 xor	 ecx, ebp
  00da7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00dac	8b e5		 mov	 esp, ebp
  00dae	5d		 pop	 ebp
  00daf	c3		 ret	 0
$LN89@CGUseItemR:

; 13607: 			}
; 13608: 		}
; 13609: 		else if ( citem->m_Type == ITEMGET(14,46) )

  00db0	b8 2e 1c 00 00	 mov	 eax, 7214		; 00001c2eH
  00db5	66 3b d0	 cmp	 dx, ax
  00db8	75 50		 jne	 SHORT $LN95@CGUseItemR

; 13610: 		{
; 13611: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00dba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00dbf	6a 01		 push	 1
  00dc1	03 c7		 add	 eax, edi
  00dc3	56		 push	 esi
  00dc4	50		 push	 eax
  00dc5	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00dca	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dcd	85 c0		 test	 eax, eax
  00dcf	75 32		 jne	 SHORT $LN97@CGUseItemR

; 13612: 			{
; 13613: 				gObjInventoryItemSet(aIndex, pos, -1);

  00dd1	68 ff 00 00 00	 push	 255			; 000000ffH
  00dd6	56		 push	 esi
  00dd7	53		 push	 ebx
  00dd8	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13614: 				gObj[aIndex].pInventory[pos].Clear();

  00ddd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00de2	83 c4 0c	 add	 esp, 12			; 0000000cH
  00de5	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  00dec	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  00df2	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13615: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00df7	6a 01		 push	 1
  00df9	56		 push	 esi
  00dfa	53		 push	 ebx
  00dfb	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00e00	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN97@CGUseItemR:

; 13616: 			}
; 13617: 
; 13618: 			gObjAddBuffEffect(&gObj[aIndex],BUFF_JACK_BLESSING);

  00e03	6a 23		 push	 35			; 00000023H
  00e05	e9 3c 15 00 00	 jmp	 $LN360@CGUseItemR
$LN95@CGUseItemR:

; 13619: 		}
; 13620: 		else if ( citem->m_Type == ITEMGET(14,47) )

  00e0a	b8 2f 1c 00 00	 mov	 eax, 7215		; 00001c2fH
  00e0f	66 3b d0	 cmp	 dx, ax
  00e12	75 50		 jne	 SHORT $LN98@CGUseItemR

; 13621: 		{
; 13622: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00e14	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e19	6a 01		 push	 1
  00e1b	03 c7		 add	 eax, edi
  00e1d	56		 push	 esi
  00e1e	50		 push	 eax
  00e1f	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00e24	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e27	85 c0		 test	 eax, eax
  00e29	75 32		 jne	 SHORT $LN100@CGUseItemR

; 13623: 			{
; 13624: 				gObjInventoryItemSet(aIndex, pos, -1);

  00e2b	68 ff 00 00 00	 push	 255			; 000000ffH
  00e30	56		 push	 esi
  00e31	53		 push	 ebx
  00e32	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13625: 				gObj[aIndex].pInventory[pos].Clear();

  00e37	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e3c	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e3f	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  00e46	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  00e4c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13626: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00e51	6a 01		 push	 1
  00e53	56		 push	 esi
  00e54	53		 push	 ebx
  00e55	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00e5a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN100@CGUseItemR:

; 13627: 			}
; 13628: 
; 13629: 			gObjAddBuffEffect(&gObj[aIndex],BUFF_JACK_WRATH);

  00e5d	6a 24		 push	 36			; 00000024H
  00e5f	e9 e2 14 00 00	 jmp	 $LN360@CGUseItemR
$LN98@CGUseItemR:

; 13630: 		}
; 13631: 		else if ( citem->m_Type == ITEMGET(14,48) )

  00e64	b8 30 1c 00 00	 mov	 eax, 7216		; 00001c30H
  00e69	66 3b d0	 cmp	 dx, ax
  00e6c	75 50		 jne	 SHORT $LN101@CGUseItemR

; 13632: 		{
; 13633: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00e6e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e73	6a 01		 push	 1
  00e75	03 c7		 add	 eax, edi
  00e77	56		 push	 esi
  00e78	50		 push	 eax
  00e79	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00e7e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e81	85 c0		 test	 eax, eax
  00e83	75 32		 jne	 SHORT $LN103@CGUseItemR

; 13634: 			{
; 13635: 				gObjInventoryItemSet(aIndex, pos, -1);

  00e85	68 ff 00 00 00	 push	 255			; 000000ffH
  00e8a	56		 push	 esi
  00e8b	53		 push	 ebx
  00e8c	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13636: 				gObj[aIndex].pInventory[pos].Clear();

  00e91	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00e96	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e99	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  00ea0	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  00ea6	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13637: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00eab	6a 01		 push	 1
  00ead	56		 push	 esi
  00eae	53		 push	 ebx
  00eaf	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00eb4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN103@CGUseItemR:

; 13638: 			}
; 13639: 
; 13640: 			gObjAddBuffEffect(&gObj[aIndex],BUFF_JACK_CRY);

  00eb7	6a 25		 push	 37			; 00000025H
  00eb9	e9 88 14 00 00	 jmp	 $LN360@CGUseItemR
$LN101@CGUseItemR:

; 13641: 		}
; 13642: 		else if ( citem->m_Type == ITEMGET(14,49) )

  00ebe	b8 31 1c 00 00	 mov	 eax, 7217		; 00001c31H
  00ec3	66 3b d0	 cmp	 dx, ax
  00ec6	75 50		 jne	 SHORT $LN104@CGUseItemR

; 13643: 		{
; 13644: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00ec8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ecd	6a 01		 push	 1
  00ecf	03 c7		 add	 eax, edi
  00ed1	56		 push	 esi
  00ed2	50		 push	 eax
  00ed3	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00ed8	83 c4 0c	 add	 esp, 12			; 0000000cH
  00edb	85 c0		 test	 eax, eax
  00edd	75 32		 jne	 SHORT $LN106@CGUseItemR

; 13645: 			{
; 13646: 				gObjInventoryItemSet(aIndex, pos, -1);

  00edf	68 ff 00 00 00	 push	 255			; 000000ffH
  00ee4	56		 push	 esi
  00ee5	53		 push	 ebx
  00ee6	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13647: 				gObj[aIndex].pInventory[pos].Clear();

  00eeb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ef0	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ef3	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  00efa	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  00f00	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13648: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00f05	6a 01		 push	 1
  00f07	56		 push	 esi
  00f08	53		 push	 ebx
  00f09	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00f0e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN106@CGUseItemR:

; 13649: 			}
; 13650: 
; 13651: 			gObjAddBuffEffect(&gObj[aIndex],BUFF_JACK_FOOD);

  00f11	6a 26		 push	 38			; 00000026H
  00f13	e9 2e 14 00 00	 jmp	 $LN360@CGUseItemR
$LN104@CGUseItemR:

; 13652: 		}
; 13653: 		else if ( citem->m_Type == ITEMGET(14,50) )

  00f18	b8 32 1c 00 00	 mov	 eax, 7218		; 00001c32H
  00f1d	66 3b d0	 cmp	 dx, ax
  00f20	75 50		 jne	 SHORT $LN107@CGUseItemR

; 13654: 		{
; 13655: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  00f22	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f27	6a 01		 push	 1
  00f29	03 c7		 add	 eax, edi
  00f2b	56		 push	 esi
  00f2c	50		 push	 eax
  00f2d	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  00f32	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f35	85 c0		 test	 eax, eax
  00f37	75 32		 jne	 SHORT $LN109@CGUseItemR

; 13656: 			{
; 13657: 				gObjInventoryItemSet(aIndex, pos, -1);

  00f39	68 ff 00 00 00	 push	 255			; 000000ffH
  00f3e	56		 push	 esi
  00f3f	53		 push	 ebx
  00f40	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13658: 				gObj[aIndex].pInventory[pos].Clear();

  00f45	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f4a	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f4d	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  00f54	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  00f5a	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13659: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  00f5f	6a 01		 push	 1
  00f61	56		 push	 esi
  00f62	53		 push	 ebx
  00f63	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00f68	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN109@CGUseItemR:

; 13660: 			}
; 13661: 
; 13662: 			gObjAddBuffEffect(&gObj[aIndex],BUFF_JACK_DRINK);

  00f6b	6a 27		 push	 39			; 00000027H
  00f6d	e9 d4 13 00 00	 jmp	 $LN360@CGUseItemR
$LN107@CGUseItemR:

; 13663: 		}
; 13664: 		else if ( citem->m_Type == ITEMGET(14,63) || citem->m_Type == ITEMGET(14,64) )

  00f72	b8 3f 1c 00 00	 mov	 eax, 7231		; 00001c3fH
  00f77	66 3b d0	 cmp	 dx, ax
  00f7a	0f 84 0a 16 00
	00		 je	 $LN112@CGUseItemR
  00f80	b8 40 1c 00 00	 mov	 eax, 7232		; 00001c40H
  00f85	66 3b d0	 cmp	 dx, ax
  00f88	0f 84 fc 15 00
	00		 je	 $LN112@CGUseItemR

; 13685: 		else if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonySmeltingItems(citem->m_Type) == TRUE )

  00f8e	52		 push	 edx
  00f8f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00f94	e8 00 00 00 00	 call	 ?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
  00f99	83 f8 01	 cmp	 eax, 1
  00f9c	75 7f		 jne	 SHORT $LN116@CGUseItemR

; 13686: 		{
; 13687: 			if ( g_kJewelOfHarmonySystem.SmeltItemBySmeltingStone(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  00f9e	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00fa4	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00fa8	50		 push	 eax
  00fa9	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00fad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00fb2	50		 push	 eax
  00fb3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fb8	03 c7		 add	 eax, edi
  00fba	50		 push	 eax
  00fbb	e8 00 00 00 00	 call	 ?SmeltItemBySmeltingStone@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@HH@Z ; CJewelOfHarmonySystem::SmeltItemBySmeltingStone
$LN366@CGUseItemR:
  00fc0	83 f8 01	 cmp	 eax, 1
  00fc3	0f 85 1e f4 ff
	ff		 jne	 $LN355@CGUseItemR

; 13688: 			{
; 13689: 				gObjInventoryItemSet(aIndex, pos, -1);

  00fc9	68 ff 00 00 00	 push	 255			; 000000ffH
  00fce	56		 push	 esi
  00fcf	53		 push	 ebx
  00fd0	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13690: 				gObj[aIndex].pInventory[pos].Clear();

  00fd5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fda	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fdd	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  00fe4	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  00fea	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13691: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);

  00fef	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00ff5	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00ff9	50		 push	 eax
  00ffa	53		 push	 ebx
  00ffb	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend

; 13692: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  01000	6a 01		 push	 1
  01002	56		 push	 esi
  01003	53		 push	 ebx
  01004	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 13984: 				gObjUseDrink(&gObj[aIndex], 2);

  01009	83 c4 14	 add	 esp, 20			; 00000014H
  0100c	5f		 pop	 edi
  0100d	5e		 pop	 esi
  0100e	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  0100f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01012	33 cd		 xor	 ecx, ebp
  01014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01019	8b e5		 mov	 esp, ebp
  0101b	5d		 pop	 ebp
  0101c	c3		 ret	 0
$LN116@CGUseItemR:

; 13693: 			}
; 13694: 			else
; 13695: 			{
; 13696: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13697: 			}
; 13698: 		}
; 13699: 		else if ( citem->m_Type == ITEMGET(12,30) ) // Pack of Bless

  0101d	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
  01023	b9 1e 18 00 00	 mov	 ecx, 6174		; 0000181eH
  01028	0f b7 40 06	 movzx	 eax, WORD PTR [eax+6]
  0102c	66 3b c1	 cmp	 ax, cx
  0102f	75 25		 jne	 SHORT $LN120@CGUseItemR

; 13700: 		{
; 13701: 			if ( gObjItemLevelUpPickAxe(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  01031	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  01037	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  0103b	50		 push	 eax
  0103c	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  01040	50		 push	 eax
  01041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01046	03 c7		 add	 eax, edi
  01048	50		 push	 eax
  01049	e8 00 00 00 00	 call	 ?gObjItemLevelUpPickAxe@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemLevelUpPickAxe
  0104e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13702: 			{
; 13703: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13704: 				gObj[aIndex].pInventory[pos].Clear();
; 13705: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 13706: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13707: 			}
; 13708: 			else

  01051	e9 6a ff ff ff	 jmp	 $LN366@CGUseItemR
$LN120@CGUseItemR:

; 13709: 			{
; 13710: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13711: 			}
; 13712: 		}
; 13713: #if( ENABLETEST_ITEMUPGRADEJEWELS == 1 )
; 13714: 		else if( g_ItemUpgradeJewels.IsJewel(citem->m_Type) )

  01056	98		 cwde
  01057	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemUpgradeJewels@@3VItemUpgradeJewels@@A ; g_ItemUpgradeJewels
  0105c	50		 push	 eax
  0105d	e8 00 00 00 00	 call	 ?IsJewel@ItemUpgradeJewels@@QAE_NH@Z ; ItemUpgradeJewels::IsJewel
  01062	84 c0		 test	 al, al
  01064	74 33		 je	 SHORT $LN124@CGUseItemR

; 13715: 		{
; 13716: 			g_ItemUpgradeJewels.ProcInsert(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget);

  01066	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  0106c	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  01070	50		 push	 eax
  01071	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  01075	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemUpgradeJewels@@3VItemUpgradeJewels@@A ; g_ItemUpgradeJewels
  0107a	50		 push	 eax
  0107b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01080	03 c7		 add	 eax, edi
  01082	50		 push	 eax
  01083	e8 00 00 00 00	 call	 ?ProcInsert@ItemUpgradeJewels@@QAEXPAUOBJECTSTRUCT@@HH@Z ; ItemUpgradeJewels::ProcInsert
  01088	5f		 pop	 edi
  01089	5e		 pop	 esi
  0108a	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  0108b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0108e	33 cd		 xor	 ecx, ebp
  01090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01095	8b e5		 mov	 esp, ebp
  01097	5d		 pop	 ebp
  01098	c3		 ret	 0
$LN124@CGUseItemR:

; 13717: 		}
; 13718: #else
; 13719: 		else if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyPurity(citem->m_Type) == TRUE )
; 13720: 		{
; 13721: 			if ( g_kJewelOfHarmonySystem.StrengthenItemByJewelOfHarmony(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 13722: 			{
; 13723: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13724: 				gObj[aIndex].pInventory[pos].Clear();
; 13725: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 13726: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13727: 			}
; 13728: 			else
; 13729: 			{
; 13730: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13731: 			}
; 13732: 		}
; 13733: 		else if ( citem->m_Type == ITEMGET(14,13) ) // Jewel Of Bless
; 13734: 		{
; 13735: 			if ( gObjItemLevelUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 13736: 			{
; 13737: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13738: 				gObj[aIndex].pInventory[pos].Clear();
; 13739: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 13740: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13741: 			}
; 13742: 			else
; 13743: 			{
; 13744: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13745: 			}
; 13746: 		}
; 13747: 		else if ( citem->m_Type == ITEMGET(14,14) ) // Jewel Of Soul
; 13748: 		{
; 13749: 			if ( gObjItemRandomLevelUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 13750: 			{
; 13751: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13752: 				gObj[aIndex].pInventory[pos].Clear();
; 13753: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 13754: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13755: 			}
; 13756: 			else
; 13757: 			{
; 13758: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13759: 			}
; 13760: 		}
; 13761: 		else if ( citem->m_Type == ITEMGET(14,16) ) // Jewel Of Life
; 13762: 		{
; 13763: 			if ( gObjItemRandomOption3Up(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 13764: 			{
; 13765: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13766: 				gObj[aIndex].pInventory[pos].Clear();
; 13767: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 13768: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13769: 			}
; 13770: 			else
; 13771: 			{
; 13772: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13773: 			}
; 13774: 		}
; 13775: #endif
; 13776: 		else if ( citem->m_Type >= ITEMGET(15,0) ||
; 13777: 				  citem->m_Type == ITEMGET(12,7) ||
; 13778: 				 (citem->m_Type >= ITEMGET(12,8) && citem->m_Type <= ITEMGET(12,24) ) ||	// Orbs
; 13779: 				  citem->m_Type == ITEMGET(12,35) ||
; 13780: 				  citem->m_Type == ITEMGET(12,44) ||
; 13781: 				  citem->m_Type == ITEMGET(12,45) ||
; 13782: 				  citem->m_Type == ITEMGET(12,46) ||
; 13783: 				  citem->m_Type == ITEMGET(12,47) ||

  01099	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
  0109f	b9 00 1e 00 00	 mov	 ecx, 7680		; 00001e00H
  010a4	c7 85 e8 fe ff
	ff 08 18 00 00	 mov	 DWORD PTR tv743[ebp], 6152 ; 00001808H
  010ae	c7 85 f0 fe ff
	ff 18 18 00 00	 mov	 DWORD PTR tv749[ebp], 6168 ; 00001818H
  010b8	0f b7 50 06	 movzx	 edx, WORD PTR [eax+6]
  010bc	66 3b d1	 cmp	 dx, cx
  010bf	0f 8d 08 13 00
	00		 jge	 $LN128@CGUseItemR
  010c5	b9 07 18 00 00	 mov	 ecx, 6151		; 00001807H
  010ca	66 3b d1	 cmp	 dx, cx
  010cd	0f 84 fa 12 00
	00		 je	 $LN128@CGUseItemR
  010d3	66 3b 95 e8 fe
	ff ff		 cmp	 dx, WORD PTR tv743[ebp]
  010da	7c 0d		 jl	 SHORT $LN129@CGUseItemR
  010dc	66 3b 95 f0 fe
	ff ff		 cmp	 dx, WORD PTR tv749[ebp]
  010e3	0f 8e e4 12 00
	00		 jle	 $LN128@CGUseItemR
$LN129@CGUseItemR:
  010e9	b9 23 18 00 00	 mov	 ecx, 6179		; 00001823H
  010ee	66 3b d1	 cmp	 dx, cx
  010f1	0f 84 d6 12 00
	00		 je	 $LN128@CGUseItemR
  010f7	b9 2c 18 00 00	 mov	 ecx, 6188		; 0000182cH
  010fc	66 3b d1	 cmp	 dx, cx
  010ff	0f 84 c8 12 00
	00		 je	 $LN128@CGUseItemR
  01105	b9 2d 18 00 00	 mov	 ecx, 6189		; 0000182dH
  0110a	66 3b d1	 cmp	 dx, cx
  0110d	0f 84 ba 12 00
	00		 je	 $LN128@CGUseItemR
  01113	b9 2e 18 00 00	 mov	 ecx, 6190		; 0000182eH
  01118	66 3b d1	 cmp	 dx, cx
  0111b	0f 84 ac 12 00
	00		 je	 $LN128@CGUseItemR
  01121	b9 2f 18 00 00	 mov	 ecx, 6191		; 0000182fH
  01126	66 3b d1	 cmp	 dx, cx
  01129	0f 84 9e 12 00
	00		 je	 $LN128@CGUseItemR
  0112f	b9 30 18 00 00	 mov	 ecx, 6192		; 00001830H
  01134	66 3b d1	 cmp	 dx, cx
  01137	0f 84 90 12 00
	00		 je	 $LN128@CGUseItemR

; 13838: 		}
; 13839: 		else if ( citem->m_Type == ITEMGET(14,10) ) // Town Portal Scroll

  0113d	b9 0a 1c 00 00	 mov	 ecx, 7178		; 00001c0aH
  01142	66 3b d1	 cmp	 dx, cx
  01145	0f 85 74 03 00
	00		 jne	 $LN140@CGUseItemR

; 13840: 		{
; 13841: 			LogAddTD("[Using Item] [Return Scroll] [%s][%s] - Current Map:[%d]",

  0114b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01151	0f b6 84 0f 23
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+291]
  01159	50		 push	 eax
  0115a	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0115d	03 c7		 add	 eax, edi
  0115f	50		 push	 eax
  01160	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  01163	03 c7		 add	 eax, edi
  01165	50		 push	 eax
  01166	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@OLFFBGBF@?$FLUsing?5Item?$FN?5?$FLReturn?5Scroll?$FN?5?$FL?$CFs@
  0116b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 13842: 				gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].MapNumber);
; 13843: 
; 13844: 			if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) )

  01171	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01176	83 c4 10	 add	 esp, 16			; 00000010H
  01179	8a 8c 07 23 01
	00 00		 mov	 cl, BYTE PTR [edi+eax+291]
  01180	80 f9 34	 cmp	 cl, 52			; 00000034H
  01183	74 10		 je	 SHORT $LN331@CGUseItemR
  01185	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  01188	72 3b		 jb	 SHORT $LN144@CGUseItemR
  0118a	b0 11		 mov	 al, 17			; 00000011H
  0118c	3a c1		 cmp	 al, cl
  0118e	1b c0		 sbb	 eax, eax
  01190	83 c0 01	 add	 eax, 1
  01193	74 30		 je	 SHORT $LN144@CGUseItemR
$LN331@CGUseItemR:

; 13845: 			{
; 13846: 				int iBridge = g_BloodCastle.GetBridgeLevel(gObj[aIndex].MapNumber);

  01195	0f b6 c1	 movzx	 eax, cl
  01198	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0119d	50		 push	 eax
  0119e	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel

; 13847: 				if ( g_BloodCastle.GetCurrentState(iBridge) == 2 )

  011a3	50		 push	 eax
  011a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  011a9	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState

; 13848: 				{
; 13849: 					g_BloodCastle.SearchUserDropQuestItem(aIndex);

  011ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  011b3	53		 push	 ebx
  011b4	83 f8 02	 cmp	 eax, 2
  011b7	75 07		 jne	 SHORT $LN143@CGUseItemR
  011b9	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem

; 13850: 				}
; 13851: 				else

  011be	eb 05		 jmp	 SHORT $LN144@CGUseItemR
$LN143@CGUseItemR:

; 13852: 				{
; 13853: 					g_BloodCastle.SearchUserDeleteQuestItem(aIndex);

  011c0	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN144@CGUseItemR:

; 13854: 				}
; 13855: 			}
; 13856: 
; 13857: 			if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) )

  011c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  011ca	8a 8c 07 23 01
	00 00		 mov	 cl, BYTE PTR [edi+eax+291]
  011d1	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  011d4	72 17		 jb	 SHORT $LN145@CGUseItemR
  011d6	b0 32		 mov	 al, 50			; 00000032H
  011d8	3a c1		 cmp	 al, cl
  011da	1b c0		 sbb	 eax, eax
  011dc	83 c0 01	 add	 eax, 1
  011df	74 0c		 je	 SHORT $LN145@CGUseItemR

; 13858: 			{
; 13859: 				g_IllusionTemple.DropRelic(gObj[aIndex].MapNumber,aIndex);

  011e1	53		 push	 ebx
  011e2	51		 push	 ecx
  011e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  011e8	e8 00 00 00 00	 call	 ?DropRelic@CIllusionTempleEvent@@QAEXEH@Z ; CIllusionTempleEvent::DropRelic
$LN145@CGUseItemR:

; 13860: 			}
; 13861: 
; 13862: 			if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 3 )

  011ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  011f3	8b 84 0f b8 11
	00 00		 mov	 eax, DWORD PTR [edi+ecx+4536]
  011fa	a8 03		 test	 al, 3
  011fc	74 34		 je	 SHORT $LN146@CGUseItemR
  011fe	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  01203	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  01208	75 28		 jne	 SHORT $LN146@CGUseItemR

; 13863: 			{
; 13864: 				gObj[aIndex].TargetShopNumber = -1;

  0120a	83 c8 ff	 or	 eax, -1
  0120d	66 89 84 0f 3a
	06 00 00	 mov	 WORD PTR [edi+ecx+1594], ax

; 13865: 				gObj[aIndex].m_IfState.type = 0;

  01215	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0121a	81 a4 07 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [edi+eax+4536], -65473 ; ffff003fH

; 13866: 				gObj[aIndex].m_IfState.use = 0;

  01225	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0122a	83 a4 07 b8 11
	00 00 fc	 and	 DWORD PTR [edi+eax+4536], -4 ; fffffffcH
$LN146@CGUseItemR:

; 13867: 			}
; 13868: 
; 13869: 			gObjInventoryItemSet(aIndex, pos, -1);

  01232	68 ff 00 00 00	 push	 255			; 000000ffH
  01237	56		 push	 esi
  01238	53		 push	 ebx
  01239	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13870: 			gObj[aIndex].pInventory[pos].Clear();

  0123e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01243	83 c4 0c	 add	 esp, 12			; 0000000cH
  01246	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  0124d	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  01253	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13871: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  01258	6a 01		 push	 1
  0125a	56		 push	 esi
  0125b	53		 push	 ebx
  0125c	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 13872: 
; 13873: 			if ( gObj[aIndex].MapNumber == MAP_INDEX_DEVIAS )

  01261	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01267	83 c4 0c	 add	 esp, 12			; 0000000cH
  0126a	03 d7		 add	 edx, edi
  0126c	8a 8a 23 01 00
	00		 mov	 cl, BYTE PTR [edx+291]
  01272	80 f9 02	 cmp	 cl, 2
  01275	0f 84 af 00 00
	00		 je	 $LN334@CGUseItemR

; 13874: 			{
; 13875: 				gObjMoveGate(aIndex, 22);
; 13876: 			}
; 13877: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_NORIA )

  0127b	80 f9 03	 cmp	 cl, 3
  0127e	0f 84 cc 00 00
	00		 je	 $LN367@CGUseItemR

; 13878: 			{
; 13879: 				gObjMoveGate(aIndex, 27);
; 13880: 			}
; 13881: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_LOSTTOWER )

  01284	80 f9 04	 cmp	 cl, 4
  01287	75 1c		 jne	 SHORT $LN151@CGUseItemR

; 13882: 			{
; 13883: 				gObjMoveGate(aIndex, 42);

  01289	6a 2a		 push	 42			; 0000002aH
  0128b	53		 push	 ebx
  0128c	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  01291	83 c4 08	 add	 esp, 8
  01294	5f		 pop	 edi
  01295	5e		 pop	 esi
  01296	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01297	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0129a	33 cd		 xor	 ecx, ebp
  0129c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012a1	8b e5		 mov	 esp, ebp
  012a3	5d		 pop	 ebp
  012a4	c3		 ret	 0
$LN151@CGUseItemR:

; 13884: 			}
; 13885: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_ATHLANSE )

  012a5	80 f9 07	 cmp	 cl, 7
  012a8	75 1c		 jne	 SHORT $LN153@CGUseItemR

; 13886: 			{
; 13887: 				gObjMoveGate(aIndex, 49);

  012aa	6a 31		 push	 49			; 00000031H
  012ac	53		 push	 ebx
  012ad	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  012b2	83 c4 08	 add	 esp, 8
  012b5	5f		 pop	 edi
  012b6	5e		 pop	 esi
  012b7	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  012b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012bb	33 cd		 xor	 ecx, ebp
  012bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012c2	8b e5		 mov	 esp, ebp
  012c4	5d		 pop	 ebp
  012c5	c3		 ret	 0
$LN153@CGUseItemR:

; 13888: 			}
; 13889: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_TARKAN )

  012c6	80 f9 08	 cmp	 cl, 8
  012c9	75 1c		 jne	 SHORT $LN155@CGUseItemR

; 13890: 			{
; 13891: 				gObjMoveGate(aIndex, 57);

  012cb	6a 39		 push	 57			; 00000039H
  012cd	53		 push	 ebx
  012ce	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  012d3	83 c4 08	 add	 esp, 8
  012d6	5f		 pop	 edi
  012d7	5e		 pop	 esi
  012d8	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  012d9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012dc	33 cd		 xor	 ecx, ebp
  012de	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012e3	8b e5		 mov	 esp, ebp
  012e5	5d		 pop	 ebp
  012e6	c3		 ret	 0
$LN155@CGUseItemR:

; 13892: 			}
; 13893: 			else if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  012e7	80 f9 34	 cmp	 cl, 52			; 00000034H
  012ea	74 3e		 je	 SHORT $LN334@CGUseItemR
  012ec	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  012ef	72 0e		 jb	 SHORT $LN157@CGUseItemR
  012f1	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  012f6	3a c1		 cmp	 al, cl
  012f8	1b c0		 sbb	 eax, eax
  012fa	83 c0 01	 add	 eax, 1
  012fd	75 2b		 jne	 SHORT $LN334@CGUseItemR
$LN157@CGUseItemR:

; 13894: 			{
; 13895: 				gObjMoveGate(aIndex, 22);
; 13896: 			}
; 13897: 			else if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  012ff	80 f9 35	 cmp	 cl, 53			; 00000035H
  01302	74 26		 je	 SHORT $LN334@CGUseItemR
  01304	80 f9 12	 cmp	 cl, 18			; 00000012H
  01307	72 0b		 jb	 SHORT $LN159@CGUseItemR
  01309	b0 17		 mov	 al, 23			; 00000017H
  0130b	3a c1		 cmp	 al, cl
  0130d	1b c0		 sbb	 eax, eax
  0130f	83 c0 01	 add	 eax, 1
  01312	75 16		 jne	 SHORT $LN334@CGUseItemR
$LN159@CGUseItemR:

; 13898: 			{
; 13899: 				gObjMoveGate(aIndex, 22);
; 13900: 			}
; 13901: 			else if ( KALIMA_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  01314	80 f9 18	 cmp	 cl, 24			; 00000018H
  01317	72 2d		 jb	 SHORT $LN161@CGUseItemR
  01319	80 f9 1d	 cmp	 cl, 29			; 0000001dH
  0131c	76 0c		 jbe	 SHORT $LN334@CGUseItemR
  0131e	33 c0		 xor	 eax, eax
  01320	80 f9 24	 cmp	 cl, 36			; 00000024H
  01323	0f 94 c0	 sete	 al
  01326	85 c0		 test	 eax, eax
  01328	74 1c		 je	 SHORT $LN161@CGUseItemR
$LN334@CGUseItemR:

; 13902: 			{
; 13903: 				gObjMoveGate(aIndex, 22);

  0132a	6a 16		 push	 22			; 00000016H
  0132c	53		 push	 ebx
  0132d	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  01332	83 c4 08	 add	 esp, 8
  01335	5f		 pop	 edi
  01336	5e		 pop	 esi
  01337	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01338	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0133b	33 cd		 xor	 ecx, ebp
  0133d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01342	8b e5		 mov	 esp, ebp
  01344	5d		 pop	 ebp
  01345	c3		 ret	 0
$LN161@CGUseItemR:

; 13904: 			}
; 13905: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_AIDA )

  01346	80 f9 21	 cmp	 cl, 33			; 00000021H
  01349	74 05		 je	 SHORT $LN367@CGUseItemR

; 13906: 			{
; 13907: 				gObjMoveGate(aIndex, 27);
; 13908: 			}
; 13909: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE )

  0134b	80 f9 22	 cmp	 cl, 34			; 00000022H
  0134e	75 1c		 jne	 SHORT $LN165@CGUseItemR
$LN367@CGUseItemR:

; 13910: 			{
; 13911: 				gObjMoveGate(aIndex, 27);

  01350	6a 1b		 push	 27			; 0000001bH
  01352	53		 push	 ebx
  01353	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  01358	83 c4 08	 add	 esp, 8
  0135b	5f		 pop	 edi
  0135c	5e		 pop	 esi
  0135d	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  0135e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01361	33 cd		 xor	 ecx, ebp
  01363	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01368	8b e5		 mov	 esp, ebp
  0136a	5d		 pop	 ebp
  0136b	c3		 ret	 0
$LN165@CGUseItemR:

; 13912: 			}
; 13913: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_ELBELAND )

  0136c	80 f9 33	 cmp	 cl, 51			; 00000033H
  0136f	75 1f		 jne	 SHORT $LN167@CGUseItemR

; 13914: 			{
; 13915: 				gObjMoveGate(aIndex,267);

  01371	68 0b 01 00 00	 push	 267			; 0000010bH
  01376	53		 push	 ebx
  01377	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  0137c	83 c4 08	 add	 esp, 8
  0137f	5f		 pop	 edi
  01380	5e		 pop	 esi
  01381	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01382	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01385	33 cd		 xor	 ecx, ebp
  01387	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0138c	8b e5		 mov	 esp, ebp
  0138e	5d		 pop	 ebp
  0138f	c3		 ret	 0
$LN167@CGUseItemR:

; 13916: 			}
; 13917: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_SWAMPOFCALMNESS )

  01390	80 f9 38	 cmp	 cl, 56			; 00000038H
  01393	75 1f		 jne	 SHORT $LN169@CGUseItemR

; 13918: 			{
; 13919: 				gObjMoveGate(aIndex,273);

  01395	68 11 01 00 00	 push	 273			; 00000111H
  0139a	53		 push	 ebx
  0139b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  013a0	83 c4 08	 add	 esp, 8
  013a3	5f		 pop	 edi
  013a4	5e		 pop	 esi
  013a5	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  013a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  013a9	33 cd		 xor	 ecx, ebp
  013ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  013b0	8b e5		 mov	 esp, ebp
  013b2	5d		 pop	 ebp
  013b3	c3		 ret	 0
$LN169@CGUseItemR:

; 13920: 			}
; 13921: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_RAKLION )

  013b4	80 f9 39	 cmp	 cl, 57			; 00000039H
  013b7	75 1f		 jne	 SHORT $LN171@CGUseItemR

; 13922: 			{
; 13923: 				gObjMoveGate(aIndex,286);

  013b9	68 1e 01 00 00	 push	 286			; 0000011eH
  013be	53		 push	 ebx
  013bf	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  013c4	83 c4 08	 add	 esp, 8
  013c7	5f		 pop	 edi
  013c8	5e		 pop	 esi
  013c9	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  013ca	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  013cd	33 cd		 xor	 ecx, ebp
  013cf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  013d4	8b e5		 mov	 esp, ebp
  013d6	5d		 pop	 ebp
  013d7	c3		 ret	 0
$LN171@CGUseItemR:
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h

; 308  : 		return nMapNumber == MAP_INDEX_VULCANUS;

  013d8	80 f9 3f	 cmp	 cl, 63			; 0000003fH
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 13926: 			else if (g_NewPVP.IsVulcanusMap(gObj[aIndex].MapNumber))

  013db	75 1f		 jne	 SHORT $LN173@CGUseItemR

; 13927: 			{
; 13928: 				gObjMoveGate(aIndex, 294);

  013dd	68 26 01 00 00	 push	 294			; 00000126H
  013e2	53		 push	 ebx
  013e3	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  013e8	83 c4 08	 add	 esp, 8
  013eb	5f		 pop	 edi
  013ec	5e		 pop	 esi
  013ed	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  013ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  013f1	33 cd		 xor	 ecx, ebp
  013f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  013f8	8b e5		 mov	 esp, ebp
  013fa	5d		 pop	 ebp
  013fb	c3		 ret	 0
$LN173@CGUseItemR:
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h

; 313  : 		return nMapNumber == MAP_INDEX_PKFIELD;

  013fc	80 f9 40	 cmp	 cl, 64			; 00000040H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 13930: 			else if (g_NewPVP.IsPKFieldMap(gObj[aIndex].MapNumber))

  013ff	75 27		 jne	 SHORT $LN175@CGUseItemR

; 13931: 			{
; 13932: 				g_NewPVP.Reset(gObj[aIndex]);

  01401	52		 push	 edx
  01402	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  01407	e8 00 00 00 00	 call	 ?Reset@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z ; CNewPVP::Reset

; 13933: 				gObjMoveGate(aIndex, 17);

  0140c	6a 11		 push	 17			; 00000011H
  0140e	53		 push	 ebx
  0140f	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  01414	83 c4 08	 add	 esp, 8
  01417	5f		 pop	 edi
  01418	5e		 pop	 esi
  01419	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  0141a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0141d	33 cd		 xor	 ecx, ebp
  0141f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01424	8b e5		 mov	 esp, ebp
  01426	5d		 pop	 ebp
  01427	c3		 ret	 0
$LN175@CGUseItemR:

; 13934: 			}
; 13935: #endif
; 13936: #if (GS_CASTLE == 1)
; 13937: 			else if ( gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE )

  01428	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  0142b	75 76		 jne	 SHORT $LN177@CGUseItemR

; 13938: 			{
; 13939: 				if ( g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)

  0142d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  01432	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  01437	83 f8 07	 cmp	 eax, 7
  0143a	75 2b		 jne	 SHORT $LN179@CGUseItemR

; 13940: 				{
; 13941: 					if( gObj[aIndex].m_btCsJoinSide == 1 )

  0143c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01441	80 bc 07 5a 20
	00 00 01	 cmp	 BYTE PTR [edi+eax+8282], 1
  01449	74 3c		 je	 SHORT $LN185@CGUseItemR
$LN181@CGUseItemR:

; 13942: 					{
; 13943: 						gObjMoveGate(aIndex,101);
; 13944: 					}
; 13945: 					else
; 13946: 					{
; 13947: 						gObjMoveGate(aIndex,100);

  0144b	6a 64		 push	 100			; 00000064H
  0144d	53		 push	 ebx
  0144e	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  01453	83 c4 08	 add	 esp, 8
  01456	5f		 pop	 edi
  01457	5e		 pop	 esi
  01458	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01459	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0145c	33 cd		 xor	 ecx, ebp
  0145e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01463	8b e5		 mov	 esp, ebp
  01465	5d		 pop	 ebp
  01466	c3		 ret	 0
$LN179@CGUseItemR:

; 13948: 					}
; 13949: 				}
; 13950: 				else
; 13951: 				{
; 13952: 					if( g_CastleSiege.CheckCastleOwnerMember(aIndex) == TRUE || g_CastleSiege.CheckCastleOwnerUnionMember(aIndex) == TRUE)

  01467	53		 push	 ebx
  01468	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0146d	e8 00 00 00 00	 call	 ?CheckCastleOwnerMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerMember
  01472	83 f8 01	 cmp	 eax, 1
  01475	74 10		 je	 SHORT $LN185@CGUseItemR
  01477	53		 push	 ebx
  01478	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  0147d	e8 00 00 00 00	 call	 ?CheckCastleOwnerUnionMember@CCastleSiege@@QAEHH@Z ; CCastleSiege::CheckCastleOwnerUnionMember
  01482	83 f8 01	 cmp	 eax, 1
  01485	75 c4		 jne	 SHORT $LN181@CGUseItemR
$LN185@CGUseItemR:

; 13953: 					{
; 13954: 						gObjMoveGate(aIndex,101);

  01487	6a 65		 push	 101			; 00000065H
  01489	53		 push	 ebx
  0148a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  0148f	83 c4 08	 add	 esp, 8
  01492	5f		 pop	 edi
  01493	5e		 pop	 esi
  01494	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01495	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01498	33 cd		 xor	 ecx, ebp
  0149a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0149f	8b e5		 mov	 esp, ebp
  014a1	5d		 pop	 ebp
  014a2	c3		 ret	 0
$LN177@CGUseItemR:

; 13955: 					}
; 13956: 					else
; 13957: 					{
; 13958: 						gObjMoveGate(aIndex,100);
; 13959: 					}
; 13960: 				}
; 13961: 			}
; 13962: #endif
; 13963: 			else
; 13964: 			{
; 13965: 				gObjMoveGate(aIndex, 17);

  014a3	6a 11		 push	 17			; 00000011H
  014a5	53		 push	 ebx
  014a6	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  014ab	83 c4 08	 add	 esp, 8
  014ae	5f		 pop	 edi
  014af	5e		 pop	 esi
  014b0	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  014b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  014b4	33 cd		 xor	 ecx, ebp
  014b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  014bb	8b e5		 mov	 esp, ebp
  014bd	5d		 pop	 ebp
  014be	c3		 ret	 0
$LN140@CGUseItemR:

; 13966: 			}
; 13967: 		}
; 13968: 		else if ( citem->m_Type == ITEMGET(14,9) ) // Ale

  014bf	b9 09 1c 00 00	 mov	 ecx, 7177		; 00001c09H
  014c4	66 3b d1	 cmp	 dx, cx
  014c7	75 40		 jne	 SHORT $LN186@CGUseItemR

; 13969: 		{
; 13970: 			int level = citem->m_Level;

  014c9	0f bf 70 08	 movsx	 esi, WORD PTR [eax+8]

; 13971: 
; 13972: 			gObjInventoryItemSet(aIndex, pos, -1);

  014cd	68 ff 00 00 00	 push	 255			; 000000ffH
  014d2	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _pos$1$[ebp]
  014d8	53		 push	 ebx
  014d9	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13973: 			gObj[aIndex].pInventory[pos].Clear();

  014de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  014e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  014e6	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  014ed	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  014f3	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13974: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  014f8	6a 01		 push	 1
  014fa	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _pos$1$[ebp]
  01500	53		 push	 ebx
  01501	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 13975: 			gObjUseDrink(&gObj[aIndex], level);

  01506	56		 push	 esi
  01507	eb 46		 jmp	 SHORT $LN362@CGUseItemR
$LN186@CGUseItemR:

; 13976: 		}
; 13977: 		else if ( citem->m_Type == ITEMGET(14,20) ) // Remedy of Love

  01509	b9 14 1c 00 00	 mov	 ecx, 7188		; 00001c14H
  0150e	66 3b d1	 cmp	 dx, cx
  01511	75 5d		 jne	 SHORT $LN188@CGUseItemR

; 13978: 		{
; 13979: 			if( citem->m_Level == 0 )

  01513	66 83 78 08 00	 cmp	 WORD PTR [eax+8], 0
  01518	0f 85 3d 15 00
	00		 jne	 $LN16@CGUseItemR

; 13980: 			{
; 13981: 				gObjInventoryItemSet(aIndex, pos, -1);

  0151e	68 ff 00 00 00	 push	 255			; 000000ffH
  01523	56		 push	 esi
  01524	53		 push	 ebx
  01525	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13982: 				gObj[aIndex].pInventory[pos].Clear();

  0152a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0152f	83 c4 0c	 add	 esp, 12			; 0000000cH
  01532	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  01539	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  0153f	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13983: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  01544	6a 01		 push	 1
  01546	56		 push	 esi
  01547	53		 push	 ebx
  01548	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 13984: 				gObjUseDrink(&gObj[aIndex], 2);

  0154d	6a 02		 push	 2
$LN362@CGUseItemR:
  0154f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01554	03 c7		 add	 eax, edi
  01556	50		 push	 eax
  01557	e8 00 00 00 00	 call	 ?gObjUseDrink@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjUseDrink
  0155c	83 c4 14	 add	 esp, 20			; 00000014H
  0155f	5f		 pop	 edi
  01560	5e		 pop	 esi
  01561	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01562	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01565	33 cd		 xor	 ecx, ebp
  01567	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0156c	8b e5		 mov	 esp, ebp
  0156e	5d		 pop	 ebp
  0156f	c3		 ret	 0
$LN188@CGUseItemR:

; 13985: 			}
; 13986: 		}
; 13987: 		else if ( citem->m_Type == ITEMGET(13,15) ) // Fruits

  01570	b9 0f 1a 00 00	 mov	 ecx, 6671		; 00001a0fH
  01575	66 3b d1	 cmp	 dx, cx
  01578	75 49		 jne	 SHORT $LN191@CGUseItemR

; 13988: 		{
; 13989: 			if ( iItemUseType == 0 )

  0157a	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _iItemUseType$1$[ebp]
  01580	85 c0		 test	 eax, eax
  01582	75 1b		 jne	 SHORT $LN193@CGUseItemR

; 13990: 			{
; 13991: 				gObjUsePlusStatFruit(aIndex, pos);

  01584	56		 push	 esi
  01585	53		 push	 ebx
  01586	e8 00 00 00 00	 call	 ?gObjUsePlusStatFruit@@YAXHH@Z ; gObjUsePlusStatFruit

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  0158b	83 c4 08	 add	 esp, 8
  0158e	5f		 pop	 edi
  0158f	5e		 pop	 esi
  01590	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01591	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01594	33 cd		 xor	 ecx, ebp
  01596	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0159b	8b e5		 mov	 esp, ebp
  0159d	5d		 pop	 ebp
  0159e	c3		 ret	 0
$LN193@CGUseItemR:

; 13992: 			}
; 13993: 			else if ( iItemUseType == 1 )

  0159f	83 f8 01	 cmp	 eax, 1
  015a2	0f 85 b3 14 00
	00		 jne	 $LN16@CGUseItemR

; 13994: 			{
; 13995: 				gObjUseMinusStatFruit(aIndex, pos);

  015a8	56		 push	 esi
  015a9	53		 push	 ebx
  015aa	e8 00 00 00 00	 call	 ?gObjUseMinusStatFruit@@YAXHH@Z ; gObjUseMinusStatFruit
  015af	83 c4 08	 add	 esp, 8
  015b2	5f		 pop	 edi
  015b3	5e		 pop	 esi
  015b4	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  015b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015b8	33 cd		 xor	 ecx, ebp
  015ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015bf	8b e5		 mov	 esp, ebp
  015c1	5d		 pop	 ebp
  015c2	c3		 ret	 0
$LN191@CGUseItemR:

; 13996: 			}
; 13997: 		}
; 13998: 		else if ( citem->m_Type == ITEMGET(13,54) ||
; 13999: 				  citem->m_Type == ITEMGET(13,55) ||
; 14000: 				  citem->m_Type == ITEMGET(13,56) ||
; 14001: 				  citem->m_Type == ITEMGET(13,57) ||

  015c3	b9 36 1a 00 00	 mov	 ecx, 6710		; 00001a36H
  015c8	66 3b d1	 cmp	 dx, cx
  015cb	0f 84 da 0d 00
	00		 je	 $LN198@CGUseItemR
  015d1	b9 37 1a 00 00	 mov	 ecx, 6711		; 00001a37H
  015d6	66 3b d1	 cmp	 dx, cx
  015d9	0f 84 cc 0d 00
	00		 je	 $LN198@CGUseItemR
  015df	b9 38 1a 00 00	 mov	 ecx, 6712		; 00001a38H
  015e4	66 3b d1	 cmp	 dx, cx
  015e7	0f 84 be 0d 00
	00		 je	 $LN198@CGUseItemR
  015ed	b9 39 1a 00 00	 mov	 ecx, 6713		; 00001a39H
  015f2	66 3b d1	 cmp	 dx, cx
  015f5	0f 84 b0 0d 00
	00		 je	 $LN198@CGUseItemR
  015fb	b9 3a 1a 00 00	 mov	 ecx, 6714		; 00001a3aH
  01600	66 3b d1	 cmp	 dx, cx
  01603	0f 84 a2 0d 00
	00		 je	 $LN198@CGUseItemR

; 14005: 		}
; 14006: 		else if( citem->m_Type == ITEMGET(14,78) ||
; 14007: 				 citem->m_Type == ITEMGET(14,79) ||
; 14008: 				 citem->m_Type == ITEMGET(14,80) ||
; 14009: 				 citem->m_Type == ITEMGET(14,81) ||

  01609	b9 4e 1c 00 00	 mov	 ecx, 7246		; 00001c4eH
  0160e	66 3b d1	 cmp	 dx, cx
  01611	0f 84 72 0d 00
	00		 je	 $LN201@CGUseItemR
  01617	b9 4f 1c 00 00	 mov	 ecx, 7247		; 00001c4fH
  0161c	66 3b d1	 cmp	 dx, cx
  0161f	0f 84 64 0d 00
	00		 je	 $LN201@CGUseItemR
  01625	b9 50 1c 00 00	 mov	 ecx, 7248		; 00001c50H
  0162a	66 3b d1	 cmp	 dx, cx
  0162d	0f 84 56 0d 00
	00		 je	 $LN201@CGUseItemR
  01633	b9 51 1c 00 00	 mov	 ecx, 7249		; 00001c51H
  01638	66 3b d1	 cmp	 dx, cx
  0163b	0f 84 48 0d 00
	00		 je	 $LN201@CGUseItemR
  01641	b9 52 1c 00 00	 mov	 ecx, 7250		; 00001c52H
  01646	66 3b d1	 cmp	 dx, cx
  01649	0f 84 3a 0d 00
	00		 je	 $LN201@CGUseItemR

; 14013: 		}
; 14014: 		else if( citem->m_Type == ITEMGET(14,72) )

  0164f	b9 48 1c 00 00	 mov	 ecx, 7240		; 00001c48H
  01654	66 3b d1	 cmp	 dx, cx
  01657	75 22		 jne	 SHORT $LN202@CGUseItemR

; 14015: 		{
; 14016: 			UsePKRemoveItem(&gObj[aIndex],pos);

  01659	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0165e	03 c7		 add	 eax, edi
  01660	56		 push	 esi
  01661	50		 push	 eax
  01662	e8 00 00 00 00	 call	 ?UsePKRemoveItem@@YAXPAUOBJECTSTRUCT@@H@Z ; UsePKRemoveItem
  01667	83 c4 08	 add	 esp, 8
  0166a	5f		 pop	 edi
  0166b	5e		 pop	 esi
  0166c	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  0166d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01670	33 cd		 xor	 ecx, ebp
  01672	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01677	8b e5		 mov	 esp, ebp
  01679	5d		 pop	 ebp
  0167a	c3		 ret	 0
$LN202@CGUseItemR:

; 14017: 		}
; 14018: 		else if( citem->m_Type == ITEMGET(14,70) || citem->m_Type == ITEMGET(14,71) )

  0167b	b9 46 1c 00 00	 mov	 ecx, 7238		; 00001c46H
  01680	66 3b d1	 cmp	 dx, cx
  01683	0f 84 de 0c 00
	00		 je	 $LN206@CGUseItemR
  01689	b9 47 1c 00 00	 mov	 ecx, 7239		; 00001c47H
  0168e	66 3b d1	 cmp	 dx, cx
  01691	0f 84 d0 0c 00
	00		 je	 $LN206@CGUseItemR

; 14021: 		}
; 14022: 		else if( citem->m_Type == ITEMGET(14,94) )

  01697	b9 5e 1c 00 00	 mov	 ecx, 7262		; 00001c5eH
  0169c	66 3b d1	 cmp	 dx, cx
  0169f	75 32		 jne	 SHORT $LN207@CGUseItemR

; 14023: 		{
; 14024: 			UseMediumElitePotion(&gObj[aIndex],pos,(double)0.65);

  016a1	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3fe4cccccccccccd
  016a9	83 ec 08	 sub	 esp, 8
  016ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016b1	03 c7		 add	 eax, edi
  016b3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  016b8	56		 push	 esi
  016b9	50		 push	 eax
  016ba	e8 00 00 00 00	 call	 ?UseMediumElitePotion@@YAXPAUOBJECTSTRUCT@@HN@Z ; UseMediumElitePotion
  016bf	83 c4 10	 add	 esp, 16			; 00000010H
  016c2	5f		 pop	 edi
  016c3	5e		 pop	 esi
  016c4	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  016c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016c8	33 cd		 xor	 ecx, ebp
  016ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  016cf	8b e5		 mov	 esp, ebp
  016d1	5d		 pop	 ebp
  016d2	c3		 ret	 0
$LN207@CGUseItemR:

; 14025: 		}
; 14026: 		else if( citem->m_Type == ITEMGET(14,85) ||
; 14027: 				 citem->m_Type == ITEMGET(14,86) ||

  016d3	c7 85 f0 fe ff
	ff 55 1c 00 00	 mov	 DWORD PTR tv556[ebp], 7253 ; 00001c55H
  016dd	b9 56 1c 00 00	 mov	 ecx, 7254		; 00001c56H
  016e2	c7 85 e8 fe ff
	ff 57 1c 00 00	 mov	 DWORD PTR tv577[ebp], 7255 ; 00001c57H
  016ec	66 3b 95 f0 fe
	ff ff		 cmp	 dx, WORD PTR tv556[ebp]
  016f3	0f 84 c1 0b 00
	00		 je	 $LN211@CGUseItemR
  016f9	66 3b d1	 cmp	 dx, cx
  016fc	0f 84 b8 0b 00
	00		 je	 $LN211@CGUseItemR
  01702	66 3b 95 e8 fe
	ff ff		 cmp	 dx, WORD PTR tv577[ebp]
  01709	0f 84 ab 0b 00
	00		 je	 $LN211@CGUseItemR

; 14053: 		}
; 14054: 		else if ( citem->m_Type == ITEMGET(14,7) )	// Siege Potion

  0170f	b9 07 1c 00 00	 mov	 ecx, 7175		; 00001c07H
  01714	66 3b d1	 cmp	 dx, cx
  01717	0f 85 2a 01 00
	00		 jne	 $LN218@CGUseItemR

; 14055: 		{
; 14056: 			int iLevel = citem->m_Level;

  0171d	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  01721	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _iLevel$1$[ebp], ecx

; 14057: 			int iSerial = citem->GetNumber();

  01727	8b c8		 mov	 ecx, eax
  01729	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 14058: 			int iDur = (int)citem->m_Durability;
; 14059: 
; 14060: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  0172e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01734	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iSerial$1$[ebp], eax
  0173a	03 cf		 add	 ecx, edi
  0173c	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
  01742	6a 01		 push	 1
  01744	56		 push	 esi
  01745	51		 push	 ecx
  01746	f3 0f 2c 40 24	 cvttss2si eax, DWORD PTR [eax+36]
  0174b	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _iDur$1$[ebp], eax
  01751	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  01756	83 c4 0c	 add	 esp, 12			; 0000000cH
  01759	85 c0		 test	 eax, eax
  0175b	75 32		 jne	 SHORT $LN220@CGUseItemR

; 14061: 			{
; 14062: 				gObjInventoryItemSet(aIndex, pos, -1);

  0175d	68 ff 00 00 00	 push	 255			; 000000ffH
  01762	56		 push	 esi
  01763	53		 push	 ebx
  01764	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14063: 				gObj[aIndex].pInventory[pos].Clear();

  01769	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0176e	83 c4 0c	 add	 esp, 12			; 0000000cH
  01771	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  01778	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  0177e	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14064: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  01783	6a 01		 push	 1
  01785	56		 push	 esi
  01786	53		 push	 ebx
  01787	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0178c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN220@CGUseItemR:

; 14065: 			}
; 14066: 
; 14067: 			if ( gObj[aIndex].lpGuild )

  0178f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01795	8b 84 0f 18 06
	00 00		 mov	 eax, DWORD PTR [edi+ecx+1560]
  0179c	85 c0		 test	 eax, eax
  0179e	74 32		 je	 SHORT $LN221@CGUseItemR

; 14068: 			{
; 14069: 				LogAddTD("[CastleSiege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s][%s] - (Guild : %s)",

  017a0	83 c0 04	 add	 eax, 4
  017a3	50		 push	 eax
  017a4	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  017a7	03 c7		 add	 eax, edi
  017a9	50		 push	 eax
  017aa	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  017ad	03 c7		 add	 eax, edi
  017af	50		 push	 eax
  017b0	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _iDur$1$[ebp]
  017b6	ff b5 ec fe ff
	ff		 push	 DWORD PTR _iSerial$1$[ebp]
  017bc	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _iLevel$1$[ebp]
  017c2	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@OKKOPLEO@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
  017c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  017cd	83 c4 1c	 add	 esp, 28			; 0000001cH

; 14070: 					iLevel, iSerial, iDur, gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].lpGuild->Name);
; 14071: 			}
; 14072: 			else

  017d0	eb 2c		 jmp	 SHORT $LN222@CGUseItemR
$LN221@CGUseItemR:

; 14073: 			{
; 14074: 				LogAddTD("[CastleSiege] Using CastleSiege Potion Lv[%d]/Si[%d]/Dur[%d] - [%s][%s]",

  017d2	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  017d5	03 c7		 add	 eax, edi
  017d7	50		 push	 eax
  017d8	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  017db	03 c7		 add	 eax, edi
  017dd	50		 push	 eax
  017de	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _iDur$1$[ebp]
  017e4	ff b5 ec fe ff
	ff		 push	 DWORD PTR _iSerial$1$[ebp]
  017ea	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _iLevel$1$[ebp]
  017f0	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@HHBGCCMK@?$FLCastleSiege?$FN?5Using?5CastleSiege?5@
  017f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  017fb	83 c4 18	 add	 esp, 24			; 00000018H
$LN222@CGUseItemR:

; 14075: 					iLevel, iSerial, iDur, gObj[aIndex].AccountID, gObj[aIndex].Name);
; 14076: 			}
; 14077: 
; 14078: 			if ( iLevel == 0 )

  017fe	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _iLevel$1$[ebp]
  01804	85 c0		 test	 eax, eax
  01806	75 1b		 jne	 SHORT $LN223@CGUseItemR

; 14079: 			{
; 14080: 				gObjUseBlessAndSoulPotion(aIndex, iLevel);

  01808	50		 push	 eax
  01809	53		 push	 ebx
  0180a	e8 00 00 00 00	 call	 ?gObjUseBlessAndSoulPotion@@YAXHH@Z ; gObjUseBlessAndSoulPotion
  0180f	83 c4 08	 add	 esp, 8
  01812	5f		 pop	 edi
  01813	5e		 pop	 esi
  01814	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01815	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01818	33 cd		 xor	 ecx, ebp
  0181a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0181f	8b e5		 mov	 esp, ebp
  01821	5d		 pop	 ebp
  01822	c3		 ret	 0
$LN223@CGUseItemR:

; 14081: 			}
; 14082: 			else if ( iLevel == 1 )

  01823	83 f8 01	 cmp	 eax, 1
  01826	0f 85 2f 12 00
	00		 jne	 $LN16@CGUseItemR

; 14083: 			{
; 14084: 				gObjUseBlessAndSoulPotion(aIndex, iLevel);

  0182c	50		 push	 eax
  0182d	53		 push	 ebx
  0182e	e8 00 00 00 00	 call	 ?gObjUseBlessAndSoulPotion@@YAXHH@Z ; gObjUseBlessAndSoulPotion
  01833	83 c4 08	 add	 esp, 8
  01836	5f		 pop	 edi
  01837	5e		 pop	 esi
  01838	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01839	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0183c	33 cd		 xor	 ecx, ebp
  0183e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01843	8b e5		 mov	 esp, ebp
  01845	5d		 pop	 ebp
  01846	c3		 ret	 0
$LN218@CGUseItemR:

; 14085: 			}
; 14086: 		}
; 14087: 		else if ( citem->m_Type == ITEMGET(13,48) )

  01847	b9 30 1a 00 00	 mov	 ecx, 6704		; 00001a30H
  0184c	66 3b d1	 cmp	 dx, cx
  0184f	0f 85 44 01 00
	00		 jne	 $LN226@CGUseItemR

; 14088: 		{
; 14089: 			if ( (gObj[aIndex].MapNumber < MAP_INDEX_KALIMA1 || gObj[aIndex].MapNumber > MAP_INDEX_KALIMA6 ) && gObj[aIndex].MapNumber != MAP_INDEX_KALIMA7 )

  01855	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0185a	8a 84 07 23 01
	00 00		 mov	 al, BYTE PTR [edi+eax+291]
  01861	3c 18		 cmp	 al, 24			; 00000018H
  01863	72 08		 jb	 SHORT $LN229@CGUseItemR
  01865	3c 1d		 cmp	 al, 29			; 0000001dH
  01867	0f 86 ee 11 00
	00		 jbe	 $LN16@CGUseItemR
$LN229@CGUseItemR:
  0186d	3c 24		 cmp	 al, 36			; 00000024H
  0186f	0f 84 e6 11 00
	00		 je	 $LN16@CGUseItemR

; 14090: 			{
; 14091: 				int iLevel = g_KalimaGate.GetKalimaGateLevel2(aIndex);

  01875	53		 push	 ebx
  01876	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  0187b	e8 00 00 00 00	 call	 ?GetKalimaGateLevel2@CKalimaGate@@QAEHH@Z ; CKalimaGate::GetKalimaGateLevel2

; 14092: 				int iSerial = citem->GetNumber();

  01880	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$1$[ebp]

; 14093: 				int iDuration = (int)citem->m_Durability;
; 14094: 				BOOL bKalimaGateCreateResult = FALSE;
; 14095: 				int iKalimaGateX = 0;
; 14096: 				int iKalimaGateY = 0;
; 14097: 
; 14098: 				iLevel++;

  01886	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  01889	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber

; 14099: 				iKalimaGateX = gObj[aIndex].X + rand()%6 - 2;

  0188e	e8 00 00 00 00	 call	 _rand
  01893	99		 cdq
  01894	b9 06 00 00 00	 mov	 ecx, 6
  01899	f7 f9		 idiv	 ecx
  0189b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018a1	0f b6 b4 0f 20
	01 00 00	 movzx	 esi, BYTE PTR [edi+ecx+288]
  018a9	83 c6 fe	 add	 esi, -2			; fffffffeH
  018ac	03 f2		 add	 esi, edx

; 14100: 				iKalimaGateY = gObj[aIndex].Y + rand()%6 - 2;

  018ae	e8 00 00 00 00	 call	 _rand
  018b3	99		 cdq
  018b4	b9 06 00 00 00	 mov	 ecx, 6
  018b9	f7 f9		 idiv	 ecx
  018bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 14101: 
; 14102: 				bKalimaGateCreateResult = g_KalimaGate.CreateKalimaGate(aIndex, iLevel, iKalimaGateX, iKalimaGateY);

  018c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  018c5	0f b6 84 07 21
	01 00 00	 movzx	 eax, BYTE PTR [edi+eax+289]
  018cd	83 c0 fe	 add	 eax, -2			; fffffffeH
  018d0	03 c2		 add	 eax, edx
  018d2	50		 push	 eax
  018d3	56		 push	 esi
  018d4	8b b5 e0 fe ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  018da	0f b6 c3	 movzx	 eax, bl
  018dd	50		 push	 eax
  018de	56		 push	 esi
  018df	e8 00 00 00 00	 call	 ?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z ; CKalimaGate::CreateKalimaGate

; 14103: 
; 14104: 				if ( bKalimaGateCreateResult == TRUE )

  018e4	83 f8 01	 cmp	 eax, 1

; 14105: 				{
; 14106: 					if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  018e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  018ec	6a 01		 push	 1
  018ee	75 67		 jne	 SHORT $LN230@CGUseItemR
  018f0	8b 9d f8 fe ff
	ff		 mov	 ebx, DWORD PTR _pos$1$[ebp]
  018f6	03 c7		 add	 eax, edi
  018f8	53		 push	 ebx
  018f9	50		 push	 eax
  018fa	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  018ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  01902	85 c0		 test	 eax, eax
  01904	75 32		 jne	 SHORT $LN232@CGUseItemR

; 14107: 					{
; 14108: 						gObjInventoryItemSet(aIndex, pos, -1);

  01906	68 ff 00 00 00	 push	 255			; 000000ffH
  0190b	53		 push	 ebx
  0190c	56		 push	 esi
  0190d	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14109: 						gObj[aIndex].pInventory[pos].Clear();

  01912	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01917	83 c4 0c	 add	 esp, 12			; 0000000cH
  0191a	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  01921	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  01927	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14110: 						GCInventoryItemDeleteSend(aIndex, pos, 1);

  0192c	6a 01		 push	 1
  0192e	53		 push	 ebx
  0192f	56		 push	 esi
  01930	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01935	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN232@CGUseItemR:

; 14111: 					}
; 14112: 
; 14113: 					LogAddTD("[PCS] Use Free Kalima Ticket Success");

  01938	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HJJFJDGL@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Suc@
  0193d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01943	83 c4 04	 add	 esp, 4
  01946	5f		 pop	 edi
  01947	5e		 pop	 esi
  01948	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01949	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0194c	33 cd		 xor	 ecx, ebp
  0194e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01953	8b e5		 mov	 esp, ebp
  01955	5d		 pop	 ebp
  01956	c3		 ret	 0
$LN230@CGUseItemR:

; 14114: 				}
; 14115: 				else
; 14116: 				{
; 14117: 					GCItemDurSend(aIndex,pos,(BYTE)gObj[aIndex].pInventory[pos].m_Durability,1);

  01957	8b 84 07 c0 11
	00 00		 mov	 eax, DWORD PTR [edi+eax+4544]
  0195e	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv2050[ebp]
  01964	f3 0f 2c 44 10
	24		 cvttss2si eax, DWORD PTR [eax+edx+36]
  0196a	0f b6 c0	 movzx	 eax, al
  0196d	50		 push	 eax
  0196e	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _pos$1$[ebp]
  01974	56		 push	 esi
  01975	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend

; 14118: 					LogAddTD("[PCS] Use Free Kalima Ticket Failed");

  0197a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@DKNGJAAK@?$FLPCS?$FN?5Use?5Free?5Kalima?5Ticket?5Fai@
  0197f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01985	83 c4 14	 add	 esp, 20			; 00000014H
  01988	5f		 pop	 edi
  01989	5e		 pop	 esi
  0198a	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  0198b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0198e	33 cd		 xor	 ecx, ebp
  01990	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01995	8b e5		 mov	 esp, ebp
  01997	5d		 pop	 ebp
  01998	c3		 ret	 0
$LN226@CGUseItemR:

; 14119: 				}
; 14120: 			}
; 14121: 		}
; 14122: 		else if( citem->m_Type == ITEMGET(13,69) )

  01999	b9 45 1a 00 00	 mov	 ecx, 6725		; 00001a45H
  0199e	66 3b d1	 cmp	 dx, cx
  019a1	0f 85 cc 01 00
	00		 jne	 $LN233@CGUseItemR

; 14123: 		{
; 14124: 			int bMove = gMoveCommand.CheckEquipmentToMove(&gObj[aIndex],gObj[aIndex].DeathMap);

  019a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019ad	03 cf		 add	 ecx, edi
  019af	0f b6 81 b7 01
	00 00		 movzx	 eax, BYTE PTR [ecx+439]
  019b6	50		 push	 eax
  019b7	51		 push	 ecx
  019b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  019bd	e8 00 00 00 00	 call	 ?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove

; 14125: 
; 14126: 			if( !BC_MAP_RANGE(gObj[aIndex].MapNumber) &&
; 14127: 				!CC_MAP_RANGE(gObj[aIndex].MapNumber) &&
; 14128: 				!KALIMA_MAP_RANGE(gObj[aIndex].MapNumber) &&
; 14129: 				!DS_MAP_RANGE(gObj[aIndex].MapNumber) &&
; 14130: 				!IT_MAP_RANGE(gObj[aIndex].MapNumber) &&
; 14131: 				gObj[aIndex].MapNumber != MAP_INDEX_CASTLESIEGE &&
; 14132: 				gObj[aIndex].MapNumber != MAP_INDEX_CASTLEHUNTZONE
; 14133: 				&& !DG_MAP_RANGE(gObj[aIndex].MapNumber)
; 14134: 				&& !IF_MAP_RANGE(gObj[aIndex].MapNumber)
; 14135: 				&& bMove == TRUE )

  019c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  019c8	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _bMove$1$[ebp], eax
  019ce	8a 8c 17 23 01
	00 00		 mov	 cl, BYTE PTR [edi+edx+291]
  019d5	80 f9 34	 cmp	 cl, 52			; 00000034H
  019d8	0f 84 46 03 00
	00		 je	 $LN239@CGUseItemR
  019de	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  019e1	72 0f		 jb	 SHORT $LN335@CGUseItemR
  019e3	b0 11		 mov	 al, 17			; 00000011H
  019e5	3a c1		 cmp	 al, cl
  019e7	1b c0		 sbb	 eax, eax
  019e9	83 c0 01	 add	 eax, 1
  019ec	0f 85 32 03 00
	00		 jne	 $LN239@CGUseItemR
$LN335@CGUseItemR:
  019f2	80 f9 35	 cmp	 cl, 53			; 00000035H
  019f5	0f 84 29 03 00
	00		 je	 $LN239@CGUseItemR
  019fb	80 f9 12	 cmp	 cl, 18			; 00000012H
  019fe	72 0f		 jb	 SHORT $LN336@CGUseItemR
  01a00	b0 17		 mov	 al, 23			; 00000017H
  01a02	3a c1		 cmp	 al, cl
  01a04	1b c0		 sbb	 eax, eax
  01a06	83 c0 01	 add	 eax, 1
  01a09	0f 85 15 03 00
	00		 jne	 $LN239@CGUseItemR
$LN336@CGUseItemR:
  01a0f	80 f9 18	 cmp	 cl, 24			; 00000018H
  01a12	72 19		 jb	 SHORT $LN337@CGUseItemR
  01a14	80 f9 1d	 cmp	 cl, 29			; 0000001dH
  01a17	0f 86 07 03 00
	00		 jbe	 $LN239@CGUseItemR
  01a1d	33 c0		 xor	 eax, eax
  01a1f	80 f9 24	 cmp	 cl, 36			; 00000024H
  01a22	0f 94 c0	 sete	 al
  01a25	85 c0		 test	 eax, eax
  01a27	0f 85 f7 02 00
	00		 jne	 $LN239@CGUseItemR
$LN337@CGUseItemR:
  01a2d	80 f9 09	 cmp	 cl, 9
  01a30	0f 84 ee 02 00
	00		 je	 $LN239@CGUseItemR
  01a36	33 c0		 xor	 eax, eax
  01a38	80 f9 20	 cmp	 cl, 32			; 00000020H
  01a3b	0f 94 c0	 sete	 al
  01a3e	85 c0		 test	 eax, eax
  01a40	0f 85 de 02 00
	00		 jne	 $LN239@CGUseItemR
  01a46	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  01a49	72 12		 jb	 SHORT $LN338@CGUseItemR
  01a4b	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  01a50	3a c1		 cmp	 al, cl
  01a52	1b c0		 sbb	 eax, eax
  01a54	83 c0 01	 add	 eax, 1
  01a57	0f 85 c7 02 00
	00		 jne	 $LN239@CGUseItemR
$LN338@CGUseItemR:
  01a5d	80 f9 1e	 cmp	 cl, 30			; 0000001eH
  01a60	0f 84 be 02 00
	00		 je	 $LN239@CGUseItemR
  01a66	80 f9 1f	 cmp	 cl, 31			; 0000001fH
  01a69	0f 84 b5 02 00
	00		 je	 $LN239@CGUseItemR
  01a6f	80 f9 41	 cmp	 cl, 65			; 00000041H
  01a72	72 0f		 jb	 SHORT $LN339@CGUseItemR
  01a74	b0 44		 mov	 al, 68			; 00000044H
  01a76	3a c1		 cmp	 al, cl
  01a78	1b c0		 sbb	 eax, eax
  01a7a	83 c0 01	 add	 eax, 1
  01a7d	0f 85 a1 02 00
	00		 jne	 $LN239@CGUseItemR
$LN339@CGUseItemR:
  01a83	80 f9 45	 cmp	 cl, 69			; 00000045H
  01a86	72 0f		 jb	 SHORT $LN340@CGUseItemR
  01a88	b0 48		 mov	 al, 72			; 00000048H
  01a8a	3a c1		 cmp	 al, cl
  01a8c	1b c0		 sbb	 eax, eax
  01a8e	83 c0 01	 add	 eax, 1
  01a91	0f 85 8d 02 00
	00		 jne	 $LN239@CGUseItemR
$LN340@CGUseItemR:
  01a97	83 bd e0 fe ff
	ff 01		 cmp	 DWORD PTR _bMove$1$[ebp], 1
  01a9e	0f 85 80 02 00
	00		 jne	 $LN239@CGUseItemR

; 14136: 			{
; 14137: 				gObjTeleport(aIndex,gObj[aIndex].DeathMap,gObj[aIndex].DeathX,gObj[aIndex].DeathY);

  01aa4	0f b6 84 17 b6
	01 00 00	 movzx	 eax, BYTE PTR [edi+edx+438]
  01aac	50		 push	 eax
  01aad	0f b6 84 17 b5
	01 00 00	 movzx	 eax, BYTE PTR [edi+edx+437]
  01ab5	50		 push	 eax
  01ab6	0f b6 84 17 b7
	01 00 00	 movzx	 eax, BYTE PTR [edi+edx+439]
  01abe	50		 push	 eax
  01abf	53		 push	 ebx
  01ac0	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport

; 14138: 				gObjInventoryItemSet(aIndex, pos, -1);

  01ac5	68 ff 00 00 00	 push	 255			; 000000ffH
  01aca	56		 push	 esi
  01acb	53		 push	 ebx
  01acc	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14139: 				gObj[aIndex].pInventory[pos].Clear();

  01ad1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ad6	83 c4 1c	 add	 esp, 28			; 0000001cH
  01ad9	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  01ae0	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  01ae6	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14140: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  01aeb	6a 01		 push	 1
  01aed	56		 push	 esi
  01aee	53		 push	 ebx
  01aef	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 14141: 
; 14142: 				LogAddTD("[Using Item] [Charm of Raise] [%s][%s] Die Position Map:[%d] X:[%d] Y:[%d]",

  01af4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01afa	0f b6 84 0f b6
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+438]
  01b02	50		 push	 eax
  01b03	0f b6 84 0f b5
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+437]
  01b0b	50		 push	 eax
  01b0c	0f b6 84 0f b7
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+439]
  01b14	50		 push	 eax
  01b15	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  01b18	03 c7		 add	 eax, edi
  01b1a	50		 push	 eax
  01b1b	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  01b1e	03 c7		 add	 eax, edi
  01b20	50		 push	 eax
  01b21	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CDNJHAJK@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Raise?$FN?5?$FL?$CF@
  01b26	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14143: 					gObj[aIndex].AccountID,gObj[aIndex].Name,gObj[aIndex].DeathMap,gObj[aIndex].DeathX,gObj[aIndex].DeathY);
; 14144: 
; 14145: 				gObj[aIndex].DeathMap = 0;

  01b2c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 14146: 				gObj[aIndex].DeathX = 0;
; 14147: 				gObj[aIndex].DeathY = 0;
; 14148: 
; 14149: 				GCServerCmd(aIndex,60,0,0);

  01b31	6a 00		 push	 0
  01b33	6a 00		 push	 0
  01b35	6a 3c		 push	 60			; 0000003cH
  01b37	c6 84 07 b7 01
	00 00 00	 mov	 BYTE PTR [edi+eax+439], 0
  01b3f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b44	53		 push	 ebx
  01b45	c6 84 07 b5 01
	00 00 00	 mov	 BYTE PTR [edi+eax+437], 0
  01b4d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b52	c6 84 07 b6 01
	00 00 00	 mov	 BYTE PTR [edi+eax+438], 0
  01b5a	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd
  01b5f	83 c4 34	 add	 esp, 52			; 00000034H
  01b62	5f		 pop	 edi
  01b63	5e		 pop	 esi
  01b64	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01b65	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b68	33 cd		 xor	 ecx, ebp
  01b6a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b6f	8b e5		 mov	 esp, ebp
  01b71	5d		 pop	 ebp
  01b72	c3		 ret	 0
$LN233@CGUseItemR:

; 14150: 			}
; 14151: 			else
; 14152: 			{
; 14153: 				char szMsg[256];
; 14154: 				wsprintf(szMsg,lMsg.Get(MSGGET(4,228)));
; 14155: 				GCServerMsgStringSend(szMsg,aIndex,1);
; 14156: 			}
; 14157: 		}
; 14158: 		else if( citem->m_Type == ITEMGET(13,70) )

  01b73	b9 46 1a 00 00	 mov	 ecx, 6726		; 00001a46H
  01b78	66 3b d1	 cmp	 dx, cx
  01b7b	0f 85 e3 01 00
	00		 jne	 $LN237@CGUseItemR

; 14159: 		{
; 14160: 			int bMove = gMoveCommand.CheckEquipmentToMove(&gObj[aIndex],gObj[aIndex].BindMap);

  01b81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01b87	03 cf		 add	 ecx, edi
  01b89	0f b6 81 ba 01
	00 00		 movzx	 eax, BYTE PTR [ecx+442]
  01b90	50		 push	 eax
  01b91	51		 push	 ecx
  01b92	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  01b97	e8 00 00 00 00	 call	 ?CheckEquipmentToMove@CMoveCommand@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove

; 14161: 
; 14162: 			if( gObjCheckMapBind(gObj[aIndex].MapNumber) == TRUE &&

  01b9c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ba2	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _bMove$1$[ebp], eax
  01ba8	0f b6 8c 0f 23
	01 00 00	 movzx	 ecx, BYTE PTR [edi+ecx+291]
  01bb0	51		 push	 ecx
  01bb1	e8 00 00 00 00	 call	 ?gObjCheckMapBind@@YAHH@Z ; gObjCheckMapBind
  01bb6	83 c4 04	 add	 esp, 4
  01bb9	83 f8 01	 cmp	 eax, 1
  01bbc	0f 85 62 01 00
	00		 jne	 $LN239@CGUseItemR
  01bc2	39 85 e0 fe ff
	ff		 cmp	 DWORD PTR _bMove$1$[ebp], eax
  01bc8	0f 85 56 01 00
	00		 jne	 $LN239@CGUseItemR

; 14163: 				bMove == TRUE )
; 14164: 			{
; 14165: 				if( gObjSearchItemMinus(&gObj[aIndex],pos,1)== FALSE )

  01bce	50		 push	 eax
  01bcf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01bd4	03 c7		 add	 eax, edi
  01bd6	56		 push	 esi
  01bd7	50		 push	 eax
  01bd8	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus

; 14166: 				{
; 14167: 					gObjTeleport(aIndex,gObj[aIndex].BindMap,gObj[aIndex].BindX,gObj[aIndex].BindY);

  01bdd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01be3	83 c4 0c	 add	 esp, 12			; 0000000cH
  01be6	85 c0		 test	 eax, eax
  01be8	0f 85 b4 00 00
	00		 jne	 $LN241@CGUseItemR
  01bee	0f b6 84 0f b9
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+441]
  01bf6	50		 push	 eax
  01bf7	0f b6 84 0f b8
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+440]
  01bff	50		 push	 eax
  01c00	0f b6 84 0f ba
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+442]
  01c08	50		 push	 eax
  01c09	53		 push	 ebx
  01c0a	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport

; 14168: 
; 14169: 					gObjInventoryItemSet(aIndex, pos, -1);

  01c0f	68 ff 00 00 00	 push	 255			; 000000ffH
  01c14	56		 push	 esi
  01c15	53		 push	 ebx
  01c16	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14170: 					gObj[aIndex].pInventory[pos].Clear();

  01c1b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c20	83 c4 1c	 add	 esp, 28			; 0000001cH
  01c23	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  01c2a	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  01c30	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14171: 					GCInventoryItemDeleteSend(aIndex, pos, 1);

  01c35	6a 01		 push	 1
  01c37	56		 push	 esi
  01c38	53		 push	 ebx
  01c39	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 14172: 
; 14173: 					gObj[aIndex].BindX = 0;

  01c3e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 14174: 					gObj[aIndex].BindY = 0;
; 14175: 					gObj[aIndex].BindMap = 0;
; 14176: 
; 14177: 					GCServerCmd(aIndex,61,0,0);

  01c43	6a 00		 push	 0
  01c45	6a 00		 push	 0
  01c47	6a 3d		 push	 61			; 0000003dH
  01c49	c6 84 07 b8 01
	00 00 00	 mov	 BYTE PTR [edi+eax+440], 0
  01c51	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c56	53		 push	 ebx
  01c57	c6 84 07 b9 01
	00 00 00	 mov	 BYTE PTR [edi+eax+441], 0
  01c5f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c64	c6 84 07 ba 01
	00 00 00	 mov	 BYTE PTR [edi+eax+442], 0
  01c6c	e8 00 00 00 00	 call	 ?GCServerCmd@@YAXHEEE@Z	; GCServerCmd

; 14178: 
; 14179: 
; 14180: 					LogAddTD("[Using Item] [Charm of Move] [%s][%s]",gObj[aIndex].AccountID,gObj[aIndex].Name);

  01c71	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01c77	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  01c7a	03 c7		 add	 eax, edi
  01c7c	50		 push	 eax
  01c7d	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  01c80	03 c7		 add	 eax, edi
  01c82	50		 push	 eax
  01c83	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HCHOOMNP@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?$FN?5?$FL?$CFs@
  01c88	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14451: 		LogAdd("error-L3 : %s return %s %d %d",

  01c8e	83 c4 28	 add	 esp, 40			; 00000028H
  01c91	5f		 pop	 edi
  01c92	5e		 pop	 esi
  01c93	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01c94	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c97	33 cd		 xor	 ecx, ebp
  01c99	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c9e	8b e5		 mov	 esp, ebp
  01ca0	5d		 pop	 ebp
  01ca1	c3		 ret	 0
$LN241@CGUseItemR:

; 14181: 				}
; 14182: 				else
; 14183: 				{
; 14184: 					gObj[aIndex].BindX = gObj[aIndex].X;

  01ca2	8a 84 0f 20 01
	00 00		 mov	 al, BYTE PTR [edi+ecx+288]
  01ca9	88 84 0f b8 01
	00 00		 mov	 BYTE PTR [edi+ecx+440], al

; 14185: 					gObj[aIndex].BindY = gObj[aIndex].Y;

  01cb0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01cb6	8a 84 0f 21 01
	00 00		 mov	 al, BYTE PTR [edi+ecx+289]
  01cbd	88 84 0f b9 01
	00 00		 mov	 BYTE PTR [edi+ecx+441], al

; 14186: 					gObj[aIndex].BindMap = gObj[aIndex].MapNumber;

  01cc4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01cca	8a 84 0f 23 01
	00 00		 mov	 al, BYTE PTR [edi+ecx+291]
  01cd1	88 84 0f ba 01
	00 00		 mov	 BYTE PTR [edi+ecx+442], al

; 14187: 
; 14188: 					LogAddTD("[Using Item] [Charm of Move - SavePosition] [%s][%s] Map:[%d] X:[%d] Y:[%d]",

  01cd8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01cde	0f b6 84 0f b9
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+441]
  01ce6	50		 push	 eax
  01ce7	0f b6 84 0f b8
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+440]
  01cef	50		 push	 eax
  01cf0	0f b6 84 0f ba
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+442]
  01cf8	50		 push	 eax
  01cf9	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  01cfc	03 c7		 add	 eax, edi
  01cfe	50		 push	 eax
  01cff	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  01d02	03 c7		 add	 eax, edi
  01d04	50		 push	 eax
  01d05	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@IOOAJBNM@?$FLUsing?5Item?$FN?5?$FLCharm?5of?5Move?5?9?5Sa@
  01d0a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01d10	83 c4 18	 add	 esp, 24			; 00000018H
  01d13	5f		 pop	 edi
  01d14	5e		 pop	 esi
  01d15	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01d16	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01d19	33 cd		 xor	 ecx, ebp
  01d1b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01d20	8b e5		 mov	 esp, ebp
  01d22	5d		 pop	 ebp
  01d23	c3		 ret	 0
$LN239@CGUseItemR:

; 14189: 						gObj[aIndex].AccountID,gObj[aIndex].Name,gObj[aIndex].BindMap,gObj[aIndex].BindX,gObj[aIndex].BindY);
; 14190: 				}
; 14191: 			}
; 14192: 			else
; 14193: 			{
; 14194: 				char szMsg[256];
; 14195: 				wsprintf(szMsg,lMsg.Get(MSGGET(4,228)));

  01d24	68 e4 04 00 00	 push	 1252			; 000004e4H
  01d29	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  01d2e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01d33	50		 push	 eax
  01d34	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$4[ebp]
  01d3a	50		 push	 eax
  01d3b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 14196: 				GCServerMsgStringSend(szMsg,aIndex,1);

  01d41	6a 01		 push	 1
  01d43	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$4[ebp]
  01d49	53		 push	 ebx
  01d4a	50		 push	 eax
  01d4b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  01d50	83 c4 14	 add	 esp, 20			; 00000014H
  01d53	5f		 pop	 edi
  01d54	5e		 pop	 esi
  01d55	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01d56	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01d59	33 cd		 xor	 ecx, ebp
  01d5b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01d60	8b e5		 mov	 esp, ebp
  01d62	5d		 pop	 ebp
  01d63	c3		 ret	 0
$LN237@CGUseItemR:

; 14197: 			}
; 14198: 		}
; 14199: 		else if( citem->m_Type == ITEMGET(13,66) )

  01d64	b9 42 1a 00 00	 mov	 ecx, 6722		; 00001a42H
  01d69	66 3b d1	 cmp	 dx, cx
  01d6c	75 68		 jne	 SHORT $LN243@CGUseItemR

; 14200: 		{
; 14201: 			if( gObj[aIndex].Level < 15 )

  01d6e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01d73	66 83 bc 07 96
	00 00 00 0f	 cmp	 WORD PTR [edi+eax+150], 15 ; 0000000fH
  01d7c	7d 2c		 jge	 SHORT $LN245@CGUseItemR

; 14202: 			{
; 14203: 				GCServerMsgStringSend(lMsg.Get(MSGGET(13,53)),aIndex,1);

  01d7e	6a 01		 push	 1
  01d80	53		 push	 ebx
  01d81	68 35 0d 00 00	 push	 3381			; 00000d35H
  01d86	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  01d8b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01d90	50		 push	 eax
  01d91	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  01d96	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d99	5f		 pop	 edi
  01d9a	5e		 pop	 esi
  01d9b	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01d9c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01d9f	33 cd		 xor	 ecx, ebp
  01da1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01da6	8b e5		 mov	 esp, ebp
  01da8	5d		 pop	 ebp
  01da9	c3		 ret	 0
$LN245@CGUseItemR:

; 14204: 			}
; 14205: 			else
; 14206: 			{
; 14207: 				gObjTeleport(aIndex,62,220,20);

  01daa	6a 14		 push	 20			; 00000014H
  01dac	68 dc 00 00 00	 push	 220			; 000000dcH
  01db1	6a 3e		 push	 62			; 0000003eH
  01db3	53		 push	 ebx
  01db4	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport

; 14208: 
; 14209: 				if( gObjSearchItemMinus(&gObj[aIndex],pos,1) == FALSE )

  01db9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01dbe	6a 01		 push	 1
  01dc0	03 c7		 add	 eax, edi
  01dc2	56		 push	 esi
  01dc3	50		 push	 eax
  01dc4	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  01dc9	83 c4 1c	 add	 esp, 28			; 0000001cH
  01dcc	85 c0		 test	 eax, eax
  01dce	0f 85 87 0c 00
	00		 jne	 $LN16@CGUseItemR

; 14210: 				{
; 14211: 					gObjInventoryItemSet(aIndex, pos, -1);
; 14212: 					gObj[aIndex].pInventory[pos].Clear();
; 14213: 					GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14214: 				}
; 14215: 			}

  01dd4	eb 2e		 jmp	 SHORT $LN358@CGUseItemR
$LN243@CGUseItemR:

; 14216: 		}
; 14217: 		else if( citem->m_Type == ITEMGET(13,81) )

  01dd6	b9 51 1a 00 00	 mov	 ecx, 6737		; 00001a51H
  01ddb	66 3b d1	 cmp	 dx, cx
  01dde	75 05		 jne	 SHORT $LN248@CGUseItemR

; 14218: 		{
; 14219: 			g_CashItemPeriodSystem.GDReqPeriodItemInsert(&gObj[aIndex],citem->m_Type,-1);

  01de0	6a ff		 push	 -1
  01de2	51		 push	 ecx

; 14220: 
; 14221: 			gObjInventoryItemSet(aIndex, pos, -1);
; 14222: 			gObj[aIndex].pInventory[pos].Clear();
; 14223: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  01de3	eb 0d		 jmp	 SHORT $LN357@CGUseItemR
$LN248@CGUseItemR:

; 14224: 		}
; 14225: 		else if( citem->m_Type == ITEMGET(13,82) )

  01de5	b9 52 1a 00 00	 mov	 ecx, 6738		; 00001a52H
  01dea	66 3b d1	 cmp	 dx, cx
  01ded	75 58		 jne	 SHORT $LN250@CGUseItemR

; 14226: 		{
; 14227: 			g_CashItemPeriodSystem.GDReqPeriodItemInsert(&gObj[aIndex],citem->m_Type,-1);

  01def	6a ff		 push	 -1
  01df1	51		 push	 ecx
$LN357@CGUseItemR:
  01df2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01df7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  01dfc	03 c7		 add	 eax, edi
  01dfe	50		 push	 eax
  01dff	e8 00 00 00 00	 call	 ?GDReqPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ; CCashItemPeriodSystem::GDReqPeriodItemInsert
$LN358@CGUseItemR:

; 14228: 
; 14229: 			gObjInventoryItemSet(aIndex, pos, -1);

  01e04	68 ff 00 00 00	 push	 255			; 000000ffH
  01e09	56		 push	 esi
  01e0a	53		 push	 ebx
  01e0b	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14230: 			gObj[aIndex].pInventory[pos].Clear();

  01e10	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e15	83 c4 0c	 add	 esp, 12			; 0000000cH
  01e18	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  01e1f	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  01e25	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14231: 			GCInventoryItemDeleteSend(aIndex, pos, 1);

  01e2a	6a 01		 push	 1
  01e2c	56		 push	 esi
$LN359@CGUseItemR:
  01e2d	53		 push	 ebx
  01e2e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01e33	83 c4 0c	 add	 esp, 12			; 0000000cH
  01e36	5f		 pop	 edi
  01e37	5e		 pop	 esi
  01e38	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01e39	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01e3c	33 cd		 xor	 ecx, ebp
  01e3e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01e43	8b e5		 mov	 esp, ebp
  01e45	5d		 pop	 ebp
  01e46	c3		 ret	 0
$LN250@CGUseItemR:

; 14232: 		}
; 14233: 		else if( citem->m_Type == ITEMGET(14,160) )

  01e47	b9 a0 1c 00 00	 mov	 ecx, 7328		; 00001ca0H
  01e4c	66 3b d1	 cmp	 dx, cx
  01e4f	75 25		 jne	 SHORT $LN252@CGUseItemR

; 14234: 		{
; 14235: 			if ( gObjItemDurUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  01e51	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  01e57	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  01e5b	50		 push	 eax
  01e5c	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  01e60	50		 push	 eax
  01e61	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e66	03 c7		 add	 eax, edi
  01e68	50		 push	 eax
  01e69	e8 00 00 00 00	 call	 ?gObjItemDurUp@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemDurUp
  01e6e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14236: 			{
; 14237: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14238: 				gObj[aIndex].pInventory[pos].Clear();
; 14239: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14240: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14241: 			}
; 14242: 			else

  01e71	e9 4a f1 ff ff	 jmp	 $LN366@CGUseItemR
$LN252@CGUseItemR:

; 14243: 			{
; 14244: 				GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14245: 			}
; 14246: 		}
; 14247: 		else if ( citem->m_Type == ITEMGET(14,161) )

  01e76	b9 a1 1c 00 00	 mov	 ecx, 7329		; 00001ca1H
  01e7b	66 3b d1	 cmp	 dx, cx
  01e7e	75 25		 jne	 SHORT $LN256@CGUseItemR

; 14248: 		{
; 14249: 			if ( gObjItemStrenghtenUp(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )

  01e80	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  01e86	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  01e8a	50		 push	 eax
  01e8b	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  01e8f	50		 push	 eax
  01e90	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01e95	03 c7		 add	 eax, edi
  01e97	50		 push	 eax
  01e98	e8 00 00 00 00	 call	 ?gObjItemStrenghtenUp@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjItemStrenghtenUp
  01e9d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14250: 			{
; 14251: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14252: 				gObj[aIndex].pInventory[pos].Clear();
; 14253: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14254: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14255: 			}
; 14256: 			else

  01ea0	e9 1b f1 ff ff	 jmp	 $LN366@CGUseItemR
$LN256@CGUseItemR:

; 14257: 			{
; 14258: 				GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14259: 			}
; 14260: 		}
; 14261: 		else if( citem->m_Type == ITEMGET(14,162) )

  01ea5	b9 a2 1c 00 00	 mov	 ecx, 7330		; 00001ca2H
  01eaa	66 3b d1	 cmp	 dx, cx
  01ead	0f 85 d4 00 00
	00		 jne	 $LN260@CGUseItemR

; 14262: 		{
; 14263: 			PMSG_ANS_EXTEND pMsg;
; 14264: 			PHeadSetB((LPBYTE)&pMsg,0x2B,sizeof(pMsg));

  01eb3	6a 04		 push	 4
  01eb5	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$3[ebp]
  01ebb	6a 2b		 push	 43			; 0000002bH
  01ebd	50		 push	 eax
  01ebe	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14265: 
; 14266: 			if( gObj[aIndex].pInventoryExtend >= 4 )

  01ec3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ec9	83 c4 0c	 add	 esp, 12			; 0000000cH
  01ecc	8a 84 0f cd 11
	00 00		 mov	 al, BYTE PTR [edi+ecx+4557]
  01ed3	3c 04		 cmp	 al, 4
  01ed5	72 2f		 jb	 SHORT $LN262@CGUseItemR

; 14267: 			{
; 14268: 				pMsg.btResult = 0;

  01ed7	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _pMsg$3[ebp+3], 0

; 14269: 				GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  01ede	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  01ee6	50		 push	 eax
  01ee7	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  01ef0	6a 01		 push	 1
  01ef2	68 fd 00 00 00	 push	 253			; 000000fdH
  01ef7	0f b7 c0	 movzx	 eax, ax
  01efa	50		 push	 eax
  01efb	53		 push	 ebx
  01efc	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  01f01	83 c4 14	 add	 esp, 20			; 00000014H

; 14270: 			}
; 14271: 			else

  01f04	eb 58		 jmp	 SHORT $LN263@CGUseItemR
$LN262@CGUseItemR:

; 14272: 			{
; 14273: 				gObj[aIndex].pInventoryExtend++;

  01f06	fe c0		 inc	 al
  01f08	88 84 0f cd 11
	00 00		 mov	 BYTE PTR [edi+ecx+4557], al

; 14274: 				GDExpandInventorySend(&gObj[aIndex],gObj[aIndex].pInventoryExtend);

  01f0f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f15	03 cf		 add	 ecx, edi
  01f17	0f b6 81 cd 11
	00 00		 movzx	 eax, BYTE PTR [ecx+4557]
  01f1e	50		 push	 eax
  01f1f	51		 push	 ecx
  01f20	e8 00 00 00 00	 call	 ?GDExpandInventorySend@@YAXPAUOBJECTSTRUCT@@H@Z ; GDExpandInventorySend

; 14275: 				gObjInventoryItemSet(aIndex, pos, -1);

  01f25	68 ff 00 00 00	 push	 255			; 000000ffH
  01f2a	56		 push	 esi
  01f2b	53		 push	 ebx
  01f2c	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14276: 				gObj[aIndex].pInventory[pos].Clear();

  01f31	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01f36	83 c4 14	 add	 esp, 20			; 00000014H
  01f39	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  01f40	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  01f46	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14277: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  01f4b	6a 01		 push	 1
  01f4d	56		 push	 esi
  01f4e	53		 push	 ebx
  01f4f	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01f54	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14278: 
; 14279: 				pMsg.btResult = 1;

  01f57	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR _pMsg$3[ebp+3], 1
$LN263@CGUseItemR:

; 14280: 			}
; 14281: 
; 14282: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  01f5e	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$3[ebp+1]
  01f65	50		 push	 eax
  01f66	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$3[ebp]
  01f6c	50		 push	 eax
  01f6d	53		 push	 ebx
  01f6e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01f73	83 c4 0c	 add	 esp, 12			; 0000000cH
  01f76	5f		 pop	 edi
  01f77	5e		 pop	 esi
  01f78	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  01f79	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01f7c	33 cd		 xor	 ecx, ebp
  01f7e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01f83	8b e5		 mov	 esp, ebp
  01f85	5d		 pop	 ebp
  01f86	c3		 ret	 0
$LN260@CGUseItemR:

; 14283: 		}
; 14284: 		else if( citem->m_Type == ITEMGET(14,163) )

  01f87	b9 a3 1c 00 00	 mov	 ecx, 7331		; 00001ca3H
  01f8c	66 3b d1	 cmp	 dx, cx
  01f8f	0f 85 d2 00 00
	00		 jne	 $LN264@CGUseItemR

; 14285: 		{
; 14286: 			PMSG_ANS_EXTEND pMsg;
; 14287: 			PHeadSetB((LPBYTE)&pMsg,0x2B,sizeof(pMsg));

  01f95	6a 04		 push	 4
  01f97	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$2[ebp]
  01f9d	6a 2b		 push	 43			; 0000002bH
  01f9f	50		 push	 eax
  01fa0	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 14288: 
; 14289: 			if( gObj[aIndex].pWarehouseExtend >= 1 )

  01fa5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01fab	83 c4 0c	 add	 esp, 12			; 0000000cH
  01fae	80 bc 0f 00 12
	00 00 01	 cmp	 BYTE PTR [edi+ecx+4608], 1
  01fb6	72 2f		 jb	 SHORT $LN266@CGUseItemR

; 14290: 			{
; 14291: 				pMsg.btResult = 0;

  01fb8	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _pMsg$2[ebp+3], 0

; 14292: 				GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  01fbf	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  01fc7	50		 push	 eax
  01fc8	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  01fd1	6a 01		 push	 1
  01fd3	68 fd 00 00 00	 push	 253			; 000000fdH
  01fd8	0f b7 c0	 movzx	 eax, ax
  01fdb	50		 push	 eax
  01fdc	53		 push	 ebx
  01fdd	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  01fe2	83 c4 14	 add	 esp, 20			; 00000014H

; 14293: 			}
; 14294: 			else

  01fe5	eb 57		 jmp	 SHORT $LN267@CGUseItemR
$LN266@CGUseItemR:

; 14295: 			{
; 14296: 				gObj[aIndex].pWarehouseExtend = 1;

  01fe7	c6 84 0f 00 12
	00 00 01	 mov	 BYTE PTR [edi+ecx+4608], 1

; 14297: 				GDExpandWarehouseSend(&gObj[aIndex],gObj[aIndex].pWarehouseExtend);

  01fef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01ff5	03 cf		 add	 ecx, edi
  01ff7	0f b6 81 00 12
	00 00		 movzx	 eax, BYTE PTR [ecx+4608]
  01ffe	50		 push	 eax
  01fff	51		 push	 ecx
  02000	e8 00 00 00 00	 call	 ?GDExpandWarehouseSend@@YAXPAUOBJECTSTRUCT@@H@Z ; GDExpandWarehouseSend

; 14298: 
; 14299: 				gObjInventoryItemSet(aIndex, pos, -1);

  02005	68 ff 00 00 00	 push	 255			; 000000ffH
  0200a	56		 push	 esi
  0200b	53		 push	 ebx
  0200c	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14300: 				gObj[aIndex].pInventory[pos].Clear();

  02011	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02016	83 c4 14	 add	 esp, 20			; 00000014H
  02019	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  02020	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  02026	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14301: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  0202b	6a 01		 push	 1
  0202d	56		 push	 esi
  0202e	53		 push	 ebx
  0202f	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  02034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14302: 
; 14303: 				pMsg.btResult = 1;

  02037	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR _pMsg$2[ebp+3], 1
$LN267@CGUseItemR:

; 14304: 			}
; 14305: 
; 14306: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0203e	0f b6 85 f9 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$2[ebp+1]
  02045	50		 push	 eax
  02046	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$2[ebp]
  0204c	50		 push	 eax
  0204d	53		 push	 ebx
  0204e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  02053	83 c4 0c	 add	 esp, 12			; 0000000cH
  02056	5f		 pop	 edi
  02057	5e		 pop	 esi
  02058	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  02059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0205c	33 cd		 xor	 ecx, ebp
  0205e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02063	8b e5		 mov	 esp, ebp
  02065	5d		 pop	 ebp
  02066	c3		 ret	 0
$LN264@CGUseItemR:

; 14307: 		}
; 14308: 		else if (citem->m_Type == ITEMGET(13, 152)
; 14309: 			|| citem->m_Type == ITEMGET(13, 156)) {

  02067	b9 98 1a 00 00	 mov	 ecx, 6808		; 00001a98H
  0206c	66 3b d1	 cmp	 dx, cx
  0206f	0f 84 ea 01 00
	00		 je	 $LN270@CGUseItemR
  02075	b9 9c 1a 00 00	 mov	 ecx, 6812		; 00001a9cH
  0207a	66 3b d1	 cmp	 dx, cx
  0207d	0f 84 dc 01 00
	00		 je	 $LN270@CGUseItemR

; 14320: 				GCServerMsgStringSend("Master Skill Reset Fail", aIndex, 1);
; 14321: 			}
; 14322: 		}
; 14323: 		else if (citem->m_Type == ITEMGET(13, 153)
; 14324: 			|| citem->m_Type == ITEMGET(13, 157)) {

  02083	b9 99 1a 00 00	 mov	 ecx, 6809		; 00001a99H
  02088	66 3b d1	 cmp	 dx, cx
  0208b	0f 84 73 01 00
	00		 je	 $LN275@CGUseItemR
  02091	b9 9d 1a 00 00	 mov	 ecx, 6813		; 00001a9dH
  02096	66 3b d1	 cmp	 dx, cx
  02099	0f 84 65 01 00
	00		 je	 $LN275@CGUseItemR

; 14335: 				GCServerMsgStringSend("Master Skill Reset Fail", aIndex, 1);
; 14336: 			}
; 14337: 		}
; 14338: 		else if (citem->m_Type == ITEMGET(13, 154)
; 14339: 			|| citem->m_Type == ITEMGET(13, 158)) {

  0209f	b9 9a 1a 00 00	 mov	 ecx, 6810		; 00001a9aH
  020a4	66 3b d1	 cmp	 dx, cx
  020a7	0f 84 00 01 00
	00		 je	 $LN280@CGUseItemR
  020ad	b9 9e 1a 00 00	 mov	 ecx, 6814		; 00001a9eH
  020b2	66 3b d1	 cmp	 dx, cx
  020b5	0f 84 f2 00 00
	00		 je	 $LN280@CGUseItemR

; 14350: 				GCServerMsgStringSend("Master Skill Reset Fail", aIndex, 1);
; 14351: 			}
; 14352: 		}
; 14353: 		else if (citem->m_Type == ITEMGET(13, 155)
; 14354: 			|| citem->m_Type == ITEMGET(13, 159)) {

  020bb	b9 9b 1a 00 00	 mov	 ecx, 6811		; 00001a9bH
  020c0	66 3b d1	 cmp	 dx, cx
  020c3	74 70		 je	 SHORT $LN285@CGUseItemR
  020c5	b9 9f 1a 00 00	 mov	 ecx, 6815		; 00001a9fH
  020ca	66 3b d1	 cmp	 dx, cx
  020cd	74 66		 je	 SHORT $LN285@CGUseItemR

; 14366: 			}
; 14367: 		}
; 14368: #if (ENABLETEST_CUSTOM_JEWELS == 1)
; 14369: 		else if( citem->m_Type == ITEMGET(14,200) )
; 14370: 		{
; 14371: 			if ( gObjJewel1Enchant(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 14372: 			{
; 14373: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14374: 				gObj[aIndex].pInventory[pos].Clear();
; 14375: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14376: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14377: 			}
; 14378: 			else
; 14379: 			{
; 14380: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14381: 			}
; 14382: 		}
; 14383: 		else if( citem->m_Type == ITEMGET(14,201) )
; 14384: 		{
; 14385: 			if ( gObjJewel2Enchant(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 14386: 			{
; 14387: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14388: 				gObj[aIndex].pInventory[pos].Clear();
; 14389: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14390: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14391: 			}
; 14392: 			else
; 14393: 			{
; 14394: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14395: 			}
; 14396: 		}
; 14397: 		else if( citem->m_Type == ITEMGET(14,202) )
; 14398: 		{
; 14399: 			if ( gObjJewel3Enchant(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 14400: 			{
; 14401: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14402: 				gObj[aIndex].pInventory[pos].Clear();
; 14403: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14404: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14405: 			}
; 14406: 			else
; 14407: 			{
; 14408: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14409: 			}
; 14410: 		}
; 14411: 		else if( citem->m_Type == ITEMGET(14,203) )
; 14412: 		{
; 14413: 			if ( gObjJewel4Enchant(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 14414: 			{
; 14415: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14416: 				gObj[aIndex].pInventory[pos].Clear();
; 14417: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14418: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14419: 			}
; 14420: 			else
; 14421: 			{
; 14422: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14423: 			}
; 14424: 		}
; 14425: 		else if( citem->m_Type == ITEMGET(14,204) )
; 14426: 		{
; 14427: 			if ( gObjJewel5Enchant(&gObj[aIndex], lpMsg->inventoryPos, lpMsg->invenrotyTarget) == TRUE )
; 14428: 			{
; 14429: 				gObjInventoryItemSet(aIndex, pos, -1);
; 14430: 				gObj[aIndex].pInventory[pos].Clear();
; 14431: 				GCInventoryItemOneSend(aIndex, lpMsg->invenrotyTarget);
; 14432: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14433: 			}
; 14434: 			else
; 14435: 			{
; 14436: 				GCReFillSend(aIndex, gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 14437: 			}
; 14438: 		}
; 14439: #endif
; 14440: 		else
; 14441: 		{
; 14442: 			LogAdd("error-L3 : %s return %s %d %d %s",

  020cf	8b c8		 mov	 ecx, eax
  020d1	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  020d6	50		 push	 eax
  020d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020dc	56		 push	 esi
  020dd	68 6b 38 00 00	 push	 14443			; 0000386bH
  020e2	83 c0 5d	 add	 eax, 93			; 0000005dH
  020e5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  020ea	03 c7		 add	 eax, edi
  020ec	50		 push	 eax
  020ed	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DBLGBMBL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?5?$CFs@
  020f2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 14443: 				gObj[aIndex].Name, __FILE__,__LINE__, pos,citem->GetName());
; 14444: 
; 14445: 			GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  020f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  020fe	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  02106	50		 push	 eax
  02107	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  02110	6a 01		 push	 1
  02112	68 fd 00 00 00	 push	 253			; 000000fdH
  02117	0f b7 c0	 movzx	 eax, ax
  0211a	50		 push	 eax
  0211b	53		 push	 ebx
  0211c	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  02121	83 c4 2c	 add	 esp, 44			; 0000002cH
  02124	5f		 pop	 edi
  02125	5e		 pop	 esi
  02126	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  02127	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0212a	33 cd		 xor	 ecx, ebp
  0212c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02131	8b e5		 mov	 esp, ebp
  02133	5d		 pop	 ebp
  02134	c3		 ret	 0
$LN285@CGUseItemR:

; 14355: 			if (g_MasterSkillSystem.CheckMasterSkillPoint(aIndex, 0)) {

  02135	6a 00		 push	 0
  02137	53		 push	 ebx
  02138	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0213d	e8 00 00 00 00	 call	 ?CheckMasterSkillPoint@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterSkillPoint
  02142	84 c0		 test	 al, al
  02144	74 46		 je	 SHORT $LN286@CGUseItemR

; 14356: 				g_MasterSkillSystem.ResetMasterSkill(aIndex, 0);

  02146	6a 00		 push	 0
  02148	53		 push	 ebx
  02149	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0214e	e8 00 00 00 00	 call	 ?ResetMasterSkill@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::ResetMasterSkill

; 14357: 				LogAddTD("[%s] [%s] [MasterLevelSkill Reset] - All", 

  02153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02159	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0215c	03 c7		 add	 eax, edi
  0215e	50		 push	 eax
  0215f	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  02162	03 c7		 add	 eax, edi
  02164	50		 push	 eax
  02165	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@HAOMGPEH@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
  0216a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14358: 					gObj[aIndex].AccountID, gObj[aIndex].Name);
; 14359: 				gObjCloseSet(aIndex, 1);

  02170	6a 01		 push	 1
  02172	53		 push	 ebx
  02173	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet

; 14360: 				gObjInventoryItemSet(aIndex, pos, -1);

  02178	68 ff 00 00 00	 push	 255			; 000000ffH
  0217d	56		 push	 esi
  0217e	53		 push	 ebx
  0217f	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  02184	83 c4 20	 add	 esp, 32			; 00000020H

; 14361: 				gObj[aIndex].pInventory[pos].Clear();
; 14362: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14363: 			}
; 14364: 			else {

  02187	e9 4e 08 00 00	 jmp	 $LN353@CGUseItemR
$LN286@CGUseItemR:

; 14365: 				GCServerMsgStringSend("Master Skill Reset Fail", aIndex, 1);

  0218c	6a 01		 push	 1
  0218e	53		 push	 ebx
$LN271@CGUseItemR:
  0218f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@IGJGPHCH@Master?5Skill?5Reset?5Fail?$AA@
  02194	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  02199	83 c4 0c	 add	 esp, 12			; 0000000cH
  0219c	5f		 pop	 edi
  0219d	5e		 pop	 esi
  0219e	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  0219f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  021a2	33 cd		 xor	 ecx, ebp
  021a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  021a9	8b e5		 mov	 esp, ebp
  021ab	5d		 pop	 ebp
  021ac	c3		 ret	 0
$LN280@CGUseItemR:

; 14340: 			if (g_MasterSkillSystem.CheckMasterSkillPoint(aIndex, 3)) {

  021ad	6a 03		 push	 3
  021af	53		 push	 ebx
  021b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  021b5	e8 00 00 00 00	 call	 ?CheckMasterSkillPoint@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterSkillPoint
  021ba	84 c0		 test	 al, al
  021bc	74 ce		 je	 SHORT $LN286@CGUseItemR

; 14341: 				g_MasterSkillSystem.ResetMasterSkill(aIndex, 3);

  021be	6a 03		 push	 3
  021c0	53		 push	 ebx
  021c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  021c6	e8 00 00 00 00	 call	 ?ResetMasterSkill@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::ResetMasterSkill

; 14342: 				LogAddTD("[%s] [%s] [MasterLevelSkill Reset] - Enhance Attack/Defense (%d)", 

  021cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  021d1	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  021d4	03 c7		 add	 eax, edi
  021d6	50		 push	 eax
  021d7	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  021da	03 c7		 add	 eax, edi
  021dc	50		 push	 eax
  021dd	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@LLBOIAD@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
  021e2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14343: 					gObj[aIndex].AccountID, gObj[aIndex].Name);
; 14344: 				gObjCloseSet(aIndex, 1);

  021e8	6a 01		 push	 1
  021ea	53		 push	 ebx
  021eb	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet

; 14345: 				gObjInventoryItemSet(aIndex, pos, -1);

  021f0	68 ff 00 00 00	 push	 255			; 000000ffH
  021f5	56		 push	 esi
  021f6	53		 push	 ebx
  021f7	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  021fc	83 c4 20	 add	 esp, 32			; 00000020H

; 14346: 				gObj[aIndex].pInventory[pos].Clear();
; 14347: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14348: 			}
; 14349: 			else {

  021ff	e9 d6 07 00 00	 jmp	 $LN353@CGUseItemR
$LN275@CGUseItemR:

; 14325: 			if (g_MasterSkillSystem.CheckMasterSkillPoint(aIndex, 2)) {

  02204	6a 02		 push	 2
  02206	53		 push	 ebx
  02207	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0220c	e8 00 00 00 00	 call	 ?CheckMasterSkillPoint@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterSkillPoint
  02211	84 c0		 test	 al, al
  02213	0f 84 73 ff ff
	ff		 je	 $LN286@CGUseItemR

; 14326: 				g_MasterSkillSystem.ResetMasterSkill(aIndex, 2);

  02219	6a 02		 push	 2
  0221b	53		 push	 ebx
  0221c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  02221	e8 00 00 00 00	 call	 ?ResetMasterSkill@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::ResetMasterSkill

; 14327: 				LogAddTD("[%s] [%s] [MasterLevelSkill Reset] - Strengthen Skill", 

  02226	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0222c	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0222f	03 c7		 add	 eax, edi
  02231	50		 push	 eax
  02232	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  02235	03 c7		 add	 eax, edi
  02237	50		 push	 eax
  02238	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@CEAHPFGG@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
  0223d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14328: 					gObj[aIndex].AccountID, gObj[aIndex].Name);
; 14329: 				gObjCloseSet(aIndex, 1);

  02243	6a 01		 push	 1
  02245	53		 push	 ebx
  02246	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet

; 14330: 				gObjInventoryItemSet(aIndex, pos, -1);

  0224b	68 ff 00 00 00	 push	 255			; 000000ffH
  02250	56		 push	 esi
  02251	53		 push	 ebx
  02252	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  02257	83 c4 20	 add	 esp, 32			; 00000020H

; 14331: 				gObj[aIndex].pInventory[pos].Clear();
; 14332: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14333: 			}
; 14334: 			else {

  0225a	e9 7b 07 00 00	 jmp	 $LN353@CGUseItemR
$LN270@CGUseItemR:

; 14310: 			if (g_MasterSkillSystem.CheckMasterSkillPoint(aIndex, 1)) {

  0225f	6a 01		 push	 1
  02261	53		 push	 ebx
  02262	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  02267	e8 00 00 00 00	 call	 ?CheckMasterSkillPoint@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterSkillPoint

; 14311: 				g_MasterSkillSystem.ResetMasterSkill(aIndex, 1);

  0226c	6a 01		 push	 1
  0226e	53		 push	 ebx
  0226f	84 c0		 test	 al, al
  02271	0f 84 18 ff ff
	ff		 je	 $LN271@CGUseItemR
  02277	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0227c	e8 00 00 00 00	 call	 ?ResetMasterSkill@CMasterLevelSkillTreeSystem@@QAEDHH@Z ; CMasterLevelSkillTreeSystem::ResetMasterSkill

; 14312: 				LogAddTD("[%s] [%s] [MasterLevelSkill Reset] - Passive", 

  02281	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02287	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0228a	03 c7		 add	 eax, edi
  0228c	50		 push	 eax
  0228d	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  02290	03 c7		 add	 eax, edi
  02292	50		 push	 eax
  02293	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HEGKGIOI@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5?$FLMasterLevelSkill?5Rese@
  02298	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 14313: 					gObj[aIndex].AccountID, gObj[aIndex].Name);
; 14314: 				gObjCloseSet(aIndex, 1);

  0229e	6a 01		 push	 1
  022a0	53		 push	 ebx
  022a1	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet

; 14315: 				gObjInventoryItemSet(aIndex, pos, -1);

  022a6	68 ff 00 00 00	 push	 255			; 000000ffH
  022ab	56		 push	 esi
  022ac	53		 push	 ebx
  022ad	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  022b2	83 c4 20	 add	 esp, 32			; 00000020H

; 14316: 				gObj[aIndex].pInventory[pos].Clear();
; 14317: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 14318: 			}
; 14319: 			else {

  022b5	e9 20 07 00 00	 jmp	 $LN353@CGUseItemR
$LN211@CGUseItemR:

; 14028: 				 citem->m_Type == ITEMGET(14,87) )
; 14029: 		{
; 14030: 			int BuffNumber = 0;

  022ba	33 c0		 xor	 eax, eax

; 14031: 
; 14032: 			if( citem->m_Type == ITEMGET(14,85) )

  022bc	66 3b 95 f0 fe
	ff ff		 cmp	 dx, WORD PTR tv556[ebp]
  022c3	75 0c		 jne	 SHORT $LN212@CGUseItemR

; 14033: 			{
; 14034: 				BuffNumber = BUFF_CHERRY_WINE;

  022c5	c7 85 f0 fe ff
	ff 4e 00 00 00	 mov	 DWORD PTR _BuffNumber$1$[ebp], 78 ; 0000004eH
  022cf	eb 26		 jmp	 SHORT $LN216@CGUseItemR
$LN212@CGUseItemR:

; 14035: 			}
; 14036: 			else if( citem->m_Type == ITEMGET(14,86) )

  022d1	66 3b d1	 cmp	 dx, cx
  022d4	75 0c		 jne	 SHORT $LN214@CGUseItemR

; 14037: 			{
; 14038: 				BuffNumber = BUFF_CHERRY_RICECAKE;

  022d6	c7 85 f0 fe ff
	ff 4f 00 00 00	 mov	 DWORD PTR _BuffNumber$1$[ebp], 79 ; 0000004fH
  022e0	eb 15		 jmp	 SHORT $LN216@CGUseItemR
$LN214@CGUseItemR:

; 14039: 			}
; 14040: 			else if( citem->m_Type == ITEMGET(14,87) )

  022e2	66 3b 95 e8 fe
	ff ff		 cmp	 dx, WORD PTR tv577[ebp]
  022e9	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  022ee	0f 44 c1	 cmove	 eax, ecx
  022f1	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _BuffNumber$1$[ebp], eax
$LN216@CGUseItemR:

; 14041: 			{
; 14042: 				BuffNumber = BUFF_CHERRY_FLOWERPETAL;
; 14043: 			}
; 14044: 
; 14045: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  022f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  022fc	6a 01		 push	 1
  022fe	03 c7		 add	 eax, edi
  02300	56		 push	 esi
  02301	50		 push	 eax
  02302	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  02307	83 c4 0c	 add	 esp, 12			; 0000000cH
  0230a	85 c0		 test	 eax, eax
  0230c	75 32		 jne	 SHORT $LN217@CGUseItemR

; 14046: 			{
; 14047: 				gObjInventoryItemSet(aIndex, pos, -1);

  0230e	68 ff 00 00 00	 push	 255			; 000000ffH
  02313	56		 push	 esi
  02314	53		 push	 ebx
  02315	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 14048: 				gObj[aIndex].pInventory[pos].Clear();

  0231a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0231f	83 c4 0c	 add	 esp, 12			; 0000000cH
  02322	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  02329	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  0232f	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14049: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  02334	6a 01		 push	 1
  02336	56		 push	 esi
  02337	53		 push	 ebx
  02338	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0233d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN217@CGUseItemR:

; 14050: 			}
; 14051: 
; 14052: 			gObjAddBuffEffect(&gObj[aIndex],BuffNumber);

  02340	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _BuffNumber$1$[ebp]
$LN360@CGUseItemR:
  02346	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0234b	03 c7		 add	 eax, edi
  0234d	50		 push	 eax
  0234e	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjAddBuffEffect
  02353	83 c4 08	 add	 esp, 8
  02356	5f		 pop	 edi
  02357	5e		 pop	 esi
  02358	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  02359	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0235c	33 cd		 xor	 ecx, ebp
  0235e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02363	8b e5		 mov	 esp, ebp
  02365	5d		 pop	 ebp
  02366	c3		 ret	 0
$LN206@CGUseItemR:

; 14019: 		{
; 14020: 			UseExCashPotions(&gObj[aIndex],pos);

  02367	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0236c	03 c7		 add	 eax, edi
  0236e	56		 push	 esi
  0236f	50		 push	 eax
  02370	e8 00 00 00 00	 call	 ?UseExCashPotions@@YAXPAUOBJECTSTRUCT@@H@Z ; UseExCashPotions
  02375	83 c4 08	 add	 esp, 8
  02378	5f		 pop	 edi
  02379	5e		 pop	 esi
  0237a	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  0237b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0237e	33 cd		 xor	 ecx, ebp
  02380	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02385	8b e5		 mov	 esp, ebp
  02387	5d		 pop	 ebp
  02388	c3		 ret	 0
$LN201@CGUseItemR:

; 14010: 				 citem->m_Type == ITEMGET(14,82) )
; 14011: 		{
; 14012: 			UseCashItems(&gObj[aIndex],pos);

  02389	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0238e	03 c7		 add	 eax, edi
  02390	56		 push	 esi
  02391	50		 push	 eax
  02392	e8 00 00 00 00	 call	 ?UseCashItems@@YAXPAUOBJECTSTRUCT@@H@Z ; UseCashItems
  02397	83 c4 08	 add	 esp, 8
  0239a	5f		 pop	 edi
  0239b	5e		 pop	 esi
  0239c	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  0239d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  023a0	33 cd		 xor	 ecx, ebp
  023a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  023a7	8b e5		 mov	 esp, ebp
  023a9	5d		 pop	 ebp
  023aa	c3		 ret	 0
$LN198@CGUseItemR:

; 14002: 				  citem->m_Type == ITEMGET(13,58) )
; 14003: 		{
; 14004: 			ExMinusStatFruit(&gObj[aIndex],pos);

  023ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  023b0	03 c7		 add	 eax, edi
  023b2	56		 push	 esi
  023b3	50		 push	 eax
  023b4	e8 00 00 00 00	 call	 ?ExMinusStatFruit@@YAXPAUOBJECTSTRUCT@@H@Z ; ExMinusStatFruit
  023b9	83 c4 08	 add	 esp, 8
  023bc	5f		 pop	 edi
  023bd	5e		 pop	 esi
  023be	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  023bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  023c2	33 cd		 xor	 ecx, ebp
  023c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  023c9	8b e5		 mov	 esp, ebp
  023cb	5d		 pop	 ebp
  023cc	c3		 ret	 0
$LN128@CGUseItemR:

; 13784: 				  citem->m_Type == ITEMGET(12,48) )
; 13785: 		{
; 13786: 			if ( (gObj[aIndex].Strength + gObj[aIndex].AddStrength) < citem->m_RequireStrength )

  023cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  023d2	03 c7		 add	 eax, edi
  023d4	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv2423[ebp], eax
  023da	0f b7 88 fc 00
	00 00		 movzx	 ecx, WORD PTR [eax+252]
  023e1	0f b7 80 d0 00
	00 00		 movzx	 eax, WORD PTR [eax+208]
  023e8	03 c8		 add	 ecx, eax
  023ea	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
  023f0	0f b7 40 52	 movzx	 eax, WORD PTR [eax+82]
  023f4	3b c8		 cmp	 ecx, eax
  023f6	7d 3b		 jge	 SHORT $LN130@CGUseItemR
$LN356@CGUseItemR:

; 13787: 			{
; 13788: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  023f8	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv2423[ebp]
  023fe	0f b7 81 2c 01
	00 00		 movzx	 eax, WORD PTR [ecx+300]
  02405	50		 push	 eax
  02406	f3 0f 2c 81 d8
	00 00 00	 cvttss2si eax, DWORD PTR [ecx+216]
  0240e	6a 01		 push	 1
  02410	68 fd 00 00 00	 push	 253			; 000000fdH
  02415	0f b7 c0	 movzx	 eax, ax
  02418	50		 push	 eax
  02419	53		 push	 ebx
  0241a	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  0241f	83 c4 14	 add	 esp, 20			; 00000014H
  02422	5f		 pop	 edi
  02423	5e		 pop	 esi
  02424	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  02425	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02428	33 cd		 xor	 ecx, ebp
  0242a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0242f	8b e5		 mov	 esp, ebp
  02431	5d		 pop	 ebp
  02432	c3		 ret	 0
$LN130@CGUseItemR:

; 13789: 				return;
; 13790: 			}
; 13791: 			
; 13792: 			if ( (gObj[aIndex].Dexterity + gObj[aIndex].AddDexterity) < citem->m_RequireDexterity )

  02433	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv2423[ebp]
  02439	0f b7 88 fe 00
	00 00		 movzx	 ecx, WORD PTR [eax+254]
  02440	0f b7 80 d2 00
	00 00		 movzx	 eax, WORD PTR [eax+210]
  02447	03 c8		 add	 ecx, eax
  02449	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
  0244f	0f b7 40 54	 movzx	 eax, WORD PTR [eax+84]
  02453	3b c8		 cmp	 ecx, eax
  02455	7c a1		 jl	 SHORT $LN356@CGUseItemR

; 13793: 			{
; 13794: 				GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13795: 				return;
; 13796: 			}
; 13797: 
; 13798: 			if ( citem->m_Type == ITEMGET(15,18) )	// Scroll of HellBurst

  02457	b8 12 1e 00 00	 mov	 eax, 7698		; 00001e12H
  0245c	66 3b d0	 cmp	 dx, ax
  0245f	75 1c		 jne	 SHORT $LN341@CGUseItemR

; 13799: 			{
; 13800: 				if ( g_QuestInfo.GetQuestState(&gObj[aIndex], 2) != 2 )

  02461	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv2423[ebp]
  02467	6a 02		 push	 2
  02469	51		 push	 ecx
  0246a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0246f	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  02474	83 f8 02	 cmp	 eax, 2
  02477	0f 85 6a df ff
	ff		 jne	 $LN355@CGUseItemR
$LN341@CGUseItemR:

; 13801: 				{
; 13802: 					GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13803: 					return;
; 13804: 				}
; 13805: 			}
; 13806: 
; 13807: 			if (citem->m_Type >= ITEMGET(12,8) && citem->m_Type <= ITEMGET(12,24))

  0247d	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _citem$1$[ebp]
  02483	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  02487	66 3b 85 e8 fe
	ff ff		 cmp	 ax, WORD PTR tv743[ebp]
  0248e	7c 22		 jl	 SHORT $LN135@CGUseItemR
  02490	66 3b 85 f0 fe
	ff ff		 cmp	 ax, WORD PTR tv749[ebp]
  02497	7f 19		 jg	 SHORT $LN135@CGUseItemR

; 13808: 			{
; 13809: 				if ( gObj[aIndex].Level < citem->m_RequireLevel )	// Orbs

  02499	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0249e	0f bf 8c 07 96
	00 00 00	 movsx	 ecx, WORD PTR [edi+eax+150]
  024a6	0f b7 42 58	 movzx	 eax, WORD PTR [edx+88]
  024aa	3b c8		 cmp	 ecx, eax
  024ac	0f 8c 35 df ff
	ff		 jl	 $LN355@CGUseItemR
$LN135@CGUseItemR:

; 13810: 				{
; 13811: 					GCReFillSend(aIndex, (WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);
; 13812: 					return;
; 13813: 				}
; 13814: 			}
; 13815: 
; 13816: 			WORD skillnumber;
; 13817: 
; 13818: 			if ( citem->IsClass((char)gObj[aIndex].Class, gObj[aIndex].ChangeUP,gObj[aIndex].ChangeUP2) == FALSE )

  024b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  024b8	0f b6 84 0f 94
	00 00 00	 movzx	 eax, BYTE PTR [edi+ecx+148]
  024c0	50		 push	 eax
  024c1	0f b6 84 0f 93
	00 00 00	 movzx	 eax, BYTE PTR [edi+ecx+147]
  024c9	50		 push	 eax
  024ca	0f b6 84 0f 90
	00 00 00	 movzx	 eax, BYTE PTR [edi+ecx+144]
  024d2	8b ca		 mov	 ecx, edx
  024d4	50		 push	 eax
  024d5	e8 00 00 00 00	 call	 ?IsClass@CItem@@QAEHDHH@Z ; CItem::IsClass
  024da	85 c0		 test	 eax, eax
  024dc	75 21		 jne	 SHORT $LN136@CGUseItemR

; 13819: 			{	
; 13820: 				GCInventoryItemDeleteSend(aIndex, -1, 1);

  024de	6a 01		 push	 1
  024e0	68 ff 00 00 00	 push	 255			; 000000ffH
  024e5	53		 push	 ebx
  024e6	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  024eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  024ee	5f		 pop	 edi
  024ef	5e		 pop	 esi
  024f0	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  024f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  024f4	33 cd		 xor	 ecx, ebp
  024f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  024fb	8b e5		 mov	 esp, ebp
  024fd	5d		 pop	 ebp
  024fe	c3		 ret	 0
$LN136@CGUseItemR:

; 13821: 			}
; 13822: 			else
; 13823: 			{
; 13824: 				int addskill = gObjMagicAdd(&gObj[aIndex], citem->m_Type>>(9), citem->m_Type %  MAX_SUBTYPE_ITEMS,citem->m_Level, skillnumber);

  024ff	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
  02505	8d 95 e0 fe ff
	ff		 lea	 edx, DWORD PTR _skillnumber$1[ebp]
  0250b	52		 push	 edx
  0250c	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  02510	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  02514	50		 push	 eax
  02515	0f bf c1	 movsx	 eax, cx
  02518	25 ff 01 00 80	 and	 eax, -2147483137	; 800001ffH
  0251d	79 07		 jns	 SHORT $LN345@CGUseItemR
  0251f	48		 dec	 eax
  02520	0d 00 fe ff ff	 or	 eax, -512		; fffffe00H
  02525	40		 inc	 eax
$LN345@CGUseItemR:
  02526	50		 push	 eax
  02527	66 c1 f9 09	 sar	 cx, 9
  0252b	0f b6 c1	 movzx	 eax, cl
  0252e	50		 push	 eax
  0252f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02534	03 c7		 add	 eax, edi
  02536	50		 push	 eax
  02537	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAUOBJECTSTRUCT@@EEEAAG@Z ; gObjMagicAdd
  0253c	83 c4 14	 add	 esp, 20			; 00000014H
  0253f	89 85 dc fe ff
	ff		 mov	 DWORD PTR _addskill$1$[ebp], eax

; 13825: 
; 13826: 				if ( addskill >= 0 )

  02545	85 c0		 test	 eax, eax
  02547	78 35		 js	 SHORT $LN138@CGUseItemR

; 13827: 				{
; 13828: 					gObjInventoryItemSet(aIndex, pos, -1);

  02549	68 ff 00 00 00	 push	 255			; 000000ffH
  0254e	56		 push	 esi
  0254f	53		 push	 ebx
  02550	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 13829: 					GCMagicListOneSend(aIndex, addskill, skillnumber, citem->m_Level, 0, 0);

  02555	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
  0255b	6a 00		 push	 0
  0255d	6a 00		 push	 0
  0255f	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  02563	50		 push	 eax
  02564	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _skillnumber$1[ebp]
  0256a	ff b5 dc fe ff
	ff		 push	 DWORD PTR _addskill$1$[ebp]
  02570	53		 push	 ebx
  02571	e8 00 00 00 00	 call	 ?GCMagicListOneSend@@YAXHDGEEE@Z ; GCMagicListOneSend
  02576	83 c4 24	 add	 esp, 36			; 00000024H

; 13830: 					gObj[aIndex].pInventory[pos].Clear();
; 13831: 					GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13832: 				}
; 13833: 				else

  02579	e9 5c 04 00 00	 jmp	 $LN353@CGUseItemR
$LN138@CGUseItemR:

; 13834: 				{
; 13835: 					GCInventoryItemDeleteSend(aIndex, -1, 1);

  0257e	6a 01		 push	 1
  02580	68 ff 00 00 00	 push	 255			; 000000ffH

; 13836: 				}
; 13837: 			}

  02585	e9 a3 f8 ff ff	 jmp	 $LN359@CGUseItemR
$LN112@CGUseItemR:

; 13665: 		{
; 13666: 			switch( citem->m_Type)

  0258a	0f bf c2	 movsx	 eax, dx
  0258d	2d 3f 1c 00 00	 sub	 eax, 7231		; 00001c3fH
  02592	74 5d		 je	 SHORT $LN113@CGUseItemR
  02594	83 e8 01	 sub	 eax, 1
  02597	0f 85 13 04 00
	00		 jne	 $LN35@CGUseItemR

; 13671: 				break;
; 13672: 			case ITEMGET(14,64):
; 13673: 				gObj[aIndex].Mana = gObj[aIndex].MaxMana + gObj[aIndex].AddMana;

  0259d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  025a2	66 0f 6e 84 07
	28 01 00 00	 movd	 xmm0, DWORD PTR [edi+eax+296]
  025ab	0f 5b c0	 cvtdq2ps xmm0, xmm0
  025ae	f3 0f 58 84 07
	f0 00 00 00	 addss	 xmm0, DWORD PTR [edi+eax+240]
  025b7	f3 0f 11 84 07
	ec 00 00 00	 movss	 DWORD PTR [edi+eax+236], xmm0

; 13674: 				GCManaSend(aIndex,(WORD)gObj[aIndex].Mana,0xFF,0,gObj[aIndex].BP);

  025c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  025c6	0f b7 84 0f 04
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+260]
  025ce	50		 push	 eax
  025cf	f3 0f 2c 84 0f
	ec 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+236]
  025d8	6a 00		 push	 0
  025da	68 ff 00 00 00	 push	 255			; 000000ffH
  025df	0f b7 c0	 movzx	 eax, ax
  025e2	50		 push	 eax
  025e3	53		 push	 ebx
  025e4	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  025e9	83 c4 14	 add	 esp, 20			; 00000014H

; 13675: 				break;
; 13676: 			}
; 13677: 
; 13678: 			if(gObjSearchItemMinus(&gObj[aIndex],pos,1) == FALSE)
; 13679: 			{
; 13680: 				gObjInventoryItemSet(aIndex,pos,0xFF);
; 13681: 				gObj[aIndex].pInventory[pos].Clear();
; 13682: 				GCInventoryItemDeleteSend(aIndex,pos,1);
; 13683: 			}
; 13684: 		}

  025ec	e9 bf 03 00 00	 jmp	 $LN35@CGUseItemR
$LN113@CGUseItemR:

; 13667: 			{
; 13668: 			case ITEMGET(14,63):
; 13669: 				gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  025f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  025f6	66 0f 6e 84 07
	24 01 00 00	 movd	 xmm0, DWORD PTR [edi+eax+292]
  025ff	0f 5b c0	 cvtdq2ps xmm0, xmm0
  02602	f3 0f 58 84 07
	dc 00 00 00	 addss	 xmm0, DWORD PTR [edi+eax+220]
  0260b	f3 0f 11 84 07
	d8 00 00 00	 movss	 DWORD PTR [edi+eax+216], xmm0

; 13670: 				GCReFillSend(aIndex,(WORD)gObj[aIndex].Life,0xFF,0,gObj[aIndex].iShield);

  02614	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0261a	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  02622	50		 push	 eax
  02623	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  0262c	6a 00		 push	 0
  0262e	68 ff 00 00 00	 push	 255			; 000000ffH
  02633	0f b7 c0	 movzx	 eax, ax
  02636	50		 push	 eax
  02637	53		 push	 ebx
  02638	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  0263d	83 c4 14	 add	 esp, 20			; 00000014H

; 13675: 				break;
; 13676: 			}
; 13677: 
; 13678: 			if(gObjSearchItemMinus(&gObj[aIndex],pos,1) == FALSE)
; 13679: 			{
; 13680: 				gObjInventoryItemSet(aIndex,pos,0xFF);
; 13681: 				gObj[aIndex].pInventory[pos].Clear();
; 13682: 				GCInventoryItemDeleteSend(aIndex,pos,1);
; 13683: 			}
; 13684: 		}

  02640	e9 6b 03 00 00	 jmp	 $LN35@CGUseItemR
$LN40@CGUseItemR:

; 13330: 				 citem->m_Type == ITEMGET(14,6)  )
; 13331: 		{
; 13332: 			int tMana = (citem->m_Value*10) - (gObj[aIndex].Level);	// #formula

  02645	8b 40 70	 mov	 eax, DWORD PTR [eax+112]
  02648	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0264e	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  02651	0f bf 8c 0f 96
	00 00 00	 movsx	 ecx, WORD PTR [edi+ecx+150]
  02659	03 c0		 add	 eax, eax
  0265b	2b c1		 sub	 eax, ecx

; 13333: 
; 13334: 			if ( tMana < 0 )

  0265d	b9 00 00 00 00	 mov	 ecx, 0
  02662	0f 48 c1	 cmovs	 eax, ecx

; 13335: 			{
; 13336: 				tMana=0;
; 13337: 			}
; 13338: 
; 13339: 			switch ( citem->m_Type )

  02665	0f bf ca	 movsx	 ecx, dx
  02668	89 85 ec fe ff
	ff		 mov	 DWORD PTR _tMana$1$[ebp], eax
  0266e	81 e9 04 1c 00
	00		 sub	 ecx, 7172		; 00001c04H
  02674	74 5d		 je	 SHORT $LN42@CGUseItemR
  02676	83 e9 01	 sub	 ecx, 1
  02679	74 2f		 je	 SHORT $LN43@CGUseItemR
  0267b	83 e9 01	 sub	 ecx, 1
  0267e	0f 85 90 00 00
	00		 jne	 $LN4@CGUseItemR

; 13347: 				case ITEMGET(14,6):	// Large Mana Potion
; 13348: 					tMana += ((int)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana))*40/100; 

  02684	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02689	66 0f 6e 84 07
	28 01 00 00	 movd	 xmm0, DWORD PTR [edi+eax+296]
  02692	0f 5b c0	 cvtdq2ps xmm0, xmm0
  02695	f3 0f 58 84 07
	f0 00 00 00	 addss	 xmm0, DWORD PTR [edi+eax+240]
  0269e	f3 0f 2c c0	 cvttss2si eax, xmm0
  026a2	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  026a5	c1 e1 03	 shl	 ecx, 3
  026a8	eb 4d		 jmp	 SHORT $LN349@CGUseItemR
$LN43@CGUseItemR:

; 13343: 					break;
; 13344: 				case ITEMGET(14,5):	// Mana Potion
; 13345: 					tMana += ((int)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana))*30/100; 

  026aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  026af	66 0f 6e 84 07
	28 01 00 00	 movd	 xmm0, DWORD PTR [edi+eax+296]
  026b8	0f 5b c0	 cvtdq2ps xmm0, xmm0
  026bb	f3 0f 58 84 07
	f0 00 00 00	 addss	 xmm0, DWORD PTR [edi+eax+240]
  026c4	f3 0f 2c c0	 cvttss2si eax, xmm0
  026c8	8b c8		 mov	 ecx, eax
  026ca	c1 e1 04	 shl	 ecx, 4
  026cd	2b c8		 sub	 ecx, eax
  026cf	03 c9		 add	 ecx, ecx

; 13346: 					break;

  026d1	eb 24		 jmp	 SHORT $LN349@CGUseItemR
$LN42@CGUseItemR:

; 13340: 			{
; 13341: 				case ITEMGET(14,4):	// Small Mana Potion
; 13342: 					tMana += ((int)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana))*20/100; 

  026d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  026d8	66 0f 6e 84 07
	28 01 00 00	 movd	 xmm0, DWORD PTR [edi+eax+296]
  026e1	0f 5b c0	 cvtdq2ps xmm0, xmm0
  026e4	f3 0f 58 84 07
	f0 00 00 00	 addss	 xmm0, DWORD PTR [edi+eax+240]
  026ed	f3 0f 2c c0	 cvttss2si eax, xmm0
  026f1	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  026f4	c1 e1 02	 shl	 ecx, 2
$LN349@CGUseItemR:
  026f7	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  026fc	f7 e9		 imul	 ecx
  026fe	c1 fa 05	 sar	 edx, 5
  02701	8b c2		 mov	 eax, edx
  02703	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  02706	03 c2		 add	 eax, edx
  02708	01 85 ec fe ff
	ff		 add	 DWORD PTR _tMana$1$[ebp], eax
  0270e	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _tMana$1$[ebp]
$LN4@CGUseItemR:

; 13349: 					break;
; 13350: 			}
; 13351: 
; 13352: 			gObj[aIndex].Mana += tMana;

  02714	66 0f 6e c0	 movd	 xmm0, eax
  02718	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0271d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  02720	f3 0f 58 84 07
	ec 00 00 00	 addss	 xmm0, DWORD PTR [edi+eax+236]
  02729	f3 0f 11 84 07
	ec 00 00 00	 movss	 DWORD PTR [edi+eax+236], xmm0

; 13353: 
; 13354: 			if ( gObj[aIndex].Mana > (gObj[aIndex].MaxMana+gObj[aIndex].AddMana-1.0f) )

  02732	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02738	66 0f 6e 94 0f
	28 01 00 00	 movd	 xmm2, DWORD PTR [edi+ecx+296]
  02741	f3 0f 10 84 0f
	ec 00 00 00	 movss	 xmm0, DWORD PTR [edi+ecx+236]
  0274a	0f 5b d2	 cvtdq2ps xmm2, xmm2
  0274d	f3 0f 58 94 0f
	f0 00 00 00	 addss	 xmm2, DWORD PTR [edi+ecx+240]
  02756	0f 28 ca	 movaps	 xmm1, xmm2
  02759	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3f800000
  02761	0f 2f c1	 comiss	 xmm0, xmm1
  02764	76 0f		 jbe	 SHORT $LN45@CGUseItemR

; 13355: 				gObj[aIndex].Mana = gObj[aIndex].MaxMana+gObj[aIndex].AddMana;

  02766	f3 0f 11 94 0f
	ec 00 00 00	 movss	 DWORD PTR [edi+ecx+236], xmm2
  0276f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN45@CGUseItemR:

; 13356: 			
; 13357: 			GCManaSend(aIndex, (WORD)gObj[aIndex].Mana, 0xFF, 0, gObj[aIndex].BP);

  02775	0f b7 84 0f 04
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+260]
  0277d	50		 push	 eax
  0277e	f3 0f 2c 84 0f
	ec 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+236]
  02787	6a 00		 push	 0
  02789	68 ff 00 00 00	 push	 255			; 000000ffH
  0278e	0f b7 c0	 movzx	 eax, ax
  02791	50		 push	 eax
  02792	53		 push	 ebx
  02793	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend

; 13358: 
; 13359: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  02798	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0279d	6a 01		 push	 1
  0279f	03 c7		 add	 eax, edi
  027a1	56		 push	 esi
  027a2	50		 push	 eax
  027a3	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  027a8	83 c4 20	 add	 esp, 32			; 00000020H

; 13360: 			{
; 13361: 				gObjInventoryItemSet(aIndex, pos, -1);
; 13362: 				gObj[aIndex].pInventory[pos].Clear();
; 13363: 				GCInventoryItemDeleteSend(aIndex, pos, 1);
; 13364: 			}
; 13365: 		}

  027ab	e9 13 02 00 00	 jmp	 $LN351@CGUseItemR
$LN22@CGUseItemR:

; 13249: 			 citem->m_Type == ITEMGET(14,3) )
; 13250: 		{
; 13251: 			int tLife = (citem->m_Value*10) - (gObj[aIndex].Level*2);	// #formula

  027b0	8b 40 70	 mov	 eax, DWORD PTR [eax+112]
  027b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  027b9	89 8d f8 fe ff
	ff		 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$10[ebp], ecx
  027bf	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  027c2	0f bf 8c 0f 96
	00 00 00	 movsx	 ecx, WORD PTR [edi+ecx+150]
  027ca	2b c1		 sub	 eax, ecx

; 13252: 
; 13253: 			if ( tLife <  0 )

  027cc	b9 00 00 00 00	 mov	 ecx, 0
  027d1	03 c0		 add	 eax, eax

; 13254: 			{
; 13255: 				tLife = 0;
; 13256: 			}
; 13257: 
; 13258: 			int nAddRate=0;

  027d3	89 8d ec fe ff
	ff		 mov	 DWORD PTR _nAddRate$1$[ebp], ecx
  027d9	0f 48 c1	 cmovs	 eax, ecx
  027dc	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _tLife$1$[ebp], eax

; 13259: 
; 13260: 			switch ( citem->m_Type )

  027e2	0f bf c2	 movsx	 eax, dx
  027e5	05 00 e4 ff ff	 add	 eax, -7168		; ffffe400H
  027ea	83 f8 03	 cmp	 eax, 3
  027ed	77 27		 ja	 SHORT $LN2@CGUseItemR
  027ef	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN375@CGUseItemR[eax*4]
$LN24@CGUseItemR:

; 13261: 			{
; 13262: 				case ITEMGET(14,0):	// Apple
; 13263: 					nAddRate = 10;

  027f6	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH

; 13264: 					break;

  027fb	eb 13		 jmp	 SHORT $LN350@CGUseItemR
$LN25@CGUseItemR:

; 13265: 				case ITEMGET(14,1):	// 
; 13266: 					nAddRate = 20;

  027fd	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H

; 13267: 					break;

  02802	eb 0c		 jmp	 SHORT $LN350@CGUseItemR
$LN26@CGUseItemR:

; 13268: 				case ITEMGET(14,2):	// 
; 13269: 					nAddRate = 30;

  02804	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH

; 13270: 					break;

  02809	eb 05		 jmp	 SHORT $LN350@CGUseItemR
$LN27@CGUseItemR:

; 13271: 				case ITEMGET(14,3):	// 
; 13272: 					nAddRate = 40;

  0280b	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
$LN350@CGUseItemR:
  02810	89 8d ec fe ff
	ff		 mov	 DWORD PTR _nAddRate$1$[ebp], ecx
$LN2@CGUseItemR:

; 13273: 					break;
; 13274: 			}
; 13275: 
; 13276: 			if ( citem->m_Level == 1 )	// #formula

  02816	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
  0281c	66 83 78 08 01	 cmp	 WORD PTR [eax+8], 1
  02821	75 09		 jne	 SHORT $LN28@CGUseItemR

; 13277: 			{
; 13278: 				nAddRate += 5;

  02823	83 c1 05	 add	 ecx, 5
  02826	89 8d ec fe ff
	ff		 mov	 DWORD PTR _nAddRate$1$[ebp], ecx
$LN28@CGUseItemR:

; 13279: 			}
; 13280: 
; 13281: 			tLife += ((int)gObj[aIndex].MaxLife * nAddRate) / 100;	// #formula

  0282c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$10[ebp]
  02832	f3 0f 2c 8c 07
	dc 00 00 00	 cvttss2si ecx, DWORD PTR [edi+eax+220]
  0283b	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  02840	0f af 8d ec fe
	ff ff		 imul	 ecx, DWORD PTR _nAddRate$1$[ebp]
  02847	f7 e9		 imul	 ecx

; 13282: 
; 13283: 			if ( citem->m_Type == ITEMGET(14,0) )

  02849	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _citem$1$[ebp]
  0284f	c1 fa 05	 sar	 edx, 5
  02852	8b c2		 mov	 eax, edx
  02854	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  02857	03 c2		 add	 eax, edx
  02859	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _tLife$1$[ebp]
  0285f	03 d0		 add	 edx, eax
  02861	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  02865	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _tLife$1$[ebp], edx
  0286b	66 3b 85 e8 fe
	ff ff		 cmp	 ax, WORD PTR tv1264[ebp]
  02872	75 3a		 jne	 SHORT $LN343@CGUseItemR

; 13284: 			{
; 13285: 				if ( citem->m_Level < 2 )

  02874	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  02878	66 83 f8 02	 cmp	 ax, 2

; 13286: 				{
; 13287: 					gObj[aIndex].FillLife += tLife;

  0287c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$10[ebp]
  02882	7d 30		 jge	 SHORT $LN30@CGUseItemR
  02884	66 0f 6e c2	 movd	 xmm0, edx
  02888	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 13288: 					tLife = 0;

  0288b	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _tLife$1$[ebp], 0
  02895	f3 0f 58 84 07
	e4 00 00 00	 addss	 xmm0, DWORD PTR [edi+eax+228]
  0289e	f3 0f 11 84 07
	e4 00 00 00	 movss	 DWORD PTR [edi+eax+228], xmm0
  028a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  028ac	eb 06		 jmp	 SHORT $LN30@CGUseItemR
$LN343@CGUseItemR:
  028ae	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$10[ebp]
$LN30@CGUseItemR:

; 13289: 				}
; 13290: 			}
; 13291: 
; 13292: 			if ( gObj[aIndex].FillLife > 0.0f )

  028b4	f3 0f 10 8c 07
	e4 00 00 00	 movss	 xmm1, DWORD PTR [edi+eax+228]
  028bd	0f 57 c0	 xorps	 xmm0, xmm0
  028c0	0f 2f c8	 comiss	 xmm1, xmm0
  028c3	0f 86 87 00 00
	00		 jbe	 $LN31@CGUseItemR

; 13293: 			{
; 13294: 				gObj[aIndex].Life += gObj[aIndex].FillLife;

  028c9	f3 0f 58 8c 07
	d8 00 00 00	 addss	 xmm1, DWORD PTR [edi+eax+216]
  028d2	f3 0f 11 8c 07
	d8 00 00 00	 movss	 DWORD PTR [edi+eax+216], xmm1

; 13295: 
; 13296: 				if ( gObj[aIndex].Life > (gObj[aIndex].MaxLife +gObj[aIndex].AddLife) )

  028db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  028e1	66 0f 6e 8c 0f
	24 01 00 00	 movd	 xmm1, DWORD PTR [edi+ecx+292]
  028ea	f3 0f 10 84 0f
	d8 00 00 00	 movss	 xmm0, DWORD PTR [edi+ecx+216]
  028f3	0f 5b c9	 cvtdq2ps xmm1, xmm1
  028f6	f3 0f 58 8c 0f
	dc 00 00 00	 addss	 xmm1, DWORD PTR [edi+ecx+220]
  028ff	0f 2f c1	 comiss	 xmm0, xmm1
  02902	76 1f		 jbe	 SHORT $LN32@CGUseItemR

; 13297: 				{
; 13298: 					gObj[aIndex].Life = gObj[aIndex].MaxLife + gObj[aIndex].AddLife;

  02904	f3 0f 11 8c 0f
	d8 00 00 00	 movss	 DWORD PTR [edi+ecx+216], xmm1

; 13299: 					gObj[aIndex].FillLife = 0;

  0290d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02912	c7 84 07 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax+228], 0
  0291d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN32@CGUseItemR:

; 13300: 				}
; 13301: 
; 13302: 				GCReFillSend(gObj[aIndex].m_Index,(WORD)gObj[aIndex].Life, 0xFF, FALSE, gObj[aIndex].iShield);

  02923	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  0292b	50		 push	 eax
  0292c	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  02935	6a 00		 push	 0
  02937	68 ff 00 00 00	 push	 255			; 000000ffH
  0293c	0f b7 c0	 movzx	 eax, ax
  0293f	50		 push	 eax
  02940	ff 34 0f	 push	 DWORD PTR [edi+ecx]
  02943	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  02948	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0294d	83 c4 14	 add	 esp, 20			; 00000014H
$LN31@CGUseItemR:

; 13303: 			}
; 13304: 
; 13305: 			gObj[aIndex].FillLifeMax = (float)tLife;
; 13306: 			gObj[aIndex].FillLife = (float)tLife;
; 13307: 
; 13308: 			if ( citem->m_Type == ITEMGET(14,0) && citem->m_Level < 2 )

  02950	66 0f 6e 85 f0
	fe ff ff	 movd	 xmm0, DWORD PTR _tLife$1$[ebp]
  02958	b9 00 1c 00 00	 mov	 ecx, 7168		; 00001c00H
  0295d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  02960	f3 0f 11 84 07
	e8 00 00 00	 movss	 DWORD PTR [edi+eax+232], xmm0
  02969	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0296e	f3 0f 11 84 07
	e4 00 00 00	 movss	 DWORD PTR [edi+eax+228], xmm0
  02977	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _citem$1$[ebp]
  0297d	66 39 48 06	 cmp	 WORD PTR [eax+6], cx
  02981	75 16		 jne	 SHORT $LN33@CGUseItemR
  02983	66 83 78 08 02	 cmp	 WORD PTR [eax+8], 2
  02988	7d 0f		 jge	 SHORT $LN33@CGUseItemR

; 13309: 			{
; 13310: 				gObj[aIndex].FillLifeCount = 0;

  0298a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0298f	c6 84 07 fb 00
	00 00 00	 mov	 BYTE PTR [edi+eax+251], 0
  02997	eb 17		 jmp	 SHORT $LN35@CGUseItemR
$LN33@CGUseItemR:

; 13311: 			}
; 13312: 			else if ( citem->m_Level == 1 )

  02999	66 83 78 08 01	 cmp	 WORD PTR [eax+8], 1
  0299e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  029a3	0f 95 c1	 setne	 cl
  029a6	80 c1 02	 add	 cl, 2
  029a9	88 8c 07 fb 00
	00 00		 mov	 BYTE PTR [edi+eax+251], cl
$LN35@CGUseItemR:

; 13313: 			{
; 13314: 				gObj[aIndex].FillLifeCount = 2;
; 13315: 			}
; 13316: 			else
; 13317: 			{
; 13318: 				gObj[aIndex].FillLifeCount = 3;
; 13319: 			}
; 13320: 
; 13321: 			if ( !gObjSearchItemMinus(&gObj[aIndex], pos, 1) )

  029b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  029b5	6a 01		 push	 1
  029b7	03 c7		 add	 eax, edi
  029b9	56		 push	 esi
  029ba	50		 push	 eax
  029bb	e8 00 00 00 00	 call	 ?gObjSearchItemMinus@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjSearchItemMinus
  029c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN351@CGUseItemR:
  029c3	85 c0		 test	 eax, eax
  029c5	0f 85 90 00 00
	00		 jne	 $LN16@CGUseItemR

; 13322: 			{
; 13323: 				gObjInventoryItemSet(aIndex, pos, -1);

  029cb	68 ff 00 00 00	 push	 255			; 000000ffH
  029d0	56		 push	 esi
  029d1	53		 push	 ebx
  029d2	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  029d7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN353@CGUseItemR:

; 13324: 				gObj[aIndex].pInventory[pos].Clear();

  029da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  029df	8b 8c 07 c0 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4544]
  029e6	03 8d f4 fe ff
	ff		 add	 ecx, DWORD PTR tv2050[ebp]
  029ec	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 13325: 				GCInventoryItemDeleteSend(aIndex, pos, 1);

  029f1	6a 01		 push	 1
  029f3	56		 push	 esi
  029f4	53		 push	 ebx
  029f5	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  029fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  029fd	5f		 pop	 edi
  029fe	5e		 pop	 esi
  029ff	5b		 pop	 ebx

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  02a00	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02a03	33 cd		 xor	 ecx, ebp
  02a05	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02a0a	8b e5		 mov	 esp, ebp
  02a0c	5d		 pop	 ebp
  02a0d	c3		 ret	 0
$LN15@CGUseItemR:

; 14446: 		}
; 14447: 	}
; 14448: 	else
; 14449: 	{
; 14450: 		GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  02a0e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02a14	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  02a1c	50		 push	 eax
  02a1d	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  02a26	6a 01		 push	 1
  02a28	68 fd 00 00 00	 push	 253			; 000000fdH
  02a2d	0f b7 c0	 movzx	 eax, ax
  02a30	50		 push	 eax
  02a31	53		 push	 ebx
  02a32	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 14451: 		LogAdd("error-L3 : %s return %s %d %d",

  02a37	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  02a3c	56		 push	 esi
  02a3d	68 74 38 00 00	 push	 14452			; 00003874H
  02a42	83 c0 5d	 add	 eax, 93			; 0000005dH
  02a45	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  02a4a	03 c7		 add	 eax, edi
  02a4c	50		 push	 eax
  02a4d	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FLPOFOKL@error?9L3?5?3?5?$CFs?5return?5?$CFs?5?$CFd?5?$CFd?$AA@
$LN346@CGUseItemR:
  02a52	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  02a58	83 c4 28	 add	 esp, 40			; 00000028H
$LN16@CGUseItemR:

; 14452: 			gObj[aIndex].Name, __FILE__,__LINE__, pos);
; 14453: 	}
; 14454: }

  02a5b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02a5e	5f		 pop	 edi
  02a5f	5e		 pop	 esi
  02a60	33 cd		 xor	 ecx, ebp
  02a62	5b		 pop	 ebx
  02a63	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02a68	8b e5		 mov	 esp, ebp
  02a6a	5d		 pop	 ebp
  02a6b	c3		 ret	 0
$LN375@CGUseItemR:
  02a6c	00 00 00 00	 DD	 $LN24@CGUseItemR
  02a70	00 00 00 00	 DD	 $LN25@CGUseItemR
  02a74	00 00 00 00	 DD	 $LN26@CGUseItemR
  02a78	00 00 00 00	 DD	 $LN27@CGUseItemR
?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z ENDP		; CGUseItemRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?ObjectMapJoinPositionSend@@YAXF@Z
_TEXT	SEGMENT
_pObject$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?ObjectMapJoinPositionSend@@YAXF@Z PROC			; ObjectMapJoinPositionSend, COMDAT

; 13076: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	0f b7 5d 08	 movzx	 ebx, WORD PTR _aIndex$[ebp]

; 13077: 	PMSG_USERMAPJOIN pObject;
; 13078: 	
; 13079: 	PHeadSubSetB((LPBYTE)&pObject, 0xF3, 0x03, sizeof(pObject));

  00015	8d 45 f0	 lea	 eax, DWORD PTR _pObject$[ebp]
  00018	6a 0a		 push	 10			; 0000000aH
  0001a	6a 03		 push	 3
  0001c	68 f3 00 00 00	 push	 243			; 000000f3H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 13080: 	pObject.NumberH = SET_NUMBERH(aIndex);

  00027	0f bf d3	 movsx	 edx, bx

; 13081: 	pObject.NumberL = SET_NUMBERL(aIndex);
; 13082: 	pObject.X = gObj[aIndex].X;

  0002a	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00030	8b c2		 mov	 eax, edx
  00032	c1 e8 08	 shr	 eax, 8
  00035	88 45 f4	 mov	 BYTE PTR _pObject$[ebp+4], al
  00038	88 5d f5	 mov	 BYTE PTR _pObject$[ebp+5], bl
  0003b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00041	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  00048	88 45 f6	 mov	 BYTE PTR _pObject$[ebp+6], al

; 13083: 	pObject.Y = gObj[aIndex].Y;

  0004b	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  00052	88 45 f7	 mov	 BYTE PTR _pObject$[ebp+7], al

; 13084: 	pObject.MapNumber = gObj[aIndex].MapNumber;

  00055	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  0005c	88 45 f8	 mov	 BYTE PTR _pObject$[ebp+8], al

; 13085: 	pObject.Dir = gObj[aIndex].Dir;

  0005f	0f b6 81 22 01
	00 00		 movzx	 eax, BYTE PTR [ecx+290]
  00066	88 45 f9	 mov	 BYTE PTR _pObject$[ebp+9], al

; 13086: 
; 13087: 	DataSend(aIndex, (LPBYTE)&pObject, pObject.h.size);

  00069	0f b6 45 f1	 movzx	 eax, BYTE PTR _pObject$[ebp+1]
  0006d	50		 push	 eax
  0006e	8d 45 f0	 lea	 eax, DWORD PTR _pObject$[ebp]
  00071	50		 push	 eax
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 13088: }

  00078	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0007e	33 cd		 xor	 ecx, ebp
  00080	5b		 pop	 ebx
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?ObjectMapJoinPositionSend@@YAXF@Z ENDP			; ObjectMapJoinPositionSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z PROC ; CGDurationMagicRecv, COMDAT

; 12992: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 12993: 	CMagicInf * lpMagic;
; 12994: 	LPOBJ lpObj = &gObj[aIndex];

  00004	69 75 0c 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  0000b	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 12995: 
; 12996: 	if ( lpObj->Teleport )

  00011	80 be 88 05 00
	00 00		 cmp	 BYTE PTR [esi+1416], 0
  00018	0f 85 2d 01 00
	00		 jne	 $LN14@CGDuration

; 12997: 	{
; 12998: 		return;
; 12999: 	}
; 13000: 
; 13001: 	int MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH,lpMsg->MagicNumberL);

  0001e	53		 push	 ebx
  0001f	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00022	57		 push	 edi
  00023	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00027	66 c1 e0 08	 shl	 ax, 8
  0002b	0f b7 c8	 movzx	 ecx, ax
  0002e	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  00032	0b c8		 or	 ecx, eax

; 13002: 
; 13003: 	if ( gObj[aIndex].Type == OBJ_USER )

  00034	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1

; 13004: 	{
; 13005: 		lpMagic = gObjGetMagicSearch(lpObj, MagicNumber);

  00038	51		 push	 ecx
  00039	56		 push	 esi
  0003a	75 07		 jne	 SHORT $LN3@CGDuration
  0003c	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch

; 13006: 	}
; 13007: 	else

  00041	eb 05		 jmp	 SHORT $LN19@CGDuration
$LN3@CGDuration:

; 13008: 	{
; 13009: 		lpMagic = gObjGetMagic( lpObj, MagicNumber);

  00043	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
$LN19@CGDuration:
  00048	8b f8		 mov	 edi, eax
  0004a	83 c4 08	 add	 esp, 8

; 13010: 	}
; 13011: 
; 13012: 	if ( lpMagic == NULL )

  0004d	85 ff		 test	 edi, edi
  0004f	0f 84 f4 00 00
	00		 je	 $LN16@CGDuration

; 13013: 	{
; 13014: 		return;
; 13015: 	}
; 13016: 
; 13017: 	if ( lpObj->Type == OBJ_USER )

  00055	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00059	75 60		 jne	 SHORT $LN8@CGDuration

; 13018: 	{
; 13019: 		if ( MagicDamageC.CheckStatus(lpMagic->m_Skill, lpObj->GuildStatus) == FALSE )

  0005b	ff b6 28 06 00
	00		 push	 DWORD PTR [esi+1576]
  00061	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00066	ff 77 08	 push	 DWORD PTR [edi+8]
  00069	e8 00 00 00 00	 call	 ?CheckStatus@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckStatus
  0006e	85 c0		 test	 eax, eax
  00070	75 18		 jne	 SHORT $LN7@CGDuration
  00072	5f		 pop	 edi
  00073	5b		 pop	 ebx
  00074	5e		 pop	 esi

; 13020: 		{
; 13021: 			LogAddC(2, "[0x1E] CGDurationMagicRecv() - Invalid Status");	// #warning maybe protocol here change

  00075	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _aIndex$[ebp], OFFSET ??_C@_0CO@PPJIEIFO@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
  0007c	c7 45 08 02 00
	00 00		 mov	 DWORD PTR _lpMsg$[ebp], 2

; 13058: }

  00083	5d		 pop	 ebp

; 13020: 		{
; 13021: 			LogAddC(2, "[0x1E] CGDurationMagicRecv() - Invalid Status");	// #warning maybe protocol here change

  00084	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
$LN7@CGDuration:

; 13022: 			return;
; 13023: 		}
; 13024: 
; 13025: 		if ( MagicDamageC.CheckKillCount(lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )

  0008a	0f b6 86 64 20
	00 00		 movzx	 eax, BYTE PTR [esi+8292]
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00096	50		 push	 eax
  00097	ff 77 08	 push	 DWORD PTR [edi+8]
  0009a	e8 00 00 00 00	 call	 ?CheckKillCount@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckKillCount
  0009f	85 c0		 test	 eax, eax
  000a1	79 18		 jns	 SHORT $LN8@CGDuration
  000a3	5f		 pop	 edi
  000a4	5b		 pop	 ebx
  000a5	5e		 pop	 esi

; 13026: 		{
; 13027: 			LogAddC(2, "[0x1E] CGDurationMagicRecv() - Invalid KillCount");

  000a6	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _aIndex$[ebp], OFFSET ??_C@_0DB@CEFMOKDJ@?$FL0x1E?$FN?5CGDurationMagicRecv?$CI?$CJ?5?9?5I@
  000ad	c7 45 08 02 00
	00 00		 mov	 DWORD PTR _lpMsg$[ebp], 2

; 13058: }

  000b4	5d		 pop	 ebp

; 13026: 		{
; 13027: 			LogAddC(2, "[0x1E] CGDurationMagicRecv() - Invalid KillCount");

  000b5	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
$LN8@CGDuration:

; 13028: 			return;
; 13029: 		}
; 13030: 	}
; 13031: 
; 13032: 	lpObj->UseMagicNumber = 0;
; 13033: 
; 13034: 	if ( lpMagic->m_Skill != 24 || lpMagic->m_Skill != 0xEB)
; 13035: 	{
; 13036: 		if ( !gObjUseSkill.SpeedHackCheck(aIndex))

  000bb	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  000be	33 c0		 xor	 eax, eax
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000c5	66 89 86 ae 06
	00 00		 mov	 WORD PTR [esi+1710], ax
  000cc	e8 00 00 00 00	 call	 ?SpeedHackCheck@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SpeedHackCheck
  000d1	85 c0		 test	 eax, eax
  000d3	74 74		 je	 SHORT $LN16@CGDuration

; 13037: 		{
; 13038: 			return;
; 13039: 		}
; 13040: 	}
; 13041: 
; 13042: 	if ( !gObjUseSkill.EnableSkill(lpMagic->m_Skill) )

  000d5	ff 77 08	 push	 DWORD PTR [edi+8]
  000d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000dd	e8 00 00 00 00	 call	 ?EnableSkill@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::EnableSkill
  000e2	85 c0		 test	 eax, eax
  000e4	74 63		 je	 SHORT $LN16@CGDuration

; 13043: 	{
; 13044: 		return;
; 13045: 	}
; 13046: 
; 13047: 	if ( !gObjUseSkill.CheckWeapon(lpObj,lpMagic->m_Skill) )

  000e6	ff 77 08	 push	 DWORD PTR [edi+8]
  000e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000ee	56		 push	 esi
  000ef	e8 00 00 00 00	 call	 ?CheckWeapon@CObjUseSkill@@QAEHPAUOBJECTSTRUCT@@H@Z ; CObjUseSkill::CheckWeapon
  000f4	85 c0		 test	 eax, eax
  000f6	74 51		 je	 SHORT $LN16@CGDuration

; 13048: 	{
; 13049: 		return;
; 13050: 	}
; 13051: 
; 13052: 	int aTargetIndex = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  000f8	0f b6 43 08	 movzx	 eax, BYTE PTR [ebx+8]
  000fc	66 c1 e0 08	 shl	 ax, 8

; 13053: 
; 13054: 	gObjUseSkill.UseSkill(aIndex, lpMagic,lpMsg->X, lpMsg->Y, lpMsg->Dir, lpMsg->TargetPos, aTargetIndex);

  00100	0f b7 c8	 movzx	 ecx, ax
  00103	0f b6 43 0a	 movzx	 eax, BYTE PTR [ebx+10]
  00107	0b c8		 or	 ecx, eax
  00109	0f b6 43 0b	 movzx	 eax, BYTE PTR [ebx+11]
  0010d	51		 push	 ecx
  0010e	50		 push	 eax
  0010f	0f b6 43 07	 movzx	 eax, BYTE PTR [ebx+7]
  00113	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00118	50		 push	 eax
  00119	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  0011d	50		 push	 eax
  0011e	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  00122	50		 push	 eax
  00123	57		 push	 edi
  00124	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  00127	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHPAVCMagicInf@@EEEEH@Z ; CObjUseSkill::UseSkill

; 13055: 
; 13056: 	if ( lpMsg->MagicKey )

  0012c	80 7b 0c 00	 cmp	 BYTE PTR [ebx+12], 0
  00130	74 17		 je	 SHORT $LN16@CGDuration

; 13057: 		lpObj->DurMagicKeyChecker.SetDurationTime(lpMsg->MagicKey, GetTickCount());

  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00138	50		 push	 eax
  00139	0f b6 43 0c	 movzx	 eax, BYTE PTR [ebx+12]
  0013d	8d 8e d8 14 00
	00		 lea	 ecx, DWORD PTR [esi+5336]
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z ; TDurMagicKeyChecker::SetDurationTime
$LN16@CGDuration:
  00149	5f		 pop	 edi
  0014a	5b		 pop	 ebx
$LN14@CGDuration:
  0014b	5e		 pop	 esi

; 13058: }

  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ENDP ; CGDurationMagicRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\tdurmagickeychecker.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGBeattackRecv@@YAXPAEHH@Z
_TEXT	SEGMENT
tv1505 = -544						; size = 4
tv1549 = -540						; size = 4
_lpObj$1$ = -536					; size = 4
_lpRecv$GSCopy$1$ = -532				; size = 4
_n$1$ = -528						; size = 4
tv1510 = -528						; size = 4
_aIndex$GSCopy$1$ = -524				; size = 4
tv1504 = -520						; size = 4
_pTargetNumber$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_magic_send$ = 16					; size = 4
?CGBeattackRecv@@YAXPAEHH@Z PROC			; CGBeattackRecv, COMDAT

; 12586: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _lpRecv$[ebp]
  0001b	89 bd ec fd ff
	ff		 mov	 DWORD PTR _lpRecv$GSCopy$1$[ebp], edi
  00021	89 b5 f4 fd ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], esi

; 12587: 	// Set the lpRecv to a Predeterminated Packet
; 12588: 	PMSG_BEATTACK_COUNT * lpCount = (PMSG_BEATTACK_COUNT *)lpRecv;
; 12589: 
; 12590: #if (__ENG__ ==1)
; 12591: 	if ( lpCount->h.headcode != 0xDB )

  00027	80 7f 02 db	 cmp	 BYTE PTR [edi+2], 219	; 000000dbH
  0002b	74 28		 je	 SHORT $LN11@CGBeattack

; 12592: #else
; 12593: 	// KOR PROTOCOL
; 12594: 	// Check the Protocol
; 12595: 	if ( lpCount->h.headcode != 0xD3 )
; 12596: #endif
; 12597: 	{
; 12598: 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  0002d	68 36 31 00 00	 push	 12598			; 00003136H
$LN97@CGBeattack:
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi

; 12983: 	}
; 12984: }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN11@CGBeattack:

; 12599: 		return;
; 12600: 	}
; 12601: 
; 12602: 	// Check if the count is leess than 1
; 12603: 	if ( lpCount->Count < 1 )

  00055	8a 47 04	 mov	 al, BYTE PTR [edi+4]
  00058	3c 01		 cmp	 al, 1
  0005a	73 07		 jae	 SHORT $LN12@CGBeattack

; 12604: 	{
; 12605: 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  0005c	68 3d 31 00 00	 push	 12605			; 0000313dH

; 12606: 		return;

  00061	eb cf		 jmp	 SHORT $LN97@CGBeattack
$LN12@CGBeattack:

; 12607: 	}
; 12608: 
; 12609: 	// Set the Max limitation to 5
; 12610: 	if ( lpCount->Count > 5 )

  00063	3c 05		 cmp	 al, 5
  00065	76 04		 jbe	 SHORT $LN13@CGBeattack

; 12611: 	{
; 12612: 		lpCount->Count = 5;

  00067	c6 47 04 05	 mov	 BYTE PTR [edi+4], 5
$LN13@CGBeattack:

; 12613: 	}
; 12614: 
; 12615: 	int lOfs = sizeof(PMSG_BEATTACK_COUNT);
; 12616: 	CMagicInf * lpMagic;
; 12617: 
; 12618: 	// Set the Start of the Offset
; 12619: 	int tNumber;
; 12620: 	PMSG_BEATTACK * lpMsg;
; 12621: 
; 12622: 	if ( MAKE_NUMBERW(lpCount->MagicNumberH,lpCount->MagicNumberL) == NULL )

  0006b	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  0006f	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00073	66 c1 e1 08	 shl	 cx, 8
  00077	66 0b c8	 or	 cx, ax
  0007a	0f 84 54 09 00
	00		 je	 $LN87@CGBeattack

; 12623: 		return;
; 12624: 
; 12625: 	// Set lpMagic according
; 12626: 	// if aIndex is OBJ_USER
; 12627: 	// or if it is OBJ_MONSTER
; 12628: 	if ( gObj[aIndex].Type == OBJ_USER )

  00080	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00086	53		 push	 ebx
  00087	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  0008d	03 d3		 add	 edx, ebx
  0008f	89 9d e4 fd ff
	ff		 mov	 DWORD PTR tv1549[ebp], ebx
  00095	80 7a 50 01	 cmp	 BYTE PTR [edx+80], 1
  00099	0f 85 80 00 00
	00		 jne	 $LN15@CGBeattack

; 12629: 	{
; 12630: 		BYTE MapAttr = MapC[gObj[aIndex].MapNumber].GetAttr(gObj[aIndex].X,gObj[aIndex].Y);

  0009f	0f b6 82 21 01
	00 00		 movzx	 eax, BYTE PTR [edx+289]
  000a6	50		 push	 eax
  000a7	0f b6 82 20 01
	00 00		 movzx	 eax, BYTE PTR [edx+288]
  000ae	50		 push	 eax
  000af	0f b6 82 23 01
	00 00		 movzx	 eax, BYTE PTR [edx+291]
  000b6	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  000bc	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000c2	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 12631: 
; 12632: 		if( (MapAttr&1) == TRUE )

  000c7	a8 01		 test	 al, 1
  000c9	74 32		 je	 SHORT $LN17@CGBeattack

; 12633: 		{
; 12634: 			gObjSetPosition(aIndex,gObj[aIndex].X,gObj[aIndex].Y);

  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d1	0f b6 84 19 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+ebx+289]
  000d9	50		 push	 eax
  000da	0f b6 84 19 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+ebx+288]
  000e2	50		 push	 eax
  000e3	56		 push	 esi
  000e4	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ec	5b		 pop	 ebx
  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi

; 12983: 	}
; 12984: }

  000ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f2	33 cd		 xor	 ecx, ebp
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN17@CGBeattack:

; 12635: 			return;
; 12636: 		}
; 12637: 		WORD MagicNumber = MAKE_NUMBERW(lpCount->MagicNumberH,lpCount->MagicNumberL);

  000fd	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00101	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00105	66 c1 e1 08	 shl	 cx, 8
  00109	66 0b c8	 or	 cx, ax
  0010c	0f b7 c1	 movzx	 eax, cx

; 12638: 
; 12639: 		lpMagic = gObjGetMagicSearch(&gObj[aIndex], MagicNumber);

  0010f	50		 push	 eax
  00110	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00115	03 c3		 add	 eax, ebx
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch

; 12640: 	}
; 12641: 	else

  0011d	eb 0a		 jmp	 SHORT $LN91@CGBeattack
$LN15@CGBeattack:

; 12642: 	{
; 12643: 		WORD MagicNumber = MAKE_NUMBERW(lpCount->MagicNumberH,lpCount->MagicNumberL);

  0011f	0f b7 c1	 movzx	 eax, cx

; 12644: 		lpMagic = gObjGetMagic(&gObj[aIndex], MagicNumber);

  00122	50		 push	 eax
  00123	52		 push	 edx
  00124	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
$LN91@CGBeattack:
  00129	8b f8		 mov	 edi, eax
  0012b	83 c4 08	 add	 esp, 8

; 12645: 	}
; 12646: 
; 12647: 	// Check if there is Magic
; 12648: 	if ( lpMagic == NULL )

  0012e	85 ff		 test	 edi, edi
  00130	75 29		 jne	 SHORT $LN18@CGBeattack

; 12649: 	{
; 12650: 		LogAdd("error-L3 %s %d", __FILE__, __LINE__);

  00132	68 6a 31 00 00	 push	 12650			; 0000316aH
  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014a	5b		 pop	 ebx
  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi

; 12983: 	}
; 12984: }

  0014d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00150	33 cd		 xor	 ecx, ebp
  00152	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c3		 ret	 0
$LN18@CGBeattack:

; 12651: 		return;
; 12652: 	}
; 12653: 
; 12654: 	// Avoid use Skill of the following types
; 12655: 	if ( lpMagic->m_Skill == AT_SKILL_BLOWOFFURY ||
; 12656: 		 lpMagic->m_Skill == AT_SKILL_STRIKE ||
; 12657: 		 g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == AT_MSKILL_DK_DEATHSTAB1 ||
; 12658: 		 g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == AT_MSKILL_DK_RAGEFULBLOW1 ||
; 12659: 		 lpMagic->m_Skill == AT_MSKILL_DK_RAGEFULBLOW2 ||
; 12660: 		 lpMagic->m_Skill == AT_MSKILL_DK_TWISTINGSLASH2 ||
; 12661: 		 lpMagic->m_Skill == AT_SKILL_WHEEL ||

  0015b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0015e	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00161	0f 84 6c 08 00
	00		 je	 $LN90@CGBeattack
  00167	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0016a	0f 84 63 08 00
	00		 je	 $LN90@CGBeattack
  00170	50		 push	 eax
  00171	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00176	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  0017b	3d 50 01 00 00	 cmp	 eax, 336		; 00000150H
  00180	0f 84 4d 08 00
	00		 je	 $LN90@CGBeattack
  00186	ff 77 08	 push	 DWORD PTR [edi+8]
  00189	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0018e	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00193	3d 4b 01 00 00	 cmp	 eax, 331		; 0000014bH
  00198	0f 84 35 08 00
	00		 je	 $LN90@CGBeattack
  0019e	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  001a1	81 f9 4d 01 00
	00		 cmp	 ecx, 333		; 0000014dH
  001a7	0f 84 26 08 00
	00		 je	 $LN90@CGBeattack
  001ad	81 f9 4c 01 00
	00		 cmp	 ecx, 332		; 0000014cH
  001b3	0f 84 1a 08 00
	00		 je	 $LN90@CGBeattack
  001b9	83 f9 29	 cmp	 ecx, 41			; 00000029H
  001bc	0f 84 11 08 00
	00		 je	 $LN90@CGBeattack
  001c2	81 f9 4a 01 00
	00		 cmp	 ecx, 330		; 0000014aH
  001c8	0f 84 05 08 00
	00		 je	 $LN90@CGBeattack

; 12662: 		 lpMagic->m_Skill == AT_MSKILL_DK_TWISTINGSLASH1 )	
; 12663: 	{
; 12664: 		return;
; 12665: 	}
; 12666: 
; 12667: 	if ( gObj[aIndex].Type == OBJ_USER )

  001ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d4	03 d3		 add	 edx, ebx
  001d6	80 7a 50 01	 cmp	 BYTE PTR [edx+80], 1
  001da	0f 85 e5 00 00
	00		 jne	 $LN21@CGBeattack

; 12668: 	{
; 12669: 		// Check if Player can use Magic
; 12670: 		// Acording to its Class
; 12671: 		if ( MagicDamageC.SkillGetRequireClass(gObj[aIndex].Class,
; 12672: 												gObj[aIndex].ChangeUP,
; 12673: 												gObj[aIndex].ChangeUP2,
; 12674: 												lpMagic->m_Skill) < 1 )

  001e0	0f b6 82 94 00
	00 00		 movzx	 eax, BYTE PTR [edx+148]
  001e7	51		 push	 ecx
  001e8	50		 push	 eax
  001e9	0f b6 82 93 00
	00 00		 movzx	 eax, BYTE PTR [edx+147]
  001f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  001f5	50		 push	 eax
  001f6	0f b7 82 90 00
	00 00		 movzx	 eax, WORD PTR [edx+144]
  001fd	50		 push	 eax
  001fe	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z ; CMagicDamage::SkillGetRequireClass
  00203	83 f8 01	 cmp	 eax, 1
  00206	7d 47		 jge	 SHORT $LN22@CGBeattack

; 12675: 		{
; 12676: 			// It's not his magic [%s][%s] .
; 12677: 			LogAddC(2, lMsg.Get(MSGGET(1, 239)),

  00208	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0020e	ff 77 08	 push	 DWORD PTR [edi+8]
  00211	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00214	03 c3		 add	 eax, ebx
  00216	50		 push	 eax
  00217	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0021a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0021f	03 c3		 add	 eax, ebx
  00221	50		 push	 eax
  00222	68 ef 01 00 00	 push	 495			; 000001efH
  00227	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0022c	50		 push	 eax
  0022d	6a 02		 push	 2
  0022f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 12678: 				gObj[aIndex].AccountID,
; 12679: 				gObj[aIndex].Name,
; 12680: 				lpMagic->m_Skill);	// #error Deathway change on WTFFile
; 12681: 
; 12682: 			gObjUserKill(aIndex);

  00235	56		 push	 esi
  00236	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  0023b	83 c4 18	 add	 esp, 24			; 00000018H
  0023e	5b		 pop	 ebx
  0023f	5f		 pop	 edi
  00240	5e		 pop	 esi

; 12983: 	}
; 12984: }

  00241	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00244	33 cd		 xor	 ecx, ebp
  00246	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0024b	8b e5		 mov	 esp, ebp
  0024d	5d		 pop	 ebp
  0024e	c3		 ret	 0
$LN22@CGBeattack:

; 12683: 			return;
; 12684: 		}
; 12685: 
; 12686: 		// Check the time cast Spell
; 12687: 		// No longer that 8 seconds
; 12688: 		if ( (GetTickCount()- gObj[aIndex].UseMagicTime) > 8000 )

  0024f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0025b	2b 84 1e b0 06
	00 00		 sub	 eax, DWORD PTR [esi+ebx+1712]
  00262	3d 40 1f 00 00	 cmp	 eax, 8000		; 00001f40H
  00267	76 44		 jbe	 SHORT $LN23@CGBeattack

; 12689: 		{
; 12690: 			LogAddC(2, "Too long time passed after casting magic. [%s][%s] (%d)(%d)",

  00269	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00275	2b 84 1e b0 06
	00 00		 sub	 eax, DWORD PTR [esi+ebx+1712]
  0027c	50		 push	 eax
  0027d	ff 77 08	 push	 DWORD PTR [edi+8]
  00280	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00283	03 c3		 add	 eax, ebx
  00285	50		 push	 eax
  00286	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00289	03 c3		 add	 eax, ebx
  0028b	50		 push	 eax
  0028c	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@BJOBFIFA@Too?5long?5time?5passed?5after?5casti@
  00291	6a 02		 push	 2
  00293	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00299	83 c4 18	 add	 esp, 24			; 00000018H
  0029c	5b		 pop	 ebx
  0029d	5f		 pop	 edi
  0029e	5e		 pop	 esi

; 12983: 	}
; 12984: }

  0029f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a2	33 cd		 xor	 ecx, ebp
  002a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a9	8b e5		 mov	 esp, ebp
  002ab	5d		 pop	 ebp
  002ac	c3		 ret	 0
$LN23@CGBeattack:

; 12691: 				gObj[aIndex].AccountID,
; 12692: 				gObj[aIndex].Name,
; 12693: 				lpMagic->m_Skill,
; 12694: 				GetTickCount() - gObj[aIndex].UseMagicTime);
; 12695: 
; 12696: 			return;
; 12697: 		}
; 12698: 
; 12699: 		// Check if user cast to much Spells
; 12700: 		// Npo longer thant 4
; 12701: 		if ( gObj[aIndex].UseMagicCount > 4 )

  002ad	8a 84 1e b4 06
	00 00		 mov	 al, BYTE PTR [esi+ebx+1716]
  002b4	3c 04		 cmp	 al, 4
  002b6	0f 8f 17 07 00
	00		 jg	 $LN90@CGBeattack

; 12702: 		{
; 12703: 			return;
; 12704: 		}
; 12705: 
; 12706: 		gObj[aIndex].UseMagicCount++;

  002bc	fe c0		 inc	 al
  002be	88 84 1e b4 06
	00 00		 mov	 BYTE PTR [esi+ebx+1716], al
$LN21@CGBeattack:

; 12707: 	}
; 12708: 
; 12709: 	if (	lpMagic->m_Skill != AT_SKILL_STORM
; 12710: 		  && lpMagic->m_Skill != AT_SKILL_EVIL
; 12711: 		  && lpMagic->m_Skill != AT_SKILL_HELL
; 12712: 		  && lpMagic->m_Skill != AT_SKILL_BLAST
; 12713: 		  && lpMagic->m_Skill != AT_SKILL_INFERNO
; 12714: 		  && lpMagic->m_Skill != AT_SKILL_FLAME
; 12715: 		  && lpMagic->m_Skill != AT_SKILL_CROSSBOW
; 12716: 		  && lpMagic->m_Skill != AT_SKILL_DEVILFIRE
; 12717: 		  && lpMagic->m_Skill != AT_SKILL_FLASH
; 12718: 		  && lpMagic->m_Skill != AT_SKILL_WHEEL
; 12719: 		  && lpMagic->m_Skill != AT_SKILL_KNIGHTSPEAR
; 12720: 		  && lpMagic->m_Skill != AT_SKILL_STRIKE
; 12721: 		  && lpMagic->m_Skill != AT_SKILL_BLOWOFFURY
; 12722: 		  && lpMagic->m_Skill != AT_SKILL_PENETRATION
; 12723: 		  && lpMagic->m_Skill != AT_SKILL_DEFENSEDOWN
; 12724: 		  && lpMagic->m_Skill != AT_SKILL_FIRESCREAM 
; 12725: 		  // MSKILL
; 12726: 		  && lpMagic->m_Skill != AT_MSKILL_DW_FLAME1
; 12727: 		  && lpMagic->m_Skill != AT_MSKILL_DW_BLAST1
; 12728: 		  && lpMagic->m_Skill != AT_MSKILL_DW_INFERNO1
; 12729: 		  && lpMagic->m_Skill != AT_MSKILL_DW_HELLFIRE1
; 12730: 		  && lpMagic->m_Skill != AT_MSKILL_DW_EVILSPIRIT1
; 12731: 		  && lpMagic->m_Skill != AT_MSKILL_FE_TRIPLESHOT1
; 12732: 		  && lpMagic->m_Skill != AT_MSKILL_FE_TRIPLESHOT2
; 12733: 		  && lpMagic->m_Skill != AT_MSKILL_FE_PENETRATION1
; 12734: 		  && lpMagic->m_Skill != AT_MSKILL_DK_TWISTINGSLASH1
; 12735: 		  && lpMagic->m_Skill != AT_MSKILL_DK_TWISTINGSLASH2
; 12736: 		  && lpMagic->m_Skill != AT_MSKILL_MG_TWISTINGSLASH1
; 12737: 		  && lpMagic->m_Skill != AT_MSKILL_DK_RAGEFULBLOW1
; 12738: 		  && lpMagic->m_Skill != AT_MSKILL_DK_RAGEFULBLOW2
; 12739: 		  && lpMagic->m_Skill != AT_MSKILL_MG_FLAME1
; 12740: 		  && lpMagic->m_Skill != AT_MSKILL_MG_BLAST1
; 12741: 		  && lpMagic->m_Skill != AT_MSKILL_MG_INFERNO1
; 12742: 		  && lpMagic->m_Skill != AT_MSKILL_MG_EVILSPIRIT1
; 12743: 		  && lpMagic->m_Skill != AT_MSKILL_MG_FIRESLASH1
; 12744: 		  && lpMagic->m_Skill != AT_MSKILL_MG_FIRESLASH2
; 12745: 		  && lpMagic->m_Skill != AT_MSKILL_DL_FIRESCREAM1 
; 12746: 		  && lpMagic->m_Skill != AT_MSKILL_DL_FIRESCREAM2 )

  002c5	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  002c8	83 f8 08	 cmp	 eax, 8
  002cb	0f 84 2a 01 00
	00		 je	 $LN25@CGBeattack
  002d1	83 f8 09	 cmp	 eax, 9
  002d4	0f 84 21 01 00
	00		 je	 $LN25@CGBeattack
  002da	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002dd	0f 84 18 01 00
	00		 je	 $LN25@CGBeattack
  002e3	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  002e6	0f 84 0f 01 00
	00		 je	 $LN25@CGBeattack
  002ec	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  002ef	0f 84 06 01 00
	00		 je	 $LN25@CGBeattack
  002f5	83 f8 05	 cmp	 eax, 5
  002f8	0f 84 fd 00 00
	00		 je	 $LN25@CGBeattack
  002fe	83 f8 18	 cmp	 eax, 24			; 00000018H
  00301	0f 84 1e 01 00
	00		 je	 $LN27@CGBeattack
  00307	83 f8 32	 cmp	 eax, 50			; 00000032H
  0030a	0f 84 eb 00 00
	00		 je	 $LN25@CGBeattack
  00310	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00313	0f 84 e2 00 00
	00		 je	 $LN25@CGBeattack
  00319	83 f8 29	 cmp	 eax, 41			; 00000029H
  0031c	0f 84 d9 00 00
	00		 je	 $LN25@CGBeattack
  00322	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00325	0f 84 d0 00 00
	00		 je	 $LN25@CGBeattack
  0032b	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0032e	0f 84 c7 00 00
	00		 je	 $LN25@CGBeattack
  00334	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00337	0f 84 be 00 00
	00		 je	 $LN25@CGBeattack
  0033d	83 f8 34	 cmp	 eax, 52			; 00000034H
  00340	0f 84 b5 00 00
	00		 je	 $LN25@CGBeattack
  00346	83 f8 37	 cmp	 eax, 55			; 00000037H
  00349	0f 84 ac 00 00
	00		 je	 $LN25@CGBeattack
  0034f	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00352	0f 84 a3 00 00
	00		 je	 $LN25@CGBeattack
  00358	3d 7a 01 00 00	 cmp	 eax, 378		; 0000017aH
  0035d	0f 84 98 00 00
	00		 je	 $LN25@CGBeattack
  00363	3d 7e 01 00 00	 cmp	 eax, 382		; 0000017eH
  00368	0f 84 8d 00 00
	00		 je	 $LN25@CGBeattack
  0036e	3d 7d 01 00 00	 cmp	 eax, 381		; 0000017dH
  00373	0f 84 82 00 00
	00		 je	 $LN25@CGBeattack
  00379	3d 84 01 00 00	 cmp	 eax, 388		; 00000184H
  0037e	74 7b		 je	 SHORT $LN25@CGBeattack
  00380	3d 81 01 00 00	 cmp	 eax, 385		; 00000181H
  00385	74 74		 je	 SHORT $LN25@CGBeattack
  00387	3d 9e 01 00 00	 cmp	 eax, 414		; 0000019eH
  0038c	74 6d		 je	 SHORT $LN25@CGBeattack
  0038e	3d a2 01 00 00	 cmp	 eax, 418		; 000001a2H
  00393	74 66		 je	 SHORT $LN25@CGBeattack
  00395	3d a0 01 00 00	 cmp	 eax, 416		; 000001a0H
  0039a	74 5f		 je	 SHORT $LN25@CGBeattack
  0039c	3d 4a 01 00 00	 cmp	 eax, 330		; 0000014aH
  003a1	74 58		 je	 SHORT $LN25@CGBeattack
  003a3	3d 4c 01 00 00	 cmp	 eax, 332		; 0000014cH
  003a8	74 51		 je	 SHORT $LN25@CGBeattack
  003aa	3d e1 01 00 00	 cmp	 eax, 481		; 000001e1H
  003af	74 4a		 je	 SHORT $LN25@CGBeattack
  003b1	3d 4b 01 00 00	 cmp	 eax, 331		; 0000014bH
  003b6	74 43		 je	 SHORT $LN25@CGBeattack
  003b8	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  003bd	74 3c		 je	 SHORT $LN25@CGBeattack
  003bf	3d e3 01 00 00	 cmp	 eax, 483		; 000001e3H
  003c4	74 35		 je	 SHORT $LN25@CGBeattack
  003c6	3d e4 01 00 00	 cmp	 eax, 484		; 000001e4H
  003cb	74 2e		 je	 SHORT $LN25@CGBeattack
  003cd	3d e6 01 00 00	 cmp	 eax, 486		; 000001e6H
  003d2	74 27		 je	 SHORT $LN25@CGBeattack
  003d4	3d e7 01 00 00	 cmp	 eax, 487		; 000001e7H
  003d9	74 20		 je	 SHORT $LN25@CGBeattack
  003db	3d ea 01 00 00	 cmp	 eax, 490		; 000001eaH
  003e0	74 19		 je	 SHORT $LN25@CGBeattack
  003e2	3d ed 01 00 00	 cmp	 eax, 493		; 000001edH
  003e7	74 12		 je	 SHORT $LN25@CGBeattack
  003e9	3d 06 02 00 00	 cmp	 eax, 518		; 00000206H
  003ee	74 0b		 je	 SHORT $LN25@CGBeattack
  003f0	3d 08 02 00 00	 cmp	 eax, 520		; 00000208H
  003f5	0f 85 d8 05 00
	00		 jne	 $LN90@CGBeattack
$LN25@CGBeattack:

; 12747: 	{
; 12748: 		//LogAdd("error-L3 Skill:[%d] %s %d ", lpMagic->m_Skill, __FILE__, __LINE__);
; 12749: 		return;
; 12750: 	}
; 12751: 
; 12752: 	if ( lpMagic->m_Skill == AT_SKILL_CROSSBOW || lpMagic->m_Skill == AT_SKILL_FIRESCREAM ||
; 12753: 		 lpMagic->m_Skill == AT_MSKILL_FE_TRIPLESHOT1 || lpMagic->m_Skill == AT_MSKILL_FE_TRIPLESHOT2 ||
; 12754: 		 lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM1 || lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM2 )

  003fb	83 f8 18	 cmp	 eax, 24			; 00000018H
  003fe	74 25		 je	 SHORT $LN27@CGBeattack
  00400	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00403	74 20		 je	 SHORT $LN27@CGBeattack
  00405	3d 9e 01 00 00	 cmp	 eax, 414		; 0000019eH
  0040a	74 19		 je	 SHORT $LN27@CGBeattack
  0040c	3d a2 01 00 00	 cmp	 eax, 418		; 000001a2H
  00411	74 12		 je	 SHORT $LN27@CGBeattack
  00413	3d 06 02 00 00	 cmp	 eax, 518		; 00000206H
  00418	74 0b		 je	 SHORT $LN27@CGBeattack
  0041a	3d 08 02 00 00	 cmp	 eax, 520		; 00000208H
  0041f	0f 85 74 01 00
	00		 jne	 $LN29@CGBeattack
$LN27@CGBeattack:

; 12755: 	{
; 12756: 		int NSAttackSerial = lpCount->Serial;
; 12757: 
; 12758: 		if ( gObj[aIndex].OSAttackSerial >= 255 && (gObj[aIndex].OSAttackSerial - lpCount->Serial) > 50 )

  00425	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042b	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
  00430	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  00436	0f b7 84 1a b6
	06 00 00	 movzx	 eax, WORD PTR [edx+ebx+1718]
  0043e	0f b6 49 07	 movzx	 ecx, BYTE PTR [ecx+7]
  00442	66 3b c6	 cmp	 ax, si
  00445	7c 13		 jl	 SHORT $LN28@CGBeattack
  00447	98		 cwde
  00448	2b c1		 sub	 eax, ecx
  0044a	83 f8 32	 cmp	 eax, 50			; 00000032H
  0044d	7e 0b		 jle	 SHORT $LN28@CGBeattack

; 12759: 		{
; 12760: 			gObj[aIndex].OSAttackSerial = -1;

  0044f	83 c8 ff	 or	 eax, -1
  00452	66 89 84 1a b6
	06 00 00	 mov	 WORD PTR [edx+ebx+1718], ax
$LN28@CGBeattack:

; 12761: 		}
; 12762: 	
; 12763: 		if ( NSAttackSerial > gObj[aIndex].OSAttackSerial )

  0045a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00460	0f bf 84 1a b6
	06 00 00	 movsx	 eax, WORD PTR [edx+ebx+1718]
  00468	3b c8		 cmp	 ecx, eax
  0046a	0f 8e 29 01 00
	00		 jle	 $LN29@CGBeattack

; 12764: 		{
; 12765: 			gObj[aIndex].OSAttackSerial = NSAttackSerial;

  00470	66 89 8c 1a b6
	06 00 00	 mov	 WORD PTR [edx+ebx+1718], cx

; 12766: 			LPOBJ lpObj = &gObj[aIndex];

  00478	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0047e	03 f3		 add	 esi, ebx

; 12767: 			int iTimeCalc = GetTickCount() - lpObj->m_LastAttackTime;

  00480	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00486	2b 86 5c 05 00
	00		 sub	 eax, DWORD PTR [esi+1372]

; 12768: 
; 12769: 			if ( iTimeCalc < lpObj->m_DetectSpeedHackTime && iTimeCalc != 0)

  0048c	3b 86 64 05 00
	00		 cmp	 eax, DWORD PTR [esi+1380]
  00492	0f 8d e1 00 00
	00		 jge	 $LN30@CGBeattack
  00498	85 c0		 test	 eax, eax
  0049a	0f 84 d9 00 00
	00		 je	 $LN30@CGBeattack

; 12770: 			{
; 12771: 				lpObj->m_DetectCount++;

  004a0	ff 86 6c 05 00
	00		 inc	 DWORD PTR [esi+1388]
  004a6	8b 8e 6c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1388]

; 12772: 				lpObj->m_SumLastAttackTime += iTimeCalc;

  004ac	01 86 68 05 00
	00		 add	 DWORD PTR [esi+1384], eax

; 12773: 
; 12774: 				if ( lpObj->m_DetectCount > gHackCheckCount )

  004b2	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gHackCheckCount@@3KA ; gHackCheckCount
  004b8	0f 86 ad 00 00
	00		 jbe	 $LN32@CGBeattack

; 12775: 				{
; 12776: 					lpObj->m_DetectedHackKickCount++;

  004be	ff 86 70 05 00
	00		 inc	 DWORD PTR [esi+1392]

; 12777: 
; 12778: 					if ( gIsKickDetecHackCountLimit )

  004c4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsKickDetecHackCountLimit@@3HA, 0 ; gIsKickDetecHackCountLimit
  004cb	8b 86 70 05 00
	00		 mov	 eax, DWORD PTR [esi+1392]
  004d1	74 53		 je	 SHORT $LN34@CGBeattack

; 12779: 					{
; 12780: 						if ( lpObj->m_DetectedHackKickCount > gDetectedHackKickCount )

  004d3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?gDetectedHackKickCount@@3HA ; gDetectedHackKickCount
  004d9	7e 4b		 jle	 SHORT $LN34@CGBeattack

; 12781: 						{
; 12782: 							LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d)",

  004db	50		 push	 eax
  004dc	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  004e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004e8	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  004ed	50		 push	 eax
  004ee	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  004f3	50		 push	 eax
  004f4	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  004f7	50		 push	 eax
  004f8	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  004fb	50		 push	 eax
  004fc	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@ENPGLNLL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
  00501	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12783: 								lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 12784: 								lpObj->m_DetectedHackKickCount);
; 12785: 
; 12786: 							CloseClient(aIndex);

  00507	ff b5 f4 fd ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  0050d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00512	83 c4 18	 add	 esp, 24			; 00000018H
  00515	5b		 pop	 ebx
  00516	5f		 pop	 edi
  00517	5e		 pop	 esi

; 12983: 	}
; 12984: }

  00518	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0051b	33 cd		 xor	 ecx, ebp
  0051d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00522	8b e5		 mov	 esp, ebp
  00524	5d		 pop	 ebp
  00525	c3		 ret	 0
$LN34@CGBeattack:

; 12787: 							return;
; 12788: 						}
; 12789: 					}
; 12790: 
; 12791: 					LogAddTD("[%s][%s] %s Attack Speed Is Wrong Magic3 (%d)(%d) Penalty %d",

  00526	8b 86 68 05 00
	00		 mov	 eax, DWORD PTR [esi+1384]
  0052c	33 d2		 xor	 edx, edx
  0052e	f7 f1		 div	 ecx
  00530	ff b6 74 05 00
	00		 push	 DWORD PTR [esi+1396]
  00536	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0053b	50		 push	 eax
  0053c	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  00543	ff b6 64 05 00
	00		 push	 DWORD PTR [esi+1380]
  00549	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  0054e	50		 push	 eax
  0054f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00554	50		 push	 eax
  00555	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00558	50		 push	 eax
  00559	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0055c	50		 push	 eax
  0055d	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@IEDPAONG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
  00562	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00568	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN32@CGBeattack:

; 12792: 						lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 12793: 						lpObj->m_DetectSpeedHackTime,lpObj->m_SumLastAttackTime/lpObj->m_DetectCount,
; 12794: 						lpObj->m_SpeedHackPenalty);
; 12795: 				}
; 12796: 
; 12797: 				lpObj->m_LastAttackTime = GetTickCount();

  0056b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00571	89 86 5c 05 00
	00		 mov	 DWORD PTR [esi+1372], eax

; 12798: 			}
; 12799: 			else

  00577	eb 14		 jmp	 SHORT $LN31@CGBeattack
$LN30@CGBeattack:

; 12800: 			{
; 12801: 				lpObj->m_SumLastAttackTime = 0;

  00579	c7 86 68 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1384], 0

; 12802: 				lpObj->m_DetectCount = 0;

  00583	c7 86 6c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1388], 0
$LN31@CGBeattack:

; 12803: 			}
; 12804: 
; 12805: 			lpObj->m_LastAttackTime = GetTickCount();

  0058d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00593	89 86 5c 05 00
	00		 mov	 DWORD PTR [esi+1372], eax
$LN29@CGBeattack:

; 12806: 		}
; 12807: 	}
; 12808: 
; 12809: 	if ( lpMagic->m_Skill == AT_SKILL_EVIL ||
; 12810: 		 lpMagic->m_Skill == AT_MSKILL_DW_EVILSPIRIT1 ||

  00599	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0059c	83 f8 09	 cmp	 eax, 9
  0059f	74 0e		 je	 SHORT $LN36@CGBeattack
  005a1	3d 81 01 00 00	 cmp	 eax, 385		; 00000181H
  005a6	74 07		 je	 SHORT $LN36@CGBeattack
  005a8	3d e7 01 00 00	 cmp	 eax, 487		; 000001e7H
  005ad	75 1b		 jne	 SHORT $LN37@CGBeattack
$LN36@CGBeattack:

; 12811: 		 lpMagic->m_Skill == AT_MSKILL_MG_EVILSPIRIT1 )
; 12812: 	{
; 12813: 		if( gObj[aIndex].Class != CLASS_WIZARD &&

  005af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005b4	0f b7 84 03 90
	00 00 00	 movzx	 eax, WORD PTR [ebx+eax+144]
  005bc	66 85 c0	 test	 ax, ax
  005bf	74 09		 je	 SHORT $LN37@CGBeattack
  005c1	83 f8 03	 cmp	 eax, 3
  005c4	0f 85 09 04 00
	00		 jne	 $LN90@CGBeattack
$LN37@CGBeattack:

; 12814: 			gObj[aIndex].Class != CLASS_MAGUMSA )
; 12815: 		{
; 12816: 			return;
; 12817: 		}
; 12818: 	}
; 12819: 
; 12820: 
; 12821: 	if ( bIsIgnorePacketSpeedHackDetect )

  005ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  005d1	74 59		 je	 SHORT $LN39@CGBeattack

; 12822: 	{
; 12823: 		LPOBJ lpObj = &gObj[aIndex];

  005d3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005d9	03 f3		 add	 esi, ebx

; 12824: 
; 12825: 		if ( lpObj->m_SpeedHackPenalty > 0 )

  005db	8b 86 74 05 00
	00		 mov	 eax, DWORD PTR [esi+1396]
  005e1	85 c0		 test	 eax, eax
  005e3	7e 47		 jle	 SHORT $LN39@CGBeattack

; 12826: 		{
; 12827: 			lpObj->m_SpeedHackPenalty--;

  005e5	48		 dec	 eax

; 12828: 			
; 12829: 			LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left)",

  005e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  005eb	50		 push	 eax
  005ec	89 86 74 05 00
	00		 mov	 DWORD PTR [esi+1396], eax
  005f2	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  005f9	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  005fe	50		 push	 eax
  005ff	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00604	50		 push	 eax
  00605	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00608	50		 push	 eax
  00609	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0060c	50		 push	 eax
  0060d	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@JJPLIMIC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
  00612	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12927: 						gObj[aIndex].AccountID, gObj[aIndex].Name,
; 12928: 						lMsg.Get(MSGGET(7, 108)+gObj[aIndex].Class));
; 12929: 
; 12930: 					CloseClient(gObj[aIndex].m_Index);

  00618	83 c4 14	 add	 esp, 20			; 00000014H
  0061b	5b		 pop	 ebx
  0061c	5f		 pop	 edi
  0061d	5e		 pop	 esi

; 12983: 	}
; 12984: }

  0061e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00621	33 cd		 xor	 ecx, ebp
  00623	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00628	8b e5		 mov	 esp, ebp
  0062a	5d		 pop	 ebp
  0062b	c3		 ret	 0
$LN39@CGBeattack:

; 12838: 	int pTargetNumber[128];
; 12839: 
; 12840: 	int i;
; 12841: 	int n;
; 12842: 	
; 12843: 	for (i=0;i<lpCount->Count;i++)

  0062c	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  00632	33 d2		 xor	 edx, edx
  00634	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00638	89 85 f0 fd ff
	ff		 mov	 DWORD PTR tv1510[ebp], eax
  0063e	85 c0		 test	 eax, eax
  00640	7e 3f		 jle	 SHORT $LN3@CGBeattack

; 12830: 				lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 12831: 				lpObj->m_SpeedHackPenalty);
; 12832: 
; 12833: 			return;
; 12834: 		}
; 12835: 	}
; 12836: 	
; 12837: 	int lOfs2 = lOfs;

  00642	8d 71 09	 lea	 esi, DWORD PTR [ecx+9]
  00645	8b d8		 mov	 ebx, eax
  00647	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@CGBeattack:

; 12844: 	{
; 12845: 		lpMsg = (PMSG_BEATTACK *)&lpRecv[lOfs2];
; 12846: 		pTargetNumber[i] = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00650	0f b6 06	 movzx	 eax, BYTE PTR [esi]

; 12847: 		lOfs2 += sizeof(PMSG_BEATTACK);

  00653	8d 76 03	 lea	 esi, DWORD PTR [esi+3]
  00656	66 c1 e0 08	 shl	 ax, 8
  0065a	0f b7 c8	 movzx	 ecx, ax
  0065d	0f b6 46 ff	 movzx	 eax, BYTE PTR [esi-1]
  00661	0b c8		 or	 ecx, eax
  00663	89 8c 95 fc fd
	ff ff		 mov	 DWORD PTR _pTargetNumber$[ebp+edx*4], ecx
  0066a	42		 inc	 edx
  0066b	3b d3		 cmp	 edx, ebx
  0066d	7c e1		 jl	 SHORT $LL4@CGBeattack
  0066f	8b 9d e4 fd ff
	ff		 mov	 ebx, DWORD PTR tv1549[ebp]
  00675	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR tv1510[ebp]
  0067b	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _lpRecv$GSCopy$1$[ebp]
$LN3@CGBeattack:

; 12848: 	}
; 12849: 
; 12850: 	for (n=0;n<lpCount->Count;n++)

  00681	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  0068b	85 c0		 test	 eax, eax
  0068d	0f 8e 40 03 00
	00		 jle	 $LN90@CGBeattack
  00693	83 c1 09	 add	 ecx, 9
  00696	89 8d f8 fd ff
	ff		 mov	 DWORD PTR tv1504[ebp], ecx
  0069c	0f 1f 40 00	 npad	 4
$LL7@CGBeattack:

; 12851: 	{
; 12852: 		lpMsg = (PMSG_BEATTACK *)&lpRecv[lOfs];
; 12853: 		tNumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  006a0	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 12854: 		LPOBJ lpObj = &gObj[aIndex];

  006a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  006a9	66 c1 e0 08	 shl	 ax, 8
  006ad	03 d3		 add	 edx, ebx
  006af	0f b7 f0	 movzx	 esi, ax
  006b2	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]

; 12855: 
; 12856: 		if ( lpMsg->MagicKey == FALSE && 

  006b6	8a 49 01	 mov	 cl, BYTE PTR [ecx+1]
  006b9	0b f0		 or	 esi, eax
  006bb	89 95 e8 fd ff
	ff		 mov	 DWORD PTR _lpObj$1$[ebp], edx
  006c1	84 c9		 test	 cl, cl
  006c3	75 2a		 jne	 SHORT $LN95@CGBeattack
  006c5	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  006c8	83 f8 09	 cmp	 eax, 9
  006cb	0f 84 02 03 00
	00		 je	 $LN90@CGBeattack
  006d1	3d e7 01 00 00	 cmp	 eax, 487		; 000001e7H
  006d6	0f 84 f7 02 00
	00		 je	 $LN90@CGBeattack
  006dc	3d 81 01 00 00	 cmp	 eax, 385		; 00000181H
  006e1	0f 84 ec 02 00
	00		 je	 $LN90@CGBeattack

; 12857: 			(lpMagic->m_Skill == AT_SKILL_EVIL ||
; 12858: 			 lpMagic->m_Skill == AT_MSKILL_MG_EVILSPIRIT1 ||
; 12859: 			 lpMagic->m_Skill == AT_MSKILL_DW_EVILSPIRIT1 ) )
; 12860: 		{
; 12861: 			return;
; 12862: 		}
; 12863: 
; 12864: 		if ( lpMsg->MagicKey  && 

  006e7	84 c9		 test	 cl, cl
  006e9	0f 84 01 01 00
	00		 je	 $LN47@CGBeattack
$LN95@CGBeattack:
  006ef	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  006f2	83 f8 09	 cmp	 eax, 9
  006f5	74 12		 je	 SHORT $LN43@CGBeattack
  006f7	3d 81 01 00 00	 cmp	 eax, 385		; 00000181H
  006fc	74 0b		 je	 SHORT $LN43@CGBeattack
  006fe	3d e7 01 00 00	 cmp	 eax, 487		; 000001e7H
  00703	0f 85 e7 00 00
	00		 jne	 $LN47@CGBeattack
$LN43@CGBeattack:

; 12865: 			(lpMagic->m_Skill == AT_SKILL_EVIL ||
; 12866: 			 lpMagic->m_Skill == AT_MSKILL_DW_EVILSPIRIT1 ||
; 12867: 			 lpMagic->m_Skill == AT_MSKILL_MG_EVILSPIRIT1 ) )
; 12868: 		{
; 12869: 			if ( lpObj->DurMagicKeyChecker.IsValidDurationTime(lpMsg->MagicKey) == FALSE )

  00709	51		 push	 ecx
  0070a	8d 8a d8 14 00
	00		 lea	 ecx, DWORD PTR [edx+5336]
  00710	e8 00 00 00 00	 call	 ?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::IsValidDurationTime
  00715	85 c0		 test	 eax, eax
  00717	75 43		 jne	 SHORT $LN44@CGBeattack

; 12870: 			{
; 12871: 				LogAddC(0, " InValid DurationTime Key = %d ( Time : %d) [%s][%s]",

  00719	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _lpObj$1$[ebp]
  0071f	8b 9d f8 fd ff
	ff		 mov	 ebx, DWORD PTR tv1504[ebp]
  00725	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00728	8a 5b 01	 mov	 bl, BYTE PTR [ebx+1]
  0072b	8d 8a d8 14 00
	00		 lea	 ecx, DWORD PTR [edx+5336]
  00731	50		 push	 eax
  00732	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  00735	50		 push	 eax
  00736	53		 push	 ebx
  00737	e8 00 00 00 00	 call	 ?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidDurationTime
  0073c	50		 push	 eax
  0073d	0f b6 c3	 movzx	 eax, bl
  00740	50		 push	 eax
  00741	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@PFIDPOLC@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5DurationTime?5Ke@
  00746	6a 00		 push	 0
  00748	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 12872: 					lpMsg->MagicKey, lpObj->DurMagicKeyChecker.GetValidDurationTime(lpMsg->MagicKey),
; 12873: 					lpObj->AccountID, lpObj->Name); 
; 12874: 				lOfs += sizeof(PMSG_BEATTACK);
; 12875: 
; 12876: 				continue;

  0074e	8b 9d e4 fd ff
	ff		 mov	 ebx, DWORD PTR tv1549[ebp]
  00754	83 c4 18	 add	 esp, 24			; 00000018H
  00757	e9 f2 01 00 00	 jmp	 $LN65@CGBeattack
$LN44@CGBeattack:

; 12877: 			}
; 12878: 			
; 12879: 			if ( lpObj->DurMagicKeyChecker.IsValidCount(lpMsg->MagicKey) == FALSE )

  0075c	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR tv1504[ebp]
  00762	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00765	89 85 e0 fd ff
	ff		 mov	 DWORD PTR tv1505[ebp], eax
; File c:\users\michel\desktop\source\gameserver\source\tdurmagickeychecker.h

; 35   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  0076b	fe c8		 dec	 al
  0076d	3c 3b		 cmp	 al, 59			; 0000003bH
  0076f	76 3f		 jbe	 SHORT $LN45@CGBeattack
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 12881: 				LogAddC(0, " InValid VailidCount = %d ( Count : %d) [%s][%s]",

  00771	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _lpObj$1$[ebp]
  00777	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  0077a	50		 push	 eax
  0077b	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  0077e	50		 push	 eax
  0077f	ff b5 e0 fd ff
	ff		 push	 DWORD PTR tv1505[ebp]
  00785	8d 8a d8 14 00
	00		 lea	 ecx, DWORD PTR [edx+5336]
  0078b	e8 00 00 00 00	 call	 ?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z ; TDurMagicKeyChecker::GetValidCount
  00790	50		 push	 eax
  00791	8b 85 e0 fd ff
	ff		 mov	 eax, DWORD PTR tv1505[ebp]
  00797	0f b6 c0	 movzx	 eax, al
  0079a	50		 push	 eax
  0079b	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@COJBHLGO@?$KB?Z?$KB?Z?$KB?Z?$KB?Z?5InValid?5VailidCount?5?$DN?5?$CF@
  007a0	6a 00		 push	 0
  007a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  007a8	83 c4 18	 add	 esp, 24			; 00000018H

; 12882: 					lpMsg->MagicKey, lpObj->DurMagicKeyChecker.GetValidCount(lpMsg->MagicKey),
; 12883: 					lpObj->AccountID, lpObj->Name); 
; 12884: 				lOfs += sizeof(PMSG_BEATTACK);
; 12885: 
; 12886: 				continue;

  007ab	e9 9e 01 00 00	 jmp	 $LN65@CGBeattack
$LN45@CGBeattack:

; 12887: 			}
; 12888: 
; 12889: 			if ( OBJMAX_RANGE( tNumber ) == FALSE)

  007b0	85 f6		 test	 esi, esi
  007b2	0f 88 a5 01 00
	00		 js	 $LN5@CGBeattack
  007b8	33 c0		 xor	 eax, eax
  007ba	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  007c0	0f 9e c0	 setle	 al
  007c3	85 c0		 test	 eax, eax
  007c5	0f 84 92 01 00
	00		 je	 $LN5@CGBeattack

; 12890: 			{
; 12891: 				continue;
; 12892: 			}
; 12893: 
; 12894: 			int Dis = gObjCalDistance(lpObj,&gObj[tNumber]);

  007cb	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _lpObj$1$[ebp]
  007d1	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  007d7	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007dd	50		 push	 eax
  007de	52		 push	 edx
  007df	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  007e4	83 c4 08	 add	 esp, 8

; 12895: 
; 12896: 			if( Dis > 13 )

  007e7	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  007ea	0f 8f 5e 01 00
	00		 jg	 $LN65@CGBeattack
$LN47@CGBeattack:

; 12897: 			{
; 12898: 				lOfs+= sizeof(PMSG_BEATTACK);
; 12899: 				continue;
; 12900: 			}
; 12901: 		}
; 12902: 		
; 12903: 		/*if ( gEnableCheckPenetrationSkill )
; 12904: 		{
; 12905: 			if ( lpMagic->m_Skill == AT_SKILL_FIRESCREAM ||
; 12906: 				 lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM1 ||
; 12907: 				 lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM2 )
; 12908: 			{
; 12909: 				if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckFireScreamSkill(tNumber, lpMagic->m_Skill, lpCount->Serial) == FALSE )
; 12910: 				{
; 12911: 					return;
; 12912: 				}
; 12913: 			}
; 12914: 			else if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckPenetrationSkill(tNumber, lpMagic->m_Skill, lpCount->Serial)== FALSE )
; 12915: 			{
; 12916: 				return;
; 12917: 			}
; 12918: 		}*/
; 12919: 
; 12920: 		for (i=0;i<lpCount->Count;i++)

  007f0	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  007f6	33 c0		 xor	 eax, eax
  007f8	0f b6 49 04	 movzx	 ecx, BYTE PTR [ecx+4]
  007fc	85 c9		 test	 ecx, ecx
  007fe	7e 1c		 jle	 SHORT $LN9@CGBeattack
  00800	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _n$1$[ebp]
$LL10@CGBeattack:

; 12921: 		{
; 12922: 			if ( n != i)

  00806	3b d0		 cmp	 edx, eax
  00808	74 0d		 je	 SHORT $LN8@CGBeattack

; 12923: 			{
; 12924: 				if ( pTargetNumber[i] == tNumber )

  0080a	39 b4 85 fc fd
	ff ff		 cmp	 DWORD PTR _pTargetNumber$[ebp+eax*4], esi
  00811	0f 84 76 01 00
	00		 je	 $LN76@CGBeattack
$LN8@CGBeattack:

; 12897: 			{
; 12898: 				lOfs+= sizeof(PMSG_BEATTACK);
; 12899: 				continue;
; 12900: 			}
; 12901: 		}
; 12902: 		
; 12903: 		/*if ( gEnableCheckPenetrationSkill )
; 12904: 		{
; 12905: 			if ( lpMagic->m_Skill == AT_SKILL_FIRESCREAM ||
; 12906: 				 lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM1 ||
; 12907: 				 lpMagic->m_Skill == AT_MSKILL_DL_FIRESCREAM2 )
; 12908: 			{
; 12909: 				if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckFireScreamSkill(tNumber, lpMagic->m_Skill, lpCount->Serial) == FALSE )
; 12910: 				{
; 12911: 					return;
; 12912: 				}
; 12913: 			}
; 12914: 			else if ( gMultiAttackHackCheck[gObj[aIndex].m_Index].CheckPenetrationSkill(tNumber, lpMagic->m_Skill, lpCount->Serial)== FALSE )
; 12915: 			{
; 12916: 				return;
; 12917: 			}
; 12918: 		}*/
; 12919: 
; 12920: 		for (i=0;i<lpCount->Count;i++)

  00817	40		 inc	 eax
  00818	3b c1		 cmp	 eax, ecx
  0081a	7c ea		 jl	 SHORT $LL10@CGBeattack
$LN9@CGBeattack:

; 12931: 					return;
; 12932: 				}
; 12933: 			}
; 12934: 		}
; 12935: 
; 12936: 		if ( tNumber >= 0 && tNumber < OBJMAX-1 )

  0081c	81 fe ea 2c 00
	00		 cmp	 esi, 11498		; 00002ceaH
  00822	0f 87 26 01 00
	00		 ja	 $LN65@CGBeattack

; 12937: 		{
; 12938: 			if ( lpMagic->m_Skill == AT_SKILL_DEFENSEDOWN )

  00828	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0082b	83 f8 37	 cmp	 eax, 55			; 00000037H
  0082e	75 4d		 jne	 SHORT $LN51@CGBeattack

; 12939: 			{
; 12940: 				if( gObj[aIndex].Type == OBJ_USER )

  00830	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00835	80 7c 03 50 01	 cmp	 BYTE PTR [ebx+eax+80], 1
  0083a	75 1e		 jne	 SHORT $LN53@CGBeattack

; 12941: 				{
; 12942: 					if( (gObj[aIndex].Strength + gObj[aIndex].AddStrength) >= 596 )

  0083c	0f b7 8c 03 fc
	00 00 00	 movzx	 ecx, WORD PTR [ebx+eax+252]
  00844	0f b7 84 03 d0
	00 00 00	 movzx	 eax, WORD PTR [ebx+eax+208]
  0084c	03 c8		 add	 ecx, eax
  0084e	81 f9 54 02 00
	00		 cmp	 ecx, 596		; 00000254H
  00854	0f 8c f4 00 00
	00		 jl	 $LN65@CGBeattack
$LN53@CGBeattack:

; 12943: 					{
; 12944: 						gObjUseSkill.MaGumSkillDefenseDown(aIndex, tNumber, lpMagic);

  0085a	57		 push	 edi
  0085b	56		 push	 esi
  0085c	ff b5 f4 fd ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  00862	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00867	e8 00 00 00 00	 call	 ?MaGumSkillDefenseDown@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::MaGumSkillDefenseDown

; 12945: 						gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  0086c	6a 00		 push	 0
  0086e	6a 00		 push	 0
  00870	6a 00		 push	 0
  00872	6a 00		 push	 0
  00874	6a 01		 push	 1
  00876	6a 01		 push	 1

; 12946: 					}
; 12947: 				}
; 12948: 				else

  00878	e9 b5 00 00 00	 jmp	 $LN96@CGBeattack
$LN51@CGBeattack:

; 12949: 				{
; 12950: 					gObjUseSkill.MaGumSkillDefenseDown(aIndex, tNumber, lpMagic);
; 12951: 					gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);
; 12952: 				}
; 12953: 			}
; 12954: 			else if ( lpMagic->m_Skill == AT_SKILL_FIRESCREAM )

  0087d	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00880	75 17		 jne	 SHORT $LN56@CGBeattack

; 12955: 			{
; 12956: 				gObjUseSkill.SkillFireScream(aIndex, tNumber, lpMagic);

  00882	57		 push	 edi
  00883	56		 push	 esi
  00884	ff b5 f4 fd ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  0088a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0088f	e8 00 00 00 00	 call	 ?SkillFireScream@CObjUseSkill@@QAEHHHPAVCMagicInf@@@Z ; CObjUseSkill::SkillFireScream
  00894	e9 b5 00 00 00	 jmp	 $LN65@CGBeattack
$LN56@CGBeattack:

; 12957: 			}
; 12958: 			else if ( g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == AT_MSKILL_MG_FIRESLASH1 )

  00899	50		 push	 eax
  0089a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0089f	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill

; 12959: 			{
; 12960: 				g_MasterSkillSystem.MLS_MaGumSkillDefenseDown(aIndex,tNumber);

  008a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  008a9	3d ea 01 00 00	 cmp	 eax, 490		; 000001eaH
  008ae	75 1a		 jne	 SHORT $LN58@CGBeattack
  008b0	56		 push	 esi
  008b1	ff b5 f4 fd ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  008b7	e8 00 00 00 00	 call	 ?MLS_MaGumSkillDefenseDown@CMasterLevelSkillTreeSystem@@QAEXHH@Z ; CMasterLevelSkillTreeSystem::MLS_MaGumSkillDefenseDown

; 12961: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  008bc	6a 00		 push	 0
  008be	6a 00		 push	 0
  008c0	6a 00		 push	 0
  008c2	6a 00		 push	 0
  008c4	6a 01		 push	 1
  008c6	6a 01		 push	 1
  008c8	eb 68		 jmp	 SHORT $LN96@CGBeattack
$LN58@CGBeattack:

; 12962: 			}
; 12963: 			else if ( g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == AT_MSKILL_MG_FIRESLASH2 )

  008ca	ff 77 08	 push	 DWORD PTR [edi+8]
  008cd	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill

; 12964: 			{
; 12965: 				g_MasterSkillSystem.MLS_MaGumSkillDefenseDownMastery(aIndex,tNumber,lpMagic);

  008d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  008d7	3d ed 01 00 00	 cmp	 eax, 493		; 000001edH
  008dc	75 1b		 jne	 SHORT $LN60@CGBeattack
  008de	57		 push	 edi
  008df	56		 push	 esi
  008e0	ff b5 f4 fd ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  008e6	e8 00 00 00 00	 call	 ?MLS_MaGumSkillDefenseDownMastery@CMasterLevelSkillTreeSystem@@QAEXHHPAVCMagicInf@@@Z ; CMasterLevelSkillTreeSystem::MLS_MaGumSkillDefenseDownMastery

; 12966: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  008eb	6a 00		 push	 0
  008ed	6a 00		 push	 0
  008ef	6a 00		 push	 0
  008f1	6a 00		 push	 0
  008f3	6a 01		 push	 1
  008f5	6a 01		 push	 1
  008f7	eb 39		 jmp	 SHORT $LN96@CGBeattack
$LN60@CGBeattack:

; 12967: 			}
; 12968: 			else if ( g_MasterSkillSystem.GetBaseMasterLevelSkill(lpMagic->m_Skill) == AT_MSKILL_DL_FIRESCREAM1 )

  008f9	ff 77 08	 push	 DWORD PTR [edi+8]
  008fc	e8 00 00 00 00	 call	 ?GetBaseMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::GetBaseMasterLevelSkill
  00901	3d 06 02 00 00	 cmp	 eax, 518		; 00000206H
  00906	75 14		 jne	 SHORT $LN62@CGBeattack

; 12969: 			{
; 12970: 				g_MasterSkillSystem.MLS_FireScream(aIndex, tNumber, lpMagic);

  00908	57		 push	 edi
  00909	56		 push	 esi
  0090a	ff b5 f4 fd ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  00910	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00915	e8 00 00 00 00	 call	 ?MLS_FireScream@CMasterLevelSkillTreeSystem@@QAEHHHPAVCMagicInf@@@Z ; CMasterLevelSkillTreeSystem::MLS_FireScream
  0091a	eb 32		 jmp	 SHORT $LN65@CGBeattack
$LN62@CGBeattack:

; 12971: 			}
; 12972: 			else if ( magic_send )

  0091c	83 7d 10 00	 cmp	 DWORD PTR _magic_send$[ebp], 0

; 12973: 			{
; 12974: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, TRUE, 1, 0, FALSE,0,0);

  00920	6a 00		 push	 0
  00922	6a 00		 push	 0
  00924	6a 00		 push	 0
  00926	6a 00		 push	 0
  00928	6a 01		 push	 1
  0092a	74 04		 je	 SHORT $LN64@CGBeattack
  0092c	6a 01		 push	 1

; 12975: 			}
; 12976: 			else

  0092e	eb 02		 jmp	 SHORT $LN96@CGBeattack
$LN64@CGBeattack:

; 12977: 			{
; 12978: 				gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, FALSE, 1, 0, FALSE,0,0);

  00930	6a 00		 push	 0
$LN96@CGBeattack:
  00932	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00938	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  0093e	57		 push	 edi
  0093f	03 c1		 add	 eax, ecx
  00941	50		 push	 eax
  00942	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  00945	50		 push	 eax
  00946	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  0094b	83 c4 24	 add	 esp, 36			; 00000024H
$LN65@CGBeattack:

; 12979: 			}
; 12980: 		}
; 12981: 
; 12982: 		lOfs += sizeof(PMSG_BEATTACK);

  0094e	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR tv1504[ebp]
  00954	83 c1 03	 add	 ecx, 3
  00957	89 8d f8 fd ff
	ff		 mov	 DWORD PTR tv1504[ebp], ecx
$LN5@CGBeattack:

; 12848: 	}
; 12849: 
; 12850: 	for (n=0;n<lpCount->Count;n++)

  0095d	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _lpRecv$GSCopy$1$[ebp]
  00963	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _n$1$[ebp]
  00969	42		 inc	 edx
  0096a	89 95 f0 fd ff
	ff		 mov	 DWORD PTR _n$1$[ebp], edx
  00970	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00974	3b d0		 cmp	 edx, eax
  00976	0f 8c 24 fd ff
	ff		 jl	 $LL7@CGBeattack
  0097c	5b		 pop	 ebx
  0097d	5f		 pop	 edi
  0097e	5e		 pop	 esi

; 12983: 	}
; 12984: }

  0097f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00982	33 cd		 xor	 ecx, ebp
  00984	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00989	8b e5		 mov	 esp, ebp
  0098b	5d		 pop	 ebp
  0098c	c3		 ret	 0
$LN76@CGBeattack:

; 12925: 				{
; 12926: 					LogAddTD("[%s][%s] %s Detect Hack : Multi Attack",

  0098d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00993	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00998	0f b7 84 33 90
	00 00 00	 movzx	 eax, WORD PTR [ebx+esi+144]
  009a0	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  009a5	50		 push	 eax
  009a6	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  009ab	50		 push	 eax
  009ac	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  009af	03 c3		 add	 eax, ebx
  009b1	50		 push	 eax
  009b2	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  009b5	03 c3		 add	 eax, ebx
  009b7	50		 push	 eax
  009b8	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MOHJLJHL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Detect?5Hack?5?3?5Multi?5@
  009bd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12927: 						gObj[aIndex].AccountID, gObj[aIndex].Name,
; 12928: 						lMsg.Get(MSGGET(7, 108)+gObj[aIndex].Class));
; 12929: 
; 12930: 					CloseClient(gObj[aIndex].m_Index);

  009c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  009c8	ff 34 03	 push	 DWORD PTR [ebx+eax]
  009cb	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  009d0	83 c4 14	 add	 esp, 20			; 00000014H
$LN90@CGBeattack:
  009d3	5b		 pop	 ebx
$LN87@CGBeattack:

; 12983: 	}
; 12984: }

  009d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009d7	5f		 pop	 edi
  009d8	33 cd		 xor	 ecx, ebp
  009da	5e		 pop	 esi
  009db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009e0	8b e5		 mov	 esp, ebp
  009e2	5d		 pop	 ebp
  009e3	c3		 ret	 0
?CGBeattackRecv@@YAXPAEHH@Z ENDP			; CGBeattackRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_MoveNumber$ = 12					; size = 4
_MapNumber$ = 16					; size = 1
_MapX$ = 20						; size = 1
_MapY$ = 24						; size = 1
_Dir$ = 28						; size = 1
?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z PROC	; GCTeleportSend, COMDAT

; 12560: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]

; 12561: 	PMSG_TELEPORT_RESULT pMsg;
; 12562: 
; 12563: 	if ( lpObj->Type != OBJ_USER )

  00013	80 7a 50 01	 cmp	 BYTE PTR [edx+80], 1
  00017	75 39		 jne	 SHORT $LN4@GCTeleport

; 12564: 		return;
; 12565: 
; 12566: 	pMsg.h.c = 0xC3;
; 12567: 	pMsg.h.size = sizeof(pMsg);
; 12568: 	pMsg.h.headcode = 0x1C;
; 12569: 	pMsg.MoveNumber = MoveNumber;
; 12570: 	pMsg.MapNumber = MapNumber;

  00019	8a 45 10	 mov	 al, BYTE PTR _MapNumber$[ebp]
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _MoveNumber$[ebp]
  0001f	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 12571: 	pMsg.MapX = MapX;

  00022	8a 45 14	 mov	 al, BYTE PTR _MapX$[ebp]
  00025	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+7], al

; 12572: 	pMsg.MapY = MapY;

  00028	8a 45 18	 mov	 al, BYTE PTR _MapY$[ebp]
  0002b	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 12573: 	pMsg.Dir = Dir;

  0002e	8a 45 1c	 mov	 al, BYTE PTR _Dir$[ebp]
  00031	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+9], al

; 12574: 
; 12575: 	if ( MoveNumber == 0 )
; 12576: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00034	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00037	6a 0a		 push	 10			; 0000000aH
  00039	50		 push	 eax
  0003a	ff 32		 push	 DWORD PTR [edx]
  0003c	66 c7 45 f0 c3
	0a		 mov	 WORD PTR _pMsg$[ebp], 2755 ; 00000ac3H
  00042	c6 45 f2 1c	 mov	 BYTE PTR _pMsg$[ebp+2], 28 ; 0000001cH
  00046	66 89 4d f4	 mov	 WORD PTR _pMsg$[ebp+4], cx

; 12577: 	else
; 12578: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0004a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GCTeleport:

; 12579: }

  00052	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00055	33 cd		 xor	 ecx, ebp
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ENDP	; GCTeleportSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z
_TEXT	SEGMENT
_usebp$1$ = -32						; size = 4
_lpMagic$1$ = -32					; size = 4
_x$ = -28						; size = 1
_y$ = -24						; size = 1
_usemana$1$ = -20					; size = 4
tv377 = -20						; size = 4
_iTargetIndex$1$ = -20					; size = 4
_pAttack$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z PROC ; CGTargetTeleportRecv, COMDAT

; 12468: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 12469: 	if ( !OBJMAX_RANGE(aIndex))

  00018	85 db		 test	 ebx, ebx
  0001a	0f 88 8c 02 00
	00		 js	 $LN9@CGTargetTe
  00020	33 c0		 xor	 eax, eax
  00022	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00028	0f 9e c0	 setle	 al
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 79 02 00
	00		 je	 $LN9@CGTargetTe

; 12470: 		return;
; 12471: 
; 12472: 	if( gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_STUN) == TRUE ||
; 12473: 		gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_SLEEP) == TRUE ||
; 12474: 		gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_EARTHBINDS) == TRUE ||

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	56		 push	 esi
  00039	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  0003f	6a 3d		 push	 61			; 0000003dH
  00041	03 c6		 add	 eax, esi
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00049	83 c4 08	 add	 esp, 8
  0004c	3c 01		 cmp	 al, 1
  0004e	0f 84 57 02 00
	00		 je	 $LN20@CGTargetTe
  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00059	03 c6		 add	 eax, esi
  0005b	6a 48		 push	 72			; 00000048H
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00063	83 c4 08	 add	 esp, 8
  00066	3c 01		 cmp	 al, 1
  00068	0f 84 3d 02 00
	00		 je	 $LN20@CGTargetTe
  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00073	03 c6		 add	 eax, esi
  00075	68 93 00 00 00	 push	 147			; 00000093H
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00080	83 c4 08	 add	 esp, 8
  00083	3c 01		 cmp	 al, 1
  00085	0f 84 20 02 00
	00		 je	 $LN20@CGTargetTe
  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00090	03 c6		 add	 eax, esi
  00092	68 92 00 00 00	 push	 146			; 00000092H
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0009d	83 c4 08	 add	 esp, 8
  000a0	3c 01		 cmp	 al, 1
  000a2	0f 84 03 02 00
	00		 je	 $LN20@CGTargetTe

; 12475: 		gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_FREEZE) == TRUE)
; 12476: 		return;
; 12477: 
; 12478: 	CMagicInf * lpMagic;
; 12479: 	BYTE x;
; 12480: 	BYTE y;
; 12481: 	PMSG_MAGICATTACK_RESULT pAttack;
; 12482: 
; 12483: 	PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof(pAttack));

  000a8	6a 09		 push	 9
  000aa	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  000ad	6a 19		 push	 25			; 00000019H
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 12484: 
; 12485: 	pAttack.MagicNumberH = SET_NUMBERH(AT_SKILL_TARGET_TELEPORT);
; 12486: 	pAttack.MagicNumberL = SET_NUMBERL(AT_SKILL_TARGET_TELEPORT);
; 12487: 
; 12488: 	pAttack.SourceNumberH = SET_NUMBERH(aIndex);

  000b5	8b c3		 mov	 eax, ebx
  000b7	66 c7 45 f5 00
	0f		 mov	 WORD PTR _pAttack$[ebp+5], 3840 ; 00000f00H
  000bd	c1 e8 08	 shr	 eax, 8
  000c0	88 45 f3	 mov	 BYTE PTR _pAttack$[ebp+3], al

; 12489: 	pAttack.SourceNumberL = SET_NUMBERL(aIndex);
; 12490: 	int iTargetIndex = MAKE_NUMBERW(lpMsg->NumberL, lpMsg->NumberH);

  000c3	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  000c7	66 c1 e0 08	 shl	 ax, 8
  000cb	0f b7 c8	 movzx	 ecx, ax
  000ce	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  000d2	0b c8		 or	 ecx, eax
  000d4	88 5d f4	 mov	 BYTE PTR _pAttack$[ebp+4], bl

; 12491: 
; 12492: 	pAttack.TargetNumberH = SET_NUMBERH(iTargetIndex);

  000d7	8b c1		 mov	 eax, ecx
  000d9	89 4d ec	 mov	 DWORD PTR _iTargetIndex$1$[ebp], ecx
  000dc	c1 e8 08	 shr	 eax, 8
  000df	88 45 f7	 mov	 BYTE PTR _pAttack$[ebp+7], al

; 12493: 	pAttack.TargetNumberL = SET_NUMBERL(iTargetIndex);
; 12494: 	lpMagic = gObjGetMagicSearch(&gObj[aIndex], AT_SKILL_TARGET_TELEPORT);

  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e7	03 c6		 add	 eax, esi
  000e9	88 4d f8	 mov	 BYTE PTR _pAttack$[ebp+8], cl
  000ec	6a 0f		 push	 15			; 0000000fH
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  000f4	89 45 e0	 mov	 DWORD PTR _lpMagic$1$[ebp], eax

; 12495: 	x = lpMsg->MapX;

  000f7	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  000fa	88 45 e4	 mov	 BYTE PTR _x$[ebp], al

; 12496: 	y = lpMsg->MapY;

  000fd	8a 47 06	 mov	 al, BYTE PTR [edi+6]

; 12497: 
; 12498: 	if ( !gObjIsConnectedGP(iTargetIndex) )

  00100	8b 7d ec	 mov	 edi, DWORD PTR _iTargetIndex$1$[ebp]
  00103	57		 push	 edi
  00104	88 45 e8	 mov	 BYTE PTR _y$[ebp], al
  00107	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP

; 12499: 	{
; 12500: 		LogAddC(2, "[%s][%s] Try Target Teleport Not Move Area [%d,%d]",

  0010c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00112	83 c4 18	 add	 esp, 24			; 00000018H
  00115	85 c0		 test	 eax, eax
  00117	74 7e		 je	 SHORT $LN21@CGTargetTe

; 12501: 			gObj[aIndex].AccountID, gObj[aIndex].Name, x, y);
; 12502: 
; 12503: 		return;
; 12504: 	}
; 12505: 
; 12506: 	if ( IT_MAP_RANGE( gObj[iTargetIndex].MapNumber ) )

  00119	69 d7 40 27 00
	00		 imul	 edx, edi, 10048
  0011f	89 55 ec	 mov	 DWORD PTR tv377[ebp], edx
  00122	8a 84 0a 23 01
	00 00		 mov	 al, BYTE PTR [edx+ecx+291]
  00129	3c 2d		 cmp	 al, 45			; 0000002dH
  0012b	72 29		 jb	 SHORT $LN7@CGTargetTe
  0012d	b4 32		 mov	 ah, 50			; 00000032H
  0012f	3a e0		 cmp	 ah, al
  00131	1b c0		 sbb	 eax, eax
  00133	83 c0 01	 add	 eax, 1
  00136	74 1e		 je	 SHORT $LN7@CGTargetTe

; 12507: 	{
; 12508: 		if( g_IllusionTemple.TeleportLock(gObj[iTargetIndex].m_Index) )

  00138	ff 34 0a	 push	 DWORD PTR [edx+ecx]
  0013b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  00140	e8 00 00 00 00	 call	 ?TeleportLock@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::TeleportLock
  00145	85 c0		 test	 eax, eax
  00147	0f 85 5e 01 00
	00		 jne	 $LN20@CGTargetTe
  0014d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00153	8b 55 ec	 mov	 edx, DWORD PTR tv377[ebp]
$LN7@CGTargetTe:

; 12509: 		{
; 12510: 			return;
; 12511: 		}
; 12512: 	}
; 12513: 
; 12514: 	if ( gObj[aIndex].PartyNumber != gObj[iTargetIndex].PartyNumber ||
; 12515: 		 gObj[aIndex].PartyNumber == -1 ||

  00156	8b 84 0e 0c 06
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1548]
  0015d	8b 8c 0a 0c 06
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+1548]
  00164	3b c1		 cmp	 eax, ecx
  00166	0f 85 3f 01 00
	00		 jne	 $LN20@CGTargetTe
  0016c	83 f8 ff	 cmp	 eax, -1
  0016f	0f 84 36 01 00
	00		 je	 $LN20@CGTargetTe
  00175	83 f9 ff	 cmp	 ecx, -1
  00178	0f 84 2d 01 00
	00		 je	 $LN20@CGTargetTe

; 12516: 		 gObj[iTargetIndex].PartyNumber == -1)
; 12517: 	{
; 12518: 		return;
; 12519: 	}
; 12520: 
; 12521: 	if ( !gObjCheckTeleportArea(iTargetIndex, x, y))

  0017e	ff 75 e8	 push	 DWORD PTR _y$[ebp]
  00181	ff 75 e4	 push	 DWORD PTR _x$[ebp]
  00184	57		 push	 edi
  00185	e8 00 00 00 00	 call	 ?gObjCheckTeleportArea@@YAHHEE@Z ; gObjCheckTeleportArea
  0018a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018d	85 c0		 test	 eax, eax
  0018f	75 3d		 jne	 SHORT $LN10@CGTargetTe

; 12522: 	{
; 12523: 		LogAddC(2, "[%s][%s] Try Target Teleport Not Move Area [%d,%d]",

  00191	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN21@CGTargetTe:
  00197	0f b6 45 e8	 movzx	 eax, BYTE PTR _y$[ebp]
  0019b	50		 push	 eax
  0019c	0f b6 45 e4	 movzx	 eax, BYTE PTR _x$[ebp]
  001a0	50		 push	 eax
  001a1	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001a4	03 c6		 add	 eax, esi
  001a6	50		 push	 eax
  001a7	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001aa	03 c6		 add	 eax, esi
  001ac	50		 push	 eax
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@FGHCMCNO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Target?5Teleport?5Not@
  001b2	6a 02		 push	 2
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  001ba	83 c4 18	 add	 esp, 24			; 00000018H
  001bd	5e		 pop	 esi
  001be	5f		 pop	 edi
  001bf	5b		 pop	 ebx

; 12547: 
; 12548: 				return;
; 12549: 			}
; 12550: 		}
; 12551: 	}
; 12552: }

  001c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c3	33 cd		 xor	 ecx, ebp
  001c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
$LN10@CGTargetTe:

; 12524: 			gObj[aIndex].AccountID, gObj[aIndex].Name, x, y);
; 12525: 
; 12526: 		return;
; 12527: 	}
; 12528: 
; 12529: 	if ( lpMagic )

  001ce	8b 45 e0	 mov	 eax, DWORD PTR _lpMagic$1$[ebp]
  001d1	85 c0		 test	 eax, eax
  001d3	0f 84 d2 00 00
	00		 je	 $LN20@CGTargetTe

; 12530: 	{
; 12531: 		int usemana = gObjMagicManaUse(&gObj[aIndex], lpMagic);

  001d9	50		 push	 eax
  001da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001df	03 c6		 add	 eax, esi
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 ?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicManaUse
  001e7	83 c4 08	 add	 esp, 8
  001ea	89 45 ec	 mov	 DWORD PTR _usemana$1$[ebp], eax

; 12532: 
; 12533: 		if ( usemana >= 0 )

  001ed	85 c0		 test	 eax, eax
  001ef	0f 88 b6 00 00
	00		 js	 $LN20@CGTargetTe

; 12534: 		{
; 12535: 			int usebp = gObjMagicBPUse(&gObj[aIndex], lpMagic);

  001f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001fb	8b 45 e0	 mov	 eax, DWORD PTR _lpMagic$1$[ebp]
  001fe	03 ce		 add	 ecx, esi
  00200	50		 push	 eax
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 ?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
  00207	83 c4 08	 add	 esp, 8
  0020a	89 45 e0	 mov	 DWORD PTR _usebp$1$[ebp], eax

; 12536: 			
; 12537: 			if ( usebp >= 0 )

  0020d	85 c0		 test	 eax, eax
  0020f	0f 88 96 00 00
	00		 js	 $LN20@CGTargetTe

; 12538: 			{
; 12539: 				if ( gObj[aIndex].Type == OBJ_USER )

  00215	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0021b	80 7c 0e 50 01	 cmp	 BYTE PTR [esi+ecx+80], 1
  00220	75 18		 jne	 SHORT $LN14@CGTargetTe

; 12540: 					DataSend(aIndex, (LPBYTE)&pAttack, pAttack.h.size);

  00222	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pAttack$[ebp+1]
  00226	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  00229	51		 push	 ecx
  0022a	50		 push	 eax
  0022b	53		 push	 ebx
  0022c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00231	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00237	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@CGTargetTe:

; 12541: 
; 12542: 				MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  0023a	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  0023e	50		 push	 eax
  0023f	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  00242	50		 push	 eax
  00243	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 12543: 				gObjTeleportMagicUse(iTargetIndex, x, y);

  0024c	ff 75 e8	 push	 DWORD PTR _y$[ebp]
  0024f	ff 75 e4	 push	 DWORD PTR _x$[ebp]
  00252	57		 push	 edi
  00253	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse
  00258	66 0f 6e 45 ec	 movd	 xmm0, DWORD PTR _usemana$1$[ebp]

; 12544: 				gObj[aIndex].Mana = (float)usemana;

  0025d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 12545: 				gObj[aIndex].BP = usebp;

  00262	8b 4d e0	 mov	 ecx, DWORD PTR _usebp$1$[ebp]
  00265	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00268	f3 0f 11 84 06
	ec 00 00 00	 movss	 DWORD PTR [esi+eax+236], xmm0
  00271	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00276	89 8c 06 04 01
	00 00		 mov	 DWORD PTR [esi+eax+260], ecx

; 12546: 				GCManaSend(gObj[aIndex].m_Index, (WORD)gObj[aIndex].Mana, -1, 0, gObj[aIndex].BP);

  0027d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00283	0f b7 84 0e 04
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+260]
  0028b	50		 push	 eax
  0028c	f3 0f 2c 84 0e
	ec 00 00 00	 cvttss2si eax, DWORD PTR [esi+ecx+236]
  00295	6a 00		 push	 0
  00297	68 ff 00 00 00	 push	 255			; 000000ffH
  0029c	0f b7 c0	 movzx	 eax, ax
  0029f	50		 push	 eax
  002a0	ff 34 0e	 push	 DWORD PTR [esi+ecx]
  002a3	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  002a8	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN20@CGTargetTe:
  002ab	5e		 pop	 esi
$LN9@CGTargetTe:

; 12547: 
; 12548: 				return;
; 12549: 			}
; 12550: 		}
; 12551: 	}
; 12552: }

  002ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002af	5f		 pop	 edi
  002b0	33 cd		 xor	 ecx, ebp
  002b2	5b		 pop	 ebx
  002b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ENDP ; CGTargetTeleportRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z
_TEXT	SEGMENT
_usemana$1$ = -44					; size = 4
_lpMagic$1$ = -44					; size = 4
_y$1 = -37						; size = 1
_x$2 = -33						; size = 1
_y$1$ = -29						; size = 1
_pTeleportResult$3 = -28				; size = 10
_pTeleportResult$4 = -28				; size = 10
_pAttack$5 = -16					; size = 9
_pTeleportResult$6 = -16				; size = 10
_pTeleportResult$7 = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z PROC		; CGTeleportRecv, COMDAT

; 12286: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 12287: 	if ( !OBJMAX_RANGE(aIndex))

  00018	85 db		 test	 ebx, ebx
  0001a	0f 88 10 05 00
	00		 js	 $LN24@CGTeleport
  00020	33 c0		 xor	 eax, eax
  00022	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00028	0f 9e c0	 setle	 al
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 fd 04 00
	00		 je	 $LN24@CGTeleport

; 12288: 		return;
; 12289: 
; 12290: 	if ( gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_STUN) == TRUE ||
; 12291: 		 gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_SLEEP) == TRUE ||
; 12292: 		 gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_EARTHBINDS) == TRUE ||

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00038	56		 push	 esi
  00039	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  0003f	6a 3d		 push	 61			; 0000003dH
  00041	03 c6		 add	 eax, esi
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00049	83 c4 08	 add	 esp, 8
  0004c	3c 01		 cmp	 al, 1
  0004e	0f 84 8e 04 00
	00		 je	 $LN4@CGTeleport
  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00059	03 c6		 add	 eax, esi
  0005b	6a 48		 push	 72			; 00000048H
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00063	83 c4 08	 add	 esp, 8
  00066	3c 01		 cmp	 al, 1
  00068	0f 84 74 04 00
	00		 je	 $LN4@CGTeleport
  0006e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00073	03 c6		 add	 eax, esi
  00075	68 93 00 00 00	 push	 147			; 00000093H
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00080	83 c4 08	 add	 esp, 8
  00083	3c 01		 cmp	 al, 1
  00085	0f 84 57 04 00
	00		 je	 $LN4@CGTeleport
  0008b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00090	03 c6		 add	 eax, esi
  00092	68 92 00 00 00	 push	 146			; 00000092H
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0009d	83 c4 08	 add	 esp, 8
  000a0	3c 01		 cmp	 al, 1
  000a2	0f 84 3a 04 00
	00		 je	 $LN4@CGTeleport

; 12305: 		return;
; 12306: 	}
; 12307: 
; 12308: 	if ( IT_MAP_RANGE( gObj[aIndex].MapNumber ) &&

  000a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ae	8a 94 0e 23 01
	00 00		 mov	 dl, BYTE PTR [esi+ecx+291]
  000b5	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  000b8	0f 82 e1 00 00
	00		 jb	 $LN7@CGTeleport
  000be	b0 32		 mov	 al, 50			; 00000032H
  000c0	3a c2		 cmp	 al, dl
  000c2	1b c0		 sbb	 eax, eax
  000c4	83 c0 01	 add	 eax, 1
  000c7	0f 84 d2 00 00
	00		 je	 $LN7@CGTeleport
  000cd	52		 push	 edx
  000ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  000d3	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleEvent@@QAEEE@Z ; CIllusionTempleEvent::GetState
  000d8	3c 02		 cmp	 al, 2
  000da	0f 85 b9 00 00
	00		 jne	 $LN34@CGTeleport

; 12309: 		 g_IllusionTemple.GetState(gObj[aIndex].MapNumber) == 2 )
; 12310: 	{
; 12311: 		if(  g_IllusionTemple.TeleportLock(aIndex) )

  000e0	53		 push	 ebx
  000e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  000e6	e8 00 00 00 00	 call	 ?TeleportLock@CIllusionTempleEvent@@QAEHH@Z ; CIllusionTempleEvent::TeleportLock

; 12318: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  000eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f1	85 c0		 test	 eax, eax
  000f3	74 40		 je	 SHORT $LN6@CGTeleport
$LN39@CGTeleport:

; 12312: 		{
; 12313: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 12314: 			pTeleportResult.h.c = 0xC3;
; 12315: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 12316: 			pTeleportResult.h.headcode = 0x1C;
; 12317: 			pTeleportResult.MoveNumber = 0;

  000f5	33 c0		 xor	 eax, eax
  000f7	66 c7 45 f0 c3
	0a		 mov	 WORD PTR _pTeleportResult$7[ebp], 2755 ; 00000ac3H
  000fd	66 89 45 f4	 mov	 WORD PTR _pTeleportResult$7[ebp+4], ax
  00101	c6 45 f2 1c	 mov	 BYTE PTR _pTeleportResult$7[ebp+2], 28 ; 0000001cH

; 12318: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  00105	8a 84 0e 23 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+291]
  0010c	88 45 f6	 mov	 BYTE PTR _pTeleportResult$7[ebp+6], al

; 12319: 			pTeleportResult.MapX = gObj[aIndex].X;

  0010f	8a 84 0e 20 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+288]
  00116	88 45 f7	 mov	 BYTE PTR _pTeleportResult$7[ebp+7], al

; 12320: 			pTeleportResult.MapY = gObj[aIndex].Y;

  00119	8a 84 0e 21 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+289]
  00120	88 45 f8	 mov	 BYTE PTR _pTeleportResult$7[ebp+8], al

; 12321: 			pTeleportResult.Dir = gObj[aIndex].Dir;

  00123	8a 84 0e 22 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+290]
  0012a	88 45 f9	 mov	 BYTE PTR _pTeleportResult$7[ebp+9], al

; 12322: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);

  0012d	8d 45 f0	 lea	 eax, DWORD PTR _pTeleportResult$7[ebp]

; 12323: 			return;

  00130	e9 ee 03 00 00	 jmp	 $LN38@CGTeleport
$LN6@CGTeleport:

; 12324: 		}
; 12325: 
; 12326: 		if( g_IllusionTemple.Is2ndSkillActive(gObj[aIndex].iTempleIndex,gObj[aIndex].MapNumber) )

  00135	0f b6 84 0e 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+291]
  0013d	50		 push	 eax
  0013e	ff b4 0e 78 24
	00 00		 push	 DWORD PTR [esi+ecx+9336]
  00145	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  0014a	e8 00 00 00 00	 call	 ?Is2ndSkillActive@CIllusionTempleEvent@@QAEHHE@Z ; CIllusionTempleEvent::Is2ndSkillActive
  0014f	85 c0		 test	 eax, eax
  00151	74 46		 je	 SHORT $LN34@CGTeleport

; 12327: 		{
; 12328: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 12329: 			pTeleportResult.h.c = 0xC3;
; 12330: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 12331: 			pTeleportResult.h.headcode = 0x1C;
; 12332: 			pTeleportResult.MoveNumber = 0;
; 12333: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00159	33 c0		 xor	 eax, eax
  0015b	66 89 45 f4	 mov	 WORD PTR _pTeleportResult$6[ebp+4], ax
  0015f	66 c7 45 f0 c3
	0a		 mov	 WORD PTR _pTeleportResult$6[ebp], 2755 ; 00000ac3H
  00165	c6 45 f2 1c	 mov	 BYTE PTR _pTeleportResult$6[ebp+2], 28 ; 0000001cH
  00169	8a 84 0e 23 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+291]
  00170	88 45 f6	 mov	 BYTE PTR _pTeleportResult$6[ebp+6], al

; 12334: 			pTeleportResult.MapX = gObj[aIndex].X;

  00173	8a 84 0e 20 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+288]
  0017a	88 45 f7	 mov	 BYTE PTR _pTeleportResult$6[ebp+7], al

; 12335: 			pTeleportResult.MapY = gObj[aIndex].Y;

  0017d	8a 84 0e 21 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+289]
  00184	88 45 f8	 mov	 BYTE PTR _pTeleportResult$6[ebp+8], al

; 12336: 			pTeleportResult.Dir = gObj[aIndex].Dir;

  00187	8a 84 0e 22 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+290]
  0018e	88 45 f9	 mov	 BYTE PTR _pTeleportResult$6[ebp+9], al

; 12337: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);

  00191	8d 45 f0	 lea	 eax, DWORD PTR _pTeleportResult$6[ebp]

; 12338: 			return;

  00194	e9 8a 03 00 00	 jmp	 $LN38@CGTeleport
$LN34@CGTeleport:
  00199	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN7@CGTeleport:

; 12339: 		}
; 12340: 	}
; 12341: 
; 12342: 	if( IT_MAP_RANGE( gObj[aIndex].MapNumber ) )

  0019f	8a 94 0e 23 01
	00 00		 mov	 dl, BYTE PTR [esi+ecx+291]
  001a6	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  001a9	72 27		 jb	 SHORT $LN9@CGTeleport
  001ab	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  001b0	3a c2		 cmp	 al, dl
  001b2	1b c0		 sbb	 eax, eax
  001b4	83 c0 01	 add	 eax, 1
  001b7	74 19		 je	 SHORT $LN9@CGTeleport

; 12343: 	{
; 12344: 		if( g_IllusionTemple.GetState(gObj[aIndex].MapNumber) == 1 )

  001b9	52		 push	 edx
  001ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  001bf	e8 00 00 00 00	 call	 ?GetState@CIllusionTempleEvent@@QAEEE@Z ; CIllusionTempleEvent::GetState

; 12345: 		{
; 12346: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 12347: 			pTeleportResult.h.c = 0xC3;
; 12348: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 12349: 			pTeleportResult.h.headcode = 0x1C;
; 12350: 			pTeleportResult.MoveNumber = 0;
; 12351: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  001c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ca	3c 01		 cmp	 al, 1
  001cc	0f 84 23 ff ff
	ff		 je	 $LN39@CGTeleport
$LN9@CGTeleport:

; 12352: 			pTeleportResult.MapX = gObj[aIndex].X;
; 12353: 			pTeleportResult.MapY = gObj[aIndex].Y;
; 12354: 			pTeleportResult.Dir = gObj[aIndex].Dir;
; 12355: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);
; 12356: 			return;
; 12357: 		}
; 12358: 	}
; 12359: 
; 12360: 	if ( lpMsg->MoveNumber == 0 )

  001d2	0f b7 57 04	 movzx	 edx, WORD PTR [edi+4]
  001d6	66 85 d2	 test	 dx, dx
  001d9	0f 85 01 02 00
	00		 jne	 $LN10@CGTeleport

; 12361: 	{
; 12362: 		CMagicInf * lpMagic;
; 12363: 		BYTE x;
; 12364: 		BYTE y;
; 12365: 		PMSG_MAGICATTACK_RESULT pAttack;
; 12366: 
; 12367: 		PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof(pAttack));

  001df	6a 09		 push	 9
  001e1	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$5[ebp]
  001e4	6a 19		 push	 25			; 00000019H
  001e6	50		 push	 eax
  001e7	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 12368: 
; 12369: 		pAttack.MagicNumberH = SET_NUMBERH(AT_SKILL_TELEPORT);
; 12370: 		pAttack.MagicNumberL = SET_NUMBERL(AT_SKILL_TELEPORT);
; 12371: 
; 12372: 		pAttack.SourceNumberH = SET_NUMBERH(aIndex);

  001ec	8b c3		 mov	 eax, ebx
  001ee	66 c7 45 f5 00
	06		 mov	 WORD PTR _pAttack$5[ebp+5], 1536 ; 00000600H
  001f4	c1 e8 08	 shr	 eax, 8
  001f7	88 45 f3	 mov	 BYTE PTR _pAttack$5[ebp+3], al

; 12373: 		pAttack.SourceNumberL = SET_NUMBERL(aIndex);
; 12374: 		pAttack.TargetNumberH = SET_NUMBERH(aIndex);

  001fa	88 45 f7	 mov	 BYTE PTR _pAttack$5[ebp+7], al

; 12375: 		pAttack.TargetNumberL = SET_NUMBERL(aIndex);
; 12376: 
; 12377: 		lpMagic = gObjGetMagicSearch(&gObj[aIndex], AT_SKILL_TELEPORT);

  001fd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00202	03 c6		 add	 eax, esi
  00204	88 5d f4	 mov	 BYTE PTR _pAttack$5[ebp+4], bl
  00207	6a 06		 push	 6
  00209	50		 push	 eax
  0020a	88 5d f8	 mov	 BYTE PTR _pAttack$5[ebp+8], bl
  0020d	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  00212	89 45 d4	 mov	 DWORD PTR _lpMagic$1$[ebp], eax

; 12378: 		x = lpMsg->MapX;

  00215	8a 47 06	 mov	 al, BYTE PTR [edi+6]
  00218	88 45 df	 mov	 BYTE PTR _x$2[ebp], al

; 12379: 		y = lpMsg->MapY;

  0021b	8a 47 07	 mov	 al, BYTE PTR [edi+7]
  0021e	88 45 db	 mov	 BYTE PTR _y$1[ebp], al

; 12380: 
; 12381: 		if ( gObjCheckTeleportArea(aIndex, x, y) == FALSE )

  00221	ff 75 db	 push	 DWORD PTR _y$1[ebp]
  00224	88 45 e3	 mov	 BYTE PTR _y$1$[ebp], al
  00227	ff 75 df	 push	 DWORD PTR _x$2[ebp]
  0022a	53		 push	 ebx
  0022b	e8 00 00 00 00	 call	 ?gObjCheckTeleportArea@@YAHHEE@Z ; gObjCheckTeleportArea

; 12382: 		{
; 12383: 			LogAddC(2, "[%s][%s] Try Teleport Not Move Area [%d,%d]",

  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00236	83 c4 20	 add	 esp, 32			; 00000020H
  00239	85 c0		 test	 eax, eax
  0023b	0f 85 81 00 00
	00		 jne	 $LN12@CGTeleport
  00241	0f b6 45 e3	 movzx	 eax, BYTE PTR _y$1$[ebp]
  00245	50		 push	 eax
  00246	0f b6 45 df	 movzx	 eax, BYTE PTR _x$2[ebp]
  0024a	50		 push	 eax
  0024b	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0024e	03 c6		 add	 eax, esi
  00250	50		 push	 eax
  00251	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00254	03 c6		 add	 eax, esi
  00256	50		 push	 eax
  00257	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PIOKLDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Teleport?5Not?5Move?5A@
  0025c	6a 02		 push	 2
  0025e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 12384: 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 12385: 				x, y);
; 12386: 
; 12387: 			PMSG_TELEPORT_RESULT pTeleportResult;
; 12388: 
; 12389: 			pTeleportResult.h.c = 0xC3;
; 12390: 			pTeleportResult.h.size = sizeof(pTeleportResult);
; 12391: 			pTeleportResult.h.headcode = 0x1C;
; 12392: 			pTeleportResult.MoveNumber = 0;
; 12393: 			pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  00264	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026a	33 c0		 xor	 eax, eax
  0026c	66 89 45 e8	 mov	 WORD PTR _pTeleportResult$3[ebp+4], ax
  00270	66 c7 45 e4 c3
	0a		 mov	 WORD PTR _pTeleportResult$3[ebp], 2755 ; 00000ac3H
  00276	c6 45 e6 1c	 mov	 BYTE PTR _pTeleportResult$3[ebp+2], 28 ; 0000001cH
  0027a	8a 84 0e 23 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+291]
  00281	88 45 ea	 mov	 BYTE PTR _pTeleportResult$3[ebp+6], al

; 12394: 			pTeleportResult.MapX = gObj[aIndex].X;

  00284	8a 84 0e 20 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+288]
  0028b	88 45 eb	 mov	 BYTE PTR _pTeleportResult$3[ebp+7], al

; 12395: 			pTeleportResult.MapY = gObj[aIndex].Y;

  0028e	8a 84 0e 21 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+289]
  00295	88 45 ec	 mov	 BYTE PTR _pTeleportResult$3[ebp+8], al

; 12396: 			pTeleportResult.Dir = gObj[aIndex].Dir;

  00298	8a 84 0e 22 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+290]
  0029f	88 45 ed	 mov	 BYTE PTR _pTeleportResult$3[ebp+9], al

; 12397: 
; 12398: 			DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);

  002a2	8d 45 e4	 lea	 eax, DWORD PTR _pTeleportResult$3[ebp]
  002a5	6a 0a		 push	 10			; 0000000aH
  002a7	50		 push	 eax
  002a8	53		 push	 ebx
  002a9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002ae	83 c4 24	 add	 esp, 36			; 00000024H
  002b1	5e		 pop	 esi
  002b2	5f		 pop	 edi
  002b3	5b		 pop	 ebx

; 12459: 		}
; 12460: #endif
; 12461: 	}
; 12462: }

  002b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b7	33 cd		 xor	 ecx, ebp
  002b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002be	8b e5		 mov	 esp, ebp
  002c0	5d		 pop	 ebp
  002c1	c3		 ret	 0
$LN12@CGTeleport:

; 12399: 			return;
; 12400: 		}
; 12401: #if (GS_CASTLE == 1)
; 12402: 
; 12403: 		if ( gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE )

  002c2	80 bc 0e 23 01
	00 00 1e	 cmp	 BYTE PTR [esi+ecx+291], 30 ; 0000001eH
  002ca	75 31		 jne	 SHORT $LN14@CGTeleport

; 12404: 		{
; 12405: 			if( g_CastleSiege.CheckTeleportMagicAxisY(gObj[aIndex].Y,x,y) == FALSE )

  002cc	0f b6 45 e3	 movzx	 eax, BYTE PTR _y$1$[ebp]
  002d0	50		 push	 eax
  002d1	0f b6 45 df	 movzx	 eax, BYTE PTR _x$2[ebp]
  002d5	50		 push	 eax
  002d6	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  002de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 ?CheckTeleportMagicAxisY@CCastleSiege@@QAEHHHH@Z ; CCastleSiege::CheckTeleportMagicAxisY

; 12406: 			{
; 12407: 				y = gObj[aIndex].Y;

  002e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ef	85 c0		 test	 eax, eax
  002f1	75 0a		 jne	 SHORT $LN14@CGTeleport
  002f3	8a 84 0e 21 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+289]
  002fa	88 45 db	 mov	 BYTE PTR _y$1[ebp], al
$LN14@CGTeleport:

; 12408: 			}
; 12409: 		}
; 12410: #endif
; 12411: 
; 12412: 		if ( lpMagic )

  002fd	8b 7d d4	 mov	 edi, DWORD PTR _lpMagic$1$[ebp]
  00300	85 ff		 test	 edi, edi
  00302	0f 84 27 02 00
	00		 je	 $LN37@CGTeleport

; 12413: 		{
; 12414: 			int usemana = gObjMagicManaUse(&gObj[aIndex], lpMagic);

  00308	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0030b	57		 push	 edi
  0030c	50		 push	 eax
  0030d	e8 00 00 00 00	 call	 ?gObjMagicManaUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicManaUse
  00312	83 c4 08	 add	 esp, 8
  00315	89 45 d4	 mov	 DWORD PTR _usemana$1$[ebp], eax

; 12415: 
; 12416: 			if ( usemana >= 0 )

  00318	85 c0		 test	 eax, eax
  0031a	0f 88 0f 02 00
	00		 js	 $LN37@CGTeleport

; 12417: 			{
; 12418: 				int usebp = gObjMagicBPUse(&gObj[aIndex], lpMagic);

  00320	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00326	03 ce		 add	 ecx, esi
  00328	57		 push	 edi
  00329	51		 push	 ecx
  0032a	e8 00 00 00 00	 call	 ?gObjMagicBPUse@@YAHPAUOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
  0032f	8b f8		 mov	 edi, eax
  00331	83 c4 08	 add	 esp, 8

; 12419: 				
; 12420: 				if ( usebp >= 0 )

  00334	85 ff		 test	 edi, edi
  00336	0f 88 f3 01 00
	00		 js	 $LN37@CGTeleport

; 12421: 				{
; 12422: 					if ( gObj[aIndex].Type == OBJ_USER )

  0033c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00342	80 7c 0e 50 01	 cmp	 BYTE PTR [esi+ecx+80], 1
  00347	75 18		 jne	 SHORT $LN18@CGTeleport

; 12423: 						DataSend(aIndex, (LPBYTE)&pAttack, pAttack.h.size);

  00349	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pAttack$5[ebp+1]
  0034d	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$5[ebp]
  00350	51		 push	 ecx
  00351	50		 push	 eax
  00352	53		 push	 ebx
  00353	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00358	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0035e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@CGTeleport:

; 12424: 
; 12425: 					MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  00361	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$5[ebp+1]
  00365	50		 push	 eax
  00366	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$5[ebp]
  00369	50		 push	 eax
  0036a	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0036d	50		 push	 eax
  0036e	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 12426: 					gObjTeleportMagicUse(aIndex, x, y);

  00373	ff 75 db	 push	 DWORD PTR _y$1[ebp]
  00376	ff 75 df	 push	 DWORD PTR _x$2[ebp]
  00379	53		 push	 ebx
  0037a	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse
  0037f	66 0f 6e 45 d4	 movd	 xmm0, DWORD PTR _usemana$1$[ebp]

; 12427: 					gObj[aIndex].Mana = (float)usemana;

  00384	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00389	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0038c	f3 0f 11 84 06
	ec 00 00 00	 movss	 DWORD PTR [esi+eax+236], xmm0

; 12428: 					gObj[aIndex].BP = usebp;

  00395	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0039a	89 bc 06 04 01
	00 00		 mov	 DWORD PTR [esi+eax+260], edi

; 12429: 					GCManaSend(gObj[aIndex].m_Index, (WORD)gObj[aIndex].Mana, -1, 0, gObj[aIndex].BP);

  003a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a7	0f b7 84 0e 04
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+260]
  003af	50		 push	 eax
  003b0	f3 0f 2c 84 0e
	ec 00 00 00	 cvttss2si eax, DWORD PTR [esi+ecx+236]
  003b9	6a 00		 push	 0
  003bb	68 ff 00 00 00	 push	 255			; 000000ffH
  003c0	0f b7 c0	 movzx	 eax, ax
  003c3	50		 push	 eax
  003c4	ff 34 0e	 push	 DWORD PTR [esi+ecx]
  003c7	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  003cc	83 c4 2c	 add	 esp, 44			; 0000002cH
  003cf	5e		 pop	 esi
  003d0	5f		 pop	 edi
  003d1	5b		 pop	 ebx

; 12459: 		}
; 12460: #endif
; 12461: 	}
; 12462: }

  003d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d5	33 cd		 xor	 ecx, ebp
  003d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003dc	8b e5		 mov	 esp, ebp
  003de	5d		 pop	 ebp
  003df	c3		 ret	 0
$LN10@CGTeleport:

; 12430: 				}
; 12431: 			}
; 12432: 		}
; 12433: 	}
; 12434: 	else if ( IF_MAP_RANGE(gObj[aIndex].MapNumber) )

  003e0	8a 84 0e 23 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+291]
  003e7	3c 45		 cmp	 al, 69			; 00000045H
  003e9	72 3c		 jb	 SHORT $LN19@CGTeleport
  003eb	b1 48		 mov	 cl, 72			; 00000048H
  003ed	3a c8		 cmp	 cl, al
  003ef	1b c0		 sbb	 eax, eax
  003f1	83 c0 01	 add	 eax, 1
  003f4	74 31		 je	 SHORT $LN19@CGTeleport

; 12435: 	{
; 12436: 		int nZoneIndex = g_ImperialGuardian.GetCurrentZoneIndex(aIndex);

  003f6	53		 push	 ebx
  003f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  003fc	e8 00 00 00 00	 call	 ?GetCurrentZoneIndex@CImperialGuardian@@QAEHH@Z ; CImperialGuardian::GetCurrentZoneIndex

; 12437: 
; 12438: 		if( nZoneIndex >= 0 )

  00401	85 c0		 test	 eax, eax
  00403	0f 88 26 01 00
	00		 js	 $LN37@CGTeleport

; 12439: 		{
; 12440: 			g_ImperialGuardian.CGEnterPortal(aIndex,nZoneIndex+1);

  00409	40		 inc	 eax
  0040a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  0040f	50		 push	 eax
  00410	53		 push	 ebx
  00411	e8 00 00 00 00	 call	 ?CGEnterPortal@CImperialGuardian@@QAEXHH@Z ; CImperialGuardian::CGEnterPortal
  00416	5e		 pop	 esi
  00417	5f		 pop	 edi
  00418	5b		 pop	 ebx

; 12459: 		}
; 12460: #endif
; 12461: 	}
; 12462: }

  00419	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041c	33 cd		 xor	 ecx, ebp
  0041e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00423	8b e5		 mov	 esp, ebp
  00425	5d		 pop	 ebp
  00426	c3		 ret	 0
$LN19@CGTeleport:

; 12441: 		}
; 12442: 	}
; 12443: 	else if ( gGateC.IsInGate(aIndex, lpMsg->MoveNumber) )

  00427	52		 push	 edx
  00428	53		 push	 ebx
  00429	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  0042e	e8 00 00 00 00	 call	 ?IsInGate@CGate@@QAEHHH@Z ; CGate::IsInGate
  00433	85 c0		 test	 eax, eax
  00435	74 1f		 je	 SHORT $LN22@CGTeleport

; 12444: 	{
; 12445: 		gObjMoveGate(aIndex, lpMsg->MoveNumber);

  00437	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  0043b	50		 push	 eax
  0043c	53		 push	 ebx
  0043d	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00442	83 c4 08	 add	 esp, 8
  00445	5e		 pop	 esi
  00446	5f		 pop	 edi
  00447	5b		 pop	 ebx

; 12459: 		}
; 12460: #endif
; 12461: 	}
; 12462: }

  00448	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0044b	33 cd		 xor	 ecx, ebp
  0044d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00452	8b e5		 mov	 esp, ebp
  00454	5d		 pop	 ebp
  00455	c3		 ret	 0
$LN22@CGTeleport:

; 12446: 	}
; 12447: 	else
; 12448: 	{
; 12449: 		gObjClearViewport(&gObj[aIndex]);

  00456	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0045b	03 c6		 add	 eax, esi
  0045d	50		 push	 eax
  0045e	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 12450: 		GCTeleportSend(&gObj[aIndex], lpMsg->MoveNumber, 

  00463	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00469	03 ce		 add	 ecx, esi
  0046b	0f b6 81 22 01
	00 00		 movzx	 eax, BYTE PTR [ecx+290]
  00472	50		 push	 eax
  00473	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  0047a	50		 push	 eax
  0047b	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  00482	50		 push	 eax
  00483	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  0048a	50		 push	 eax
  0048b	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  0048f	50		 push	 eax
  00490	51		 push	 ecx
  00491	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAUOBJECTSTRUCT@@HEEEE@Z ; GCTeleportSend

; 12451: 			gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y, gObj[aIndex].Dir);
; 12452: 
; 12453: #if (GS_CASTLE == 1)
; 12454: 		if( gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE 
; 12455: 			&& g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)

  00496	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0049b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0049e	80 bc 06 23 01
	00 00 1e	 cmp	 BYTE PTR [esi+eax+291], 30 ; 0000001eH
  004a6	0f 85 83 00 00
	00		 jne	 $LN37@CGTeleport
  004ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  004b1	e8 00 00 00 00	 call	 ?GetCastleState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetCastleState
  004b6	83 f8 07	 cmp	 eax, 7
  004b9	75 74		 jne	 SHORT $LN37@CGTeleport

; 12456: 		{
; 12457: 			g_CastleSiege.NotifySelfCsJoinSide(aIndex);

  004bb	53		 push	 ebx
  004bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  004c1	e8 00 00 00 00	 call	 ?NotifySelfCsJoinSide@CCastleSiege@@QAEXH@Z ; CCastleSiege::NotifySelfCsJoinSide

; 12458: 			g_CastleSiege.NotifyCsSelfLeftTime(aIndex);

  004c6	53		 push	 ebx
  004c7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  004cc	e8 00 00 00 00	 call	 ?NotifyCsSelfLeftTime@CCastleSiege@@QAEXH@Z ; CCastleSiege::NotifyCsSelfLeftTime
  004d1	5e		 pop	 esi
  004d2	5f		 pop	 edi
  004d3	5b		 pop	 ebx

; 12459: 		}
; 12460: #endif
; 12461: 	}
; 12462: }

  004d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d7	33 cd		 xor	 ecx, ebp
  004d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004de	8b e5		 mov	 esp, ebp
  004e0	5d		 pop	 ebp
  004e1	c3		 ret	 0
$LN4@CGTeleport:

; 12293: 		 gObjCheckUsedBuffEffect(&gObj[aIndex],BUFF_FREEZE) == TRUE )
; 12294: 	{
; 12295: 		PMSG_TELEPORT_RESULT pTeleportResult;
; 12296: 		pTeleportResult.h.c = 0xC3;
; 12297: 		pTeleportResult.h.size = sizeof(pTeleportResult);
; 12298: 		pTeleportResult.h.headcode = 0x1C;
; 12299: 		pTeleportResult.MoveNumber = 0;
; 12300: 		pTeleportResult.MapNumber = gObj[aIndex].MapNumber;

  004e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004e8	33 c0		 xor	 eax, eax
  004ea	66 89 45 e8	 mov	 WORD PTR _pTeleportResult$4[ebp+4], ax
  004ee	66 c7 45 e4 c3
	0a		 mov	 WORD PTR _pTeleportResult$4[ebp], 2755 ; 00000ac3H
  004f4	c6 45 e6 1c	 mov	 BYTE PTR _pTeleportResult$4[ebp+2], 28 ; 0000001cH
  004f8	8a 84 0e 23 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+291]
  004ff	88 45 ea	 mov	 BYTE PTR _pTeleportResult$4[ebp+6], al

; 12301: 		pTeleportResult.MapX = gObj[aIndex].X;

  00502	8a 84 0e 20 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+288]
  00509	88 45 eb	 mov	 BYTE PTR _pTeleportResult$4[ebp+7], al

; 12302: 		pTeleportResult.MapY = gObj[aIndex].Y;

  0050c	8a 84 0e 21 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+289]
  00513	88 45 ec	 mov	 BYTE PTR _pTeleportResult$4[ebp+8], al

; 12303: 		pTeleportResult.Dir = gObj[aIndex].Dir;

  00516	8a 84 0e 22 01
	00 00		 mov	 al, BYTE PTR [esi+ecx+290]
  0051d	88 45 ed	 mov	 BYTE PTR _pTeleportResult$4[ebp+9], al

; 12304: 		DataSend(aIndex, (LPBYTE)&pTeleportResult, pTeleportResult.h.size);

  00520	8d 45 e4	 lea	 eax, DWORD PTR _pTeleportResult$4[ebp]
$LN38@CGTeleport:
  00523	6a 0a		 push	 10			; 0000000aH
  00525	50		 push	 eax
  00526	53		 push	 ebx
  00527	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0052c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN37@CGTeleport:
  0052f	5e		 pop	 esi
$LN24@CGTeleport:

; 12459: 		}
; 12460: #endif
; 12461: 	}
; 12462: }

  00530	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00533	5f		 pop	 edi
  00534	33 cd		 xor	 ecx, ebp
  00536	5b		 pop	 ebx
  00537	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0053c	8b e5		 mov	 esp, ebp
  0053e	5d		 pop	 ebp
  0053f	c3		 ret	 0
?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z ENDP		; CGTeleportRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_lpObj$ = 8						; size = 4
_state$ = 12						; size = 1
_Effect$ = 16						; size = 1
?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z PROC		; GCStateInfoSend, COMDAT

; 12253: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 12254: 	PMSG_VIEWSKILLSTATE pMsg;
; 12255: 
; 12256: 	PHeadSetB((LPBYTE)&pMsg, 0x07, sizeof(pMsg));

  00007	6a 07		 push	 7
  00009	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000c	6a 07		 push	 7
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12257: 	pMsg.State = state;

  00014	8a 45 0c	 mov	 al, BYTE PTR _state$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12258: 	pMsg.Effect = Effect;
; 12259: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0001a	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0001d	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00020	8a 45 10	 mov	 al, BYTE PTR _Effect$[ebp]
  00023	88 45 fe	 mov	 BYTE PTR _pMsg$[ebp+6], al
  00026	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00028	8b c1		 mov	 eax, ecx
  0002a	c1 e8 08	 shr	 eax, 8

; 12260: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 12261: 
; 12262: 	if ( lpObj->Type == OBJ_USER )

  0002d	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00031	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00034	0f b6 c1	 movzx	 eax, cl
  00037	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  0003a	75 12		 jne	 SHORT $LN2@GCStateInf

; 12263: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0003c	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00040	50		 push	 eax
  00041	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00044	50		 push	 eax
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCStateInf:

; 12264: 
; 12265: 	if ( CC_MAP_RANGE(lpObj->MapNumber) != FALSE )

  0004e	8a 86 23 01 00
	00		 mov	 al, BYTE PTR [esi+291]
  00054	3c 35		 cmp	 al, 53			; 00000035H
  00056	74 0f		 je	 SHORT $LN9@GCStateInf
  00058	3c 12		 cmp	 al, 18			; 00000012H
  0005a	72 0f		 jb	 SHORT $LN3@GCStateInf
  0005c	b1 17		 mov	 cl, 23			; 00000017H
  0005e	3a c8		 cmp	 cl, al
  00060	1b c0		 sbb	 eax, eax
  00062	83 c0 01	 add	 eax, 1
  00065	74 04		 je	 SHORT $LN3@GCStateInf
$LN9@GCStateInf:

; 12266: 		pMsg.Effect = 0;

  00067	c6 45 fe 00	 mov	 BYTE PTR _pMsg$[ebp+6], 0
$LN3@GCStateInf:

; 12267: 
; 12268: 	MsgSendV2(lpObj, (UCHAR*)&pMsg, pMsg.h.size);

  0006b	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0006f	50		 push	 eax
  00070	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00073	50		 push	 eax
  00074	56		 push	 esi
  00075	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	5e		 pop	 esi

; 12269: }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ENDP		; GCStateInfoSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_iSkillNumber$ = 16					; size = 4
?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z PROC	; GCUseMonsterSkillSend, COMDAT

; 12223: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]

; 12224: 	PMSG_USE_MONSTERSKILL pMsg;
; 12225: 
; 12226: 	PHeadSetB((LPBYTE)&pMsg, 0x69, sizeof(pMsg));

  00014	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001b	6a 0a		 push	 10			; 0000000aH
  0001d	6a 69		 push	 105			; 00000069H
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12227: 
; 12228: 	pMsg.btMonsterSkillNumberH = SET_NUMBERH(iSkillNumber);

  00025	8b 4d 10	 mov	 ecx, DWORD PTR _iSkillNumber$[ebp]
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	8b c1		 mov	 eax, ecx

; 12229: 	pMsg.btMonsterSkillNumberL = SET_NUMBERL(iSkillNumber);

  0002d	88 4d f4	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00030	c1 e8 08	 shr	 eax, 8

; 12230: 
; 12231: 
; 12232: 	pMsg.wObjIndex = lpObj->m_Index;
; 12233: 	pMsg.wTargetObjIndex = lpTargetObj->m_Index;
; 12234: 
; 12235: 	if ( lpObj->Type == OBJ_USER )

  00033	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00037	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al
  0003a	0f b7 07	 movzx	 eax, WORD PTR [edi]
  0003d	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+6], ax
  00041	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00044	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+8], ax
  00048	75 13		 jne	 SHORT $LN2@GCUseMonst

; 12236: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0004a	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0004e	50		 push	 eax
  0004f	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00052	50		 push	 eax
  00053	ff 37		 push	 DWORD PTR [edi]
  00055	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCUseMonst:

; 12237: 
; 12238: 	MsgSendV2(lpObj, (UCHAR*)&pMsg, pMsg.h.size);

  0005d	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00061	50		 push	 eax
  00062	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00065	50		 push	 eax
  00066	57		 push	 edi
  00067	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 12239: }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	33 cd		 xor	 ecx, ebp
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?GCUseMonsterSkillSend@@YAXPAUOBJECTSTRUCT@@0H@Z ENDP	; GCUseMonsterSkillSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z PROC	; CGMagicCancel, COMDAT

; 12166: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 12167: 	if ( !OBJMAX_RANGE(aIndex))

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	0f 88 0b 01 00
	00		 js	 $LN16@CGMagicCan
  0000e	33 c0		 xor	 eax, eax
  00010	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00016	0f 9e c0	 setle	 al
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 f8 00 00
	00		 je	 $LN16@CGMagicCan

; 12168: 		return;
; 12169: 
; 12170: 	LPOBJ lpObj = &gObj[aIndex];
; 12171: 
; 12172: 	WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH,lpMsg->MagicNumberL);

  00021	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00024	56		 push	 esi
  00025	69 f1 40 27 00
	00		 imul	 esi, ecx, 10048
  0002b	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0002f	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00033	66 c1 e1 08	 shl	 cx, 8
  00037	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	66 0b c8	 or	 cx, ax
  00040	0f b7 c1	 movzx	 eax, cx

; 12173: 
; 12174: 	if ( MagicNumber == AT_SKILL_INFINITY_ARROW )

  00043	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00046	75 21		 jne	 SHORT $LN3@CGMagicCan

; 12175: 	{
; 12176: 		if ( gObjCheckUsedBuffEffect(lpObj,BUFF_INFINITY_ARROW) == TRUE )

  00048	6a 06		 push	 6
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00050	83 c4 08	 add	 esp, 8
  00053	3c 01		 cmp	 al, 1
  00055	0f 85 bd 00 00
	00		 jne	 $LN20@CGMagicCan

; 12177: 		{
; 12178: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW);

  0005b	6a 06		 push	 6

; 12205: 		{
; 12206: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  00063	83 c4 08	 add	 esp, 8
  00066	5e		 pop	 esi

; 12207: 		}
; 12208: 	}
; 12209: }

  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN3@CGMagicCan:

; 12179: 		}
; 12180: 	}
; 12181: 	else if( MagicNumber == AT_SKILL_EXPWIZARDRY )

  00069	b9 e9 00 00 00	 mov	 ecx, 233		; 000000e9H
  0006e	66 3b c1	 cmp	 ax, cx
  00071	75 21		 jne	 SHORT $LN6@CGMagicCan

; 12182: 	{
; 12183: 		if ( gObjCheckUsedBuffEffect(lpObj,BUFF_EXP_WIZARDRY) == TRUE )

  00073	6a 52		 push	 82			; 00000052H
  00075	56		 push	 esi
  00076	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0007b	83 c4 08	 add	 esp, 8
  0007e	3c 01		 cmp	 al, 1
  00080	0f 85 92 00 00
	00		 jne	 $LN20@CGMagicCan

; 12184: 		{
; 12185: 			gObjRemoveBuffEffect(lpObj,BUFF_EXP_WIZARDRY);

  00086	6a 52		 push	 82			; 00000052H

; 12205: 		{
; 12206: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  00088	56		 push	 esi
  00089	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  0008e	83 c4 08	 add	 esp, 8
  00091	5e		 pop	 esi

; 12207: 		}
; 12208: 	}
; 12209: }

  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN6@CGMagicCan:

; 12186: 		}
; 12187: 	}
; 12188: 	else if( MagicNumber == AT_MSKILL_DW_EXPWIZARDRY1 )

  00094	b9 7c 01 00 00	 mov	 ecx, 380		; 0000017cH
  00099	66 3b c1	 cmp	 ax, cx
  0009c	75 23		 jne	 SHORT $LN9@CGMagicCan

; 12189: 	{
; 12190: 		if ( gObjCheckUsedBuffEffect(lpObj,BUFF_EXP_WIZARDRY2) == TRUE )

  0009e	68 8a 00 00 00	 push	 138			; 0000008aH
  000a3	56		 push	 esi
  000a4	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000a9	83 c4 08	 add	 esp, 8
  000ac	3c 01		 cmp	 al, 1
  000ae	75 68		 jne	 SHORT $LN20@CGMagicCan

; 12191: 		{
; 12192: 			gObjRemoveBuffEffect(lpObj,BUFF_EXP_WIZARDRY2);

  000b0	68 8a 00 00 00	 push	 138			; 0000008aH

; 12205: 		{
; 12206: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  000b5	56		 push	 esi
  000b6	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  000bb	83 c4 08	 add	 esp, 8
  000be	5e		 pop	 esi

; 12207: 		}
; 12208: 	}
; 12209: }

  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
$LN9@CGMagicCan:

; 12193: 		}
; 12194: 	}
; 12195: 	else if( MagicNumber == AT_MSKILL_DW_EXPWIZARDRY2 )

  000c1	b9 7f 01 00 00	 mov	 ecx, 383		; 0000017fH
  000c6	66 3b c1	 cmp	 ax, cx
  000c9	75 23		 jne	 SHORT $LN12@CGMagicCan

; 12196: 	{
; 12197: 		if ( gObjCheckUsedBuffEffect(lpObj,BUFF_EXP_WIZARDRY3) == TRUE )

  000cb	68 8b 00 00 00	 push	 139			; 0000008bH
  000d0	56		 push	 esi
  000d1	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000d6	83 c4 08	 add	 esp, 8
  000d9	3c 01		 cmp	 al, 1
  000db	75 3b		 jne	 SHORT $LN20@CGMagicCan

; 12198: 		{
; 12199: 			gObjRemoveBuffEffect(lpObj,BUFF_EXP_WIZARDRY3);

  000dd	68 8b 00 00 00	 push	 139			; 0000008bH

; 12205: 		{
; 12206: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  000e2	56		 push	 esi
  000e3	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  000e8	83 c4 08	 add	 esp, 8
  000eb	5e		 pop	 esi

; 12207: 		}
; 12208: 	}
; 12209: }

  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
$LN12@CGMagicCan:

; 12200: 		}
; 12201: 	}
; 12202: 	else if( MagicNumber == AT_MSKILL_FE_INFINITY1 )

  000ee	b9 b9 01 00 00	 mov	 ecx, 441		; 000001b9H
  000f3	66 3b c1	 cmp	 ax, cx
  000f6	75 20		 jne	 SHORT $LN20@CGMagicCan

; 12203: 	{
; 12204: 		if( gObjCheckUsedBuffEffect(lpObj,BUFF_INFINITY_ARROW2) == TRUE )

  000f8	68 8f 00 00 00	 push	 143			; 0000008fH
  000fd	56		 push	 esi
  000fe	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00103	83 c4 08	 add	 esp, 8
  00106	3c 01		 cmp	 al, 1
  00108	75 0e		 jne	 SHORT $LN20@CGMagicCan

; 12205: 		{
; 12206: 			gObjRemoveBuffEffect(lpObj,BUFF_INFINITY_ARROW2);

  0010a	68 8f 00 00 00	 push	 143			; 0000008fH
  0010f	56		 push	 esi
  00110	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect
  00115	83 c4 08	 add	 esp, 8
$LN20@CGMagicCan:
  00118	5e		 pop	 esi
$LN16@CGMagicCan:

; 12207: 		}
; 12208: 	}
; 12209: }

  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z ENDP	; CGMagicCancel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSendEffect@@YAXPAUOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iEffectUseOption$ = 12					; size = 4
_iOptionType$ = 16					; size = 4
_iEffectType$ = 20					; size = 4
_iLeftTime$ = 24					; size = 4
?GCSendEffect@@YAXPAUOBJECTSTRUCT@@HHHH@Z PROC		; GCSendEffect, COMDAT

; 12150: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 12151: 	PMSG_SENDEFFECT pMsg;
; 12152: 
; 12153: 	PHeadSetB((LPBYTE)&pMsg, 0x2D, sizeof(pMsg));

  00014	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 18		 push	 24			; 00000018H
  00019	6a 2d		 push	 45			; 0000002dH
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12154: 	pMsg.byEffectOption = iEffectUseOption;

  00021	8a 45 0c	 mov	 al, BYTE PTR _iEffectUseOption$[ebp]
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12155: 	pMsg.wOptionType = iOptionType;
; 12156: 	pMsg.wEffectType = iEffectType;
; 12157: 	pMsg.iLeftTime = iLeftTime;
; 12158: 	pMsg.iEffect = iEffectType;
; 12159: 
; 12160: 	if ( lpObj->Type == OBJ_USER )

  00027	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  0002b	8b 4d 14	 mov	 ecx, DWORD PTR _iEffectType$[ebp]
  0002e	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+8], al
  00031	66 8b 45 10	 mov	 ax, WORD PTR _iOptionType$[ebp]
  00035	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+4], ax
  00039	8b 45 18	 mov	 eax, DWORD PTR _iLeftTime$[ebp]
  0003c	66 89 4d ea	 mov	 WORD PTR _pMsg$[ebp+6], cx
  00040	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00043	88 4d f4	 mov	 BYTE PTR _pMsg$[ebp+16], cl
  00046	75 13		 jne	 SHORT $LN2@GCSendEffe

; 12161: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  00048	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0004c	50		 push	 eax
  0004d	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00050	50		 push	 eax
  00051	ff 36		 push	 DWORD PTR [esi]
  00053	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCSendEffe:

; 12162: }

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005e	33 cd		 xor	 ecx, ebp
  00060	5e		 pop	 esi
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?GCSendEffect@@YAXPAUOBJECTSTRUCT@@HHHH@Z ENDP		; GCSendEffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 4
?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; GCMagicCancelSend, COMDAT

; 12132: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 12133: 	PMSG_MAGICCANCEL pMsg;
; 12134: 
; 12135: 	PHeadSetB((LPBYTE)&pMsg, 0x1B, sizeof(pMsg));

  00007	6a 07		 push	 7
  00009	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000c	6a 1b		 push	 27			; 0000001bH
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 12136: 
; 12137: 	pMsg.MagicNumberH = SET_NUMBERH(MagicNumber);

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _MagicNumber$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12138: 	pMsg.MagicNumberL = SET_NUMBERL(MagicNumber);
; 12139: 
; 12140: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0001a	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0001d	8b c1		 mov	 eax, ecx
  0001f	c1 e8 08	 shr	 eax, 8
  00022	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00025	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00028	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002a	8b c1		 mov	 eax, ecx
  0002c	c1 e8 08	 shr	 eax, 8

; 12141: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 12142: 
; 12143: 	if ( lpObj->Type == OBJ_USER )

  0002f	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00033	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00036	8a c1		 mov	 al, cl
  00038	88 45 fe	 mov	 BYTE PTR _pMsg$[ebp+6], al
  0003b	75 12		 jne	 SHORT $LN2@GCMagicCan

; 12144: 		DataSend(lpObj->m_Index, (UCHAR*)&pMsg, pMsg.h.size);

  0003d	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00041	50		 push	 eax
  00042	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00045	50		 push	 eax
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCMagicCan:

; 12145: 	
; 12146: 	MsgSendV2(lpObj, (UCHAR*)&pMsg, pMsg.h.size);

  0004f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00053	50		 push	 eax
  00054	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00057	50		 push	 eax
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	5e		 pop	 esi

; 12147: }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?GCMagicCancelSend@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; GCMagicCancelSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z
_TEXT	SEGMENT
_pAttack$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_MagicNumber$ = 12					; size = 2
_usernumber$ = 16					; size = 4
_skillsuccess$ = 20					; size = 1
?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z PROC ; GCMagicAttackNumberSend, COMDAT

; 12077: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 12078: 	PMSG_MAGICATTACK_RESULT pAttack;
; 12079: 	
; 12080: 	PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof(pAttack));

  00015	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  00018	6a 09		 push	 9
  0001a	6a 19		 push	 25			; 00000019H
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 12081: 
; 12082: 	pAttack.MagicNumberH = SET_NUMBERH(MagicNumber);

  00022	8b 5d 0c	 mov	 ebx, DWORD PTR _MagicNumber$[ebp]
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12083: 	pAttack.MagicNumberL = SET_NUMBERL(MagicNumber);
; 12084: 
; 12085: 	pAttack.SourceNumberH = SET_NUMBERH(lpObj->m_Index);

  00028	8b 16		 mov	 edx, DWORD PTR [esi]
  0002a	8b c3		 mov	 eax, ebx
  0002c	c1 e8 08	 shr	 eax, 8
  0002f	88 45 f5	 mov	 BYTE PTR _pAttack$[ebp+5], al
  00032	8b c2		 mov	 eax, edx
  00034	c1 e8 08	 shr	 eax, 8
  00037	88 45 f3	 mov	 BYTE PTR _pAttack$[ebp+3], al

; 12086: 	pAttack.SourceNumberL = SET_NUMBERL(lpObj->m_Index);

  0003a	8a c2		 mov	 al, dl
  0003c	88 45 f4	 mov	 BYTE PTR _pAttack$[ebp+4], al

; 12087: 	pAttack.TargetNumberH = SET_NUMBERH(usernumber);

  0003f	8b 45 10	 mov	 eax, DWORD PTR _usernumber$[ebp]
  00042	8b c8		 mov	 ecx, eax
  00044	c1 e9 08	 shr	 ecx, 8

; 12088: 	pAttack.TargetNumberL = SET_NUMBERL(usernumber);
; 12089: 	pAttack.TargetNumberH &= 0x7F;

  00047	80 e1 7f	 and	 cl, 127			; 0000007fH
  0004a	88 5d f6	 mov	 BYTE PTR _pAttack$[ebp+6], bl

; 12090: 
; 12091: 	if ( skillsuccess )

  0004d	80 7d 14 00	 cmp	 BYTE PTR _skillsuccess$[ebp], 0
  00051	88 45 f8	 mov	 BYTE PTR _pAttack$[ebp+8], al
  00054	88 4d f7	 mov	 BYTE PTR _pAttack$[ebp+7], cl
  00057	74 06		 je	 SHORT $LN4@GCMagicAtt

; 12092: 		pAttack.TargetNumberH |= 0x80;

  00059	80 c9 80	 or	 cl, 128			; 00000080H
  0005c	88 4d f7	 mov	 BYTE PTR _pAttack$[ebp+7], cl
$LN4@GCMagicAtt:

; 12093: 
; 12094: 	if ( lpObj->Type == OBJ_USER )

  0005f	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00063	75 12		 jne	 SHORT $LN5@GCMagicAtt

; 12095: 		DataSend(lpObj->m_Index, (LPBYTE)&pAttack, pAttack.h.size);

  00065	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  00069	50		 push	 eax
  0006a	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  0006d	50		 push	 eax
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@GCMagicAtt:

; 12096: 
; 12097: 	if ( CC_MAP_RANGE(lpObj->MapNumber) )

  00077	8a 86 23 01 00
	00		 mov	 al, BYTE PTR [esi+291]
  0007d	3c 35		 cmp	 al, 53			; 00000035H
  0007f	74 0f		 je	 SHORT $LN14@GCMagicAtt
  00081	3c 12		 cmp	 al, 18			; 00000012H
  00083	72 45		 jb	 SHORT $LN2@GCMagicAtt
  00085	b1 17		 mov	 cl, 23			; 00000017H
  00087	3a c8		 cmp	 cl, al
  00089	1b c0		 sbb	 eax, eax
  0008b	83 c0 01	 add	 eax, 1
  0008e	74 3a		 je	 SHORT $LN2@GCMagicAtt
$LN14@GCMagicAtt:

; 12098: 	{
; 12099: 		switch ( MagicNumber )

  00090	0f b7 c3	 movzx	 eax, bx
  00093	3d 64 01 00 00	 cmp	 eax, 356		; 00000164H
  00098	7f 18		 jg	 SHORT $LN13@GCMagicAtt
  0009a	74 40		 je	 SHORT $LN1@GCMagicAtt
  0009c	83 e8 10	 sub	 eax, 16			; 00000010H
  0009f	83 f8 20	 cmp	 eax, 32			; 00000020H
  000a2	77 26		 ja	 SHORT $LN2@GCMagicAtt
  000a4	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN15@GCMagicAtt[eax]
  000ab	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@GCMagicAtt[eax*4]
$LN13@GCMagicAtt:
  000b2	2d 68 01 00 00	 sub	 eax, 360		; 00000168H
  000b7	83 f8 49	 cmp	 eax, 73			; 00000049H
  000ba	77 0e		 ja	 SHORT $LN2@GCMagicAtt
  000bc	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN16@GCMagicAtt[eax]
  000c3	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN19@GCMagicAtt[eax*4]
$LN2@GCMagicAtt:

; 12100: 		{
; 12101: 			case 16:
; 12102: 			case 26:
; 12103: 			case 27:
; 12104: 			case 28:
; 12105: 			case 48:
; 12106: 				// MSKILL
; 12107: 			case AT_MSKILL_DW_MANASHIELD1:
; 12108: 			case AT_MSKILL_DW_MANASHIELD2:
; 12109: 			case AT_MSKILL_FE_HEAL1:
; 12110: 			case AT_MSKILL_FE_DEFENSEBUFF1:
; 12111: 			case AT_MSKILL_FE_DEFENSEBUFF2:
; 12112: 			case AT_MSKILL_FE_CURE:
; 12113: 			case AT_MSKILL_FE_BLESS:
; 12114: 			case AT_MSKILL_FE_BLESS1:
; 12115: 			case AT_MSKILL_FE_ATTACKBUFF1:
; 12116: 			case AT_MSKILL_FE_ATTACKBUFF2:
; 12117: 			case AT_MSKILL_DK_SWELLLIFE1:
; 12118: 			case AT_MSKILL_DK_SWELLLIFE2:
; 12119: 			case AT_MSKILL_DK_SWELLLIFE3:
; 12120: 				return;
; 12121: 		}
; 12122: 	}
; 12123: 	
; 12124: 	MsgSendV2(lpObj, (LPBYTE)&pAttack, pAttack.h.size);

  000ca	0f b6 45 f1	 movzx	 eax, BYTE PTR _pAttack$[ebp+1]
  000ce	50		 push	 eax
  000cf	8d 45 f0	 lea	 eax, DWORD PTR _pAttack$[ebp]
  000d2	50		 push	 eax
  000d3	56		 push	 esi
  000d4	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCMagicAtt:

; 12125: }

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	5e		 pop	 esi
  000e0	33 cd		 xor	 ecx, ebp
  000e2	5b		 pop	 ebx
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
$LN18@GCMagicAtt:
  000ec	00 00 00 00	 DD	 $LN1@GCMagicAtt
  000f0	00 00 00 00	 DD	 $LN2@GCMagicAtt
$LN15@GCMagicAtt:
  000f4	00		 DB	 0
  000f5	01		 DB	 1
  000f6	01		 DB	 1
  000f7	01		 DB	 1
  000f8	01		 DB	 1
  000f9	01		 DB	 1
  000fa	01		 DB	 1
  000fb	01		 DB	 1
  000fc	01		 DB	 1
  000fd	01		 DB	 1
  000fe	00		 DB	 0
  000ff	00		 DB	 0
  00100	00		 DB	 0
  00101	01		 DB	 1
  00102	01		 DB	 1
  00103	01		 DB	 1
  00104	01		 DB	 1
  00105	01		 DB	 1
  00106	01		 DB	 1
  00107	01		 DB	 1
  00108	01		 DB	 1
  00109	01		 DB	 1
  0010a	01		 DB	 1
  0010b	01		 DB	 1
  0010c	01		 DB	 1
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	01		 DB	 1
  00110	01		 DB	 1
  00111	01		 DB	 1
  00112	01		 DB	 1
  00113	01		 DB	 1
  00114	00		 DB	 0
  00115	0f 1f 00	 npad	 3
$LN19@GCMagicAtt:
  00118	00 00 00 00	 DD	 $LN1@GCMagicAtt
  0011c	00 00 00 00	 DD	 $LN2@GCMagicAtt
$LN16@GCMagicAtt:
  00120	00		 DB	 0
  00121	01		 DB	 1
  00122	01		 DB	 1
  00123	00		 DB	 0
  00124	01		 DB	 1
  00125	01		 DB	 1
  00126	01		 DB	 1
  00127	01		 DB	 1
  00128	01		 DB	 1
  00129	01		 DB	 1
  0012a	01		 DB	 1
  0012b	01		 DB	 1
  0012c	01		 DB	 1
  0012d	01		 DB	 1
  0012e	01		 DB	 1
  0012f	01		 DB	 1
  00130	01		 DB	 1
  00131	01		 DB	 1
  00132	01		 DB	 1
  00133	01		 DB	 1
  00134	01		 DB	 1
  00135	01		 DB	 1
  00136	01		 DB	 1
  00137	01		 DB	 1
  00138	01		 DB	 1
  00139	01		 DB	 1
  0013a	01		 DB	 1
  0013b	01		 DB	 1
  0013c	01		 DB	 1
  0013d	01		 DB	 1
  0013e	01		 DB	 1
  0013f	01		 DB	 1
  00140	01		 DB	 1
  00141	01		 DB	 1
  00142	01		 DB	 1
  00143	01		 DB	 1
  00144	01		 DB	 1
  00145	01		 DB	 1
  00146	01		 DB	 1
  00147	01		 DB	 1
  00148	01		 DB	 1
  00149	01		 DB	 1
  0014a	01		 DB	 1
  0014b	00		 DB	 0
  0014c	00		 DB	 0
  0014d	01		 DB	 1
  0014e	01		 DB	 1
  0014f	01		 DB	 1
  00150	01		 DB	 1
  00151	01		 DB	 1
  00152	01		 DB	 1
  00153	01		 DB	 1
  00154	01		 DB	 1
  00155	00		 DB	 0
  00156	01		 DB	 1
  00157	01		 DB	 1
  00158	01		 DB	 1
  00159	00		 DB	 0
  0015a	01		 DB	 1
  0015b	01		 DB	 1
  0015c	00		 DB	 0
  0015d	01		 DB	 1
  0015e	00		 DB	 0
  0015f	00		 DB	 0
  00160	01		 DB	 1
  00161	00		 DB	 0
  00162	01		 DB	 1
  00163	01		 DB	 1
  00164	01		 DB	 1
  00165	01		 DB	 1
  00166	00		 DB	 0
  00167	01		 DB	 1
  00168	01		 DB	 1
  00169	00		 DB	 0
?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ENDP ; GCMagicAttackNumberSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z
_TEXT	SEGMENT
tv533 = -4						; size = 4
_lpTargetObj$1$ = -4					; size = 4
_MagicNumber$1$ = 8					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z PROC	; CGMagicAttack, COMDAT

; 11929: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 11930: 	LPOBJ lpObj;
; 11931: 	LPOBJ lpTargetObj;
; 11932: 	int usernumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00004	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00007	53		 push	 ebx
  00008	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]

; 11933: 	CMagicInf * lpMagic;
; 11934: 	WORD MagicNumber = MAKE_NUMBERW(lpMsg->MagicNumberH,lpMsg->MagicNumberL);

  0000c	0f b6 4a 04	 movzx	 ecx, BYTE PTR [edx+4]
  00010	66 c1 e0 08	 shl	 ax, 8
  00014	0f b7 d8	 movzx	 ebx, ax
  00017	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  0001b	0b d8		 or	 ebx, eax
  0001d	66 c1 e1 08	 shl	 cx, 8
  00021	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  00025	66 0b c8	 or	 cx, ax
  00028	0f b7 c1	 movzx	 eax, cx
  0002b	89 45 08	 mov	 DWORD PTR _MagicNumber$1$[ebp], eax

; 11935: 
; 11936: 	if ( usernumber < 0 || usernumber > OBJMAX-1 )

  0002e	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00034	0f 87 01 03 00
	00		 ja	 $LN5@CGMagicAtt

; 11939: 		return;
; 11940: 	}
; 11941: 
; 11942: 	if ( gObj[usernumber].Live == 0 || gObj[usernumber].Connected  < PLAYER_LOGGED )

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00040	69 c3 40 27 00
	00		 imul	 eax, ebx, 10048
  00046	89 45 fc	 mov	 DWORD PTR tv533[ebp], eax
  00049	80 7c 08 51 00	 cmp	 BYTE PTR [eax+ecx+81], 0
  0004e	0f 84 cb 01 00
	00		 je	 $LN1@CGMagicAtt
  00054	83 7c 08 04 02	 cmp	 DWORD PTR [eax+ecx+4], 2
  00059	0f 8c c0 01 00
	00		 jl	 $LN1@CGMagicAtt

; 11943: 		return;
; 11944: 
; 11945: 	if ( gObj[aIndex].CloseCount >= 0 )

  0005f	56		 push	 esi
  00060	57		 push	 edi
  00061	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00064	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0006a	80 7c 0e 0c 00	 cmp	 BYTE PTR [esi+ecx+12], 0
  0006f	0f 8d a8 01 00
	00		 jge	 $LN31@CGMagicAtt

; 11946: 		return;
; 11947: 
; 11948: 	BYTE MapAttr = MapC[gObj[aIndex].MapNumber].GetAttr(gObj[aIndex].X,gObj[aIndex].Y);

  00075	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  0007d	50		 push	 eax
  0007e	0f b6 84 0e 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+288]
  00086	50		 push	 eax
  00087	0f b6 84 0e 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+291]
  0008f	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  00095	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0009b	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 11949: 
; 11950: 	if ( (MapAttr&1)==TRUE && MagicNumber == 58 )

  000a0	a8 01		 test	 al, 1
  000a2	74 41		 je	 SHORT $LN9@CGMagicAtt
  000a4	66 83 7d 08 3a	 cmp	 WORD PTR _MagicNumber$1$[ebp], 58 ; 0000003aH
  000a9	75 3a		 jne	 SHORT $LN9@CGMagicAtt

; 11951: 	{
; 11952: 		GCMagicAttackNumberSend(&gObj[aIndex],40,aIndex,TRUE);

  000ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b0	6a 01		 push	 1
  000b2	57		 push	 edi
  000b3	03 c6		 add	 eax, esi
  000b5	6a 28		 push	 40			; 00000028H
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@GHE@Z ; GCMagicAttackNumberSend

; 11953: 		gObjSetPosition(aIndex,gObj[aIndex].X,gObj[aIndex].Y);

  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c3	0f b6 84 31 21
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+289]
  000cb	50		 push	 eax
  000cc	0f b6 84 31 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+esi+288]
  000d4	50		 push	 eax
  000d5	57		 push	 edi
  000d6	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  000db	83 c4 1c	 add	 esp, 28			; 0000001cH
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx

; 12071: }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
$LN9@CGMagicAtt:

; 11954: 		return;
; 11955: 	}
; 11956: 
; 11957: 	lpObj = &gObj[aIndex];

  000e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ea	03 f0		 add	 esi, eax

; 11958: 	lpTargetObj = &gObj[usernumber];

  000ec	03 45 fc	 add	 eax, DWORD PTR tv533[ebp]

; 11959: 	
; 11960: 	int attackret = gObjCheckAttackArea(aIndex, usernumber);

  000ef	53		 push	 ebx
  000f0	57		 push	 edi
  000f1	89 45 fc	 mov	 DWORD PTR _lpTargetObj$1$[ebp], eax
  000f4	e8 00 00 00 00	 call	 ?gObjCheckAttackArea@@YAHHH@Z ; gObjCheckAttackArea
  000f9	83 c4 08	 add	 esp, 8

; 11961: 
; 11962: 	if ( attackret )

  000fc	85 c0		 test	 eax, eax
  000fe	74 64		 je	 SHORT $LN12@CGMagicAtt

; 11963: 	{
; 11964: 		LogAddTD("[%s][%s] Try Attack In Not Attack Area [Protocol] (%s:%d,%d) errortype = %d",

  00100	50		 push	 eax
  00101	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00108	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0010d	50		 push	 eax
  0010e	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00115	50		 push	 eax
  00116	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  0011d	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00128	50		 push	 eax
  00129	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0012c	50		 push	 eax
  0012d	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00130	50		 push	 eax
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@CEMNDEFL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 11965: 			lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 208)+lpObj->MapNumber), lpObj->X, lpObj->Y,
; 11966: 			attackret);
; 11967: 
; 11968: 		if ( lpObj->Class == 275 )	// Kundun

  0013c	b8 13 01 00 00	 mov	 eax, 275		; 00000113H
  00141	83 c4 1c	 add	 esp, 28			; 0000001cH
  00144	66 39 86 90 00
	00 00		 cmp	 WORD PTR [esi+144], ax
  0014b	75 0a		 jne	 SHORT $LN11@CGMagicAtt

; 11969: 			lpObj->TargetNumber = -1;

  0014d	83 c8 ff	 or	 eax, -1
  00150	66 89 86 38 06
	00 00		 mov	 WORD PTR [esi+1592], ax
$LN11@CGMagicAtt:

; 11970: 
; 11971: 		if ( bIsIgnorePacketSpeedHackDetect )

  00157	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  0015e	0f 85 b9 00 00
	00		 jne	 $LN31@CGMagicAtt
$LN12@CGMagicAtt:

; 11972: 			return;
; 11973: 	}
; 11974: 
; 11975: 	if ( lpObj->Type == OBJ_USER )

  00164	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1

; 11976: 	{
; 11977: 		lpMagic = gObjGetMagicSearch(lpObj, MagicNumber);

  00168	8b 45 08	 mov	 eax, DWORD PTR _MagicNumber$1$[ebp]
  0016b	0f b7 c0	 movzx	 eax, ax
  0016e	50		 push	 eax
  0016f	56		 push	 esi
  00170	0f 85 de 00 00
	00		 jne	 $LN13@CGMagicAtt
  00176	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagicSearch
  0017b	83 c4 08	 add	 esp, 8
  0017e	8b f8		 mov	 edi, eax

; 11978: 
; 11979: #if( FIX_MAXSTAT == 1 )
; 11980: 		WORD Energy = lpObj->Energy+ lpObj->AddEnergy;
; 11981: 		WORD Strength = lpObj->Strength + lpObj->AddStrength;
; 11982: 		WORD Dexterity = lpObj->Dexterity + lpObj->AddDexterity;
; 11983: #else
; 11984: 		short Energy = lpObj->Energy+ lpObj->AddEnergy;
; 11985: 		short Strength = lpObj->Strength + lpObj->AddStrength;
; 11986: 		short Dexterity = lpObj->Dexterity + lpObj->AddDexterity;
; 11987: #endif
; 11988: 
; 11989: 		switch( MagicNumber )

  00180	66 83 7d 08 33	 cmp	 WORD PTR _MagicNumber$1$[ebp], 51 ; 00000033H
  00185	75 18		 jne	 SHORT $LN16@CGMagicAtt

; 11990: 		{
; 11991: 		case 0x33:
; 11992: 			if( Dexterity < 646 )

  00187	66 8b 8e fe 00
	00 00		 mov	 cx, WORD PTR [esi+254]
  0018e	b8 86 02 00 00	 mov	 eax, 646		; 00000286H
  00193	66 03 8e d2 00
	00 00		 add	 cx, WORD PTR [esi+210]
  0019a	66 3b c8	 cmp	 cx, ax
  0019d	72 7e		 jb	 SHORT $LN31@CGMagicAtt
$LN16@CGMagicAtt:

; 11993: 			{
; 11994: 				return;
; 11995: 			}
; 11996: 			break;
; 11997: 		}
; 11998: 
; 11999: 		if ( !lpMagic )

  0019f	85 ff		 test	 edi, edi
  001a1	74 7a		 je	 SHORT $LN31@CGMagicAtt

; 12000: 			return;
; 12001: 
; 12002: 		if ( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP,lpObj->ChangeUP2, lpMagic->m_Skill) < 1 )

  001a3	ff 77 08	 push	 DWORD PTR [edi+8]
  001a6	0f b6 86 94 00
	00 00		 movzx	 eax, BYTE PTR [esi+148]
  001ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  001b2	50		 push	 eax
  001b3	0f b6 86 93 00
	00 00		 movzx	 eax, BYTE PTR [esi+147]
  001ba	50		 push	 eax
  001bb	0f b7 86 90 00
	00 00		 movzx	 eax, WORD PTR [esi+144]
  001c2	50		 push	 eax
  001c3	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHHH@Z ; CMagicDamage::SkillGetRequireClass
  001c8	83 f8 01	 cmp	 eax, 1
  001cb	7c 50		 jl	 SHORT $LN31@CGMagicAtt

; 12003: 			return;
; 12004: 
; 12005: #if (ENABLETEST_NEWPVP == 1)
; 12006: 		if (lpMagic->m_Skill == 63 && (g_NewPVP.IsDuel(*lpObj) || g_NewPVP.IsDuel(*lpTargetObj))) {

  001cd	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  001d0	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  001d3	75 23		 jne	 SHORT $LN19@CGMagicAtt
  001d5	56		 push	 esi
  001d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  001db	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  001e0	85 c0		 test	 eax, eax
  001e2	75 39		 jne	 SHORT $LN31@CGMagicAtt
  001e4	ff 75 fc	 push	 DWORD PTR _lpTargetObj$1$[ebp]
  001e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  001ec	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  001f1	85 c0		 test	 eax, eax
  001f3	75 28		 jne	 SHORT $LN31@CGMagicAtt
  001f5	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
$LN19@CGMagicAtt:

; 12007: 			return;
; 12008: 		}
; 12009: #endif
; 12010: 
; 12011: 		if ( MagicDamageC.CheckStatus(lpMagic->m_Skill, lpObj->GuildStatus) == 0 )

  001f8	ff b6 28 06 00
	00		 push	 DWORD PTR [esi+1576]
  001fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ?CheckStatus@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckStatus
  00209	85 c0		 test	 eax, eax
  0020b	75 17		 jne	 SHORT $LN21@CGMagicAtt

; 12012: 		{
; 12013: 			LogAddC(2, "[0x19] CGMagicAttack() - Invalid Status");

  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@GEFMIMGG@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
  00212	6a 02		 push	 2
  00214	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0021a	83 c4 08	 add	 esp, 8
$LN31@CGMagicAtt:
  0021d	5f		 pop	 edi
  0021e	5e		 pop	 esi
$LN1@CGMagicAtt:
  0021f	5b		 pop	 ebx

; 12071: }

  00220	8b e5		 mov	 esp, ebp
  00222	5d		 pop	 ebp
  00223	c3		 ret	 0
$LN21@CGMagicAtt:

; 12014: 			return;
; 12015: 		}
; 12016: 
; 12017: 		if ( MagicDamageC.CheckKillCount(lpMagic->m_Skill, lpObj->m_btKillCount) < 0 )

  00224	0f b6 86 64 20
	00 00		 movzx	 eax, BYTE PTR [esi+8292]
  0022b	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00230	50		 push	 eax
  00231	ff 77 08	 push	 DWORD PTR [edi+8]
  00234	e8 00 00 00 00	 call	 ?CheckKillCount@CMagicDamage@@QAEHHH@Z ; CMagicDamage::CheckKillCount
  00239	85 c0		 test	 eax, eax
  0023b	79 25		 jns	 SHORT $LN23@CGMagicAtt

; 12018: 		{
; 12019: 			LogAddC(2, "[0x19] CGMagicAttack() - Invalid KillCount");

  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DNLLEKGJ@?$FL0x19?$FN?5CGMagicAttack?$CI?$CJ?5?9?5Invalid@
  00242	6a 02		 push	 2
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0024a	83 c4 08	 add	 esp, 8
  0024d	5f		 pop	 edi
  0024e	5e		 pop	 esi
  0024f	5b		 pop	 ebx

; 12071: }

  00250	8b e5		 mov	 esp, ebp
  00252	5d		 pop	 ebp
  00253	c3		 ret	 0
$LN13@CGMagicAtt:

; 12020: 			return;
; 12021: 		}
; 12022: 	}
; 12023: 	else
; 12024: 	{
; 12025: 		lpMagic = gObjGetMagic(lpObj, MagicNumber);

  00254	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
  00259	8b f8		 mov	 edi, eax
  0025b	83 c4 08	 add	 esp, 8

; 12026: 
; 12027: 		if ( !lpMagic )

  0025e	85 ff		 test	 edi, edi
  00260	74 bb		 je	 SHORT $LN31@CGMagicAtt
$LN23@CGMagicAtt:

; 12028: 			return;
; 12029: 	}
; 12030: 
; 12031: 	if ( lpMagic->m_Skill != AT_SKILL_CROSSBOW && 
; 12032: 		 lpMagic->m_Skill != AT_MSKILL_FE_TRIPLESHOT1 &&

  00262	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00265	83 f8 18	 cmp	 eax, 24			; 00000018H
  00268	74 1f		 je	 SHORT $LN25@CGMagicAtt
  0026a	3d 9e 01 00 00	 cmp	 eax, 414		; 0000019eH
  0026f	74 18		 je	 SHORT $LN25@CGMagicAtt
  00271	3d a2 01 00 00	 cmp	 eax, 418		; 000001a2H
  00276	74 11		 je	 SHORT $LN25@CGMagicAtt

; 12033: 		 lpMagic->m_Skill != AT_MSKILL_FE_TRIPLESHOT2 )
; 12034: 	{
; 12035: 		if( gObjUseSkill.SpeedHackCheck(aIndex) == FALSE )

  00278	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  0027b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00280	e8 00 00 00 00	 call	 ?SpeedHackCheck@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SpeedHackCheck
  00285	85 c0		 test	 eax, eax
  00287	74 94		 je	 SHORT $LN31@CGMagicAtt
$LN25@CGMagicAtt:

; 12036: 		{
; 12037: 			return;
; 12038: 		}
; 12039: 	}
; 12040: 
; 12041: 	if ( !gCheckSkillDistance(aIndex, usernumber, lpMagic->m_Skill))

  00289	ff 77 08	 push	 DWORD PTR [edi+8]
  0028c	53		 push	 ebx
  0028d	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  00290	e8 00 00 00 00	 call	 ?gCheckSkillDistance@@YAHHHH@Z ; gCheckSkillDistance
  00295	83 c4 0c	 add	 esp, 12			; 0000000cH
  00298	85 c0		 test	 eax, eax
  0029a	0f 85 85 00 00
	00		 jne	 $LN26@CGMagicAtt

; 12042: 	{
; 12043: 		DWORD dwTick = GetTickCount() - lpObj->m_dwSkillDistanceErrorTick;

  002a0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  002a6	ff d7		 call	 edi

; 12044: 		
; 12045: 		if ( dwTick > (g_iSkillDiatanceKickCheckTime*1000) )

  002a8	69 0d 00 00 00
	00 e8 03 00 00	 imul	 ecx, DWORD PTR ?g_iSkillDiatanceKickCheckTime@@3KA, 1000 ; g_iSkillDiatanceKickCheckTime
  002b2	2b 86 28 24 00
	00		 sub	 eax, DWORD PTR [esi+9256]
  002b8	3b c1		 cmp	 eax, ecx
  002ba	76 12		 jbe	 SHORT $LN27@CGMagicAtt

; 12046: 		{
; 12047: 			lpObj->m_iSkillDistanceErrorCount = 0;

  002bc	c7 86 24 24 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9252], 0

; 12048: 			lpObj->m_dwSkillDistanceErrorTick = GetTickCount();

  002c6	ff d7		 call	 edi
  002c8	89 86 28 24 00
	00		 mov	 DWORD PTR [esi+9256], eax
$LN27@CGMagicAtt:

; 12049: 		}
; 12050: 
; 12051: 		lpObj->m_iSkillDistanceErrorCount++;

  002ce	ff 86 24 24 00
	00		 inc	 DWORD PTR [esi+9252]
  002d4	8b 86 24 24 00
	00		 mov	 eax, DWORD PTR [esi+9252]

; 12052: 
; 12053: 		if ( lpObj->m_iSkillDistanceErrorCount > g_iSkillDistanceKickCount )

  002da	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?g_iSkillDistanceKickCount@@3HA ; g_iSkillDistanceKickCount
  002e0	0f 8e 37 ff ff
	ff		 jle	 $LN31@CGMagicAtt

; 12054: 		{
; 12055: 			if ( g_iSkillDistanceKick )

  002e6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iSkillDistanceKick@@3HA, 0 ; g_iSkillDistanceKick
  002ed	74 25		 je	 SHORT $LN29@CGMagicAtt

; 12056: 			{
; 12057: 				LogAddTD("[SKILL DISTANCE CHECK] [%s][%s] Kick Invalid Skill Area User. count(%d)",

  002ef	50		 push	 eax
  002f0	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  002f3	50		 push	 eax
  002f4	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  002f7	50		 push	 eax
  002f8	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFFDPBJO@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  002fd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 12058: 					lpObj->AccountID, lpObj->Name, lpObj->m_iSkillDistanceErrorCount);
; 12059: 
; 12060: 				CloseClient(lpObj->m_Index);

  00303	ff 36		 push	 DWORD PTR [esi]
  00305	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0030a	83 c4 14	 add	 esp, 20			; 00000014H
  0030d	5f		 pop	 edi
  0030e	5e		 pop	 esi
  0030f	5b		 pop	 ebx

; 12071: }

  00310	8b e5		 mov	 esp, ebp
  00312	5d		 pop	 ebp
  00313	c3		 ret	 0
$LN29@CGMagicAtt:
  00314	5f		 pop	 edi

; 12061: 				return;
; 12062: 			}
; 12063: 
; 12064: 			lpObj->m_iSkillDistanceErrorCount=0;

  00315	c7 86 24 24 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+9252], 0
  0031f	5e		 pop	 esi
  00320	5b		 pop	 ebx

; 12071: }

  00321	8b e5		 mov	 esp, ebp
  00323	5d		 pop	 ebp
  00324	c3		 ret	 0
$LN26@CGMagicAtt:

; 12065: 		}
; 12066: 
; 12067: 		return;
; 12068: 	}
; 12069: 	
; 12070: 	gObjUseSkill.UseSkill(aIndex, usernumber, lpMagic);

  00325	57		 push	 edi
  00326	53		 push	 ebx
  00327	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  0032a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0032f	e8 00 00 00 00	 call	 ?UseSkill@CObjUseSkill@@QAEXHHPAVCMagicInf@@@Z ; CObjUseSkill::UseSkill
  00334	5f		 pop	 edi
  00335	5e		 pop	 esi
  00336	5b		 pop	 ebx

; 12071: }

  00337	8b e5		 mov	 esp, ebp
  00339	5d		 pop	 ebp
  0033a	c3		 ret	 0
$LN5@CGMagicAtt:

; 11937: 	{
; 11938: 		LogAdd("error :%s %d %d", __FILE__, __LINE__, usernumber);

  0033b	53		 push	 ebx
  0033c	68 a2 2e 00 00	 push	 11938			; 00002ea2H
  00341	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00346	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GMMKNNFF@error?5?3?$CFs?5?$CFd?5?$CFd?$AA@
  0034b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00351	83 c4 10	 add	 esp, 16			; 00000010H
  00354	5b		 pop	 ebx

; 12071: }

  00355	8b e5		 mov	 esp, ebp
  00357	5d		 pop	 ebp
  00358	c3		 ret	 0
?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ENDP	; CGMagicAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z
_TEXT	SEGMENT
_pResult$ = -16						; size = 9
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z PROC		; CGActionRecv, COMDAT

; 11872: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 11873: 	if ( !OBJMAX_RANGE(aIndex))

  00018	85 db		 test	 ebx, ebx
  0001a	0f 88 e3 00 00
	00		 js	 $LN21@CGActionRe
  00020	33 c0		 xor	 eax, eax
  00022	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  00028	0f 9e c0	 setle	 al
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 d0 00 00
	00		 je	 $LN21@CGActionRe

; 11876: 		return;
; 11877: 	}
; 11878: 
; 11879: 	PMSG_ACTIONRESULT pResult;
; 11880: 	LPOBJ lpObj = &gObj[aIndex];

  00033	56		 push	 esi
  00034	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048

; 11881: 
; 11882: 	PHeadSetB((LPBYTE)&pResult, 0x18, sizeof(pResult));

  0003a	8d 45 f0	 lea	 eax, DWORD PTR _pResult$[ebp]
  0003d	6a 09		 push	 9
  0003f	6a 18		 push	 24			; 00000018H
  00041	50		 push	 eax
  00042	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00048	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11883: 	pResult.ActionNumber = lpMsg->ActionNumber;

  0004d	8a 4f 04	 mov	 cl, BYTE PTR [edi+4]

; 11884: 	pResult.NumberH = SET_NUMBERH(aIndex);

  00050	8b c3		 mov	 eax, ebx
  00052	c1 e8 08	 shr	 eax, 8
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	88 45 f3	 mov	 BYTE PTR _pResult$[ebp+3], al
  0005b	88 4d f6	 mov	 BYTE PTR _pResult$[ebp+6], cl

; 11885: 	pResult.NumberL = SET_NUMBERL(aIndex);

  0005e	88 5d f4	 mov	 BYTE PTR _pResult$[ebp+4], bl

; 11886: 	lpObj->m_ActionNumber = lpMsg->ActionNumber;

  00061	88 8e cc 01 00
	00		 mov	 BYTE PTR [esi+460], cl

; 11887: 	lpObj->Dir = lpMsg->Dir;

  00067	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  0006a	88 86 22 01 00
	00		 mov	 BYTE PTR [esi+290], al

; 11888: 	pResult.Dir = lpObj->Dir;

  00070	88 45 f5	 mov	 BYTE PTR _pResult$[ebp+5], al

; 11889: 	pResult.TargetNumberH = lpMsg->iTargetIndexH;

  00073	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00077	88 45 f7	 mov	 BYTE PTR _pResult$[ebp+7], al

; 11890: 	pResult.TargetNumberL = lpMsg->iTargetIndexL;

  0007a	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  0007e	88 45 f8	 mov	 BYTE PTR _pResult$[ebp+8], al

; 11891: 
; 11892: 	if ( lpObj->m_ActionNumber == 0x80)

  00081	8a 86 cc 01 00
	00		 mov	 al, BYTE PTR [esi+460]
  00087	3c 80		 cmp	 al, 128			; 00000080H
  00089	75 0b		 jne	 SHORT $LN6@CGActionRe

; 11893: 	{
; 11894: 		lpObj->m_ViewState = 2;
; 11895: 		lpObj->m_Rest = lpObj->m_ActionNumber;

  0008b	66 c7 86 d4 01
	00 00 80 02	 mov	 WORD PTR [esi+468], 640	; 00000280H
  00094	eb 1c		 jmp	 SHORT $LN10@CGActionRe
$LN6@CGActionRe:

; 11896: 	}
; 11897: 	else if ( lpObj->m_ActionNumber == 0x81 )

  00096	3c 81		 cmp	 al, 129			; 00000081H
  00098	75 0b		 jne	 SHORT $LN8@CGActionRe

; 11898: 	{
; 11899: 		lpObj->m_ViewState = 3;
; 11900: 		lpObj->m_Rest = lpObj->m_ActionNumber;

  0009a	66 c7 86 d4 01
	00 00 81 03	 mov	 WORD PTR [esi+468], 897	; 00000381H
  000a3	eb 0d		 jmp	 SHORT $LN10@CGActionRe
$LN8@CGActionRe:

; 11901: 	}
; 11902: 	else if ( lpObj->m_ActionNumber == 0x82 )

  000a5	3c 82		 cmp	 al, 130			; 00000082H
  000a7	75 09		 jne	 SHORT $LN10@CGActionRe

; 11903: 	{
; 11904: 		lpObj->m_ViewState = 4;
; 11905: 		lpObj->m_Rest = lpObj->m_ActionNumber;

  000a9	66 c7 86 d4 01
	00 00 82 04	 mov	 WORD PTR [esi+468], 1154 ; 00000482H
$LN10@CGActionRe:

; 11906: 	}
; 11907: 	
; 11908: 	int MVL = MAX_VIEWPORT;
; 11909: 
; 11910: 	if ( lpObj->Type == OBJ_MONSTER )
; 11911: 		MVL = MAX_VIEWPORT_MONSTER;
; 11912: 
; 11913: 	for (int n=0;n<MVL;n++)

  000b2	81 c6 48 0c 00
	00		 add	 esi, 3144		; 00000c48H
  000b8	bf 4b 00 00 00	 mov	 edi, 75			; 0000004bH
  000bd	0f 1f 00	 npad	 3
$LL4@CGActionRe:

; 11914: 	{
; 11915: 		if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  000c0	80 7e 04 01	 cmp	 BYTE PTR [esi+4], 1
  000c4	75 24		 jne	 SHORT $LN2@CGActionRe

; 11916: 		{
; 11917: 			if ( lpObj->VpPlayer2[n].state != 0 && lpObj->VpPlayer2[n].state != 0x10 && lpObj->VpPlayer2[n].state != 0x08)

  000c6	8a 06		 mov	 al, BYTE PTR [esi]
  000c8	84 c0		 test	 al, al
  000ca	74 1e		 je	 SHORT $LN2@CGActionRe
  000cc	3c 10		 cmp	 al, 16			; 00000010H
  000ce	74 1a		 je	 SHORT $LN2@CGActionRe
  000d0	3c 08		 cmp	 al, 8
  000d2	74 16		 je	 SHORT $LN2@CGActionRe

; 11918: 			{
; 11919: 				DataSend(lpObj->VpPlayer2[n].number, (LPBYTE)&pResult, pResult.h.size);

  000d4	0f b6 45 f1	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000d8	50		 push	 eax
  000d9	8d 45 f0	 lea	 eax, DWORD PTR _pResult$[ebp]
  000dc	50		 push	 eax
  000dd	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGActionRe:

; 11906: 	}
; 11907: 	
; 11908: 	int MVL = MAX_VIEWPORT;
; 11909: 
; 11910: 	if ( lpObj->Type == OBJ_MONSTER )
; 11911: 		MVL = MAX_VIEWPORT_MONSTER;
; 11912: 
; 11913: 	for (int n=0;n<MVL;n++)

  000ea	83 c6 0c	 add	 esi, 12			; 0000000cH
  000ed	83 ef 01	 sub	 edi, 1
  000f0	75 ce		 jne	 SHORT $LL4@CGActionRe
  000f2	5e		 pop	 esi
  000f3	5f		 pop	 edi
  000f4	5b		 pop	 ebx

; 11920: 			}
; 11921: 		}
; 11922: 	}
; 11923: }

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f8	33 cd		 xor	 ecx, ebp
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN21@CGActionRe:

; 11874: 	{
; 11875: 		LogAdd("error : move protocol index error %s %d", __FILE__, __LINE__);

  00103	68 63 2e 00 00	 push	 11875			; 00002e63H
  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 11920: 			}
; 11921: 		}
; 11922: 	}
; 11923: }

  00118	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011e	33 cd		 xor	 ecx, ebp
  00120	5f		 pop	 edi
  00121	5b		 pop	 ebx
  00122	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z ENDP		; CGActionRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z
_TEXT	SEGMENT
_pActionResult$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_ActionNumber$ = 12					; size = 1
_aIndex$ = 16						; size = 4
_aTargetIndex$ = 20					; size = 4
?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z PROC		; GCActionSend, COMDAT

; 11854: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 11855: 	PMSG_ACTIONRESULT pActionResult;
; 11856: 
; 11857: 	PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));

  00014	8d 45 f0	 lea	 eax, DWORD PTR _pActionResult$[ebp]
  00017	6a 09		 push	 9
  00019	6a 18		 push	 24			; 00000018H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11858: 	pActionResult.NumberH = SET_NUMBERH(aIndex);

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00024	8b c1		 mov	 eax, ecx
  00026	c1 e8 08	 shr	 eax, 8
  00029	88 45 f3	 mov	 BYTE PTR _pActionResult$[ebp+3], al

; 11859: 	pActionResult.NumberL = SET_NUMBERL(aIndex);
; 11860: 	pActionResult.ActionNumber = ActionNumber;

  0002c	8a 45 0c	 mov	 al, BYTE PTR _ActionNumber$[ebp]
  0002f	88 45 f6	 mov	 BYTE PTR _pActionResult$[ebp+6], al

; 11861: 	pActionResult.Dir = lpObj->Dir;

  00032	0f b6 86 22 01
	00 00		 movzx	 eax, BYTE PTR [esi+290]
  00039	88 45 f5	 mov	 BYTE PTR _pActionResult$[ebp+5], al
  0003c	88 4d f4	 mov	 BYTE PTR _pActionResult$[ebp+4], cl

; 11862: 	pActionResult.TargetNumberH = SET_NUMBERH(aTargetIndex);

  0003f	8b 4d 14	 mov	 ecx, DWORD PTR _aTargetIndex$[ebp]
  00042	8b c1		 mov	 eax, ecx
  00044	c1 e8 08	 shr	 eax, 8
  00047	88 45 f7	 mov	 BYTE PTR _pActionResult$[ebp+7], al

; 11863: 	pActionResult.TargetNumberL = SET_NUMBERL(aTargetIndex);
; 11864: 
; 11865: 	MsgSendV2(lpObj, (LPBYTE)&pActionResult, pActionResult.h.size);

  0004a	0f b6 45 f1	 movzx	 eax, BYTE PTR _pActionResult$[ebp+1]
  0004e	50		 push	 eax
  0004f	8d 45 f0	 lea	 eax, DWORD PTR _pActionResult$[ebp]
  00052	88 4d f8	 mov	 BYTE PTR _pActionResult$[ebp+8], cl
  00055	50		 push	 eax
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 11866: }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	83 c4 18	 add	 esp, 24			; 00000018H
  00062	33 cd		 xor	 ecx, ebp
  00064	5e		 pop	 esi
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z ENDP		; GCActionSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HGH@Z
_TEXT	SEGMENT
_pDieMsg$ = -8						; size = 8
_lpObj$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_skill$ = 16						; size = 2
_KillerIndex$ = 20					; size = 4
?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HGH@Z PROC	; GCDiePlayerSend, COMDAT

; 11831: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 11832: 	PMSG_DIEPLAYER pDieMsg;
; 11833: 
; 11834: 	PHeadSetB((LPBYTE)&pDieMsg, 0x17, sizeof(pDieMsg));

  00008	6a 08		 push	 8
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pDieMsg$[ebp]
  0000d	6a 17		 push	 23			; 00000017H
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11835: 	pDieMsg.NumberH = SET_NUMBERH(TargetIndex);

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _TargetIndex$[ebp]
  00018	8b c1		 mov	 eax, ecx

; 11836: 	pDieMsg.NumberL = SET_NUMBERL(TargetIndex);
; 11837: 	pDieMsg.Skill = (BYTE)skill;
; 11838: 	pDieMsg.KillerNumberH = SET_NUMBERH(KillerIndex);
; 11839: 	pDieMsg.KillerNumberL = SET_NUMBERL(KillerIndex);
; 11840: 	int iSize = pDieMsg.h.size;

  0001a	0f b6 7d f9	 movzx	 edi, BYTE PTR _pDieMsg$[ebp+1]

; 11841: 
; 11842: 	MsgSendV2(lpObj, (LPBYTE)&pDieMsg, iSize);

  0001e	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00021	c1 e8 08	 shr	 eax, 8
  00024	88 45 fb	 mov	 BYTE PTR _pDieMsg$[ebp+3], al
  00027	8a 45 10	 mov	 al, BYTE PTR _skill$[ebp]
  0002a	88 45 fd	 mov	 BYTE PTR _pDieMsg$[ebp+5], al
  0002d	88 4d fc	 mov	 BYTE PTR _pDieMsg$[ebp+4], cl
  00030	8b 4d 14	 mov	 ecx, DWORD PTR _KillerIndex$[ebp]
  00033	8b c1		 mov	 eax, ecx
  00035	c1 e8 08	 shr	 eax, 8
  00038	88 45 fe	 mov	 BYTE PTR _pDieMsg$[ebp+6], al
  0003b	8d 45 f8	 lea	 eax, DWORD PTR _pDieMsg$[ebp]
  0003e	57		 push	 edi
  0003f	50		 push	 eax
  00040	56		 push	 esi
  00041	88 4d ff	 mov	 BYTE PTR _pDieMsg$[ebp+7], cl
  00044	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00049	83 c4 18	 add	 esp, 24			; 00000018H

; 11843: 
; 11844: 	if ( lpObj->Type == OBJ_USER )

  0004c	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00050	75 0f		 jne	 SHORT $LN2@GCDiePlaye

; 11845: 	{
; 11846: 		DataSend(lpObj->m_Index, (LPBYTE)&pDieMsg, iSize);

  00052	57		 push	 edi
  00053	8d 45 f8	 lea	 eax, DWORD PTR _pDieMsg$[ebp]
  00056	50		 push	 eax
  00057	ff 36		 push	 DWORD PTR [esi]
  00059	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCDiePlaye:
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi

; 11847: 	}
; 11848: }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?GCDiePlayerSend@@YAXPAUOBJECTSTRUCT@@HGH@Z ENDP	; GCDiePlayerSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCKillPlayerExpSend@@YAXHHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_exp$ = 16						; size = 4
_AttackDamage$ = 20					; size = 4
_MSBFlag$ = 24						; size = 4
?GCKillPlayerExpSend@@YAXHHHHH@Z PROC			; GCKillPlayerExpSend, COMDAT

; 11760: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 11761: 	/*PMSG_KILLPLAYER pkillMsg;
; 11762: 
; 11763: 	PHeadSetBE((LPBYTE)&pkillMsg, 0x16, sizeof(pkillMsg));
; 11764: 	pkillMsg.NumberH = SET_NUMBERH(TargetIndex);
; 11765: 	pkillMsg.NumberL = SET_NUMBERL(TargetIndex);
; 11766: 	pkillMsg.ExpH = SET_NUMBERH(exp);
; 11767: 	pkillMsg.ExpL = SET_NUMBERL(exp);
; 11768: 	pkillMsg.DamageH = SET_NUMBERH(AttackDamage);
; 11769: 	pkillMsg.DamageL = SET_NUMBERL(AttackDamage);
; 11770: 
; 11771: 	if ( MSBFlag != FALSE )
; 11772: 	{
; 11773: 		pkillMsg.NumberH &= 0x7F;
; 11774: 		pkillMsg.NumberH |= 0x80;
; 11775: 	}
; 11776: 
; 11777: 	if (  BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )
; 11778: 	{
; 11779: 		g_BloodCastle.AddExperience(aIndex, exp);
; 11780: 	}
; 11781: 
; 11782: 	DataSend(aIndex, (UCHAR*)&pkillMsg, pkillMsg.h.size);*/
; 11783: 
; 11784: 	PMSG_KILLPLAYER_EXT pMsg;
; 11785: 	PHeadSetBE((LPBYTE)&pMsg,0x9C,sizeof(pMsg));

  00014	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	57		 push	 edi
  00018	6a 0c		 push	 12			; 0000000cH
  0001a	68 9c 00 00 00	 push	 156			; 0000009cH
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 11786: 
; 11787: 	pMsg.NumberH = SET_NUMBERH(TargetIndex);

  00025	8b 45 0c	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11788: 	pMsg.NumberL = SET_NUMBERL(TargetIndex);
; 11789: 	pMsg.ExpH = (DWORD)exp >> 16;

  0002b	8b 7d 10	 mov	 edi, DWORD PTR _exp$[ebp]
  0002e	8b d0		 mov	 edx, eax

; 11790: 	pMsg.ExpL = (DWORD)exp & 0xFFFF;
; 11791: 
; 11792: #if (CUSTOM_DAMAGE==1)
; 11793: 	pMsg.DamageHW = SET_NUMBERHW(AttackDamage);
; 11794: 	pMsg.DamageLW = SET_NUMBERLW(AttackDamage);
; 11795: #else
; 11796: 	pMsg.DamageH = SET_NUMBERH(AttackDamage);

  00030	8b 4d 14	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  00033	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00036	8b c7		 mov	 eax, edi
  00038	c1 e8 10	 shr	 eax, 16			; 00000010H
  0003b	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+6], ax
  0003f	8b c1		 mov	 eax, ecx
  00041	c1 ea 08	 shr	 edx, 8
  00044	c1 e8 08	 shr	 eax, 8

; 11797: 	pMsg.DamageL = SET_NUMBERL(AttackDamage);
; 11798: #endif
; 11799: 
; 11800: 	if ( MSBFlag != FALSE )

  00047	83 7d 18 00	 cmp	 DWORD PTR _MSBFlag$[ebp], 0
  0004b	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+3], dl
  0004e	66 89 7d f8	 mov	 WORD PTR _pMsg$[ebp+8], di
  00052	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+10], al
  00055	88 4d fb	 mov	 BYTE PTR _pMsg$[ebp+11], cl
  00058	74 06		 je	 SHORT $LN2@GCKillPlay

; 11801: 	{
; 11802: 		pMsg.NumberH &= 0x7F;
; 11803: 		pMsg.NumberH |= 0x80;

  0005a	80 ca 80	 or	 dl, 128			; 00000080H
  0005d	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+3], dl
$LN2@GCKillPlay:

; 11804: 	}
; 11805: 
; 11806: 	if (  BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00065	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0006b	8a 84 01 23 01
	00 00		 mov	 al, BYTE PTR [ecx+eax+291]
  00072	3c 34		 cmp	 al, 52			; 00000034H
  00074	74 0f		 je	 SHORT $LN9@GCKillPlay
  00076	3c 0b		 cmp	 al, 11			; 0000000bH
  00078	72 17		 jb	 SHORT $LN3@GCKillPlay
  0007a	b1 11		 mov	 cl, 17			; 00000011H
  0007c	3a c8		 cmp	 cl, al
  0007e	1b c0		 sbb	 eax, eax
  00080	83 c0 01	 add	 eax, 1
  00083	74 0c		 je	 SHORT $LN3@GCKillPlay
$LN9@GCKillPlay:

; 11807: 	{
; 11808: 		g_BloodCastle.AddExperience(aIndex, exp);

  00085	57		 push	 edi
  00086	56		 push	 esi
  00087	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0008c	e8 00 00 00 00	 call	 ?AddExperience@CBloodCastle@@QAE_NHH@Z ; CBloodCastle::AddExperience
$LN3@GCKillPlay:

; 11809: 	}
; 11810: 
; 11811: 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00091	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00095	50		 push	 eax
  00096	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00099	50		 push	 eax
  0009a	56		 push	 esi
  0009b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11812: 
; 11813: }

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	33 cd		 xor	 ecx, ebp
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?GCKillPlayerExpSend@@YAXHHHHH@Z ENDP			; GCKillPlayerExpSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z PROC		; GCLifeSendAll, COMDAT

; 11721: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 11722: 	PMSG_LIFEINFO_SEND pMsg;
; 11723: 	PHeadSubSetB((LPBYTE)&pMsg,0xEC,0x10,sizeof(pMsg));

  00014	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 0e		 push	 14			; 0000000eH
  00019	6a 10		 push	 16			; 00000010H
  0001b	68 ec 00 00 00	 push	 236			; 000000ecH
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00026	66 0f 6e 86 24
	01 00 00	 movd	 xmm0, DWORD PTR [esi+292]

; 11724: 
; 11725: 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0002e	8b 06		 mov	 eax, DWORD PTR [esi]

; 11726: 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);
; 11727: 
; 11728: 	int MaxLife = (int)(lpObj->MaxLife + lpObj->AddLife);
; 11729: 	int Life = (int)lpObj->Life;

  00030	f3 0f 2c 96 d8
	00 00 00	 cvttss2si edx, DWORD PTR [esi+216]
  00038	c1 e8 08	 shr	 eax, 8
  0003b	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0003e	8a 06		 mov	 al, BYTE PTR [esi]
  00040	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00043	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 11730: 
; 11731: 	pMsg.MAXHP_HIGHH = (MaxLife>>16)>>8;
; 11732: 	pMsg.MAXHP_HIGHL = (MaxLife>>16)&0xFF;
; 11733: 	pMsg.MAXHP_LOWH = (MaxLife&0xFFFF)>>8;
; 11734: 	pMsg.MAXHP_LOWL = (MaxLife&0xFFFF)&0xFF;
; 11735: 
; 11736: 	pMsg.HP_HIGHH = (Life>>16)>>8;
; 11737: 	pMsg.HP_HIGHL = (Life>>16)&0xFF;
; 11738: 	pMsg.HP_LOWH = (Life&0xFFFF)>>8;
; 11739: 	pMsg.HP_LOWL = (Life&0xFFFF)&0xFF;

  00046	88 55 f9	 mov	 BYTE PTR _pMsg$[ebp+13], dl
  00049	f3 0f 58 86 dc
	00 00 00	 addss	 xmm0, DWORD PTR [esi+220]
  00051	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00055	8b c1		 mov	 eax, ecx
  00057	88 4d f5	 mov	 BYTE PTR _pMsg$[ebp+9], cl
  0005a	c1 f8 18	 sar	 eax, 24			; 00000018H
  0005d	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al
  00060	8b c1		 mov	 eax, ecx
  00062	c1 f8 10	 sar	 eax, 16			; 00000010H
  00065	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+8], al
  00068	8b c1		 mov	 eax, ecx
  0006a	c1 f8 08	 sar	 eax, 8
  0006d	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+7], al
  00070	8b c2		 mov	 eax, edx
  00072	c1 f8 18	 sar	 eax, 24			; 00000018H
  00075	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+10], al
  00078	8b c2		 mov	 eax, edx
  0007a	c1 f8 10	 sar	 eax, 16			; 00000010H
  0007d	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  00080	8b c2		 mov	 eax, edx
  00082	c1 f8 08	 sar	 eax, 8
  00085	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 11740: 
; 11741: 	MsgSendV2(lpObj,(LPBYTE)&pMsg,pMsg.h.size);

  00088	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0008c	50		 push	 eax
  0008d	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00090	50		 push	 eax
  00091	56		 push	 esi
  00092	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 11742: }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0009d	33 cd		 xor	 ecx, ebp
  0009f	5e		 pop	 esi
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z ENDP		; GCLifeSendAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCDamageSend@@YAXHHHE@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
_Element$ = 20						; size = 1
?GCDamageSend@@YAXHHHE@Z PROC				; GCDamageSend, COMDAT

; 11678: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aTargetIndex$[ebp]

; 11679: 	PMSG_ATTACKRESULT_ELEMENTAL pMsg;
; 11680: 	PHeadSetB((LPBYTE)&pMsg,0xD8,sizeof(pMsg));

  00014	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	68 d8 00 00 00	 push	 216			; 000000d8H
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11681: 
; 11682: 	pMsg.NumberH = SET_NUMBERH(aTargetIndex);

  00029	8b c3		 mov	 eax, ebx

; 11683: 	pMsg.NumberL = SET_NUMBERL(aTargetIndex);
; 11684: 	pMsg.btElement = Element;
; 11685: 	pMsg.dwDamage = AttackDamage;
; 11686: 
; 11687: 	if ( gObj[aTargetIndex].Type == OBJ_USER )

  0002b	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00031	c1 e8 08	 shr	 eax, 8
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al
  0003a	8a 45 14	 mov	 al, BYTE PTR _Element$[ebp]
  0003d	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00040	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  00043	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004b	88 5d f4	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  0004e	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00053	75 24		 jne	 SHORT $LN2@GCDamageSe

; 11688: 	{
; 11689: 		DataSend(aTargetIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00055	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00059	50		 push	 eax
  0005a	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0005d	50		 push	 eax
  0005e	53		 push	 ebx
  0005f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11690: 		GCLifeSendAll(&gObj[aTargetIndex]); //temp fix

  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00069	03 c6		 add	 eax, esi
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z ; GCLifeSendAll
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00076	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@GCDamageSe:

; 11691: 	}
; 11692: 
; 11693: //	if ( cManager.WatchTargetIndex == aTargetIndex || cManager.WatchTargetIndex == aIndex )
; 11694: //	{
; 11695: //		cManager.DataSend((LPBYTE)&pMsg, pMsg.h.size);
; 11696: //	}
; 11697: 
; 11698: 	if ( gObj[aIndex].Type == OBJ_USER )

  00079	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0007f	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00084	75 1f		 jne	 SHORT $LN3@GCDamageSe

; 11699: 	{
; 11700: 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00086	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0008a	50		 push	 eax
  0008b	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0008e	50		 push	 eax
  0008f	57		 push	 edi
  00090	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 11701: 		GCLifeSendAll(&gObj[aIndex]); //temp fix

  00095	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009a	03 c6		 add	 eax, esi
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?GCLifeSendAll@@YAXPAUOBJECTSTRUCT@@@Z ; GCLifeSendAll
  000a2	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@GCDamageSe:

; 11702: 	}
; 11703: }

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	33 cd		 xor	 ecx, ebp
  000ac	5b		 pop	 ebx
  000ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
?GCDamageSend@@YAXHHHE@Z ENDP				; GCDamageSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCDamageSend@@YAXHHHHHH@Z
_TEXT	SEGMENT
_TargetIndex$GSCopy$1$ = -28				; size = 4
_pResult$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_TargetIndex$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
_MSBDamage$ = 24					; size = 4
_iShieldDamage$ = 28					; size = 4
?GCDamageSend@@YAXHHHHHH@Z PROC				; GCDamageSend, COMDAT

; 11596: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _TargetIndex$[ebp]

; 11597: 	PMSG_ATTACKRESULT pResult;
; 11598: 
; 11599: #if (__ENG__ == 1)
; 11600: 	PHeadSetB((LPBYTE)&pResult, 0x11, sizeof(pResult));

  00014	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001b	6a 14		 push	 20			; 00000014H
  0001d	6a 11		 push	 17			; 00000011H
  0001f	50		 push	 eax
  00020	89 5d e4	 mov	 DWORD PTR _TargetIndex$GSCopy$1$[ebp], ebx
  00023	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11601: #else
; 11602: 	// KOR PROTOCOL
; 11603: 	PHeadSetB((LPBYTE)&pResult, 0xDF, sizeof(pResult));
; 11604: #endif
; 11605: 	pResult.NumberH = SET_NUMBERH(TargetIndex);
; 11606: 	pResult.NumberL = SET_NUMBERL(TargetIndex);

  00028	8b 45 e4	 mov	 eax, DWORD PTR _TargetIndex$GSCopy$1$[ebp]
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11607: 
; 11608: #if (FIX_HP == 1)
; 11609: 	pResult.Damage = AttackDamage;

  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]

; 11610: 	pResult.ShieldDamage = iShieldDamage;

  00031	8b 55 1c	 mov	 edx, DWORD PTR _iShieldDamage$[ebp]
  00034	88 45 ec	 mov	 BYTE PTR _pResult$[ebp+4], al

; 11611: #endif
; 11612: 
; 11613: 	pResult.DamageH = SET_NUMBERH(AttackDamage);

  00037	8b c1		 mov	 eax, ecx
  00039	c1 e8 08	 shr	 eax, 8
  0003c	88 45 ed	 mov	 BYTE PTR _pResult$[ebp+5], al

; 11614: 	pResult.DamageL = SET_NUMBERL(AttackDamage);
; 11615: 	pResult.btShieldDamageH = SET_NUMBERH(iShieldDamage);

  0003f	8b c2		 mov	 eax, edx
  00041	c1 eb 08	 shr	 ebx, 8
  00044	c1 e8 08	 shr	 eax, 8

; 11616: 	pResult.btShieldDamageL = SET_NUMBERL(iShieldDamage);
; 11617: 
; 11618: 	if ( MSBFlag != FALSE )

  00047	83 7d 14 00	 cmp	 DWORD PTR _MSBFlag$[ebp], 0
  0004b	88 5d eb	 mov	 BYTE PTR _pResult$[ebp+3], bl
  0004e	89 4d f4	 mov	 DWORD PTR _pResult$[ebp+12], ecx
  00051	89 55 f8	 mov	 DWORD PTR _pResult$[ebp+16], edx
  00054	88 4d ee	 mov	 BYTE PTR _pResult$[ebp+6], cl
  00057	88 45 f1	 mov	 BYTE PTR _pResult$[ebp+9], al
  0005a	88 55 f2	 mov	 BYTE PTR _pResult$[ebp+10], dl
  0005d	74 06		 je	 SHORT $LN2@GCDamageSe

; 11619: 	{
; 11620: 		pResult.NumberH &= 0x7F;
; 11621: 		pResult.NumberH |= 0x80;

  0005f	80 cb 80	 or	 bl, 128			; 00000080H
  00062	88 5d eb	 mov	 BYTE PTR _pResult$[ebp+3], bl
$LN2@GCDamageSe:

; 11622: 	}
; 11623: 
; 11624: 	pResult.DamageType = (MSBDamage/0x100)&1;

  00065	8b 4d 18	 mov	 ecx, DWORD PTR _MSBDamage$[ebp]
  00068	8b c1		 mov	 eax, ecx
  0006a	99		 cdq
  0006b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH

; 11625: 	pResult.DamageType2 = MSBDamage;

  00071	88 4d f0	 mov	 BYTE PTR _pResult$[ebp+8], cl

; 11626: 
; 11627: 
; 11628: 
; 11629: 	if ( gObj[TargetIndex].Type == OBJ_USER )

  00074	8b 4d e4	 mov	 ecx, DWORD PTR _TargetIndex$GSCopy$1$[ebp]
  00077	03 c2		 add	 eax, edx
  00079	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007f	c1 f8 08	 sar	 eax, 8
  00082	24 01		 and	 al, 1
  00084	88 45 ef	 mov	 BYTE PTR _pResult$[ebp+7], al
  00087	69 c1 40 27 00
	00		 imul	 eax, ecx, 10048
  0008d	80 7c 10 50 01	 cmp	 BYTE PTR [eax+edx+80], 1
  00092	75 18		 jne	 SHORT $LN3@GCDamageSe

; 11630: 	{
; 11631: 		DataSend(TargetIndex, (LPBYTE)&pResult, pResult.h.size);

  00094	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00098	50		 push	 eax
  00099	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0009c	50		 push	 eax
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCDamageSe:

; 11632: 	}
; 11633: 
; 11634: //	if ( cManager.WatchTargetIndex == TargetIndex || cManager.WatchTargetIndex == aIndex )
; 11635: //	{
; 11636: //		cManager.DataSend((LPBYTE)&pResult, pResult.h.size);
; 11637: //	}
; 11638: 
; 11639: 	if ( gObj[aIndex].Type == OBJ_USER )

  000ac	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  000b2	80 7c 10 50 01	 cmp	 BYTE PTR [eax+edx+80], 1
  000b7	75 12		 jne	 SHORT $LN4@GCDamageSe

; 11640: 	{
; 11641: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000b9	0f b6 45 e9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000bd	50		 push	 eax
  000be	8d 45 e8	 lea	 eax, DWORD PTR _pResult$[ebp]
  000c1	50		 push	 eax
  000c2	56		 push	 esi
  000c3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GCDamageSe:

; 11642: 	}
; 11643: }

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	5e		 pop	 esi
  000cf	33 cd		 xor	 ecx, ebp
  000d1	5b		 pop	 ebx
  000d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
?GCDamageSend@@YAXHHHHHH@Z ENDP				; GCDamageSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCDamageSend@@YAXHHH@Z
_TEXT	SEGMENT
_pDamage$ = -8						; size = 8
_aIndex$ = 8						; size = 4
_damage$ = 12						; size = 4
_iShieldDamage$ = 16					; size = 4
?GCDamageSend@@YAXHHH@Z PROC				; GCDamageSend, COMDAT

; 11659: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 11660: 	if ( gObj[aIndex].Type != OBJ_USER )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000f	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00015	80 7c 01 50 01	 cmp	 BYTE PTR [ecx+eax+80], 1
  0001a	75 40		 jne	 SHORT $LN1@GCDamageSe

; 11661: 	{
; 11662: 		return;
; 11663: 	}
; 11664: 
; 11665: 
; 11666: 	PMSG_DAMAGE pDamage;
; 11667: 
; 11668: 	PHeadSubSetB((LPBYTE)&pDamage, 0xF3, 0x07, sizeof(pDamage));

  0001c	6a 08		 push	 8
  0001e	6a 07		 push	 7
  00020	8d 45 f8	 lea	 eax, DWORD PTR _pDamage$[ebp]
  00023	68 f3 00 00 00	 push	 243			; 000000f3H
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 11669: 	pDamage.DamageH = SET_NUMBERH(damage);

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _damage$[ebp]
  00031	8b c1		 mov	 eax, ecx
  00033	c1 e8 08	 shr	 eax, 8
  00036	88 45 fc	 mov	 BYTE PTR _pDamage$[ebp+4], al

; 11670: 	pDamage.DamageL = SET_NUMBERL(damage);

  00039	88 4d fd	 mov	 BYTE PTR _pDamage$[ebp+5], cl

; 11671: 	pDamage.btShieldDamageH = SET_NUMBERH(iShieldDamage);

  0003c	8b 4d 10	 mov	 ecx, DWORD PTR _iShieldDamage$[ebp]
  0003f	8b c1		 mov	 eax, ecx
  00041	c1 e8 08	 shr	 eax, 8
  00044	88 45 fe	 mov	 BYTE PTR _pDamage$[ebp+6], al

; 11672: 	pDamage.btShieldDamageL = SET_NUMBERL(iShieldDamage);
; 11673: 
; 11674: 	DataSend(aIndex, (LPBYTE)&pDamage, pDamage.h.size);

  00047	0f b6 45 f9	 movzx	 eax, BYTE PTR _pDamage$[ebp+1]
  0004b	50		 push	 eax
  0004c	8d 45 f8	 lea	 eax, DWORD PTR _pDamage$[ebp]
  0004f	88 4d ff	 mov	 BYTE PTR _pDamage$[ebp+7], cl
  00052	50		 push	 eax
  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00059	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@GCDamageSe:
  0005c	5e		 pop	 esi

; 11675: }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?GCDamageSend@@YAXHHH@Z ENDP				; GCDamageSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z
_TEXT	SEGMENT
tv371 = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z PROC			; CGAttack, COMDAT

; 11516: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 11517: 	LPOBJ lpObj;
; 11518: 	LPOBJ lpTargetObj;
; 11519: 	int usernumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00007	53		 push	 ebx
  00008	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0000c	66 c1 e0 08	 shl	 ax, 8
  00010	0f b7 d8	 movzx	 ebx, ax
  00013	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00017	0b d8		 or	 ebx, eax

; 11520: 
; 11521: 	if ( usernumber < 0 || usernumber > OBJMAX-1)

  00019	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  0001f	0f 87 05 02 00
	00		 ja	 $LN3@CGAttack

; 11524: 		return;
; 11525: 	}
; 11526: 
; 11527: 	if ( !gObj[usernumber].Live )

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  00030	89 4d fc	 mov	 DWORD PTR tv371[ebp], ecx
  00033	80 7c 01 51 00	 cmp	 BYTE PTR [ecx+eax+81], 0
  00038	0f 84 b4 00 00
	00		 je	 $LN1@CGAttack

; 11528: 		return;
; 11529: 
; 11530: 	lpObj = &gObj[aIndex];

  0003e	56		 push	 esi
  0003f	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00042	57		 push	 edi
  00043	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00049	03 f8		 add	 edi, eax

; 11531: 	int iTimeCalc = GetTickCount() - lpObj->m_LastAttackTime;

  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00051	2b 87 5c 05 00
	00		 sub	 eax, DWORD PTR [edi+1372]

; 11532: 
; 11533: 	if ( iTimeCalc < lpObj->m_DetectSpeedHackTime )

  00057	3b 87 64 05 00
	00		 cmp	 eax, DWORD PTR [edi+1380]
  0005d	0f 8d f0 00 00
	00		 jge	 $LN5@CGAttack

; 11534: 	{
; 11535: 		lpObj->m_DetectCount++;

  00063	ff 87 6c 05 00
	00		 inc	 DWORD PTR [edi+1388]
  00069	8b 8f 6c 05 00
	00		 mov	 ecx, DWORD PTR [edi+1388]

; 11536: 		lpObj->m_SumLastAttackTime += iTimeCalc;

  0006f	01 87 68 05 00
	00		 add	 DWORD PTR [edi+1384], eax

; 11537: 
; 11538: 		if ( lpObj->m_DetectCount > gHackCheckCount && lpObj->Type == OBJ_USER )

  00075	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gHackCheckCount@@3KA ; gHackCheckCount
  0007b	0f 86 c2 00 00
	00		 jbe	 $LN7@CGAttack
  00081	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00085	0f 85 b8 00 00
	00		 jne	 $LN7@CGAttack

; 11539: 		{
; 11540: 			lpObj->m_DetectedHackKickCount++;

  0008b	ff 87 70 05 00
	00		 inc	 DWORD PTR [edi+1392]

; 11541: 			lpObj->m_SpeedHackPenalty = gSpeedHackPenalty;

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gSpeedHackPenalty@@3HA ; gSpeedHackPenalty
  00096	8b 8f 70 05 00
	00		 mov	 ecx, DWORD PTR [edi+1392]
  0009c	89 87 74 05 00
	00		 mov	 DWORD PTR [edi+1396], eax

; 11542: 			
; 11543: 			if ( gIsKickDetecHackCountLimit )

  000a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsKickDetecHackCountLimit@@3HA, 0 ; gIsKickDetecHackCountLimit
  000a9	74 4c		 je	 SHORT $LN9@CGAttack

; 11544: 			{
; 11545: 				if ( lpObj->m_DetectedHackKickCount > gDetectedHackKickCount )

  000ab	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gDetectedHackKickCount@@3HA ; gDetectedHackKickCount
  000b1	7e 44		 jle	 SHORT $LN9@CGAttack

; 11546: 				{
; 11547: 					LogAddTD("[%s][%s] %s Kick DetecHackCountLimit Over User (%d) @%d",

  000b3	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  000ba	50		 push	 eax
  000bb	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  000c2	51		 push	 ecx
  000c3	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  000c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000d3	50		 push	 eax
  000d4	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  000d7	50		 push	 eax
  000d8	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  000db	50		 push	 eax
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CILMICFP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Kick?5DetecHackCountL@
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 11548: 						lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 11549: 						lpObj->m_DetectedHackKickCount,lpObj->MapNumber);
; 11550: 
; 11551: 					CloseClient(aIndex);

  000e7	56		 push	 esi
  000e8	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000ed	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
$LN1@CGAttack:
  000f2	5b		 pop	 ebx

; 11591: }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
$LN9@CGAttack:

; 11552: 					return;
; 11553: 				}
; 11554: 			}
; 11555: 
; 11556: 			LogAddTD("[%s][%s] %s Attack Speed Is Wrong Normal (%d)(%d) Penalty %d @%d",

  000f7	0f b6 8f 23 01
	00 00		 movzx	 ecx, BYTE PTR [edi+291]
  000fe	33 d2		 xor	 edx, edx
  00100	51		 push	 ecx
  00101	50		 push	 eax
  00102	8b 87 68 05 00
	00		 mov	 eax, DWORD PTR [edi+1384]
  00108	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0010d	f7 b7 6c 05 00
	00		 div	 DWORD PTR [edi+1388]
  00113	50		 push	 eax
  00114	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  0011b	ff b7 64 05 00
	00		 push	 DWORD PTR [edi+1380]
  00121	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0012c	50		 push	 eax
  0012d	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00130	50		 push	 eax
  00131	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00134	50		 push	 eax
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@PGHIAIFO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Attack?5Speed?5Is?5Wron@
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00140	83 c4 20	 add	 esp, 32			; 00000020H
$LN7@CGAttack:

; 11557: 				lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 11558: 				lpObj->m_DetectSpeedHackTime, lpObj->m_SumLastAttackTime/lpObj->m_DetectCount, lpObj->m_SpeedHackPenalty,lpObj->MapNumber);
; 11559: 		}
; 11560: 
; 11561: 		lpObj->m_LastAttackTime = GetTickCount();

  00143	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  00149	ff d6		 call	 esi
  0014b	89 87 5c 05 00
	00		 mov	 DWORD PTR [edi+1372], eax

; 11562: 	}
; 11563: 	else

  00151	eb 1a		 jmp	 SHORT $LN6@CGAttack
$LN5@CGAttack:
  00153	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0

; 11564: 	{
; 11565: 		lpObj->m_SumLastAttackTime = 0;

  00159	c7 87 68 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1384], 0

; 11566: 		lpObj->m_DetectCount = 0;

  00163	c7 87 6c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+1388], 0
$LN6@CGAttack:

; 11567: 	}
; 11568: 
; 11569: 	lpObj->m_LastAttackTime = GetTickCount();

  0016d	ff d6		 call	 esi
  0016f	89 87 5c 05 00
	00		 mov	 DWORD PTR [edi+1372], eax

; 11570: 
; 11571: 	if ( bIsIgnorePacketSpeedHackDetect )

  00175	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  0017c	74 4f		 je	 SHORT $LN11@CGAttack

; 11572: 	{
; 11573: 		if ( lpObj->m_SpeedHackPenalty > 0 )

  0017e	8b 97 74 05 00
	00		 mov	 edx, DWORD PTR [edi+1396]
  00184	85 d2		 test	 edx, edx
  00186	7e 45		 jle	 SHORT $LN11@CGAttack

; 11574: 		{
; 11575: 			lpObj->m_SpeedHackPenalty--;
; 11576: 			
; 11577: 			LogAddTD("[%s][%s] %s Apply Attack Speed Penalty (%d left) @%d",

  00188	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  0018f	4a		 dec	 edx
  00190	50		 push	 eax
  00191	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  00198	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0019d	52		 push	 edx
  0019e	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  001a3	89 97 74 05 00
	00		 mov	 DWORD PTR [edi+1396], edx
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001af	50		 push	 eax
  001b0	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  001b3	50		 push	 eax
  001b4	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  001b7	50		 push	 eax
  001b8	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LECGNCFD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CFs?5Apply?5Attack?5Speed?5P@
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c3	83 c4 18	 add	 esp, 24			; 00000018H
  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx

; 11591: }

  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c3		 ret	 0
$LN11@CGAttack:

; 11578: 				lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 108)+lpObj->Class),
; 11579: 				lpObj->m_SpeedHackPenalty,lpObj->MapNumber);
; 11580: 
; 11581: 			return;
; 11582: 		}
; 11583: 	}
; 11584: 	
; 11585: 	lpTargetObj = &gObj[usernumber];
; 11586: 	lpObj->Dir = lpMsg->DirDis;

  001cd	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001d0	8b 75 fc	 mov	 esi, DWORD PTR tv371[ebp]
  001d3	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11587: 	GCActionSend(lpObj, lpMsg->AttackAction, aIndex, usernumber);

  001d9	53		 push	 ebx
  001da	8a 41 06	 mov	 al, BYTE PTR [ecx+6]
  001dd	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  001e0	88 87 22 01 00
	00		 mov	 BYTE PTR [edi+290], al
  001e6	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  001ea	53		 push	 ebx
  001eb	50		 push	 eax
  001ec	57		 push	 edi
  001ed	e8 00 00 00 00	 call	 ?GCActionSend@@YAXPAUOBJECTSTRUCT@@EHH@Z ; GCActionSend
  001f2	83 c4 10	 add	 esp, 16			; 00000010H

; 11588: 	gComboAttack.CheckCombo(aIndex, 0);

  001f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gComboAttack@@3VCComboAttack@@A ; gComboAttack
  001fa	6a 00		 push	 0
  001fc	53		 push	 ebx
  001fd	e8 00 00 00 00	 call	 ?CheckCombo@CComboAttack@@QAEHHH@Z ; CComboAttack::CheckCombo

; 11589: 	gObjAttack(lpObj, lpTargetObj, NULL, FALSE, FALSE, 0, FALSE,0,0);

  00202	6a 00		 push	 0
  00204	6a 00		 push	 0
  00206	6a 00		 push	 0
  00208	6a 00		 push	 0
  0020a	6a 00		 push	 0
  0020c	6a 00		 push	 0
  0020e	6a 00		 push	 0
  00210	56		 push	 esi
  00211	57		 push	 edi
  00212	e8 00 00 00 00	 call	 ?gObjAttack@@YAXPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHHEE@Z ; gObjAttack
  00217	83 c4 24	 add	 esp, 36			; 00000024H

; 11590: 	lpObj->UseMagicNumber = 0;

  0021a	33 c0		 xor	 eax, eax
  0021c	66 89 87 ae 06
	00 00		 mov	 WORD PTR [edi+1710], ax
  00223	5f		 pop	 edi
  00224	5e		 pop	 esi
  00225	5b		 pop	 ebx

; 11591: }

  00226	8b e5		 mov	 esp, ebp
  00228	5d		 pop	 ebp
  00229	c3		 ret	 0
$LN3@CGAttack:

; 11522: 	{
; 11523: 		LogAdd("[CGAttack] [UserIndex Error] :%s %d %d", __FILE__, __LINE__, usernumber);

  0022a	53		 push	 ebx
  0022b	68 03 2d 00 00	 push	 11523			; 00002d03H
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@PODPFEHM@?$FLCGAttack?$FN?5?$FLUserIndex?5Error?$FN?5?3?$CFs@
  0023a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00240	83 c4 10	 add	 esp, 16			; 00000010H
  00243	5b		 pop	 ebx

; 11591: }

  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c3		 ret	 0
?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z ENDP			; CGAttack
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z
_TEXT	SEGMENT
_pMove$ = -8						; size = 7
_lpMove$ = 8						; size = 4
_Index$1$ = 12						; size = 4
_aIndex$ = 12						; size = 4
?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z PROC ; RecvPositionSetProc, COMDAT

; 11408: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 11409: 	short n;
; 11410: 
; 11411: 	if (  OBJMAX_RANGE(aIndex) == FALSE)

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000a	85 db		 test	 ebx, ebx
  0000c	0f 88 06 02 00
	00		 js	 $LN29@RecvPositi
  00012	33 c0		 xor	 eax, eax
  00014	81 fb eb 2c 00
	00		 cmp	 ebx, 11499		; 00002cebH
  0001a	0f 9e c0	 setle	 al
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 f3 01 00
	00		 je	 $LN29@RecvPositi

; 11414: 		return;
; 11415: 	}
; 11416: 
; 11417: 	LPOBJ lpObj = &gObj[aIndex];

  00025	56		 push	 esi
  00026	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  0002c	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11418: 
; 11419: 	if ( ::PacketCheckTime(lpObj) == FALSE )

  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00038	83 c4 04	 add	 esp, 4
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 cf 01 00
	00		 je	 $LN31@RecvPositi

; 11420: 	{
; 11421: 		return;
; 11422: 	}
; 11423: 
; 11424: 	if ( lpObj->Teleport != 0 )

  00043	80 be 88 05 00
	00 00		 cmp	 BYTE PTR [esi+1416], 0
  0004a	0f 85 c2 01 00
	00		 jne	 $LN31@RecvPositi

; 11425: 	{
; 11426: 		return;
; 11427: 	}
; 11428: 
; 11429: 	lpObj->X = lpMove->X;

  00050	57		 push	 edi
  00051	8b 7d 08	 mov	 edi, DWORD PTR _lpMove$[ebp]
  00054	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00058	88 86 20 01 00
	00		 mov	 BYTE PTR [esi+288], al

; 11430: 	lpObj->Y = lpMove->Y;

  0005e	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00062	88 86 21 01 00
	00		 mov	 BYTE PTR [esi+289], al

; 11431: 
; 11432: 	if ( CC_MAP_RANGE(lpObj->MapNumber) != FALSE )

  00068	8a 86 23 01 00
	00		 mov	 al, BYTE PTR [esi+291]
  0006e	3c 35		 cmp	 al, 53			; 00000035H
  00070	74 0f		 je	 SHORT $LN30@RecvPositi
  00072	3c 12		 cmp	 al, 18			; 00000012H
  00074	72 22		 jb	 SHORT $LN9@RecvPositi
  00076	b1 17		 mov	 cl, 23			; 00000017H
  00078	3a c8		 cmp	 cl, al
  0007a	1b c0		 sbb	 eax, eax
  0007c	83 c0 01	 add	 eax, 1
  0007f	74 17		 je	 SHORT $LN9@RecvPositi
$LN30@RecvPositi:

; 11433: 	{
; 11434: 		if ( (GetTickCount() - lpObj->m_iChaosCastleBlowTime ) < 1000 )

  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00087	2b 86 40 12 00
	00		 sub	 eax, DWORD PTR [esi+4672]
  0008d	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00092	0f 82 79 01 00
	00		 jb	 $LN32@RecvPositi
$LN9@RecvPositi:

; 11435: 		{
; 11436: 			return;
; 11437: 		}
; 11438: 	}
; 11439: 
; 11440: 	if ( gObjCheckXYMapTile(lpObj, 2) == TRUE)

  00098	6a 02		 push	 2
  0009a	56		 push	 esi
  0009b	e8 00 00 00 00	 call	 ?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCheckXYMapTile
  000a0	83 c4 08	 add	 esp, 8
  000a3	83 f8 01	 cmp	 eax, 1
  000a6	0f 84 65 01 00
	00		 je	 $LN32@RecvPositi

; 11441: 	{
; 11442: 		return;
; 11443: 	}
; 11444: 
; 11445: 	PMSG_RECV_POSISTION_SET pMove;
; 11446: #if (__ENG__ == 1)
; 11447: 	PHeadSetB((LPBYTE)&pMove, 0x15, sizeof(pMove));

  000ac	6a 07		 push	 7
  000ae	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  000b1	6a 15		 push	 21			; 00000015H
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11448: #else
; 11449: 	// KOR PROTOCOL
; 11450: 	PHeadSetB((LPBYTE)&pMove, 0x10, sizeof(pMove));
; 11451: #endif
; 11452: 	pMove.NumberH = SET_NUMBERH(aIndex);
; 11453: 	pMove.NumberL = SET_NUMBERL(aIndex);
; 11454: 	pMove.X = lpMove->X;

  000b9	8a 4f 03	 mov	 cl, BYTE PTR [edi+3]
  000bc	8b c3		 mov	 eax, ebx
  000be	c1 e8 08	 shr	 eax, 8
  000c1	88 45 fb	 mov	 BYTE PTR _pMove$[ebp+3], al

; 11455: 	pMove.Y = lpMove->Y;

  000c4	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  000c8	88 45 fe	 mov	 BYTE PTR _pMove$[ebp+6], al
  000cb	88 5d fc	 mov	 BYTE PTR _pMove$[ebp+4], bl
  000ce	88 4d fd	 mov	 BYTE PTR _pMove$[ebp+5], cl

; 11456: 	lpObj->TX = lpMove->X;

  000d1	88 8e 52 01 00
	00		 mov	 BYTE PTR [esi+338], cl

; 11457: 	lpObj->TY = lpMove->Y;

  000d7	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]

; 11458: 
; 11459: 	if ( ::gObjPositionCheck(lpObj) == FALSE )

  000db	56		 push	 esi
  000dc	88 86 53 01 00
	00		 mov	 BYTE PTR [esi+339], al
  000e2	e8 00 00 00 00	 call	 ?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjPositionCheck
  000e7	83 c4 10	 add	 esp, 16			; 00000010H
  000ea	85 c0		 test	 eax, eax
  000ec	0f 84 1f 01 00
	00		 je	 $LN32@RecvPositi

; 11460: 	{
; 11461: 		return;
; 11462: 	}
; 11463: 
; 11464: 	CreateFrustrum(lpObj->X, lpObj->Y, aIndex);

  000f2	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  000f9	53		 push	 ebx
  000fa	50		 push	 eax
  000fb	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11465: 
; 11466: 	if ( lpObj->Type == OBJ_USER )

  0010b	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  0010f	75 12		 jne	 SHORT $LN12@RecvPositi

; 11467: 	{
; 11468: 		DataSend(aIndex, (UCHAR *)&pMove, pMove.h.size);

  00111	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  00115	50		 push	 eax
  00116	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  00119	50		 push	 eax
  0011a	53		 push	 ebx
  0011b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00120	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@RecvPositi:

; 11469: 	}
; 11470: 
; 11471: 	int MVL = MAX_VIEWPORT;
; 11472: 
; 11473: 	if ( lpObj->Type == OBJ_MONSTER )
; 11474: 	{
; 11475: #if (GS_CASTLE == 1)
; 11476: 		MVL = MAX_VIEWPORT;
; 11477: #else
; 11478: 		MVL = MAX_VIEWPORT_MONSTER;
; 11479: #endif
; 11480: 	}
; 11481: 
; 11482: 	for ( n=0;n<MVL;n++)

  00123	33 ff		 xor	 edi, edi
  00125	33 c9		 xor	 ecx, ecx
  00127	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@RecvPositi:

; 11483: 	{
; 11484: 		if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  00130	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00133	80 bc 86 4c 0c
	00 00 01	 cmp	 BYTE PTR [esi+eax*4+3148], 1
  0013b	8d 14 86	 lea	 edx, DWORD PTR [esi+eax*4]
  0013e	75 5e		 jne	 SHORT $LN2@RecvPositi

; 11485: 		{
; 11486: 			if ( lpObj->VpPlayer2[n].state == 1 )

  00140	8d 81 06 01 00
	00		 lea	 eax, DWORD PTR [ecx+262]
  00146	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00149	80 3c 86 01	 cmp	 BYTE PTR [esi+eax*4], 1
  0014d	8d 1c 86	 lea	 ebx, DWORD PTR [esi+eax*4]
  00150	75 4c		 jne	 SHORT $LN2@RecvPositi

; 11487: 			{
; 11488: 				int Index = lpObj->VpPlayer2[n].number;

  00152	0f bf 82 4a 0c
	00 00		 movsx	 eax, WORD PTR [edx+3146]

; 11489: 
; 11490: 				if ( gObj[Index].Connected > PLAYER_CONNECTED && gObj[Index].Live != FALSE)

  00159	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  0015f	89 45 0c	 mov	 DWORD PTR _Index$1$[ebp], eax
  00162	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00167	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  0016c	7e 1d		 jle	 SHORT $LN16@RecvPositi
  0016e	80 7c 01 51 00	 cmp	 BYTE PTR [ecx+eax+81], 0
  00173	74 16		 je	 SHORT $LN16@RecvPositi

; 11491: 				{
; 11492: 					DataSend(lpObj->VpPlayer2[n].number, (UCHAR *)&pMove, pMove.h.size);

  00175	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  00179	50		 push	 eax
  0017a	8d 45 f8	 lea	 eax, DWORD PTR _pMove$[ebp]
  0017d	50		 push	 eax
  0017e	ff 75 0c	 push	 DWORD PTR _Index$1$[ebp]
  00181	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00186	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11493: 				}
; 11494: 				else

  00189	eb 13		 jmp	 SHORT $LN2@RecvPositi
$LN16@RecvPositi:

; 11495: 				{
; 11496: 					lpObj->VpPlayer2[n].number = -1;

  0018b	83 c8 ff	 or	 eax, -1

; 11497: 					lpObj->VpPlayer2[n].state = FALSE;

  0018e	c6 03 00	 mov	 BYTE PTR [ebx], 0
  00191	66 89 82 4a 0c
	00 00		 mov	 WORD PTR [edx+3146], ax

; 11498: 					lpObj->VPCount2--;

  00198	ff 8e d0 0f 00
	00		 dec	 DWORD PTR [esi+4048]
$LN2@RecvPositi:

; 11469: 	}
; 11470: 
; 11471: 	int MVL = MAX_VIEWPORT;
; 11472: 
; 11473: 	if ( lpObj->Type == OBJ_MONSTER )
; 11474: 	{
; 11475: #if (GS_CASTLE == 1)
; 11476: 		MVL = MAX_VIEWPORT;
; 11477: #else
; 11478: 		MVL = MAX_VIEWPORT_MONSTER;
; 11479: #endif
; 11480: 	}
; 11481: 
; 11482: 	for ( n=0;n<MVL;n++)

  0019e	47		 inc	 edi
  0019f	0f bf cf	 movsx	 ecx, di
  001a2	83 f9 4b	 cmp	 ecx, 75			; 0000004bH
  001a5	7c 89		 jl	 SHORT $LL4@RecvPositi

; 11499: 				}
; 11500: 			}
; 11501: 		}
; 11502: 	}
; 11503: 
; 11504: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  001a7	0f b6 86 51 01
	00 00		 movzx	 eax, BYTE PTR [esi+337]
  001ae	50		 push	 eax
  001af	0f b6 86 50 01
	00 00		 movzx	 eax, BYTE PTR [esi+336]
  001b6	50		 push	 eax
  001b7	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  001be	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  001c4	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001ca	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 11505: 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  001cf	0f b6 86 53 01
	00 00		 movzx	 eax, BYTE PTR [esi+339]
  001d6	50		 push	 eax
  001d7	0f b6 86 52 01
	00 00		 movzx	 eax, BYTE PTR [esi+338]
  001de	50		 push	 eax
  001df	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  001e6	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  001ec	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001f2	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 11506: 
; 11507: 	lpObj->m_OldX = lpObj->TX;

  001f7	0f b6 86 52 01
	00 00		 movzx	 eax, BYTE PTR [esi+338]
  001fe	88 86 50 01 00
	00		 mov	 BYTE PTR [esi+336], al

; 11508: 	lpObj->m_OldY = lpObj->TY;

  00204	0f b6 86 53 01
	00 00		 movzx	 eax, BYTE PTR [esi+339]
  0020b	88 86 51 01 00
	00		 mov	 BYTE PTR [esi+337], al
$LN32@RecvPositi:
  00211	5f		 pop	 edi
$LN31@RecvPositi:
  00212	5e		 pop	 esi
  00213	5b		 pop	 ebx

; 11509: 
; 11510: }

  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c3		 ret	 0
$LN29@RecvPositi:

; 11412: 	{
; 11413: 		LogAdd("error : move protocol index error %s %d", __FILE__, __LINE__);

  00218	68 95 2c 00 00	 push	 11413			; 00002c95H
  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00222	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HDJHDEIB@error?5?3?5move?5protocol?5index?5erro@
  00227	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0022d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00230	5b		 pop	 ebx

; 11509: 
; 11510: }

  00231	8b e5		 mov	 esp, ebp
  00233	5d		 pop	 ebp
  00234	c3		 ret	 0
?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ENDP ; RecvPositionSetProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z
_TEXT	SEGMENT
_sy$1$ = -304						; size = 4
_sx$1$ = -300						; size = 4
tv1194 = -296						; size = 4
_n$1$ = -296						; size = 4
_aIndex$GSCopy$1$ = -292				; size = 4
_lpMove$GSCopy$1$ = -288				; size = 4
_pMove$ = -284						; size = 8
_ay$1$ = -274						; size = 1
_ax$1$ = -273						; size = 1
_pActionResult$1 = -272					; size = 9
_msg$2 = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_lpMove$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z PROC			; PMoveProc, COMDAT

; 11030: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00016	89 8d dc fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], ecx
  0001c	53		 push	 ebx
  0001d	8b 5d 08	 mov	 ebx, DWORD PTR _lpMove$[ebp]
  00020	89 9d e0 fe ff
	ff		 mov	 DWORD PTR _lpMove$GSCopy$1$[ebp], ebx

; 11031: 	if ( !OBJMAX_RANGE(aIndex))

  00026	85 c9		 test	 ecx, ecx
  00028	0f 88 24 07 00
	00		 js	 $LN74@PMoveProc
  0002e	33 c0		 xor	 eax, eax
  00030	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00036	0f 9e c0	 setle	 al
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 11 07 00
	00		 je	 $LN74@PMoveProc

; 11034: 		return;
; 11035: 	}
; 11036: 
; 11037: 	PMSG_RECVMOVE pMove;
; 11038: 	short n;
; 11039: 	short pathtable;
; 11040: 	BYTE ax;
; 11041: 	BYTE ay;
; 11042: 	int sx;
; 11043: 	int sy;
; 11044: 	LPOBJ lpObj = &gObj[aIndex];

  00041	56		 push	 esi
  00042	69 f1 40 27 00
	00		 imul	 esi, ecx, 10048
  00048	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 11045: 
; 11046: 	if ( lpObj->RegenOk > 0 )

  0004e	80 be 8b 05 00
	00 00		 cmp	 BYTE PTR [esi+1419], 0
  00055	0f 8f 16 01 00
	00		 jg	 $LN76@PMoveProc

; 11047: 		return;
; 11048: 
; 11049: 	if ( lpObj->SkillRecallParty_Time )

  0005b	66 83 be 04 16
	00 00 00	 cmp	 WORD PTR [esi+5636], 0
  00063	74 39		 je	 SHORT $LN18@PMoveProc

; 11050: 	{
; 11051: 		lpObj->SkillRecallParty_Time = 0;

  00065	33 c0		 xor	 eax, eax

; 11052: 		char msg[255];
; 11053: 		wsprintf(msg, lMsg.Get(MSGGET(4, 230)));

  00067	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0006c	68 e6 04 00 00	 push	 1254			; 000004e6H
  00071	66 89 86 04 16
	00 00		 mov	 WORD PTR [esi+5636], ax
  00078	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0007d	50		 push	 eax
  0007e	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$2[ebp]
  00084	50		 push	 eax
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 11054: 		GCServerMsgStringSend(msg, lpObj->m_Index, 1);

  0008b	6a 01		 push	 1
  0008d	ff 36		 push	 DWORD PTR [esi]
  0008f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$2[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0009b	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@PMoveProc:

; 11055: 	}
; 11056: 
; 11057: 	if ( (GetTickCount()-lpObj->m_LastMoveTime) < 100 )

  0009e	57		 push	 edi
  0009f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  000a5	ff d7		 call	 edi
  000a7	2b 86 58 05 00
	00		 sub	 eax, DWORD PTR [esi+1368]
  000ad	83 f8 64	 cmp	 eax, 100		; 00000064H
  000b0	0f 82 ba 00 00
	00		 jb	 $LN77@PMoveProc

; 11058: 		return;
; 11059: 
; 11060: 	if ( lpObj->Teleport )

  000b6	80 be 88 05 00
	00 00		 cmp	 BYTE PTR [esi+1416], 0
  000bd	0f 85 ad 00 00
	00		 jne	 $LN77@PMoveProc

; 11061: 		return;
; 11062: 
; 11063: 	if ( gObjCheckUsedBuffEffect(lpObj,BUFF_ICEARROW) == TRUE ||
; 11064: 		 gObjCheckUsedBuffEffect(lpObj,BUFF_STUN) == TRUE ||
; 11065: 		 gObjCheckUsedBuffEffect(lpObj,BUFF_SLEEP) == TRUE ||
; 11066: 		 gObjCheckUsedBuffEffect(lpObj,BUFF_FREEZE) == TRUE ||

  000c3	6a 39		 push	 57			; 00000039H
  000c5	56		 push	 esi
  000c6	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000cb	83 c4 08	 add	 esp, 8
  000ce	3c 01		 cmp	 al, 1
  000d0	0f 84 9a 00 00
	00		 je	 $LN77@PMoveProc
  000d6	6a 3d		 push	 61			; 0000003dH
  000d8	56		 push	 esi
  000d9	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000de	83 c4 08	 add	 esp, 8
  000e1	3c 01		 cmp	 al, 1
  000e3	0f 84 87 00 00
	00		 je	 $LN77@PMoveProc
  000e9	6a 48		 push	 72			; 00000048H
  000eb	56		 push	 esi
  000ec	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  000f1	83 c4 08	 add	 esp, 8
  000f4	3c 01		 cmp	 al, 1
  000f6	74 78		 je	 SHORT $LN77@PMoveProc
  000f8	68 92 00 00 00	 push	 146			; 00000092H
  000fd	56		 push	 esi
  000fe	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00103	83 c4 08	 add	 esp, 8
  00106	3c 01		 cmp	 al, 1
  00108	74 66		 je	 SHORT $LN77@PMoveProc
  0010a	68 93 00 00 00	 push	 147			; 00000093H
  0010f	56		 push	 esi
  00110	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00115	83 c4 08	 add	 esp, 8
  00118	3c 01		 cmp	 al, 1
  0011a	74 54		 je	 SHORT $LN77@PMoveProc

; 11067: 		 gObjCheckUsedBuffEffect(lpObj,BUFF_EARTHBINDS) == TRUE )
; 11068: 	{
; 11069: 		return;
; 11070: 	}
; 11071: 
; 11072: 	lpObj->m_LastMoveTime = GetTickCount();

  0011c	ff d7		 call	 edi
  0011e	89 86 58 05 00
	00		 mov	 DWORD PTR [esi+1368], eax

; 11073: 	lpObj->m_Rest = 0;

  00124	c6 86 d4 01 00
	00 00		 mov	 BYTE PTR [esi+468], 0

; 11074: 	lpObj->PathCur = 0;

  0012b	c7 86 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+348], 0

; 11075: 	lpObj->Dir = lpMove->Path[0] >> 4;

  00135	8a 43 05	 mov	 al, BYTE PTR [ebx+5]
  00138	c0 e8 04	 shr	 al, 4
  0013b	88 86 22 01 00
	00		 mov	 BYTE PTR [esi+290], al

; 11076: 	lpObj->PathCount = lpMove->Path[0] & 0x0F;

  00141	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  00145	83 e0 0f	 and	 eax, 15			; 0000000fH
  00148	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax

; 11077: 
; 11078: 	if ( lpObj->PathCount > 15 )

  0014e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00151	7e 2e		 jle	 SHORT $LN23@PMoveProc

; 11079: 	{
; 11080: 		LogAdd("error-L3 : Path Count error %d id:%s %s %d",

  00153	68 49 2b 00 00	 push	 11081			; 00002b49H
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0015d	83 c6 52	 add	 esi, 82			; 00000052H
  00160	56		 push	 esi
  00161	50		 push	 eax
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@FPLHDOJG@error?9L3?5?3?5Path?5Count?5error?5?$CFd?5i@
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0016d	83 c4 14	 add	 esp, 20			; 00000014H
$LN77@PMoveProc:
  00170	5f		 pop	 edi
$LN76@PMoveProc:
  00171	5e		 pop	 esi
  00172	5b		 pop	 ebx

; 11401: }

  00173	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00176	33 cd		 xor	 ecx, ebp
  00178	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c3		 ret	 0
$LN23@PMoveProc:

; 11081: 			lpObj->PathCount, lpObj->AccountID, __FILE__, __LINE__);
; 11082: 		return;
; 11083: 	}
; 11084: 
; 11085: 	for ( n=0;n<15;n++)

  00181	8d 9e 62 01 00
	00		 lea	 ebx, DWORD PTR [esi+354]
  00187	ba 0f 00 00 00	 mov	 edx, 15			; 0000000fH
  0018c	8d 86 8f 01 00
	00		 lea	 eax, DWORD PTR [esi+399]
  00192	8b cb		 mov	 ecx, ebx
$LL4@PMoveProc:

; 11086: 	{
; 11087: 		lpObj->PathX[n]=0;
; 11088: 		lpObj->PathY[n]=0;
; 11089: 		lpObj->PathOri[n]=0;

  00194	33 ff		 xor	 edi, edi
  00196	c6 40 f1 00	 mov	 BYTE PTR [eax-15], 0
  0019a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0019d	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  001a0	66 89 79 fe	 mov	 WORD PTR [ecx-2], di
  001a4	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  001a7	83 ea 01	 sub	 edx, 1
  001aa	75 e8		 jne	 SHORT $LL4@PMoveProc

; 11090: 	}
; 11091: 
; 11092: 	sx = lpMove->X;

  001ac	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMove$GSCopy$1$[ebp]

; 11093: 	sy = lpMove->Y;
; 11094: 
; 11095: 	if ( gObjCheckXYMapTile(lpObj, 1) == TRUE )

  001b2	6a 01		 push	 1
  001b4	56		 push	 esi
  001b5	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  001b9	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  001bd	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _sx$1$[ebp], ecx
  001c3	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _sy$1$[ebp], eax
  001c9	e8 00 00 00 00	 call	 ?gObjCheckXYMapTile@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCheckXYMapTile
  001ce	83 c4 08	 add	 esp, 8
  001d1	8d be 8f 01 00
	00		 lea	 edi, DWORD PTR [esi+399]
  001d7	83 f8 01	 cmp	 eax, 1
  001da	75 20		 jne	 SHORT $LN24@PMoveProc

; 11096: 	{
; 11097: 		lpObj->PathCount = 0;

  001dc	c7 86 58 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+344], 0

; 11098: 		lpObj->PathCur = 0;

  001e6	c7 86 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+348], 0

; 11099: 		lpObj->PathStartEnd = 0;

  001f0	c6 86 60 01 00
	00 00		 mov	 BYTE PTR [esi+352], 0

; 11100: 		gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 11101: 		return;

  001f7	e9 8e 01 00 00	 jmp	 $LN82@PMoveProc
$LN24@PMoveProc:

; 11102: 	}
; 11103: 
; 11104: 	lpObj->PathX[0] = lpMove->X;

  001fc	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMove$GSCopy$1$[ebp]
  00202	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00205	88 8e 80 01 00
	00		 mov	 BYTE PTR [esi+384], cl

; 11105: 	ax = lpObj->PathX[0];
; 11106: 	lpObj->PathY[0] = lpMove->Y;

  0020b	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  0020e	88 07		 mov	 BYTE PTR [edi], al
  00210	88 85 ee fe ff
	ff		 mov	 BYTE PTR _ay$1$[ebp], al

; 11107: 	ay = lpObj->PathY[0];
; 11108: 	lpObj->PathDir[0] = lpObj->Dir;

  00216	8a 86 22 01 00
	00		 mov	 al, BYTE PTR [esi+290]
  0021c	88 86 9e 01 00
	00		 mov	 BYTE PTR [esi+414], al

; 11109: 	lpObj->PathStartEnd = 1;
; 11110: 
; 11111: 	if ( lpObj->PathCount > 0 )

  00222	83 be 58 01 00
	00 00		 cmp	 DWORD PTR [esi+344], 0
  00229	88 8d ef fe ff
	ff		 mov	 BYTE PTR _ax$1$[ebp], cl
  0022f	c6 86 60 01 00
	00 01		 mov	 BYTE PTR [esi+352], 1
  00236	7e 10		 jle	 SHORT $LN25@PMoveProc

; 11112: 	{
; 11113: 		lpObj->PathCur = 1;
; 11114: 		lpObj->PathCount++;

  00238	ff 86 58 01 00
	00		 inc	 DWORD PTR [esi+344]
  0023e	c7 86 5c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+348], 1
$LN25@PMoveProc:

; 11115: 	}
; 11116: 
; 11117: 	for (n=1;n<lpObj->PathCount;n++)

  00248	83 be 58 01 00
	00 01		 cmp	 DWORD PTR [esi+344], 1
  0024f	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 1
  00259	0f 8e c3 00 00
	00		 jle	 $LN6@PMoveProc
  0025f	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _lpMove$GSCopy$1$[ebp]
  00265	b9 01 00 00 00	 mov	 ecx, 1
  0026a	66 0f 1f 44 00
	00		 npad	 6
$LL7@PMoveProc:

; 11118: 	{
; 11119: 		if ( (n%2) == 1 )

  00270	8b c1		 mov	 eax, ecx
  00272	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00277	79 05		 jns	 SHORT $LN78@PMoveProc
  00279	48		 dec	 eax
  0027a	83 c8 fe	 or	 eax, -2			; fffffffeH
  0027d	40		 inc	 eax
$LN78@PMoveProc:
  0027e	83 f8 01	 cmp	 eax, 1

; 11120: 		{
; 11121: 			pathtable = lpMove->Path[(n+1) / 2] >> 4;

  00281	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00284	75 14		 jne	 SHORT $LN26@PMoveProc
  00286	8b c0		 mov	 eax, eax
  00288	85 c0		 test	 eax, eax
  0028a	79 03		 jns	 SHORT $LN84@PMoveProc
  0028c	83 c0 01	 add	 eax, 1
$LN84@PMoveProc:
  0028f	d1 f8		 sar	 eax, 1
  00291	8a 44 18 05	 mov	 al, BYTE PTR [eax+ebx+5]
  00295	c0 e8 04	 shr	 al, 4

; 11122: 		}
; 11123: 		else

  00298	eb 11		 jmp	 SHORT $LN79@PMoveProc
$LN26@PMoveProc:

; 11124: 		{
; 11125: 			pathtable = lpMove->Path[(n+1) / 2] & 0x0F;

  0029a	8b c0		 mov	 eax, eax
  0029c	85 c0		 test	 eax, eax
  0029e	79 03		 jns	 SHORT $LN85@PMoveProc
  002a0	83 c0 01	 add	 eax, 1
$LN85@PMoveProc:
  002a3	d1 f8		 sar	 eax, 1
  002a5	8a 44 18 05	 mov	 al, BYTE PTR [eax+ebx+5]
  002a9	24 0f		 and	 al, 15			; 0000000fH
$LN79@PMoveProc:

; 11126: 		}
; 11127: 
; 11128: 		ax += RoadPathTable[pathtable*2];

  002ab	8a 9d ef fe ff
	ff		 mov	 bl, BYTE PTR _ax$1$[ebp]
  002b1	0f b6 d0	 movzx	 edx, al
  002b4	0f bf c2	 movsx	 eax, dx
  002b7	02 1c 85 00 00
	00 00		 add	 bl, BYTE PTR ?RoadPathTable@@3PAFA[eax*4]
  002be	88 9d ef fe ff
	ff		 mov	 BYTE PTR _ax$1$[ebp], bl

; 11129: 		ay += RoadPathTable[pathtable*2+1];

  002c4	8a 9d ee fe ff
	ff		 mov	 bl, BYTE PTR _ay$1$[ebp]
  002ca	02 1c 85 02 00
	00 00		 add	 bl, BYTE PTR ?RoadPathTable@@3PAFA[eax*4+2]

; 11130: 		
; 11131: 		lpObj->PathOri[n-1] = pathtable;
; 11132: 		lpObj->PathDir[n]= (char)pathtable;
; 11133: 		lpObj->PathX[n] = ax;

  002d1	8a 85 ef fe ff
	ff		 mov	 al, BYTE PTR _ax$1$[ebp]
  002d7	66 89 94 4e 60
	01 00 00	 mov	 WORD PTR [esi+ecx*2+352], dx
  002df	88 94 31 9e 01
	00 00		 mov	 BYTE PTR [ecx+esi+414], dl
  002e6	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _n$1$[ebp]
  002ec	42		 inc	 edx

; 11134: 		lpObj->PathY[n] = ay;

  002ed	88 9c 31 8f 01
	00 00		 mov	 BYTE PTR [ecx+esi+399], bl
  002f4	88 84 31 80 01
	00 00		 mov	 BYTE PTR [ecx+esi+384], al
  002fb	0f bf ca	 movsx	 ecx, dx
  002fe	88 9d ee fe ff
	ff		 mov	 BYTE PTR _ay$1$[ebp], bl
  00304	8b 9d e0 fe ff
	ff		 mov	 ebx, DWORD PTR _lpMove$GSCopy$1$[ebp]
  0030a	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _n$1$[ebp], edx
  00310	3b 8e 58 01 00
	00		 cmp	 ecx, DWORD PTR [esi+344]
  00316	0f 8c 54 ff ff
	ff		 jl	 $LL7@PMoveProc
  0031c	8d 9e 62 01 00
	00		 lea	 ebx, DWORD PTR [esi+354]
$LN6@PMoveProc:

; 11135: 	}
; 11136: 
; 11137: 	if ( lpObj->PathCount > 0 )

  00322	83 be 58 01 00
	00 00		 cmp	 DWORD PTR [esi+344], 0
  00329	0f 8e 86 00 00
	00		 jle	 $LN29@PMoveProc

; 11138: 	{
; 11139: 		int nextX;
; 11140: 		int nextY;
; 11141: 		BYTE mapnumber;
; 11142: 		BYTE attr;
; 11143: 		nextX = lpObj->PathX[1];
; 11144: 		nextY = lpObj->PathY[1];

  0032f	0f b6 86 90 01
	00 00		 movzx	 eax, BYTE PTR [esi+400]
  00336	0f b6 96 81 01
	00 00		 movzx	 edx, BYTE PTR [esi+385]

; 11145: 		mapnumber = lpObj->MapNumber;
; 11146: 		attr = MapC[mapnumber].GetAttr(nextX, nextY);

  0033d	50		 push	 eax
  0033e	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  00345	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  0034b	52		 push	 edx
  0034c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00352	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00357	a8 0c		 test	 al, 12			; 0000000cH

; 11147: 
; 11148: 		if ( (((BYTE)attr & (BYTE)4) == (BYTE)4) || (((BYTE)attr & (BYTE)8) == (BYTE)8) )

  00359	74 5a		 je	 SHORT $LN29@PMoveProc

; 11149: 		{
; 11150: 			for ( n=0 ; n<15 ; n++)

  0035b	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
$LL10@PMoveProc:

; 11151: 			{
; 11152: 				lpObj->PathX[n] = 0;
; 11153: 				lpObj->PathY[n] = 0;
; 11154: 				lpObj->PathOri[n] = 0;

  00360	33 c9		 xor	 ecx, ecx
  00362	c6 47 f1 00	 mov	 BYTE PTR [edi-15], 0
  00366	c6 07 00	 mov	 BYTE PTR [edi], 0
  00369	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]
  0036c	66 89 4b fe	 mov	 WORD PTR [ebx-2], cx
  00370	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00373	83 e8 01	 sub	 eax, 1
  00376	75 e8		 jne	 SHORT $LL10@PMoveProc

; 11155: 			}
; 11156: 
; 11157: 			lpObj->PathCount = 0;

  00378	89 8e 58 01 00
	00		 mov	 DWORD PTR [esi+344], ecx

; 11158: 			lpObj->PathCur = 0;

  0037e	89 8e 5c 01 00
	00		 mov	 DWORD PTR [esi+348], ecx

; 11159: 			lpObj->PathStartEnd = 0;

  00384	88 8e 60 01 00
	00		 mov	 BYTE PTR [esi+352], cl
$LN82@PMoveProc:

; 11160: 			gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  0038a	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00391	50		 push	 eax
  00392	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00399	50		 push	 eax
  0039a	ff 36		 push	 DWORD PTR [esi]
  0039c	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  003a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a4	5f		 pop	 edi
  003a5	5e		 pop	 esi
  003a6	5b		 pop	 ebx

; 11401: }

  003a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003aa	33 cd		 xor	 ecx, ebp
  003ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b1	8b e5		 mov	 esp, ebp
  003b3	5d		 pop	 ebp
  003b4	c3		 ret	 0
$LN29@PMoveProc:

; 11161: 			return;
; 11162: 		}
; 11163: 	}
; 11164: 
; 11165: 	lpObj->TX = (BYTE)ax;

  003b5	8a 85 ef fe ff
	ff		 mov	 al, BYTE PTR _ax$1$[ebp]

; 11166: 	lpObj->TY = (BYTE)ay;
; 11167: 
; 11168: 	/*if ( lpObj->Type == OBJ_USER )
; 11169: 	{
; 11170: 		int x = lpObj->X;
; 11171: 		int y = lpObj->Y;
; 11172: 		int bOk = FALSE;
; 11173: 		WORD Attr = 0;
; 11174: 
; 11175: 		for(int i = 0; i< 256;i++)
; 11176: 		{
; 11177: 			if( x > lpObj->TX )
; 11178: 			{
; 11179: 				x--;
; 11180: 			}
; 11181: 
; 11182: 			if( x < lpObj->TX )
; 11183: 			{
; 11184: 				x++;
; 11185: 			}
; 11186: 
; 11187: 			if( y > lpObj->TY )
; 11188: 			{
; 11189: 				y--;
; 11190: 			}
; 11191: 
; 11192: 			if( y < lpObj->TY )
; 11193: 			{
; 11194: 				y++;
; 11195: 			}
; 11196: 
; 11197: 			Attr = MapC[lpObj->MapNumber].GetAttr(x,y);
; 11198: 
; 11199: 			if( (Attr & 16) == 16 )
; 11200: 			{
; 11201: 				bOk = TRUE;
; 11202: 				break;
; 11203: 			}
; 11204: 
; 11205: 			if( x == lpObj->TX &&
; 11206: 				y == lpObj->TY )
; 11207: 			{
; 11208: 				break;
; 11209: 			}
; 11210: 		}
; 11211: 
; 11212: 		if( bOk == TRUE )
; 11213: 		{
; 11214: 			lpObj->m_Rest = 1;
; 11215: 			lpObj->PathCur = 0;
; 11216: 			lpObj->PathCount = 0;
; 11217: 			lpObj->PathStartEnd = 0;
; 11218: 			gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 11219: 
; 11220: 			PMSG_ACTIONRESULT pActionResult;
; 11221: 
; 11222: 			PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));
; 11223: 			pActionResult.NumberH = SET_NUMBERH(aIndex);
; 11224: 			pActionResult.NumberL = SET_NUMBERL(aIndex);
; 11225: 			pActionResult.ActionNumber = 0x7A;
; 11226: 			pActionResult.Dir = lpObj->Dir;
; 11227: 			pActionResult.TargetNumberH = 0;
; 11228: 			pActionResult.TargetNumberL = 0;
; 11229: 			DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));
; 11230: 			return;
; 11231: 		}
; 11232: 	}*/
; 11233: 
; 11234: 	if ( BC_MAP_RANGE(lpObj->MapNumber) && lpObj->Type == OBJ_USER )

  003bb	8a 8e 23 01 00
	00		 mov	 cl, BYTE PTR [esi+291]
  003c1	88 86 52 01 00
	00		 mov	 BYTE PTR [esi+338], al
  003c7	8a 85 ee fe ff
	ff		 mov	 al, BYTE PTR _ay$1$[ebp]
  003cd	88 86 53 01 00
	00		 mov	 BYTE PTR [esi+339], al
  003d3	80 f9 34	 cmp	 cl, 52			; 00000034H
  003d6	74 1b		 je	 SHORT $LN75@PMoveProc
  003d8	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  003db	0f 82 65 01 00
	00		 jb	 $LN33@PMoveProc
  003e1	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  003e6	3a c1		 cmp	 al, cl
  003e8	1b c0		 sbb	 eax, eax
  003ea	83 c0 01	 add	 eax, 1
  003ed	0f 84 53 01 00
	00		 je	 $LN33@PMoveProc
$LN75@PMoveProc:
  003f3	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  003f7	0f 85 49 01 00
	00		 jne	 $LN33@PMoveProc

; 11235: 	{
; 11236: 		int Bridge = g_BloodCastle.GetBridgeLevel(lpObj->MapNumber);

  003fd	0f b6 c1	 movzx	 eax, cl
  00400	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00405	50		 push	 eax
  00406	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  0040b	8b f8		 mov	 edi, eax

; 11237: 		switch ( g_BloodCastle.GetCurrentState(Bridge) )

  0040d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00412	57		 push	 edi
  00413	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00418	83 e8 01	 sub	 eax, 1
  0041b	0f 84 18 01 00
	00		 je	 $LN32@PMoveProc
  00421	83 e8 01	 sub	 eax, 1
  00424	0f 85 1c 01 00
	00		 jne	 $LN33@PMoveProc

; 11241: 				{
; 11242: 					lpObj->m_Rest = 1;
; 11243: 					lpObj->PathCur = 0;
; 11244: 					lpObj->PathCount = 0;
; 11245: 					lpObj->PathStartEnd = 0;
; 11246: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 11247: 
; 11248: 					PMSG_ACTIONRESULT pActionResult;
; 11249: 
; 11250: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));
; 11251: 					pActionResult.NumberH = SET_NUMBERH(aIndex);
; 11252: 					pActionResult.NumberL = SET_NUMBERL(aIndex);
; 11253: 					pActionResult.ActionNumber = 0x7A;
; 11254: 					pActionResult.Dir = lpObj->Dir;
; 11255: 					pActionResult.TargetNumberH = 0;
; 11256: 					pActionResult.TargetNumberL = 0;
; 11257: 
; 11258: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));
; 11259: 					return;
; 11260: 				}
; 11261: 				break;
; 11262: 			case 0x02:
; 11263: 				if ( lpObj->Y > 17 && g_BloodCastle.CheckPlayStart(Bridge) == false)

  0042a	80 be 21 01 00
	00 11		 cmp	 BYTE PTR [esi+289], 17	; 00000011H
  00431	76 2e		 jbe	 SHORT $LN35@PMoveProc
  00433	57		 push	 edi
  00434	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00439	e8 00 00 00 00	 call	 ?CheckPlayStart@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckPlayStart
  0043e	84 c0		 test	 al, al
  00440	75 1f		 jne	 SHORT $LN35@PMoveProc

; 11264: 				{
; 11265: 					gObjMoveGate(lpObj->m_Index, Bridge+0x42);

  00442	8d 47 42	 lea	 eax, DWORD PTR [edi+66]
  00445	50		 push	 eax
  00446	ff 36		 push	 DWORD PTR [esi]
  00448	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0044d	83 c4 08	 add	 esp, 8
  00450	5f		 pop	 edi
  00451	5e		 pop	 esi
  00452	5b		 pop	 ebx

; 11401: }

  00453	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00456	33 cd		 xor	 ecx, ebp
  00458	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045d	8b e5		 mov	 esp, ebp
  0045f	5d		 pop	 ebp
  00460	c3		 ret	 0
$LN35@PMoveProc:

; 11266: 					return;
; 11267: 				}
; 11268: 
; 11269: 				if ( lpObj->TY > 15 && g_BloodCastle.CheckPlayStart(Bridge) == false )

  00461	80 be 53 01 00
	00 0f		 cmp	 BYTE PTR [esi+339], 15	; 0000000fH
  00468	76 0f		 jbe	 SHORT $LN36@PMoveProc
  0046a	57		 push	 edi
  0046b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00470	e8 00 00 00 00	 call	 ?CheckPlayStart@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckPlayStart
  00475	84 c0		 test	 al, al
  00477	74 20		 je	 SHORT $LN81@PMoveProc
$LN36@PMoveProc:

; 11270: 				{
; 11271: 					lpObj->m_Rest = 1;
; 11272: 					lpObj->PathCur = 0;
; 11273: 					lpObj->PathCount = 0;
; 11274: 					lpObj->PathStartEnd = 0;
; 11275: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);
; 11276: 
; 11277: 					PMSG_ACTIONRESULT pActionResult;
; 11278: 
; 11279: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));
; 11280: 					pActionResult.NumberH = SET_NUMBERH(aIndex);
; 11281: 					pActionResult.NumberL = SET_NUMBERL(aIndex);
; 11282: 					pActionResult.ActionNumber = 0x7A;
; 11283: 					pActionResult.Dir = lpObj->Dir;
; 11284: 					pActionResult.TargetNumberH = 0;
; 11285: 					pActionResult.TargetNumberL = 0;
; 11286: 
; 11287: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));
; 11288: 					return;
; 11289: 				}
; 11290: 
; 11291: 				if ( lpObj->TY > 76 &&  g_BloodCastle.m_BridgeData[Bridge].m_bCASTLE_DOOR_LIVE )

  00479	80 be 53 01 00
	00 4c		 cmp	 BYTE PTR [esi+339], 76	; 0000004cH
  00480	0f 86 c0 00 00
	00		 jbe	 $LN33@PMoveProc
  00486	69 c7 0c 02 00
	00		 imul	 eax, edi, 524
  0048c	83 b8 4c 01 00
	00 00		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+332], 0
  00493	0f 84 ad 00 00
	00		 je	 $LN33@PMoveProc
$LN81@PMoveProc:

; 11292: 				{
; 11293: 					lpObj->m_Rest = 1;
; 11294: 					lpObj->PathCur = 0;
; 11295: 					lpObj->PathCount = 0;
; 11296: 					lpObj->PathStartEnd = 0;
; 11297: 					gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  00499	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  004a0	50		 push	 eax
  004a1	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  004a8	50		 push	 eax
  004a9	ff 36		 push	 DWORD PTR [esi]
  004ab	c6 86 d4 01 00
	00 01		 mov	 BYTE PTR [esi+468], 1
  004b2	c7 86 5c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+348], 0
  004bc	c7 86 58 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+344], 0
  004c6	c6 86 60 01 00
	00 00		 mov	 BYTE PTR [esi+352], 0
  004cd	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition

; 11298: 
; 11299: 					PMSG_ACTIONRESULT pActionResult;
; 11300: 
; 11301: 					PHeadSetB((LPBYTE)&pActionResult, 0x18, sizeof(pActionResult));

  004d2	6a 09		 push	 9
  004d4	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$1[ebp]
  004da	6a 18		 push	 24			; 00000018H
  004dc	50		 push	 eax
  004dd	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11302: 					pActionResult.NumberH = SET_NUMBERH(aIndex);

  004e2	8b 9d dc fe ff
	ff		 mov	 ebx, DWORD PTR _aIndex$GSCopy$1$[ebp]
  004e8	8b c3		 mov	 eax, ebx
  004ea	c1 e8 08	 shr	 eax, 8
  004ed	88 85 f3 fe ff
	ff		 mov	 BYTE PTR _pActionResult$1[ebp+3], al

; 11303: 					pActionResult.NumberL = SET_NUMBERL(aIndex);
; 11304: 					pActionResult.ActionNumber = 0x7A;
; 11305: 					pActionResult.Dir = lpObj->Dir;

  004f3	8a 86 22 01 00
	00		 mov	 al, BYTE PTR [esi+290]
  004f9	88 85 f5 fe ff
	ff		 mov	 BYTE PTR _pActionResult$1[ebp+5], al

; 11306: 					pActionResult.TargetNumberH = 0;
; 11307: 					pActionResult.TargetNumberL = 0;
; 11308: 
; 11309: 					DataSend(lpObj->m_Index, (LPBYTE)&pActionResult, sizeof(pActionResult));

  004ff	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pActionResult$1[ebp]
  00505	6a 09		 push	 9
  00507	50		 push	 eax
  00508	ff 36		 push	 DWORD PTR [esi]
  0050a	88 9d f4 fe ff
	ff		 mov	 BYTE PTR _pActionResult$1[ebp+4], bl
  00510	66 c7 85 f6 fe
	ff ff 7a 00	 mov	 WORD PTR _pActionResult$1[ebp+6], 122 ; 0000007aH
  00519	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR _pActionResult$1[ebp+8], 0
  00520	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00525	83 c4 24	 add	 esp, 36			; 00000024H
  00528	5f		 pop	 edi
  00529	5e		 pop	 esi
  0052a	5b		 pop	 ebx

; 11401: }

  0052b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0052e	33 cd		 xor	 ecx, ebp
  00530	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00535	8b e5		 mov	 esp, ebp
  00537	5d		 pop	 ebp
  00538	c3		 ret	 0
$LN32@PMoveProc:

; 11238: 		{
; 11239: 			case 0x01:
; 11240: 				if ( lpObj->TY > 15 )

  00539	80 be 53 01 00
	00 0f		 cmp	 BYTE PTR [esi+339], 15	; 0000000fH
  00540	0f 87 53 ff ff
	ff		 ja	 $LN81@PMoveProc
$LN33@PMoveProc:

; 11310: 					return;
; 11311: 				}
; 11312: 				break;
; 11313: 		}
; 11314: 	}
; 11315: 
; 11316: 	
; 11317: #if (__ENG__ == 1)
; 11318: 	PHeadSetB((LPBYTE)&pMove, 0xD4, sizeof(pMove));

  00546	6a 08		 push	 8
  00548	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMove$[ebp]
  0054e	68 d4 00 00 00	 push	 212			; 000000d4H
  00553	50		 push	 eax
  00554	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 11319: #else
; 11320: 	// KOR PROTOCOL !!
; 11321: 	PHeadSetB((LPBYTE)&pMove, 0xD7, sizeof(pMove));
; 11322: #endif
; 11323: 	pMove.NumberH = SET_NUMBERH(aIndex);

  00559	8b 9d dc fe ff
	ff		 mov	 ebx, DWORD PTR _aIndex$GSCopy$1$[ebp]
  0055f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00562	8b c3		 mov	 eax, ebx

; 11324: 	pMove.NumberL = SET_NUMBERL(aIndex);

  00564	88 9d e8 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+4], bl
  0056a	c1 e8 08	 shr	 eax, 8

; 11325: 	pMove.X = ax;
; 11326: 	pMove.Y = ay;
; 11327: 	pMove.Path = lpObj->Dir << 4;
; 11328: 
; 11329: 	if ( lpObj->Type == OBJ_USER )

  0056d	83 ca ff	 or	 edx, -1
  00570	88 85 e7 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+3], al
  00576	8a 85 ef fe ff
	ff		 mov	 al, BYTE PTR _ax$1$[ebp]
  0057c	88 85 e9 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+5], al
  00582	8a 85 ee fe ff
	ff		 mov	 al, BYTE PTR _ay$1$[ebp]
  00588	88 85 ea fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+6], al
  0058e	8a 86 22 01 00
	00		 mov	 al, BYTE PTR [esi+290]
  00594	c0 e0 04	 shl	 al, 4
  00597	88 85 eb fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+7], al
  0059d	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  005a1	0f 85 88 00 00
	00		 jne	 $LN38@PMoveProc

; 11330: 	{
; 11331: 		if ( lpObj->m_IfState.use )

  005a7	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  005ad	a8 03		 test	 al, 3
  005af	74 29		 je	 SHORT $LN42@PMoveProc

; 11332: 		{
; 11333: 			if ( lpObj->m_IfState.type == 3 )

  005b1	8b c8		 mov	 ecx, eax
  005b3	c1 e9 06	 shr	 ecx, 6
  005b6	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  005bc	83 f9 03	 cmp	 ecx, 3
  005bf	75 09		 jne	 SHORT $LN40@PMoveProc

; 11334: 			{
; 11335: 				lpObj->TargetShopNumber = -1;

  005c1	66 89 96 3a 06
	00 00		 mov	 WORD PTR [esi+1594], dx

; 11336: 				lpObj->m_IfState.type = 0;
; 11337: 				lpObj->m_IfState.use = 0;

  005c8	eb 05		 jmp	 SHORT $LN80@PMoveProc
$LN40@PMoveProc:

; 11338: 			}
; 11339: 			else if( lpObj->m_IfState.type == 21 )

  005ca	83 f9 15	 cmp	 ecx, 21			; 00000015H
  005cd	75 0b		 jne	 SHORT $LN42@PMoveProc
$LN80@PMoveProc:

; 11340: 			{
; 11341: 				lpObj->m_IfState.type = 0;
; 11342: 				lpObj->m_IfState.use = 0;

  005cf	25 3c 00 ff ff	 and	 eax, -65476		; ffff003cH
  005d4	89 86 b8 11 00
	00		 mov	 DWORD PTR [esi+4536], eax
$LN42@PMoveProc:

; 11343: 			}
; 11344: 		}
; 11345: 
; 11346: 		if ( !gObjPositionCheck(lpObj))

  005da	56		 push	 esi
  005db	e8 00 00 00 00	 call	 ?gObjPositionCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjPositionCheck
  005e0	83 c4 04	 add	 esp, 4
  005e3	85 c0		 test	 eax, eax
  005e5	75 30		 jne	 SHORT $LN43@PMoveProc

; 11347: 		{
; 11348: 			lpObj->PathCur = 0;
; 11349: 			lpObj->PathCount = 0;
; 11350: 			ax = lpObj->X;
; 11351: 			ay = lpObj->Y;

  005e7	8a 8e 21 01 00
	00		 mov	 cl, BYTE PTR [esi+289]
  005ed	89 86 5c 01 00
	00		 mov	 DWORD PTR [esi+348], eax
  005f3	89 86 58 01 00
	00		 mov	 DWORD PTR [esi+344], eax
  005f9	8a 86 20 01 00
	00		 mov	 al, BYTE PTR [esi+288]

; 11352: 			lpObj->TX = (BYTE)ax;

  005ff	88 86 52 01 00
	00		 mov	 BYTE PTR [esi+338], al

; 11353: 			lpObj->TY = (BYTE)ay;

  00605	88 8e 53 01 00
	00		 mov	 BYTE PTR [esi+339], cl

; 11354: 			pMove.X = ax;

  0060b	88 85 e9 fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+5], al

; 11355: 			pMove.Y = ay;

  00611	88 8d ea fe ff
	ff		 mov	 BYTE PTR _pMove$[ebp+6], cl
$LN43@PMoveProc:

; 11356: 		}
; 11357: 
; 11358: 		DataSend(aIndex, (LPBYTE)&pMove, pMove.h.size);

  00617	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  0061e	50		 push	 eax
  0061f	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMove$[ebp]
  00625	50		 push	 eax
  00626	53		 push	 ebx
  00627	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0062c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN38@PMoveProc:

; 11359: 	}
; 11360: 
; 11361: 	int MVL = MAX_VIEWPORT;
; 11362: 
; 11363: 	if ( lpObj->Type == OBJ_MONSTER )
; 11364: 		MVL = MAX_VIEWPORT_MONSTER;
; 11365: 		
; 11366: 	for (n=0;n<MVL;n++)

  0062f	33 ff		 xor	 edi, edi
  00631	33 c9		 xor	 ecx, ecx
$LL15@PMoveProc:

; 11367: 	{
; 11368: 		if ( lpObj->VpPlayer2[n].state == TRUE )

  00633	8d 81 06 01 00
	00		 lea	 eax, DWORD PTR [ecx+262]
  00639	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0063c	80 3c 86 01	 cmp	 BYTE PTR [esi+eax*4], 1
  00640	8d 1c 86	 lea	 ebx, DWORD PTR [esi+eax*4]
  00643	75 68		 jne	 SHORT $LN13@PMoveProc

; 11369: 		{
; 11370: 			int number = lpObj->VpPlayer2[n].number;

  00645	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00648	8d 04 85 4a 0c
	00 00		 lea	 eax, DWORD PTR [eax*4+3146]
  0064f	03 c6		 add	 eax, esi
  00651	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv1194[ebp], eax
  00657	0f bf 10	 movsx	 edx, WORD PTR [eax]

; 11371: 			
; 11372: 			if ( number >= 0 )

  0065a	85 d2		 test	 edx, edx
  0065c	78 4f		 js	 SHORT $LN13@PMoveProc

; 11373: 			{
; 11374: 				if ( gObj[number].Connected > PLAYER_CONNECTED )

  0065e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00663	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  00669	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  0066e	7e 28		 jle	 SHORT $LN47@PMoveProc

; 11375: 				{
; 11376: 					if ( gObj[number].Live )

  00670	80 7c 01 51 00	 cmp	 BYTE PTR [ecx+eax+81], 0
  00675	74 36		 je	 SHORT $LN13@PMoveProc

; 11377: 					{
; 11378: 						if ( gObj[number].Type == OBJ_USER )

  00677	80 7c 01 50 01	 cmp	 BYTE PTR [ecx+eax+80], 1
  0067c	75 2f		 jne	 SHORT $LN13@PMoveProc

; 11379: 						{
; 11380: 							DataSend(lpObj->VpPlayer2[n].number, (LPBYTE)&pMove, pMove.h.size);

  0067e	0f b6 85 e5 fe
	ff ff		 movzx	 eax, BYTE PTR _pMove$[ebp+1]
  00685	50		 push	 eax
  00686	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _pMove$[ebp]
  0068c	50		 push	 eax
  0068d	52		 push	 edx
  0068e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00693	83 c4 0c	 add	 esp, 12			; 0000000cH

; 11381: 						}
; 11382: 					}
; 11383: 				}
; 11384: 				else

  00696	eb 15		 jmp	 SHORT $LN13@PMoveProc
$LN47@PMoveProc:

; 11385: 				{
; 11386: 					lpObj->VpPlayer2[n].number= -1;

  00698	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR tv1194[ebp]
  0069e	83 ca ff	 or	 edx, -1

; 11387: 					lpObj->VpPlayer2[n].state = 0;

  006a1	c6 03 00	 mov	 BYTE PTR [ebx], 0
  006a4	66 89 10	 mov	 WORD PTR [eax], dx

; 11388: 					lpObj->VPCount2--;

  006a7	ff 8e d0 0f 00
	00		 dec	 DWORD PTR [esi+4048]
$LN13@PMoveProc:

; 11359: 	}
; 11360: 
; 11361: 	int MVL = MAX_VIEWPORT;
; 11362: 
; 11363: 	if ( lpObj->Type == OBJ_MONSTER )
; 11364: 		MVL = MAX_VIEWPORT_MONSTER;
; 11365: 		
; 11366: 	for (n=0;n<MVL;n++)

  006ad	47		 inc	 edi
  006ae	0f bf cf	 movsx	 ecx, di
  006b1	83 f9 4b	 cmp	 ecx, 75			; 0000004bH
  006b4	0f 8c 79 ff ff
	ff		 jl	 $LL15@PMoveProc

; 11389: 				}
; 11390: 			}
; 11391: 		}
; 11392: 	}
; 11393: 
; 11394: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  006ba	0f b6 86 51 01
	00 00		 movzx	 eax, BYTE PTR [esi+337]
  006c1	50		 push	 eax
  006c2	0f b6 86 50 01
	00 00		 movzx	 eax, BYTE PTR [esi+336]
  006c9	50		 push	 eax
  006ca	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  006d1	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  006d7	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  006dd	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 11395: 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  006e2	0f b6 86 53 01
	00 00		 movzx	 eax, BYTE PTR [esi+339]
  006e9	50		 push	 eax
  006ea	0f b6 86 52 01
	00 00		 movzx	 eax, BYTE PTR [esi+338]
  006f1	50		 push	 eax
  006f2	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  006f9	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  006ff	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00705	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 11396: 	lpObj->m_OldX = lpObj->TX;

  0070a	8a 86 52 01 00
	00		 mov	 al, BYTE PTR [esi+338]
  00710	88 86 50 01 00
	00		 mov	 BYTE PTR [esi+336], al

; 11397: 	lpObj->m_OldY = lpObj->TY;

  00716	8a 86 53 01 00
	00		 mov	 al, BYTE PTR [esi+339]
  0071c	88 86 51 01 00
	00		 mov	 BYTE PTR [esi+337], al

; 11398: 	lpObj->X = sx;

  00722	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _sx$1$[ebp]
  00728	88 86 20 01 00
	00		 mov	 BYTE PTR [esi+288], al

; 11399: 	lpObj->Y = sy;

  0072e	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _sy$1$[ebp]
  00734	5f		 pop	 edi
  00735	88 86 21 01 00
	00		 mov	 BYTE PTR [esi+289], al

; 11400: 	lpObj->m_ViewState = 0;

  0073b	c6 86 d5 01 00
	00 00		 mov	 BYTE PTR [esi+469], 0
  00742	5e		 pop	 esi
  00743	5b		 pop	 ebx

; 11401: }

  00744	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00747	33 cd		 xor	 ecx, ebp
  00749	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0074e	8b e5		 mov	 esp, ebp
  00750	5d		 pop	 ebp
  00751	c3		 ret	 0
$LN74@PMoveProc:

; 11032: 	{
; 11033: 		LogAdd("error-L3 : move protocol index error %s %d", __FILE__, __LINE__);

  00752	68 19 2b 00 00	 push	 11033			; 00002b19H
  00757	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0075c	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HEMFEGBB@error?9L3?5?3?5move?5protocol?5index?5e@
  00761	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 11401: }

  00767	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0076a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0076d	33 cd		 xor	 ecx, ebp
  0076f	5b		 pop	 ebx
  00770	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00775	8b e5		 mov	 esp, ebp
  00777	5d		 pop	 ebp
  00778	c3		 ret	 0
?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ENDP			; PMoveProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGChaosBoxUseEnd@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?CGChaosBoxUseEnd@@YAXH@Z PROC				; CGChaosBoxUseEnd, COMDAT

; 10985: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 10986: 	if ( !gObjIsConnectedGP(aIndex))

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	75 1f		 jne	 SHORT $LN2@CGChaosBox

; 10987: 	{
; 10988: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00015	68 ec 2a 00 00	 push	 10988			; 00002aecH
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00024	6a 02		 push	 2
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	5f		 pop	 edi

; 11012: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN2@CGChaosBox:
  00034	56		 push	 esi

; 10989: 		return;
; 10990: 	}
; 10991: 
; 10992: 	LPOBJ lpObj = &gObj[aIndex];

  00035	69 f7 40 27 00
	00		 imul	 esi, edi, 10048

; 10993: 
; 10994: 	PMSG_DEFAULT pMsg;
; 10995: 	PHeadSetB((LPBYTE)&pMsg, 0x87, sizeof(pMsg));

  0003b	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003e	6a 03		 push	 3
  00040	68 87 00 00 00	 push	 135			; 00000087H
  00045	50		 push	 eax
  00046	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10996: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00051	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00055	50		 push	 eax
  00056	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00059	50		 push	 eax
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10997: 
; 10998: 	if ( lpObj->m_IfState.use && lpObj->m_IfState.type == 7 )

  00060	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  00066	83 c4 18	 add	 esp, 24			; 00000018H
  00069	f6 c1 03	 test	 cl, 3
  0006c	74 17		 je	 SHORT $LN3@CGChaosBox
  0006e	8b c1		 mov	 eax, ecx
  00070	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00075	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  0007a	75 09		 jne	 SHORT $LN3@CGChaosBox

; 10999: 	{
; 11000: 		lpObj->m_IfState.use = 0;
; 11001: 		lpObj->m_IfState.state = 0;

  0007c	83 e1 c0	 and	 ecx, -64		; ffffffc0H
  0007f	89 8e b8 11 00
	00		 mov	 DWORD PTR [esi+4536], ecx
$LN3@CGChaosBox:

; 11002: 	}
; 11003: 
; 11004: 	g_ChaosBox.ChaosBoxInit(lpObj);

  00085	56		 push	 esi
  00086	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0008b	e8 00 00 00 00	 call	 ?ChaosBoxInit@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::ChaosBoxInit

; 11005: 
; 11006: 	if(lpObj->pTransaction == 1)

  00090	80 be cc 11 00
	00 01		 cmp	 BYTE PTR [esi+4556], 1
  00097	75 0a		 jne	 SHORT $LN4@CGChaosBox

; 11007: 	{
; 11008: 		gObjInventoryCommit(lpObj->m_Index);

  00099	ff 36		 push	 DWORD PTR [esi]
  0009b	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  000a0	83 c4 04	 add	 esp, 4
$LN4@CGChaosBox:

; 11009: 	}
; 11010: 
; 11011: 	lpObj->m_bIsCastleNPCUpgradeCompleted = false;

  000a3	c6 86 5c 20 00
	00 00		 mov	 BYTE PTR [esi+8284], 0
  000aa	5e		 pop	 esi
  000ab	5f		 pop	 edi

; 11012: }

  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?CGChaosBoxUseEnd@@YAXH@Z ENDP				; CGChaosBoxUseEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z
_TEXT	SEGMENT
_iHeight$1 = -44					; size = 4
_iWidth$2 = -40						; size = 4
_aRecv$GSCopy$1$ = -36					; size = 4
tv626 = -32						; size = 4
_aIndex$GSCopy$1$ = -28					; size = 4
_iPos$1$ = -24						; size = 4
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z PROC ; CGChaosBoxItemMixButtonClick, COMDAT

; 10678: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 08	 mov	 edi, DWORD PTR _aRecv$[ebp]

; 10679: 	if ( !gObjIsConnectedGP(aIndex))

  00018	53		 push	 ebx
  00019	89 7d dc	 mov	 DWORD PTR _aRecv$GSCopy$1$[ebp], edi
  0001c	89 5d e4	 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], ebx
  0001f	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 2a		 jne	 SHORT $LN10@CGChaosBox

; 10680: 	{
; 10681: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  0002b	68 b9 29 00 00	 push	 10681			; 000029b9H
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  0003a	6a 02		 push	 2
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	5f		 pop	 edi
  00046	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN10@CGChaosBox:
  00055	56		 push	 esi

; 10682: 		return;
; 10683: 	}
; 10684: 
; 10685: 	LPOBJ lpObj = &gObj[aIndex];

  00056	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  0005c	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 10686: 
; 10687: 	if ( lpObj->ChaosLock == TRUE )

  00062	83 be 20 12 00
	00 01		 cmp	 DWORD PTR [esi+4640], 1
  00069	75 43		 jne	 SHORT $LN11@CGChaosBox

; 10688: 	{
; 10689: 		LogAdd("[%s][%s] Already Used Chaos",

  0006b	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0006e	50		 push	 eax
  0006f	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00072	50		 push	 eax
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GLBENMI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Already?5Used?5Chaos?$AA@
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10690: 			lpObj->AccountID, lpObj->Name);
; 10691: 
; 10692: 		GCServerMsgStringSend(lMsg.Get(MSGGET(2, 198)), lpObj->m_Index, 1);

  00081	6a 01		 push	 1
  00083	ff 36		 push	 DWORD PTR [esi]
  00085	68 c6 02 00 00	 push	 710			; 000002c6H
$LN94@CGChaosBox:
  0008a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0008f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 10777: 		{
; 10778: 
; 10779: 		}
; 10780: 		else
; 10781: 		{
; 10782: 			pMsg.Result = FALSE;
; 10783: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009d	5e		 pop	 esi
  0009e	5f		 pop	 edi
  0009f	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a3	33 cd		 xor	 ecx, ebp
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
$LN11@CGChaosBox:

; 10693: 		return;
; 10694: 	}
; 10695: 
; 10696: 	if ( lpObj->m_bPShopOpen == true )

  000ae	80 be 5c 12 00
	00 01		 cmp	 BYTE PTR [esi+4700], 1
  000b5	75 21		 jne	 SHORT $LN12@CGChaosBox

; 10697: 	{
; 10698: 		LogAdd("[%s][%s] is Already Opening PShop, ChaosBox Failed",

  000b7	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000ba	50		 push	 eax
  000bb	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  000be	50		 push	 eax
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10699: 			lpObj->AccountID, lpObj->Name);
; 10700: 
; 10701: 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 194)), lpObj->m_Index, 1);

  000cd	6a 01		 push	 1
  000cf	ff 36		 push	 DWORD PTR [esi]
  000d1	68 c2 04 00 00	 push	 1218			; 000004c2H

; 10702: 		return;

  000d6	eb b2		 jmp	 SHORT $LN94@CGChaosBox
$LN12@CGChaosBox:

; 10703: 	}
; 10704: 
; 10705: 
; 10706: 	PMSG_CHAOSMIXRESULT pMsg;
; 10707: 	PHeadSetB((LPBYTE)&pMsg.h, 0x86, sizeof(PMSG_CHAOSMIXRESULT));

  000d8	6a 10		 push	 16			; 00000010H
  000da	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000dd	68 86 00 00 00	 push	 134			; 00000086H
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10708: 	pMsg.Result = FALSE;
; 10709: 
; 10710: 	if ( aRecv->Type == CHAOS_TYPE_UPGRADE_10 ||
; 10711: 		 aRecv->Type == CHAOS_TYPE_UPGRADE_11 || 
; 10712: 		 aRecv->Type == CHAOS_TYPE_UPGRADE_12 ||
; 10713: 		 aRecv->Type == CHAOS_TYPE_UPGRADE_13 ||
; 10714: 		 aRecv->Type == CHAOS_TYPE_UPGRADE_14 ||

  000e8	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ee	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  000f2	3c 03		 cmp	 al, 3
  000f4	74 18		 je	 SHORT $LN14@CGChaosBox
  000f6	3c 04		 cmp	 al, 4
  000f8	74 14		 je	 SHORT $LN14@CGChaosBox
  000fa	3c 16		 cmp	 al, 22			; 00000016H
  000fc	74 10		 je	 SHORT $LN14@CGChaosBox
  000fe	3c 17		 cmp	 al, 23			; 00000017H
  00100	74 0c		 je	 SHORT $LN14@CGChaosBox
  00102	3c 31		 cmp	 al, 49			; 00000031H
  00104	74 08		 je	 SHORT $LN14@CGChaosBox
  00106	3c 32		 cmp	 al, 50			; 00000032H
  00108	0f 85 f6 00 00
	00		 jne	 $LN30@CGChaosBox
$LN14@CGChaosBox:

; 10715: 		 aRecv->Type == CHAOS_TYPE_UPGRADE_15 )
; 10716: 	{
; 10717: 		int iPos = 0;
; 10718: 		int iItemCount = 0;

  0010e	33 ff		 xor	 edi, edi
  00110	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iPos$1$[ebp], 0

; 10719: 
; 10720: 		for(int n = 0; n < CHAOS_BOX_SIZE; n++)

  00117	33 db		 xor	 ebx, ebx
  00119	33 d2		 xor	 edx, edx
  0011b	89 55 e0	 mov	 DWORD PTR tv626[ebp], edx
  0011e	66 90		 npad	 2
$LL4@CGChaosBox:

; 10721: 		{
; 10722: 			if( lpObj->pChaosBox[n].IsItem() == TRUE )

  00120	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  00126	03 ca		 add	 ecx, edx
  00128	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 10723: 			{
; 10724: 				if( lpObj->pChaosBox[n].m_Level == 9 )

  0012d	8b 55 e0	 mov	 edx, DWORD PTR tv626[ebp]
  00130	83 f8 01	 cmp	 eax, 1
  00133	75 5f		 jne	 SHORT $LN91@CGChaosBox
  00135	8b 86 10 12 00
	00		 mov	 eax, DWORD PTR [esi+4624]
  0013b	0f b7 44 02 08	 movzx	 eax, WORD PTR [edx+eax+8]
  00140	66 83 f8 09	 cmp	 ax, 9
  00144	75 08		 jne	 SHORT $LN16@CGChaosBox

; 10725: 				{
; 10726: 					iPos = n;

  00146	8b c3		 mov	 eax, ebx

; 10727: 					iItemCount++;

  00148	47		 inc	 edi
  00149	89 45 e8	 mov	 DWORD PTR _iPos$1$[ebp], eax
  0014c	eb 49		 jmp	 SHORT $LN2@CGChaosBox
$LN16@CGChaosBox:

; 10728: 				}
; 10729: 				else if( lpObj->pChaosBox[n].m_Level == 10 )

  0014e	66 83 f8 0a	 cmp	 ax, 10			; 0000000aH
  00152	75 08		 jne	 SHORT $LN18@CGChaosBox

; 10730: 				{
; 10731: 					iPos = n;

  00154	8b c3		 mov	 eax, ebx

; 10732: 					iItemCount++;

  00156	47		 inc	 edi
  00157	89 45 e8	 mov	 DWORD PTR _iPos$1$[ebp], eax
  0015a	eb 3b		 jmp	 SHORT $LN2@CGChaosBox
$LN18@CGChaosBox:

; 10733: 				}
; 10734: 				else if( lpObj->pChaosBox[n].m_Level == 11 )

  0015c	66 83 f8 0b	 cmp	 ax, 11			; 0000000bH
  00160	75 08		 jne	 SHORT $LN20@CGChaosBox

; 10735: 				{
; 10736: 					iPos = n;

  00162	8b c3		 mov	 eax, ebx

; 10737: 					iItemCount++;

  00164	47		 inc	 edi
  00165	89 45 e8	 mov	 DWORD PTR _iPos$1$[ebp], eax
  00168	eb 2d		 jmp	 SHORT $LN2@CGChaosBox
$LN20@CGChaosBox:

; 10738: 				}
; 10739: 				else if( lpObj->pChaosBox[n].m_Level == 12 )

  0016a	66 83 f8 0c	 cmp	 ax, 12			; 0000000cH
  0016e	75 08		 jne	 SHORT $LN22@CGChaosBox

; 10740: 				{
; 10741: 					iPos = n;

  00170	8b c3		 mov	 eax, ebx

; 10742: 					iItemCount++;

  00172	47		 inc	 edi
  00173	89 45 e8	 mov	 DWORD PTR _iPos$1$[ebp], eax
  00176	eb 1f		 jmp	 SHORT $LN2@CGChaosBox
$LN22@CGChaosBox:

; 10743: 				}
; 10744: 				else if( lpObj->pChaosBox[n].m_Level == 13 )

  00178	66 83 f8 0d	 cmp	 ax, 13			; 0000000dH
  0017c	75 08		 jne	 SHORT $LN24@CGChaosBox

; 10745: 				{
; 10746: 					iPos = n;

  0017e	8b c3		 mov	 eax, ebx

; 10747: 					iItemCount++;

  00180	47		 inc	 edi
  00181	89 45 e8	 mov	 DWORD PTR _iPos$1$[ebp], eax
  00184	eb 11		 jmp	 SHORT $LN2@CGChaosBox
$LN24@CGChaosBox:

; 10748: 				}
; 10749: 				else if( lpObj->pChaosBox[n].m_Level == 14 )

  00186	66 83 f8 0e	 cmp	 ax, 14			; 0000000eH
  0018a	75 08		 jne	 SHORT $LN91@CGChaosBox

; 10750: 				{
; 10751: 					iPos = n;

  0018c	8b c3		 mov	 eax, ebx

; 10752: 					iItemCount++;

  0018e	47		 inc	 edi
  0018f	89 45 e8	 mov	 DWORD PTR _iPos$1$[ebp], eax
  00192	eb 03		 jmp	 SHORT $LN2@CGChaosBox
$LN91@CGChaosBox:
  00194	8b 45 e8	 mov	 eax, DWORD PTR _iPos$1$[ebp]
$LN2@CGChaosBox:

; 10719: 
; 10720: 		for(int n = 0; n < CHAOS_BOX_SIZE; n++)

  00197	81 c2 d4 00 00
	00		 add	 edx, 212		; 000000d4H
  0019d	43		 inc	 ebx
  0019e	89 55 e0	 mov	 DWORD PTR tv626[ebp], edx
  001a1	81 fa 80 1a 00
	00		 cmp	 edx, 6784		; 00001a80H
  001a7	0f 8c 73 ff ff
	ff		 jl	 $LL4@CGChaosBox

; 10753: 				}
; 10754: 			}
; 10755: 		}
; 10756: 
; 10757: 		if( iItemCount != 1 )

  001ad	83 ff 01	 cmp	 edi, 1
  001b0	0f 85 ef 05 00
	00		 jne	 $LN29@CGChaosBox

; 10758: 		{
; 10759: 			pMsg.Result = FALSE;
; 10760: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 10761: 			return;
; 10762: 		}
; 10763: 
; 10764: 		if( lpObj->pChaosBox[iPos].m_bLuckySet )

  001b6	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  001bc	03 8e 10 12 00
	00		 add	 ecx, DWORD PTR [esi+4624]
  001c2	80 b9 ce 00 00
	00 00		 cmp	 BYTE PTR [ecx+206], 0
  001c9	0f 85 d6 05 00
	00		 jne	 $LN29@CGChaosBox

; 10765: 		{
; 10766: 			pMsg.Result = FALSE;
; 10767: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 10768: 			return;
; 10769: 		}
; 10770: 
; 10771: 		int iWidth = 0;
; 10772: 		int iHeight = 0;
; 10773: 
; 10774: 		lpObj->pChaosBox[iPos].GetSize(iHeight,iWidth);

  001cf	8d 45 d8	 lea	 eax, DWORD PTR _iWidth$2[ebp]
  001d2	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _iWidth$2[ebp], 0
  001d9	50		 push	 eax
  001da	8d 45 d4	 lea	 eax, DWORD PTR _iHeight$1[ebp]
  001dd	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _iHeight$1[ebp], 0
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 10775: 
; 10776: 		if( CheckInventoryEmptySpace(lpObj,iHeight,iWidth) != false )

  001ea	ff 75 d8	 push	 DWORD PTR _iWidth$2[ebp]
  001ed	ff 75 d4	 push	 DWORD PTR _iHeight$1[ebp]
  001f0	56		 push	 esi
  001f1	e8 00 00 00 00	 call	 ?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
  001f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f9	85 c0		 test	 eax, eax
  001fb	0f 84 a4 05 00
	00		 je	 $LN29@CGChaosBox
  00201	8b 7d dc	 mov	 edi, DWORD PTR _aRecv$GSCopy$1$[ebp]
$LN30@CGChaosBox:

; 10784: 			return;
; 10785: 		}
; 10786: 	}
; 10787: 
; 10788: 
; 10789: 	lpObj->bIsChaosMixCompleted = true;

  00204	c6 86 09 16 00
	00 01		 mov	 BYTE PTR [esi+5641], 1

; 10790: 	int iMixType = aRecv->Type;

  0020b	0f b6 5f 03	 movzx	 ebx, BYTE PTR [edi+3]
  0020f	33 ff		 xor	 edi, edi
$LL7@CGChaosBox:

; 10793: 	{
; 10794: 		if ( lpObj->pChaosBox[n].IsItem() == TRUE
; 10795: 			&& lpObj->pChaosBox[n].m_bPeriodItem )

  00211	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  00217	03 cf		 add	 ecx, edi
  00219	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0021e	83 f8 01	 cmp	 eax, 1
  00221	75 14		 jne	 SHORT $LN5@CGChaosBox
  00223	8b 86 10 12 00
	00		 mov	 eax, DWORD PTR [esi+4624]
  00229	80 bc 07 cf 00
	00 00 00	 cmp	 BYTE PTR [edi+eax+207], 0
  00231	0f 85 6e 05 00
	00		 jne	 $LN29@CGChaosBox
$LN5@CGChaosBox:

; 10791: 
; 10792: 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00237	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  0023d	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  00243	7c cc		 jl	 SHORT $LL7@CGChaosBox

; 10796: 		{
; 10797: 			pMsg.Result = FALSE;
; 10798: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 10799: 			return;
; 10800: 		}
; 10801: 	}
; 10802: #if(ENABLETEST_CHAOSMACHINEMNGR == 1)
; 10803: 	if (g_ChaosMachineManager.StartMix(lpObj, iMixType))
; 10804: 	{
; 10805: 		return;
; 10806: 	}
; 10807: #endif
; 10808: 	switch ( iMixType )	// TEST - Good

  00245	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00248	83 f8 38	 cmp	 eax, 56			; 00000038H
  0024b	0f 87 2c 05 00
	00		 ja	 $LN78@CGChaosBox
  00251	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN96@CGChaosBox[eax*4]
$LN32@CGChaosBox:

; 10809: 	{
; 10810: 		case CHAOS_TYPE_DEVILSQUARE:
; 10811: 			g_ChaosBox.DevilSquareItemChaosMix(lpObj);

  00258	56		 push	 esi
  00259	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0025e	e8 00 00 00 00	 call	 ?DevilSquareItemChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::DevilSquareItemChaosMix
  00263	5e		 pop	 esi
  00264	5f		 pop	 edi
  00265	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00266	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00269	33 cd		 xor	 ecx, ebp
  0026b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00270	8b e5		 mov	 esp, ebp
  00272	5d		 pop	 ebp
  00273	c3		 ret	 0
$LN33@CGChaosBox:

; 10812: 			break;
; 10813: 		case CHAOS_TYPE_UPGRADE_10:
; 10814: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_10);

  00274	6a 03		 push	 3
  00276	56		 push	 esi
  00277	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0027c	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  00281	5e		 pop	 esi
  00282	5f		 pop	 edi
  00283	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00284	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00287	33 cd		 xor	 ecx, ebp
  00289	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c3		 ret	 0
$LN34@CGChaosBox:

; 10815: 			break;
; 10816: 		case CHAOS_TYPE_UPGRADE_11:
; 10817: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_11);

  00292	6a 04		 push	 4
  00294	56		 push	 esi
  00295	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0029a	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  0029f	5e		 pop	 esi
  002a0	5f		 pop	 edi
  002a1	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  002a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a5	33 cd		 xor	 ecx, ebp
  002a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ac	8b e5		 mov	 esp, ebp
  002ae	5d		 pop	 ebp
  002af	c3		 ret	 0
$LN35@CGChaosBox:

; 10818: 			break;
; 10819: 		case CHAOS_TYPE_UPGRADE_12:
; 10820: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_12);

  002b0	6a 16		 push	 22			; 00000016H
  002b2	56		 push	 esi
  002b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  002b8	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  002bd	5e		 pop	 esi
  002be	5f		 pop	 edi
  002bf	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  002c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c3	33 cd		 xor	 ecx, ebp
  002c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ca	8b e5		 mov	 esp, ebp
  002cc	5d		 pop	 ebp
  002cd	c3		 ret	 0
$LN36@CGChaosBox:

; 10821: 			break;
; 10822: 		case CHAOS_TYPE_UPGRADE_13:
; 10823: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_13);

  002ce	6a 17		 push	 23			; 00000017H
  002d0	56		 push	 esi
  002d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  002d6	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  002db	5e		 pop	 esi
  002dc	5f		 pop	 edi
  002dd	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  002de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e1	33 cd		 xor	 ecx, ebp
  002e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e8	8b e5		 mov	 esp, ebp
  002ea	5d		 pop	 ebp
  002eb	c3		 ret	 0
$LN37@CGChaosBox:

; 10824: 			break;
; 10825: 		case CHAOS_TYPE_UPGRADE_14:
; 10826: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_14);

  002ec	6a 31		 push	 49			; 00000031H
  002ee	56		 push	 esi
  002ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  002f4	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  002f9	5e		 pop	 esi
  002fa	5f		 pop	 edi
  002fb	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  002fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ff	33 cd		 xor	 ecx, ebp
  00301	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00306	8b e5		 mov	 esp, ebp
  00308	5d		 pop	 ebp
  00309	c3		 ret	 0
$LN38@CGChaosBox:

; 10827: 			break;
; 10828: 		case CHAOS_TYPE_UPGRADE_15:
; 10829: 			g_ChaosBox.PlusItemLevelChaosMix(lpObj, CHAOS_TYPE_UPGRADE_15);

  0030a	6a 32		 push	 50			; 00000032H
  0030c	56		 push	 esi
  0030d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00312	e8 00 00 00 00	 call	 ?PlusItemLevelChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@H@Z ; CChaosBox::PlusItemLevelChaosMix
  00317	5e		 pop	 esi
  00318	5f		 pop	 edi
  00319	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0031a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0031d	33 cd		 xor	 ecx, ebp
  0031f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00324	8b e5		 mov	 esp, ebp
  00326	5d		 pop	 ebp
  00327	c3		 ret	 0
$LN39@CGChaosBox:

; 10830: 			break;
; 10831: 		case CHAOS_TYPE_DINORANT:
; 10832: 			g_ChaosBox.PegasiaChaosMix(lpObj);

  00328	56		 push	 esi
  00329	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0032e	e8 00 00 00 00	 call	 ?PegasiaChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::PegasiaChaosMix
  00333	5e		 pop	 esi
  00334	5f		 pop	 edi
  00335	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00336	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00339	33 cd		 xor	 ecx, ebp
  0033b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00340	8b e5		 mov	 esp, ebp
  00342	5d		 pop	 ebp
  00343	c3		 ret	 0
$LN40@CGChaosBox:

; 10833: 			break;
; 10834: 		case CHAOS_TYPE_FRUIT:
; 10835: 			g_ChaosBox.CircleChaosMix(lpObj);

  00344	56		 push	 esi
  00345	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0034a	e8 00 00 00 00	 call	 ?CircleChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::CircleChaosMix
  0034f	5e		 pop	 esi
  00350	5f		 pop	 edi
  00351	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00352	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00355	33 cd		 xor	 ecx, ebp
  00357	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035c	8b e5		 mov	 esp, ebp
  0035e	5d		 pop	 ebp
  0035f	c3		 ret	 0
$LN41@CGChaosBox:

; 10836: 			break;
; 10837: 		case CHAOS_TYPE_SECOND_WING:
; 10838: 		case CHAOS_TYPE_CLOAK:
; 10839: 			g_ChaosBox.WingChaosMix(lpObj);

  00360	56		 push	 esi
  00361	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00366	e8 00 00 00 00	 call	 ?WingChaosMix@CChaosBox@@QAEHPAUOBJECTSTRUCT@@@Z ; CChaosBox::WingChaosMix
  0036b	5e		 pop	 esi
  0036c	5f		 pop	 edi
  0036d	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0036e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00371	33 cd		 xor	 ecx, ebp
  00373	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00378	8b e5		 mov	 esp, ebp
  0037a	5d		 pop	 ebp
  0037b	c3		 ret	 0
$LN42@CGChaosBox:

; 10840: 			break;
; 10841: 		case CHAOS_TYPE_BLOODCATLE:
; 10842: 			g_ChaosBox.BloodCastleItemChaosMix(lpObj);

  0037c	56		 push	 esi
  0037d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00382	e8 00 00 00 00	 call	 ?BloodCastleItemChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::BloodCastleItemChaosMix
  00387	5e		 pop	 esi
  00388	5f		 pop	 edi
  00389	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0038a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0038d	33 cd		 xor	 ecx, ebp
  0038f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00394	8b e5		 mov	 esp, ebp
  00396	5d		 pop	 ebp
  00397	c3		 ret	 0
$LN43@CGChaosBox:

; 10843: 			break;
; 10844: 		case CHAOS_TYPE_DEFAULT:
; 10845: 		case CHAOS_TYPE_FIRST_WING:
; 10846: 			g_ChaosBox.DefaultChaosMix(lpObj);

  00398	56		 push	 esi
  00399	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0039e	e8 00 00 00 00	 call	 ?DefaultChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::DefaultChaosMix
  003a3	5e		 pop	 esi
  003a4	5f		 pop	 edi
  003a5	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  003a6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a9	33 cd		 xor	 ecx, ebp
  003ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b0	8b e5		 mov	 esp, ebp
  003b2	5d		 pop	 ebp
  003b3	c3		 ret	 0
$LN44@CGChaosBox:

; 10847: 			break;
; 10848: 		//case CHAOS_TYPE_SETITEM:	// #warning Activate this to SetItemChaosMix
; 10849: 			//SetItemChaosMix(lpObj);
; 10850: 			//break;
; 10851: 		case CHAOS_TYPE_DARKHORSE:
; 10852: 			g_ChaosBox.DarkHorseChaosMix(lpObj);

  003b4	56		 push	 esi
  003b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  003ba	e8 00 00 00 00	 call	 ?DarkHorseChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::DarkHorseChaosMix
  003bf	5e		 pop	 esi
  003c0	5f		 pop	 edi
  003c1	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  003c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c5	33 cd		 xor	 ecx, ebp
  003c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cc	8b e5		 mov	 esp, ebp
  003ce	5d		 pop	 ebp
  003cf	c3		 ret	 0
$LN45@CGChaosBox:

; 10853: 			break;
; 10854: 		case CHAOS_TYPE_DARKSPIRIT:
; 10855: 			g_ChaosBox.DarkSpiritChaosMix(lpObj);

  003d0	56		 push	 esi
  003d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  003d6	e8 00 00 00 00	 call	 ?DarkSpiritChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::DarkSpiritChaosMix
  003db	5e		 pop	 esi
  003dc	5f		 pop	 edi
  003dd	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  003de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e1	33 cd		 xor	 ecx, ebp
  003e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e8	8b e5		 mov	 esp, ebp
  003ea	5d		 pop	 ebp
  003eb	c3		 ret	 0
$LN46@CGChaosBox:

; 10856: 			break;
; 10857: 		case CHAOS_TYPE_BLESS_POTION:
; 10858: 			g_ChaosBox.BlessPotionChaosMix(lpObj);

  003ec	56		 push	 esi
  003ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  003f2	e8 00 00 00 00	 call	 ?BlessPotionChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::BlessPotionChaosMix
  003f7	5e		 pop	 esi
  003f8	5f		 pop	 edi
  003f9	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  003fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fd	33 cd		 xor	 ecx, ebp
  003ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00404	8b e5		 mov	 esp, ebp
  00406	5d		 pop	 ebp
  00407	c3		 ret	 0
$LN47@CGChaosBox:

; 10859: 			break;
; 10860: 		case CHAOS_TYPE_SOUL_POTION:
; 10861: 			g_ChaosBox.SoulPotionChaosMix(lpObj);

  00408	56		 push	 esi
  00409	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0040e	e8 00 00 00 00	 call	 ?SoulPotionChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::SoulPotionChaosMix
  00413	5e		 pop	 esi
  00414	5f		 pop	 edi
  00415	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00416	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00419	33 cd		 xor	 ecx, ebp
  0041b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00420	8b e5		 mov	 esp, ebp
  00422	5d		 pop	 ebp
  00423	c3		 ret	 0
$LN48@CGChaosBox:

; 10862: 			break;
; 10863: 		case CHAOS_TYPE_LIFE_STONE:
; 10864: 			g_ChaosBox.LifeStoneChaosMix(lpObj);

  00424	56		 push	 esi
  00425	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0042a	e8 00 00 00 00	 call	 ?LifeStoneChaosMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::LifeStoneChaosMix
  0042f	5e		 pop	 esi
  00430	5f		 pop	 edi
  00431	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00432	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00435	33 cd		 xor	 ecx, ebp
  00437	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0043c	8b e5		 mov	 esp, ebp
  0043e	5d		 pop	 ebp
  0043f	c3		 ret	 0
$LN49@CGChaosBox:

; 10865: 			break;
; 10866: #if (GS_CASTLE == 1)
; 10867: 		case CHAOS_TYPE_CASTLE_SPECIALMIX:
; 10868: 			g_ChaosBox.CastleSpecialItemMix(lpObj);

  00440	56		 push	 esi
  00441	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00446	e8 00 00 00 00	 call	 ?CastleSpecialItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::CastleSpecialItemMix
  0044b	5e		 pop	 esi
  0044c	5f		 pop	 edi
  0044d	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0044e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00451	33 cd		 xor	 ecx, ebp
  00453	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00458	8b e5		 mov	 esp, ebp
  0045a	5d		 pop	 ebp
  0045b	c3		 ret	 0
$LN50@CGChaosBox:

; 10869: 			break;
; 10870: #endif
; 10871: 		case CHAOS_TYPE_HT_BOX:
; 10872: 			g_ChaosBox.HiddenTreasureBoxItemMix(lpObj);

  0045c	56		 push	 esi
  0045d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00462	e8 00 00 00 00	 call	 ?HiddenTreasureBoxItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::HiddenTreasureBoxItemMix
  00467	5e		 pop	 esi
  00468	5f		 pop	 edi
  00469	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0046a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0046d	33 cd		 xor	 ecx, ebp
  0046f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00474	8b e5		 mov	 esp, ebp
  00476	5d		 pop	 ebp
  00477	c3		 ret	 0
$LN51@CGChaosBox:

; 10873: 			break;
; 10874: 		case CHAOS_TYPE_FENRIR_01:
; 10875: 			g_ChaosBox.Fenrir_01Level_Mix(lpObj);

  00478	56		 push	 esi
  00479	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0047e	e8 00 00 00 00	 call	 ?Fenrir_01Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::Fenrir_01Level_Mix
  00483	5e		 pop	 esi
  00484	5f		 pop	 edi
  00485	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00486	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00489	33 cd		 xor	 ecx, ebp
  0048b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00490	8b e5		 mov	 esp, ebp
  00492	5d		 pop	 ebp
  00493	c3		 ret	 0
$LN52@CGChaosBox:

; 10876: 			break;
; 10877: 		case CHAOS_TYPE_FENRIR_02:
; 10878: 			g_ChaosBox.Fenrir_02Level_Mix(lpObj);

  00494	56		 push	 esi
  00495	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0049a	e8 00 00 00 00	 call	 ?Fenrir_02Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::Fenrir_02Level_Mix
  0049f	5e		 pop	 esi
  004a0	5f		 pop	 edi
  004a1	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  004a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a5	33 cd		 xor	 ecx, ebp
  004a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ac	8b e5		 mov	 esp, ebp
  004ae	5d		 pop	 ebp
  004af	c3		 ret	 0
$LN53@CGChaosBox:

; 10879: 			break;
; 10880: 		case CHAOS_TYPE_FENRIR_03:
; 10881: 			g_ChaosBox.Fenrir_03Level_Mix(lpObj);

  004b0	56		 push	 esi
  004b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  004b6	e8 00 00 00 00	 call	 ?Fenrir_03Level_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::Fenrir_03Level_Mix
  004bb	5e		 pop	 esi
  004bc	5f		 pop	 edi
  004bd	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  004be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004c1	33 cd		 xor	 ecx, ebp
  004c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c8	8b e5		 mov	 esp, ebp
  004ca	5d		 pop	 ebp
  004cb	c3		 ret	 0
$LN54@CGChaosBox:

; 10882: 			break;
; 10883: 		case CHAOS_TYPE_FENRIR_04:
; 10884: 			g_ChaosBox.Fenrir_04Upgrade_Mix(lpObj);

  004cc	56		 push	 esi
  004cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  004d2	e8 00 00 00 00	 call	 ?Fenrir_04Upgrade_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::Fenrir_04Upgrade_Mix
  004d7	5e		 pop	 esi
  004d8	5f		 pop	 edi
  004d9	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  004da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004dd	33 cd		 xor	 ecx, ebp
  004df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004e4	8b e5		 mov	 esp, ebp
  004e6	5d		 pop	 ebp
  004e7	c3		 ret	 0
$LN55@CGChaosBox:

; 10885: 			break;
; 10886: 		case CHAOS_TYPE_COMPOUNDPOTION_LV1:
; 10887: 			g_ChaosBox.ShieldPotionLv1_Mix(lpObj);

  004e8	56		 push	 esi
  004e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  004ee	e8 00 00 00 00	 call	 ?ShieldPotionLv1_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::ShieldPotionLv1_Mix
  004f3	5e		 pop	 esi
  004f4	5f		 pop	 edi
  004f5	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  004f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004f9	33 cd		 xor	 ecx, ebp
  004fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00500	8b e5		 mov	 esp, ebp
  00502	5d		 pop	 ebp
  00503	c3		 ret	 0
$LN56@CGChaosBox:

; 10888: 			break;
; 10889: 		case CHAOS_TYPE_COMPOUNTPOTION_LV2:
; 10890: 			g_ChaosBox.ShieldPotionLv2_Mix(lpObj);

  00504	56		 push	 esi
  00505	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0050a	e8 00 00 00 00	 call	 ?ShieldPotionLv2_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::ShieldPotionLv2_Mix
  0050f	5e		 pop	 esi
  00510	5f		 pop	 edi
  00511	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00512	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00515	33 cd		 xor	 ecx, ebp
  00517	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0051c	8b e5		 mov	 esp, ebp
  0051e	5d		 pop	 ebp
  0051f	c3		 ret	 0
$LN57@CGChaosBox:

; 10891: 			break;
; 10892: 		case CHAOS_TYPE_COMPOUNTPOTION_LV3:
; 10893: 			g_ChaosBox.ShieldPotionLv3_Mix(lpObj);

  00520	56		 push	 esi
  00521	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00526	e8 00 00 00 00	 call	 ?ShieldPotionLv3_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::ShieldPotionLv3_Mix
  0052b	5e		 pop	 esi
  0052c	5f		 pop	 edi
  0052d	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0052e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00531	33 cd		 xor	 ecx, ebp
  00533	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00538	8b e5		 mov	 esp, ebp
  0053a	5d		 pop	 ebp
  0053b	c3		 ret	 0
$LN58@CGChaosBox:

; 10894: 			break;
; 10895: 		case CHAOS_TYPE_JEWELOFHARMONY_PURITY:
; 10896: 			g_kJewelOfHarmonySystem.PurityJewelOfHarmony(lpObj);

  0053c	56		 push	 esi
  0053d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00542	e8 00 00 00 00	 call	 ?PurityJewelOfHarmony@CJewelOfHarmonySystem@@QAEXPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::PurityJewelOfHarmony
  00547	5e		 pop	 esi
  00548	5f		 pop	 edi
  00549	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0054a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0054d	33 cd		 xor	 ecx, ebp
  0054f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00554	8b e5		 mov	 esp, ebp
  00556	5d		 pop	 ebp
  00557	c3		 ret	 0
$LN59@CGChaosBox:

; 10897: 			break;
; 10898: 		case CHAOS_TYPE_JEWELOFHARMONY_MIX_SMELTINGITEM:
; 10899: 			g_kJewelOfHarmonySystem.MakeSmeltingStoneItem(lpObj);

  00558	56		 push	 esi
  00559	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0055e	e8 00 00 00 00	 call	 ?MakeSmeltingStoneItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::MakeSmeltingStoneItem
  00563	5e		 pop	 esi
  00564	5f		 pop	 edi
  00565	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00566	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00569	33 cd		 xor	 ecx, ebp
  0056b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00570	8b e5		 mov	 esp, ebp
  00572	5d		 pop	 ebp
  00573	c3		 ret	 0
$LN60@CGChaosBox:

; 10900: 			break;
; 10901: 		case CHAOS_TYPE_JEWELOFHARMONY_RESTORE_ITEM:
; 10902: 			g_kJewelOfHarmonySystem.RestoreStrengthenItem(lpObj);

  00574	56		 push	 esi
  00575	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0057a	e8 00 00 00 00	 call	 ?RestoreStrengthenItem@CJewelOfHarmonySystem@@QAEHPAUOBJECTSTRUCT@@@Z ; CJewelOfHarmonySystem::RestoreStrengthenItem
  0057f	5e		 pop	 esi
  00580	5f		 pop	 edi
  00581	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00582	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00585	33 cd		 xor	 ecx, ebp
  00587	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0058c	8b e5		 mov	 esp, ebp
  0058e	5d		 pop	 ebp
  0058f	c3		 ret	 0
$LN61@CGChaosBox:

; 10903: 			break;
; 10904: 		case CHAOS_TYPE_380_OPTIONITEM:
; 10905: 			g_kItemSystemFor380.ChaosMix380ItemOption(lpObj);

  00590	56		 push	 esi
  00591	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kItemSystemFor380@@3VCItemSystemFor380@@A ; g_kItemSystemFor380
  00596	e8 00 00 00 00	 call	 ?ChaosMix380ItemOption@CItemSystemFor380@@QAEHPAUOBJECTSTRUCT@@@Z ; CItemSystemFor380::ChaosMix380ItemOption
  0059b	5e		 pop	 esi
  0059c	5f		 pop	 edi
  0059d	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0059e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005a1	33 cd		 xor	 ecx, ebp
  005a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005a8	8b e5		 mov	 esp, ebp
  005aa	5d		 pop	 ebp
  005ab	c3		 ret	 0
$LN62@CGChaosBox:

; 10906: 			break;
; 10907: 		case CHAOS_TYPE_LOTTERY_MIX:
; 10908: 			g_ChaosBox.LotteryItemMix(lpObj);

  005ac	56		 push	 esi
  005ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  005b2	e8 00 00 00 00	 call	 ?LotteryItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::LotteryItemMix
  005b7	5e		 pop	 esi
  005b8	5f		 pop	 edi
  005b9	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  005ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005bd	33 cd		 xor	 ecx, ebp
  005bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005c4	8b e5		 mov	 esp, ebp
  005c6	5d		 pop	 ebp
  005c7	c3		 ret	 0
$LN63@CGChaosBox:

; 10909: 			break;
; 10910: 		case CHAOS_TYPE_ILLUSIONMIX:
; 10911: 			g_ChaosBox.IllusionTemple_Mix(lpObj);

  005c8	56		 push	 esi
  005c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  005ce	e8 00 00 00 00	 call	 ?IllusionTemple_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::IllusionTemple_Mix
  005d3	5e		 pop	 esi
  005d4	5f		 pop	 edi
  005d5	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  005d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005d9	33 cd		 xor	 ecx, ebp
  005db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e0	8b e5		 mov	 esp, ebp
  005e2	5d		 pop	 ebp
  005e3	c3		 ret	 0
$LN64@CGChaosBox:

; 10912: 			break;
; 10913: 		case CHAOS_TYPE_CONDOR_FEATHER:
; 10914: 			g_ChaosBox.CondorFeather_Mix(lpObj);

  005e4	56		 push	 esi
  005e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  005ea	e8 00 00 00 00	 call	 ?CondorFeather_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::CondorFeather_Mix
  005ef	5e		 pop	 esi
  005f0	5f		 pop	 edi
  005f1	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  005f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f5	33 cd		 xor	 ecx, ebp
  005f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005fc	8b e5		 mov	 esp, ebp
  005fe	5d		 pop	 ebp
  005ff	c3		 ret	 0
$LN65@CGChaosBox:

; 10915: 			break;
; 10916: 		case CHAOS_TYPE_3RDWING_MIX:
; 10917: 			g_ChaosBox.NewWingChaos_Mix(lpObj);

  00600	56		 push	 esi
  00601	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00606	e8 00 00 00 00	 call	 ?NewWingChaos_Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::NewWingChaos_Mix
  0060b	5e		 pop	 esi
  0060c	5f		 pop	 edi
  0060d	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0060e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00611	33 cd		 xor	 ecx, ebp
  00613	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00618	8b e5		 mov	 esp, ebp
  0061a	5d		 pop	 ebp
  0061b	c3		 ret	 0
$LN66@CGChaosBox:

; 10918: 			break;
; 10919: 		case CHAOS_TYPE_CHERRY_BLOSSOM:
; 10920: 			g_ChaosBox.CherryBlossomMix(lpObj);

  0061c	56		 push	 esi
  0061d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00622	e8 00 00 00 00	 call	 ?CherryBlossomMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::CherryBlossomMix
  00627	5e		 pop	 esi
  00628	5f		 pop	 edi
  00629	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0062a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0062d	33 cd		 xor	 ecx, ebp
  0062f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00634	8b e5		 mov	 esp, ebp
  00636	5d		 pop	 ebp
  00637	c3		 ret	 0
$LN67@CGChaosBox:

; 10921: 			break;
; 10922: 		case CHAOS_TYPE_SEEDEXTRACT:
; 10923: 			g_ChaosBox.SeedExtractMix(lpObj);

  00638	56		 push	 esi
  00639	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0063e	e8 00 00 00 00	 call	 ?SeedExtractMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::SeedExtractMix
  00643	5e		 pop	 esi
  00644	5f		 pop	 edi
  00645	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00646	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00649	33 cd		 xor	 ecx, ebp
  0064b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00650	8b e5		 mov	 esp, ebp
  00652	5d		 pop	 ebp
  00653	c3		 ret	 0
$LN68@CGChaosBox:

; 10924: 			break;
; 10925: 		case CHAOS_TYPE_SPHEREMIX:
; 10926: 			g_ChaosBox.SeedSphereCompositeMix(lpObj);

  00654	56		 push	 esi
  00655	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0065a	e8 00 00 00 00	 call	 ?SeedSphereCompositeMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::SeedSphereCompositeMix
  0065f	5e		 pop	 esi
  00660	5f		 pop	 edi
  00661	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00662	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00665	33 cd		 xor	 ecx, ebp
  00667	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0066c	8b e5		 mov	 esp, ebp
  0066e	5d		 pop	 ebp
  0066f	c3		 ret	 0
$LN69@CGChaosBox:

; 10927: 			break;
; 10928: 		case CHAOS_TYPE_SPHEREMOUNT:
; 10929: 			g_ChaosBox.SetSeedSphereMix(lpObj,aRecv->Pos);

  00670	8b 45 dc	 mov	 eax, DWORD PTR _aRecv$GSCopy$1$[ebp]
  00673	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00678	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0067c	50		 push	 eax
  0067d	56		 push	 esi
  0067e	e8 00 00 00 00	 call	 ?SetSeedSphereMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@E@Z ; CChaosBox::SetSeedSphereMix
  00683	5e		 pop	 esi
  00684	5f		 pop	 edi
  00685	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00686	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00689	33 cd		 xor	 ecx, ebp
  0068b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00690	8b e5		 mov	 esp, ebp
  00692	5d		 pop	 ebp
  00693	c3		 ret	 0
$LN70@CGChaosBox:

; 10930: 			break;
; 10931: 		case CHAOS_TYPE_SPHEREUNMOUNT:
; 10932: 			g_ChaosBox.RemoveSeedSphereMix(lpObj,aRecv->Pos);

  00694	8b 45 dc	 mov	 eax, DWORD PTR _aRecv$GSCopy$1$[ebp]
  00697	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0069c	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  006a0	50		 push	 eax
  006a1	56		 push	 esi
  006a2	e8 00 00 00 00	 call	 ?RemoveSeedSphereMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@E@Z ; CChaosBox::RemoveSeedSphereMix
  006a7	5e		 pop	 esi
  006a8	5f		 pop	 edi
  006a9	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  006aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006ad	33 cd		 xor	 ecx, ebp
  006af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006b4	8b e5		 mov	 esp, ebp
  006b6	5d		 pop	 ebp
  006b7	c3		 ret	 0
$LN71@CGChaosBox:

; 10933: 			break;
; 10934: 		case CHAOS_TYPE_DUNGEON_KEYITEM:
; 10935: 			g_ChaosBox.SecromiconMix(lpObj);

  006b8	56		 push	 esi
  006b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  006be	e8 00 00 00 00	 call	 ?SecromiconMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::SecromiconMix
  006c3	5e		 pop	 esi
  006c4	5f		 pop	 edi
  006c5	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  006c6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006c9	33 cd		 xor	 ecx, ebp
  006cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006d0	8b e5		 mov	 esp, ebp
  006d2	5d		 pop	 ebp
  006d3	c3		 ret	 0
$LN72@CGChaosBox:

; 10936: 			break;
; 10937: 		case CHAOS_TYPE_GOLD_AND_SILBER_BOX:
; 10938: 			g_ChaosBox.GoldenNSilverBoxMix(lpObj);

  006d4	56		 push	 esi
  006d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  006da	e8 00 00 00 00	 call	 ?GoldenNSilverBoxMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::GoldenNSilverBoxMix
  006df	5e		 pop	 esi
  006e0	5f		 pop	 edi
  006e1	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  006e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006e5	33 cd		 xor	 ecx, ebp
  006e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006ec	8b e5		 mov	 esp, ebp
  006ee	5d		 pop	 ebp
  006ef	c3		 ret	 0
$LN73@CGChaosBox:

; 10939: 			break;
; 10940: 		case CHAOS_TYPE_LUCKYSYSTEM1:
; 10941: 			g_ChaosBox.LuckySystemItemCreate(lpObj);

  006f0	56		 push	 esi
  006f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  006f6	e8 00 00 00 00	 call	 ?LuckySystemItemCreate@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::LuckySystemItemCreate
  006fb	5e		 pop	 esi
  006fc	5f		 pop	 edi
  006fd	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  006fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00701	33 cd		 xor	 ecx, ebp
  00703	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00708	8b e5		 mov	 esp, ebp
  0070a	5d		 pop	 ebp
  0070b	c3		 ret	 0
$LN74@CGChaosBox:

; 10942: 			break;
; 10943: 		case CHAOS_TYPE_LUCKYSYSTEM2:
; 10944: 			g_ChaosBox.LuckySystemJewelCreate(lpObj);

  0070c	56		 push	 esi
  0070d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00712	e8 00 00 00 00	 call	 ?LuckySystemJewelCreate@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::LuckySystemJewelCreate
  00717	5e		 pop	 esi
  00718	5f		 pop	 edi
  00719	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0071a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0071d	33 cd		 xor	 ecx, ebp
  0071f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00724	8b e5		 mov	 esp, ebp
  00726	5d		 pop	 ebp
  00727	c3		 ret	 0
$LN75@CGChaosBox:

; 10945: 			break;
; 10946: 		case CHAOS_TYPE_SNAKEBEGINS:
; 10947: 			g_SnakeBegins.Mix(lpObj);

  00728	56		 push	 esi
  00729	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SnakeBegins@@3VSnakeBegins@@A ; g_SnakeBegins
  0072e	e8 00 00 00 00	 call	 ?Mix@SnakeBegins@@QAEXPAUOBJECTSTRUCT@@@Z ; SnakeBegins::Mix
  00733	5e		 pop	 esi
  00734	5f		 pop	 edi
  00735	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00736	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00739	33 cd		 xor	 ecx, ebp
  0073b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00740	8b e5		 mov	 esp, ebp
  00742	5d		 pop	 ebp
  00743	c3		 ret	 0
$LN76@CGChaosBox:

; 10948: 			break;
; 10949: #if (ENABLETEST_ARCA == 1)
; 10950: 		case CHAOS_TYPE_ARCA_BOOTY:
; 10951: 			g_ArcaBattle.BootyExchange(lpObj);
; 10952: 			break;
; 10953: 		case CHAOS_TYPE_ARCA_REGMARK:
; 10954: 			//CGReqMarkRegButtonClick(lpObj);
; 10955: 			break;
; 10956: #endif
; 10957: 		case CHAOS_TYPE_25WINGMIX:
; 10958: 			g_ChaosBox.Wing25Mix(lpObj);

  00744	56		 push	 esi
  00745	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  0074a	e8 00 00 00 00	 call	 ?Wing25Mix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@@Z ; CChaosBox::Wing25Mix
  0074f	5e		 pop	 esi
  00750	5f		 pop	 edi
  00751	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00752	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00755	33 cd		 xor	 ecx, ebp
  00757	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0075c	8b e5		 mov	 esp, ebp
  0075e	5d		 pop	 ebp
  0075f	c3		 ret	 0
$LN77@CGChaosBox:

; 10959: 			break;
; 10960: 		case CHAOS_TYPE_SOCKETMIX1:
; 10961: 			g_ChaosBox.SocketItemMix(lpObj,iMixType);

  00760	53		 push	 ebx
  00761	56		 push	 esi
  00762	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosBox@@3VCChaosBox@@A ; g_ChaosBox
  00767	e8 00 00 00 00	 call	 ?SocketItemMix@CChaosBox@@QAEXPAUOBJECTSTRUCT@@H@Z ; CChaosBox::SocketItemMix
  0076c	5e		 pop	 esi
  0076d	5f		 pop	 edi
  0076e	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  0076f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00772	33 cd		 xor	 ecx, ebp
  00774	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00779	8b e5		 mov	 esp, ebp
  0077b	5d		 pop	 ebp
  0077c	c3		 ret	 0
$LN78@CGChaosBox:

; 10962: 			break;
; 10963: 
; 10964: #if (CUSTOM_WINGS == 1)
; 10965: 		case CHAOS_TYPE_4THWINGS:
; 10966: 			g_ChaosBox.Create4thWings(lpObj);
; 10967: 			break;
; 10968: #endif
; 10969: #ifdef __NOVUS__
; 10970: 		case CHAOS_TYPE_RAREITEM:
; 10971: 			g_ChaosBox.RareItem(lpObj);
; 10972: 			break;
; 10973: #endif
; 10974: 		default:
; 10975: 			LogAddTD("[%s][%s] Undefine chaosmix type detect %d",

  0077d	53		 push	 ebx
  0077e	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00781	50		 push	 eax
  00782	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00785	50		 push	 eax
  00786	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PKJFNKMA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Undefine?5chaosmix?5type?5@
  0078b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00791	83 c4 10	 add	 esp, 16			; 00000010H
  00794	5e		 pop	 esi
  00795	5f		 pop	 edi
  00796	5b		 pop	 ebx

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  00797	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0079a	33 cd		 xor	 ecx, ebp
  0079c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007a1	8b e5		 mov	 esp, ebp
  007a3	5d		 pop	 ebp
  007a4	c3		 ret	 0
$LN29@CGChaosBox:

; 10777: 		{
; 10778: 
; 10779: 		}
; 10780: 		else
; 10781: 		{
; 10782: 			pMsg.Result = FALSE;
; 10783: 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  007a5	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  007a9	50		 push	 eax
  007aa	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  007ad	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
  007b1	50		 push	 eax
  007b2	ff 75 e4	 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  007b5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10976: 				lpObj->AccountID, lpObj->Name, iMixType);
; 10977: 			break;
; 10978: 	}
; 10979: }

  007ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  007c0	33 cd		 xor	 ecx, ebp
  007c2	5e		 pop	 esi
  007c3	5f		 pop	 edi
  007c4	5b		 pop	 ebx
  007c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007ca	8b e5		 mov	 esp, ebp
  007cc	5d		 pop	 ebp
  007cd	c3		 ret	 0
  007ce	66 90		 npad	 2
$LN96@CGChaosBox:
  007d0	00 00 00 00	 DD	 $LN43@CGChaosBox
  007d4	00 00 00 00	 DD	 $LN32@CGChaosBox
  007d8	00 00 00 00	 DD	 $LN33@CGChaosBox
  007dc	00 00 00 00	 DD	 $LN34@CGChaosBox
  007e0	00 00 00 00	 DD	 $LN39@CGChaosBox
  007e4	00 00 00 00	 DD	 $LN40@CGChaosBox
  007e8	00 00 00 00	 DD	 $LN41@CGChaosBox
  007ec	00 00 00 00	 DD	 $LN42@CGChaosBox
  007f0	00 00 00 00	 DD	 $LN78@CGChaosBox
  007f4	00 00 00 00	 DD	 $LN78@CGChaosBox
  007f8	00 00 00 00	 DD	 $LN43@CGChaosBox
  007fc	00 00 00 00	 DD	 $LN78@CGChaosBox
  00800	00 00 00 00	 DD	 $LN44@CGChaosBox
  00804	00 00 00 00	 DD	 $LN45@CGChaosBox
  00808	00 00 00 00	 DD	 $LN46@CGChaosBox
  0080c	00 00 00 00	 DD	 $LN47@CGChaosBox
  00810	00 00 00 00	 DD	 $LN48@CGChaosBox
  00814	00 00 00 00	 DD	 $LN49@CGChaosBox
  00818	00 00 00 00	 DD	 $LN78@CGChaosBox
  0081c	00 00 00 00	 DD	 $LN50@CGChaosBox
  00820	00 00 00 00	 DD	 $LN78@CGChaosBox
  00824	00 00 00 00	 DD	 $LN35@CGChaosBox
  00828	00 00 00 00	 DD	 $LN36@CGChaosBox
  0082c	00 00 00 00	 DD	 $LN41@CGChaosBox
  00830	00 00 00 00	 DD	 $LN51@CGChaosBox
  00834	00 00 00 00	 DD	 $LN52@CGChaosBox
  00838	00 00 00 00	 DD	 $LN53@CGChaosBox
  0083c	00 00 00 00	 DD	 $LN54@CGChaosBox
  00840	00 00 00 00	 DD	 $LN78@CGChaosBox
  00844	00 00 00 00	 DD	 $LN55@CGChaosBox
  00848	00 00 00 00	 DD	 $LN56@CGChaosBox
  0084c	00 00 00 00	 DD	 $LN57@CGChaosBox
  00850	00 00 00 00	 DD	 $LN58@CGChaosBox
  00854	00 00 00 00	 DD	 $LN59@CGChaosBox
  00858	00 00 00 00	 DD	 $LN60@CGChaosBox
  0085c	00 00 00 00	 DD	 $LN61@CGChaosBox
  00860	00 00 00 00	 DD	 $LN63@CGChaosBox
  00864	00 00 00 00	 DD	 $LN64@CGChaosBox
  00868	00 00 00 00	 DD	 $LN65@CGChaosBox
  0086c	00 00 00 00	 DD	 $LN62@CGChaosBox
  00870	00 00 00 00	 DD	 $LN66@CGChaosBox
  00874	00 00 00 00	 DD	 $LN67@CGChaosBox
  00878	00 00 00 00	 DD	 $LN68@CGChaosBox
  0087c	00 00 00 00	 DD	 $LN69@CGChaosBox
  00880	00 00 00 00	 DD	 $LN70@CGChaosBox
  00884	00 00 00 00	 DD	 $LN71@CGChaosBox
  00888	00 00 00 00	 DD	 $LN72@CGChaosBox
  0088c	00 00 00 00	 DD	 $LN75@CGChaosBox
  00890	00 00 00 00	 DD	 $LN37@CGChaosBox
  00894	00 00 00 00	 DD	 $LN38@CGChaosBox
  00898	00 00 00 00	 DD	 $LN73@CGChaosBox
  0089c	00 00 00 00	 DD	 $LN74@CGChaosBox
  008a0	00 00 00 00	 DD	 $LN78@CGChaosBox
  008a4	00 00 00 00	 DD	 $LN78@CGChaosBox
  008a8	00 00 00 00	 DD	 $LN78@CGChaosBox
  008ac	00 00 00 00	 DD	 $LN76@CGChaosBox
  008b0	00 00 00 00	 DD	 $LN77@CGChaosBox
?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ENDP ; CGChaosBoxItemMixButtonClick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$GSCopy$1$ = -2072				; size = 4
_n$1$ = -2068						; size = 4
_pMsg$ = -2064						; size = 6
_lOfs$1$ = -2056					; size = 4
_SendByte$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iChaosBoxType$ = 12					; size = 4
?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; GCUserChaosBoxSend, COMDAT

; 10614: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 08 00
	00		 sub	 esp, 2072		; 00000818H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00018	57		 push	 edi

; 10615: 	if ( iChaosBoxType == 1  )

  00019	8b 7d 0c	 mov	 edi, DWORD PTR _iChaosBoxType$[ebp]
  0001c	89 b5 e8 f7 ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$1$[ebp], esi

; 10616: 	{
; 10617: 		if ( lpObj->m_IfState.type != 13 )

  00022	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  00028	8b c1		 mov	 eax, ecx
  0002a	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0002f	83 ff 01	 cmp	 edi, 1
  00032	75 07		 jne	 SHORT $LN5@GCUserChao
  00034	3d 40 03 00 00	 cmp	 eax, 832		; 00000340H

; 10618: 		{
; 10619: 			return;
; 10620: 		}
; 10621: 
; 10622: 		if ( lpObj->m_IfState.type == 13 && lpObj->m_IfState.state == 1 )
; 10623: 		{
; 10624: 			return;
; 10625: 		}
; 10626: 	}
; 10627: 	else 

  00039	eb 05		 jmp	 SHORT $LN21@GCUserChao
$LN5@GCUserChao:

; 10628: 	{
; 10629: 		if ( lpObj->m_IfState.type != 7 )

  0003b	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
$LN21@GCUserChao:
  00040	0f 85 29 01 00
	00		 jne	 $LN1@GCUserChao

; 10630: 		{
; 10631: 			return;
; 10632: 		}
; 10633: 
; 10634: 		if ( lpObj->m_IfState.type == 7 && lpObj->m_IfState.state == 1 )

  00046	80 e1 3c	 and	 cl, 60			; 0000003cH
  00049	80 f9 04	 cmp	 cl, 4
  0004c	0f 84 1d 01 00
	00		 je	 $LN1@GCUserChao

; 10635: 		{
; 10636: 			return;
; 10637: 		}
; 10638: 	}
; 10639: 
; 10640: 	PMSG_SHOPITEMCOUNT pMsg;
; 10641: 	BYTE SendByte[2048];
; 10642: 	int lOfs = sizeof(pMsg);
; 10643: 	PHeadSetW((LPBYTE)&pMsg, 0x31, 0);

  00052	6a 00		 push	 0
  00054	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0005a	c7 85 f8 f7 ff
	ff 06 00 00 00	 mov	 DWORD PTR _lOfs$1$[ebp], 6
  00064	6a 31		 push	 49			; 00000031H
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10644: 	pMsg.count = 0;

  0006f	c6 85 f5 f7 ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+5], 0

; 10645: 
; 10646: 	if ( iChaosBoxType == 1 )

  00076	83 ff 01	 cmp	 edi, 1

; 10647: 	{
; 10648: 		pMsg.Type = 5;
; 10649: 	}
; 10650: 	else
; 10651: 	{
; 10652: 		pMsg.Type = 3;
; 10653: 	}
; 10654: 
; 10655: 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  00079	c7 85 ec f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  00083	0f 94 c0	 sete	 al
  00086	33 db		 xor	 ebx, ebx
  00088	8d 04 45 03 00
	00 00		 lea	 eax, DWORD PTR [eax*2+3]
  0008f	88 85 f4 f7 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], al
  00095	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@GCUserChao:

; 10656: 	{
; 10657: 		if ( lpObj->pChaosBox[n].IsItem() == TRUE )

  000a0	8b 8e 10 12 00
	00		 mov	 ecx, DWORD PTR [esi+4624]
  000a6	03 cb		 add	 ecx, ebx
  000a8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 62		 jne	 SHORT $LN19@GCUserChao

; 10658: 		{
; 10659: 			SendByte[lOfs] = n;

  000b2	8b 85 f8 f7 ff
	ff		 mov	 eax, DWORD PTR _lOfs$1$[ebp]

; 10660: 			lOfs++;
; 10661: 			ItemByteConvert(&SendByte[lOfs], lpObj->pChaosBox[n] );

  000b8	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  000be	8b b6 10 12 00
	00		 mov	 esi, DWORD PTR [esi+4624]
  000c4	8b fc		 mov	 edi, esp
  000c6	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _n$1$[ebp]
  000cc	03 f3		 add	 esi, ebx
  000ce	88 8c 05 fc f7
	ff ff		 mov	 BYTE PTR _SendByte$[ebp+eax], cl
  000d5	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  000da	40		 inc	 eax
  000db	f3 a5		 rep movsd
  000dd	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  000e3	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], eax
  000e9	03 c1		 add	 eax, ecx
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 10662: 			lOfs += MAX_ITEM_INFO;

  000f1	8b 8d f8 f7 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
  000f7	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 10663: 			pMsg.count ++;

  000fd	8b b5 e8 f7 ff
	ff		 mov	 esi, DWORD PTR _lpObj$GSCopy$1$[ebp]
  00103	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00106	fe 85 f5 f7 ff
	ff		 inc	 BYTE PTR _pMsg$[ebp+5]
  0010c	89 8d f8 f7 ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
  00112	eb 06		 jmp	 SHORT $LN2@GCUserChao
$LN19@GCUserChao:
  00114	8b 8d f8 f7 ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
$LN2@GCUserChao:

; 10647: 	{
; 10648: 		pMsg.Type = 5;
; 10649: 	}
; 10650: 	else
; 10651: 	{
; 10652: 		pMsg.Type = 3;
; 10653: 	}
; 10654: 
; 10655: 	for ( int n=0;n<CHAOS_BOX_SIZE;n++)

  0011a	ff 85 ec f7 ff
	ff		 inc	 DWORD PTR _n$1$[ebp]
  00120	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  00126	81 fb 80 1a 00
	00		 cmp	 ebx, 6784		; 00001a80H
  0012c	0f 8c 6e ff ff
	ff		 jl	 $LL4@GCUserChao

; 10664: 		}
; 10665: 	}
; 10666: 
; 10667: 	pMsg.h.sizeH = SET_NUMBERH(lOfs);

  00132	8b c1		 mov	 eax, ecx

; 10668: 	pMsg.h.sizeL = SET_NUMBERL(lOfs);

  00134	88 8d f2 f7 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+2], cl
  0013a	c1 e8 08	 shr	 eax, 8
  0013d	88 85 f1 f7 ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+1], al

; 10669: 	memcpy(SendByte, &pMsg, sizeof(pMsg));

  00143	8b 85 f0 f7 ff
	ff		 mov	 eax, DWORD PTR _pMsg$[ebp]
  00149	89 85 fc f7 ff
	ff		 mov	 DWORD PTR _SendByte$[ebp], eax
  0014f	66 8b 85 f4 f7
	ff ff		 mov	 ax, WORD PTR _pMsg$[ebp+4]
  00156	66 89 85 00 f8
	ff ff		 mov	 WORD PTR _SendByte$[ebp+4], ax

; 10670: 
; 10671: 	DataSend(lpObj->m_Index, SendByte, lOfs);

  0015d	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _SendByte$[ebp]
  00163	51		 push	 ecx
  00164	50		 push	 eax
  00165	ff 36		 push	 DWORD PTR [esi]
  00167	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0016c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCUserChao:

; 10672: }

  0016f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	33 cd		 xor	 ecx, ebp
  00176	5b		 pop	 ebx
  00177	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	c3		 ret	 0
?GCUserChaosBoxSend@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; GCUserChaosBoxSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z
_TEXT	SEGMENT
_szJoomin$1 = -28					; size = 21
_szJoomin$2 = -28					; size = 21
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z PROC ; GCWarehouseRecivePassword, COMDAT

; 10536: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 10537: 	if ( bCanWarehouseLock == FALSE )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 0 ; bCanWarehouseLock
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001e	0f 84 e6 00 00
	00		 je	 $LN8@GCWarehous

; 10538: 		return;
; 10539: 
; 10540: 	int pw = lpMsg->Pass;
; 10541: 
; 10542: 	switch ( lpMsg->Type )

  00024	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00028	53		 push	 ebx
  00029	0f bf 59 04	 movsx	 ebx, WORD PTR [ecx+4]
  0002d	83 e8 00	 sub	 eax, 0
  00030	0f 84 40 01 00
	00		 je	 $LN5@GCWarehous
  00036	83 e8 01	 sub	 eax, 1
  00039	0f 84 a2 00 00
	00		 je	 $LN9@GCWarehous
  0003f	83 e8 01	 sub	 eax, 1
  00042	0f 85 c1 00 00
	00		 jne	 $LN18@GCWarehous

; 10585: 		case 0x02:
; 10586: 			{
; 10587: 				char szJoomin[21];
; 10588: 
; 10589: 				memset(szJoomin, 0, sizeof(szJoomin));
; 10590: 				memcpy(szJoomin, lpMsg->LastJoominNumber, 20);
; 10591: 
; 10592: #if (__CUSTOM__ == 1)
; 10593: 				if ( gc_bPersonalID == TRUE && gObjJoominCheck(aIndex, szJoomin) == FALSE )

  00048	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gc_bPersonalID@@3HA, 1 ; gc_bPersonalID
  0004f	0f 57 c0	 xorps	 xmm0, xmm0
  00052	0f 11 45 e4	 movups	 XMMWORD PTR _szJoomin$1[ebp], xmm0
  00056	89 45 f4	 mov	 DWORD PTR _szJoomin$1[ebp+16], eax
  00059	0f 10 41 06	 movups	 xmm0, XMMWORD PTR [ecx+6]
  0005d	88 45 f8	 mov	 BYTE PTR _szJoomin$1[ebp+20], al
  00060	8b 41 16	 mov	 eax, DWORD PTR [ecx+22]
  00063	0f 11 45 e4	 movups	 XMMWORD PTR _szJoomin$1[ebp], xmm0
  00067	89 45 f4	 mov	 DWORD PTR _szJoomin$1[ebp+16], eax
  0006a	75 2c		 jne	 SHORT $LN15@GCWarehous
  0006c	8d 45 e4	 lea	 eax, DWORD PTR _szJoomin$1[ebp]
  0006f	50		 push	 eax
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  00076	83 c4 08	 add	 esp, 8
  00079	85 c0		 test	 eax, eax
  0007b	75 1b		 jne	 SHORT $LN15@GCWarehous

; 10594: #else
; 10595: 				if ( gObjJoominCheck(aIndex, szJoomin) == FALSE )
; 10596: #endif
; 10597: 				{
; 10598: 					GCWarehouseStateSend(aIndex, 0x0D);

  0007d	6a 0d		 push	 13			; 0000000dH
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  00085	83 c4 08	 add	 esp, 8
  00088	5b		 pop	 ebx
  00089	5e		 pop	 esi

; 10605: 			}
; 10606: 			break;
; 10607: 	}
; 10608: }	

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	33 cd		 xor	 ecx, ebp
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
$LN15@GCWarehous:

; 10599: 					return;
; 10600: 				}
; 10601: 
; 10602: 				gObj[aIndex].WarehouseLock = FALSE;

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 10603: 				gObj[aIndex].WarehousePW = 0;

  0009d	33 d2		 xor	 edx, edx
  0009f	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  000a5	c6 84 01 04 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4612], 0
  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b2	66 89 94 01 02
	12 00 00	 mov	 WORD PTR [ecx+eax+4610], dx

; 10604: 				GCWarehouseStateSend(aIndex, gObj[aIndex].WarehouseLock);

  000ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bf	0f b6 84 01 04
	12 00 00	 movzx	 eax, BYTE PTR [ecx+eax+4612]
  000c7	50		 push	 eax
  000c8	56		 push	 esi
  000c9	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  000ce	83 c4 08	 add	 esp, 8
  000d1	5b		 pop	 ebx
  000d2	5e		 pop	 esi

; 10605: 			}
; 10606: 			break;
; 10607: 	}
; 10608: }	

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 cd		 xor	 ecx, ebp
  000d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
$LN9@GCWarehous:

; 10555: 				}
; 10556: 			}
; 10557: 			break;
; 10558: 		case 0x01:
; 10559: 			if ( !gObj[aIndex].WarehouseLock || gObj[aIndex].WarehouseLock == 0xFF )

  000e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e7	57		 push	 edi
  000e8	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  000ee	8a 84 17 04 12
	00 00		 mov	 al, BYTE PTR [edi+edx+4612]
  000f5	84 c0		 test	 al, al
  000f7	74 20		 je	 SHORT $LN12@GCWarehous
  000f9	3c ff		 cmp	 al, 255			; 000000ffH
  000fb	74 1c		 je	 SHORT $LN12@GCWarehous

; 10579: 			}
; 10580: 			else
; 10581: 			{
; 10582: 				GCWarehouseStateSend(aIndex, 0x0B);

  000fd	6a 0b		 push	 11			; 0000000bH
$LN20@GCWarehous:

; 10568: #else
; 10569: 				if ( gObjJoominCheck(aIndex, szJoomin) == FALSE )
; 10570: #endif
; 10571: 				{
; 10572: 					GCWarehouseStateSend(aIndex, 0x0D);

  000ff	56		 push	 esi
  00100	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  00105	83 c4 08	 add	 esp, 8
  00108	5f		 pop	 edi
$LN18@GCWarehous:
  00109	5b		 pop	 ebx
$LN8@GCWarehous:
  0010a	5e		 pop	 esi

; 10605: 			}
; 10606: 			break;
; 10607: 	}
; 10608: }	

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c3		 ret	 0
$LN12@GCWarehous:

; 10560: 			{
; 10561: 				char szJoomin[21];
; 10562: 
; 10563: 				memset(szJoomin, 0, sizeof(szJoomin));
; 10564: 				memcpy(szJoomin, lpMsg->LastJoominNumber, 20);
; 10565: 
; 10566: #if (__CUSTOM__ == 1)
; 10567: 				if ( gc_bPersonalID == TRUE && gObjJoominCheck(aIndex, szJoomin) == FALSE )

  00119	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gc_bPersonalID@@3HA, 1 ; gc_bPersonalID
  00120	0f 57 c0	 xorps	 xmm0, xmm0
  00123	8b 41 16	 mov	 eax, DWORD PTR [ecx+22]
  00126	0f 11 45 e4	 movups	 XMMWORD PTR _szJoomin$2[ebp], xmm0
  0012a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _szJoomin$2[ebp+16], 0
  00131	0f 10 41 06	 movups	 xmm0, XMMWORD PTR [ecx+6]
  00135	c6 45 f8 00	 mov	 BYTE PTR _szJoomin$2[ebp+20], 0
  00139	89 45 f4	 mov	 DWORD PTR _szJoomin$2[ebp+16], eax
  0013c	0f 11 45 e4	 movups	 XMMWORD PTR _szJoomin$2[ebp], xmm0
  00140	75 1b		 jne	 SHORT $LN13@GCWarehous
  00142	8d 45 e4	 lea	 eax, DWORD PTR _szJoomin$2[ebp]
  00145	50		 push	 eax
  00146	56		 push	 esi
  00147	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  0014c	83 c4 08	 add	 esp, 8
  0014f	85 c0		 test	 eax, eax
  00151	75 04		 jne	 SHORT $LN17@GCWarehous

; 10568: #else
; 10569: 				if ( gObjJoominCheck(aIndex, szJoomin) == FALSE )
; 10570: #endif
; 10571: 				{
; 10572: 					GCWarehouseStateSend(aIndex, 0x0D);

  00153	6a 0d		 push	 13			; 0000000dH

; 10573: 					return;

  00155	eb a8		 jmp	 SHORT $LN20@GCWarehous
$LN17@GCWarehous:
  00157	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN13@GCWarehous:

; 10574: 				}
; 10575: 
; 10576: 				gObj[aIndex].WarehousePW = pw;

  0015d	66 89 9c 17 02
	12 00 00	 mov	 WORD PTR [edi+edx+4610], bx

; 10577: 				gObj[aIndex].WarehouseLock = FALSE;

  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 10578: 				GCWarehouseStateSend(aIndex, 0x0C);

  0016a	6a 0c		 push	 12			; 0000000cH
  0016c	c6 84 07 04 12
	00 00 00	 mov	 BYTE PTR [edi+eax+4612], 0

; 10583: 			}
; 10584: 			break;

  00174	eb 89		 jmp	 SHORT $LN20@GCWarehous
$LN5@GCWarehous:

; 10543: 	{
; 10544: 		case 0x00:
; 10545: 			if ( gObj[aIndex].WarehouseLock )

  00176	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0017c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00182	80 b9 04 12 00
	00 00		 cmp	 BYTE PTR [ecx+4612], 0
  00189	0f 84 7a ff ff
	ff		 je	 $LN18@GCWarehous

; 10546: 			{
; 10547: 				if ( gObj[aIndex].WarehousePW == pw )

  0018f	0f bf 81 02 12
	00 00		 movsx	 eax, WORD PTR [ecx+4610]
  00196	3b c3		 cmp	 eax, ebx
  00198	75 22		 jne	 SHORT $LN7@GCWarehous

; 10548: 				{
; 10549: 					gObj[aIndex].WarehouseLock = FALSE;
; 10550: 					GCWarehouseStateSend(aIndex, 0x0C);

  0019a	6a 0c		 push	 12			; 0000000cH
  0019c	56		 push	 esi
  0019d	c6 81 04 12 00
	00 00		 mov	 BYTE PTR [ecx+4612], 0
  001a4	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend
  001a9	83 c4 08	 add	 esp, 8
  001ac	5b		 pop	 ebx
  001ad	5e		 pop	 esi

; 10605: 			}
; 10606: 			break;
; 10607: 	}
; 10608: }	

  001ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b1	33 cd		 xor	 ecx, ebp
  001b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
$LN7@GCWarehous:

; 10551: 				}
; 10552: 				else
; 10553: 				{
; 10554: 					GCWarehouseStateSend(aIndex, 0x0A);

  001bc	6a 0a		 push	 10			; 0000000aH
  001be	56		 push	 esi
  001bf	e8 00 00 00 00	 call	 ?GCWarehouseStateSend@@YAXHE@Z ; GCWarehouseStateSend

; 10605: 			}
; 10606: 			break;
; 10607: 	}
; 10608: }	

  001c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c7	83 c4 08	 add	 esp, 8
  001ca	33 cd		 xor	 ecx, ebp
  001cc	5b		 pop	 ebx
  001cd	5e		 pop	 esi
  001ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d3	8b e5		 mov	 esp, ebp
  001d5	5d		 pop	 ebp
  001d6	c3		 ret	 0
?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ENDP ; GCWarehouseRecivePassword
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCWarehouseStateSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_state$ = 12						; size = 1
?GCWarehouseStateSend@@YAXHE@Z PROC			; GCWarehouseStateSend, COMDAT

; 10523: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 10524: 	PMSG_WAREHOUSESTATE pMsg;
; 10525: 
; 10526: 	PHeadSetB((LPBYTE)&pMsg, 0x83, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	68 83 00 00 00	 push	 131			; 00000083H
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10527: 	pMsg.State = state;

  00014	8a 45 0c	 mov	 al, BYTE PTR _state$[ebp]
  00017	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 10528: 
; 10529: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0001a	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001e	50		 push	 eax
  0001f	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00022	50		 push	 eax
  00023	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00026	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002b	83 c4 18	 add	 esp, 24			; 00000018H

; 10530: }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?GCWarehouseStateSend@@YAXHE@Z ENDP			; GCWarehouseStateSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGWarehouseUseEnd@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?CGWarehouseUseEnd@@YAXH@Z PROC				; CGWarehouseUseEnd, COMDAT

; 10486: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 10487: 	if ( !gObjIsConnectedGP(aIndex))

  00005	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	75 1f		 jne	 SHORT $LN2@CGWarehous

; 10488: 	{
; 10489: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00015	68 f9 28 00 00	 push	 10489			; 000028f9H
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00024	6a 02		 push	 2
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	5f		 pop	 edi

; 10508: 	}
; 10509: }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN2@CGWarehous:
  00034	56		 push	 esi

; 10490: 		return;
; 10491: 	}
; 10492: 
; 10493: 	LPOBJ lpObj = &gObj[aIndex];

  00035	69 f7 40 27 00
	00		 imul	 esi, edi, 10048

; 10494: 
; 10495: 	PMSG_DEFAULT pMsg;
; 10496: 	PHeadSetB((LPBYTE)&pMsg, 0x82, sizeof(pMsg));

  0003b	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003e	6a 03		 push	 3
  00040	68 82 00 00 00	 push	 130			; 00000082H
  00045	50		 push	 eax
  00046	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10497: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00051	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00055	50		 push	 eax
  00056	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00059	50		 push	 eax
  0005a	57		 push	 edi
  0005b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10498: 
; 10499: 	gObjItemTextSave(lpObj);

  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjItemTextSave

; 10500: 	GDSetWarehouseList(aIndex);

  00066	57		 push	 edi
  00067	e8 00 00 00 00	 call	 ?GDSetWarehouseList@@YAXH@Z ; GDSetWarehouseList

; 10501: 	GDUserItemSave(lpObj);

  0006c	56		 push	 esi
  0006d	e8 00 00 00 00	 call	 ?GDUserItemSave@@YAXPAUOBJECTSTRUCT@@@Z ; GDUserItemSave

; 10502: 
; 10503: 	if ( lpObj->m_IfState.use  && lpObj->m_IfState.type == 6 )

  00072	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  00078	83 c4 24	 add	 esp, 36			; 00000024H
  0007b	f6 c1 03	 test	 cl, 3
  0007e	74 21		 je	 SHORT $LN5@CGWarehous
  00080	8b c1		 mov	 eax, ecx
  00082	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00087	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  0008c	75 13		 jne	 SHORT $LN5@CGWarehous

; 10504: 	{
; 10505: 		lpObj->m_IfState.use = 0;
; 10506: 		lpObj->m_IfState.state = 0;

  0008e	83 e1 c0	 and	 ecx, -64		; ffffffc0H

; 10507: 		lpObj->WarehouseSave = FALSE;

  00091	c7 86 0c 12 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+4620], 0
  0009b	89 8e b8 11 00
	00		 mov	 DWORD PTR [esi+4536], ecx
$LN5@CGWarehous:
  000a1	5e		 pop	 esi
  000a2	5f		 pop	 edi

; 10508: 	}
; 10509: }

  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?CGWarehouseUseEnd@@YAXH@Z ENDP				; CGWarehouseUseEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_money$ = 16						; size = 4
_wmoney$ = 20						; size = 4
?GCWarehouseInventoryMoneySend@@YAXHEHH@Z PROC		; GCWarehouseInventoryMoneySend, COMDAT

; 10471: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 10472: 	PMSG_MONEY pMsg;
; 10473: 
; 10474: 	PHeadSetB((LPBYTE)&pMsg, 0x81, sizeof(pMsg));

  00010	6a 0c		 push	 12			; 0000000cH
  00012	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	68 81 00 00 00	 push	 129			; 00000081H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10475: 	pMsg.Result = result;

  00020	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00023	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 10476: 	pMsg.iMoney = money;

  00026	8b 45 10	 mov	 eax, DWORD PTR _money$[ebp]
  00029	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 10477: 	pMsg.wMoney = wmoney;

  0002c	8b 45 14	 mov	 eax, DWORD PTR _wmoney$[ebp]
  0002f	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 10478: 
; 10479: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00032	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00036	50		 push	 eax
  00037	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003a	50		 push	 eax
  0003b	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0003e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10480: }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	83 c4 18	 add	 esp, 24			; 00000018H
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ENDP		; GCWarehouseInventoryMoneySend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z
_TEXT	SEGMENT
_oldmoney$1$ = -268					; size = 4
tv401 = -264						; size = 4
_rZen$1$ = -264						; size = 4
_msg$1 = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z PROC ; CGWarehouseMoneyInOut, COMDAT

; 10337: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 10338: 	int money = 0;
; 10339: 
; 10340: 	if ( !gObjIsConnected(aIndex))

  00017	57		 push	 edi
  00018	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001d	83 c4 04	 add	 esp, 4
  00020	85 c0		 test	 eax, eax
  00022	75 35		 jne	 SHORT $LN4@CGWarehous

; 10341: 	{
; 10342: 		LogAddC(2, "error-L3 [%s][%d]", __FILE__, __LINE__);

  00024	68 66 28 00 00	 push	 10342			; 00002866H
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OFCHNMFP@error?9L3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$AA@
  00033	6a 02		 push	 2
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 10343: 		GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	57		 push	 edi
  00042	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00047	83 c4 20	 add	 esp, 32			; 00000020H
  0004a	5f		 pop	 edi

; 10457: }

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@CGWarehous:

; 10344: 		return;
; 10345: 	}
; 10346: 
; 10347: 	LPOBJ lpObj = &gObj[aIndex];
; 10348: 	money = lpMsg->Money;

  00059	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  0005c	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00062	53		 push	 ebx
  00063	56		 push	 esi
  00064	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006a	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  0006d	03 f1		 add	 esi, ecx
  0006f	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv401[ebp], ecx

; 10349: 	
; 10350: 	if ( lpObj->m_IfState.state == 0 )

  00075	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  0007b	f6 c1 3c	 test	 cl, 60			; 0000003cH
  0007e	0f 84 21 02 00
	00		 je	 $LN10@CGWarehous

; 10351: 	{
; 10352: 		GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 10353: 		return;
; 10354: 	}
; 10355: 
; 10356: 	if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 6 )

  00084	8b c1		 mov	 eax, ecx
  00086	24 03		 and	 al, 3
  00088	3c 01		 cmp	 al, 1
  0008a	0f 82 35 02 00
	00		 jb	 $LN7@CGWarehous
  00090	81 e1 c0 ff 00
	00		 and	 ecx, 65472		; 0000ffc0H
  00096	81 f9 80 01 00
	00		 cmp	 ecx, 384		; 00000180H
  0009c	0f 85 23 02 00
	00		 jne	 $LN7@CGWarehous

; 10360: 			gObj[aIndex].AccountID, gObj[aIndex].Name);
; 10361: 
; 10362: 		return;
; 10363: 	}
; 10364: 
; 10365: 	switch ( lpMsg->Type )

  000a2	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  000a6	83 e8 00	 sub	 eax, 0
  000a9	0f 84 96 01 00
	00		 je	 $LN8@CGWarehous
  000af	83 e8 01	 sub	 eax, 1
  000b2	0f 85 ed 01 00
	00		 jne	 $LN10@CGWarehous

; 10388: 			break;
; 10389: 		case 0x01:
; 10390: 			{
; 10391: 				if ( bCanWarehouseLock == TRUE)

  000b8	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 1 ; bCanWarehouseLock
  000bf	75 42		 jne	 SHORT $LN15@CGWarehous

; 10392: 				{
; 10393: 					if ( lpObj->WarehouseLock == 1)

  000c1	80 be 04 12 00
	00 01		 cmp	 BYTE PTR [esi+4612], 1
  000c8	75 39		 jne	 SHORT $LN15@CGWarehous

; 10394: 					{
; 10395: 						GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  000ca	50		 push	 eax
  000cb	50		 push	 eax
  000cc	50		 push	 eax
  000cd	57		 push	 edi
  000ce	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  000d3	83 c4 10	 add	 esp, 16			; 00000010H

; 10396: 						GCServerMsgStringSend(lMsg.Get(MSGGET(6, 70)), lpObj->m_Index,1);

  000d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000db	6a 01		 push	 1
  000dd	ff 36		 push	 DWORD PTR [esi]
  000df	68 46 06 00 00	 push	 1606			; 00000646H
  000e4	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000e9	50		 push	 eax
  000ea	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	5f		 pop	 edi

; 10457: }

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f8	33 cd		 xor	 ecx, ebp
  000fa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
$LN15@CGWarehous:

; 10397: 						return;
; 10398: 					}
; 10399: 				}
; 10400: 
; 10401: 				if ( money <= 0 || money > MAX_WAREHOUSE_ZEN )

  00103	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00106	3d ff 93 35 77	 cmp	 eax, 1999999999		; 773593ffH
  0010b	0f 87 94 01 00
	00		 ja	 $LN10@CGWarehous

; 10402: 				{
; 10403: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 10404: 					return;
; 10405: 				}
; 10406: 				
; 10407: 				if ( money > lpObj->WarehouseMoney )

  00111	8b 86 08 12 00
	00		 mov	 eax, DWORD PTR [esi+4616]
  00117	3b d8		 cmp	 ebx, eax
  00119	0f 8f 86 01 00
	00		 jg	 $LN10@CGWarehous

; 10408: 				{
; 10409: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 10410: 					return;
; 10411: 				}
; 10412: 
; 10413: 				lpObj->WarehouseMoney -= money;
; 10414: 				lpObj->Money += money;

  0011f	01 9e cc 00 00
	00		 add	 DWORD PTR [esi+204], ebx
  00125	2b c3		 sub	 eax, ebx
  00127	89 86 08 12 00
	00		 mov	 DWORD PTR [esi+4616], eax

; 10415: 				int rZen = GetWarehouseUsedHowMuch(lpObj->Level,lpObj->MasterLevel, lpObj->WarehousePW);

  0012d	0f bf 86 02 12
	00 00		 movsx	 eax, WORD PTR [esi+4610]
  00134	50		 push	 eax
  00135	0f bf 86 a8 00
	00 00		 movsx	 eax, WORD PTR [esi+168]
  0013c	50		 push	 eax
  0013d	0f bf 86 96 00
	00 00		 movsx	 eax, WORD PTR [esi+150]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHHH@Z ; GetWarehouseUsedHowMuch
  0014a	8b c8		 mov	 ecx, eax
  0014c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10416: 
; 10417: 				if ( (lpObj->Money-rZen) > 0 )

  0014f	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  00155	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _oldmoney$1$[ebp], eax
  0015b	2b c1		 sub	 eax, ecx
  0015d	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _rZen$1$[ebp], ecx
  00163	85 c0		 test	 eax, eax
  00165	7e 33		 jle	 SHORT $LN19@CGWarehous

; 10418: 				{
; 10419: 					int oldmoney = lpObj->Money;
; 10420: 					lpObj->Money -= rZen;
; 10421: 					GCMoneySend(lpObj->m_Index, lpObj->Money);

  00167	50		 push	 eax
  00168	ff 36		 push	 DWORD PTR [esi]
  0016a	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  00170	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 10422: 					
; 10423: 					LogAdd("Get WareHouse Money(In Inventory) : %d - %d = %d",

  00175	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  0017b	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _rZen$1$[ebp]
  00181	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _oldmoney$1$[ebp]
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@IPFMNKBF@Get?5WareHouse?5Money?$CIIn?5Inventory@
  0018c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00192	83 c4 18	 add	 esp, 24			; 00000018H
  00195	e9 dd 00 00 00	 jmp	 $LN2@CGWarehous
$LN19@CGWarehous:

; 10424: 						oldmoney, rZen, lpObj->Money);
; 10425: 				}
; 10426: 				else if ( (lpObj->WarehouseMoney-rZen) > 0 )

  0019a	8b 96 08 12 00
	00		 mov	 edx, DWORD PTR [esi+4616]
  001a0	8b c2		 mov	 eax, edx
  001a2	2b c1		 sub	 eax, ecx
  001a4	85 c0		 test	 eax, eax
  001a6	7e 30		 jle	 SHORT $LN21@CGWarehous

; 10427: 				{
; 10428: 					int oldmoney = lpObj->WarehouseMoney;
; 10429: 					lpObj->WarehouseMoney -= rZen;
; 10430: 
; 10431: 					LogAdd("Get WareHouse Money(In WareHouse) : %d - %d = %d",

  001a8	50		 push	 eax
  001a9	51		 push	 ecx
  001aa	52		 push	 edx
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HJKJHPEL@Get?5WareHouse?5Money?$CIIn?5WareHouse@
  001b0	89 86 08 12 00
	00		 mov	 DWORD PTR [esi+4616], eax
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 10432: 						oldmoney, rZen, lpObj->WarehouseMoney);
; 10433: 
; 10434: 					GCWarehouseInventoryMoneySend(aIndex, 1, lpObj->Money, lpObj->WarehouseMoney);

  001bc	ff b6 08 12 00
	00		 push	 DWORD PTR [esi+4616]
  001c2	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  001c8	6a 01		 push	 1
  001ca	57		 push	 edi
  001cb	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  001d0	83 c4 20	 add	 esp, 32			; 00000020H

; 10445: 					return;
; 10446: 				}
; 10447: 			}
; 10448: 			break;

  001d3	e9 9f 00 00 00	 jmp	 $LN2@CGWarehous
$LN21@CGWarehous:

; 10435: 				}
; 10436: 				else
; 10437: 				{
; 10438: 					lpObj->WarehouseMoney +=money;

  001d8	8d 04 1a	 lea	 eax, DWORD PTR [edx+ebx]

; 10439: 					lpObj->Money -= money;
; 10440: 					GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  001db	6a 00		 push	 0
  001dd	89 86 08 12 00
	00		 mov	 DWORD PTR [esi+4616], eax
  001e3	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _oldmoney$1$[ebp]
  001e9	6a 00		 push	 0
  001eb	2b c3		 sub	 eax, ebx
  001ed	6a 00		 push	 0
  001ef	57		 push	 edi
  001f0	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  001f6	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  001fb	83 c4 10	 add	 esp, 16			; 00000010H

; 10441: 					char msg[255];
; 10442: 
; 10443: 					wsprintf(msg, lMsg.Get(MSGGET(6, 69)), rZen);

  001fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00203	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _rZen$1$[ebp]
  00209	68 45 06 00 00	 push	 1605			; 00000645H
  0020e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00213	50		 push	 eax
  00214	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$1[ebp]
  0021a	50		 push	 eax
  0021b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 10444: 					GCServerMsgStringSend(msg, lpObj->m_Index, 1);

  00221	6a 01		 push	 1
  00223	ff 36		 push	 DWORD PTR [esi]
  00225	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _msg$1[ebp]
  0022b	50		 push	 eax
  0022c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00231	83 c4 18	 add	 esp, 24			; 00000018H
  00234	5e		 pop	 esi
  00235	5b		 pop	 ebx
  00236	5f		 pop	 edi

; 10457: }

  00237	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023a	33 cd		 xor	 ecx, ebp
  0023c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00241	8b e5		 mov	 esp, ebp
  00243	5d		 pop	 ebp
  00244	c3		 ret	 0
$LN8@CGWarehous:

; 10366: 	{
; 10367: 		case 0x00:
; 10368: 			if ( money <= 0 || money > MAX_WAREHOUSE_ZEN )

  00245	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00248	3d ff 93 35 77	 cmp	 eax, 1999999999		; 773593ffH
  0024d	77 56		 ja	 SHORT $LN10@CGWarehous

; 10371: 				return;
; 10372: 			}
; 10373: 
; 10374: 			if ( (DWORD)(lpObj->WarehouseMoney+money) > MAX_WAREHOUSE_ZEN )

  0024f	8b 8e 08 12 00
	00		 mov	 ecx, DWORD PTR [esi+4616]
  00255	03 cb		 add	 ecx, ebx
  00257	81 f9 00 94 35
	77		 cmp	 ecx, 2000000000		; 77359400H
  0025d	77 46		 ja	 SHORT $LN10@CGWarehous

; 10375: 			{
; 10376: 				GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 10377: 				return;
; 10378: 			}
; 10379: 
; 10380: 			if ( money > lpObj->Money )

  0025f	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  00265	3b d8		 cmp	 ebx, eax
  00267	7f 3c		 jg	 SHORT $LN10@CGWarehous

; 10381: 			{
; 10382: 				GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 10383: 				return;
; 10384: 			}
; 10385: 
; 10386: 			lpObj->Money-=money;

  00269	2b c3		 sub	 eax, ebx

; 10387: 			lpObj->WarehouseMoney+=money;

  0026b	89 8e 08 12 00
	00		 mov	 DWORD PTR [esi+4616], ecx
  00271	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
$LN2@CGWarehous:

; 10449: 
; 10450: 		default:
; 10451: 			GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);
; 10452: 			return;
; 10453: 	}
; 10454: 
; 10455: 	lpObj->WarehouseCount++;
; 10456: 	GCWarehouseInventoryMoneySend(aIndex, 1, lpObj->Money, lpObj->WarehouseMoney);

  00277	ff b6 08 12 00
	00		 push	 DWORD PTR [esi+4616]
  0027d	fe 86 01 12 00
	00		 inc	 BYTE PTR [esi+4609]
  00283	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  00289	6a 01		 push	 1
  0028b	57		 push	 edi
  0028c	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00291	83 c4 10	 add	 esp, 16			; 00000010H
  00294	5e		 pop	 esi
  00295	5b		 pop	 ebx
  00296	5f		 pop	 edi

; 10457: }

  00297	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029a	33 cd		 xor	 ecx, ebp
  0029c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a1	8b e5		 mov	 esp, ebp
  002a3	5d		 pop	 ebp
  002a4	c3		 ret	 0
$LN10@CGWarehous:

; 10369: 			{
; 10370: 				GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  002a5	6a 00		 push	 0
  002a7	6a 00		 push	 0
  002a9	6a 00		 push	 0
  002ab	57		 push	 edi
  002ac	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  002b1	83 c4 10	 add	 esp, 16			; 00000010H
  002b4	5e		 pop	 esi
  002b5	5b		 pop	 ebx
  002b6	5f		 pop	 edi

; 10457: }

  002b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ba	33 cd		 xor	 ecx, ebp
  002bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c1	8b e5		 mov	 esp, ebp
  002c3	5d		 pop	 ebp
  002c4	c3		 ret	 0
$LN7@CGWarehous:

; 10357: 	{
; 10358: 		GCWarehouseInventoryMoneySend(aIndex, 0, 0, 0);

  002c5	6a 00		 push	 0
  002c7	6a 00		 push	 0
  002c9	6a 00		 push	 0
  002cb	57		 push	 edi
  002cc	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend

; 10359: 		LogAdd("[%s][%s] error-L1 : used not Warehouse",

  002d1	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv401[ebp]
  002d7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002dd	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002e0	50		 push	 eax
  002e1	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  002e4	50		 push	 eax
  002e5	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@
  002ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 10457: }

  002f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f3	83 c4 1c	 add	 esp, 28			; 0000001cH
  002f6	33 cd		 xor	 ecx, ebp
  002f8	5e		 pop	 esi
  002f9	5b		 pop	 ebx
  002fa	5f		 pop	 edi
  002fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00300	8b e5		 mov	 esp, ebp
  00302	5d		 pop	 ebp
  00303	c3		 ret	 0
?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ENDP ; CGWarehouseMoneyInOut
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildWarScore@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
?GCGuildWarScore@@YAXH@Z PROC				; GCGuildWarScore, COMDAT

; 10305: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 10306: #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 10307: 	if ( gObj[aIndex].GuildNumber < 1 )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	83 ec 08	 sub	 esp, 8
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00010	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00016	83 bc 06 14 06
	00 00 01	 cmp	 DWORD PTR [esi+eax+1556], 1
  0001e	0f 8c ae 00 00
	00		 jl	 $LN1@GCGuildWar

; 10308: 		return;
; 10309: 
; 10310: 	PMSG_GUILDSCORE pMsg;
; 10311: 
; 10312: 	PHeadSetB((LPBYTE)&pMsg, 0x64, sizeof(pMsg));

  00024	6a 06		 push	 6
  00026	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	6a 64		 push	 100			; 00000064H
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10313: 	pMsg.Score1 = 0;
; 10314: 	pMsg.Score2 = 0;
; 10315: 	pMsg.Type = 0;
; 10316: 
; 10317: 	if ( gObj[aIndex].lpGuild != NULL )

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0003c	66 c7 45 fb 00
	00		 mov	 WORD PTR _pMsg$[ebp+3], 0
  00042	c6 45 fd 00	 mov	 BYTE PTR _pMsg$[ebp+5], 0
  00046	8b 91 18 06 00
	00		 mov	 edx, DWORD PTR [ecx+1560]
  0004c	85 d2		 test	 edx, edx
  0004e	74 2e		 je	 SHORT $LN3@GCGuildWar

; 10318: 	{
; 10319: 		pMsg.Score1 = gObj[aIndex].lpGuild->PlayScore;

  00050	8a 82 95 05 00
	00		 mov	 al, BYTE PTR [edx+1429]
  00056	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 10320: 		LogAdd("Score %s %d", gObj[aIndex].Name, gObj[aIndex].lpGuild->PlayScore);

  00059	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  0005f	0f b6 80 95 05
	00 00		 movzx	 eax, BYTE PTR [eax+1429]
  00066	50		 push	 eax
  00067	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0006a	50		 push	 eax
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NJMAOJLE@Score?5?$CFs?5?$CFd?$AA@
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@GCGuildWar:

; 10321: 	}
; 10322: 
; 10323: 	if ( gObj[aIndex].lpGuild->lpTargetGuildNode != NULL )

  0007e	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00081	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  00087	8b 80 8c 05 00
	00		 mov	 eax, DWORD PTR [eax+1420]
  0008d	85 c0		 test	 eax, eax
  0008f	74 2f		 je	 SHORT $LN4@GCGuildWar

; 10324: 	{
; 10325: 		pMsg.Score2 = gObj[aIndex].lpGuild->lpTargetGuildNode->PlayScore;

  00091	8a 80 95 05 00
	00		 mov	 al, BYTE PTR [eax+1429]
  00097	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 10326: 		LogAdd("Target Score %s %d", gObj[aIndex].Name, gObj[aIndex].lpGuild->lpTargetGuildNode->PlayScore);

  0009a	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  000a0	8b 80 8c 05 00
	00		 mov	 eax, DWORD PTR [eax+1420]
  000a6	0f b6 80 95 05
	00 00		 movzx	 eax, BYTE PTR [eax+1429]
  000ad	50		 push	 eax
  000ae	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000b1	50		 push	 eax
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@ICJCOFEA@Target?5Score?5?$CFs?5?$CFd?$AA@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GCGuildWar:

; 10327: 	}
; 10328: 
; 10329: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000c0	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000c4	50		 push	 eax
  000c5	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000c8	50		 push	 eax
  000c9	57		 push	 edi
  000ca	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@GCGuildWar:
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi

; 10330: #endif
; 10331: }	

  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
?GCGuildWarScore@@YAXH@Z ENDP				; GCGuildWarScore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildWarEnd@@YAXHEPAD@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
__guildname$ = 16					; size = 4
?GCGuildWarEnd@@YAXHEPAD@Z PROC				; GCGuildWarEnd, COMDAT

; 10280: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 10	 mov	 esi, DWORD PTR __guildname$[ebp]

; 10281: #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 10282: 	PMSG_GUILDWAR_END pMsg;
; 10283: 
; 10284: 	PHeadSetB((LPBYTE)&pMsg, 0x63, sizeof(pMsg));

  00014	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 0c		 push	 12			; 0000000cH
  00019	6a 63		 push	 99			; 00000063H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10285: 	pMsg.Result = result;

  00021	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00024	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 10286: 	memcpy(pMsg.GuildName, _guildname, sizeof(pMsg.GuildName));

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+4], eax
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 10287: 
; 10288: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00032	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00036	50		 push	 eax
  00037	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003a	50		 push	 eax
  0003b	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0003e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10289: #endif
; 10290: }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	83 c4 18	 add	 esp, 24			; 00000018H
  00049	33 cd		 xor	 ecx, ebp
  0004b	5e		 pop	 esi
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GCGuildWarEnd@@YAXHEPAD@Z ENDP				; GCGuildWarEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildWarDeclare@@YAXHPAD@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
__guildname$ = 12					; size = 4
?GCGuildWarDeclare@@YAXHPAD@Z PROC			; GCGuildWarDeclare, COMDAT

; 10258: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR __guildname$[ebp]

; 10259: #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 10260: 	PMSG_GUILDWAR_DECLARE pMsg;
; 10261: 
; 10262: 	PHeadSetB((LPBYTE)&pMsg, 0x62, sizeof(pMsg));

  00014	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 0d		 push	 13			; 0000000dH
  00019	6a 62		 push	 98			; 00000062H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10263: 	memcpy(pMsg.GuildName, _guildname, sizeof(pMsg.GuildName));

  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	89 45 ef	 mov	 DWORD PTR _pMsg$[ebp+3], eax
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	89 45 f3	 mov	 DWORD PTR _pMsg$[ebp+7], eax

; 10264: 
; 10265: 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0002c	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00030	50		 push	 eax
  00031	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00034	50		 push	 eax
  00035	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00038	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10266: #endif
; 10267: }

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	83 c4 18	 add	 esp, 24			; 00000018H
  00043	33 cd		 xor	 ecx, ebp
  00045	5e		 pop	 esi
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?GCGuildWarDeclare@@YAXHPAD@Z ENDP			; GCGuildWarDeclare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z
_TEXT	SEGMENT
tv914 = -300						; size = 4
_aIndex$GSCopy$1$ = -296				; size = 4
_pResult$1 = -296					; size = 4
_pResult$2 = -296					; size = 4
_pResult$3 = -296					; size = 4
_pNotice$4 = -292					; size = 272
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z PROC ; GCGuildWarRequestSendRecv, COMDAT

; 9991 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 9992 : #if (GS_CASTLE == 1 && GS_SPEC != 1)
; 9993 : 	return;
; 9994 : #endif
; 9995 : 	PMSG_GUILDWAR_DECLARE pMsg;
; 9996 : 	int count=0;
; 9997 : 	int g_call=0;
; 9998 : 	int n;
; 9999 : 	
; 10000: 	PHeadSetB((LPBYTE)&pMsg, 0x62, sizeof(pMsg));

  00017	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001f	6a 0d		 push	 13			; 0000000dH
  00021	6a 62		 push	 98			; 00000062H
  00023	50		 push	 eax
  00024	89 9d d8 fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], ebx
  0002a	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10001: 	pMsg.Type = 0;
; 10002: 	
; 10003: 	_GUILD_INFO_STRUCT * lpMyNode = gObj[aIndex].lpGuild;

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	69 c3 40 27 00
	00		 imul	 eax, ebx, 10048
  0003e	c6 45 f7 00	 mov	 BYTE PTR _pMsg$[ebp+11], 0
  00042	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv914[ebp], eax
  00048	8b b4 08 18 06
	00 00		 mov	 esi, DWORD PTR [eax+ecx+1560]

; 10004: 
; 10005: 	if ( !lpMyNode )

  0004f	85 f6		 test	 esi, esi
  00051	75 2d		 jne	 SHORT $LN10@GCGuildWar

; 10006: 	{
; 10007: 		PMSG_GUILDWARREQUEST_RESULT pResult;
; 10008: 
; 10009: 		pResult.h.c = 0xC1;
; 10010: 		pResult.h.headcode = 0x60;
; 10011: 		pResult.h.size = sizeof(pResult);
; 10012: 		pResult.Result = 0;
; 10013: 
; 10014: 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00053	6a 04		 push	 4
  00055	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$3[ebp]
  0005b	c7 85 d8 fe ff
	ff c1 04 60 00	 mov	 DWORD PTR _pResult$3[ebp], 6292673 ; 006004c1H
  00065	50		 push	 eax
  00066	53		 push	 ebx
  00067	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10245: 						GCServerMsgStringSendGuild(lpMyNode,lMsg.Get(MSGGET(4, 130)), 1);

  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 10246: 					}
; 10247: 				}
; 10248: 			}
; 10249: 		}
; 10250: 	}
; 10251: }

  00072	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00075	33 cd		 xor	 ecx, ebp
  00077	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN10@GCGuildWar:

; 10015: 		return;
; 10016: 	}
; 10017: 
; 10018: 	if ( lpMyNode->lpTargetGuildNode && lpMsg->Result )

  00080	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00086	85 c0		 test	 eax, eax
  00088	0f 84 c6 00 00
	00		 je	 $LN12@GCGuildWar
  0008e	80 7f 03 00	 cmp	 BYTE PTR [edi+3], 0
  00092	0f 84 bc 00 00
	00		 je	 $LN12@GCGuildWar

; 10019: 	{
; 10020: 		int iTarGetIndex = lpMyNode->lpTargetGuildNode->Index[0];

  00098	0f bf 80 a0 03
	00 00		 movsx	 eax, WORD PTR [eax+928]

; 10021: 
; 10022: 		if ( BC_MAP_RANGE(gObj[iTarGetIndex].MapNumber) ||
; 10023: 			 CC_MAP_RANGE(gObj[iTarGetIndex].MapNumber) ||
; 10024: 			 DS_MAP_RANGE(gObj[iTarGetIndex].MapNumber) ||
; 10025: 			 IT_MAP_RANGE(gObj[iTarGetIndex].MapNumber) ||
; 10026: 			 DG_MAP_RANGE(gObj[iTarGetIndex].MapNumber) ||

  0009f	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  000a5	8a 8c 08 23 01
	00 00		 mov	 cl, BYTE PTR [eax+ecx+291]
  000ac	80 f9 34	 cmp	 cl, 52			; 00000034H
  000af	74 69		 je	 SHORT $LN13@GCGuildWar
  000b1	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  000b4	72 0b		 jb	 SHORT $LN77@GCGuildWar
  000b6	b0 11		 mov	 al, 17			; 00000011H
  000b8	3a c1		 cmp	 al, cl
  000ba	1b c0		 sbb	 eax, eax
  000bc	83 c0 01	 add	 eax, 1
  000bf	75 59		 jne	 SHORT $LN13@GCGuildWar
$LN77@GCGuildWar:
  000c1	80 f9 35	 cmp	 cl, 53			; 00000035H
  000c4	74 54		 je	 SHORT $LN13@GCGuildWar
  000c6	80 f9 12	 cmp	 cl, 18			; 00000012H
  000c9	72 0b		 jb	 SHORT $LN78@GCGuildWar
  000cb	b0 17		 mov	 al, 23			; 00000017H
  000cd	3a c1		 cmp	 al, cl
  000cf	1b c0		 sbb	 eax, eax
  000d1	83 c0 01	 add	 eax, 1
  000d4	75 44		 jne	 SHORT $LN13@GCGuildWar
$LN78@GCGuildWar:
  000d6	80 f9 09	 cmp	 cl, 9
  000d9	74 3f		 je	 SHORT $LN13@GCGuildWar
  000db	33 c0		 xor	 eax, eax
  000dd	80 f9 20	 cmp	 cl, 32			; 00000020H
  000e0	0f 94 c0	 sete	 al
  000e3	85 c0		 test	 eax, eax
  000e5	75 33		 jne	 SHORT $LN13@GCGuildWar
  000e7	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  000ea	72 0e		 jb	 SHORT $LN79@GCGuildWar
  000ec	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  000f1	3a c1		 cmp	 al, cl
  000f3	1b c0		 sbb	 eax, eax
  000f5	83 c0 01	 add	 eax, 1
  000f8	75 20		 jne	 SHORT $LN13@GCGuildWar
$LN79@GCGuildWar:
  000fa	80 f9 41	 cmp	 cl, 65			; 00000041H
  000fd	72 0b		 jb	 SHORT $LN80@GCGuildWar
  000ff	b0 44		 mov	 al, 68			; 00000044H
  00101	3a c1		 cmp	 al, cl
  00103	1b c0		 sbb	 eax, eax
  00105	83 c0 01	 add	 eax, 1
  00108	75 10		 jne	 SHORT $LN13@GCGuildWar
$LN80@GCGuildWar:
  0010a	80 f9 45	 cmp	 cl, 69			; 00000045H
  0010d	72 45		 jb	 SHORT $LN12@GCGuildWar
  0010f	b0 48		 mov	 al, 72			; 00000048H
  00111	3a c1		 cmp	 al, cl
  00113	1b c0		 sbb	 eax, eax
  00115	83 c0 01	 add	 eax, 1
  00118	74 3a		 je	 SHORT $LN12@GCGuildWar
$LN13@GCGuildWar:

; 10027: 			 IF_MAP_RANGE(gObj[iTarGetIndex].MapNumber)
; 10028: 			 )
; 10029: 		{
; 10030: 			PMSG_NOTICE pNotice;
; 10031: 
; 10032: 			TNotice::MakeNoticeMsgEx(&pNotice, 1, lMsg.Get(MSGGET(4, 199)));

  0011a	68 c7 04 00 00	 push	 1223			; 000004c7H
  0011f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00124	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00129	50		 push	 eax
  0012a	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$4[ebp]
  00130	6a 01		 push	 1
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx

; 10033: 
; 10034: 			DataSend(aIndex, (LPBYTE)&pNotice, pNotice.h.size);

  00138	0f b6 85 dd fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$4[ebp+1]
  0013f	50		 push	 eax
  00140	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$4[ebp]
  00146	50		 push	 eax
  00147	53		 push	 ebx
  00148	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0014d	83 c4 18	 add	 esp, 24			; 00000018H

; 10035: 
; 10036: 			lpMsg->Result = 0;

  00150	c6 47 03 00	 mov	 BYTE PTR [edi+3], 0
$LN12@GCGuildWar:

; 10037: 		}
; 10038: 	}
; 10039: 
; 10040: 	pMsg.Type = lpMyNode->WarType;
; 10041: 
; 10042: 	if ( lpMsg->Result == 0 )

  00154	80 7f 03 00	 cmp	 BYTE PTR [edi+3], 0
  00158	8a 86 92 05 00
	00		 mov	 al, BYTE PTR [esi+1426]
  0015e	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+11], al
  00161	0f 85 85 00 00
	00		 jne	 $LN14@GCGuildWar

; 10043: 	{
; 10044: 		if ( lpMyNode->lpTargetGuildNode )

  00167	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0016d	85 c0		 test	 eax, eax
  0016f	0f 84 8b 04 00
	00		 je	 $LN51@GCGuildWar

; 10045: 		{
; 10046: 			if ( lpMyNode->lpTargetGuildNode->WarDeclareState == 1 )

  00175	80 b8 90 05 00
	00 01		 cmp	 BYTE PTR [eax+1424], 1
  0017c	0f 85 7e 04 00
	00		 jne	 $LN51@GCGuildWar

; 10047: 			{
; 10048: 				lpMyNode->lpTargetGuildNode->WarDeclareState = 0;

  00182	c6 80 90 05 00
	00 00		 mov	 BYTE PTR [eax+1424], 0

; 10049: 				lpMyNode->WarDeclareState = 0;
; 10050: 
; 10051: 				PMSG_GUILDWARREQUEST_RESULT pResult;
; 10052: 
; 10053: 				PHeadSetB((LPBYTE)&pResult, 0x60, sizeof(pResult));

  00189	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$2[ebp]
  0018f	6a 04		 push	 4
  00191	6a 60		 push	 96			; 00000060H
  00193	50		 push	 eax
  00194	c6 86 90 05 00
	00 00		 mov	 BYTE PTR [esi+1424], 0
  0019b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10054: 				pResult.Result = 6;
; 10055: 
; 10056: 				if ( lpMyNode->lpTargetGuildNode->Index[0] >= 0 )

  001a0	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a9	c6 85 db fe ff
	ff 06		 mov	 BYTE PTR _pResult$2[ebp+3], 6
  001b0	0f b7 88 a0 03
	00 00		 movzx	 ecx, WORD PTR [eax+928]
  001b7	66 85 c9	 test	 cx, cx
  001ba	0f 88 40 04 00
	00		 js	 $LN51@GCGuildWar

; 10057: 				{
; 10058: 					DataSend(lpMyNode->lpTargetGuildNode->Index[0], (LPBYTE)&pResult, pResult.h.size);

  001c0	0f b6 85 d9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$2[ebp+1]
  001c7	50		 push	 eax
  001c8	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$2[ebp]
  001ce	50		 push	 eax
  001cf	0f bf c1	 movsx	 eax, cx
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10245: 						GCServerMsgStringSendGuild(lpMyNode,lMsg.Get(MSGGET(4, 130)), 1);

  001d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001db	5f		 pop	 edi
  001dc	5e		 pop	 esi
  001dd	5b		 pop	 ebx

; 10246: 					}
; 10247: 				}
; 10248: 			}
; 10249: 		}
; 10250: 	}
; 10251: }

  001de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e1	33 cd		 xor	 ecx, ebp
  001e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	c3		 ret	 0
$LN14@GCGuildWar:

; 10059: 				}
; 10060: 			}
; 10061: 		}
; 10062: 	}
; 10063: 	else //if ( lpMsg->Result == 1 )
; 10064: 	{
; 10065: 		if ( lpMyNode->WarDeclareState == 1 )

  001ec	80 be 90 05 00
	00 01		 cmp	 BYTE PTR [esi+1424], 1
  001f3	0f 85 07 04 00
	00		 jne	 $LN51@GCGuildWar

; 10066: 		{
; 10067: 			if ( lpMyNode->lpTargetGuildNode )

  001f9	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  001ff	85 c0		 test	 eax, eax
  00201	0f 84 f9 03 00
	00		 je	 $LN51@GCGuildWar

; 10068: 			{
; 10069: 				if (lpMyNode->lpTargetGuildNode->WarDeclareState == 1 )

  00207	80 b8 90 05 00
	00 01		 cmp	 BYTE PTR [eax+1424], 1
  0020e	0f 85 ec 03 00
	00		 jne	 $LN51@GCGuildWar

; 10070: 				{
; 10071: 					PMSG_TELEPORT pTeleportMsg;
; 10072: 
; 10073: 					if ( lpMyNode->WarType == 1 )

  00214	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  0021b	0f 85 9b 00 00
	00		 jne	 $LN22@GCGuildWar

; 10074: 					{
; 10075: 						lpMyNode->BattleGroundIndex = gCheckBlankBattleGround();

  00221	e8 00 00 00 00	 call	 ?gCheckBlankBattleGround@@YAHXZ ; gCheckBlankBattleGround
  00226	88 86 93 05 00
	00		 mov	 BYTE PTR [esi+1427], al

; 10076: 
; 10077: 						switch ( lpMyNode->BattleGroundIndex )

  0022c	3c ff		 cmp	 al, 255			; 000000ffH
  0022e	0f 84 dd 03 00
	00		 je	 $LN23@GCGuildWar

; 10091: 								return;
; 10092: 						}
; 10093: 	
; 10094: 						pTeleportMsg.MoveNumber = 51;
; 10095: 						lpMyNode->lpTargetGuildNode->BattleGroundIndex = lpMyNode->BattleGroundIndex;

  00234	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  0023a	88 81 93 05 00
	00		 mov	 BYTE PTR [ecx+1427], al

; 10096: 
; 10097: 						if ( gBSGround[0]->m_BallIndex >= 0 )

  00240	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gBSGround@@3PAPAVCBattleSoccer@@A ; gBSGround
  00245	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00248	85 c0		 test	 eax, eax
  0024a	78 15		 js	 SHORT $LN24@GCGuildWar

; 10098: 							gObjMonsterRegen(&gObj[gBSGround[0]->m_BallIndex]);

  0024c	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00252	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 ?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterRegen
  0025e	83 c4 04	 add	 esp, 4
$LN24@GCGuildWar:

; 10099: 
; 10100: 						BattleSoccerGoalEnd(0);

  00261	6a 00		 push	 0
  00263	e8 00 00 00 00	 call	 ?BattleSoccerGoalEnd@@YAXH@Z ; BattleSoccerGoalEnd

; 10101: 						lpMyNode->PlayScore = 0;
; 10102: 						lpMyNode->lpTargetGuildNode->PlayScore = 0;

  00268	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0026e	c6 86 95 05 00
	00 00		 mov	 BYTE PTR [esi+1429], 0

; 10103: 						gBattleGroundEnable(lpMyNode->BattleGroundIndex, TRUE);

  00275	6a 01		 push	 1
  00277	c6 80 95 05 00
	00 00		 mov	 BYTE PTR [eax+1429], 0
  0027e	0f b6 86 93 05
	00 00		 movzx	 eax, BYTE PTR [esi+1427]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable

; 10104: 						gSetBattleTeamMaster(lpMyNode->BattleGroundIndex, 0, lpMyNode->Name, lpMyNode);

  0028b	56		 push	 esi
  0028c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0028f	50		 push	 eax
  00290	0f b6 86 93 05
	00 00		 movzx	 eax, BYTE PTR [esi+1427]
  00297	6a 00		 push	 0
  00299	50		 push	 eax
  0029a	e8 00 00 00 00	 call	 ?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z ; gSetBattleTeamMaster

; 10105: 						gSetBattleTeamMaster(lpMyNode->BattleGroundIndex, 1, lpMyNode->lpTargetGuildNode->Name, lpMyNode->lpTargetGuildNode);

  0029f	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  002a5	50		 push	 eax
  002a6	83 c0 04	 add	 eax, 4
  002a9	50		 push	 eax
  002aa	0f b6 86 93 05
	00 00		 movzx	 eax, BYTE PTR [esi+1427]
  002b1	6a 01		 push	 1
  002b3	50		 push	 eax
  002b4	e8 00 00 00 00	 call	 ?gSetBattleTeamMaster@@YAXHHPADPAU_GUILD_INFO_STRUCT@@@Z ; gSetBattleTeamMaster
  002b9	83 c4 2c	 add	 esp, 44			; 0000002cH
$LN22@GCGuildWar:

; 10106: 					}
; 10107: 
; 10108: 					lpMyNode->WarDeclareState = 2;
; 10109: 					lpMyNode->WarState = 1;
; 10110: 					lpMyNode->lpTargetGuildNode->WarDeclareState = 2;

  002bc	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  002c2	0f 57 c0	 xorps	 xmm0, xmm0
  002c5	66 c7 86 90 05
	00 00 02 01	 mov	 WORD PTR [esi+1424], 258 ; 00000102H

; 10111: 					lpMyNode->lpTargetGuildNode->WarState = 1;
; 10112: 					lpMyNode->PlayScore = 0;
; 10113: 					lpMyNode->lpTargetGuildNode->PlayScore = 0;
; 10114: 					lpMyNode->BattleTeamCode = 0;
; 10115: 					lpMyNode->lpTargetGuildNode->BattleTeamCode = 1;
; 10116: 					memset(pMsg.GuildName, 0, sizeof(pMsg.GuildName));
; 10117: 					memcpy(pMsg.GuildName, lpMyNode->lpTargetGuildNode->Name, sizeof(pMsg.GuildName));
; 10118: 					pMsg.TeamCode = lpMyNode->BattleTeamCode;
; 10119: 					count = 0;
; 10120: 
; 10121: 					for ( n=0;n<MAX_USER_GUILD;n++)

  002ce	33 ff		 xor	 edi, edi
  002d0	c6 80 90 05 00
	00 02		 mov	 BYTE PTR [eax+1424], 2
  002d7	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  002dd	c6 80 91 05 00
	00 01		 mov	 BYTE PTR [eax+1425], 1
  002e4	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  002ea	c6 86 95 05 00
	00 00		 mov	 BYTE PTR [esi+1429], 0
  002f1	c6 80 95 05 00
	00 00		 mov	 BYTE PTR [eax+1429], 0
  002f8	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  002fe	c6 86 94 05 00
	00 00		 mov	 BYTE PTR [esi+1428], 0
  00305	c6 80 94 05 00
	00 01		 mov	 BYTE PTR [eax+1428], 1
  0030c	66 0f d6 45 ef	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  00311	8b 8e 8c 05 00
	00		 mov	 ecx, DWORD PTR [esi+1420]
  00317	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0031a	89 45 ef	 mov	 DWORD PTR _pMsg$[ebp+3], eax
  0031d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00320	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00326	89 45 f3	 mov	 DWORD PTR _pMsg$[ebp+7], eax
  00329	8a 86 94 05 00
	00		 mov	 al, BYTE PTR [esi+1428]
  0032f	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
$LL6@GCGuildWar:

; 10122: 					{
; 10123: 						if ( lpMyNode->Use[n] )

  00332	80 bc 3e 40 04
	00 00 00	 cmp	 BYTE PTR [esi+edi+1088], 0
  0033a	0f 84 fb 00 00
	00		 je	 $LN4@GCGuildWar

; 10124: 						{
; 10125: 							if ( lpMyNode->Index[n] >= 0 )

  00340	0f b7 94 7e a0
	03 00 00	 movzx	 edx, WORD PTR [esi+edi*2+928]
  00348	66 85 d2	 test	 dx, dx
  0034b	0f 88 ea 00 00
	00		 js	 $LN4@GCGuildWar

; 10126: 							{
; 10127: 								g_call = 0;
; 10128: 
; 10129: 								if ( n > 0 )

  00351	85 ff		 test	 edi, edi
  00353	7e 35		 jle	 SHORT $LN86@GCGuildWar

; 10130: 								{
; 10131: 									if ( lpMyNode->WarType == 1 )

  00355	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  0035c	75 32		 jne	 SHORT $LN81@GCGuildWar

; 10132: 									{
; 10133: 										if ( gObj[lpMyNode->Index[0]].PartyNumber  >= 0 )

  0035e	0f bf 86 a0 03
	00 00		 movsx	 eax, WORD PTR [esi+928]
  00365	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0036b	8b 9c 08 0c 06
	00 00		 mov	 ebx, DWORD PTR [eax+ecx+1548]
  00372	85 db		 test	 ebx, ebx
  00374	0f 88 c1 00 00
	00		 js	 $LN4@GCGuildWar

; 10134: 										{
; 10135: 											if ( gObj[lpMyNode->Index[0]].PartyNumber == gObj[lpMyNode->Index[n]].PartyNumber )

  0037a	0f bf c2	 movsx	 eax, dx
  0037d	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00383	3b 9c 08 0c 06
	00 00		 cmp	 ebx, DWORD PTR [eax+ecx+1548]
$LN86@GCGuildWar:

; 10136: 											{
; 10137: 												g_call = 1;
; 10138: 											}
; 10139: 										}
; 10140: 									}
; 10141: 									else 
; 10142: 									{
; 10143: 										g_call = 1;
; 10144: 									}
; 10145: 								}
; 10146: 								else if ( n== 0 )

  0038a	0f 85 ab 00 00
	00		 jne	 $LN4@GCGuildWar
$LN81@GCGuildWar:

; 10147: 								{
; 10148: 									g_call = 1;
; 10149: 								}
; 10150: 
; 10151: 								if ( g_call )
; 10152: 								{
; 10153: 									DataSend(lpMyNode->Index[n], (LPBYTE)&pMsg, pMsg.h.size);

  00390	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00394	50		 push	 eax
  00395	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00398	50		 push	 eax
  00399	0f bf c2	 movsx	 eax, dx
  0039c	50		 push	 eax
  0039d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10154: 
; 10155: 									// Declared guild war against (%s)
; 10156: 									LogAddTD(lMsg.Get(MSGGET(1, 238)), lpMyNode->Name);

  003a5	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  003a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003ad	50		 push	 eax
  003ae	68 ee 01 00 00	 push	 494			; 000001eeH
  003b3	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003b8	50		 push	 eax
  003b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 10157: 									GCGuildWarScore(lpMyNode->Index[n]);

  003bf	0f bf 84 7e a0
	03 00 00	 movsx	 eax, WORD PTR [esi+edi*2+928]
  003c7	50		 push	 eax
  003c8	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore
  003cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10158: 									int x = 60;
; 10159: 
; 10160: 									if ( lpMyNode->WarType == 1 )

  003d0	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  003d7	75 5c		 jne	 SHORT $LN83@GCGuildWar

; 10161: 									{
; 10162: 										gObj[lpMyNode->Index[n]].IsInBattleGround = true;

  003d9	0f bf 84 7e a0
	03 00 00	 movsx	 eax, WORD PTR [esi+edi*2+928]
  003e1	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  003e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ec	c6 84 01 de 13
	00 00 01	 mov	 BYTE PTR [ecx+eax+5086], 1

; 10163: 										pTeleportMsg.MoveNumber = 51;
; 10164: 
; 10165: 										if ( gPkLimitFree || gObj[lpMyNode->Index[n]].m_PK_Level < 6 )

  003f4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  003fb	75 1e		 jne	 SHORT $LN37@GCGuildWar
  003fd	0f bf 84 7e a0
	03 00 00	 movsx	 eax, WORD PTR [esi+edi*2+928]
  00405	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0040b	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00411	80 bc 08 19 01
	00 00 06	 cmp	 BYTE PTR [eax+ecx+281], 6
  00419	7d 20		 jge	 SHORT $LN4@GCGuildWar
$LN37@GCGuildWar:

; 10166: 										{
; 10167: 											gObjTeleport(lpMyNode->Index[n], 6, x++, 153);

  0041b	0f bf 84 7e a0
	03 00 00	 movsx	 eax, WORD PTR [esi+edi*2+928]
  00423	68 99 00 00 00	 push	 153			; 00000099H
  00428	6a 3c		 push	 60			; 0000003cH
  0042a	6a 06		 push	 6
  0042c	50		 push	 eax
  0042d	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  00432	83 c4 10	 add	 esp, 16			; 00000010H
$LN83@GCGuildWar:
  00435	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN4@GCGuildWar:

; 10111: 					lpMyNode->lpTargetGuildNode->WarState = 1;
; 10112: 					lpMyNode->PlayScore = 0;
; 10113: 					lpMyNode->lpTargetGuildNode->PlayScore = 0;
; 10114: 					lpMyNode->BattleTeamCode = 0;
; 10115: 					lpMyNode->lpTargetGuildNode->BattleTeamCode = 1;
; 10116: 					memset(pMsg.GuildName, 0, sizeof(pMsg.GuildName));
; 10117: 					memcpy(pMsg.GuildName, lpMyNode->lpTargetGuildNode->Name, sizeof(pMsg.GuildName));
; 10118: 					pMsg.TeamCode = lpMyNode->BattleTeamCode;
; 10119: 					count = 0;
; 10120: 
; 10121: 					for ( n=0;n<MAX_USER_GUILD;n++)

  0043b	47		 inc	 edi
  0043c	83 ff 50	 cmp	 edi, 80			; 00000050H
  0043f	0f 8c ed fe ff
	ff		 jl	 $LL6@GCGuildWar

; 10168: 											count++;
; 10169: 										}
; 10170: 									}
; 10171: 								}
; 10172: 							}
; 10173: 						}
; 10174: 					}
; 10175: 
; 10176: 					memset(pMsg.GuildName, 0, sizeof(pMsg.GuildName));
; 10177: 					memcpy(pMsg.GuildName, lpMyNode->Name, sizeof(pMsg.GuildName));
; 10178: 
; 10179: 					pMsg.TeamCode = lpMyNode->lpTargetGuildNode->BattleTeamCode;
; 10180: 					count = 0;
; 10181: 
; 10182: 					for ( n=0;n<MAX_USER_GUILD;n++)

  00445	0f 57 c0	 xorps	 xmm0, xmm0
  00448	33 ff		 xor	 edi, edi
  0044a	66 0f d6 45 ef	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  0044f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00452	89 45 ef	 mov	 DWORD PTR _pMsg$[ebp+3], eax
  00455	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00458	89 45 f3	 mov	 DWORD PTR _pMsg$[ebp+7], eax
  0045b	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00461	8a 80 94 05 00
	00		 mov	 al, BYTE PTR [eax+1428]
  00467	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al
  0046a	66 0f 1f 44 00
	00		 npad	 6
$LL9@GCGuildWar:

; 10183: 					{
; 10184: 						if ( lpMyNode->lpTargetGuildNode->Use[n] )

  00470	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00476	80 bc 38 40 04
	00 00 00	 cmp	 BYTE PTR [eax+edi+1088], 0
  0047e	0f 84 0e 01 00
	00		 je	 $LN7@GCGuildWar

; 10185: 						{
; 10186: 							if ( lpMyNode->lpTargetGuildNode->Index[n] >= 0 )

  00484	0f b7 94 78 a0
	03 00 00	 movzx	 edx, WORD PTR [eax+edi*2+928]
  0048c	66 85 d2	 test	 dx, dx
  0048f	0f 88 fd 00 00
	00		 js	 $LN7@GCGuildWar

; 10187: 							{
; 10188: 								g_call = 0;
; 10189: 
; 10190: 								if ( n > 0 )

  00495	85 ff		 test	 edi, edi
  00497	7e 35		 jle	 SHORT $LN87@GCGuildWar

; 10191: 								{
; 10192: 									if ( lpMyNode->WarType == 1 )

  00499	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  004a0	75 32		 jne	 SHORT $LN82@GCGuildWar

; 10193: 									{
; 10194: 										if ( gObj[lpMyNode->lpTargetGuildNode->Index[0]].PartyNumber  >= 0 )

  004a2	0f bf 80 a0 03
	00 00		 movsx	 eax, WORD PTR [eax+928]
  004a9	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  004af	8b 9c 08 0c 06
	00 00		 mov	 ebx, DWORD PTR [eax+ecx+1548]
  004b6	85 db		 test	 ebx, ebx
  004b8	0f 88 d4 00 00
	00		 js	 $LN7@GCGuildWar

; 10195: 										{
; 10196: 											if ( gObj[lpMyNode->lpTargetGuildNode->Index[0]].PartyNumber == gObj[lpMyNode->lpTargetGuildNode->Index[n]].PartyNumber )

  004be	0f bf c2	 movsx	 eax, dx
  004c1	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  004c7	3b 9c 08 0c 06
	00 00		 cmp	 ebx, DWORD PTR [eax+ecx+1548]
$LN87@GCGuildWar:

; 10197: 											{
; 10198: 												g_call = 1;
; 10199: 											}
; 10200: 										}
; 10201: 									}
; 10202: 									else 
; 10203: 									{
; 10204: 										g_call = 1;
; 10205: 									}
; 10206: 								}
; 10207: 								else if ( n== 0 )

  004ce	0f 85 be 00 00
	00		 jne	 $LN7@GCGuildWar
$LN82@GCGuildWar:

; 10208: 								{
; 10209: 									g_call = 1;
; 10210: 								}
; 10211: 
; 10212: 								if ( g_call )
; 10213: 								{
; 10214: 									DataSend(lpMyNode->lpTargetGuildNode->Index[n], (LPBYTE)&pMsg, pMsg.h.size);

  004d4	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  004d8	50		 push	 eax
  004d9	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  004dc	50		 push	 eax
  004dd	0f bf c2	 movsx	 eax, dx
  004e0	50		 push	 eax
  004e1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10215: 
; 10216: 									// Declared guild war against (%s)
; 10217: 									LogAddTD(lMsg.Get(MSGGET(1, 238)), lpMyNode->lpTargetGuildNode->Name);

  004e6	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  004ec	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ef	83 c0 04	 add	 eax, 4
  004f2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004f7	50		 push	 eax
  004f8	68 ee 01 00 00	 push	 494			; 000001eeH
  004fd	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00502	50		 push	 eax
  00503	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 10218: 									GCGuildWarScore(lpMyNode->lpTargetGuildNode->Index[n]);

  00509	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0050f	0f bf 84 78 a0
	03 00 00	 movsx	 eax, WORD PTR [eax+edi*2+928]
  00517	50		 push	 eax
  00518	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore

; 10219: 									int x = 59;
; 10220: 
; 10221: 									if ( lpMyNode->lpTargetGuildNode->WarType == 1 )

  0051d	8b 96 8c 05 00
	00		 mov	 edx, DWORD PTR [esi+1420]
  00523	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10222: 									{
; 10223: 
; 10224: 										if ( gPkLimitFree != 0 || gObj[lpMyNode->lpTargetGuildNode->Index[n]].m_PK_Level < 6 )

  00526	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0052c	80 ba 92 05 00
	00 01		 cmp	 BYTE PTR [edx+1426], 1
  00533	75 5d		 jne	 SHORT $LN7@GCGuildWar
  00535	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  0053c	75 18		 jne	 SHORT $LN50@GCGuildWar
  0053e	0f bf 84 7a a0
	03 00 00	 movsx	 eax, WORD PTR [edx+edi*2+928]
  00546	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  0054c	80 bc 08 19 01
	00 00 06	 cmp	 BYTE PTR [eax+ecx+281], 6
  00554	7d 3c		 jge	 SHORT $LN7@GCGuildWar
$LN50@GCGuildWar:

; 10225: 										{
; 10226: 											gObj[lpMyNode->lpTargetGuildNode->Index[n]].IsInBattleGround = true;

  00556	0f bf 84 7a a0
	03 00 00	 movsx	 eax, WORD PTR [edx+edi*2+928]
  0055e	69 c0 40 27 00
	00		 imul	 eax, eax, 10048

; 10227: 											gObjTeleport(lpMyNode->lpTargetGuildNode->Index[n], 6, x++, 164);

  00564	68 a4 00 00 00	 push	 164			; 000000a4H
  00569	6a 3b		 push	 59			; 0000003bH
  0056b	6a 06		 push	 6
  0056d	c6 84 08 de 13
	00 00 01	 mov	 BYTE PTR [eax+ecx+5086], 1
  00575	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  0057b	0f bf 84 78 a0
	03 00 00	 movsx	 eax, WORD PTR [eax+edi*2+928]
  00583	50		 push	 eax
  00584	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport
  00589	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0058f	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@GCGuildWar:

; 10168: 											count++;
; 10169: 										}
; 10170: 									}
; 10171: 								}
; 10172: 							}
; 10173: 						}
; 10174: 					}
; 10175: 
; 10176: 					memset(pMsg.GuildName, 0, sizeof(pMsg.GuildName));
; 10177: 					memcpy(pMsg.GuildName, lpMyNode->Name, sizeof(pMsg.GuildName));
; 10178: 
; 10179: 					pMsg.TeamCode = lpMyNode->lpTargetGuildNode->BattleTeamCode;
; 10180: 					count = 0;
; 10181: 
; 10182: 					for ( n=0;n<MAX_USER_GUILD;n++)

  00592	47		 inc	 edi
  00593	83 ff 50	 cmp	 edi, 80			; 00000050H
  00596	0f 8c d4 fe ff
	ff		 jl	 $LL9@GCGuildWar

; 10228: 											count++;
; 10229: 										}
; 10230: 									}
; 10231: 								}
; 10232: 							}
; 10233: 						}
; 10234: 					}
; 10235: 
; 10236: //					cManager.BattleInfoSend(GetBattleTeamName(0,0),
; 10237: //											GetBattleTeamScore(0,0),
; 10238: //											GetBattleTeamName(0, 1),
; 10239: //											GetBattleTeamScore(0,1));
; 10240: 
; 10241: 					if ( lpMyNode->WarType == 1 )

  0059c	80 be 92 05 00
	00 01		 cmp	 BYTE PTR [esi+1426], 1
  005a3	75 5b		 jne	 SHORT $LN51@GCGuildWar

; 10242: 					{
; 10243: 						gObjAddMsgSendDelay(&gObj[aIndex], 5, aIndex, 10000, 0);

  005a5	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv914[ebp]
  005ab	6a 00		 push	 0
  005ad	68 10 27 00 00	 push	 10000			; 00002710H
  005b2	ff b5 d8 fe ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  005b8	03 c1		 add	 eax, ecx
  005ba	6a 05		 push	 5
  005bc	50		 push	 eax
  005bd	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  005c2	83 c4 14	 add	 esp, 20			; 00000014H

; 10244: 						GCServerMsgStringSendGuild(lpMyNode->lpTargetGuildNode,lMsg.Get(MSGGET(4, 130)), 1);

  005c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  005ca	6a 01		 push	 1
  005cc	68 82 04 00 00	 push	 1154			; 00000482H
  005d1	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  005d6	50		 push	 eax
  005d7	ff b6 8c 05 00
	00		 push	 DWORD PTR [esi+1420]
  005dd	e8 00 00 00 00	 call	 ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
  005e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10245: 						GCServerMsgStringSendGuild(lpMyNode,lMsg.Get(MSGGET(4, 130)), 1);

  005e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  005ea	6a 01		 push	 1
  005ec	68 82 04 00 00	 push	 1154			; 00000482H
  005f1	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  005f6	50		 push	 eax
  005f7	56		 push	 esi
  005f8	e8 00 00 00 00	 call	 ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ; GCServerMsgStringSendGuild
  005fd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN51@GCGuildWar:
  00600	5f		 pop	 edi
  00601	5e		 pop	 esi
  00602	5b		 pop	 ebx

; 10246: 					}
; 10247: 				}
; 10248: 			}
; 10249: 		}
; 10250: 	}
; 10251: }

  00603	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00606	33 cd		 xor	 ecx, ebp
  00608	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0060d	8b e5		 mov	 esp, ebp
  0060f	5d		 pop	 ebp
  00610	c3		 ret	 0
$LN23@GCGuildWar:

; 10078: 						{
; 10079: 							case 0xFF:
; 10080: 								lpMyNode->WarDeclareState = 0;
; 10081: 								lpMyNode->WarState = 0;
; 10082: 								lpMyNode->lpTargetGuildNode->WarDeclareState = 0;

  00611	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00617	66 c7 86 90 05
	00 00 00 00	 mov	 WORD PTR [esi+1424], 0

; 10083: 								lpMyNode->lpTargetGuildNode->WarState = 0;
; 10084: 
; 10085: 								PMSG_GUILDWARREQUEST_RESULT pResult;
; 10086: 
; 10087: 								PHeadSetB((LPBYTE)&pResult, 0x60, sizeof(pResult));

  00620	6a 04		 push	 4
  00622	6a 60		 push	 96			; 00000060H
  00624	c6 80 90 05 00
	00 00		 mov	 BYTE PTR [eax+1424], 0
  0062b	8b 86 8c 05 00
	00		 mov	 eax, DWORD PTR [esi+1420]
  00631	c6 80 91 05 00
	00 00		 mov	 BYTE PTR [eax+1425], 0
  00638	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$1[ebp]
  0063e	50		 push	 eax
  0063f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 10088: 								pResult.Result = 4;
; 10089: 
; 10090: 								DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00644	0f b6 85 d9 fe
	ff ff		 movzx	 eax, BYTE PTR _pResult$1[ebp+1]
  0064b	50		 push	 eax
  0064c	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$1[ebp]
  00652	c6 85 db fe ff
	ff 04		 mov	 BYTE PTR _pResult$1[ebp+3], 4
  00659	50		 push	 eax
  0065a	53		 push	 ebx
  0065b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 10246: 					}
; 10247: 				}
; 10248: 			}
; 10249: 		}
; 10250: 	}
; 10251: }

  00660	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00663	83 c4 18	 add	 esp, 24			; 00000018H
  00666	33 cd		 xor	 ecx, ebp
  00668	5f		 pop	 edi
  00669	5e		 pop	 esi
  0066a	5b		 pop	 ebx
  0066b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00670	8b e5		 mov	 esp, ebp
  00672	5d		 pop	 ebp
  00673	c3		 ret	 0
?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ENDP ; GCGuildWarRequestSendRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildWarRequestSend@@YAXPADHH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_GuildName$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 4
?GCGuildWarRequestSend@@YAXPADHH@Z PROC			; GCGuildWarRequestSend, COMDAT

; 9963 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _GuildName$[ebp]

; 9964 : #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 9965 : 	PMSG_GUILDWARSEND pMsg;
; 9966 : 
; 9967 : 	PHeadSetB((LPBYTE)&pMsg, 0x61, sizeof(pMsg));

  00014	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 0c		 push	 12			; 0000000cH
  00019	6a 61		 push	 97			; 00000061H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9968 : 	pMsg.Type = type;

  00021	8a 45 10	 mov	 al, BYTE PTR _type$[ebp]
  00024	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 9969 : 	memcpy(pMsg.GuildName, GuildName, MAX_GUILD_LEN);

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	89 45 f3	 mov	 DWORD PTR _pMsg$[ebp+3], eax
  0002c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002f	89 45 f7	 mov	 DWORD PTR _pMsg$[ebp+7], eax

; 9970 : 
; 9971 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00032	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00036	50		 push	 eax
  00037	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003a	50		 push	 eax
  0003b	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  0003e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 9972 : 
; 9973 : 	// (%s) guild declared guild war
; 9974 : 	LogAddTD(lMsg.Get(MSGGET(1, 237)), GuildName);

  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0004b	56		 push	 esi
  0004c	68 ed 01 00 00	 push	 493			; 000001edH
  00051	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00056	50		 push	 eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9975 : #endif
; 9976 : }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	83 c4 08	 add	 esp, 8
  00063	33 cd		 xor	 ecx, ebp
  00065	5e		 pop	 esi
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?GCGuildWarRequestSend@@YAXPADHH@Z ENDP			; GCGuildWarRequestSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildWarRequestResult@@YAXPADHH@Z
_TEXT	SEGMENT
tv854 = -44						; size = 4
_lpNode$1$ = -40					; size = 4
tv860 = -36						; size = 4
tv898 = -32						; size = 4
_lpMyGuild$1$ = -28					; size = 4
_n$1$ = -24						; size = 4
_pMsg$ = -20						; size = 4
__guildname$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_GuildName$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 4
?GCGuildWarRequestResult@@YAXPADHH@Z PROC		; GCGuildWarRequestResult, COMDAT

; 9757 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 9758 : #if (GS_CASTLE == 1 && GS_SPEC != 1)
; 9759 : 	return;
; 9760 : #endif
; 9761 : 	PMSG_GUILDWARREQUEST_RESULT pMsg;
; 9762 : 
; 9763 : 	PHeadSetB((LPBYTE)&pMsg, 0x60, sizeof(pMsg));

  00014	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _GuildName$[ebp]
  0001b	6a 04		 push	 4
  0001d	6a 60		 push	 96			; 00000060H
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9764 : 	pMsg.Result = 3;
; 9765 : 
; 9766 : 	if ( gObj[aIndex].GuildNumber < 1)

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  00033	c6 45 ef 03	 mov	 BYTE PTR _pMsg$[ebp+3], 3
  00037	03 c1		 add	 eax, ecx
  00039	89 4d e0	 mov	 DWORD PTR tv898[ebp], ecx
  0003c	83 b8 14 06 00
	00 01		 cmp	 DWORD PTR [eax+1556], 1
  00043	7d 22		 jge	 SHORT $LN4@GCGuildWar
$LN90@GCGuildWar:

; 9767 : 	{
; 9768 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00045	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00049	50		 push	 eax
  0004a	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004d	50		 push	 eax
  0004e	53		 push	 ebx
  0004f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  00059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005c	33 cd		 xor	 ecx, ebp
  0005e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
$LN4@GCGuildWar:

; 9769 : 		return;
; 9770 : 	}
; 9771 : 
; 9772 : 	_GUILD_INFO_STRUCT * lpMyGuild = gObj[aIndex].lpGuild;

  00067	8b 88 18 06 00
	00		 mov	 ecx, DWORD PTR [eax+1560]
  0006d	89 4d e4	 mov	 DWORD PTR _lpMyGuild$1$[ebp], ecx

; 9773 : 
; 9774 : 	if ( !lpMyGuild )

  00070	85 c9		 test	 ecx, ecx
  00072	74 d1		 je	 SHORT $LN90@GCGuildWar

; 9775 : 	{
; 9776 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 9777 : 		return;
; 9778 : 	}
; 9779 : 
; 9780 : 	if ( lpMyGuild->WarState == 1 || lpMyGuild->WarDeclareState == 1 )

  00074	80 b9 91 05 00
	00 01		 cmp	 BYTE PTR [ecx+1425], 1
  0007b	0f 84 d3 04 00
	00		 je	 $LN7@GCGuildWar
  00081	80 b9 90 05 00
	00 01		 cmp	 BYTE PTR [ecx+1424], 1
  00088	0f 84 c6 04 00
	00		 je	 $LN7@GCGuildWar

; 9788 : 
; 9789 : 		return;
; 9790 : 	}
; 9791 : 
; 9792 : 	if ( gPkLimitFree == FALSE && gObj[aIndex].m_PK_Level >= 6)

  0008e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00095	75 42		 jne	 SHORT $LN8@GCGuildWar
  00097	80 b8 19 01 00
	00 06		 cmp	 BYTE PTR [eax+281], 6
  0009e	7c 39		 jl	 SHORT $LN8@GCGuildWar

; 9793 : 	{
; 9794 : 		pMsg.Result = 4;
; 9795 : 
; 9796 : 		LogAdd("Error on declaring war : GuildMaster Is Murderer 0x04 %s %s",

  000a0	83 c0 5d	 add	 eax, 93			; 0000005dH
  000a3	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  000a7	50		 push	 eax
  000a8	8d 41 2f	 lea	 eax, DWORD PTR [ecx+47]
  000ab	50		 push	 eax
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@KAENPAGM@Error?5on?5declaring?5war?5?3?5GuildMa@
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 9797 : 			lpMyGuild->Names[0], gObj[aIndex].Name);
; 9798 : 
; 9799 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000b7	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000bb	50		 push	 eax
  000bc	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000bf	50		 push	 eax
  000c0	53		 push	 ebx
  000c1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c6	83 c4 18	 add	 esp, 24			; 00000018H
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ce	33 cd		 xor	 ecx, ebp
  000d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
$LN8@GCGuildWar:
  000d9	57		 push	 edi

; 9800 : 
; 9801 : 		return;
; 9802 : 	}
; 9803 : 
; 9804 : 	if ( strcmp(lpMyGuild->Names[0], gObj[aIndex].Name ) )

  000da	8d 78 5d	 lea	 edi, DWORD PTR [eax+93]
  000dd	8d 41 2f	 lea	 eax, DWORD PTR [ecx+47]
  000e0	8b cf		 mov	 ecx, edi
  000e2	89 45 dc	 mov	 DWORD PTR tv860[ebp], eax
$LL75@GCGuildWar:
  000e5	8a 10		 mov	 dl, BYTE PTR [eax]
  000e7	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000e9	75 1a		 jne	 SHORT $LN76@GCGuildWar
  000eb	84 d2		 test	 dl, dl
  000ed	74 12		 je	 SHORT $LN77@GCGuildWar
  000ef	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000f2	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000f5	75 0e		 jne	 SHORT $LN76@GCGuildWar
  000f7	83 c0 02	 add	 eax, 2
  000fa	83 c1 02	 add	 ecx, 2
  000fd	84 d2		 test	 dl, dl
  000ff	75 e4		 jne	 SHORT $LL75@GCGuildWar
$LN77@GCGuildWar:
  00101	33 c0		 xor	 eax, eax
  00103	eb 05		 jmp	 SHORT $LN78@GCGuildWar
$LN76@GCGuildWar:
  00105	1b c0		 sbb	 eax, eax
  00107	83 c8 01	 or	 eax, 1
$LN78@GCGuildWar:
  0010a	85 c0		 test	 eax, eax
  0010c	74 1d		 je	 SHORT $LN9@GCGuildWar

; 9805 : 	{
; 9806 : 		pMsg.Result = 5;
; 9807 : 
; 9808 : 		LogAdd(lMsg.Get(MSGGET(1, 235)),

  0010e	57		 push	 edi
  0010f	ff 75 dc	 push	 DWORD PTR tv860[ebp]
  00112	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00117	c6 45 ef 05	 mov	 BYTE PTR _pMsg$[ebp+3], 5
  0011b	68 eb 01 00 00	 push	 491			; 000001ebH
  00120	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00125	50		 push	 eax

; 9809 : 			lpMyGuild->Names[0], gObj[aIndex].Name);
; 9810 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 9811 : 
; 9812 : 		return;

  00126	e9 46 01 00 00	 jmp	 $LN89@GCGuildWar
$LN9@GCGuildWar:

; 9813 : 	}
; 9814 : 
; 9815 : 	char _guildname[MAX_GUILD_LEN+1];
; 9816 : 	memset(_guildname, 0, sizeof(_guildname));
; 9817 : 	memcpy(_guildname, GuildName, MAX_GUILD_LEN);

  0012b	8b 06		 mov	 eax, DWORD PTR [esi]
  0012d	0f 57 c0	 xorps	 xmm0, xmm0

; 9818 : 
; 9819 : 	if ( !strncmp(lpMyGuild->Name, GuildName, MAX_GUILD_LEN))

  00130	8b 7d e4	 mov	 edi, DWORD PTR _lpMyGuild$1$[ebp]
  00133	6a 08		 push	 8
  00135	66 0f d6 45 f0	 movq	 QWORD PTR __guildname$[ebp], xmm0
  0013a	83 c7 04	 add	 edi, 4
  0013d	89 45 f0	 mov	 DWORD PTR __guildname$[ebp], eax
  00140	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00143	56		 push	 esi
  00144	57		 push	 edi
  00145	c6 45 f8 00	 mov	 BYTE PTR __guildname$[ebp+8], 0
  00149	89 45 f4	 mov	 DWORD PTR __guildname$[ebp+4], eax
  0014c	e8 00 00 00 00	 call	 _strncmp
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH
  00154	85 c0		 test	 eax, eax
  00156	74 5f		 je	 SHORT $LN84@GCGuildWar

; 9820 : 		return;
; 9821 : 
; 9822 : 	_GUILD_INFO_STRUCT * lpNode = Guild.SearchGuild(_guildname);

  00158	8d 45 f0	 lea	 eax, DWORD PTR __guildname$[ebp]
  0015b	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00166	8b d0		 mov	 edx, eax
  00168	89 55 d8	 mov	 DWORD PTR _lpNode$1$[ebp], edx

; 9823 : 
; 9824 : 	if ( lpNode )

  0016b	85 d2		 test	 edx, edx
  0016d	0f 84 ba 03 00
	00		 je	 $LN11@GCGuildWar

; 9825 : 	{
; 9826 : 		if ( lpNode->WarState == 1 || lpNode->WarDeclareState == 1 )

  00173	80 ba 91 05 00
	00 01		 cmp	 BYTE PTR [edx+1425], 1
  0017a	0f 84 5c 03 00
	00		 je	 $LN14@GCGuildWar
  00180	80 ba 90 05 00
	00 01		 cmp	 BYTE PTR [edx+1424], 1
  00187	0f 84 4f 03 00
	00		 je	 $LN14@GCGuildWar

; 9834 : 
; 9835 : 			return;
; 9836 : 		}
; 9837 : 
; 9838 : 		if ( lpMyGuild->iGuildUnion != 0 && lpMyGuild->iGuildUnion == lpNode->iGuildUnion )

  0018d	8b 45 e4	 mov	 eax, DWORD PTR _lpMyGuild$1$[ebp]
  00190	8b 88 44 07 00
	00		 mov	 ecx, DWORD PTR [eax+1860]
  00196	85 c9		 test	 ecx, ecx
  00198	74 2e		 je	 SHORT $LN15@GCGuildWar
  0019a	3b 8a 44 07 00
	00		 cmp	 ecx, DWORD PTR [edx+1860]
  001a0	75 26		 jne	 SHORT $LN15@GCGuildWar

; 9839 : 		{
; 9840 : 			LogAddTD("[U.System][Guildwar] Can't declare guildwar between Same Union (%s / %d) <-> (%s / %d)",

  001a2	51		 push	 ecx
  001a3	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  001a6	50		 push	 eax
  001a7	51		 push	 ecx
  001a8	57		 push	 edi
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@HAMEKJOJ@?$FLU?4System?$FN?$FLGuildwar?$FN?5Can?8t?5decla@
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001b4	83 c4 14	 add	 esp, 20			; 00000014H
$LN84@GCGuildWar:
  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  001ba	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bd	33 cd		 xor	 ecx, ebp
  001bf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
$LN15@GCGuildWar:

; 9841 : 				lpMyGuild->Name, lpMyGuild->iGuildUnion, lpNode->Name, lpMyGuild->iGuildUnion);
; 9842 : 
; 9843 : 			return;
; 9844 : 		}
; 9845 : 
; 9846 : 		int n=OBJ_STARTUSERINDEX;	// #warning Change this 0 to OBJ_STARTUSERINDEX

  001c8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 9854 : 				{
; 9855 : 					if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  001ce	83 c2 2f	 add	 edx, 47			; 0000002fH
  001d1	b9 04 29 00 00	 mov	 ecx, 10500		; 00002904H
  001d6	89 55 d4	 mov	 DWORD PTR tv854[ebp], edx
  001d9	81 c6 5d dd 49
	06		 add	 esi, 105504093		; 0649dd5dH
$LN85@GCGuildWar:

; 9841 : 				lpMyGuild->Name, lpMyGuild->iGuildUnion, lpNode->Name, lpMyGuild->iGuildUnion);
; 9842 : 
; 9843 : 			return;
; 9844 : 		}
; 9845 : 
; 9846 : 		int n=OBJ_STARTUSERINDEX;	// #warning Change this 0 to OBJ_STARTUSERINDEX

  001df	80 7e f3 01	 cmp	 BYTE PTR [esi-13], 1
  001e3	89 4d e8	 mov	 DWORD PTR _n$1$[ebp], ecx

; 9847 : 		int warmaster=-1;
; 9848 : 
; 9849 : 		while ( true )
; 9850 : 		{
; 9851 : 			if ( gObj[n].Type == OBJ_USER )

  001e6	75 3f		 jne	 SHORT $LN19@GCGuildWar

; 9852 : 			{
; 9853 : 				if ( gObj[n].Connected > PLAYER_LOGGED )

  001e8	83 7e a7 02	 cmp	 DWORD PTR [esi-89], 2
  001ec	7e 39		 jle	 SHORT $LN19@GCGuildWar

; 9854 : 				{
; 9855 : 					if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  001ee	8a 06		 mov	 al, BYTE PTR [esi]
  001f0	3a 02		 cmp	 al, BYTE PTR [edx]
  001f2	75 33		 jne	 SHORT $LN19@GCGuildWar

; 9856 : 					{
; 9857 : 						if ( !strcmp(gObj[n].Name, lpNode->Names[0]))

  001f4	8b ca		 mov	 ecx, edx
  001f6	8b c6		 mov	 eax, esi
$LL79@GCGuildWar:
  001f8	8a 10		 mov	 dl, BYTE PTR [eax]
  001fa	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001fc	75 1a		 jne	 SHORT $LN80@GCGuildWar
  001fe	84 d2		 test	 dl, dl
  00200	74 12		 je	 SHORT $LN81@GCGuildWar
  00202	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00205	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00208	75 0e		 jne	 SHORT $LN80@GCGuildWar
  0020a	83 c0 02	 add	 eax, 2
  0020d	83 c1 02	 add	 ecx, 2
  00210	84 d2		 test	 dl, dl
  00212	75 e4		 jne	 SHORT $LL79@GCGuildWar
$LN81@GCGuildWar:
  00214	33 c0		 xor	 eax, eax
  00216	eb 05		 jmp	 SHORT $LN82@GCGuildWar
$LN80@GCGuildWar:
  00218	1b c0		 sbb	 eax, eax
  0021a	83 c8 01	 or	 eax, 1
$LN82@GCGuildWar:
  0021d	85 c0		 test	 eax, eax
  0021f	74 1b		 je	 SHORT $LN60@GCGuildWar
  00221	8b 4d e8	 mov	 ecx, DWORD PTR _n$1$[ebp]
  00224	8b 55 d4	 mov	 edx, DWORD PTR tv854[ebp]
$LN19@GCGuildWar:

; 9867 : 
; 9868 : 								return;
; 9869 : 							}
; 9870 : 
; 9871 : 							warmaster = n;
; 9872 : 							break;
; 9873 : 						}
; 9874 : 					}
; 9875 : 				}
; 9876 : 			}
; 9877 : 
; 9878 : 			if ( n < OBJMAX-1 )

  00227	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  0022d	0f 8d a3 02 00
	00		 jge	 $LN23@GCGuildWar

; 9879 : 				n++;

  00233	41		 inc	 ecx
  00234	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H

; 9880 : 			else
; 9881 : 				break;
; 9882 : 		}

  0023a	eb a3		 jmp	 SHORT $LN85@GCGuildWar
$LN60@GCGuildWar:

; 9858 : 						{
; 9859 : 							if ( gPkLimitFree == FALSE && gObj[n].m_PK_Level >= 6)

  0023c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00243	8b 55 e8	 mov	 edx, DWORD PTR _n$1$[ebp]
  00246	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024c	75 4c		 jne	 SHORT $LN20@GCGuildWar
  0024e	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  00254	80 bc 30 19 01
	00 00 06	 cmp	 BYTE PTR [eax+esi+281], 6
  0025c	7c 3c		 jl	 SHORT $LN20@GCGuildWar

; 9860 : 							{
; 9861 : 								pMsg.Result = 4;
; 9862 : 
; 9863 : 								LogAdd("Error on declaring war : Target GuildMaster Is Murderer 0x04 %s %s",

  0025e	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00261	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  00265	03 45 e0	 add	 eax, DWORD PTR tv898[ebp]
  00268	50		 push	 eax
  00269	ff 75 dc	 push	 DWORD PTR tv860[ebp]
  0026c	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@OFKACPCN@Error?5on?5declaring?5war?5?3?5Target?5@
$LN89@GCGuildWar:
  00271	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 9864 : 									lpMyGuild->Names[0], gObj[aIndex].Name);
; 9865 : 
; 9866 : 								DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00277	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0027b	50		 push	 eax
  0027c	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0027f	50		 push	 eax
  00280	53		 push	 ebx
  00281	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00286	83 c4 18	 add	 esp, 24			; 00000018H
  00289	5f		 pop	 edi
  0028a	5e		 pop	 esi
  0028b	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  0028c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0028f	33 cd		 xor	 ecx, ebp
  00291	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00296	8b e5		 mov	 esp, ebp
  00298	5d		 pop	 ebp
  00299	c3		 ret	 0
$LN20@GCGuildWar:

; 9883 : 		
; 9884 : 		if ( warmaster >= 1 )

  0029a	83 fa 01	 cmp	 edx, 1
  0029d	0f 8c 33 02 00
	00		 jl	 $LN23@GCGuildWar

; 9885 : 		{
; 9886 : 			if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) || CC_MAP_RANGE(gObj[warmaster].MapNumber) )

  002a3	8b 45 e0	 mov	 eax, DWORD PTR tv898[ebp]
  002a6	8a 8c 30 23 01
	00 00		 mov	 cl, BYTE PTR [eax+esi+291]
  002ad	80 f9 35	 cmp	 cl, 53			; 00000035H
  002b0	0f 84 f4 01 00
	00		 je	 $LN26@GCGuildWar
  002b6	80 f9 12	 cmp	 cl, 18			; 00000012H
  002b9	72 0f		 jb	 SHORT $LN67@GCGuildWar
  002bb	b0 17		 mov	 al, 23			; 00000017H
  002bd	3a c1		 cmp	 al, cl
  002bf	1b c0		 sbb	 eax, eax
  002c1	83 c0 01	 add	 eax, 1
  002c4	0f 85 e0 01 00
	00		 jne	 $LN26@GCGuildWar
$LN67@GCGuildWar:
  002ca	69 c2 40 27 00
	00		 imul	 eax, edx, 10048
  002d0	8a 94 06 23 01
	00 00		 mov	 dl, BYTE PTR [esi+eax+291]
  002d7	03 f0		 add	 esi, eax
  002d9	80 fa 35	 cmp	 dl, 53			; 00000035H
  002dc	0f 84 c8 01 00
	00		 je	 $LN26@GCGuildWar
  002e2	80 fa 12	 cmp	 dl, 18			; 00000012H
  002e5	72 0f		 jb	 SHORT $LN68@GCGuildWar
  002e7	b0 17		 mov	 al, 23			; 00000017H
  002e9	3a c2		 cmp	 al, dl
  002eb	1b c0		 sbb	 eax, eax
  002ed	83 c0 01	 add	 eax, 1
  002f0	0f 85 b4 01 00
	00		 jne	 $LN26@GCGuildWar
$LN68@GCGuildWar:

; 9889 : 				return;
; 9890 : 			}
; 9891 : 
; 9892 : 			if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) || IT_MAP_RANGE(gObj[warmaster].MapNumber) )

  002f6	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  002f9	72 0b		 jb	 SHORT $LN69@GCGuildWar
  002fb	b0 32		 mov	 al, 50			; 00000032H
  002fd	3a c1		 cmp	 al, cl
  002ff	1b c0		 sbb	 eax, eax
  00301	83 c0 01	 add	 eax, 1
  00304	75 10		 jne	 SHORT $LN28@GCGuildWar
$LN69@GCGuildWar:
  00306	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00309	72 2c		 jb	 SHORT $LN70@GCGuildWar
  0030b	b0 32		 mov	 al, 50			; 00000032H
  0030d	3a c2		 cmp	 al, dl
  0030f	1b c0		 sbb	 eax, eax
  00311	83 c0 01	 add	 eax, 1
  00314	74 21		 je	 SHORT $LN70@GCGuildWar
$LN28@GCGuildWar:

; 9893 : 			{
; 9894 : 				GCServerMsgStringSend("Guild War cannot be started within Illusion Temple.", aIndex, 1);

  00316	6a 01		 push	 1
  00318	53		 push	 ebx
  00319	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@OPCGOEPD@Guild?5War?5cannot?5be?5started?5with@
  0031e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 9946 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00323	83 c4 0c	 add	 esp, 12			; 0000000cH
  00326	5f		 pop	 edi
  00327	5e		 pop	 esi
  00328	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  00329	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032c	33 cd		 xor	 ecx, ebp
  0032e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00333	8b e5		 mov	 esp, ebp
  00335	5d		 pop	 ebp
  00336	c3		 ret	 0
$LN70@GCGuildWar:

; 9895 : 				return;
; 9896 : 			}
; 9897 : 
; 9898 : 			if ( DG_MAP_RANGE(gObj[aIndex].MapNumber) || DG_MAP_RANGE(gObj[warmaster].MapNumber) )

  00337	80 f9 41	 cmp	 cl, 65			; 00000041H
  0033a	72 0e		 jb	 SHORT $LN71@GCGuildWar
  0033c	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  00341	3a c1		 cmp	 al, cl
  00343	1b c0		 sbb	 eax, eax
  00345	83 c0 01	 add	 eax, 1
  00348	75 10		 jne	 SHORT $LN30@GCGuildWar
$LN71@GCGuildWar:
  0034a	80 fa 41	 cmp	 dl, 65			; 00000041H
  0034d	72 2c		 jb	 SHORT $LN72@GCGuildWar
  0034f	b0 44		 mov	 al, 68			; 00000044H
  00351	3a c2		 cmp	 al, dl
  00353	1b c0		 sbb	 eax, eax
  00355	83 c0 01	 add	 eax, 1
  00358	74 21		 je	 SHORT $LN72@GCGuildWar
$LN30@GCGuildWar:

; 9899 : 			{
; 9900 : 				GCServerMsgStringSend("Guild War cannot be started within Doppelganger.", aIndex, 1);

  0035a	6a 01		 push	 1
  0035c	53		 push	 ebx
  0035d	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@IJAALLLN@Guild?5War?5cannot?5be?5started?5with@
  00362	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 9946 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00367	83 c4 0c	 add	 esp, 12			; 0000000cH
  0036a	5f		 pop	 edi
  0036b	5e		 pop	 esi
  0036c	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  0036d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00370	33 cd		 xor	 ecx, ebp
  00372	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00377	8b e5		 mov	 esp, ebp
  00379	5d		 pop	 ebp
  0037a	c3		 ret	 0
$LN72@GCGuildWar:

; 9901 : 				return;
; 9902 : 			}
; 9903 : 
; 9904 : 			if ( IF_MAP_RANGE(gObj[aIndex].MapNumber) || IF_MAP_RANGE(gObj[warmaster].MapNumber) )

  0037b	80 f9 45	 cmp	 cl, 69			; 00000045H
  0037e	72 0e		 jb	 SHORT $LN73@GCGuildWar
  00380	b8 48 00 00 00	 mov	 eax, 72			; 00000048H
  00385	3a c1		 cmp	 al, cl
  00387	1b c0		 sbb	 eax, eax
  00389	83 c0 01	 add	 eax, 1
  0038c	75 10		 jne	 SHORT $LN32@GCGuildWar
$LN73@GCGuildWar:
  0038e	80 fa 45	 cmp	 dl, 69			; 00000045H
  00391	72 2c		 jb	 SHORT $LN74@GCGuildWar
  00393	b0 48		 mov	 al, 72			; 00000048H
  00395	3a c2		 cmp	 al, dl
  00397	1b c0		 sbb	 eax, eax
  00399	83 c0 01	 add	 eax, 1
  0039c	74 21		 je	 SHORT $LN74@GCGuildWar
$LN32@GCGuildWar:

; 9905 : 			{
; 9906 : 				GCServerMsgStringSend("Guild War cannot be started within Imperial Fort.", aIndex, 1);

  0039e	6a 01		 push	 1
  003a0	53		 push	 ebx
  003a1	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@ENCBPHMM@Guild?5War?5cannot?5be?5started?5with@
  003a6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 9946 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  003ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ae	5f		 pop	 edi
  003af	5e		 pop	 esi
  003b0	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  003b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b4	33 cd		 xor	 ecx, ebp
  003b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003bb	8b e5		 mov	 esp, ebp
  003bd	5d		 pop	 ebp
  003be	c3		 ret	 0
$LN74@GCGuildWar:

; 9907 : 				return;
; 9908 : 			}
; 9909 : 
; 9910 : 			if ( (gObj[warmaster].m_Option&1) != 1 )

  003bf	f6 86 24 12 00
	00 01		 test	 BYTE PTR [esi+4644], 1

; 9911 : 			{
; 9912 : 				pMsg.Result = 4;
; 9913 : 				DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  003c6	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  003ca	50		 push	 eax
  003cb	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  003ce	50		 push	 eax
  003cf	53		 push	 ebx
  003d0	75 1d		 jne	 SHORT $LN33@GCGuildWar

; 9946 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  003d2	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  003d6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003db	83 c4 0c	 add	 esp, 12			; 0000000cH
  003de	5f		 pop	 edi
  003df	5e		 pop	 esi
  003e0	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  003e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003e4	33 cd		 xor	 ecx, ebp
  003e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003eb	8b e5		 mov	 esp, ebp
  003ed	5d		 pop	 ebp
  003ee	c3		 ret	 0
$LN33@GCGuildWar:

; 9914 : 
; 9915 : 				return;
; 9916 : 			}
; 9917 : 
; 9918 : 			pMsg.Result = 1;

  003ef	c6 45 ef 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1

; 9919 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  003f3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9920 : 			GCGuildWarRequestSend(lpMyGuild->Name, warmaster, type);

  003f8	8b 5d 10	 mov	 ebx, DWORD PTR _type$[ebp]
  003fb	53		 push	 ebx
  003fc	ff 75 e8	 push	 DWORD PTR _n$1$[ebp]
  003ff	57		 push	 edi
  00400	e8 00 00 00 00	 call	 ?GCGuildWarRequestSend@@YAXPADHH@Z ; GCGuildWarRequestSend

; 9921 : 			lpMyGuild->WarDeclareState = 1;

  00405	8b 4d e4	 mov	 ecx, DWORD PTR _lpMyGuild$1$[ebp]
  00408	83 c4 18	 add	 esp, 24			; 00000018H

; 9922 : 			lpNode->WarDeclareState = 1;

  0040b	8b 45 d8	 mov	 eax, DWORD PTR _lpNode$1$[ebp]
  0040e	c6 81 90 05 00
	00 01		 mov	 BYTE PTR [ecx+1424], 1
  00415	c6 80 90 05 00
	00 01		 mov	 BYTE PTR [eax+1424], 1

; 9923 : 			lpMyGuild->WarType = type;

  0041c	88 99 92 05 00
	00		 mov	 BYTE PTR [ecx+1426], bl

; 9924 : 			lpNode->WarType = type;
; 9925 : 
; 9926 : 			// Declared guild war [%s][%s] sGuild:(%s) TargetGuild:(%s)
; 9927 : 			LogAddTD(lMsg.Get(MSGGET(1, 236)), gObj[aIndex].AccountID, gObj[aIndex].Name,

  00422	8b 4d e0	 mov	 ecx, DWORD PTR tv898[ebp]
  00425	88 98 92 05 00
	00		 mov	 BYTE PTR [eax+1426], bl
  0042b	8b d8		 mov	 ebx, eax
  0042d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00433	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  00436	56		 push	 esi
  00437	57		 push	 edi
  00438	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0043b	50		 push	 eax
  0043c	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0043f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00444	50		 push	 eax
  00445	68 ec 01 00 00	 push	 492			; 000001ecH
  0044a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0044f	50		 push	 eax
  00450	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 9928 : 				lpMyGuild->Name, lpNode->Name);
; 9929 : 
; 9930 : 			strcpy(lpMyGuild->TargetGuildName, lpNode->Name);

  00456	8b 55 e4	 mov	 edx, DWORD PTR _lpMyGuild$1$[ebp]
  00459	83 c4 14	 add	 esp, 20			; 00000014H
  0045c	8d 8a e0 04 00
	00		 lea	 ecx, DWORD PTR [edx+1248]
  00462	2b ce		 sub	 ecx, esi
$LL55@GCGuildWar:
  00464	8a 06		 mov	 al, BYTE PTR [esi]
  00466	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00469	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  0046d	84 c0		 test	 al, al
  0046f	75 f3		 jne	 SHORT $LL55@GCGuildWar

; 9931 : 			strcpy(lpNode->TargetGuildName, lpMyGuild->Name);

  00471	8d 8b e0 04 00
	00		 lea	 ecx, DWORD PTR [ebx+1248]
  00477	2b cf		 sub	 ecx, edi
  00479	0f 1f 80 00 00
	00 00		 npad	 7
$LL56@GCGuildWar:
  00480	8a 07		 mov	 al, BYTE PTR [edi]
  00482	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00485	88 44 39 ff	 mov	 BYTE PTR [ecx+edi-1], al
  00489	84 c0		 test	 al, al
  0048b	75 f3		 jne	 SHORT $LL56@GCGuildWar

; 9932 : 			lpMyGuild->lpTargetGuildNode = lpNode;

  0048d	5f		 pop	 edi
  0048e	89 9a 8c 05 00
	00		 mov	 DWORD PTR [edx+1420], ebx
  00494	5e		 pop	 esi

; 9933 : 			lpNode->lpTargetGuildNode = lpMyGuild;

  00495	89 93 8c 05 00
	00		 mov	 DWORD PTR [ebx+1420], edx
  0049b	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  0049c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0049f	33 cd		 xor	 ecx, ebp
  004a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a6	8b e5		 mov	 esp, ebp
  004a8	5d		 pop	 ebp
  004a9	c3		 ret	 0
$LN26@GCGuildWar:

; 9887 : 			{
; 9888 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(4, 199)), aIndex, 1);

  004aa	6a 01		 push	 1
  004ac	53		 push	 ebx
  004ad	68 c7 04 00 00	 push	 1223			; 000004c7H
  004b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004b7	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  004bc	50		 push	 eax
  004bd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 9946 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  004c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c5	5f		 pop	 edi
  004c6	5e		 pop	 esi
  004c7	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  004c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004cb	33 cd		 xor	 ecx, ebp
  004cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004d2	8b e5		 mov	 esp, ebp
  004d4	5d		 pop	 ebp
  004d5	c3		 ret	 0
$LN23@GCGuildWar:

; 9934 : 		}
; 9935 : 		else
; 9936 : 		{
; 9937 : 			pMsg.Result = 2;

  004d6	c6 45 ef 02	 mov	 BYTE PTR _pMsg$[ebp+3], 2

; 9938 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 9939 : 
; 9940 : 			//return;
; 9941 : 		}
; 9942 : 	}
; 9943 : 	else

  004da	eb 55		 jmp	 SHORT $LN86@GCGuildWar
$LN14@GCGuildWar:

; 9827 : 		{
; 9828 : 			pMsg.Result = 4;
; 9829 : 
; 9830 : 			//Error on declaring war : %d %d %s
; 9831 : 			LogAdd(lMsg.Get(MSGGET(1, 234)), lpNode->WarState,

  004dc	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  004df	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  004e3	50		 push	 eax
  004e4	0f b6 82 90 05
	00 00		 movzx	 eax, BYTE PTR [edx+1424]
  004eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004f0	50		 push	 eax
  004f1	0f b6 82 91 05
	00 00		 movzx	 eax, BYTE PTR [edx+1425]
  004f8	50		 push	 eax
  004f9	68 ea 01 00 00	 push	 490			; 000001eaH
  004fe	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00503	50		 push	 eax
  00504	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 9832 : 				lpNode->WarDeclareState, lpNode->Name);
; 9833 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0050a	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0050e	50		 push	 eax
  0050f	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00512	50		 push	 eax
  00513	53		 push	 ebx
  00514	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00519	83 c4 1c	 add	 esp, 28			; 0000001cH
  0051c	5f		 pop	 edi
  0051d	5e		 pop	 esi
  0051e	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  0051f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00522	33 cd		 xor	 ecx, ebp
  00524	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00529	8b e5		 mov	 esp, ebp
  0052b	5d		 pop	 ebp
  0052c	c3		 ret	 0
$LN11@GCGuildWar:

; 9944 : 	{
; 9945 : 		pMsg.Result = 0;

  0052d	c6 45 ef 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
$LN86@GCGuildWar:

; 9946 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00531	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00535	50		 push	 eax
  00536	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00539	50		 push	 eax
  0053a	53		 push	 ebx
  0053b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00540	83 c4 0c	 add	 esp, 12			; 0000000cH
  00543	5f		 pop	 edi
  00544	5e		 pop	 esi
  00545	5b		 pop	 ebx

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  00546	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00549	33 cd		 xor	 ecx, ebp
  0054b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00550	8b e5		 mov	 esp, ebp
  00552	5d		 pop	 ebp
  00553	c3		 ret	 0
$LN7@GCGuildWar:

; 9781 : 	{
; 9782 : 		pMsg.Result = 4;
; 9783 : 
; 9784 : 		//Error on declaring war : %d %d %s
; 9785 : 		LogAdd(lMsg.Get(MSGGET(1, 234)), lpMyGuild->WarState,

  00554	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00557	c6 45 ef 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4
  0055b	50		 push	 eax
  0055c	0f b6 81 90 05
	00 00		 movzx	 eax, BYTE PTR [ecx+1424]
  00563	50		 push	 eax
  00564	0f b6 81 91 05
	00 00		 movzx	 eax, BYTE PTR [ecx+1425]
  0056b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00570	50		 push	 eax
  00571	68 ea 01 00 00	 push	 490			; 000001eaH
  00576	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0057b	50		 push	 eax
  0057c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 9786 : 			lpMyGuild->WarDeclareState, lpMyGuild->Name);
; 9787 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00582	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00586	50		 push	 eax
  00587	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0058a	50		 push	 eax
  0058b	53		 push	 ebx
  0058c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9947 : 
; 9948 : 		return;
; 9949 : 	}
; 9950 : }

  00591	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00594	83 c4 1c	 add	 esp, 28			; 0000001cH
  00597	33 cd		 xor	 ecx, ebp
  00599	5e		 pop	 esi
  0059a	5b		 pop	 ebx
  0059b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005a0	8b e5		 mov	 esp, ebp
  005a2	5d		 pop	 ebp
  005a3	c3		 ret	 0
?GCGuildWarRequestResult@@YAXPADHH@Z ENDP		; GCGuildWarRequestResult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCManagerGuildWarSet@@YAXPAD0H@Z
_TEXT	SEGMENT
_GuildName1$ = 8					; size = 4
_GuildName2$ = 12					; size = 4
_type$ = 16						; size = 4
?GCManagerGuildWarSet@@YAXPAD0H@Z PROC			; GCManagerGuildWarSet, COMDAT

; 9703 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 9704 : 	_GUILD_INFO_STRUCT * lpNode = Guild.SearchGuild(GuildName1);

  00003	ff 75 08	 push	 DWORD PTR _GuildName1$[ebp]
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  0000b	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild

; 9705 : 
; 9706 : 	if ( lpNode == NULL )

  00010	85 c0		 test	 eax, eax
  00012	74 7d		 je	 SHORT $LN11@GCManagerG

; 9707 : 	{
; 9708 : 		return;
; 9709 : 	}
; 9710 : 
; 9711 : 	int n=0;

  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 9719 : 			{
; 9720 : 				if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  0001c	8d 58 2f	 lea	 ebx, DWORD PTR [eax+47]
  0001f	57		 push	 edi
  00020	33 ff		 xor	 edi, edi
  00022	83 c6 5d	 add	 esi, 93			; 0000005dH
$LL2@GCManagerG:

; 9712 : 	int warmaster = -1;
; 9713 : 
; 9714 : 	while ( true )
; 9715 : 	{
; 9716 : 		if ( gObj[n].Type == OBJ_USER )

  00025	80 7e f3 01	 cmp	 BYTE PTR [esi-13], 1
  00029	75 3e		 jne	 SHORT $LN8@GCManagerG

; 9717 : 		{
; 9718 : 			if ( gObj[n].Connected > PLAYER_LOGGED )

  0002b	83 7e a7 02	 cmp	 DWORD PTR [esi-89], 2
  0002f	7e 38		 jle	 SHORT $LN8@GCManagerG

; 9719 : 			{
; 9720 : 				if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  00031	8a 06		 mov	 al, BYTE PTR [esi]
  00033	3a 03		 cmp	 al, BYTE PTR [ebx]
  00035	75 32		 jne	 SHORT $LN8@GCManagerG

; 9721 : 				{
; 9722 : 					if ( strcmp(gObj[n].Name, lpNode->Names[0]) == 0 )

  00037	8b c3		 mov	 eax, ebx
  00039	8b ce		 mov	 ecx, esi
  0003b	0f 1f 44 00 00	 npad	 5
$LL17@GCManagerG:
  00040	8a 11		 mov	 dl, BYTE PTR [ecx]
  00042	3a 10		 cmp	 dl, BYTE PTR [eax]
  00044	75 1a		 jne	 SHORT $LN18@GCManagerG
  00046	84 d2		 test	 dl, dl
  00048	74 12		 je	 SHORT $LN19@GCManagerG
  0004a	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  0004d	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00050	75 0e		 jne	 SHORT $LN18@GCManagerG
  00052	83 c1 02	 add	 ecx, 2
  00055	83 c0 02	 add	 eax, 2
  00058	84 d2		 test	 dl, dl
  0005a	75 e4		 jne	 SHORT $LL17@GCManagerG
$LN19@GCManagerG:
  0005c	33 c0		 xor	 eax, eax
  0005e	eb 05		 jmp	 SHORT $LN20@GCManagerG
$LN18@GCManagerG:
  00060	1b c0		 sbb	 eax, eax
  00062	83 c8 01	 or	 eax, 1
$LN20@GCManagerG:
  00065	85 c0		 test	 eax, eax
  00067	74 11		 je	 SHORT $LN14@GCManagerG
$LN8@GCManagerG:

; 9723 : 					{
; 9724 : 						warmaster = n;
; 9725 : 						break;
; 9726 : 					}
; 9727 : 				}
; 9728 : 			}
; 9729 : 		}
; 9730 : 
; 9731 : 		if ( n < OBJMAX-1 )

  00069	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0006f	7d 1d		 jge	 SHORT $LN21@GCManagerG

; 9732 : 		{
; 9733 : 			n++;

  00071	47		 inc	 edi
  00072	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H

; 9734 : 		}
; 9735 : 		else
; 9736 : 		{
; 9737 : 			break;
; 9738 : 		}
; 9739 : 	}

  00078	eb ab		 jmp	 SHORT $LL2@GCManagerG
$LN14@GCManagerG:

; 9740 : 
; 9741 : 	if ( warmaster >= 1 )

  0007a	83 ff 01	 cmp	 edi, 1
  0007d	7c 0f		 jl	 SHORT $LN21@GCManagerG

; 9742 : 	{
; 9743 : 		::GCGuildWarRequestResult(GuildName2, warmaster, type);

  0007f	ff 75 10	 push	 DWORD PTR _type$[ebp]
  00082	57		 push	 edi
  00083	ff 75 0c	 push	 DWORD PTR _GuildName2$[ebp]
  00086	e8 00 00 00 00	 call	 ?GCGuildWarRequestResult@@YAXPADHH@Z ; GCGuildWarRequestResult
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@GCManagerG:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
$LN11@GCManagerG:

; 9744 : 	}
; 9745 : }

  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?GCManagerGuildWarSet@@YAXPAD0H@Z ENDP			; GCManagerGuildWarSet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCManagerGuildWarEnd@@YAXPAD@Z
_TEXT	SEGMENT
_Result1$1 = -8						; size = 1
_Result2$2 = -4						; size = 1
_GuildName$ = 8						; size = 4
?GCManagerGuildWarEnd@@YAXPAD@Z PROC			; GCManagerGuildWarEnd, COMDAT

; 9623 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 9624 : 	_GUILD_INFO_STRUCT * lpNode = Guild.SearchGuild(GuildName);

  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  0000b	53		 push	 ebx
  0000c	ff 75 08	 push	 DWORD PTR _GuildName$[ebp]
  0000f	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild
  00014	8b d8		 mov	 ebx, eax

; 9625 : 
; 9626 : 	if ( lpNode == NULL )

  00016	85 db		 test	 ebx, ebx
  00018	0f 84 06 01 00
	00		 je	 $LN17@GCManagerG

; 9627 : 	{
; 9628 : 		return;
; 9629 : 	}
; 9630 : 
; 9631 : 	int n=0;

  0001e	56		 push	 esi
  0001f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 9639 : 			{
; 9640 : 				if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  00025	8d 53 2f	 lea	 edx, DWORD PTR [ebx+47]
  00028	57		 push	 edi
  00029	33 ff		 xor	 edi, edi
  0002b	83 c6 5d	 add	 esi, 93			; 0000005dH
  0002e	66 90		 npad	 2
$LL2@GCManagerG:

; 9632 : 	int warmaster = -1;
; 9633 : 
; 9634 : 	while ( true )
; 9635 : 	{
; 9636 : 		if ( gObj[n].Type == OBJ_USER )

  00030	80 7e f3 01	 cmp	 BYTE PTR [esi-13], 1
  00034	75 3c		 jne	 SHORT $LN8@GCManagerG

; 9637 : 		{
; 9638 : 			if ( gObj[n].Connected > PLAYER_LOGGED )

  00036	83 7e a7 02	 cmp	 DWORD PTR [esi-89], 2
  0003a	7e 36		 jle	 SHORT $LN8@GCManagerG

; 9639 : 			{
; 9640 : 				if ( gObj[n].Name[0] == lpNode->Names[0][0] )

  0003c	8a 06		 mov	 al, BYTE PTR [esi]
  0003e	3a 02		 cmp	 al, BYTE PTR [edx]
  00040	75 30		 jne	 SHORT $LN8@GCManagerG

; 9641 : 				{
; 9642 : 					if ( strcmp(gObj[n].Name, lpNode->Names[0]) == 0 )

  00042	8b c2		 mov	 eax, edx
  00044	8b ce		 mov	 ecx, esi
$LL23@GCManagerG:
  00046	8a 11		 mov	 dl, BYTE PTR [ecx]
  00048	3a 10		 cmp	 dl, BYTE PTR [eax]
  0004a	75 1a		 jne	 SHORT $LN24@GCManagerG
  0004c	84 d2		 test	 dl, dl
  0004e	74 12		 je	 SHORT $LN25@GCManagerG
  00050	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00053	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00056	75 0e		 jne	 SHORT $LN24@GCManagerG
  00058	83 c1 02	 add	 ecx, 2
  0005b	83 c0 02	 add	 eax, 2
  0005e	84 d2		 test	 dl, dl
  00060	75 e4		 jne	 SHORT $LL23@GCManagerG
$LN25@GCManagerG:
  00062	33 c0		 xor	 eax, eax
  00064	eb 05		 jmp	 SHORT $LN26@GCManagerG
$LN24@GCManagerG:
  00066	1b c0		 sbb	 eax, eax
  00068	83 c8 01	 or	 eax, 1
$LN26@GCManagerG:
  0006b	85 c0		 test	 eax, eax
  0006d	74 18		 je	 SHORT $LN20@GCManagerG
  0006f	8d 53 2f	 lea	 edx, DWORD PTR [ebx+47]
$LN8@GCManagerG:

; 9643 : 					{
; 9644 : 						warmaster = n;
; 9645 : 						break;
; 9646 : 					}
; 9647 : 				}
; 9648 : 			}
; 9649 : 		}
; 9650 : 
; 9651 : 		if ( n < OBJMAX-1 )

  00072	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00078	0f 8d a4 00 00
	00		 jge	 $LN27@GCManagerG

; 9652 : 		{
; 9653 : 			n++;

  0007e	47		 inc	 edi
  0007f	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H

; 9654 : 		}
; 9655 : 		else
; 9656 : 		{
; 9657 : 			break;
; 9658 : 		}
; 9659 : 	}

  00085	eb a9		 jmp	 SHORT $LL2@GCManagerG
$LN20@GCManagerG:

; 9660 : 
; 9661 : 	if ( warmaster >= 1 )

  00087	83 ff 01	 cmp	 edi, 1
  0008a	0f 8c 92 00 00
	00		 jl	 $LN27@GCManagerG

; 9662 : 	{
; 9663 : 		BYTE Result1 = 0;
; 9664 : 		BYTE Result2 = 0;
; 9665 : 
; 9666 : 		if ( lpNode != NULL )
; 9667 : 		{
; 9668 : 			if ( lpNode->lpTargetGuildNode != NULL )

  00090	8b 83 8c 05 00
	00		 mov	 eax, DWORD PTR [ebx+1420]
  00096	c6 45 f8 00	 mov	 BYTE PTR _Result1$1[ebp], 0
  0009a	c6 45 fc 00	 mov	 BYTE PTR _Result2$2[ebp], 0
  0009e	85 c0		 test	 eax, eax
  000a0	74 24		 je	 SHORT $LN15@GCManagerG

; 9669 : 			{
; 9670 : 				if ( lpNode->PlayScore == 0 && lpNode->lpTargetGuildNode->PlayScore == 0 )

  000a2	80 bb 95 05 00
	00 00		 cmp	 BYTE PTR [ebx+1429], 0
  000a9	75 13		 jne	 SHORT $LN14@GCManagerG
  000ab	80 b8 95 05 00
	00 00		 cmp	 BYTE PTR [eax+1429], 0
  000b2	75 0a		 jne	 SHORT $LN14@GCManagerG

; 9671 : 				{
; 9672 : 					Result1 = 6;

  000b4	c6 45 f8 06	 mov	 BYTE PTR _Result1$1[ebp], 6

; 9673 : 					Result2 = 6;

  000b8	c6 45 fc 06	 mov	 BYTE PTR _Result2$2[ebp], 6

; 9674 : 				}
; 9675 : 				else

  000bc	eb 08		 jmp	 SHORT $LN15@GCManagerG
$LN14@GCManagerG:

; 9676 : 				{
; 9677 : 					Result1 = 0;

  000be	c6 45 f8 00	 mov	 BYTE PTR _Result1$1[ebp], 0

; 9678 : 					Result2 = 1;

  000c2	c6 45 fc 01	 mov	 BYTE PTR _Result2$2[ebp], 1
$LN15@GCManagerG:

; 9679 : 				}
; 9680 : 			}
; 9681 : 		}
; 9682 : 
; 9683 : 		if ( lpNode->WarType == 1 )

  000c6	80 bb 92 05 00
	00 01		 cmp	 BYTE PTR [ebx+1426], 1
  000cd	75 37		 jne	 SHORT $LN16@GCManagerG

; 9684 : 		{
; 9685 : 			gBattleGroundEnable(lpNode->BattleGroundIndex, FALSE );

  000cf	0f b6 83 93 05
	00 00		 movzx	 eax, BYTE PTR [ebx+1427]
  000d6	6a 00		 push	 0
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable

; 9686 : 			gObjGuildWarEndSend(lpNode, lpNode->lpTargetGuildNode, Result1, Result2);

  000de	ff 75 fc	 push	 DWORD PTR _Result2$2[ebp]
  000e1	ff 75 f8	 push	 DWORD PTR _Result1$1[ebp]
  000e4	ff b3 8c 05 00
	00		 push	 DWORD PTR [ebx+1420]
  000ea	53		 push	 ebx
  000eb	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend

; 9687 : 			gObjGuildWarEnd(lpNode, lpNode->lpTargetGuildNode);

  000f0	ff b3 8c 05 00
	00		 push	 DWORD PTR [ebx+1420]
  000f6	53		 push	 ebx
  000f7	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  000fc	83 c4 20	 add	 esp, 32			; 00000020H
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx

; 9695 : 		}
; 9696 : 	}
; 9697 : }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
$LN16@GCManagerG:

; 9688 : 
; 9689 : 			//cManager.BattleInfoSend(::GetBattleTeamName(0, 0), -1, ::GetBattleTeamName(0, 1), -1);
; 9690 : 		}
; 9691 : 		else
; 9692 : 		{
; 9693 : 			gObjGuildWarEndSend(lpNode, lpNode->lpTargetGuildNode, Result1, Result2);

  00106	ff 75 fc	 push	 DWORD PTR _Result2$2[ebp]
  00109	ff 75 f8	 push	 DWORD PTR _Result1$1[ebp]
  0010c	50		 push	 eax
  0010d	53		 push	 ebx
  0010e	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend

; 9694 : 			gObjGuildWarEnd(lpNode, lpNode->lpTargetGuildNode);

  00113	ff b3 8c 05 00
	00		 push	 DWORD PTR [ebx+1420]
  00119	53		 push	 ebx
  0011a	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  0011f	83 c4 18	 add	 esp, 24			; 00000018H
$LN27@GCManagerG:
  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
$LN17@GCManagerG:
  00124	5b		 pop	 ebx

; 9695 : 		}
; 9696 : 	}
; 9697 : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
?GCManagerGuildWarEnd@@YAXPAD@Z ENDP			; GCManagerGuildWarEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildViewportDelNow@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_isGuildMaster$ = 12					; size = 4
?GCGuildViewportDelNow@@YAXHH@Z PROC			; GCGuildViewportDelNow, COMDAT

; 9601 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 9602 : 	PMSG_GUILDDEL_VIEWPORT_NOW pMsg;
; 9603 : 
; 9604 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 9605 : 
; 9606 : 	PHeadSetB((LPBYTE)&pMsg, 0x5D, sizeof(pMsg));

  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	56		 push	 esi
  0000e	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00014	6a 05		 push	 5
  00016	6a 5d		 push	 93			; 0000005dH
  00018	50		 push	 eax
  00019	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9607 : 	pMsg.NumberH = SET_NUMBERH(aIndex) & 0x7F;

  00024	8b c3		 mov	 eax, ebx

; 9608 : 	pMsg.NumberL = SET_NUMBERL(aIndex);

  00026	88 5d fc	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  00029	c1 e8 08	 shr	 eax, 8
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	24 7f		 and	 al, 127			; 0000007fH

; 9609 : 
; 9610 : 	if ( isGuildMaster != FALSE )

  00031	83 7d 0c 00	 cmp	 DWORD PTR _isGuildMaster$[ebp], 0
  00035	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00038	74 05		 je	 SHORT $LN2@GCGuildVie

; 9611 : 	{
; 9612 : 		pMsg.NumberH |= 0x80;

  0003a	0c 80		 or	 al, 128			; 00000080H
  0003c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al
$LN2@GCGuildVie:

; 9613 : 	}
; 9614 : 
; 9615 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0003f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00043	50		 push	 eax
  00044	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00047	50		 push	 eax
  00048	53		 push	 ebx
  00049	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9616 : 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  0004e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00052	50		 push	 eax
  00053	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00056	50		 push	 eax
  00057	56		 push	 esi
  00058	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0005d	83 c4 18	 add	 esp, 24			; 00000018H
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx

; 9617 : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?GCGuildViewportDelNow@@YAXHH@Z ENDP			; GCGuildViewportDelNow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildViewportNowPaint@@YAXHPADPAEH@Z
_TEXT	SEGMENT
_pMsg$ = -280						; size = 12
_pGVCount$ = -268					; size = 5
__GuildInfoBuf$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_guildname$ = 12					; size = 4
_mark$ = 16						; size = 4
_isGuildMaster$ = 20					; size = 4
?GCGuildViewportNowPaint@@YAXHPADPAEH@Z PROC		; GCGuildViewportNowPaint, COMDAT

; 9538 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _guildname$[ebp]

; 9539 : 	_GUILD_INFO_STRUCT * lpGuild = Guild.SearchGuild(guildname);

  00016	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  0001b	53		 push	 ebx
  0001c	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild

; 9540 : 
; 9541 : 	if ( lpGuild == NULL )

  00025	85 c0		 test	 eax, eax
  00027	0f 84 0f 01 00
	00		 je	 $LN1@GCGuildVie

; 9542 : 		return;
; 9543 : 
; 9544 : 	LPOBJ lpObj = &gObj[aIndex];

  0002d	56		 push	 esi
  0002e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00034	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR __GuildInfoBuf$[ebp]
  0003a	57		 push	 edi
  0003b	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  00041	68 00 01 00 00	 push	 256			; 00000100H
  00046	6a 00		 push	 0
  00048	50		 push	 eax
  00049	03 f7		 add	 esi, edi
  0004b	e8 00 00 00 00	 call	 _memset

; 9545 : 	BYTE _GuildInfoBuf[256] = {0};
; 9546 : 	int _GuildInfoOfs = 5;
; 9547 : 
; 9548 : 	if ( lpObj->lpGuild == NULL )

  00050	8b 8e 18 06 00
	00		 mov	 ecx, DWORD PTR [esi+1560]
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	85 c9		 test	 ecx, ecx
  0005b	0f 84 d9 00 00
	00		 je	 $LN14@GCGuildVie

; 9549 : 		return;
; 9550 : 
; 9551 : 
; 9552 : 	PMSG_SIMPLE_GUILDVIEWPORT pMsg;
; 9553 : 	pMsg.GuildNumber = lpObj->lpGuild->Number;

  00061	8b 01		 mov	 eax, DWORD PTR [ecx]
  00063	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _pMsg$[ebp], eax

; 9554 : 	pMsg.NumberH = SET_NUMBERH(aIndex)&0x7F;

  00069	8b c3		 mov	 eax, ebx
  0006b	c1 e8 08	 shr	 eax, 8
  0006e	24 7f		 and	 al, 127			; 0000007fH

; 9555 : 	pMsg.NumberL = SET_NUMBERL(aIndex);

  00070	88 9d f0 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+8], bl

; 9556 : 
; 9557 : 	if ( isGuildMaster != FALSE )

  00076	83 7d 14 00	 cmp	 DWORD PTR _isGuildMaster$[ebp], 0
  0007a	88 85 ef fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+7], al
  00080	74 11		 je	 SHORT $LN5@GCGuildVie

; 9558 : 		pMsg.NumberH |= 0x80;

  00082	0c 80		 or	 al, 128			; 00000080H

; 9559 : 
; 9560 : 
; 9561 : 	if ( isGuildMaster != FALSE )
; 9562 : 		pMsg.btGuildStatus = 0x80;

  00084	c6 85 ec fe ff
	ff 80		 mov	 BYTE PTR _pMsg$[ebp+4], 128 ; 00000080H
  0008b	88 85 ef fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+7], al

; 9563 : 	else

  00091	eb 0c		 jmp	 SHORT $LN6@GCGuildVie
$LN5@GCGuildVie:

; 9564 : 		pMsg.btGuildStatus = lpObj->GuildStatus;

  00093	8a 86 28 06 00
	00		 mov	 al, BYTE PTR [esi+1576]
  00099	88 85 ec fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], al
$LN6@GCGuildVie:

; 9565 : 
; 9566 : 	pMsg.btGuildType = lpObj->lpGuild->btGuildType;

  0009f	0f b6 81 40 07
	00 00		 movzx	 eax, BYTE PTR [ecx+1856]

; 9567 : 	pMsg.btGuildRelationShip = 0;
; 9568 : 	lpObj->iGuildUnionTimeStamp = 0;
; 9569 : 	memcpy(&_GuildInfoBuf[_GuildInfoOfs], &pMsg, sizeof(pMsg));
; 9570 : 	_GuildInfoOfs += sizeof(pMsg);
; 9571 : 
; 9572 : 	PMSG_SIMPLE_GUILDVIEWPORT_COUNT pGVCount;
; 9573 : 
; 9574 : 	pGVCount.h.c = 0xC2;
; 9575 : 	pGVCount.h.headcode = 0x65;
; 9576 : 	pGVCount.h.sizeH = SET_NUMBERH(_GuildInfoOfs);
; 9577 : 	pGVCount.h.sizeL = SET_NUMBERL(_GuildInfoOfs);
; 9578 : 	pGVCount.Count = 1;

  000a6	b1 01		 mov	 cl, 1
  000a8	88 85 ed fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+5], al
  000ae	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _pMsg$[ebp+8]
  000b4	c7 86 2c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1580], 0
  000be	89 85 09 ff ff
	ff		 mov	 DWORD PTR __GuildInfoBuf$[ebp+13], eax
  000c4	c7 85 f4 fe ff
	ff c2 00 11 65	 mov	 DWORD PTR _pGVCount$[ebp], 1695613122 ; 651100c2H

; 9579 : 	memcpy(_GuildInfoBuf, &pGVCount, sizeof(pGVCount));

  000ce	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _pGVCount$[ebp]
  000d4	89 85 fc fe ff
	ff		 mov	 DWORD PTR __GuildInfoBuf$[ebp], eax

; 9580 : 
; 9581 : 	if ( !CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000df	c6 85 ee fe ff
	ff 00		 mov	 BYTE PTR _pMsg$[ebp+6], 0
  000e6	f3 0f 7e 85 e8
	fe ff ff	 movq	 xmm0, QWORD PTR _pMsg$[ebp]
  000ee	66 0f d6 85 01
	ff ff ff	 movq	 QWORD PTR __GuildInfoBuf$[ebp+5], xmm0
  000f6	88 8d 00 ff ff
	ff		 mov	 BYTE PTR __GuildInfoBuf$[ebp+4], cl
  000fc	8a 84 07 23 01
	00 00		 mov	 al, BYTE PTR [edi+eax+291]
  00103	3c 35		 cmp	 al, 53			; 00000035H
  00105	74 21		 je	 SHORT $LN7@GCGuildVie
  00107	3c 12		 cmp	 al, 18			; 00000012H
  00109	72 0b		 jb	 SHORT $LN13@GCGuildVie
  0010b	b1 17		 mov	 cl, 23			; 00000017H
  0010d	3a c8		 cmp	 cl, al
  0010f	1b c0		 sbb	 eax, eax
  00111	83 c0 01	 add	 eax, 1
  00114	75 12		 jne	 SHORT $LN7@GCGuildVie
$LN13@GCGuildVie:

; 9582 : 		DataSend(aIndex, _GuildInfoBuf, _GuildInfoOfs);

  00116	6a 11		 push	 17			; 00000011H
  00118	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR __GuildInfoBuf$[ebp]
  0011e	50		 push	 eax
  0011f	53		 push	 ebx
  00120	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@GCGuildVie:

; 9583 : 
; 9584 : 	MsgSendV2(lpObj, _GuildInfoBuf, _GuildInfoOfs);

  00128	6a 11		 push	 17			; 00000011H
  0012a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR __GuildInfoBuf$[ebp]
  00130	50		 push	 eax
  00131	56		 push	 esi
  00132	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00137	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@GCGuildVie:
  0013a	5f		 pop	 edi
  0013b	5e		 pop	 esi
$LN1@GCGuildVie:

; 9585 : }

  0013c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013f	33 cd		 xor	 ecx, ebp
  00141	5b		 pop	 ebx
  00142	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c3		 ret	 0
?GCGuildViewportNowPaint@@YAXHPADPAEH@Z ENDP		; GCGuildViewportNowPaint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGGuildMasterCreateCancel@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGGuildMasterCreateCancel@@YAXH@Z PROC			; CGGuildMasterCreateCancel, COMDAT

; 9525 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 9526 : 	if ( gObj[aIndex].GuildNumber > 0 )

  00003	69 55 08 40 27
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 10048
  0000a	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00010	83 ba 14 06 00
	00 00		 cmp	 DWORD PTR [edx+1556], 0
  00017	7f 22		 jg	 SHORT $LN3@CGGuildMas

; 9527 : 		return;
; 9528 : 
; 9529 : 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  00019	8b 8a b8 11 00
	00		 mov	 ecx, DWORD PTR [edx+4536]
  0001f	f6 c1 03	 test	 cl, 3
  00022	74 17		 je	 SHORT $LN3@CGGuildMas
  00024	8b c1		 mov	 eax, ecx
  00026	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0002b	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00030	75 09		 jne	 SHORT $LN3@CGGuildMas

; 9530 : 	{
; 9531 : 		gObj[aIndex].m_IfState.use = 0;

  00032	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00035	89 8a b8 11 00
	00		 mov	 DWORD PTR [edx+4536], ecx
$LN3@CGGuildMas:

; 9532 : 	}
; 9533 : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?CGGuildMasterCreateCancel@@YAXH@Z ENDP			; CGGuildMasterCreateCancel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$1$ = -24					; size = 4
_pMsg$1 = -24						; size = 5
_pMsg$2 = -24						; size = 5
_GuildName$ = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z PROC ; CGGuildMasterInfoSave, COMDAT

; 9468 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	56		 push	 esi

; 9469 : 	char GuildName[MAX_GUILD_LEN+1];
; 9470 : 	GuildName[MAX_GUILD_LEN] ='\0';
; 9471 : 	memcpy(GuildName, lpMsg->GuildName, MAX_GUILD_LEN);

  00018	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 9472 : 	int len = strlen(GuildName);

  0001b	8d 75 f0	 lea	 esi, DWORD PTR _GuildName$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR _GuildName$[ebp], eax
  00021	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  00024	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00027	89 4d e8	 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], ecx
  0002a	c6 45 f8 00	 mov	 BYTE PTR _GuildName$[ebp+8], 0
  0002e	89 45 f4	 mov	 DWORD PTR _GuildName$[ebp+4], eax
$LL20@CGGuildMas:
  00031	8a 06		 mov	 al, BYTE PTR [esi]
  00033	46		 inc	 esi
  00034	84 c0		 test	 al, al
  00036	75 f9		 jne	 SHORT $LL20@CGGuildMas
  00038	2b f2		 sub	 esi, edx

; 9473 : 
; 9474 : 	if ( len <= 2 || len > MAX_GUILD_LEN)

  0003a	8d 46 fd	 lea	 eax, DWORD PTR [esi-3]
  0003d	83 f8 05	 cmp	 eax, 5
  00040	0f 87 f8 00 00
	00		 ja	 $LN6@CGGuildMas

; 9486 : 		}
; 9487 : 
; 9488 : 		return;
; 9489 : 	}
; 9490 : 
; 9491 : 	if( g_MultilangGuildName == 0 )

  00046	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_MultilangGuildName@@3EA, 0 ; g_MultilangGuildName
  0004d	57		 push	 edi
  0004e	75 2a		 jne	 SHORT $LN3@CGGuildMas

; 9492 : 	{
; 9493 : 		for(int i = 0; i < len; i++)

  00050	33 ff		 xor	 edi, edi
  00052	85 f6		 test	 esi, esi
  00054	7e 24		 jle	 SHORT $LN3@CGGuildMas
  00056	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@CGGuildMas:

; 9494 : 		{
; 9495 : 			if( !isalnum(GuildName[i]) )	

  00060	0f be 44 3d f0	 movsx	 eax, BYTE PTR _GuildName$[ebp+edi]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _isalnum
  0006b	83 c4 04	 add	 esp, 4
  0006e	85 c0		 test	 eax, eax
  00070	74 6a		 je	 SHORT $LN16@CGGuildMas

; 9492 : 	{
; 9493 : 		for(int i = 0; i < len; i++)

  00072	47		 inc	 edi
  00073	3b fe		 cmp	 edi, esi
  00075	7c e9		 jl	 SHORT $LL4@CGGuildMas

; 9494 : 		{
; 9495 : 			if( !isalnum(GuildName[i]) )	

  00077	8b 4d e8	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
$LN3@CGGuildMas:

; 9507 : 				}
; 9508 : 				return;
; 9509 : 			}
; 9510 : 		}
; 9511 : 	}
; 9512 : 
; 9513 : 	GDGuildCreateSend(aIndex, GuildName, gObj[aIndex].Name, lpMsg->Mark, lpMsg->btGuildType);

  0007a	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0007e	50		 push	 eax
  0007f	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  00082	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00088	50		 push	 eax
  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008e	83 c0 5d	 add	 eax, 93			; 0000005dH
  00091	03 c6		 add	 eax, esi
  00093	50		 push	 eax
  00094	8d 45 f0	 lea	 eax, DWORD PTR _GuildName$[ebp]
  00097	50		 push	 eax
  00098	53		 push	 ebx
  00099	e8 00 00 00 00	 call	 ?GDGuildCreateSend@@YAXHPAD0PAEH@Z ; GDGuildCreateSend

; 9514 : 
; 9515 : 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  0009e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a4	83 c4 14	 add	 esp, 20			; 00000014H
  000a7	8b 8c 32 b8 11
	00 00		 mov	 ecx, DWORD PTR [edx+esi+4536]
  000ae	f6 c1 03	 test	 cl, 3
  000b1	74 18		 je	 SHORT $LN21@CGGuildMas
  000b3	8b c1		 mov	 eax, ecx
  000b5	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000ba	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  000bf	75 0a		 jne	 SHORT $LN21@CGGuildMas

; 9516 : 	{
; 9517 : 		gObj[aIndex].m_IfState.use = 0;

  000c1	83 e1 fc	 and	 ecx, -4			; fffffffcH
  000c4	89 8c 32 b8 11
	00 00		 mov	 DWORD PTR [edx+esi+4536], ecx
$LN21@CGGuildMas:
  000cb	5f		 pop	 edi
$LN7@CGGuildMas:
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx

; 9518 : 	}
; 9519 : }

  000ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d1	33 cd		 xor	 ecx, ebp
  000d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
$LN16@CGGuildMas:

; 9496 : 			{
; 9497 : 				PMSG_GUILDCREATED_RESULT pMsg;
; 9498 : 
; 9499 : 				PHeadSetB((LPBYTE)&pMsg, 0x56, sizeof(pMsg));

  000dc	6a 05		 push	 5
  000de	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  000e1	6a 56		 push	 86			; 00000056H
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9500 : 				pMsg.Result = 5;
; 9501 : 
; 9502 : 				DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  000e9	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  000ed	50		 push	 eax
  000ee	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  000f1	c6 45 eb 05	 mov	 BYTE PTR _pMsg$1[ebp+3], 5
  000f5	50		 push	 eax
  000f6	53		 push	 ebx
  000f7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9503 : 
; 9504 : 				if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )	

  000fc	69 d3 40 27 00
	00		 imul	 edx, ebx, 10048
  00102	83 c4 18	 add	 esp, 24			; 00000018H
  00105	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010b	8b 8a b8 11 00
	00		 mov	 ecx, DWORD PTR [edx+4536]
  00111	f6 c1 03	 test	 cl, 3
  00114	74 b5		 je	 SHORT $LN21@CGGuildMas
  00116	8b c1		 mov	 eax, ecx
  00118	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0011d	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00122	75 a7		 jne	 SHORT $LN21@CGGuildMas

; 9505 : 				{
; 9506 : 					gObj[aIndex].m_IfState.use = 0;

  00124	5f		 pop	 edi
  00125	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00128	5e		 pop	 esi
  00129	89 8a b8 11 00
	00		 mov	 DWORD PTR [edx+4536], ecx
  0012f	5b		 pop	 ebx

; 9518 : 	}
; 9519 : }

  00130	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00133	33 cd		 xor	 ecx, ebp
  00135	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c3		 ret	 0
$LN6@CGGuildMas:

; 9475 : 	{
; 9476 : 		PMSG_GUILDCREATED_RESULT pMsg;
; 9477 : 
; 9478 : 		PHeadSetB((LPBYTE)&pMsg, 0x56, sizeof(pMsg));

  0013e	6a 05		 push	 5
  00140	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$2[ebp]
  00143	6a 56		 push	 86			; 00000056H
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9479 : 		pMsg.Result = 2;
; 9480 : 		
; 9481 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0014b	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$2[ebp+1]
  0014f	50		 push	 eax
  00150	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$2[ebp]
  00153	c6 45 eb 02	 mov	 BYTE PTR _pMsg$2[ebp+3], 2
  00157	50		 push	 eax
  00158	53		 push	 ebx
  00159	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9482 : 
; 9483 : 		if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  0015e	69 d3 40 27 00
	00		 imul	 edx, ebx, 10048
  00164	83 c4 18	 add	 esp, 24			; 00000018H
  00167	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016d	8b 8a b8 11 00
	00		 mov	 ecx, DWORD PTR [edx+4536]
  00173	f6 c1 03	 test	 cl, 3
  00176	0f 84 50 ff ff
	ff		 je	 $LN7@CGGuildMas
  0017c	8b c1		 mov	 eax, ecx
  0017e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00183	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00188	0f 85 3e ff ff
	ff		 jne	 $LN7@CGGuildMas

; 9484 : 		{
; 9485 : 			gObj[aIndex].m_IfState.use = 0;

  0018e	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00191	89 8a b8 11 00
	00		 mov	 DWORD PTR [edx+4536], ecx

; 9518 : 	}
; 9519 : }

  00197	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019a	5e		 pop	 esi
  0019b	33 cd		 xor	 ecx, ebp
  0019d	5b		 pop	 ebx
  0019e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a3	8b e5		 mov	 esp, ebp
  001a5	5d		 pop	 ebp
  001a6	c3		 ret	 0
?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ENDP ; CGGuildMasterInfoSave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildMasterManagerRun@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCGuildMasterManagerRun@@YAXH@Z PROC			; GCGuildMasterManagerRun, COMDAT

; 9456 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 9457 : 	PMSG_GUILDMASTERMANAGER_RUN pMsg;
; 9458 : 
; 9459 : 	PHeadSetB((LPBYTE)&pMsg, 0x55, sizeof(pMsg));

  00004	6a 03		 push	 3
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 55		 push	 85			; 00000055H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9460 : 
; 9461 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00015	50		 push	 eax
  00016	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	50		 push	 eax
  0001a	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0001d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00022	83 c4 18	 add	 esp, 24			; 00000018H

; 9462 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?GCGuildMasterManagerRun@@YAXH@Z ENDP			; GCGuildMasterManagerRun
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z PROC ; CGGuildMasterAnswerRecv, COMDAT

; 9424 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 9425 : 	if ( lpMsg->Result == 1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	80 78 03 01	 cmp	 BYTE PTR [eax+3], 1
  0000a	75 5a		 jne	 SHORT $LN2@CGGuildMas

; 9426 : 	{
; 9427 : 		if ( !gObjGuildMasterCapacityTest(&gObj[aIndex]))

  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00015	57		 push	 edi
  00016	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  0001c	03 c7		 add	 eax, edi
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?gObjGuildMasterCapacityTest@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGuildMasterCapacityTest
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 2e		 jne	 SHORT $LN3@CGGuildMas

; 9428 : 		{
; 9429 : 			if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00031	8b 8c 3a b8 11
	00 00		 mov	 ecx, DWORD PTR [edx+edi+4536]
  00038	f6 c1 03	 test	 cl, 3
  0003b	74 18		 je	 SHORT $LN7@CGGuildMas
  0003d	8b c1		 mov	 eax, ecx
  0003f	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00044	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  00049	75 0a		 jne	 SHORT $LN7@CGGuildMas

; 9430 : 			{
; 9431 : 				gObj[aIndex].m_IfState.use = 0;

  0004b	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0004e	89 8c 3a b8 11
	00 00		 mov	 DWORD PTR [edx+edi+4536], ecx
$LN7@CGGuildMas:
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
$LN5@CGGuildMas:

; 9444 : 	}
; 9445 : }

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN3@CGGuildMas:

; 9432 : 			}
; 9433 : 
; 9434 : 			return;
; 9435 : 		}
; 9436 : 
; 9437 : 		GCGuildMasterManagerRun(aIndex);

  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?GCGuildMasterManagerRun@@YAXH@Z ; GCGuildMasterManagerRun
  0005f	83 c4 04	 add	 esp, 4
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 9444 : 	}
; 9445 : }

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN2@CGGuildMas:

; 9438 : 		return;
; 9439 : 	}
; 9440 : 
; 9441 : 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 5 )

  00066	69 55 0c 40 27
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 10048
  0006d	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00073	8b 8a b8 11 00
	00		 mov	 ecx, DWORD PTR [edx+4536]
  00079	f6 c1 03	 test	 cl, 3
  0007c	74 d9		 je	 SHORT $LN5@CGGuildMas
  0007e	8b c1		 mov	 eax, ecx
  00080	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00085	3d 40 01 00 00	 cmp	 eax, 320		; 00000140H
  0008a	75 cb		 jne	 SHORT $LN5@CGGuildMas

; 9442 : 	{
; 9443 : 		gObj[aIndex].m_IfState.use = 0;

  0008c	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0008f	89 8a b8 11 00
	00		 mov	 DWORD PTR [edx+4536], ecx

; 9444 : 	}
; 9445 : }

  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ENDP ; CGGuildMasterAnswerRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildMasterQuestionSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 3
_aIndex$ = 8						; size = 4
?GCGuildMasterQuestionSend@@YAXH@Z PROC			; GCGuildMasterQuestionSend, COMDAT

; 9404 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 9405 : 	if ( gObj[aIndex].m_IfState.use > 0 )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000d	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00013	f6 84 06 b8 11
	00 00 03	 test	 BYTE PTR [esi+eax+4536], 3
  0001b	77 64		 ja	 SHORT $LN1@GCGuildMas

; 9406 : 	{
; 9407 : 		return;
; 9408 : 	}
; 9409 : 
; 9410 : 	PMSG_GUILDMASTERQUESTION pMsg;
; 9411 : 
; 9412 : 	PHeadSetB((LPBYTE)&pMsg, 0x54, sizeof(pMsg));

  0001d	6a 03		 push	 3
  0001f	8d 45 08	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00022	6a 54		 push	 84			; 00000054H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9413 : 	gObj[aIndex].m_IfState.use = 1;

  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	8b 84 31 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+esi+4536]
  00037	83 e0 fd	 and	 eax, -3			; fffffffdH
  0003a	83 c8 01	 or	 eax, 1
  0003d	89 84 31 b8 11
	00 00		 mov	 DWORD PTR [ecx+esi+4536], eax

; 9414 : 	gObj[aIndex].m_IfState.type = 5;

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004a	8b 84 31 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+esi+4536]
  00051	25 7f 01 ff ff	 and	 eax, -65153		; ffff017fH
  00056	0d 40 01 00 00	 or	 eax, 320		; 00000140H
  0005b	89 84 31 b8 11
	00 00		 mov	 DWORD PTR [ecx+esi+4536], eax

; 9415 : 	gObj[aIndex].m_IfState.state = 0;

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00067	83 a4 06 b8 11
	00 00 c3	 and	 DWORD PTR [esi+eax+4536], -61 ; ffffffc3H

; 9416 : 
; 9417 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0006f	0f b6 45 09	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00073	50		 push	 eax
  00074	8d 45 08	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00077	50		 push	 eax
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0007e	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@GCGuildMas:
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi

; 9418 : }

  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?GCGuildMasterQuestionSend@@YAXH@Z ENDP			; GCGuildMasterQuestionSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGuildDelUserResult@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Result$ = 12						; size = 1
?GCGuildDelUserResult@@YAXHE@Z PROC			; GCGuildDelUserResult, COMDAT

; 9385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 9386 : 	PMSG_GUILDDELUSER_RESULT pMsg;
; 9387 : 
; 9388 : 	PHeadSetB((LPBYTE)&pMsg, 0x53, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 53		 push	 83			; 00000053H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9389 : 	pMsg.Result = Result;

  00011	8a 45 0c	 mov	 al, BYTE PTR _Result$[ebp]
  00014	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 9390 : 
; 9391 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00017	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001b	50		 push	 eax
  0001c	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00023	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00028	83 c4 18	 add	 esp, 24			; 00000018H

; 9392 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GCGuildDelUserResult@@YAXHE@Z ENDP			; GCGuildDelUserResult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$1$ = -60					; size = 4
_pMsg$ = -56						; size = 4
_joomin$ = -52						; size = 21
_guildname$ = -28					; size = 11
_memberid$ = -16					; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z PROC	; CGGuildDelUser, COMDAT

; 9283 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 9284 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00019	56		 push	 esi
  0001a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001d	57		 push	 edi
  0001e	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00024	89 5d c4	 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], ebx
  00027	03 c7		 add	 eax, edi
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	0f 84 70 02 00
	00		 je	 $LN6@CGGuildDel

; 9285 : 		return;
; 9286 : 
; 9287 : 	if ( gObj[aIndex].GuildNumber < 1 )

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003f	83 bc 07 14 06
	00 00 01	 cmp	 DWORD PTR [edi+eax+1556], 1
  00047	0f 8c 5d 02 00
	00		 jl	 $LN6@CGGuildDel

; 9288 : 		return;
; 9289 : 
; 9290 : 	char joomin[21];
; 9291 : 	char memberid[11];
; 9292 : 	char guildname[11];
; 9293 : 	PMSG_GUILDDELUSER_RESULT pMsg;
; 9294 : 	
; 9295 : 	PHeadSetB((LPBYTE)&pMsg, 0x53, sizeof(pMsg));

  0004d	6a 04		 push	 4
  0004f	8d 45 c8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00052	6a 53		 push	 83			; 00000053H
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9296 : 	pMsg.Result = 3;

  0005d	c6 45 cb 03	 mov	 BYTE PTR _pMsg$[ebp+3], 3

; 9297 : 
; 9298 : 	if ( !gGuildDestroy )

  00061	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGuildDestroy@@3HA, 0 ; gGuildDestroy
  00068	0f 84 cf 00 00
	00		 je	 $LN36@CGGuildDel

; 9299 : 	{
; 9300 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 9301 : 		return;
; 9302 : 	}
; 9303 : 
; 9304 : #if (ENABLETEST_ARCA == 1)
; 9305 : 	int iArcaBattleState = g_ArcaBattle.GetState();
; 9306 : 
; 9307 : 	if( iArcaBattleState > AB_STATE_CLOSED && iArcaBattleState < AB_STATE_CLOSE )
; 9308 : 	{
; 9309 : 		pMsg.Result = 6;
; 9310 : 		DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 9311 : 		return;
; 9312 : 	}
; 9313 : #endif
; 9314 : 
; 9315 : 	memset(memberid, 0, sizeof(memberid));
; 9316 : 	memset(guildname, 0, sizeof(guildname));
; 9317 : 	memcpy(memberid, lpMsg->Name, MAX_ACCOUNT_LEN);

  0006e	66 8b 43 0b	 mov	 ax, WORD PTR [ebx+11]

; 9318 : 	strcpy(guildname, gObj[aIndex].lpGuild->Name);

  00072	8d 55 e4	 lea	 edx, DWORD PTR _guildname$[ebp]
  00075	0f 57 c0	 xorps	 xmm0, xmm0
  00078	66 c7 45 f8 00
	00		 mov	 WORD PTR _memberid$[ebp+8], 0
  0007e	66 0f d6 45 f0	 movq	 QWORD PTR _memberid$[ebp], xmm0
  00083	66 0f d6 45 e4	 movq	 QWORD PTR _guildname$[ebp], xmm0
  00088	f3 0f 7e 43 03	 movq	 xmm0, QWORD PTR [ebx+3]
  0008d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00093	c6 45 fa 00	 mov	 BYTE PTR _memberid$[ebp+10], 0
  00097	66 c7 45 ec 00
	00		 mov	 WORD PTR _guildname$[ebp+8], 0
  0009d	c6 45 ee 00	 mov	 BYTE PTR _guildname$[ebp+10], 0
  000a1	66 0f d6 45 f0	 movq	 QWORD PTR _memberid$[ebp], xmm0
  000a6	66 89 45 f8	 mov	 WORD PTR _memberid$[ebp+8], ax
  000aa	8b 8c 1f 18 06
	00 00		 mov	 ecx, DWORD PTR [edi+ebx+1560]
  000b1	83 c1 04	 add	 ecx, 4
$LL17@CGGuildDel:
  000b4	8a 01		 mov	 al, BYTE PTR [ecx]
  000b6	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000b9	88 02		 mov	 BYTE PTR [edx], al
  000bb	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  000be	84 c0		 test	 al, al
  000c0	75 f2		 jne	 SHORT $LL17@CGGuildDel

; 9319 : 
; 9320 : 	if ( !strcmp(gObj[aIndex].lpGuild->Names[0], gObj[aIndex].Name ))

  000c2	8b 84 1f 18 06
	00 00		 mov	 eax, DWORD PTR [edi+ebx+1560]
  000c9	8d 4b 5d	 lea	 ecx, DWORD PTR [ebx+93]
  000cc	03 cf		 add	 ecx, edi
  000ce	83 c0 2f	 add	 eax, 47			; 0000002fH
  000d1	8b d1		 mov	 edx, ecx
$LL21@CGGuildDel:
  000d3	8a 18		 mov	 bl, BYTE PTR [eax]
  000d5	3a 1a		 cmp	 bl, BYTE PTR [edx]
  000d7	75 1a		 jne	 SHORT $LN22@CGGuildDel
  000d9	84 db		 test	 bl, bl
  000db	74 12		 je	 SHORT $LN23@CGGuildDel
  000dd	8a 58 01	 mov	 bl, BYTE PTR [eax+1]
  000e0	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  000e3	75 0e		 jne	 SHORT $LN22@CGGuildDel
  000e5	83 c0 02	 add	 eax, 2
  000e8	83 c2 02	 add	 edx, 2
  000eb	84 db		 test	 bl, bl
  000ed	75 e4		 jne	 SHORT $LL21@CGGuildDel
$LN23@CGGuildDel:
  000ef	33 c0		 xor	 eax, eax
  000f1	eb 05		 jmp	 SHORT $LN24@CGGuildDel
$LN22@CGGuildDel:
  000f3	1b c0		 sbb	 eax, eax
  000f5	83 c8 01	 or	 eax, 1
$LN24@CGGuildDel:
  000f8	85 c0		 test	 eax, eax
  000fa	0f 85 f2 00 00
	00		 jne	 $LN5@CGGuildDel

; 9321 : 	{
; 9322 : 		memset(joomin, 0, sizeof(joomin));
; 9323 : 		memcpy(joomin, lpMsg->JoominNumber, 20);
; 9324 : 
; 9325 : #if (__CUSTOM__ == 1)
; 9326 : 		if ( gc_bPersonalID == FALSE || gObjJoominCheck(aIndex, joomin) == TRUE )

  00100	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gc_bPersonalID@@3HA, 0 ; gc_bPersonalID
  00107	0f 57 c0	 xorps	 xmm0, xmm0
  0010a	89 45 dc	 mov	 DWORD PTR _joomin$[ebp+16], eax
  0010d	88 45 e0	 mov	 BYTE PTR _joomin$[ebp+20], al
  00110	8b 45 c4	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00113	0f 11 45 cc	 movups	 XMMWORD PTR _joomin$[ebp], xmm0
  00117	0f 10 40 0d	 movups	 xmm0, XMMWORD PTR [eax+13]
  0011b	8b 40 1d	 mov	 eax, DWORD PTR [eax+29]
  0011e	89 45 dc	 mov	 DWORD PTR _joomin$[ebp+16], eax
  00121	0f 11 45 cc	 movups	 XMMWORD PTR _joomin$[ebp], xmm0
  00125	74 39		 je	 SHORT $LN33@CGGuildDel
  00127	8d 45 cc	 lea	 eax, DWORD PTR _joomin$[ebp]
  0012a	50		 push	 eax
  0012b	56		 push	 esi
  0012c	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  00131	83 c4 08	 add	 esp, 8
  00134	83 f8 01	 cmp	 eax, 1
  00137	74 27		 je	 SHORT $LN33@CGGuildDel
$LN37@CGGuildDel:

; 9342 : 				gObj[aIndex].AccountID,gObj[aIndex].Name, guildname);
; 9343 : 		}
; 9344 : 		else
; 9345 : 		{
; 9346 : 			pMsg.Result = 0;

  00139	c6 45 cb 00	 mov	 BYTE PTR _pMsg$[ebp+3], 0
$LN36@CGGuildDel:

; 9347 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0013d	0f b6 45 c9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00141	50		 push	 eax
  00142	8d 45 c8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00145	50		 push	 eax
  00146	56		 push	 esi
  00147	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0014c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx

; 9377 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, guildname);
; 9378 : 	}
; 9379 : }

  00152	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00155	33 cd		 xor	 ecx, ebp
  00157	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
$LN33@CGGuildDel:

; 9327 : #else
; 9328 : 		if ( gObjJoominCheck(aIndex, joomin) == TRUE )
; 9329 : #endif
; 9330 : 		{
; 9331 : 			if ( !strcmp(memberid, gObj[aIndex].Name ))

  00160	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00166	8d 45 f0	 lea	 eax, DWORD PTR _memberid$[ebp]
  00169	03 df		 add	 ebx, edi
  0016b	8d 4b 5d	 lea	 ecx, DWORD PTR [ebx+93]
  0016e	66 90		 npad	 2
$LL25@CGGuildDel:
  00170	8a 10		 mov	 dl, BYTE PTR [eax]
  00172	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00174	75 1a		 jne	 SHORT $LN26@CGGuildDel
  00176	84 d2		 test	 dl, dl
  00178	74 12		 je	 SHORT $LN27@CGGuildDel
  0017a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0017d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00180	75 0e		 jne	 SHORT $LN26@CGGuildDel
  00182	83 c0 02	 add	 eax, 2
  00185	83 c1 02	 add	 ecx, 2
  00188	84 d2		 test	 dl, dl
  0018a	75 e4		 jne	 SHORT $LL25@CGGuildDel
$LN27@CGGuildDel:
  0018c	33 c0		 xor	 eax, eax
  0018e	eb 05		 jmp	 SHORT $LN28@CGGuildDel
$LN26@CGGuildDel:
  00190	1b c0		 sbb	 eax, eax
  00192	83 c8 01	 or	 eax, 1
$LN28@CGGuildDel:
  00195	85 c0		 test	 eax, eax
  00197	75 28		 jne	 SHORT $LN10@CGGuildDel

; 9332 : 			{
; 9333 : 				gObjGuildWarMasterClose(&gObj[aIndex]);

  00199	53		 push	 ebx
  0019a	e8 00 00 00 00	 call	 ?gObjGuildWarMasterClose@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGuildWarMasterClose

; 9334 : 				GDGuildDestroySend(aIndex, gObj[aIndex].lpGuild->Name, gObj[aIndex].Name);

  0019f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001a5	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001a8	03 c7		 add	 eax, edi
  001aa	50		 push	 eax
  001ab	8b 84 39 18 06
	00 00		 mov	 eax, DWORD PTR [ecx+edi+1560]
  001b2	83 c0 04	 add	 eax, 4
  001b5	50		 push	 eax
  001b6	56		 push	 esi
  001b7	e8 00 00 00 00	 call	 ?GDGuildDestroySend@@YAXHPAD0@Z ; GDGuildDestroySend
  001bc	83 c4 10	 add	 esp, 16			; 00000010H

; 9335 : 			}
; 9336 : 			else

  001bf	eb 11		 jmp	 SHORT $LN11@CGGuildDel
$LN10@CGGuildDel:

; 9337 : 			{
; 9338 : 				GDGuildMemberDel(aIndex, guildname, memberid);

  001c1	8d 45 f0	 lea	 eax, DWORD PTR _memberid$[ebp]
  001c4	50		 push	 eax
  001c5	8d 45 e4	 lea	 eax, DWORD PTR _guildname$[ebp]
  001c8	50		 push	 eax
  001c9	56		 push	 esi
  001ca	e8 00 00 00 00	 call	 ?GDGuildMemberDel@@YAXHPAD0@Z ; GDGuildMemberDel
  001cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@CGGuildDel:

; 9339 : 			}
; 9340 : 
; 9341 : 			LogAddTD("[%s][%s] Guild Request - Dismiss All : %s",

  001d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d8	8d 45 e4	 lea	 eax, DWORD PTR _guildname$[ebp]
  001db	50		 push	 eax
  001dc	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001df	03 c7		 add	 eax, edi
  001e1	50		 push	 eax
  001e2	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001e5	03 c7		 add	 eax, edi
  001e7	50		 push	 eax
  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@LPFOPCOO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Dismiss@

; 9348 : 			return;
; 9349 : 		}
; 9350 : 	}
; 9351 : 	else

  001ed	e9 af 00 00 00	 jmp	 $LN34@CGGuildDel
$LN5@CGGuildDel:

; 9352 : 	{
; 9353 : 		if ( strcmp(memberid, gObj[aIndex].Name) )

  001f2	8d 45 f0	 lea	 eax, DWORD PTR _memberid$[ebp]
$LL29@CGGuildDel:
  001f5	8a 10		 mov	 dl, BYTE PTR [eax]
  001f7	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001f9	75 1a		 jne	 SHORT $LN30@CGGuildDel
  001fb	84 d2		 test	 dl, dl
  001fd	74 12		 je	 SHORT $LN31@CGGuildDel
  001ff	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00202	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00205	75 0e		 jne	 SHORT $LN30@CGGuildDel
  00207	83 c0 02	 add	 eax, 2
  0020a	83 c1 02	 add	 ecx, 2
  0020d	84 d2		 test	 dl, dl
  0020f	75 e4		 jne	 SHORT $LL29@CGGuildDel
$LN31@CGGuildDel:
  00211	33 c0		 xor	 eax, eax
  00213	eb 05		 jmp	 SHORT $LN32@CGGuildDel
$LN30@CGGuildDel:
  00215	1b c0		 sbb	 eax, eax
  00217	83 c8 01	 or	 eax, 1
$LN32@CGGuildDel:
  0021a	85 c0		 test	 eax, eax
  0021c	0f 85 17 ff ff
	ff		 jne	 $LN37@CGGuildDel

; 9354 : 		{
; 9355 : 			pMsg.Result = 0;
; 9356 : 			DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 9357 : 			return;
; 9358 : 		}
; 9359 : 
; 9360 : 		memset(joomin, 0, sizeof(joomin));
; 9361 : 		memcpy(joomin, lpMsg->JoominNumber, 20);
; 9362 : 
; 9363 : #if (__CUSTOM__ == 1)
; 9364 : 		if ( gc_bPersonalID == FALSE || gObjJoominCheck(aIndex, joomin) == TRUE )

  00222	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gc_bPersonalID@@3HA, 0 ; gc_bPersonalID
  00229	0f 57 c0	 xorps	 xmm0, xmm0
  0022c	89 45 dc	 mov	 DWORD PTR _joomin$[ebp+16], eax
  0022f	88 45 e0	 mov	 BYTE PTR _joomin$[ebp+20], al
  00232	8b 45 c4	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00235	0f 11 45 cc	 movups	 XMMWORD PTR _joomin$[ebp], xmm0
  00239	0f 10 40 0d	 movups	 xmm0, XMMWORD PTR [eax+13]
  0023d	8b 40 1d	 mov	 eax, DWORD PTR [eax+29]
  00240	89 45 dc	 mov	 DWORD PTR _joomin$[ebp+16], eax
  00243	0f 11 45 cc	 movups	 XMMWORD PTR _joomin$[ebp], xmm0
  00247	74 2c		 je	 SHORT $LN15@CGGuildDel
  00249	8d 45 cc	 lea	 eax, DWORD PTR _joomin$[ebp]
  0024c	50		 push	 eax
  0024d	56		 push	 esi
  0024e	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  00253	83 c4 08	 add	 esp, 8
  00256	83 f8 01	 cmp	 eax, 1
  00259	74 1a		 je	 SHORT $LN15@CGGuildDel

; 9370 : 		}
; 9371 : 		else
; 9372 : 		{
; 9373 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(4, 108)), aIndex, 1);

  0025b	6a 01		 push	 1
  0025d	56		 push	 esi
  0025e	68 6c 04 00 00	 push	 1132			; 0000046cH
  00263	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00268	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0026d	50		 push	 eax
  0026e	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00273	eb 0e		 jmp	 SHORT $LN35@CGGuildDel
$LN15@CGGuildDel:

; 9365 : #else
; 9366 : 		if ( gObjJoominCheck(aIndex, joomin) == TRUE )
; 9367 : #endif
; 9368 : 		{
; 9369 : 			GDGuildMemberDel(aIndex, guildname, memberid);

  00275	8d 45 f0	 lea	 eax, DWORD PTR _memberid$[ebp]
  00278	50		 push	 eax
  00279	8d 45 e4	 lea	 eax, DWORD PTR _guildname$[ebp]
  0027c	50		 push	 eax
  0027d	56		 push	 esi
  0027e	e8 00 00 00 00	 call	 ?GDGuildMemberDel@@YAXHPAD0@Z ; GDGuildMemberDel
$LN35@CGGuildDel:

; 9374 : 		}
; 9375 : 
; 9376 : 		LogAddTD("[%s][%s] Guild Request - Leave : %s",

  00283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00289	8d 45 e4	 lea	 eax, DWORD PTR _guildname$[ebp]
  0028c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0028f	50		 push	 eax
  00290	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00293	03 c7		 add	 eax, edi
  00295	50		 push	 eax
  00296	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00299	03 c7		 add	 eax, edi
  0029b	50		 push	 eax
  0029c	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CALGKPMO@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Leave?5?3@
$LN34@CGGuildDel:
  002a1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002a7	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@CGGuildDel:

; 9377 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, guildname);
; 9378 : 	}
; 9379 : }

  002aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ad	5f		 pop	 edi
  002ae	5e		 pop	 esi
  002af	33 cd		 xor	 ecx, ebp
  002b1	5b		 pop	 ebx
  002b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b7	8b e5		 mov	 esp, ebp
  002b9	5d		 pop	 ebp
  002ba	c3		 ret	 0
?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z ENDP	; CGGuildDelUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGGuildListAll@@YAXH@Z
_TEXT	SEGMENT
_pnumber$GSCopy$1$ = -1592				; size = 4
tv434 = -1588						; size = 4
_pList$ = -1584						; size = 13
tv427 = -1568						; size = 4
_lOfs$1$ = -1564					; size = 4
_pCount$ = -1560					; size = 56
_sendbuf$ = -1504					; size = 1500
__$ArrayPad$ = -4					; size = 4
_pnumber$ = 8						; size = 4
?CGGuildListAll@@YAXH@Z PROC				; CGGuildListAll, COMDAT

; 9196 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 06 00
	00		 sub	 esp, 1592		; 00000638H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 9197 : 	if ( gObj[pnumber].lpGuild == NULL )

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	8b 5d 08	 mov	 ebx, DWORD PTR _pnumber$[ebp]
  0001c	56		 push	 esi
  0001d	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00023	89 9d c8 f9 ff
	ff		 mov	 DWORD PTR _pnumber$GSCopy$1$[ebp], ebx
  00029	83 bc 06 18 06
	00 00 00	 cmp	 DWORD PTR [esi+eax+1560], 0
  00031	0f 84 78 02 00
	00		 je	 $LN1@CGGuildLis

; 9198 : 		return;
; 9199 : 
; 9200 : 	PMSG_GUILDLISTCOUNT pCount;
; 9201 : 	PMSG_GUILDLIST pList;
; 9202 : 	char sendbuf[1500];
; 9203 : 	int lOfs = 0;
; 9204 : 	int number;
; 9205 : 	int n;
; 9206 : 	int guildmaster = 0;
; 9207 : 	
; 9208 : 	PHeadSetW((LPBYTE)&pCount, 0x52, 0);

  00037	6a 00		 push	 0
  00039	8d 85 e8 f9 ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0003f	6a 52		 push	 82			; 00000052H
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 9209 : 	pCount.Result = 0;
; 9210 : 	pCount.Count = 0;
; 9211 : 	lOfs += sizeof(pCount);
; 9212 : 	pCount.h.sizeH = SET_NUMBERH(lOfs);
; 9213 : 	pCount.h.sizeL = SET_NUMBERL(lOfs);
; 9214 : 
; 9215 : 	if ( gObj[pnumber].GuildNumber < 1 )

  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	03 ce		 add	 ecx, esi
  00052	66 c7 85 ec f9
	ff ff 00 00	 mov	 WORD PTR _pCount$[ebp+4], 0
  0005b	66 c7 85 e9 f9
	ff ff 00 38	 mov	 WORD PTR _pCount$[ebp+1], 14336 ; 00003800H
  00064	c7 85 e4 f9 ff
	ff 38 00 00 00	 mov	 DWORD PTR _lOfs$1$[ebp], 56 ; 00000038H
  0006e	83 b9 14 06 00
	00 01		 cmp	 DWORD PTR [ecx+1556], 1
  00075	7d 22		 jge	 SHORT $LN6@CGGuildLis

; 9216 : 	{
; 9217 : 		DataSend(pnumber, (LPBYTE)&pCount, lOfs);

  00077	6a 38		 push	 56			; 00000038H
  00079	8d 85 e8 f9 ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0007f	50		 push	 eax
  00080	53		 push	 ebx
  00081	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx

; 9272 : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN6@CGGuildLis:

; 9218 : 		return;
; 9219 : 	}
; 9220 : 
; 9221 : 	pCount.Count = gObj[pnumber].lpGuild->Count;

  00099	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  0009f	0f 57 c0	 xorps	 xmm0, xmm0
  000a2	0f b6 40 2d	 movzx	 eax, BYTE PTR [eax+45]
  000a6	88 85 ed f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], al

; 9222 : 	pCount.TotalScore = gObj[pnumber].lpGuild->TotalScore;

  000ac	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  000b2	8b 80 98 05 00
	00		 mov	 eax, DWORD PTR [eax+1432]
  000b8	89 85 f0 f9 ff
	ff		 mov	 DWORD PTR _pCount$[ebp+8], eax

; 9223 : 	pCount.Score = gObj[pnumber].lpGuild->PlayScore;

  000be	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  000c4	0f b6 80 95 05
	00 00		 movzx	 eax, BYTE PTR [eax+1429]
  000cb	88 85 f4 f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+12], al

; 9224 : 	memset(pCount.szRivalGuild, 0, sizeof(pCount.szRivalGuild));

  000d1	66 0f d6 85 f5
	f9 ff ff	 movq	 QWORD PTR _pCount$[ebp+13], xmm0
  000d9	c6 85 fd f9 ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+21], 0

; 9225 : 
; 9226 : 	if ( gObj[pnumber].lpGuild->iGuildRival )

  000e0	8b 91 18 06 00
	00		 mov	 edx, DWORD PTR [ecx+1560]
  000e6	83 ba 48 07 00
	00 00		 cmp	 DWORD PTR [edx+1864], 0
  000ed	74 51		 je	 SHORT $LN17@CGGuildLis

; 9227 : 	{
; 9228 : 		memcpy(pCount.szRivalGuild, gObj[pnumber].lpGuild->szGuildRivalName, MAX_GUILD_LEN);

  000ef	8b 82 50 07 00
	00		 mov	 eax, DWORD PTR [edx+1872]
  000f5	89 85 f5 f9 ff
	ff		 mov	 DWORD PTR _pCount$[ebp+13], eax
  000fb	8b 82 54 07 00
	00		 mov	 eax, DWORD PTR [edx+1876]
  00101	89 85 f9 f9 ff
	ff		 mov	 DWORD PTR _pCount$[ebp+17], eax

; 9229 : 		_GUILD_INFO_STRUCT* lpRivalGuild = Guild.SearchGuild(gObj[pnumber].lpGuild->szGuildRivalName);

  00107	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  0010d	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  00112	05 50 07 00 00	 add	 eax, 1872		; 00000750H
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?SearchGuild@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@PAD@Z ; CGuildClass::SearchGuild

; 9230 : 
; 9231 : 		if( lpRivalGuild )

  0011d	85 c0		 test	 eax, eax
  0011f	74 1f		 je	 SHORT $LN17@CGGuildLis

; 9232 : 		{
; 9233 : 			memcpy(pCount.btUnk,lpRivalGuild->Mark,sizeof(lpRivalGuild->Mark));

  00121	0f 10 40 0d	 movups	 xmm0, XMMWORD PTR [eax+13]
  00125	0f 11 85 ff f9
	ff ff		 movups	 XMMWORD PTR _pCount$[ebp+23], xmm0
  0012c	0f 10 40 1d	 movups	 xmm0, XMMWORD PTR [eax+29]
  00130	0f 11 85 0f fa
	ff ff		 movups	 XMMWORD PTR _pCount$[ebp+39], xmm0

; 9234 : 			pCount.btCount = lpRivalGuild->Count;

  00137	8a 40 2d	 mov	 al, BYTE PTR [eax+45]
  0013a	88 85 fe f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+22], al
$LN17@CGGuildLis:

; 9235 : 		}
; 9236 : 	}
; 9237 : 
; 9238 : 	pCount.Result = 1;
; 9239 : 	guildmaster = 1;
; 9240 : 
; 9241 : 	if ( pCount.Count == 0 )

  00140	80 bd ed f9 ff
	ff 00		 cmp	 BYTE PTR _pCount$[ebp+5], 0
  00147	c6 85 ec f9 ff
	ff 01		 mov	 BYTE PTR _pCount$[ebp+4], 1
  0014e	0f 84 5b 01 00
	00		 je	 $LN1@CGGuildLis

; 9242 : 		return;
; 9243 : 
; 9244 : 	pCount.Count = 0;

  00154	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00159	32 ed		 xor	 ch, ch
  0015b	05 18 06 00 00	 add	 eax, 1560		; 00000618H
  00160	88 ad ed f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], ch
  00166	03 c6		 add	 eax, esi
  00168	ba 00 06 00 00	 mov	 edx, 1536		; 00000600H
  0016d	57		 push	 edi

; 9245 : 
; 9246 : 	for ( n=0;n<MAX_USER_GUILD;n++)

  0016e	33 ff		 xor	 edi, edi
  00170	89 85 cc f9 ff
	ff		 mov	 DWORD PTR tv434[ebp], eax
  00176	33 c0		 xor	 eax, eax
  00178	8d b5 58 fa ff
	ff		 lea	 esi, DWORD PTR _sendbuf$[ebp+56]
  0017e	89 85 e0 f9 ff
	ff		 mov	 DWORD PTR tv427[ebp], eax
  00184	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@CGGuildLis:

; 9247 : 	{
; 9248 : 		number = gObj[pnumber].lpGuild->Use[n];

  00190	8b 9d cc f9 ff
	ff		 mov	 ebx, DWORD PTR tv434[ebp]
  00196	8b 1b		 mov	 ebx, DWORD PTR [ebx]

; 9249 : 
; 9250 : 		if ( number > 0 )

  00198	80 bc 3b 40 04
	00 00 00	 cmp	 BYTE PTR [ebx+edi+1088], 0
  001a0	0f 86 88 00 00
	00		 jbe	 $LN18@CGGuildLis

; 9251 : 		{
; 9252 : 			memset(&pList, 0, sizeof(pList));

  001a6	0f 57 c0	 xorps	 xmm0, xmm0
  001a9	c7 85 d8 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _pList$[ebp+8], 0
  001b3	66 0f d6 85 d0
	f9 ff ff	 movq	 QWORD PTR _pList$[ebp], xmm0

; 9253 : 			memcpy(pList.Name, gObj[pnumber].lpGuild->Names[n], sizeof(pList.Name));

  001bb	f3 0f 7e 44 18
	2f		 movq	 xmm0, QWORD PTR [eax+ebx+47]
  001c1	66 8b 44 18 37	 mov	 ax, WORD PTR [eax+ebx+55]
  001c6	66 89 85 d8 f9
	ff ff		 mov	 WORD PTR _pList$[ebp+8], ax

; 9254 : 			pList.Number = gObj[pnumber].lpGuild->pServer[n];

  001cd	8a 84 3b 90 04
	00 00		 mov	 al, BYTE PTR [ebx+edi+1168]

; 9255 : 			pList.ConnectAServer = (short)gObj[pnumber].lpGuild->pServer[n] & 0x7F;

  001d4	8a c8		 mov	 cl, al
  001d6	c6 85 dc f9 ff
	ff 00		 mov	 BYTE PTR _pList$[ebp+12], 0
  001dd	80 e1 7f	 and	 cl, 127			; 0000007fH
  001e0	88 85 da f9 ff
	ff		 mov	 BYTE PTR _pList$[ebp+10], al
  001e6	88 8d db f9 ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], cl

; 9256 : 
; 9257 : 			if ( gObj[pnumber].lpGuild->pServer[n] >= 0 )

  001ec	84 c0		 test	 al, al
  001ee	78 09		 js	 SHORT $LN11@CGGuildLis

; 9258 : 				pList.ConnectAServer |= 0x80;

  001f0	80 c9 80	 or	 cl, 128			; 00000080H
  001f3	88 8d db f9 ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], cl
$LN11@CGGuildLis:

; 9259 : 
; 9260 : 			pList.btGuildStatus = gObj[pnumber].lpGuild->GuildStatus[n];

  001f9	8a 0c 1a	 mov	 cl, BYTE PTR [edx+ebx]

; 9261 : 			memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  001fc	8b 85 d8 f9 ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp+8]

; 9262 : 			lOfs+= sizeof(pList);

  00202	8b 9d e4 f9 ff
	ff		 mov	 ebx, DWORD PTR _lOfs$1$[ebp]
  00208	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  0020c	83 c3 0d	 add	 ebx, 13			; 0000000dH
  0020f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00212	8b 85 e0 f9 ff
	ff		 mov	 eax, DWORD PTR tv427[ebp]
  00218	88 4e 0c	 mov	 BYTE PTR [esi+12], cl
  0021b	83 c6 0d	 add	 esi, 13			; 0000000dH

; 9263 : 			pCount.Count++;

  0021e	fe c5		 inc	 ch
  00220	89 9d e4 f9 ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ebx
  00226	88 ad ed f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], ch
  0022c	eb 06		 jmp	 SHORT $LN2@CGGuildLis
$LN18@CGGuildLis:
  0022e	8b 9d e4 f9 ff
	ff		 mov	 ebx, DWORD PTR _lOfs$1$[ebp]
$LN2@CGGuildLis:

; 9245 : 
; 9246 : 	for ( n=0;n<MAX_USER_GUILD;n++)

  00234	83 c2 04	 add	 edx, 4
  00237	83 c0 0b	 add	 eax, 11			; 0000000bH
  0023a	47		 inc	 edi
  0023b	89 85 e0 f9 ff
	ff		 mov	 DWORD PTR tv427[ebp], eax
  00241	81 fa 40 07 00
	00		 cmp	 edx, 1856		; 00000740H
  00247	0f 8c 43 ff ff
	ff		 jl	 $LL4@CGGuildLis

; 9264 : 		}
; 9265 : 	}
; 9266 : 
; 9267 : 	pCount.h.sizeH = SET_NUMBERH(lOfs);

  0024d	8b c3		 mov	 eax, ebx

; 9268 : 	pCount.h.sizeL = SET_NUMBERL(lOfs);

  0024f	88 9d ea f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+2], bl
  00255	c1 e8 08	 shr	 eax, 8
  00258	88 85 e9 f9 ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], al

; 9269 : 	memcpy(sendbuf, (LPBYTE)&pCount, sizeof(pCount));
; 9270 : 
; 9271 : 	DataSend(pnumber, (LPBYTE)sendbuf, lOfs);

  0025e	8d 85 20 fa ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  00264	0f 10 85 e8 f9
	ff ff		 movups	 xmm0, XMMWORD PTR _pCount$[ebp]
  0026b	53		 push	 ebx
  0026c	50		 push	 eax
  0026d	ff b5 c8 f9 ff
	ff		 push	 DWORD PTR _pnumber$GSCopy$1$[ebp]
  00273	0f 11 85 20 fa
	ff ff		 movups	 XMMWORD PTR _sendbuf$[ebp], xmm0
  0027a	0f 10 85 f8 f9
	ff ff		 movups	 xmm0, XMMWORD PTR _pCount$[ebp+16]
  00281	0f 11 85 30 fa
	ff ff		 movups	 XMMWORD PTR _sendbuf$[ebp+16], xmm0
  00288	0f 10 85 08 fa
	ff ff		 movups	 xmm0, XMMWORD PTR _pCount$[ebp+32]
  0028f	0f 11 85 40 fa
	ff ff		 movups	 XMMWORD PTR _sendbuf$[ebp+32], xmm0
  00296	f3 0f 7e 85 18
	fa ff ff	 movq	 xmm0, QWORD PTR _pCount$[ebp+48]
  0029e	66 0f d6 85 50
	fa ff ff	 movq	 QWORD PTR _sendbuf$[ebp+48], xmm0
  002a6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ae	5f		 pop	 edi
$LN1@CGGuildLis:

; 9272 : }

  002af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b2	5e		 pop	 esi
  002b3	33 cd		 xor	 ecx, ebp
  002b5	5b		 pop	 ebx
  002b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c3		 ret	 0
?CGGuildListAll@@YAXH@Z ENDP				; CGGuildListAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z
_TEXT	SEGMENT
tv267 = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z PROC ; CGGuildRequestResultRecv, COMDAT

; 9123 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 9124 : 	int number;
; 9125 : 	BYTE result=0;
; 9126 : 	int pnumber=-1;
; 9127 : 
; 9128 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	69 7d 0c 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00012	32 db		 xor	 bl, bl
  00014	03 c7		 add	 eax, edi
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 bf 00 00
	00		 je	 $LN4@CGGuildReq

; 9129 : 		return;
; 9130 : 
; 9131 : 	number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0002a	56		 push	 esi
  0002b	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  0002f	66 c1 e0 08	 shl	 ax, 8
  00033	0f b7 f0	 movzx	 esi, ax
  00036	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  0003a	0b f0		 or	 esi, eax

; 9132 : 
; 9133 : 	if ( number < 0 || number > OBJMAX-1)

  0003c	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00042	0f 87 9d 00 00
	00		 ja	 $LN16@CGGuildReq

; 9134 : 		return;
; 9135 : 
; 9136 : 	if ( !gObjIsConnected(&gObj[number]))

  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004d	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00053	03 c1		 add	 eax, ecx
  00055	89 4d fc	 mov	 DWORD PTR tv267[ebp], ecx
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0005e	83 c4 04	 add	 esp, 4
  00061	85 c0		 test	 eax, eax
  00063	75 11		 jne	 SHORT $LN5@CGGuildReq

; 9137 : 	{
; 9138 : 		GCResultSend(aIndex, 0x51, 0x02);

  00065	6a 02		 push	 2
  00067	6a 51		 push	 81			; 00000051H
  00069	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  0006c	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9139 : 	}
; 9140 : 	else

  00074	eb 02		 jmp	 SHORT $LN6@CGGuildReq
$LN5@CGGuildReq:

; 9141 : 	{
; 9142 : 		result = 1;

  00076	b3 01		 mov	 bl, 1
$LN6@CGGuildReq:

; 9143 : 	}
; 9144 : 
; 9145 : 	if ( lpMsg->Result == 0 )

  00078	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0007b	80 78 03 00	 cmp	 BYTE PTR [eax+3], 0
  0007f	75 6b		 jne	 SHORT $LN7@CGGuildReq

; 9146 : 	{
; 9147 : 		result = 0;
; 9148 : 		GCResultSend(number, 0x51, 0x00);

  00081	6a 00		 push	 0
  00083	6a 51		 push	 81			; 00000051H
  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@CGGuildReq:
  0008e	8b 5d fc	 mov	 ebx, DWORD PTR tv267[ebp]
$LN13@CGGuildReq:

; 9156 : 		}
; 9157 : 	}
; 9158 : 
; 9159 : 	if ( gObj[aIndex].m_IfState.use && gObj[aIndex].m_IfState.type == 4)

  00091	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00097	8b 8c 3a b8 11
	00 00		 mov	 ecx, DWORD PTR [edx+edi+4536]
  0009e	f6 c1 03	 test	 cl, 3
  000a1	74 18		 je	 SHORT $LN10@CGGuildReq
  000a3	8b c1		 mov	 eax, ecx
  000a5	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000aa	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  000af	75 0a		 jne	 SHORT $LN10@CGGuildReq

; 9160 : 		gObj[aIndex].m_IfState.use = 0;

  000b1	83 e1 fc	 and	 ecx, -4			; fffffffcH
  000b4	89 8c 3a b8 11
	00 00		 mov	 DWORD PTR [edx+edi+4536], ecx
$LN10@CGGuildReq:

; 9161 : 		
; 9162 : 	if ( gObj[number].m_IfState.use && gObj[number].m_IfState.type == 4)

  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c1	8b 8c 1a b8 11
	00 00		 mov	 ecx, DWORD PTR [edx+ebx+4536]
  000c8	f6 c1 03	 test	 cl, 3
  000cb	74 18		 je	 SHORT $LN16@CGGuildReq
  000cd	8b c1		 mov	 eax, ecx
  000cf	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000d4	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  000d9	75 0a		 jne	 SHORT $LN16@CGGuildReq

; 9163 : 		gObj[number].m_IfState.use = 0;

  000db	83 e1 fc	 and	 ecx, -4			; fffffffcH
  000de	89 8c 1a b8 11
	00 00		 mov	 DWORD PTR [edx+ebx+4536], ecx
$LN16@CGGuildReq:
  000e5	5e		 pop	 esi
$LN4@CGGuildReq:
  000e6	5f		 pop	 edi
  000e7	5b		 pop	 ebx

; 9164 : }

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
$LN7@CGGuildReq:

; 9149 : 	}
; 9150 : 
; 9151 : 	if ( result == 1 )

  000ec	80 fb 01	 cmp	 bl, 1
  000ef	75 9d		 jne	 SHORT $LN15@CGGuildReq

; 9152 : 	{
; 9153 : 		if ( gObj[aIndex].GuildNumber > 0 )

  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f6	83 bc 07 14 06
	00 00 00	 cmp	 DWORD PTR [edi+eax+1556], 0
  000fe	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]

; 9154 : 		{
; 9155 : 			GDGuildMemberAdd(number, gObj[aIndex].lpGuild->Name, gObj[number].Name);

  00101	8b 5d fc	 mov	 ebx, DWORD PTR tv267[ebp]
  00104	7e 8b		 jle	 SHORT $LN13@CGGuildReq
  00106	83 c0 5d	 add	 eax, 93			; 0000005dH
  00109	03 c3		 add	 eax, ebx
  0010b	50		 push	 eax
  0010c	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  00112	83 c0 04	 add	 eax, 4
  00115	50		 push	 eax
  00116	56		 push	 esi
  00117	e8 00 00 00 00	 call	 ?GDGuildMemberAdd@@YAXHPAD0@Z ; GDGuildMemberAdd
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011f	e9 6d ff ff ff	 jmp	 $LN13@CGGuildReq
?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ENDP ; CGGuildRequestResultRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 5
tv526 = -12						; size = 4
tv523 = -12						; size = 4
tv515 = -8						; size = 4
tv528 = -4						; size = 4
tv524 = 8						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z PROC	; CGGuildRequestRecv, COMDAT

; 8972 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8973 : 	PMSG_GUILDQUESTSEND pMsg;
; 8974 : 	int number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0000d	66 c1 e0 08	 shl	 ax, 8
  00011	57		 push	 edi
  00012	0f b7 f8	 movzx	 edi, ax
  00015	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00019	0b f8		 or	 edi, eax

; 8975 : 
; 8976 : 	if ( number < 0 || number > OBJMAX-1 )

  0001b	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00021	0f 87 cc 03 00
	00		 ja	 $LN3@CGGuildReq

; 8977 : 		return;
; 8978 : 
; 8979 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	53		 push	 ebx
  0002d	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00030	56		 push	 esi
  00031	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00037	03 c6		 add	 eax, esi
  00039	89 75 fc	 mov	 DWORD PTR tv528[ebp], esi
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00042	83 c4 04	 add	 esp, 4
  00045	85 c0		 test	 eax, eax
  00047	0f 84 a4 03 00
	00		 je	 $LN31@CGGuildReq

; 8980 : 		return;
; 8981 : 
; 8982 : 	if ( !gObjIsConnected(&gObj[number]))

  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00058	03 c1		 add	 eax, ecx
  0005a	89 4d 08	 mov	 DWORD PTR tv524[ebp], ecx
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00063	83 c4 04	 add	 esp, 4
  00066	85 c0		 test	 eax, eax
  00068	75 14		 jne	 SHORT $LN5@CGGuildReq

; 8983 : 	{
; 8984 : 		GCResultSend(aIndex, 0x51, 0x03);

  0006a	6a 03		 push	 3
  0006c	6a 51		 push	 81			; 00000051H
  0006e	53		 push	 ebx
  0006f	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 9008 : 		 GCServerMsgStringSend(lMsg.Get(3426), aIndex, 1);

  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
$LN5@CGGuildReq:

; 8985 : 		return;
; 8986 : 	}
; 8987 : 
; 8988 : 	if ( gObj[aIndex].m_IfState.use > 0 )

  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00084	03 f1		 add	 esi, ecx
  00086	f6 86 b8 11 00
	00 03		 test	 BYTE PTR [esi+4536], 3
  0008d	76 14		 jbe	 SHORT $LN6@CGGuildReq
$LN35@CGGuildReq:

; 8989 : 	{
; 8990 : 		GCResultSend(aIndex, 0x51, 0x06);

  0008f	6a 06		 push	 6
  00091	6a 51		 push	 81			; 00000051H
  00093	53		 push	 ebx
  00094	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 9008 : 		 GCServerMsgStringSend(lMsg.Get(3426), aIndex, 1);

  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
$LN6@CGGuildReq:

; 8991 : 		return;
; 8992 : 	}
; 8993 : 	
; 8994 : 	if ( gObj[number].m_IfState.use > 0 )

  000a3	8b 45 08	 mov	 eax, DWORD PTR tv524[ebp]
  000a6	03 c1		 add	 eax, ecx
  000a8	89 45 f4	 mov	 DWORD PTR tv523[ebp], eax
  000ab	f6 80 b8 11 00
	00 03		 test	 BYTE PTR [eax+4536], 3
  000b2	77 db		 ja	 SHORT $LN35@CGGuildReq

; 8995 : 	{
; 8996 : 		GCResultSend(aIndex, 0x51, 0x06);
; 8997 : 		return;
; 8998 : 	}
; 8999 : 
; 9000 : 	if ( gObj[aIndex].Level < 6 )

  000b4	66 83 be 96 00
	00 00 06	 cmp	 WORD PTR [esi+150], 6
  000bc	7d 14		 jge	 SHORT $LN8@CGGuildReq

; 9001 : 	{
; 9002 : 		GCResultSend(aIndex, 0x51, 0x07);

  000be	6a 07		 push	 7
  000c0	6a 51		 push	 81			; 00000051H
  000c2	53		 push	 ebx
  000c3	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 9008 : 		 GCServerMsgStringSend(lMsg.Get(3426), aIndex, 1);

  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
$LN8@CGGuildReq:

; 9003 : 		return;
; 9004 : 	}
; 9005 : 
; 9006 : #if (ENABLETEST_NEWPVP == 1)
; 9007 : 	if (g_NewPVP.IsDuel(gObj[aIndex]) || g_NewPVP.IsDuel(gObj[number])) {

  000d2	56		 push	 esi
  000d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000d8	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  000dd	85 c0		 test	 eax, eax
  000df	0f 85 f1 02 00
	00		 jne	 $LN10@CGGuildReq
  000e5	ff 75 f4	 push	 DWORD PTR tv523[ebp]
  000e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000ed	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  000f2	85 c0		 test	 eax, eax
  000f4	0f 85 dc 02 00
	00		 jne	 $LN10@CGGuildReq

; 9009 : 		 return;
; 9010 : 	}
; 9011 : 
; 9012 : 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  000fa	56		 push	 esi
  000fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00100	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00105	85 c0		 test	 eax, eax
  00107	74 0d		 je	 SHORT $LN11@CGGuildReq

; 9013 : 		 GCServerMsgStringSend(lMsg.Get(3427), aIndex, 1);

  00109	6a 01		 push	 1
  0010b	53		 push	 ebx
  0010c	68 63 0d 00 00	 push	 3427			; 00000d63H

; 9014 : 		 return;

  00111	e9 c8 02 00 00	 jmp	 $LN34@CGGuildReq
$LN11@CGGuildReq:

; 9015 : 	}
; 9016 : #endif
; 9017 : 
; 9018 : #if (ENABLETEST_ARCA == 1)
; 9019 : 	int iArcaBattleState = g_ArcaBattle.GetState();
; 9020 : 
; 9021 : 	if( iArcaBattleState > AB_STATE_CLOSED && iArcaBattleState < AB_STATE_CLOSE )
; 9022 : 	{
; 9023 : 		GCResultSend(aIndex, 0x51, 0xA4);
; 9024 : 		return;
; 9025 : 	}
; 9026 : #endif
; 9027 : 
; 9028 : 	if ( gObj[aIndex].GuildNumber > 0 )

  00116	8b 45 fc	 mov	 eax, DWORD PTR tv528[ebp]
  00119	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011f	03 c1		 add	 eax, ecx
  00121	89 45 f4	 mov	 DWORD PTR tv526[ebp], eax
  00124	83 b8 14 06 00
	00 00		 cmp	 DWORD PTR [eax+1556], 0
  0012b	7e 14		 jle	 SHORT $LN12@CGGuildReq

; 9029 : 	{
; 9030 : 		GCResultSend(aIndex, 0x51, 0x05);

  0012d	6a 05		 push	 5
  0012f	6a 51		 push	 81			; 00000051H
  00131	53		 push	 ebx
  00132	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00137	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
  0013c	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
$LN12@CGGuildReq:

; 9031 : 		return;
; 9032 : 	}
; 9033 : 
; 9034 : 	if ( (gObj[number].m_Option&1 ) != 1 )

  00141	8b 75 08	 mov	 esi, DWORD PTR tv524[ebp]
  00144	f6 84 0e 24 12
	00 00 01	 test	 BYTE PTR [esi+ecx+4644], 1
  0014c	75 14		 jne	 SHORT $LN13@CGGuildReq

; 9035 : 	{
; 9036 : 		GCResultSend(aIndex, 0x51, 0x00);

  0014e	6a 00		 push	 0
  00150	6a 51		 push	 81			; 00000051H
  00152	53		 push	 ebx
  00153	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx
  0015d	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c3		 ret	 0
$LN13@CGGuildReq:

; 9037 : 		return;
; 9038 : 	}
; 9039 : 
; 9040 : 	if ( gObj[number].GuildNumber > 0 )

  00162	83 bc 0e 14 06
	00 00 00	 cmp	 DWORD PTR [esi+ecx+1556], 0
  0016a	7e 3d		 jle	 SHORT $LN14@CGGuildReq

; 9041 : 	{
; 9042 : 		if ( strcmp(gObj[number].lpGuild->Names[0], gObj[number].Name))

  0016c	8b 84 0e 18 06
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1560]
  00173	83 c1 5d	 add	 ecx, 93			; 0000005dH
  00176	89 45 f8	 mov	 DWORD PTR tv515[ebp], eax
  00179	03 ce		 add	 ecx, esi
  0017b	83 c0 2f	 add	 eax, 47			; 0000002fH
  0017e	66 90		 npad	 2
$LL26@CGGuildReq:
  00180	8a 10		 mov	 dl, BYTE PTR [eax]
  00182	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00184	75 1a		 jne	 SHORT $LN27@CGGuildReq
  00186	84 d2		 test	 dl, dl
  00188	74 12		 je	 SHORT $LN28@CGGuildReq
  0018a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0018d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00190	75 0e		 jne	 SHORT $LN27@CGGuildReq
  00192	83 c0 02	 add	 eax, 2
  00195	83 c1 02	 add	 ecx, 2
  00198	84 d2		 test	 dl, dl
  0019a	75 e4		 jne	 SHORT $LL26@CGGuildReq
$LN28@CGGuildReq:
  0019c	33 c0		 xor	 eax, eax
  0019e	eb 05		 jmp	 SHORT $LN29@CGGuildReq
$LN27@CGGuildReq:
  001a0	1b c0		 sbb	 eax, eax
  001a2	83 c8 01	 or	 eax, 1
$LN29@CGGuildReq:
  001a5	85 c0		 test	 eax, eax
  001a7	74 14		 je	 SHORT $LN16@CGGuildReq
$LN14@CGGuildReq:

; 9043 : 		{
; 9044 : 			GCResultSend(aIndex, 0x51, 0x04);

  001a9	6a 04		 push	 4
  001ab	6a 51		 push	 81			; 00000051H
  001ad	53		 push	 ebx
  001ae	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx
  001b8	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c3		 ret	 0
$LN16@CGGuildReq:

; 9045 : 			return;
; 9046 : 		}
; 9047 : 
; 9048 : 		if ( gObj[number].lpGuild->WarState )

  001bd	8b 45 f8	 mov	 eax, DWORD PTR tv515[ebp]
  001c0	80 b8 91 05 00
	00 00		 cmp	 BYTE PTR [eax+1425], 0
  001c7	0f 85 c2 fe ff
	ff		 jne	 $LN35@CGGuildReq

; 9049 : 		{
; 9050 : 			GCResultSend(aIndex, 0x51, 0x06);
; 9051 : 			return;
; 9052 : 		}
; 9053 : 
; 9054 : #if (__GENS_SYSTEM__ == 1)
; 9055 : 
; 9056 : 		if( gGensSystem.m_CheckForGuild )

  001cd	80 3d 49 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VCGensSystem@@A+73, 0

; 9057 : 		{
; 9058 : 			if ( gObj[number].m_GensInfo.btFamily == GENS_NONE )

  001d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d9	74 44		 je	 SHORT $LN20@CGGuildReq
  001db	8a 8c 06 ac 26
	00 00		 mov	 cl, BYTE PTR [esi+eax+9900]
  001e2	84 c9		 test	 cl, cl
  001e4	75 17		 jne	 SHORT $LN19@CGGuildReq

; 9059 : 			{
; 9060 : 				GCResultSend(aIndex,0x51,0xA1);

  001e6	68 a1 00 00 00	 push	 161			; 000000a1H
  001eb	6a 51		 push	 81			; 00000051H
  001ed	53		 push	 ebx
  001ee	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f6	5e		 pop	 esi
  001f7	5b		 pop	 ebx
  001f8	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  001f9	8b e5		 mov	 esp, ebp
  001fb	5d		 pop	 ebp
  001fc	c3		 ret	 0
$LN19@CGGuildReq:

; 9061 : 				return;
; 9062 : 			}
; 9063 : 
; 9064 : 			if ( gObj[number].m_GensInfo.btFamily != gObj[aIndex].m_GensInfo.btFamily )

  001fd	8b 55 f4	 mov	 edx, DWORD PTR tv526[ebp]
  00200	3a 8a ac 26 00
	00		 cmp	 cl, BYTE PTR [edx+9900]
  00206	74 17		 je	 SHORT $LN20@CGGuildReq

; 9065 : 			{
; 9066 : 				GCResultSend(aIndex,0x51,0xA2);

  00208	68 a2 00 00 00	 push	 162			; 000000a2H
  0020d	6a 51		 push	 81			; 00000051H
  0020f	53		 push	 ebx
  00210	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00215	83 c4 0c	 add	 esp, 12			; 0000000cH
  00218	5e		 pop	 esi
  00219	5b		 pop	 ebx
  0021a	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c3		 ret	 0
$LN20@CGGuildReq:

; 9067 : 				return;
; 9068 : 			}
; 9069 : 		}
; 9070 : 
; 9071 : #endif
; 9072 : 
; 9073 : 		int MaxGuildMember;
; 9074 : 
; 9075 : 		if ( gObj[number].Class == CLASS_DARKLORD )

  0021f	66 83 bc 06 90
	00 00 00 04	 cmp	 WORD PTR [esi+eax+144], 4
  00228	75 42		 jne	 SHORT $LN21@CGGuildReq

; 9076 : 			MaxGuildMember = gObj[number].Level / 10 + gObj[number].Leadership / 10;

  0022a	0f b7 8c 06 f4
	00 00 00	 movzx	 ecx, WORD PTR [esi+eax+244]
  00232	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00237	f7 e9		 imul	 ecx
  00239	8b 45 08	 mov	 eax, DWORD PTR tv524[ebp]
  0023c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00242	c1 fa 02	 sar	 edx, 2
  00245	8b f2		 mov	 esi, edx
  00247	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0024a	0f bf 8c 08 96
	00 00 00	 movsx	 ecx, WORD PTR [eax+ecx+150]
  00252	03 f2		 add	 esi, edx
  00254	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00259	f7 e9		 imul	 ecx
  0025b	c1 fa 02	 sar	 edx, 2
  0025e	8b ca		 mov	 ecx, edx
  00260	03 f2		 add	 esi, edx
  00262	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00265	03 ce		 add	 ecx, esi

; 9077 : 		else

  00267	8b 75 08	 mov	 esi, DWORD PTR tv524[ebp]
  0026a	eb 19		 jmp	 SHORT $LN22@CGGuildReq
$LN21@CGGuildReq:

; 9078 : 			MaxGuildMember = gObj[number].Level / 10;

  0026c	0f bf 8c 06 96
	00 00 00	 movsx	 ecx, WORD PTR [esi+eax+150]
  00274	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00279	f7 e9		 imul	 ecx
  0027b	c1 fa 02	 sar	 edx, 2
  0027e	8b ca		 mov	 ecx, edx
  00280	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00283	03 ca		 add	 ecx, edx
$LN22@CGGuildReq:

; 9079 : 
; 9080 : 		if ( MaxGuildMember > g_GuildMaxMember )
; 9081 : 			MaxGuildMember = g_GuildMaxMember;
; 9082 : 
; 9083 : 		if ( gObj[number].lpGuild->TotalCount >= MaxGuildMember )

  00285	8b 45 f8	 mov	 eax, DWORD PTR tv515[ebp]
  00288	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GuildMaxMember@@3HA ; g_GuildMaxMember
  0028e	0f 4f 0d 00 00
	00 00		 cmovg	 ecx, DWORD PTR ?g_GuildMaxMember@@3HA ; g_GuildMaxMember
  00295	0f b6 40 2e	 movzx	 eax, BYTE PTR [eax+46]
  00299	3b c1		 cmp	 eax, ecx
  0029b	7c 14		 jl	 SHORT $LN24@CGGuildReq

; 9084 : 		{
; 9085 : 			GCResultSend(aIndex, 0x51, 0x02);

  0029d	6a 02		 push	 2
  0029f	6a 51		 push	 81			; 00000051H
  002a1	53		 push	 ebx
  002a2	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  002a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  002aa	5e		 pop	 esi
  002ab	5b		 pop	 ebx
  002ac	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  002ad	8b e5		 mov	 esp, ebp
  002af	5d		 pop	 ebp
  002b0	c3		 ret	 0
$LN24@CGGuildReq:

; 9086 : 			return;
; 9087 : 		}
; 9088 : 	}
; 9089 : 	else
; 9090 : 	{
; 9091 : 		GCResultSend(aIndex, 0x51, 0x04);
; 9092 : 		return;
; 9093 : 	}
; 9094 : 	
; 9095 : 	gObj[aIndex].m_IfState.use = 1;

  002b1	8b 4d f4	 mov	 ecx, DWORD PTR tv526[ebp]

; 9096 : 	gObj[aIndex].m_IfState.type = 4;

  002b4	8b 55 fc	 mov	 edx, DWORD PTR tv528[ebp]
  002b7	8b 81 b8 11 00
	00		 mov	 eax, DWORD PTR [ecx+4536]
  002bd	83 e0 fd	 and	 eax, -3			; fffffffdH
  002c0	83 c8 01	 or	 eax, 1
  002c3	89 81 b8 11 00
	00		 mov	 DWORD PTR [ecx+4536], eax
  002c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002cf	8b 84 11 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+edx+4536]
  002d6	25 3f 01 ff ff	 and	 eax, -65217		; ffff013fH
  002db	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  002e0	89 84 11 b8 11
	00 00		 mov	 DWORD PTR [ecx+edx+4536], eax

; 9097 : 	gObj[aIndex].m_IfState.state = 0;

  002e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ec	83 a4 02 b8 11
	00 00 c3	 and	 DWORD PTR [edx+eax+4536], -61 ; ffffffc3H

; 9098 : 
; 9099 : 	gObj[number].m_IfState.use = 1;

  002f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002fa	8b 84 31 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+esi+4536]
  00301	83 e0 fd	 and	 eax, -3			; fffffffdH
  00304	83 c8 01	 or	 eax, 1
  00307	89 84 31 b8 11
	00 00		 mov	 DWORD PTR [ecx+esi+4536], eax

; 9100 : 	gObj[number].m_IfState.type = 4;

  0030e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00314	8b 84 31 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+esi+4536]
  0031b	25 3f 01 ff ff	 and	 eax, -65217		; ffff013fH
  00320	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  00325	89 84 31 b8 11
	00 00		 mov	 DWORD PTR [ecx+esi+4536], eax

; 9101 : 	gObj[number].m_IfState.state = 0;

  0032c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00331	83 a4 06 b8 11
	00 00 c3	 and	 DWORD PTR [esi+eax+4536], -61 ; ffffffc3H

; 9102 : 
; 9103 : 	gObj[aIndex].TargetNumber = number;

  00339	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0033e	66 89 bc 02 38
	06 00 00	 mov	 WORD PTR [edx+eax+1592], di

; 9104 : 	gObj[number].TargetNumber = aIndex;

  00346	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0034b	66 89 9c 06 38
	06 00 00	 mov	 WORD PTR [esi+eax+1592], bx

; 9105 : 	gObj[aIndex].m_InterfaceTime = GetTickCount();

  00353	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  00359	ff d6		 call	 esi
  0035b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00361	8b 55 fc	 mov	 edx, DWORD PTR tv528[ebp]
  00364	89 84 0a bc 11
	00 00		 mov	 DWORD PTR [edx+ecx+4540], eax

; 9106 : 	gObj[number].m_InterfaceTime = GetTickCount();

  0036b	ff d6		 call	 esi
  0036d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00373	8b 75 08	 mov	 esi, DWORD PTR tv524[ebp]

; 9107 : 
; 9108 : 	PHeadSetB((LPBYTE)&pMsg, 0x50, sizeof(pMsg));

  00376	6a 05		 push	 5
  00378	6a 50		 push	 80			; 00000050H
  0037a	89 84 0e bc 11
	00 00		 mov	 DWORD PTR [esi+ecx+4540], eax
  00381	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00384	50		 push	 eax
  00385	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 9109 : 	pMsg.NumberH = SET_NUMBERH(aIndex);

  0038a	8b c3		 mov	 eax, ebx

; 9110 : 	pMsg.NumberL = SET_NUMBERL(aIndex);

  0038c	88 5d f0	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  0038f	c1 e8 08	 shr	 eax, 8
  00392	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 9111 : 
; 9112 : 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  00395	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00399	50		 push	 eax
  0039a	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0039d	50		 push	 eax
  0039e	57		 push	 edi
  0039f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 9113 : 
; 9114 : 	LogAddTD("[%s][%s] Guild Request - Join : %s",

  003a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a9	8b 4d fc	 mov	 ecx, DWORD PTR tv528[ebp]
  003ac	03 c8		 add	 ecx, eax
  003ae	8b 84 06 18 06
	00 00		 mov	 eax, DWORD PTR [esi+eax+1560]
  003b5	83 c0 04	 add	 eax, 4
  003b8	50		 push	 eax
  003b9	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  003bc	50		 push	 eax
  003bd	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  003c0	50		 push	 eax
  003c1	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KPIJPFAI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Guild?5Request?5?9?5Join?5?3?5@
  003c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003cc	83 c4 28	 add	 esp, 40			; 00000028H
  003cf	5e		 pop	 esi
  003d0	5b		 pop	 ebx
  003d1	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  003d2	8b e5		 mov	 esp, ebp
  003d4	5d		 pop	 ebp
  003d5	c3		 ret	 0
$LN10@CGGuildReq:

; 9008 : 		 GCServerMsgStringSend(lMsg.Get(3426), aIndex, 1);

  003d6	6a 01		 push	 1
  003d8	53		 push	 ebx
  003d9	68 62 0d 00 00	 push	 3426			; 00000d62H
$LN34@CGGuildReq:
  003de	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003e3	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003e8	50		 push	 eax
  003e9	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003ee	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@CGGuildReq:
  003f1	5e		 pop	 esi
  003f2	5b		 pop	 ebx
$LN3@CGGuildReq:
  003f3	5f		 pop	 edi

; 9115 : 		gObj[aIndex].AccountID, gObj[aIndex].Name,
; 9116 : 		gObj[number].lpGuild->Name);
; 9117 : }

  003f4	8b e5		 mov	 esp, ebp
  003f6	5d		 pop	 ebp
  003f7	c3		 ret	 0
?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z ENDP	; CGGuildRequestRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCPartyDelUserSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 3
_aIndex$ = 8						; size = 4
?GCPartyDelUserSend@@YAXH@Z PROC			; GCPartyDelUserSend, COMDAT

; 8954 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 8955 : 	PMSG_PARTYDELUSERSEND pMsg;
; 8956 : 
; 8957 : 	PHeadSetB((LPBYTE)&pMsg, 0x43, sizeof(pMsg));

  00004	6a 03		 push	 3
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 43		 push	 67			; 00000043H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8958 : 
; 8959 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00011	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00015	50		 push	 eax
  00016	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	50		 push	 eax
  0001a	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0001d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00022	83 c4 18	 add	 esp, 24			; 00000018H

; 8960 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?GCPartyDelUserSend@@YAXH@Z ENDP			; GCPartyDelUserSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPartyDelUserAsExitGameByForce@@YAXPAUPMSG_PARTYDELUSER@@H@Z
_TEXT	SEGMENT
_count$1$ = -16						; size = 4
_dbnumber$ = -12					; size = 4
_pnumber$1$ = -8					; size = 4
_usernumber$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyDelUserAsExitGameByForce@@YAXPAUPMSG_PARTYDELUSER@@H@Z PROC ; CGPartyDelUserAsExitGameByForce, COMDAT

; 8831 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 8832 : 	int usernumber = -1;
; 8833 : 	int dbnumber = -1;
; 8834 : 	int count;
; 8835 : 	int number;
; 8836 : 	int pnumber;
; 8837 : 
; 8838 : 	if( gObj[aIndex].PartyNumber < 0 )

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	56		 push	 esi
  0000d	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00010	57		 push	 edi
  00011	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00017	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _usernumber$[ebp], -1
  0001e	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _dbnumber$[ebp], -1
  00025	8b 94 39 0c 06
	00 00		 mov	 edx, DWORD PTR [ecx+edi+1548]
  0002c	85 d2		 test	 edx, edx
  0002e	79 20		 jns	 SHORT $LN8@CGPartyDel

; 8839 : 	{
; 8840 : 		LogAdd("No party %s %s",gObj[aIndex].AccountID,gObj[aIndex].Name);

  00030	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00033	03 c7		 add	 eax, edi
  00035	50		 push	 eax
  00036	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00039	03 c7		 add	 eax, edi
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IDGHFMPH@No?5party?5?$CFs?5?$CFs?$AA@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 8939 : 		}
; 8940 : 	}
; 8941 : 
; 8942 : 
; 8943 : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
$LN8@CGPartyDel:

; 8841 : 		return;
; 8842 : 	}
; 8843 : 
; 8844 : 	if( !gParty.GetIndexUser(gObj[aIndex].PartyNumber,lpMsg->Number,usernumber,dbnumber) )

  00050	8d 45 f4	 lea	 eax, DWORD PTR _dbnumber$[ebp]
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00058	50		 push	 eax
  00059	8d 45 fc	 lea	 eax, DWORD PTR _usernumber$[ebp]
  0005c	50		 push	 eax
  0005d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00060	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00064	50		 push	 eax
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ?GetIndexUser@PartyClass@@QAEHHHAAH0@Z ; PartyClass::GetIndexUser
  0006b	85 c0		 test	 eax, eax
  0006d	75 14		 jne	 SHORT $LN9@CGPartyDel
$LN42@CGPartyDel:

; 8845 : 	{
; 8846 : 		LogAdd("User not found");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CPKIABHC@User?5not?5found?$AA@
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0007a	83 c4 04	 add	 esp, 4
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi

; 8939 : 		}
; 8940 : 	}
; 8941 : 
; 8942 : 
; 8943 : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
$LN9@CGPartyDel:

; 8847 : 		return;
; 8848 : 	}
; 8849 : 
; 8850 : 	if( usernumber < 0 )

  00083	83 7d fc 00	 cmp	 DWORD PTR _usernumber$[ebp], 0
  00087	7c e6		 jl	 SHORT $LN42@CGPartyDel

; 8851 : 	{
; 8852 : 		LogAdd("User not found");
; 8853 : 		return;
; 8854 : 	}
; 8855 : 
; 8856 : 	pnumber = gObj[aIndex].PartyNumber;

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008e	53		 push	 ebx
  0008f	8b 9c 07 0c 06
	00 00		 mov	 ebx, DWORD PTR [edi+eax+1548]
  00096	89 5d f8	 mov	 DWORD PTR _pnumber$1$[ebp], ebx

; 8857 : 
; 8858 : 	if( pnumber < 0 )

  00099	85 db		 test	 ebx, ebx
  0009b	79 07		 jns	 SHORT $LN11@CGPartyDel

; 8859 : 	{
; 8860 : 		LogAdd("%s %d",__FILE__,__LINE__);

  0009d	68 9c 22 00 00	 push	 8860			; 0000229cH

; 8861 : 		return;

  000a2	eb 1a		 jmp	 SHORT $LN43@CGPartyDel
$LN11@CGPartyDel:

; 8862 : 	}
; 8863 : 
; 8864 : 	count = gParty.GetCount(pnumber);

  000a4	53		 push	 ebx
  000a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000aa	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  000af	8b d0		 mov	 edx, eax
  000b1	89 55 f0	 mov	 DWORD PTR _count$1$[ebp], edx

; 8865 : 
; 8866 : 	if( count < 1 )

  000b4	83 fa 01	 cmp	 edx, 1
  000b7	7d 1f		 jge	 SHORT $LN12@CGPartyDel

; 8867 : 	{
; 8868 : 		LogAdd("%s %d",__FILE__,__LINE__);

  000b9	68 a4 22 00 00	 push	 8868			; 000022a4H
$LN43@CGPartyDel:
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 8890 : 					gObj[number].IsInBattleGround )
; 8891 : 				{
; 8892 : 					GCServerMsgStringSend(lMsg.Get(MSGGET(13,216)),aIndex,1);

  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	5b		 pop	 ebx
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi

; 8939 : 		}
; 8940 : 	}
; 8941 : 
; 8942 : 
; 8943 : }

  000d4	8b e5		 mov	 esp, ebp
  000d6	5d		 pop	 ebp
  000d7	c3		 ret	 0
$LN12@CGPartyDel:

; 8869 : 		return;
; 8870 : 	}
; 8871 : 
; 8872 : 	if( gObj[aIndex].lpGuild != NULL )

  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000de	8b 84 0f 18 06
	00 00		 mov	 eax, DWORD PTR [edi+ecx+1560]
  000e5	85 c0		 test	 eax, eax
  000e7	74 73		 je	 SHORT $LN37@CGPartyDel

; 8873 : 	{
; 8874 : 		if( gObj[aIndex].lpGuild->WarState == 1 &&

  000e9	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  000f0	75 12		 jne	 SHORT $LN14@CGPartyDel
  000f2	80 bc 0f de 13
	00 00 00	 cmp	 BYTE PTR [edi+ecx+5086], 0
  000fa	74 08		 je	 SHORT $LN14@CGPartyDel

; 8875 : 			gObj[aIndex].IsInBattleGround )
; 8876 : 		{
; 8877 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13,216)),aIndex,1);

  000fc	6a 01		 push	 1
  000fe	56		 push	 esi

; 8878 : 			return;

  000ff	e9 c7 00 00 00	 jmp	 $LN40@CGPartyDel
$LN14@CGPartyDel:

; 8879 : 		}
; 8880 : 
; 8881 : 		if( usernumber == gParty.m_PartyS[pnumber].Number[0] )

  00104	8b c3		 mov	 eax, ebx
  00106	c1 e0 04	 shl	 eax, 4
  00109	2b c3		 sub	 eax, ebx
  0010b	8d 0c 85 0c 00
	00 00		 lea	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  00112	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
  00115	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00117	75 43		 jne	 SHORT $LN37@CGPartyDel

; 8882 : 		{
; 8883 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00119	33 d2		 xor	 edx, edx
  0011b	0f 1f 44 00 00	 npad	 5
$LL4@CGPartyDel:

; 8884 : 			{
; 8885 : 				number = gParty.m_PartyS[pnumber].Number[n];

  00120	8b 01		 mov	 eax, DWORD PTR [ecx]

; 8886 : 
; 8887 : 				if( number >= 0 &&
; 8888 : 					gObj[number].lpGuild != NULL && 
; 8889 : 					gObj[number].lpGuild->WarState == 1 && 

  00122	85 c0		 test	 eax, eax
  00124	78 2a		 js	 SHORT $LN2@CGPartyDel
  00126	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0012c	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00132	03 f0		 add	 esi, eax
  00134	8b 86 18 06 00
	00		 mov	 eax, DWORD PTR [esi+1560]
  0013a	85 c0		 test	 eax, eax
  0013c	74 12		 je	 SHORT $LN2@CGPartyDel
  0013e	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  00145	75 09		 jne	 SHORT $LN2@CGPartyDel
  00147	80 be de 13 00
	00 00		 cmp	 BYTE PTR [esi+5086], 0
  0014e	75 76		 jne	 SHORT $LN29@CGPartyDel
$LN2@CGPartyDel:

; 8882 : 		{
; 8883 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00150	42		 inc	 edx
  00151	83 c1 04	 add	 ecx, 4
  00154	83 fa 05	 cmp	 edx, 5
  00157	7c c7		 jl	 SHORT $LL4@CGPartyDel
  00159	8b 55 f0	 mov	 edx, DWORD PTR _count$1$[ebp]
$LN37@CGPartyDel:

; 8893 : 					return;
; 8894 : 				}
; 8895 : 			}
; 8896 : 		}
; 8897 : 	}
; 8898 : 
; 8899 : 	if( lpMsg->Number == 0 || count <= 2 )

  0015c	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0015f	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00163	74 09		 je	 SHORT $LN18@CGPartyDel
  00165	83 fa 02	 cmp	 edx, 2
  00168	0f 8f f7 00 00
	00		 jg	 $LN39@CGPartyDel
$LN18@CGPartyDel:

; 8900 : 	{
; 8901 : 		int nReallyConnectPartyMemberCount = gParty.GetReallyConnectPartyMemberCount(pnumber);

  0016e	53		 push	 ebx
  0016f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00174	e8 00 00 00 00	 call	 ?GetReallyConnectPartyMemberCount@PartyClass@@QAEHH@Z ; PartyClass::GetReallyConnectPartyMemberCount

; 8902 : 
; 8903 : 		if( lpMsg->Number == 0 && 

  00179	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  0017d	75 6b		 jne	 SHORT $LN19@CGPartyDel
  0017f	83 f8 01	 cmp	 eax, 1
  00182	7e 6b		 jle	 SHORT $LN36@CGPartyDel

; 8904 : 			nReallyConnectPartyMemberCount > 1 )
; 8905 : 		{
; 8906 : 			if( !gObj[aIndex].m_bIsMaintainParty )

  00184	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00189	80 bc 07 cc 26
	00 00 00	 cmp	 BYTE PTR [edi+eax+9932], 0
  00191	75 0d		 jne	 SHORT $LN21@CGPartyDel

; 8907 : 			{
; 8908 : 				gParty.Delete(pnumber,lpMsg->Number);

  00193	6a 00		 push	 0
  00195	53		 push	 ebx
  00196	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0019b	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete
$LN21@CGPartyDel:

; 8909 : 			}
; 8910 : 
; 8911 : 			gParty.UpdatePKPartyPanalty(pnumber);

  001a0	53		 push	 ebx
  001a1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001a6	e8 00 00 00 00	 call	 ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ; PartyClass::UpdatePKPartyPanalty

; 8912 : 			gParty.SwitchLeader(pnumber);

  001ab	53		 push	 ebx
  001ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  001b1	e8 00 00 00 00	 call	 ?SwitchLeader@PartyClass@@QAEXH@Z ; PartyClass::SwitchLeader

; 8913 : 			CGPartyListAll(pnumber);

  001b6	53		 push	 ebx
  001b7	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  001bc	83 c4 04	 add	 esp, 4
  001bf	5b		 pop	 ebx
  001c0	5f		 pop	 edi
  001c1	5e		 pop	 esi

; 8939 : 		}
; 8940 : 	}
; 8941 : 
; 8942 : 
; 8943 : }

  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c3		 ret	 0
$LN29@CGPartyDel:

; 8890 : 					gObj[number].IsInBattleGround )
; 8891 : 				{
; 8892 : 					GCServerMsgStringSend(lMsg.Get(MSGGET(13,216)),aIndex,1);

  001c6	6a 01		 push	 1
  001c8	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
$LN40@CGPartyDel:
  001cb	68 d8 0d 00 00	 push	 3544			; 00000dd8H
  001d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001d5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e3	5b		 pop	 ebx
  001e4	5f		 pop	 edi
  001e5	5e		 pop	 esi

; 8939 : 		}
; 8940 : 	}
; 8941 : 
; 8942 : 
; 8943 : }

  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c3		 ret	 0
$LN19@CGPartyDel:

; 8914 : 		}
; 8915 : 		else if( nReallyConnectPartyMemberCount > 1 )

  001ea	83 f8 01	 cmp	 eax, 1
  001ed	7f 76		 jg	 SHORT $LN39@CGPartyDel
$LN36@CGPartyDel:

; 8916 : 		{
; 8917 : 
; 8918 : 		}
; 8919 : 		else
; 8920 : 		{
; 8921 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  001ef	8b c3		 mov	 eax, ebx
  001f1	33 f6		 xor	 esi, esi
  001f3	c1 e0 04	 shl	 eax, 4
  001f6	2b c3		 sub	 eax, ebx
  001f8	8d 1c 85 0c 00
	00 00		 lea	 ebx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  001ff	90		 npad	 1
$LL7@CGPartyDel:

; 8922 : 			{
; 8923 : 				number = gParty.m_PartyS[pnumber].Number[n];

  00200	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 8924 : 
; 8925 : 				if( number >= 0 )

  00202	85 ff		 test	 edi, edi
  00204	78 49		 js	 SHORT $LN5@CGPartyDel

; 8926 : 				{
; 8927 : 					gParty.Delete(pnumber,n);

  00206	56		 push	 esi
  00207	ff 75 f8	 push	 DWORD PTR _pnumber$1$[ebp]
  0020a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0020f	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8928 : 					gObj[number].PartyNumber = -1;

  00214	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00219	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  0021f	c7 84 01 0c 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1548], -1

; 8929 : 					gObj[number].PartyTargetUser = -1;

  0022a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0022f	c7 84 01 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1552], -1

; 8930 : 
; 8931 : 					if( gObj[number].Connected == PLAYER_PLAYING )

  0023a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0023f	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00244	75 09		 jne	 SHORT $LN5@CGPartyDel

; 8932 : 					{
; 8933 : 						GCPartyDelUserSend(number);

  00246	57		 push	 edi
  00247	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend
  0024c	83 c4 04	 add	 esp, 4
$LN5@CGPartyDel:

; 8916 : 		{
; 8917 : 
; 8918 : 		}
; 8919 : 		else
; 8920 : 		{
; 8921 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  0024f	46		 inc	 esi
  00250	83 c3 04	 add	 ebx, 4
  00253	83 fe 05	 cmp	 esi, 5
  00256	7c a8		 jl	 SHORT $LL7@CGPartyDel

; 8934 : 					}
; 8935 : 				}
; 8936 : 			}
; 8937 : 
; 8938 : 			gParty.Destroy(pnumber);

  00258	ff 75 f8	 push	 DWORD PTR _pnumber$1$[ebp]
  0025b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00260	e8 00 00 00 00	 call	 ?Destroy@PartyClass@@QAEHH@Z ; PartyClass::Destroy
$LN39@CGPartyDel:
  00265	5b		 pop	 ebx
  00266	5f		 pop	 edi
  00267	5e		 pop	 esi

; 8939 : 		}
; 8940 : 	}
; 8941 : 
; 8942 : 
; 8943 : }

  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c3		 ret	 0
?CGPartyDelUserAsExitGameByForce@@YAXPAUPMSG_PARTYDELUSER@@H@Z ENDP ; CGPartyDelUserAsExitGameByForce
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z
_TEXT	SEGMENT
tv797 = -20						; size = 4
_dbnumber$ = -16					; size = 4
_count$2$ = -12						; size = 4
_usernumber$ = -8					; size = 4
tv795 = -1						; size = 1
_lpMsg$ = 8						; size = 4
tv780 = 12						; size = 4
_aIndex$ = 12						; size = 4
tv832 = 15						; size = 1
?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z PROC	; CGPartyDelUser, COMDAT

; 8611 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 8612 : 	int usernumber = -1;
; 8613 : 	int dbnumber = -1;
; 8614 : 
; 8615 : 	if ( gObj[aIndex].PartyNumber < 0 )

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	57		 push	 edi
  0000d	69 7d 0c 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00014	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _usernumber$[ebp], -1
  0001b	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _dbnumber$[ebp], -1
  00022	8b 94 39 0c 06
	00 00		 mov	 edx, DWORD PTR [ecx+edi+1548]
  00029	85 d2		 test	 edx, edx
  0002b	79 1f		 jns	 SHORT $LN14@CGPartyDel

; 8616 : 	{
; 8617 : 		LogAdd("No Party %s %s", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0002d	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00030	03 c1		 add	 eax, ecx
  00032	50		 push	 eax
  00033	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00036	03 c1		 add	 eax, ecx
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JLFGIHAP@No?5Party?5?$CFs?5?$CFs?$AA@
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
  00047	5f		 pop	 edi

; 8827 : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN14@CGPartyDel:

; 8618 : 		return;
; 8619 : 	}
; 8620 : 
; 8621 : 	if ( !gParty.GetIndexUser(gObj[aIndex].PartyNumber, lpMsg->Number, usernumber, dbnumber))

  0004c	8d 45 f0	 lea	 eax, DWORD PTR _dbnumber$[ebp]
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00054	50		 push	 eax
  00055	8d 45 f8	 lea	 eax, DWORD PTR _usernumber$[ebp]
  00058	50		 push	 eax
  00059	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0005c	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00060	50		 push	 eax
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ?GetIndexUser@PartyClass@@QAEHHHAAH0@Z ; PartyClass::GetIndexUser
  00067	85 c0		 test	 eax, eax
  00069	75 13		 jne	 SHORT $LN15@CGPartyDel
$LN97@CGPartyDel:

; 8622 : 	{
; 8623 : 		LogAdd("User Not found");

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GAPFACKC@User?5Not?5found?$AA@
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00076	83 c4 04	 add	 esp, 4
  00079	5f		 pop	 edi

; 8827 : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
$LN15@CGPartyDel:

; 8624 : 		return;
; 8625 : 	}
; 8626 : 
; 8627 : 	if ( usernumber < 0 )

  0007e	83 7d f8 00	 cmp	 DWORD PTR _usernumber$[ebp], 0
  00082	7c e7		 jl	 SHORT $LN97@CGPartyDel

; 8628 : 	{
; 8629 : 		LogAdd("User Not found");
; 8630 : 		return;
; 8631 : 	}
; 8632 : 
; 8633 : 	int count;
; 8634 : 	int number;
; 8635 : 	int pnumber = gObj[aIndex].PartyNumber;

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00089	8b bc 07 0c 06
	00 00		 mov	 edi, DWORD PTR [edi+eax+1548]

; 8636 : 
; 8637 : 	if ( pnumber < 0 )

  00090	85 ff		 test	 edi, edi
  00092	79 1d		 jns	 SHORT $LN17@CGPartyDel

; 8638 : 	{
; 8639 : 		LogAdd("%s %d", __FILE__, __LINE__);

  00094	68 bf 21 00 00	 push	 8639			; 000021bfH
$LN98@CGPartyDel:
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	5f		 pop	 edi

; 8827 : }

  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
$LN17@CGPartyDel:

; 8640 : 		return;
; 8641 : 	}
; 8642 : 
; 8643 : 	count = gParty.GetCount(pnumber);

  000b1	57		 push	 edi
  000b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000b7	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  000bc	89 45 f4	 mov	 DWORD PTR _count$2$[ebp], eax

; 8644 : 
; 8645 : 	if ( count < 1 )

  000bf	83 f8 01	 cmp	 eax, 1
  000c2	7d 07		 jge	 SHORT $LN18@CGPartyDel

; 8646 : 	{
; 8647 : 		LogAdd("%s %d", __FILE__, __LINE__);

  000c4	68 c7 21 00 00	 push	 8647			; 000021c7H

; 8648 : 		return;

  000c9	eb ce		 jmp	 SHORT $LN98@CGPartyDel
$LN18@CGPartyDel:
  000cb	53		 push	 ebx

; 8649 : 	}
; 8650 : 
; 8651 : 	if( !IF_MAP_RANGE(gObj[usernumber].MapNumber) &&

  000cc	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d2	56		 push	 esi
  000d3	8b 75 f8	 mov	 esi, DWORD PTR _usernumber$[ebp]
  000d6	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  000dc	8a 8c 18 23 01
	00 00		 mov	 cl, BYTE PTR [eax+ebx+291]
  000e3	80 f9 45	 cmp	 cl, 69			; 00000045H
  000e6	72 0b		 jb	 SHORT $LN79@CGPartyDel
  000e8	b0 48		 mov	 al, 72			; 00000048H
  000ea	3a c1		 cmp	 al, cl
  000ec	1b c0		 sbb	 eax, eax
  000ee	83 c0 01	 add	 eax, 1
  000f1	75 2b		 jne	 SHORT $LN19@CGPartyDel
$LN79@CGPartyDel:
  000f3	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  000f6	72 0b		 jb	 SHORT $LN80@CGPartyDel
  000f8	b0 32		 mov	 al, 50			; 00000032H
  000fa	3a c1		 cmp	 al, cl
  000fc	1b c0		 sbb	 eax, eax
  000fe	83 c0 01	 add	 eax, 1
  00101	75 1b		 jne	 SHORT $LN19@CGPartyDel
$LN80@CGPartyDel:

; 8652 : 		!IT_MAP_RANGE(gObj[usernumber].MapNumber) )
; 8653 : 	{
; 8654 : 		TidyUpTempuserdate(usernumber,pnumber,lpMsg->Number);

  00103	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00106	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  0010a	50		 push	 eax
  0010b	57		 push	 edi
  0010c	56		 push	 esi
  0010d	e8 00 00 00 00	 call	 ?TidyUpTempuserdate@@YAXHHE@Z ; TidyUpTempuserdate
  00112	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011b	8b 75 f8	 mov	 esi, DWORD PTR _usernumber$[ebp]
$LN19@CGPartyDel:

; 8655 : 	}
; 8656 : 
; 8657 : 	if( DG_MAP_RANGE(gObj[usernumber].MapNumber) )

  0011e	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  00124	03 c3		 add	 eax, ebx
  00126	89 45 ec	 mov	 DWORD PTR tv797[ebp], eax
  00129	8a 80 23 01 00
	00		 mov	 al, BYTE PTR [eax+291]
  0012f	88 45 ff	 mov	 BYTE PTR tv795[ebp], al
  00132	3c 41		 cmp	 al, 65			; 00000041H
  00134	72 0f		 jb	 SHORT $LN81@CGPartyDel
  00136	b1 44		 mov	 cl, 68			; 00000044H
  00138	3a c8		 cmp	 cl, al
  0013a	1b c0		 sbb	 eax, eax
  0013c	83 c0 01	 add	 eax, 1
  0013f	0f 85 86 04 00
	00		 jne	 $LN91@CGPartyDel
$LN81@CGPartyDel:

; 8658 : 		return;
; 8659 : 
; 8660 : 	if( lpMsg->Number == 0 )

  00145	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00148	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  0014b	88 4d 0f	 mov	 BYTE PTR tv832[ebp], cl
  0014e	84 c9		 test	 cl, cl
  00150	75 46		 jne	 SHORT $LN85@CGPartyDel

; 8661 : 	{
; 8662 : 		int bDPUser = FALSE;
; 8663 : 
; 8664 : 		for(int n = 1; n < MAX_USER_IN_PARTY; n++)

  00152	8b c7		 mov	 eax, edi
  00154	ba 01 00 00 00	 mov	 edx, 1
  00159	c1 e0 04	 shl	 eax, 4
  0015c	2b c7		 sub	 eax, edi
  0015e	8d 0c 85 10 00
	00 00		 lea	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+16]
$LL4@CGPartyDel:

; 8665 : 		{
; 8666 : 			int nUserIndex = gParty.m_PartyS[pnumber].Number[n];

  00165	8b 01		 mov	 eax, DWORD PTR [ecx]

; 8667 : 
; 8668 : 			if( nUserIndex != -1 )

  00167	83 f8 ff	 cmp	 eax, -1
  0016a	74 20		 je	 SHORT $LN2@CGPartyDel

; 8669 : 			{
; 8670 : 				if( DG_MAP_RANGE(gObj[nUserIndex].MapNumber) )

  0016c	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00172	8a 84 18 23 01
	00 00		 mov	 al, BYTE PTR [eax+ebx+291]
  00179	3c 41		 cmp	 al, 65			; 00000041H
  0017b	72 0f		 jb	 SHORT $LN2@CGPartyDel
  0017d	b4 44		 mov	 ah, 68			; 00000044H
  0017f	3a e0		 cmp	 ah, al
  00181	1b c0		 sbb	 eax, eax
  00183	83 c0 01	 add	 eax, 1
  00186	0f 85 9c 00 00
	00		 jne	 $LN64@CGPartyDel
$LN2@CGPartyDel:

; 8661 : 	{
; 8662 : 		int bDPUser = FALSE;
; 8663 : 
; 8664 : 		for(int n = 1; n < MAX_USER_IN_PARTY; n++)

  0018c	42		 inc	 edx
  0018d	83 c1 04	 add	 ecx, 4
  00190	83 fa 05	 cmp	 edx, 5
  00193	7c d0		 jl	 SHORT $LL4@CGPartyDel
$LN90@CGPartyDel:
  00195	8a 4d 0f	 mov	 cl, BYTE PTR tv832[ebp]
$LN85@CGPartyDel:

; 8693 : 		}
; 8694 : 	}
; 8695 : 
; 8696 : 	if( IF_MAP_RANGE(gObj[usernumber].MapNumber) )

  00198	8a 45 ff	 mov	 al, BYTE PTR tv795[ebp]
  0019b	3c 45		 cmp	 al, 69			; 00000045H
  0019d	72 0f		 jb	 SHORT $LN83@CGPartyDel
  0019f	b2 48		 mov	 dl, 72			; 00000048H
  001a1	3a d0		 cmp	 dl, al
  001a3	1b c0		 sbb	 eax, eax
  001a5	83 c0 01	 add	 eax, 1
  001a8	0f 85 1d 04 00
	00		 jne	 $LN91@CGPartyDel
$LN83@CGPartyDel:

; 8697 : 		return;
; 8698 : 
; 8699 : 	if( lpMsg->Number == 0 )

  001ae	84 c9		 test	 cl, cl
  001b0	75 43		 jne	 SHORT $LN86@CGPartyDel

; 8700 : 	{
; 8701 : 		int bDPUser = FALSE;
; 8702 : 
; 8703 : 		for(int n = 1; n < MAX_USER_IN_PARTY; n++)

  001b2	8b c7		 mov	 eax, edi
  001b4	ba 01 00 00 00	 mov	 edx, 1
  001b9	c1 e0 04	 shl	 eax, 4
  001bc	2b c7		 sub	 eax, edi
  001be	8d 0c 85 10 00
	00 00		 lea	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+16]
$LL7@CGPartyDel:

; 8704 : 		{
; 8705 : 			int nUserIndex = gParty.m_PartyS[pnumber].Number[n];

  001c5	8b 01		 mov	 eax, DWORD PTR [ecx]

; 8706 : 
; 8707 : 			if( nUserIndex != -1 )

  001c7	83 f8 ff	 cmp	 eax, -1
  001ca	74 20		 je	 SHORT $LN5@CGPartyDel

; 8708 : 			{
; 8709 : 				if( IF_MAP_RANGE(gObj[nUserIndex].MapNumber) )

  001cc	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  001d2	8a 84 18 23 01
	00 00		 mov	 al, BYTE PTR [eax+ebx+291]
  001d9	3c 45		 cmp	 al, 69			; 00000045H
  001db	72 0f		 jb	 SHORT $LN5@CGPartyDel
  001dd	b4 48		 mov	 ah, 72			; 00000048H
  001df	3a e0		 cmp	 ah, al
  001e1	1b c0		 sbb	 eax, eax
  001e3	83 c0 01	 add	 eax, 1
  001e6	0f 85 8e 00 00
	00		 jne	 $LN65@CGPartyDel
$LN5@CGPartyDel:

; 8700 : 	{
; 8701 : 		int bDPUser = FALSE;
; 8702 : 
; 8703 : 		for(int n = 1; n < MAX_USER_IN_PARTY; n++)

  001ec	42		 inc	 edx
  001ed	83 c1 04	 add	 ecx, 4
  001f0	83 fa 05	 cmp	 edx, 5
  001f3	7c d0		 jl	 SHORT $LL7@CGPartyDel
$LN86@CGPartyDel:

; 8730 : 				usernumber,gObj[usernumber].AccountID,gObj[usernumber].Name);
; 8731 : 			return;
; 8732 : 		}
; 8733 : 	}
; 8734 : 
; 8735 : 	if( gObj[usernumber].lpGuild != NULL )

  001f5	8b 4d ec	 mov	 ecx, DWORD PTR tv797[ebp]
  001f8	8b 81 18 06 00
	00		 mov	 eax, DWORD PTR [ecx+1560]
  001fe	85 c0		 test	 eax, eax
  00200	0f 84 61 01 00
	00		 je	 $LN87@CGPartyDel

; 8736 : 	{
; 8737 : 		if( gObj[usernumber].lpGuild->WarState == 1 &&

  00206	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  0020d	0f 85 08 01 00
	00		 jne	 $LN31@CGPartyDel
  00213	80 b9 de 13 00
	00 00		 cmp	 BYTE PTR [ecx+5086], 0
  0021a	0f 84 fb 00 00
	00		 je	 $LN31@CGPartyDel

; 8738 : 			gObj[usernumber].IsInBattleGround )
; 8739 : 		{
; 8740 : 			GCServerMsgStringSend(lMsg.Get(MSGGET(13,216)),usernumber,1);

  00220	6a 01		 push	 1
  00222	56		 push	 esi

; 8741 : 			return;

  00223	e9 b3 01 00 00	 jmp	 $LN95@CGPartyDel
$LN64@CGPartyDel:

; 8671 : 				{
; 8672 : 					bDPUser = TRUE;
; 8673 : 					break;
; 8674 : 				}
; 8675 : 			}
; 8676 : 		}
; 8677 : 
; 8678 : 		if( bDPUser == TRUE && count > 2 )

  00228	83 7d f4 02	 cmp	 DWORD PTR _count$2$[ebp], 2
  0022c	0f 8e 63 ff ff
	ff		 jle	 $LN90@CGPartyDel

; 8679 : 		{
; 8680 : 			gParty.Delete(pnumber,lpMsg->Number);

  00232	6a 00		 push	 0
  00234	57		 push	 edi
  00235	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0023a	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8681 : 			count = gParty.GetCount(pnumber);

  0023f	57		 push	 edi
  00240	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00245	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 8682 : 			gObj[usernumber].PartyNumber = -1;

  0024a	69 55 f8 40 27
	00 00		 imul	 edx, DWORD PTR _usernumber$[ebp], 10048
  00251	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00256	c7 84 02 0c 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+eax+1548], -1

; 8683 : 			gObj[usernumber].PartyTargetUser = -1;

  00261	69 55 f8 40 27
	00 00		 imul	 edx, DWORD PTR _usernumber$[ebp], 10048
  00268	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026d	c7 84 02 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+eax+1552], -1

; 8684 : 
; 8685 : 			gParty.UpdatePKPartyPanalty(pnumber);
; 8686 : 			gParty.ChangeLeader(pnumber);
; 8687 : 			GCPartyDelUserSend(usernumber);
; 8688 : 			CGPartyListAll(pnumber);
; 8689 : 
; 8690 : 			LogAddTD("PartyMember(%d) : Party Out. [%s][%s]",
; 8691 : 				usernumber,gObj[usernumber].AccountID,gObj[usernumber].Name);
; 8692 : 			return;

  00278	eb 50		 jmp	 SHORT $LN96@CGPartyDel
$LN65@CGPartyDel:

; 8710 : 				{
; 8711 : 					bDPUser = TRUE;
; 8712 : 					break;
; 8713 : 				}
; 8714 : 			}
; 8715 : 		}
; 8716 : 
; 8717 : 		if( bDPUser == TRUE && count > 2 )

  0027a	83 7d f4 02	 cmp	 DWORD PTR _count$2$[ebp], 2
  0027e	0f 8e 71 ff ff
	ff		 jle	 $LN86@CGPartyDel

; 8718 : 		{
; 8719 : 			gParty.Delete(pnumber,lpMsg->Number);

  00284	6a 00		 push	 0
  00286	57		 push	 edi
  00287	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0028c	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8720 : 			count = gParty.GetCount(pnumber);

  00291	57		 push	 edi
  00292	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00297	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 8721 : 			gObj[usernumber].PartyNumber = -1;

  0029c	69 4d f8 40 27
	00 00		 imul	 ecx, DWORD PTR _usernumber$[ebp], 10048
  002a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a8	c7 84 01 0c 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1548], -1

; 8722 : 			gObj[usernumber].PartyTargetUser = -1;

  002b3	69 4d f8 40 27
	00 00		 imul	 ecx, DWORD PTR _usernumber$[ebp], 10048
  002ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002bf	c7 84 01 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1552], -1
$LN96@CGPartyDel:

; 8723 : 
; 8724 : 			gParty.UpdatePKPartyPanalty(pnumber);

  002ca	57		 push	 edi
  002cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  002d0	e8 00 00 00 00	 call	 ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ; PartyClass::UpdatePKPartyPanalty

; 8725 : 			gParty.ChangeLeader(pnumber);

  002d5	57		 push	 edi
  002d6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  002db	e8 00 00 00 00	 call	 ?ChangeLeader@PartyClass@@QAEXH@Z ; PartyClass::ChangeLeader

; 8726 : 			GCPartyDelUserSend(usernumber);

  002e0	ff 75 f8	 push	 DWORD PTR _usernumber$[ebp]
  002e3	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 8727 : 			CGPartyListAll(pnumber);

  002e8	57		 push	 edi
  002e9	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll

; 8728 : 
; 8729 : 			LogAddTD("PartyMember(%d) : Party Out. [%s][%s]",

  002ee	8b 55 f8	 mov	 edx, DWORD PTR _usernumber$[ebp]
  002f1	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  002f7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002fd	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00300	50		 push	 eax
  00301	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00304	50		 push	 eax
  00305	52		 push	 edx
  00306	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@IDLFABNI@PartyMember?$CI?$CFd?$CJ?5?3?5Party?5Out?4?5?$FL?$CFs@
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00311	83 c4 18	 add	 esp, 24			; 00000018H
  00314	5e		 pop	 esi
  00315	5b		 pop	 ebx
  00316	5f		 pop	 edi

; 8827 : }

  00317	8b e5		 mov	 esp, ebp
  00319	5d		 pop	 ebp
  0031a	c3		 ret	 0
$LN31@CGPartyDel:

; 8742 : 		}
; 8743 : 
; 8744 : 		if( usernumber == gParty.m_PartyS[pnumber].Number[0] )

  0031b	8b c7		 mov	 eax, edi
  0031d	c1 e0 04	 shl	 eax, 4
  00320	2b c7		 sub	 eax, edi
  00322	3b 34 85 0c 00
	00 00		 cmp	 esi, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  00329	8d 0c 85 0c 00
	00 00		 lea	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  00330	75 35		 jne	 SHORT $LN87@CGPartyDel

; 8745 : 		{
; 8746 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00332	33 d2		 xor	 edx, edx
$LL10@CGPartyDel:

; 8747 : 			{
; 8748 : 				number = gParty.m_PartyS[pnumber].Number[n];

  00334	8b 01		 mov	 eax, DWORD PTR [ecx]

; 8749 : 				
; 8750 : 				if( number >= 0 &&
; 8751 : 					gObj[number].lpGuild != NULL &&
; 8752 : 					gObj[number].lpGuild->WarState == 1 &&

  00336	85 c0		 test	 eax, eax
  00338	78 24		 js	 SHORT $LN8@CGPartyDel
  0033a	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  00340	8b 84 1e 18 06
	00 00		 mov	 eax, DWORD PTR [esi+ebx+1560]
  00347	85 c0		 test	 eax, eax
  00349	74 13		 je	 SHORT $LN8@CGPartyDel
  0034b	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  00352	75 0a		 jne	 SHORT $LN8@CGPartyDel
  00354	80 bc 1e de 13
	00 00 00	 cmp	 BYTE PTR [esi+ebx+5086], 0
  0035c	75 78		 jne	 SHORT $LN66@CGPartyDel
$LN8@CGPartyDel:

; 8745 : 		{
; 8746 : 			for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  0035e	42		 inc	 edx
  0035f	83 c1 04	 add	 ecx, 4
  00362	83 fa 05	 cmp	 edx, 5
  00365	7c cd		 jl	 SHORT $LL10@CGPartyDel
$LN87@CGPartyDel:

; 8756 : 					return;
; 8757 : 				}
; 8758 : 			}
; 8759 : 		}
; 8760 : 	}
; 8761 : 
; 8762 : 	if( (lpMsg->Number == 0 || count <= 2) )

  00367	8a 5d 0f	 mov	 bl, BYTE PTR tv832[ebp]
  0036a	8b 55 f4	 mov	 edx, DWORD PTR _count$2$[ebp]
  0036d	84 db		 test	 bl, bl
  0036f	0f 84 85 00 00
	00		 je	 $LN35@CGPartyDel
  00375	83 fa 02	 cmp	 edx, 2
  00378	0f 8e 7c 00 00
	00		 jle	 $LN35@CGPartyDel

; 8817 : 		return;
; 8818 : 	}
; 8819 : 
; 8820 : 	gParty.Delete(pnumber,lpMsg->Number);

  0037e	0f b6 c3	 movzx	 eax, bl
  00381	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00386	50		 push	 eax
  00387	57		 push	 edi
  00388	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8821 : 	count = gParty.GetCount(pnumber);

  0038d	57		 push	 edi
  0038e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00393	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 8822 : 	gObj[usernumber].PartyNumber = -1;

  00398	69 4d f8 40 27
	00 00		 imul	 ecx, DWORD PTR _usernumber$[ebp], 10048
  0039f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 8823 : 	gObj[usernumber].PartyTargetUser = -1;
; 8824 : 	gParty.UpdatePKPartyPanalty(pnumber);

  003a4	57		 push	 edi
  003a5	c7 84 01 0c 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1548], -1
  003b0	69 4d f8 40 27
	00 00		 imul	 ecx, DWORD PTR _usernumber$[ebp], 10048
  003b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003bc	c7 84 01 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1552], -1
  003c7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  003cc	e8 00 00 00 00	 call	 ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ; PartyClass::UpdatePKPartyPanalty

; 8825 : 	GCPartyDelUserSend(usernumber);
; 8826 : 	CGPartyListAll(pnumber);

  003d1	e9 69 01 00 00	 jmp	 $LN41@CGPartyDel
$LN66@CGPartyDel:

; 8753 : 					gObj[number].IsInBattleGround )
; 8754 : 				{
; 8755 : 					GCServerMsgStringSend(lMsg.Get(MSGGET(13,216)),usernumber,1);

  003d6	6a 01		 push	 1
  003d8	ff 75 f8	 push	 DWORD PTR _usernumber$[ebp]
$LN95@CGPartyDel:
  003db	68 d8 0d 00 00	 push	 3544			; 00000dd8H
  003e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003e5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003ea	50		 push	 eax
  003eb	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003f0	83 c4 0c	 add	 esp, 12			; 0000000cH
  003f3	5e		 pop	 esi
  003f4	5b		 pop	 ebx
  003f5	5f		 pop	 edi

; 8827 : }

  003f6	8b e5		 mov	 esp, ebp
  003f8	5d		 pop	 ebp
  003f9	c3		 ret	 0
$LN35@CGPartyDel:

; 8763 : 	{
; 8764 : 		if( IT_MAP_RANGE(gObj[usernumber].MapNumber) )

  003fa	8a 4d ff	 mov	 cl, BYTE PTR tv795[ebp]
  003fd	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00400	0f 82 51 01 00
	00		 jb	 $LN40@CGPartyDel
  00406	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  0040b	3a c1		 cmp	 al, cl
  0040d	1b c0		 sbb	 eax, eax
  0040f	83 c0 01	 add	 eax, 1
  00412	0f 84 9c 00 00
	00		 je	 $LN37@CGPartyDel

; 8765 : 		{
; 8766 : 			if( lpMsg->Number == 0 && count > 2 )

  00418	84 db		 test	 bl, bl
  0041a	0f 85 94 00 00
	00		 jne	 $LN37@CGPartyDel
  00420	83 fa 02	 cmp	 edx, 2
  00423	0f 8e 8b 00 00
	00		 jle	 $LN37@CGPartyDel

; 8767 : 			{
; 8768 : 				gParty.Delete(pnumber,lpMsg->Number);

  00429	6a 00		 push	 0
  0042b	57		 push	 edi
  0042c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00431	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8769 : 				count = gParty.GetCount(pnumber);

  00436	57		 push	 edi
  00437	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0043c	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 8770 : 				gObj[usernumber].PartyNumber = -1;

  00441	69 55 f8 40 27
	00 00		 imul	 edx, DWORD PTR _usernumber$[ebp], 10048
  00448	8b f0		 mov	 esi, eax
  0044a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 8771 : 				gObj[usernumber].PartyTargetUser = -1;
; 8772 : 				gParty.UpdatePKPartyPanalty(pnumber);

  00450	57		 push	 edi
  00451	c7 84 0a 0c 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+ecx+1548], -1
  0045c	69 55 f8 40 27
	00 00		 imul	 edx, DWORD PTR _usernumber$[ebp], 10048
  00463	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00469	c7 84 0a 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+ecx+1552], -1
  00474	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00479	e8 00 00 00 00	 call	 ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ; PartyClass::UpdatePKPartyPanalty

; 8773 : 				gParty.ChangeLeader(pnumber);

  0047e	57		 push	 edi
  0047f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00484	e8 00 00 00 00	 call	 ?ChangeLeader@PartyClass@@QAEXH@Z ; PartyClass::ChangeLeader

; 8774 : 				GCPartyDelUserSend(usernumber);

  00489	ff 75 f8	 push	 DWORD PTR _usernumber$[ebp]
  0048c	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 8775 : 				CGPartyListAll(pnumber);

  00491	57		 push	 edi
  00492	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  00497	83 c4 08	 add	 esp, 8

; 8776 : 
; 8777 : 				if( count == 0 )

  0049a	85 f6		 test	 esi, esi
  0049c	0f 85 29 01 00
	00		 jne	 $LN91@CGPartyDel

; 8813 : 			}
; 8814 : 		}
; 8815 : 
; 8816 : 		gParty.Destroy(pnumber);

  004a2	57		 push	 edi
  004a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  004a8	e8 00 00 00 00	 call	 ?Destroy@PartyClass@@QAEHH@Z ; PartyClass::Destroy
  004ad	5e		 pop	 esi
  004ae	5b		 pop	 ebx
  004af	5f		 pop	 edi

; 8827 : }

  004b0	8b e5		 mov	 esp, ebp
  004b2	5d		 pop	 ebp
  004b3	c3		 ret	 0
$LN37@CGPartyDel:

; 8778 : 					gParty.Destroy(pnumber);
; 8779 : 				return;
; 8780 : 			}
; 8781 : 		}
; 8782 : 		
; 8783 : 		if( IT_MAP_RANGE(gObj[usernumber].MapNumber) )

  004b4	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  004b7	0f 82 9a 00 00
	00		 jb	 $LN40@CGPartyDel
  004bd	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  004c2	3a c1		 cmp	 al, cl
  004c4	1b c0		 sbb	 eax, eax
  004c6	83 c0 01	 add	 eax, 1
  004c9	0f 84 88 00 00
	00		 je	 $LN40@CGPartyDel

; 8784 : 		{
; 8785 : 			if( count <= 2 )

  004cf	83 fa 02	 cmp	 edx, 2
  004d2	0f 8f 7f 00 00
	00		 jg	 $LN40@CGPartyDel

; 8786 : 			{
; 8787 : 				gParty.Delete(pnumber,lpMsg->Number);

  004d8	0f b6 c3	 movzx	 eax, bl
  004db	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  004e0	50		 push	 eax
  004e1	57		 push	 edi
  004e2	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8788 : 				count = gParty.GetCount(pnumber);

  004e7	57		 push	 edi
  004e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  004ed	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount

; 8789 : 				gObj[usernumber].PartyNumber = -1;

  004f2	69 4d f8 40 27
	00 00		 imul	 ecx, DWORD PTR _usernumber$[ebp], 10048
  004f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 8790 : 				gObj[usernumber].PartyTargetUser = -1;
; 8791 : 				gParty.UpdatePKPartyPanalty(pnumber);

  004fe	57		 push	 edi
  004ff	c7 84 01 0c 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1548], -1
  0050a	69 4d f8 40 27
	00 00		 imul	 ecx, DWORD PTR _usernumber$[ebp], 10048
  00511	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00516	c7 84 01 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1552], -1
  00521	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00526	e8 00 00 00 00	 call	 ?UpdatePKPartyPanalty@PartyClass@@QAEXH@Z ; PartyClass::UpdatePKPartyPanalty

; 8792 : 
; 8793 : 				if( lpMsg->Number == 0 )

  0052b	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0052e	80 78 03 00	 cmp	 BYTE PTR [eax+3], 0
  00532	75 0b		 jne	 SHORT $LN41@CGPartyDel

; 8794 : 					gParty.ChangeLeader(pnumber);

  00534	57		 push	 edi
  00535	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0053a	e8 00 00 00 00	 call	 ?ChangeLeader@PartyClass@@QAEXH@Z ; PartyClass::ChangeLeader
$LN41@CGPartyDel:

; 8795 : 
; 8796 : 				GCPartyDelUserSend(usernumber);

  0053f	ff 75 f8	 push	 DWORD PTR _usernumber$[ebp]
  00542	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend

; 8797 : 				CGPartyListAll(pnumber);

  00547	57		 push	 edi
  00548	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  0054d	83 c4 08	 add	 esp, 8
  00550	5e		 pop	 esi
  00551	5b		 pop	 ebx
  00552	5f		 pop	 edi

; 8827 : }

  00553	8b e5		 mov	 esp, ebp
  00555	5d		 pop	 ebp
  00556	c3		 ret	 0
$LN40@CGPartyDel:

; 8798 : 				return;
; 8799 : 			}
; 8800 : 		}
; 8801 : 
; 8802 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  00557	8b c7		 mov	 eax, edi
  00559	33 f6		 xor	 esi, esi
  0055b	c1 e0 04	 shl	 eax, 4
  0055e	2b c7		 sub	 eax, edi
  00560	8d 04 85 0c 00
	00 00		 lea	 eax, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+12]
  00567	89 45 0c	 mov	 DWORD PTR tv780[ebp], eax
  0056a	66 0f 1f 44 00
	00		 npad	 6
$LL13@CGPartyDel:

; 8803 : 		{
; 8804 : 			number = gParty.m_PartyS[pnumber].Number[n];

  00570	8b 18		 mov	 ebx, DWORD PTR [eax]

; 8805 : 
; 8806 : 			if( number >= 0 )

  00572	85 db		 test	 ebx, ebx
  00574	78 3e		 js	 SHORT $LN11@CGPartyDel

; 8807 : 			{
; 8808 : 				gParty.Delete(pnumber,n);

  00576	56		 push	 esi
  00577	57		 push	 edi
  00578	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0057d	e8 00 00 00 00	 call	 ?Delete@PartyClass@@QAEXHH@Z ; PartyClass::Delete

; 8809 : 				gObj[number].PartyNumber = -1;

  00582	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00587	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048

; 8810 : 				gObj[number].PartyTargetUser = -1;
; 8811 : 
; 8812 : 				GCPartyDelUserSend(number);

  0058d	53		 push	 ebx
  0058e	c7 84 01 0c 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1548], -1
  00599	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0059e	c7 84 01 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+1552], -1
  005a9	e8 00 00 00 00	 call	 ?GCPartyDelUserSend@@YAXH@Z ; GCPartyDelUserSend
  005ae	8b 45 0c	 mov	 eax, DWORD PTR tv780[ebp]
  005b1	83 c4 04	 add	 esp, 4
$LN11@CGPartyDel:

; 8798 : 				return;
; 8799 : 			}
; 8800 : 		}
; 8801 : 
; 8802 : 		for(int n = 0; n < MAX_USER_IN_PARTY; n++)

  005b4	46		 inc	 esi
  005b5	83 c0 04	 add	 eax, 4
  005b8	89 45 0c	 mov	 DWORD PTR tv780[ebp], eax
  005bb	83 fe 05	 cmp	 esi, 5
  005be	7c b0		 jl	 SHORT $LL13@CGPartyDel

; 8813 : 			}
; 8814 : 		}
; 8815 : 
; 8816 : 		gParty.Destroy(pnumber);

  005c0	57		 push	 edi
  005c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  005c6	e8 00 00 00 00	 call	 ?Destroy@PartyClass@@QAEHH@Z ; PartyClass::Destroy
$LN91@CGPartyDel:
  005cb	5e		 pop	 esi
  005cc	5b		 pop	 ebx
  005cd	5f		 pop	 edi

; 8827 : }

  005ce	8b e5		 mov	 esp, ebp
  005d0	5d		 pop	 ebp
  005d1	c3		 ret	 0
?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ENDP	; CGPartyDelUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPartyListAll@@YAXH@Z
_TEXT	SEGMENT
_pList$ = -572						; size = 36
tv390 = -536						; size = 4
tv392 = -532						; size = 4
_lOfs$1$ = -528						; size = 4
_pCount$ = -524						; size = 5
_sendbuf$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_pnumber$ = 8						; size = 4
?CGPartyListAll@@YAXH@Z PROC				; CGPartyListAll, COMDAT

; 8542 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 02 00
	00		 sub	 esp, 572		; 0000023cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _pnumber$[ebp]

; 8543 : 	PMSG_PARTYLISTCOUNT pCount;
; 8544 : 	PMSG_PARTYLIST pList;
; 8545 : 	BYTE sendbuf[512];
; 8546 : 	int lOfs = 0;
; 8547 : 	int number;
; 8548 : 	int n;
; 8549 : 
; 8550 : 	if ( pnumber < 0 )

  00017	85 f6		 test	 esi, esi
  00019	0f 88 18 02 00
	00		 js	 $LN6@CGPartyLis

; 8551 : 		return;
; 8552 : 
; 8553 : 	if ( gParty.IsParty(pnumber) == FALSE )

  0001f	56		 push	 esi
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00025	e8 00 00 00 00	 call	 ?IsParty@PartyClass@@QAEHH@Z ; PartyClass::IsParty
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 05 02 00
	00		 je	 $LN6@CGPartyLis

; 8554 : 		return;
; 8555 : 
; 8556 : 	PHeadSetB((LPBYTE)&pCount, 0x42, sizeof(pCount));

  00032	6a 05		 push	 5
  00034	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0003a	6a 42		 push	 66			; 00000042H
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8557 : 	pCount.Result = false;

  00045	c6 85 f7 fd ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+3], 0

; 8558 : 	pCount.Count = gParty.GetCount(pnumber);

  0004c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  00057	88 85 f8 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], al

; 8559 : 
; 8560 : 	if ( pCount.Count == 0 )

  0005d	84 c0		 test	 al, al
  0005f	0f 84 d2 01 00
	00		 je	 $LN6@CGPartyLis

; 8561 : 		return;
; 8562 : 
; 8563 : 	pCount.Result = true;

  00065	8d 85 01 fe ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp+5]
  0006b	c6 85 f7 fd ff
	ff 01		 mov	 BYTE PTR _pCount$[ebp+3], 1
  00072	89 85 ec fd ff
	ff		 mov	 DWORD PTR tv392[ebp], eax

; 8564 : 	lOfs += sizeof(pCount);

  00078	b9 05 00 00 00	 mov	 ecx, 5
  0007d	8b c6		 mov	 eax, esi
  0007f	89 8d f0 fd ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
  00085	c1 e0 04	 shl	 eax, 4
  00088	53		 push	 ebx
  00089	2b c6		 sub	 eax, esi

; 8565 : 
; 8566 : 	for (n=0;n<MAX_USER_IN_PARTY;n++)

  0008b	33 db		 xor	 ebx, ebx
  0008d	c1 e0 02	 shl	 eax, 2
  00090	57		 push	 edi
  00091	89 85 e8 fd ff
	ff		 mov	 DWORD PTR tv390[ebp], eax
  00097	8d b0 20 00 00
	00		 lea	 esi, DWORD PTR ?gParty@@3VPartyClass@@A[eax+32]
  0009d	0f 1f 00	 npad	 3
$LL4@CGPartyLis:

; 8567 : 	{
; 8568 : 		number = gParty.m_PartyS[pnumber].Number[n];

  000a0	8b 46 ec	 mov	 eax, DWORD PTR [esi-20]

; 8569 : 
; 8570 : 		if ( number >= 0 )

  000a3	85 c0		 test	 eax, eax
  000a5	0f 88 26 01 00
	00		 js	 $LN2@CGPartyLis

; 8571 : 		{
; 8572 : 			if ( gObjIsConnected(&gObj[number], gParty.m_PartyS[pnumber].DbNumber[n]) == TRUE )

  000ab	ff 36		 push	 DWORD PTR [esi]
  000ad	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b8	03 c7		 add	 eax, edi
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjIsConnected
  000c0	83 c4 08	 add	 esp, 8
  000c3	83 f8 01	 cmp	 eax, 1
  000c6	0f 85 ff 00 00
	00		 jne	 $LN24@CGPartyLis

; 8573 : 			{
; 8574 : 				memset(&pList, 0, sizeof(pList));
; 8575 : 				memcpy(pList.szId, gObj[number].Name, MAX_ACCOUNT_LEN);

  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d2	0f 57 c0	 xorps	 xmm0, xmm0
  000d5	0f 11 85 c4 fd
	ff ff		 movups	 XMMWORD PTR _pList$[ebp], xmm0

; 8576 : 				pList.Number = n;

  000dc	88 9d ce fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+10], bl
  000e2	0f 11 85 d4 fd
	ff ff		 movups	 XMMWORD PTR _pList$[ebp+16], xmm0
  000e9	66 8b 44 0f 65	 mov	 ax, WORD PTR [edi+ecx+101]
  000ee	66 89 85 cc fd
	ff ff		 mov	 WORD PTR _pList$[ebp+8], ax

; 8577 : 				pList.MapNumber = gObj[number].MapNumber;

  000f5	0f b6 84 0f 23
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+291]
  000fd	f3 0f 7e 44 0f
	5d		 movq	 xmm0, QWORD PTR [edi+ecx+93]
  00103	88 85 cf fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], al

; 8578 : 				pList.X = gObj[number].X;

  00109	0f b6 84 0f 20
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+288]
  00111	88 85 d0 fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+12], al

; 8579 : 				pList.Y = gObj[number].Y;

  00117	0f b6 84 0f 21
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+289]
  0011f	88 85 d1 fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+13], al

; 8580 : 				pList.Life = (int)gObj[number].Life;

  00125	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  0012e	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _pList$[ebp+32], 0
  00138	66 0f d6 85 c4
	fd ff ff	 movq	 QWORD PTR _pList$[ebp], xmm0
  00140	66 0f 6e 84 0f
	28 01 00 00	 movd	 xmm0, DWORD PTR [edi+ecx+296]
  00149	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+16], eax

; 8581 : 				pList.MaxLife =  (int)gObj[number].MaxLife;

  0014f	f3 0f 2c 84 0f
	dc 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+220]

; 8582 : 				pList.Mana = (int)gObj[number].Mana;
; 8583 : 				pList.MaxMana = (int)(gObj[number].MaxMana + gObj[number].AddMana);

  00158	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0015b	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+20], eax
  00161	f3 0f 2c 84 0f
	ec 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+236]
  0016a	f3 0f 58 84 0f
	f0 00 00 00	 addss	 xmm0, DWORD PTR [edi+ecx+240]
  00173	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+28], eax

; 8584 : 				pList.ServerCode = gGameServerCode % 20 + 1;

  00179	bf 14 00 00 00	 mov	 edi, 20			; 00000014H
  0017e	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  00185	99		 cdq
  00186	f7 ff		 idiv	 edi
  00188	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0018c	42		 inc	 edx
  0018d	89 95 dc fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+24], edx

; 8585 : 
; 8586 : 				memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  00193	8b 95 ec fd ff
	ff		 mov	 edx, DWORD PTR tv392[ebp]
  00199	0f 10 85 c4 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _pList$[ebp]
  001a0	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  001a3	0f 10 85 d4 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _pList$[ebp+16]
  001aa	0f 11 42 10	 movups	 XMMWORD PTR [edx+16], xmm0
  001ae	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 8587 : 				lOfs += sizeof(pList);

  001b1	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
  001b7	83 c1 24	 add	 ecx, 36			; 00000024H
  001ba	83 c2 24	 add	 edx, 36			; 00000024H
  001bd	89 8d f0 fd ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
  001c3	89 95 ec fd ff
	ff		 mov	 DWORD PTR tv392[ebp], edx
  001c9	eb 06		 jmp	 SHORT $LN2@CGPartyLis
$LN24@CGPartyLis:
  001cb	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
$LN2@CGPartyLis:

; 8565 : 
; 8566 : 	for (n=0;n<MAX_USER_IN_PARTY;n++)

  001d1	43		 inc	 ebx
  001d2	83 c6 04	 add	 esi, 4
  001d5	83 fb 05	 cmp	 ebx, 5
  001d8	0f 8c c2 fe ff
	ff		 jl	 $LL4@CGPartyLis

; 8588 : 			}
; 8589 : 		}
; 8590 : 	}
; 8591 : 
; 8592 : 	pCount.h.size = lOfs;

  001de	88 8d f5 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], cl
  001e4	bf 05 00 00 00	 mov	 edi, 5

; 8593 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  001e9	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _pCount$[ebp]
  001ef	89 85 fc fd ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], eax
  001f5	8a 85 f8 fd ff
	ff		 mov	 al, BYTE PTR _pCount$[ebp+4]
  001fb	88 85 00 fe ff
	ff		 mov	 BYTE PTR _sendbuf$[ebp+4], al
  00201	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR tv390[ebp]
  00207	8d b0 0c 00 00
	00		 lea	 esi, DWORD PTR ?gParty@@3VPartyClass@@A[eax+12]
  0020d	0f 1f 00	 npad	 3
$LL7@CGPartyLis:

; 8596 : 	{
; 8597 : 		number = gParty.m_PartyS[pnumber].Number[n];

  00210	8b 06		 mov	 eax, DWORD PTR [esi]

; 8598 : 
; 8599 : 		if ( number >= 0 )

  00212	85 c0		 test	 eax, eax
  00214	78 17		 js	 SHORT $LN5@CGPartyLis

; 8600 : 		{
; 8601 : 			DataSend(number, sendbuf, lOfs);

  00216	51		 push	 ecx
  00217	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _sendbuf$[ebp]
  0021d	51		 push	 ecx
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00224	8b 8d f0 fd ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
  0022a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@CGPartyLis:

; 8594 : 
; 8595 : 	for (n=0;n<MAX_USER_IN_PARTY;n++)

  0022d	83 c6 04	 add	 esi, 4
  00230	83 ef 01	 sub	 edi, 1
  00233	75 db		 jne	 SHORT $LL7@CGPartyLis
  00235	5f		 pop	 edi
  00236	5b		 pop	 ebx
$LN6@CGPartyLis:

; 8602 : 		}
; 8603 : 	}
; 8604 : }

  00237	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0023a	33 cd		 xor	 ecx, ebp
  0023c	5e		 pop	 esi
  0023d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00242	8b e5		 mov	 esp, ebp
  00244	5d		 pop	 ebp
  00245	c3		 ret	 0
?CGPartyListAll@@YAXH@Z ENDP				; CGPartyListAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPartyList@@YAXH@Z
_TEXT	SEGMENT
_pList$ = -572						; size = 36
_aIndex$GSCopy$1$ = -536				; size = 4
tv361 = -532						; size = 4
_lOfs$1$ = -528						; size = 4
_pCount$ = -524						; size = 5
_sendbuf$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?CGPartyList@@YAXH@Z PROC				; CGPartyList, COMDAT

; 8480 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 02 00
	00		 sub	 esp, 572		; 0000023cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00016	56		 push	 esi

; 8481 : 	PMSG_PARTYLISTCOUNT pCount;
; 8482 : 	PMSG_PARTYLIST pList;
; 8483 : 	BYTE sendbuf[512];
; 8484 : 	int lOfs = 0;
; 8485 : 
; 8486 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00017	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  0001d	89 85 e8 fd ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], eax
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	03 c6		 add	 eax, esi
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00030	83 c4 04	 add	 esp, 4
  00033	85 c0		 test	 eax, eax
  00035	0f 84 f8 01 00
	00		 je	 $LN1@CGPartyLis

; 8487 : 		return;
; 8488 : 
; 8489 : 	PHeadSetB((LPBYTE)&pCount, 0x42, sizeof(pCount));

  0003b	6a 05		 push	 5
  0003d	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  00043	6a 42		 push	 66			; 00000042H
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8490 : 	pCount.Count = 0;
; 8491 : 	pCount.Result = false;
; 8492 : 
; 8493 : 	int number;
; 8494 : 	int pnumber = gObj[aIndex].PartyNumber ;

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	66 c7 85 f7 fd
	ff ff 00 00	 mov	 WORD PTR _pCount$[ebp+3], 0
  0005c	32 c9		 xor	 cl, cl
  0005e	8b b4 06 0c 06
	00 00		 mov	 esi, DWORD PTR [esi+eax+1548]

; 8495 : 
; 8496 : 	if ( pnumber >= 0 )

  00065	85 f6		 test	 esi, esi
  00067	78 13		 js	 SHORT $LN6@CGPartyLis

; 8497 : 		pCount.Count = gParty.GetCount(pnumber);

  00069	56		 push	 esi
  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0006f	e8 00 00 00 00	 call	 ?GetCount@PartyClass@@QAEHH@Z ; PartyClass::GetCount
  00074	8a c8		 mov	 cl, al
  00076	88 8d f8 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], cl
$LN6@CGPartyLis:

; 8498 : 
; 8499 : 	lOfs += sizeof(pCount);

  0007c	ba 05 00 00 00	 mov	 edx, 5
  00081	89 95 f0 fd ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], edx

; 8500 : 
; 8501 : 	if ( pCount.Count != 0 )

  00087	84 c9		 test	 cl, cl
  00089	0f 84 76 01 00
	00		 je	 $LN7@CGPartyLis

; 8502 : 	{
; 8503 : 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  0008f	8d 85 01 fe ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp+5]
  00095	89 85 ec fd ff
	ff		 mov	 DWORD PTR tv361[ebp], eax
  0009b	8b c6		 mov	 eax, esi
  0009d	53		 push	 ebx
  0009e	c1 e0 04	 shl	 eax, 4
  000a1	33 db		 xor	 ebx, ebx
  000a3	2b c6		 sub	 eax, esi
  000a5	57		 push	 edi
  000a6	8d 34 85 20 00
	00 00		 lea	 esi, DWORD PTR ?gParty@@3VPartyClass@@A[eax*4+32]
  000ad	0f 1f 00	 npad	 3
$LL4@CGPartyLis:

; 8504 : 		{
; 8505 : 			number = gParty.m_PartyS[pnumber].Number[n];

  000b0	8b 46 ec	 mov	 eax, DWORD PTR [esi-20]

; 8506 : 
; 8507 : 			if ( number >= 0 )

  000b3	85 c0		 test	 eax, eax
  000b5	0f 88 2e 01 00
	00		 js	 $LN2@CGPartyLis

; 8508 : 			{
; 8509 : 				if ( gObjIsConnected(&gObj[number], gParty.m_PartyS[pnumber].DbNumber[n]) == TRUE )

  000bb	ff 36		 push	 DWORD PTR [esi]
  000bd	69 f8 40 27 00
	00		 imul	 edi, eax, 10048
  000c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c8	03 c7		 add	 eax, edi
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjIsConnected
  000d0	83 c4 08	 add	 esp, 8
  000d3	83 f8 01	 cmp	 eax, 1
  000d6	0f 85 07 01 00
	00		 jne	 $LN16@CGPartyLis

; 8510 : 				{
; 8511 : 					memset(&pList, 0, sizeof(pList));
; 8512 : 					memcpy(pList.szId, gObj[number].Name, MAX_ACCOUNT_LEN);

  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e2	0f 57 c0	 xorps	 xmm0, xmm0
  000e5	0f 11 85 c4 fd
	ff ff		 movups	 XMMWORD PTR _pList$[ebp], xmm0

; 8513 : 					pList.Number = n;
; 8514 : 					pList.MapNumber = gObj[number].MapNumber;
; 8515 : 					pList.X = gObj[number].X;
; 8516 : 					pList.Y = gObj[number].Y;
; 8517 : 					pList.Life = (int)gObj[number].Life;
; 8518 : 					pList.MaxLife = (int)(gObj[number].MaxLife + gObj[number].AddLife);
; 8519 : 					pList.Mana = (int)gObj[number].Mana;
; 8520 : 					pList.MaxMana = (int)(gObj[number].MaxMana + gObj[number].AddMana);
; 8521 : 					pList.ServerCode = gGameServerCode+1;
; 8522 : 
; 8523 : 					memcpy(&sendbuf[lOfs], &pList, sizeof(pList));
; 8524 : 					lOfs += sizeof(pList);

  000ec	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _lOfs$1$[ebp]
  000f2	0f 11 85 d4 fd
	ff ff		 movups	 XMMWORD PTR _pList$[ebp+16], xmm0
  000f9	66 8b 44 0f 65	 mov	 ax, WORD PTR [edi+ecx+101]
  000fe	83 c2 24	 add	 edx, 36			; 00000024H
  00101	f3 0f 7e 44 0f
	5d		 movq	 xmm0, QWORD PTR [edi+ecx+93]
  00107	66 89 85 cc fd
	ff ff		 mov	 WORD PTR _pList$[ebp+8], ax
  0010e	0f b6 84 0f 23
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+291]
  00116	88 85 cf fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+11], al
  0011c	0f b6 84 0f 20
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+288]
  00124	66 0f d6 85 c4
	fd ff ff	 movq	 QWORD PTR _pList$[ebp], xmm0
  0012c	66 0f 6e 84 0f
	24 01 00 00	 movd	 xmm0, DWORD PTR [edi+ecx+292]
  00135	88 85 d0 fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+12], al
  0013b	0f b6 84 0f 21
	01 00 00	 movzx	 eax, BYTE PTR [edi+ecx+289]
  00143	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00146	88 85 d1 fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+13], al
  0014c	88 9d ce fd ff
	ff		 mov	 BYTE PTR _pList$[ebp+10], bl
  00152	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _pList$[ebp+32], 0
  0015c	89 95 f0 fd ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], edx
  00162	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  0016b	f3 0f 58 84 0f
	dc 00 00 00	 addss	 xmm0, DWORD PTR [edi+ecx+220]
  00174	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+16], eax
  0017a	f3 0f 2c c0	 cvttss2si eax, xmm0
  0017e	66 0f 6e 84 0f
	28 01 00 00	 movd	 xmm0, DWORD PTR [edi+ecx+296]
  00187	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0018a	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+20], eax
  00190	f3 0f 2c 84 0f
	ec 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+236]
  00199	f3 0f 58 84 0f
	f0 00 00 00	 addss	 xmm0, DWORD PTR [edi+ecx+240]
  001a2	8b bd ec fd ff
	ff		 mov	 edi, DWORD PTR tv361[ebp]
  001a8	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+28], eax
  001ae	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  001b5	40		 inc	 eax
  001b6	f3 0f 2c c8	 cvttss2si ecx, xmm0
  001ba	89 85 dc fd ff
	ff		 mov	 DWORD PTR _pList$[ebp+24], eax
  001c0	0f 10 85 c4 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _pList$[ebp]
  001c7	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  001ca	0f 10 85 d4 fd
	ff ff		 movups	 xmm0, XMMWORD PTR _pList$[ebp+16]
  001d1	0f 11 47 10	 movups	 XMMWORD PTR [edi+16], xmm0
  001d5	89 4f 20	 mov	 DWORD PTR [edi+32], ecx
  001d8	83 c7 24	 add	 edi, 36			; 00000024H
  001db	89 bd ec fd ff
	ff		 mov	 DWORD PTR tv361[ebp], edi
  001e1	eb 06		 jmp	 SHORT $LN2@CGPartyLis
$LN16@CGPartyLis:
  001e3	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR _lOfs$1$[ebp]
$LN2@CGPartyLis:

; 8502 : 	{
; 8503 : 		for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  001e9	43		 inc	 ebx
  001ea	83 c6 04	 add	 esi, 4
  001ed	83 fb 05	 cmp	 ebx, 5
  001f0	0f 8c ba fe ff
	ff		 jl	 $LL4@CGPartyLis

; 8525 : 				}
; 8526 : 			}
; 8527 : 		}
; 8528 : 
; 8529 : 		pCount.Result = true;

  001f6	8a 8d f8 fd ff
	ff		 mov	 cl, BYTE PTR _pCount$[ebp+4]
  001fc	5f		 pop	 edi
  001fd	c6 85 f7 fd ff
	ff 01		 mov	 BYTE PTR _pCount$[ebp+3], 1
  00204	5b		 pop	 ebx
$LN7@CGPartyLis:

; 8530 : 	}
; 8531 : 
; 8532 : 	pCount.h.size = lOfs;

  00205	88 95 f5 fd ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], dl

; 8533 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  0020b	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _pCount$[ebp]
  00211	89 85 fc fd ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], eax

; 8534 : 	
; 8535 : 	DataSend(aIndex, (LPBYTE)&sendbuf, lOfs);

  00217	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  0021d	52		 push	 edx
  0021e	50		 push	 eax
  0021f	ff b5 e8 fd ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  00225	88 8d 00 fe ff
	ff		 mov	 BYTE PTR _sendbuf$[ebp+4], cl
  0022b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00230	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGPartyLis:

; 8536 : }

  00233	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00236	33 cd		 xor	 ecx, ebp
  00238	5e		 pop	 esi
  00239	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c3		 ret	 0
?CGPartyList@@YAXH@Z ENDP				; CGPartyList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z
_TEXT	SEGMENT
_aIndex$GSCopy$1$ = -276				; size = 4
_lpMsg$GSCopy$1$ = -272					; size = 4
_pnumber$1$ = -272					; size = 4
tv568 = -268						; size = 4
_result$1$ = -261					; size = 1
_szTemp$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z PROC ; CGPartyRequestResultRecv, COMDAT

; 8320 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 8321 : 	int number;
; 8322 : 	BYTE result = false;
; 8323 : 	char szTemp[256];
; 8324 : 	int pnumber = -1;
; 8325 : 
; 8326 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001d	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00023	57		 push	 edi
  00024	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00027	89 bd f0 fe ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], edi
  0002d	89 b5 ec fe ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], esi
  00033	03 c3		 add	 eax, ebx
  00035	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$1$[ebp], 0
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00042	83 c4 04	 add	 esp, 4
  00045	85 c0		 test	 eax, eax
  00047	0f 84 4e 04 00
	00		 je	 $LN4@CGPartyReq

; 8327 : 		return;
; 8328 : 
; 8329 : 	number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  0004d	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00051	66 c1 e0 08	 shl	 ax, 8
  00055	0f b7 f8	 movzx	 edi, ax
  00058	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  0005e	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00062	0b f8		 or	 edi, eax

; 8330 : 
; 8331 : 	if ( number < 0 || number > OBJMAX-1)

  00064	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0006a	0f 87 2b 04 00
	00		 ja	 $LN4@CGPartyReq

; 8332 : 		return;
; 8333 : 
; 8334 : 	if ( !gObjIsConnected(&gObj[aIndex]))

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00075	03 c3		 add	 eax, ebx
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0007d	83 c4 04	 add	 esp, 4
  00080	85 c0		 test	 eax, eax
  00082	0f 84 13 04 00
	00		 je	 $LN4@CGPartyReq

; 8335 : 		return;
; 8336 : 
; 8337 : 	if ( !gObjIsConnected(&gObj[number]))

  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008d	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00093	03 c1		 add	 eax, ecx
  00095	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv568[ebp], ecx
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000a1	83 c4 04	 add	 esp, 4
  000a4	85 c0		 test	 eax, eax
  000a6	75 0f		 jne	 SHORT $LN6@CGPartyReq

; 8338 : 	{
; 8339 : 		GCResultSend(aIndex, 0x41, 0x04);

  000a8	6a 04		 push	 4
  000aa	6a 41		 push	 65			; 00000041H
  000ac	56		 push	 esi
  000ad	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8340 : 	}
; 8341 : 	else

  000b5	eb 07		 jmp	 SHORT $LN7@CGPartyReq
$LN6@CGPartyReq:

; 8342 : 	{
; 8343 : 		result = true;

  000b7	c6 85 fb fe ff
	ff 01		 mov	 BYTE PTR _result$1$[ebp], 1
$LN7@CGPartyReq:

; 8344 : 	}
; 8345 : 
; 8346 : 	if ( gObj[number].MapNumber != gObj[aIndex].MapNumber )

  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c4	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv568[ebp]
  000ca	8a 84 08 23 01
	00 00		 mov	 al, BYTE PTR [eax+ecx+291]
  000d1	3a 84 0b 23 01
	00 00		 cmp	 al, BYTE PTR [ebx+ecx+291]
  000d8	74 14		 je	 SHORT $LN8@CGPartyReq

; 8347 : 	{
; 8348 : 		result = false;
; 8349 : 		GCResultSend(number, 0x41, 0x00);

  000da	6a 00		 push	 0
  000dc	6a 41		 push	 65			; 00000041H
  000de	57		 push	 edi
  000df	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$1$[ebp], 0
  000e6	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@CGPartyReq:

; 8350 : 	}
; 8351 : 
; 8352 : 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  000ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f3	8a 84 03 23 01
	00 00		 mov	 al, BYTE PTR [ebx+eax+291]
  000fa	3c 35		 cmp	 al, 53			; 00000035H
  000fc	74 0f		 je	 SHORT $LN40@CGPartyReq
  000fe	3c 12		 cmp	 al, 18			; 00000012H
  00100	72 37		 jb	 SHORT $LN9@CGPartyReq
  00102	b1 17		 mov	 cl, 23			; 00000017H
  00104	3a c8		 cmp	 cl, al
  00106	1b c0		 sbb	 eax, eax
  00108	83 c0 01	 add	 eax, 1
  0010b	74 2c		 je	 SHORT $LN9@CGPartyReq
$LN40@CGPartyReq:

; 8353 : 	{
; 8354 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(4, 198)), aIndex, 1);

  0010d	6a 01		 push	 1
  0010f	56		 push	 esi
  00110	68 c6 04 00 00	 push	 1222			; 000004c6H
  00115	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0011a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8355 : 		result = false;
; 8356 : 		::GCResultSend(number, 0x41, 0x00);

  00125	6a 00		 push	 0
  00127	6a 41		 push	 65			; 00000041H
  00129	57		 push	 edi
  0012a	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$1$[ebp], 0
  00131	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00136	83 c4 18	 add	 esp, 24			; 00000018H
$LN9@CGPartyReq:

; 8357 : 	}
; 8358 : 
; 8359 : 	if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) )

  00139	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0013e	8a 84 03 23 01
	00 00		 mov	 al, BYTE PTR [ebx+eax+291]
  00145	3c 2d		 cmp	 al, 45			; 0000002dH
  00147	72 2c		 jb	 SHORT $LN10@CGPartyReq
  00149	b1 32		 mov	 cl, 50			; 00000032H
  0014b	3a c8		 cmp	 cl, al
  0014d	1b c0		 sbb	 eax, eax
  0014f	83 c0 01	 add	 eax, 1
  00152	74 21		 je	 SHORT $LN10@CGPartyReq

; 8360 : 	{
; 8361 : 		GCServerMsgStringSend("Party not allowed in Illusion Temple.", aIndex, 1);

  00154	6a 01		 push	 1
  00156	56		 push	 esi
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@
  0015c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8362 : 		result = false;
; 8363 : 		::GCResultSend(number, 0x41, 0x00);

  00161	6a 00		 push	 0
  00163	6a 41		 push	 65			; 00000041H
  00165	57		 push	 edi
  00166	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$1$[ebp], 0
  0016d	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00172	83 c4 18	 add	 esp, 24			; 00000018H
$LN10@CGPartyReq:

; 8364 : 	}
; 8365 : 
; 8366 : 	if ( DG_MAP_RANGE(gObj[aIndex].MapNumber) )

  00175	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017a	8a 84 03 23 01
	00 00		 mov	 al, BYTE PTR [ebx+eax+291]
  00181	3c 41		 cmp	 al, 65			; 00000041H
  00183	72 2c		 jb	 SHORT $LN11@CGPartyReq
  00185	b1 44		 mov	 cl, 68			; 00000044H
  00187	3a c8		 cmp	 cl, al
  00189	1b c0		 sbb	 eax, eax
  0018b	83 c0 01	 add	 eax, 1
  0018e	74 21		 je	 SHORT $LN11@CGPartyReq

; 8367 : 	{
; 8368 : 		GCServerMsgStringSend("Party not allowed in Doppelganger.", aIndex, 1);

  00190	6a 01		 push	 1
  00192	56		 push	 esi
  00193	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@
  00198	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8369 : 		result = false;
; 8370 : 		::GCResultSend(number, 0x41, 0x00);

  0019d	6a 00		 push	 0
  0019f	6a 41		 push	 65			; 00000041H
  001a1	57		 push	 edi
  001a2	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$1$[ebp], 0
  001a9	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001ae	83 c4 18	 add	 esp, 24			; 00000018H
$LN11@CGPartyReq:

; 8371 : 	}
; 8372 : 
; 8373 : 	if ( IF_MAP_RANGE(gObj[aIndex].MapNumber) )

  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b6	8a 84 03 23 01
	00 00		 mov	 al, BYTE PTR [ebx+eax+291]
  001bd	3c 45		 cmp	 al, 69			; 00000045H
  001bf	72 2c		 jb	 SHORT $LN12@CGPartyReq
  001c1	b1 48		 mov	 cl, 72			; 00000048H
  001c3	3a c8		 cmp	 cl, al
  001c5	1b c0		 sbb	 eax, eax
  001c7	83 c0 01	 add	 eax, 1
  001ca	74 21		 je	 SHORT $LN12@CGPartyReq

; 8374 : 	{
; 8375 : 		GCServerMsgStringSend("Party not allowed in Imperial Fort.", aIndex, 1);

  001cc	6a 01		 push	 1
  001ce	56		 push	 esi
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@
  001d4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8376 : 		result = false;
; 8377 : 		::GCResultSend(number, 0x41, 0x00);

  001d9	6a 00		 push	 0
  001db	6a 41		 push	 65			; 00000041H
  001dd	57		 push	 edi
  001de	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$1$[ebp], 0
  001e5	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001ea	83 c4 18	 add	 esp, 24			; 00000018H
$LN12@CGPartyReq:

; 8378 : 	}
; 8379 : 
; 8380 : 	if ( lpMsg->Result == 0 )

  001ed	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  001f3	80 78 03 00	 cmp	 BYTE PTR [eax+3], 0
  001f7	75 14		 jne	 SHORT $LN13@CGPartyReq

; 8381 : 	{
; 8382 : 		result = false;
; 8383 : 		::GCResultSend(number, 0x41, 0x01);

  001f9	6a 01		 push	 1
  001fb	6a 41		 push	 65			; 00000041H
  001fd	57		 push	 edi
  001fe	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$1$[ebp], 0
  00205	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0020a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@CGPartyReq:

; 8384 : 	}
; 8385 : 
; 8386 : 	if ( gObj[number].m_IfState.use == 0 || gObj[number].m_IfState.type != 2)

  0020d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00212	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv568[ebp]
  00218	8b 84 02 b8 11
	00 00		 mov	 eax, DWORD PTR [edx+eax+4536]
  0021f	a8 03		 test	 al, 3
  00221	74 0c		 je	 SHORT $LN15@CGPartyReq
  00223	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00228	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0022d	74 1a		 je	 SHORT $LN14@CGPartyReq
$LN15@CGPartyReq:

; 8387 : 	{
; 8388 : 		result = false;
; 8389 : 		::GCResultSend(number, 0x41, 0x00);

  0022f	6a 00		 push	 0
  00231	6a 41		 push	 65			; 00000041H
  00233	57		 push	 edi
  00234	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _result$1$[ebp], 0
  0023b	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00240	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv568[ebp]
  00246	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@CGPartyReq:

; 8390 : 	}	
; 8391 : 	
; 8392 : 	if ( gObj[aIndex].m_IfState.use == 0 || gObj[aIndex].m_IfState.type != 2)

  00249	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0024f	8b 84 0b b8 11
	00 00		 mov	 eax, DWORD PTR [ebx+ecx+4536]
  00256	a8 03		 test	 al, 3
  00258	0f 84 a6 01 00
	00		 je	 $LN17@CGPartyReq
  0025e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00263	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00268	0f 85 96 01 00
	00		 jne	 $LN17@CGPartyReq

; 8396 : 	}
; 8397 : 
; 8398 : 	if ( result == 1 )

  0026e	80 bd fb fe ff
	ff 01		 cmp	 BYTE PTR _result$1$[ebp], 1
  00275	0f 85 96 01 00
	00		 jne	 $LN43@CGPartyReq

; 8399 : 	{
; 8400 : 		if ( gObj[number].PartyNumber < 0 )

  0027b	83 bc 11 0c 06
	00 00 00	 cmp	 DWORD PTR [ecx+edx+1548], 0
  00283	7d 2b		 jge	 SHORT $LN19@CGPartyReq

; 8401 : 		{
; 8402 : 			gObj[number].PartyNumber = gParty.Create(number, gObj[number].DBNumber, gObj[number].Level);

  00285	0f bf 84 11 96
	00 00 00	 movsx	 eax, WORD PTR [ecx+edx+150]
  0028d	50		 push	 eax
  0028e	ff 74 11 30	 push	 DWORD PTR [ecx+edx+48]
  00292	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00297	57		 push	 edi
  00298	e8 00 00 00 00	 call	 ?Create@PartyClass@@QAEHHHH@Z ; PartyClass::Create
  0029d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a3	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv568[ebp]
  002a9	89 84 0a 0c 06
	00 00		 mov	 DWORD PTR [edx+ecx+1548], eax
$LN19@CGPartyReq:

; 8403 : 		}
; 8404 : 
; 8405 : 		if ( gObj[number].PartyNumber >= 0  )

  002b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b6	8b 94 0a 0c 06
	00 00		 mov	 edx, DWORD PTR [edx+ecx+1548]
  002bd	85 d2		 test	 edx, edx
  002bf	0f 88 4c 01 00
	00		 js	 $LN43@CGPartyReq

; 8406 : 		{
; 8407 : 			pnumber = gObj[number].PartyNumber;
; 8408 : 			int iPartyPos = gParty.Add(gObj[number].PartyNumber, aIndex, gObj[aIndex].DBNumber, gObj[aIndex].Level);

  002c5	0f bf 84 0b 96
	00 00 00	 movsx	 eax, WORD PTR [ebx+ecx+150]
  002cd	50		 push	 eax
  002ce	ff 74 0b 30	 push	 DWORD PTR [ebx+ecx+48]
  002d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  002d7	89 95 f0 fe ff
	ff		 mov	 DWORD PTR _pnumber$1$[ebp], edx
  002dd	56		 push	 esi
  002de	52		 push	 edx
  002df	e8 00 00 00 00	 call	 ?Add@PartyClass@@QAEHHHHH@Z ; PartyClass::Add

; 8409 : 
; 8410 : 			if ( iPartyPos >= 0 )

  002e4	85 c0		 test	 eax, eax
  002e6	0f 88 ad 00 00
	00		 js	 $LN21@CGPartyReq

; 8411 : 			{
; 8412 : 				gObj[aIndex].PartyNumber = gObj[number].PartyNumber;

  002ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f2	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv568[ebp]
  002f8	8b 84 08 0c 06
	00 00		 mov	 eax, DWORD PTR [eax+ecx+1548]
  002ff	89 84 0b 0c 06
	00 00		 mov	 DWORD PTR [ebx+ecx+1548], eax

; 8413 : 				result = true;
; 8414 : 				wsprintf(szTemp, lMsg.Get(MSGGET(4, 83)), gObj[aIndex].Name);

  00306	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0030b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00310	83 c0 5d	 add	 eax, 93			; 0000005dH
  00313	03 c3		 add	 eax, ebx
  00315	50		 push	 eax
  00316	68 53 04 00 00	 push	 1107			; 00000453H
  0031b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00320	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfA
  00326	50		 push	 eax
  00327	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0032d	50		 push	 eax
  0032e	ff d6		 call	 esi

; 8415 : 				::GCServerMsgStringSend(szTemp, number, 1);

  00330	6a 01		 push	 1
  00332	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00338	57		 push	 edi
  00339	50		 push	 eax
  0033a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8416 : 				wsprintf(szTemp, lMsg.Get(MSGGET(4, 83)), gObj[number].Name);

  0033f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00344	83 c4 18	 add	 esp, 24			; 00000018H
  00347	8b bd f4 fe ff
	ff		 mov	 edi, DWORD PTR tv568[ebp]
  0034d	83 c0 5d	 add	 eax, 93			; 0000005dH
  00350	03 c7		 add	 eax, edi
  00352	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00357	50		 push	 eax
  00358	68 53 04 00 00	 push	 1107			; 00000453H
  0035d	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00362	50		 push	 eax
  00363	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00369	50		 push	 eax
  0036a	ff d6		 call	 esi

; 8417 : 				::GCServerMsgStringSend(szTemp, aIndex, 1);

  0036c	6a 01		 push	 1
  0036e	ff b5 ec fe ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  00374	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0037a	50		 push	 eax
  0037b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8418 : 
; 8419 : 				gParty.Paint(pnumber);

  00380	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _pnumber$1$[ebp]
  00386	83 c4 18	 add	 esp, 24			; 00000018H
  00389	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0038e	56		 push	 esi
  0038f	e8 00 00 00 00	 call	 ?Paint@PartyClass@@QAEXH@Z ; PartyClass::Paint
  00394	e9 81 00 00 00	 jmp	 $LN25@CGPartyReq
$LN21@CGPartyReq:

; 8420 : 			}
; 8421 : 			else if ( iPartyPos == -1 )

  00399	83 f8 ff	 cmp	 eax, -1
  0039c	75 1f		 jne	 SHORT $LN23@CGPartyReq

; 8422 : 			{
; 8423 : 				GCResultSend(number, 0x41, 2);

  0039e	6a 02		 push	 2
  003a0	6a 41		 push	 65			; 00000041H
  003a2	57		 push	 edi
  003a3	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend

; 8424 : 				GCResultSend(aIndex, 0x41, 2);

  003a8	6a 02		 push	 2
  003aa	6a 41		 push	 65			; 00000041H
  003ac	56		 push	 esi
  003ad	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  003b2	83 c4 18	 add	 esp, 24			; 00000018H
$LN41@CGPartyReq:
  003b5	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _pnumber$1$[ebp]
  003bb	eb 57		 jmp	 SHORT $LN44@CGPartyReq
$LN23@CGPartyReq:

; 8425 : 			}
; 8426 : 			else if ( iPartyPos == -2 )

  003bd	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  003c0	75 f3		 jne	 SHORT $LN41@CGPartyReq

; 8427 : 			{
; 8428 : 				result = 2;
; 8429 : 				wsprintf(szTemp, lMsg.Get(MSGGET(4, 84)), gObj[aIndex].Name);

  003c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003c7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003cc	83 c0 5d	 add	 eax, 93			; 0000005dH
  003cf	03 c3		 add	 eax, ebx
  003d1	50		 push	 eax
  003d2	68 54 04 00 00	 push	 1108			; 00000454H
  003d7	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003dc	50		 push	 eax
  003dd	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  003e3	50		 push	 eax
  003e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 8430 : 				GCServerMsgStringSend(szTemp, aIndex, 1);

  003ea	6a 01		 push	 1
  003ec	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  003f2	56		 push	 esi
  003f3	50		 push	 eax
  003f4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003f9	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _pnumber$1$[ebp]
  003ff	83 c4 18	 add	 esp, 24			; 00000018H
  00402	eb 10		 jmp	 SHORT $LN44@CGPartyReq
$LN17@CGPartyReq:

; 8393 : 	{
; 8394 : 		result = false;
; 8395 : 		::GCResultSend(number, 0x41, 0x00);

  00404	6a 00		 push	 0
  00406	6a 41		 push	 65			; 00000041H
  00408	57		 push	 edi
  00409	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0040e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN43@CGPartyReq:
  00411	83 ce ff	 or	 esi, -1
$LN44@CGPartyReq:
  00414	8b bd f4 fe ff
	ff		 mov	 edi, DWORD PTR tv568[ebp]
$LN25@CGPartyReq:

; 8431 : 			}
; 8432 : 		}
; 8433 : 	}
; 8434 : 
; 8435 : 	if ( gObj[aIndex].m_IfState.use !=  0 && gObj[aIndex].m_IfState.type == 2)

  0041a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00420	8b 8c 1a b8 11
	00 00		 mov	 ecx, DWORD PTR [edx+ebx+4536]
  00427	f6 c1 03	 test	 cl, 3
  0042a	74 28		 je	 SHORT $LN26@CGPartyReq
  0042c	8b c1		 mov	 eax, ecx
  0042e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00433	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00438	75 1a		 jne	 SHORT $LN26@CGPartyReq

; 8436 : 	{
; 8437 : 		gObj[aIndex].m_IfState.use = 0;

  0043a	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0043d	89 8c 1a b8 11
	00 00		 mov	 DWORD PTR [edx+ebx+4536], ecx

; 8438 : 		gObj[aIndex].PartyTargetUser = -1;

  00444	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00449	c7 84 03 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ebx+eax+1552], -1
$LN26@CGPartyReq:

; 8439 : 	}
; 8440 : 
; 8441 : 	if ( gObj[number].m_IfState.use !=  0 && gObj[number].m_IfState.type == 2)

  00454	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0045a	8b 8c 3a b8 11
	00 00		 mov	 ecx, DWORD PTR [edx+edi+4536]
  00461	f6 c1 03	 test	 cl, 3
  00464	74 28		 je	 SHORT $LN27@CGPartyReq
  00466	8b c1		 mov	 eax, ecx
  00468	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0046d	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00472	75 1a		 jne	 SHORT $LN27@CGPartyReq

; 8442 : 	{
; 8443 : 		gObj[number].m_IfState.use = 0;

  00474	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00477	89 8c 3a b8 11
	00 00		 mov	 DWORD PTR [edx+edi+4536], ecx

; 8444 : 		gObj[number].PartyTargetUser = -1;

  0047e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00483	c7 84 07 10 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edi+eax+1552], -1
$LN27@CGPartyReq:

; 8445 : 	}
; 8446 : 
; 8447 : 	if ( pnumber >= 0 )

  0048e	85 f6		 test	 esi, esi
  00490	78 09		 js	 SHORT $LN4@CGPartyReq

; 8448 : 	{
; 8449 : 		CGPartyListAll(pnumber);

  00492	56		 push	 esi
  00493	e8 00 00 00 00	 call	 ?CGPartyListAll@@YAXH@Z	; CGPartyListAll
  00498	83 c4 04	 add	 esp, 4
$LN4@CGPartyReq:

; 8450 : 	}
; 8451 : }

  0049b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0049e	5f		 pop	 edi
  0049f	5e		 pop	 esi
  004a0	33 cd		 xor	 ecx, ebp
  004a2	5b		 pop	 ebx
  004a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a8	8b e5		 mov	 esp, ebp
  004aa	5d		 pop	 ebp
  004ab	c3		 ret	 0
?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ENDP ; CGPartyRequestResultRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 5
_iDbNumber$1 = -12					; size = 4
_iUserIndex$2 = -8					; size = 4
_number$1$ = -4						; size = 4
tv676 = 8						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z PROC	; CGPartyRequestRecv, COMDAT

; 8146 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 8147 : 	int number =  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00009	57		 push	 edi
  0000a	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0000e	66 c1 e0 08	 shl	 ax, 8
  00012	0f b7 f8	 movzx	 edi, ax
  00015	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00019	0b f8		 or	 edi, eax
  0001b	89 7d fc	 mov	 DWORD PTR _number$1$[ebp], edi

; 8148 : 	PMSG_PARTYREQUESTSEND pMsg;
; 8149 : 
; 8150 : 	if ( number < 0 || number > OBJMAX-1)

  0001e	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00024	0f 87 be 03 00
	00		 ja	 $LN3@CGPartyReq

; 8151 : 		return;
; 8152 : 
; 8153 : 	if (!PacketCheckTime(&gObj[aIndex]))

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	53		 push	 ebx
  00030	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00033	56		 push	 esi
  00034	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  0003a	03 c6		 add	 eax, esi
  0003c	89 75 08	 mov	 DWORD PTR tv676[ebp], esi
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00045	83 c4 04	 add	 esp, 4
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 96 03 00
	00		 je	 $LN39@CGPartyReq

; 8154 : 		return;
; 8155 : 
; 8156 : 	if ( !gObjIsConnected(&gObj[number]))

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00055	69 ff 40 27 00
	00		 imul	 edi, edi, 10048
  0005b	03 c7		 add	 eax, edi
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00063	83 c4 04	 add	 esp, 4
  00066	85 c0		 test	 eax, eax
  00068	75 14		 jne	 SHORT $LN5@CGPartyReq

; 8157 : 	{
; 8158 : 		::GCResultSend(aIndex, 0x41, 0x03);

  0006a	6a 03		 push	 3

; 8163 : 	{
; 8164 : 		::GCResultSend(aIndex, 0x41, 0x00);

  0006c	6a 41		 push	 65			; 00000041H
  0006e	53		 push	 ebx
  0006f	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	5f		 pop	 edi

; 8313 : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
$LN5@CGPartyReq:

; 8159 : 		return;
; 8160 : 	}
; 8161 : 
; 8162 : 	if ( gObj[aIndex].CloseCount >= 0 || gObj[number].CloseCount >= 0 )

  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00084	80 7c 0e 0c 00	 cmp	 BYTE PTR [esi+ecx+12], 0
  00089	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0008c	0f 8d 47 03 00
	00		 jge	 $LN7@CGPartyReq
  00092	80 7c 0f 0c 00	 cmp	 BYTE PTR [edi+ecx+12], 0
  00097	0f 8d 3c 03 00
	00		 jge	 $LN7@CGPartyReq

; 8165 : 		return;
; 8166 : 	}
; 8167 : 
; 8168 : #if (ENABLETEST_NEWPVP == 1)
; 8169 : 	if (g_NewPVP.IsDuel(gObj[aIndex])) {

  0009d	50		 push	 eax
  0009e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000a3	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  000a8	85 c0		 test	 eax, eax
  000aa	74 22		 je	 SHORT $LN8@CGPartyReq

; 8170 : 		 GCServerMsgStringSend(lMsg.Get(3429), aIndex, 1);

  000ac	6a 01		 push	 1
  000ae	53		 push	 ebx
  000af	68 65 0d 00 00	 push	 3429			; 00000d65H
$LN44@CGPartyReq:
  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000b9	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	5f		 pop	 edi

; 8313 : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
$LN8@CGPartyReq:

; 8171 : 		 return;
; 8172 : 	}
; 8173 : 	
; 8174 : 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000d8	03 c6		 add	 eax, esi
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  000e0	85 c0		 test	 eax, eax
  000e2	74 0a		 je	 SHORT $LN9@CGPartyReq

; 8175 : 		 GCServerMsgStringSend(lMsg.Get(3430), aIndex, 1);

  000e4	6a 01		 push	 1
  000e6	53		 push	 ebx
  000e7	68 66 0d 00 00	 push	 3430			; 00000d66H

; 8176 : 		 return;

  000ec	eb c6		 jmp	 SHORT $LN44@CGPartyReq
$LN9@CGPartyReq:

; 8177 : 	}
; 8178 : #endif
; 8179 : 
; 8180 : 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  000ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f4	8a 8c 16 23 01
	00 00		 mov	 cl, BYTE PTR [esi+edx+291]
  000fb	80 f9 35	 cmp	 cl, 53			; 00000035H
  000fe	0f 84 c8 02 00
	00		 je	 $LN37@CGPartyReq
  00104	80 f9 12	 cmp	 cl, 18			; 00000012H
  00107	72 12		 jb	 SHORT $LN10@CGPartyReq
  00109	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
  0010e	3a c1		 cmp	 al, cl
  00110	1b c0		 sbb	 eax, eax
  00112	83 c0 01	 add	 eax, 1
  00115	0f 85 b1 02 00
	00		 jne	 $LN37@CGPartyReq
$LN10@CGPartyReq:

; 8184 : 	}
; 8185 : 
; 8186 : 	if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) )

  0011b	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0011e	72 22		 jb	 SHORT $LN11@CGPartyReq
  00120	b0 32		 mov	 al, 50			; 00000032H
  00122	3a c1		 cmp	 al, cl
  00124	1b c0		 sbb	 eax, eax
  00126	83 c0 01	 add	 eax, 1
  00129	74 17		 je	 SHORT $LN11@CGPartyReq

; 8187 : 	{
; 8188 : 		::GCServerMsgStringSend("Party not allowed in Illusion Temple.", aIndex, 1);

  0012b	6a 01		 push	 1
  0012d	53		 push	 ebx
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OFOEABOJ@Party?5not?5allowed?5in?5Illusion?5Te@
  00133	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	5e		 pop	 esi
  0013c	5b		 pop	 ebx
  0013d	5f		 pop	 edi

; 8313 : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
$LN11@CGPartyReq:

; 8189 : 		return;
; 8190 : 	}
; 8191 : 
; 8192 : 	if ( DG_MAP_RANGE(gObj[aIndex].MapNumber) )

  00142	80 f9 41	 cmp	 cl, 65			; 00000041H
  00145	72 25		 jb	 SHORT $LN12@CGPartyReq
  00147	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  0014c	3a c1		 cmp	 al, cl
  0014e	1b c0		 sbb	 eax, eax
  00150	83 c0 01	 add	 eax, 1
  00153	74 17		 je	 SHORT $LN12@CGPartyReq

; 8193 : 	{
; 8194 : 		::GCServerMsgStringSend("Party not allowed in Doppelganger.", aIndex, 1);

  00155	6a 01		 push	 1
  00157	53		 push	 ebx
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@ECCPKOHJ@Party?5not?5allowed?5in?5Doppelgange@
  0015d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH
  00165	5e		 pop	 esi
  00166	5b		 pop	 ebx
  00167	5f		 pop	 edi

; 8313 : }

  00168	8b e5		 mov	 esp, ebp
  0016a	5d		 pop	 ebp
  0016b	c3		 ret	 0
$LN12@CGPartyReq:

; 8195 : 		return;
; 8196 : 	}
; 8197 : 
; 8198 : 	if ( IF_MAP_RANGE(gObj[aIndex].MapNumber) )

  0016c	80 f9 45	 cmp	 cl, 69			; 00000045H
  0016f	72 25		 jb	 SHORT $LN13@CGPartyReq
  00171	b8 48 00 00 00	 mov	 eax, 72			; 00000048H
  00176	3a c1		 cmp	 al, cl
  00178	1b c0		 sbb	 eax, eax
  0017a	83 c0 01	 add	 eax, 1
  0017d	74 17		 je	 SHORT $LN13@CGPartyReq

; 8199 : 	{
; 8200 : 		::GCServerMsgStringSend("Party not allowed in Imperial Fort.", aIndex, 1);

  0017f	6a 01		 push	 1
  00181	53		 push	 ebx
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NBODNOHA@Party?5not?5allowed?5in?5Imperial?5Fo@
  00187	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018f	5e		 pop	 esi
  00190	5b		 pop	 ebx
  00191	5f		 pop	 edi

; 8313 : }

  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c3		 ret	 0
$LN13@CGPartyReq:

; 8201 : 		return;
; 8202 : 	}
; 8203 : 
; 8204 : #if (__GENS_SYSTEM__ == 1 )
; 8205 : 
; 8206 : 	/*if ( gObj[aIndex].m_GensInfo.btFamily == GENS_NONE )
; 8207 : 	{
; 8208 : 		::GCResultSend(aIndex, 0x41, 0x06);
; 8209 : 		return;
; 8210 : 	}*/
; 8211 : 	if( gGensSystem.m_CheckForParty )

  00196	80 3d 48 00 00
	00 00		 cmp	 BYTE PTR ?gGensSystem@@3VCGensSystem@@A+72, 0
  0019d	74 24		 je	 SHORT $LN16@CGPartyReq

; 8212 : 	{
; 8213 : 		if ( gObj[aIndex].m_GensInfo.btFamily != GENS_NONE && gObj[aIndex].m_GensInfo.btFamily != gObj[number].m_GensInfo.btFamily )

  0019f	8a 84 16 ac 26
	00 00		 mov	 al, BYTE PTR [esi+edx+9900]
  001a6	3a 84 17 ac 26
	00 00		 cmp	 al, BYTE PTR [edi+edx+9900]
  001ad	74 14		 je	 SHORT $LN16@CGPartyReq

; 8214 : 		{
; 8215 : 			::GCResultSend(aIndex, 0x41, 0x07);

  001af	6a 07		 push	 7
  001b1	6a 41		 push	 65			; 00000041H
  001b3	53		 push	 ebx
  001b4	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  001b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx
  001be	5f		 pop	 edi

; 8313 : }

  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
$LN16@CGPartyReq:

; 8216 : 			return;
; 8217 : 		}
; 8218 : 
; 8219 : 		if ( gObj[aIndex].m_GensInfo.btFamily != gObj[number].m_GensInfo.btFamily )
; 8220 : 		{
; 8221 : 			::GCResultSend(aIndex, 0x41, 0x07);
; 8222 : 			return;
; 8223 : 		}
; 8224 : 	}
; 8225 : 
; 8226 : 	//if ( gGensSystem.GensMap(gObj[aIndex].MapNumber) )
; 8227 : 	//{
; 8228 : 	//	return;
; 8229 : 	//}
; 8230 : 
; 8231 : #endif
; 8232 : 
; 8233 : 
; 8234 : 	if ( gObj[aIndex].m_IfState.use > 0 )

  001c3	f6 84 16 b8 11
	00 00 03	 test	 BYTE PTR [esi+edx+4536], 3
  001cb	0f 87 08 02 00
	00		 ja	 $LN7@CGPartyReq

; 8235 : 	{
; 8236 : 		::GCResultSend(aIndex, 0x41, 0x00);
; 8237 : 		return;
; 8238 : 	}
; 8239 : 
; 8240 : 	LogAddL("Party result : %d %d %d %d", gObj[aIndex].CloseCount, gObj[number].CloseCount, gObj[aIndex].Connected, gObj[number].Connected);

  001d1	ff 74 17 04	 push	 DWORD PTR [edi+edx+4]
  001d5	0f be 44 17 0c	 movsx	 eax, BYTE PTR [edi+edx+12]
  001da	ff 74 16 04	 push	 DWORD PTR [esi+edx+4]
  001de	50		 push	 eax
  001df	0f be 44 16 0c	 movsx	 eax, BYTE PTR [esi+edx+12]
  001e4	50		 push	 eax
  001e5	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OEGODNEF@Party?5result?5?3?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  001ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL

; 8241 : 	LogAddL("%s %s", gObj[aIndex].Name, gObj[number].Name);

  001f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f6	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001f9	03 c7		 add	 eax, edi
  001fb	50		 push	 eax
  001fc	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001ff	03 c6		 add	 eax, esi
  00201	50		 push	 eax
  00202	68 00 00 00 00	 push	 OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
  00207	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL

; 8242 : 		
; 8243 : 	if ( gObj[number].m_IfState.use > 0 )

  0020d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00213	83 c4 20	 add	 esp, 32			; 00000020H
  00216	f6 84 0f b8 11
	00 00 03	 test	 BYTE PTR [edi+ecx+4536], 3
  0021e	0f 87 b5 01 00
	00		 ja	 $LN7@CGPartyReq

; 8244 : 	{
; 8245 : 		::GCResultSend(aIndex, 0x41, 0x00);
; 8246 : 		return;
; 8247 : 	}
; 8248 : 
; 8249 : 	if ( (gObj[number].m_Option &1) != TRUE )

  00224	f6 84 0f 24 12
	00 00 01	 test	 BYTE PTR [edi+ecx+4644], 1
  0022c	75 14		 jne	 SHORT $LN19@CGPartyReq

; 8250 : 	{
; 8251 : 		::GCResultSend(aIndex, 0x41, 0x01);

  0022e	6a 01		 push	 1
  00230	6a 41		 push	 65			; 00000041H
  00232	53		 push	 ebx
  00233	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  00238	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023b	5e		 pop	 esi
  0023c	5b		 pop	 ebx
  0023d	5f		 pop	 edi

; 8313 : }

  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c3		 ret	 0
$LN19@CGPartyReq:

; 8252 : 		return;
; 8253 : 	}
; 8254 : 
; 8255 : 	if ( gObj[aIndex].PartyNumber >= 0 )

  00242	8b 84 0e 0c 06
	00 00		 mov	 eax, DWORD PTR [esi+ecx+1548]
  00249	85 c0		 test	 eax, eax
  0024b	78 37		 js	 SHORT $LN21@CGPartyReq

; 8256 : 	{
; 8257 : 		int iUserIndex;
; 8258 : 		int iDbNumber;
; 8259 : 		gParty.GetIndexUser(gObj[aIndex].PartyNumber, 0, iUserIndex, iDbNumber);

  0024d	8d 4d f4	 lea	 ecx, DWORD PTR _iDbNumber$1[ebp]
  00250	51		 push	 ecx
  00251	8d 4d f8	 lea	 ecx, DWORD PTR _iUserIndex$2[ebp]
  00254	51		 push	 ecx
  00255	6a 00		 push	 0
  00257	50		 push	 eax
  00258	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0025d	e8 00 00 00 00	 call	 ?GetIndexUser@PartyClass@@QAEHHHAAH0@Z ; PartyClass::GetIndexUser

; 8260 : 		
; 8261 : 		if ( iUserIndex < 0 || ( iUserIndex != aIndex && gObj[aIndex].DBNumber != iDbNumber )  )

  00262	8b 45 f8	 mov	 eax, DWORD PTR _iUserIndex$2[ebp]
  00265	85 c0		 test	 eax, eax
  00267	0f 88 6c 01 00
	00		 js	 $LN7@CGPartyReq
  0026d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00273	3b c3		 cmp	 eax, ebx
  00275	74 0d		 je	 SHORT $LN21@CGPartyReq
  00277	8b 44 0e 30	 mov	 eax, DWORD PTR [esi+ecx+48]
  0027b	3b 45 f4	 cmp	 eax, DWORD PTR _iDbNumber$1[ebp]
  0027e	0f 85 55 01 00
	00		 jne	 $LN7@CGPartyReq
$LN21@CGPartyReq:

; 8262 : 		{
; 8263 : 			::GCResultSend(aIndex, 0x41, 0x00);
; 8264 : 			return;
; 8265 : 
; 8266 : 		}
; 8267 : 	}
; 8268 : 
; 8269 : 	if ( gObj[aIndex].PartyTargetUser >= 0 )

  00284	83 bc 0e 10 06
	00 00 00	 cmp	 DWORD PTR [esi+ecx+1552], 0
  0028c	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0028f	0f 8d 51 01 00
	00		 jge	 $LN39@CGPartyReq

; 8270 : 		return;
; 8271 : 
; 8272 : 	if ( gObj[number].PartyNumber >= 0 )

  00295	83 bc 0f 0c 06
	00 00 00	 cmp	 DWORD PTR [edi+ecx+1548], 0
  0029d	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  002a0	7c 14		 jl	 SHORT $LN24@CGPartyReq

; 8273 : 	{
; 8274 : 		::GCResultSend(aIndex, 0x41, 0x04);

  002a2	6a 04		 push	 4
  002a4	6a 41		 push	 65			; 00000041H
  002a6	53		 push	 ebx
  002a7	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  002af	5e		 pop	 esi
  002b0	5b		 pop	 ebx
  002b1	5f		 pop	 edi

; 8313 : }

  002b2	8b e5		 mov	 esp, ebp
  002b4	5d		 pop	 ebp
  002b5	c3		 ret	 0
$LN24@CGPartyReq:

; 8275 : 		return;
; 8276 : 	}
; 8277 : 
; 8278 : 	if ( gObj[number].PartyTargetUser >= 0 )

  002b6	83 b8 10 06 00
	00 00		 cmp	 DWORD PTR [eax+1552], 0
  002bd	0f 8d 16 01 00
	00		 jge	 $LN7@CGPartyReq

; 8279 : 	{
; 8280 : 		::GCResultSend(aIndex, 0x41, 0x00);
; 8281 : 		return;
; 8282 : 	}
; 8283 : 
; 8284 : #if (ENABLETEST_ARCA == 1)
; 8285 : 	if( g_ArcaBattle.IsArcaBattleServer()
; 8286 : #if (ENABLETEST_ACHERON == 1)
; 8287 : 		&& !g_AcheronGuardianEvent.IsPlayStart()
; 8288 : #endif
; 8289 : 		&& gObj[aIndex].GuildNumber != gObj[number].GuildNumber )
; 8290 :     {
; 8291 :         GCServerMsgStringSend(/*lMsg.Get(3507)*/"You can create party only with your guild", aIndex, 1);
; 8292 : 		return;
; 8293 :     }
; 8294 : #endif
; 8295 : 
; 8296 : 	gObj[aIndex].m_IfState.use = TRUE;

  002c3	8b 82 b8 11 00
	00		 mov	 eax, DWORD PTR [edx+4536]
  002c9	83 e0 fd	 and	 eax, -3			; fffffffdH
  002cc	83 c8 01	 or	 eax, 1
  002cf	89 82 b8 11 00
	00		 mov	 DWORD PTR [edx+4536], eax

; 8297 : 	gObj[aIndex].m_IfState.type = 2;

  002d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002db	8b 84 31 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+esi+4536]
  002e2	25 bf 00 ff ff	 and	 eax, -65345		; ffff00bfH
  002e7	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  002ec	89 84 31 b8 11
	00 00		 mov	 DWORD PTR [ecx+esi+4536], eax

; 8298 : 	gObj[aIndex].m_IfState.state = 0;

  002f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f8	83 a4 06 b8 11
	00 00 c3	 and	 DWORD PTR [esi+eax+4536], -61 ; ffffffc3H

; 8299 : 	gObj[number].m_IfState.use = TRUE;

  00300	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00306	8b 84 39 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+edi+4536]
  0030d	83 e0 fd	 and	 eax, -3			; fffffffdH
  00310	83 c8 01	 or	 eax, 1
  00313	89 84 39 b8 11
	00 00		 mov	 DWORD PTR [ecx+edi+4536], eax

; 8300 : 	gObj[number].m_IfState.type = 2;

  0031a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00320	8b 84 39 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+edi+4536]
  00327	25 bf 00 ff ff	 and	 eax, -65345		; ffff00bfH
  0032c	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00331	89 84 39 b8 11
	00 00		 mov	 DWORD PTR [ecx+edi+4536], eax

; 8301 : 	gObj[number].m_IfState.state = 0;

  00338	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 8302 : 	gObj[aIndex].TargetNumber = number;

  0033d	8b 4d fc	 mov	 ecx, DWORD PTR _number$1$[ebp]
  00340	83 a4 07 b8 11
	00 00 c3	 and	 DWORD PTR [edi+eax+4536], -61 ; ffffffc3H
  00348	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0034d	66 89 8c 06 38
	06 00 00	 mov	 WORD PTR [esi+eax+1592], cx

; 8303 : 	gObj[number].TargetNumber = aIndex;

  00355	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 8304 : 	gObj[aIndex].m_InterfaceTime = GetTickCount();

  0035a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  00360	66 89 9c 07 38
	06 00 00	 mov	 WORD PTR [edi+eax+1592], bx
  00368	ff d6		 call	 esi
  0036a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00370	8b 55 08	 mov	 edx, DWORD PTR tv676[ebp]
  00373	89 84 0a bc 11
	00 00		 mov	 DWORD PTR [edx+ecx+4540], eax

; 8305 : 	gObj[number].m_InterfaceTime = GetTickCount();

  0037a	ff d6		 call	 esi
  0037c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 8306 : 	gObj[aIndex].PartyTargetUser = number;

  00382	8b 75 fc	 mov	 esi, DWORD PTR _number$1$[ebp]

; 8307 : 	
; 8308 : 	PHeadSetB((LPBYTE)&pMsg, 0x40, sizeof(pMsg));

  00385	6a 05		 push	 5
  00387	6a 40		 push	 64			; 00000040H
  00389	89 84 0f bc 11
	00 00		 mov	 DWORD PTR [edi+ecx+4540], eax
  00390	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00395	8b 4d 08	 mov	 ecx, DWORD PTR tv676[ebp]
  00398	89 b4 01 10 06
	00 00		 mov	 DWORD PTR [ecx+eax+1552], esi
  0039f	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 8309 : 	pMsg.NumberH = SET_NUMBERH(aIndex);

  003a8	8b c3		 mov	 eax, ebx

; 8310 : 	pMsg.NumberL = SET_NUMBERL(aIndex);

  003aa	88 5d f0	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  003ad	c1 e8 08	 shr	 eax, 8
  003b0	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 8311 : 
; 8312 : 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  003b3	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  003b7	50		 push	 eax
  003b8	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  003bb	50		 push	 eax
  003bc	56		 push	 esi
  003bd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003c2	83 c4 18	 add	 esp, 24			; 00000018H
  003c5	5e		 pop	 esi
  003c6	5b		 pop	 ebx
  003c7	5f		 pop	 edi

; 8313 : }

  003c8	8b e5		 mov	 esp, ebp
  003ca	5d		 pop	 ebp
  003cb	c3		 ret	 0
$LN37@CGPartyReq:

; 8181 : 	{
; 8182 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 198)), aIndex, 1);

  003cc	6a 01		 push	 1
  003ce	53		 push	 ebx
  003cf	68 c6 04 00 00	 push	 1222			; 000004c6H

; 8183 : 		return;

  003d4	e9 db fc ff ff	 jmp	 $LN44@CGPartyReq
$LN7@CGPartyReq:

; 8163 : 	{
; 8164 : 		::GCResultSend(aIndex, 0x41, 0x00);

  003d9	6a 00		 push	 0
  003db	6a 41		 push	 65			; 00000041H
  003dd	53		 push	 ebx
  003de	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  003e3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@CGPartyReq:
  003e6	5e		 pop	 esi
  003e7	5b		 pop	 ebx
$LN3@CGPartyReq:
  003e8	5f		 pop	 edi

; 8313 : }

  003e9	8b e5		 mov	 esp, ebp
  003eb	5d		 pop	 ebp
  003ec	c3		 ret	 0
?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ENDP	; CGPartyRequestRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopAnsDealerClosedShop@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
?CGPShopAnsDealerClosedShop@@YAXHH@Z PROC		; CGPShopAnsDealerClosedShop, COMDAT

; 8124 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 8125 : 	PMSG_REQ_DEALER_CLOSED_SHOP pMsg;
; 8126 : 
; 8127 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x12, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	6a 12		 push	 18			; 00000012H
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 8128 : 	pMsg.NumberH = SET_NUMBERH(aTargetIndex);

  00015	8b 4d 0c	 mov	 ecx, DWORD PTR _aTargetIndex$[ebp]
  00018	8b c1		 mov	 eax, ecx
  0001a	c1 e8 08	 shr	 eax, 8
  0001d	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 8129 : 	pMsg.NumberL = SET_NUMBERL(aTargetIndex);
; 8130 : 
; 8131 : 	DataSend(aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00020	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00024	50		 push	 eax
  00025	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00028	88 4d fd	 mov	 BYTE PTR _pMsg$[ebp+5], cl
  0002b	50		 push	 eax
  0002c	ff 75 08	 push	 DWORD PTR _aSourceIndex$[ebp]
  0002f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH

; 8132 : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?CGPShopAnsDealerClosedShop@@YAXHH@Z ENDP		; CGPShopAnsDealerClosedShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopAnsSoldItem@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 15
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_iItemPos$ = 16						; size = 4
?CGPShopAnsSoldItem@@YAXHHH@Z PROC			; CGPShopAnsSoldItem, COMDAT

; 8102 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aTargetIndex$[ebp]

; 8103 : 	PMSG_ANS_SOLDITEM_FROM_PSHOP pMsg;
; 8104 : 
; 8105 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x08, sizeof(pMsg));

  00014	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 0f		 push	 15			; 0000000fH
  00019	6a 08		 push	 8
  0001b	6a 3f		 push	 63			; 0000003fH
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 8106 : 	pMsg.btItemPos = iItemPos;

  00023	8a 45 10	 mov	 al, BYTE PTR _iItemPos$[ebp]
  00026	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 8107 : 	memcpy(pMsg.btName, gObj[aTargetIndex].Name, MAX_ACCOUNT_LEN);

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00034	f3 0f 7e 44 01
	5d		 movq	 xmm0, QWORD PTR [ecx+eax+93]
  0003a	66 0f d6 45 f1	 movq	 QWORD PTR _pMsg$[ebp+5], xmm0
  0003f	66 8b 44 01 65	 mov	 ax, WORD PTR [ecx+eax+101]
  00044	66 89 45 f9	 mov	 WORD PTR _pMsg$[ebp+13], ax

; 8108 : 
; 8109 : 	DataSend(aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00048	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0004c	50		 push	 eax
  0004d	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00050	50		 push	 eax
  00051	ff 75 08	 push	 DWORD PTR _aSourceIndex$[ebp]
  00054	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 8110 : }

  00059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005f	33 cd		 xor	 ecx, ebp
  00061	5e		 pop	 esi
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?CGPShopAnsSoldItem@@YAXHHH@Z ENDP			; CGPShopAnsSoldItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z PROC ; CGPShopReqCloseDeal, COMDAT

; 8089 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 8090 : 	if ( !gObjIsConnected(aIndex))

  00004	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 3e		 je	 SHORT $LN1@CGPShopReq

; 8091 : 		return;
; 8092 : 
; 8093 : 	gObj[aIndex].m_bPShopWantDeal = false;

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00019	0f 57 c0	 xorps	 xmm0, xmm0
  0001c	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00022	c6 84 01 84 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4740], 0

; 8094 : 	gObj[aIndex].m_iPShopDealerIndex =-1;

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	c7 84 01 88 12
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+4744], -1

; 8095 : 	memset(gObj[aIndex].m_szPShopDealerName , 0, MAX_ACCOUNT_LEN);

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003f	66 0f d6 84 01
	8c 12 00 00	 movq	 QWORD PTR [ecx+eax+4748], xmm0
  00048	66 c7 84 01 94
	12 00 00 00 00	 mov	 WORD PTR [ecx+eax+4756], 0
$LN1@CGPShopReq:
  00052	5e		 pop	 esi

; 8096 : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?CGPShopReqCloseDeal@@YAXPAUPMSG_REQ_PSHOPDEAL_CLOSE@@H@Z ENDP ; CGPShopReqCloseDeal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopAnsBuyItem@@YAXHHHE@Z
_TEXT	SEGMENT
_aSourceIndex$GSCopy$1$ = -28				; size = 4
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_iItemPos$ = 16						; size = 4
_btResult$ = 20						; size = 1
?CGPShopAnsBuyItem@@YAXHHHE@Z PROC			; CGPShopAnsBuyItem, COMDAT

; 8064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 10	 mov	 ebx, DWORD PTR _iItemPos$[ebp]

; 8065 : 	PMSG_ANS_BUYITEM_FROM_PSHOP pMsg;
; 8066 : 
; 8067 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x06, sizeof(pMsg));

  00014	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  0001b	57		 push	 edi
  0001c	6a 14		 push	 20			; 00000014H
  0001e	6a 06		 push	 6
  00020	6a 3f		 push	 63			; 0000003fH
  00022	50		 push	 eax
  00023	89 75 e4	 mov	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp], esi
  00026	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 8068 : 	pMsg.NumberH = SET_NUMBERH(aTargetIndex);

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _aTargetIndex$[ebp]

; 8069 : 	pMsg.NumberL = SET_NUMBERL(aTargetIndex);
; 8070 : 	pMsg.btItemPos = iItemPos;
; 8071 : 	pMsg.Result = btResult;
; 8072 : 	ItemByteConvert(pMsg.cItemInfo, gObj[aSourceIndex].Inventory1[iItemPos]);

  0002e	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00034	8b c1		 mov	 eax, ecx
  00036	88 4d ee	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  00039	c1 e8 08	 shr	 eax, 8
  0003c	8b fc		 mov	 edi, esp
  0003e	88 45 ed	 mov	 BYTE PTR _pMsg$[ebp+5], al
  00041	8a 45 14	 mov	 al, BYTE PTR _btResult$[ebp]
  00044	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0004a	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	69 d3 d4 00 00
	00		 imul	 edx, ebx, 212
  00058	88 5d fb	 mov	 BYTE PTR _pMsg$[ebp+19], bl
  0005b	8b b4 01 d0 11
	00 00		 mov	 esi, DWORD PTR [ecx+eax+4560]
  00062	8d 45 ef	 lea	 eax, DWORD PTR _pMsg$[ebp+7]
  00065	03 f2		 add	 esi, edx
  00067	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0006c	f3 a5		 rep movsd
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 8073 : 
; 8074 : 	DataSend(aSourceIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00074	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00078	50		 push	 eax
  00079	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0007c	50		 push	 eax
  0007d	ff 75 e4	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00080	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 8075 : }

  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0008e	33 cd		 xor	 ecx, ebp
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?CGPShopAnsBuyItem@@YAXHHHE@Z ENDP			; CGPShopAnsBuyItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z
_TEXT	SEGMENT
_lpObj$ = -220						; size = 4
tv1555 = -216						; size = 4
tv1535 = -212						; size = 4
_x$2 = -208						; size = 4
_iEmptyCount$3 = -204					; size = 4
_x$4 = -200						; size = 4
_x$5 = -196						; size = 4
_x$6 = -192						; size = 4
_x$7 = -188						; size = 4
_aPShopJewelValue$1$ = -182				; size = 2
_iFreeSpaceReq$8 = -180					; size = 4
_iPShopValue$1$ = -176					; size = 4
tv1678 = -172						; size = 4
_iITEM_LOG_SERIAL$1$ = -172				; size = 4
tv1672 = -168						; size = 4
_iITEM_LOG_DUR$1$ = -168				; size = 4
tv1668 = -164						; size = 4
_iITEM_LOG_LEVEL$1$ = -164				; size = 4
tv1648 = -160						; size = 4
_iITEM_LOG_TYPE$1$ = -160				; size = 4
_aPShopJewelValue$3$ = -154				; size = 2
_invSize$2$ = -152					; size = 4
tv1854 = -152						; size = 4
_aPShopJewelValue$2$ = -148				; size = 2
_btNewItemPos$1$ = -145					; size = 1
_bBoundle$9 = -144					; size = 3
_JewelType$1$ = -140					; size = 4
tv1845 = -140						; size = 4
_n$3$ = -140						; size = 4
_JewelLevel$1$ = -136					; size = 4
_lpObj$1$ = -136					; size = 4
tv1889 = -132						; size = 4
tv1844 = -132						; size = 4
_lpMsg$GSCopy$1$ = -128					; size = 4
_n$10 = -124						; size = 4
tv692 = -120						; size = 4
_aSourceIndex$GSCopy$1$ = -116				; size = 4
_iJewelId$11 = -112					; size = 12
_iBoundleId$12 = -100					; size = 12
_JewelCount$13 = -88					; size = 12
_aPShopJewel$14 = -76					; size = 6
_aPShopJewelBoundle$15 = -68				; size = 18
_szName$ = -48						; size = 11
_aPShopJewelValue$16 = -36				; size = 6
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_lpMsg$ = 8						; size = 4
_aSourceIndex$ = 12					; size = 4
?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z PROC ; CGPShopReqBuyItem, COMDAT

; 7541 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00039	89 55 80	 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], edx
  0003c	8b 45 0c	 mov	 eax, DWORD PTR _aSourceIndex$[ebp]
  0003f	89 45 8c	 mov	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp], eax

; 7542 : 	if ( gDoPShopOpen == FALSE )

  00042	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  00049	0f 84 0b 11 00
	00		 je	 $LN121@CGPShopReq

; 7543 : 		return;
; 7544 : 
; 7545 : 	LPOBJ lpSourceObj = &gObj[aSourceIndex];

  0004f	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  00055	89 b5 7c ff ff
	ff		 mov	 DWORD PTR tv1889[ebp], esi
  0005b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00061	89 7d 88	 mov	 DWORD PTR tv692[ebp], edi

; 7546 : 
; 7547 : 	if ( gObjIsConnected( MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)) == FALSE )

  00064	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00068	66 c1 e0 08	 shl	 ax, 8
  0006c	0f b7 c8	 movzx	 ecx, ax
  0006f	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00073	0b c8		 or	 ecx, eax
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0007b	83 c4 04	 add	 esp, 4
  0007e	85 c0		 test	 eax, eax
  00080	75 42		 jne	 SHORT $LN35@CGPShopReq

; 7548 : 	{
; 7549 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller did Not CONNECTED (%d)",

  00082	8b 55 80	 mov	 edx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00085	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00089	66 c1 e0 08	 shl	 ax, 8
  0008d	0f b7 c8	 movzx	 ecx, ax
  00090	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00094	0b c8		 or	 ecx, eax
  00096	51		 push	 ecx
  00097	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0009a	03 c6		 add	 eax, esi
  0009c	50		 push	 eax
  0009d	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  000a0	03 c6		 add	 eax, esi
  000a2	50		 push	 eax
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@OPAFJLAF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7550 : 			lpSourceObj->AccountID, lpSourceObj->Name, MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));
; 7551 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  000ae	6a 02		 push	 2
  000b0	6a 00		 push	 0
  000b2	6a ff		 push	 -1
  000b4	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  000b7	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  000bc	83 c4 20	 add	 esp, 32			; 00000020H

; 7552 : 		return;

  000bf	e9 96 10 00 00	 jmp	 $LN121@CGPShopReq
$LN35@CGPShopReq:

; 7553 : 	}
; 7554 : 
; 7555 : 	LPOBJ lpObj = &gObj[MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)];

  000c4	8b 4d 80	 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  000c7	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  000cb	66 c1 e0 08	 shl	 ax, 8
  000cf	0f b7 d0	 movzx	 edx, ax
  000d2	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  000d6	0b d0		 or	 edx, eax
  000d8	69 fa 40 27 00
	00		 imul	 edi, edx, 10048
  000de	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e4	89 bd 78 ff ff
	ff		 mov	 DWORD PTR _lpObj$1$[ebp], edi
  000ea	89 bd 24 ff ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], edi

; 7559 : 	{
; 7560 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Not CHARACTER (%d)",

  000f0	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]

; 7556 : 	
; 7557 : 
; 7558 : 	if ( lpObj->Type != OBJ_USER )

  000f3	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  000f7	74 2e		 je	 SHORT $LN36@CGPShopReq

; 7559 : 	{
; 7560 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Not CHARACTER (%d)",

  000f9	52		 push	 edx
  000fa	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000fd	03 c6		 add	 eax, esi
  000ff	50		 push	 eax
  00100	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00103	03 c6		 add	 eax, esi
  00105	50		 push	 eax
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@KMDCDECB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7561 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));
; 7562 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  00111	6a 02		 push	 2
  00113	6a 00		 push	 0
  00115	6a ff		 push	 -1
  00117	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  0011a	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  0011f	83 c4 20	 add	 esp, 32			; 00000020H

; 7563 : 		return;

  00122	e9 33 10 00 00	 jmp	 $LN121@CGPShopReq
$LN36@CGPShopReq:

; 7564 : 	}
; 7565 : 
; 7566 : 	if ( lpObj->CloseCount >= 0 )	

  00127	80 7f 0c 00	 cmp	 BYTE PTR [edi+12], 0
  0012b	7c 2e		 jl	 SHORT $LN37@CGPShopReq

; 7567 : 	{
; 7568 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Closing (%d)",

  0012d	52		 push	 edx
  0012e	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00131	03 c6		 add	 eax, esi
  00133	50		 push	 eax
  00134	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00137	03 c6		 add	 eax, esi
  00139	50		 push	 eax
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7569 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)  );
; 7570 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0,2);

  00145	6a 02		 push	 2
  00147	6a 00		 push	 0
  00149	6a ff		 push	 -1
  0014b	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  0014e	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00153	83 c4 20	 add	 esp, 32			; 00000020H

; 7571 : 		return;

  00156	e9 ff 0f 00 00	 jmp	 $LN121@CGPShopReq
$LN37@CGPShopReq:

; 7572 : 	}
; 7573 : 
; 7574 : 
; 7575 : 	if ( lpSourceObj->CloseCount >= 0 )	

  0015b	80 7c 0e 0c 00	 cmp	 BYTE PTR [esi+ecx+12], 0
  00160	7c 2e		 jl	 SHORT $LN38@CGPShopReq

; 7576 : 	{
; 7577 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Closing (%d)",

  00162	52		 push	 edx
  00163	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00166	03 c6		 add	 eax, esi
  00168	50		 push	 eax
  00169	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0016c	03 c6		 add	 eax, esi
  0016e	50		 push	 eax
  0016f	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7578 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));
; 7579 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  0017a	6a 02		 push	 2
  0017c	6a 00		 push	 0
  0017e	6a ff		 push	 -1
  00180	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00183	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00188	83 c4 20	 add	 esp, 32			; 00000020H

; 7580 : 		return;

  0018b	e9 ca 0f 00 00	 jmp	 $LN121@CGPShopReq
$LN38@CGPShopReq:

; 7581 : 	}
; 7582 : 
; 7583 : 	if ( lpSourceObj->pInventory[0].m_Type == ITEMGET(0,41) )

  00190	8b 84 0e c0 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4544]
  00197	66 83 78 06 29	 cmp	 WORD PTR [eax+6], 41	; 00000029H
  0019c	75 2e		 jne	 SHORT $LN39@CGPShopReq

; 7584 : 	{
; 7585 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Mining (%d)",

  0019e	52		 push	 edx
  0019f	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001a2	03 c6		 add	 eax, esi
  001a4	50		 push	 eax
  001a5	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001a8	03 c6		 add	 eax, esi
  001aa	50		 push	 eax
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KFEECMPB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7586 : 			lpSourceObj->AccountID, lpSourceObj->Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));
; 7587 : 		::CGPShopAnsBuyItem(aSourceIndex, -1, 0, 10);

  001b6	6a 0a		 push	 10			; 0000000aH
  001b8	6a 00		 push	 0
  001ba	6a ff		 push	 -1
  001bc	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  001bf	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  001c4	83 c4 20	 add	 esp, 32			; 00000020H

; 7588 : 		return;

  001c7	e9 8e 0f 00 00	 jmp	 $LN121@CGPShopReq
$LN39@CGPShopReq:

; 7589 : 	}
; 7590 : 
; 7591 : #if (ENABLETEST_NEWPVP == 1)
; 7592 : 	if (g_NewPVP.IsDuel(gObj[aSourceIndex])) {

  001cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001d1	03 c6		 add	 eax, esi
  001d3	50		 push	 eax
  001d4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  001d9	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  001de	85 c0		 test	 eax, eax
  001e0	74 22		 je	 SHORT $LN40@CGPShopReq

; 7593 : 		 GCServerMsgStringSend(lMsg.Get(3429), aSourceIndex, 1);

  001e2	6a 01		 push	 1
  001e4	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  001e7	68 65 0d 00 00	 push	 3429			; 00000d65H
$LN171@CGPShopReq:
  001ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001f1	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7594 : 		 return;

  001ff	e9 56 0f 00 00	 jmp	 $LN121@CGPShopReq
$LN40@CGPShopReq:

; 7595 : 	}
; 7596 : 	
; 7597 : 	if (g_NewPVP.IsObserver(gObj[aSourceIndex])) {

  00204	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00209	03 c6		 add	 eax, esi
  0020b	50		 push	 eax
  0020c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00211	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00216	85 c0		 test	 eax, eax
  00218	74 0c		 je	 SHORT $LN41@CGPShopReq

; 7598 : 		 GCServerMsgStringSend(lMsg.Get(3430), aSourceIndex, 1);

  0021a	6a 01		 push	 1
  0021c	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  0021f	68 66 0d 00 00	 push	 3430			; 00000d66H

; 7599 : 		 return;

  00224	eb c6		 jmp	 SHORT $LN171@CGPShopReq
$LN41@CGPShopReq:

; 7600 : 	}
; 7601 : #endif
; 7602 : 
; 7603 : 	if ( lpObj->m_bPShopOpen == false )

  00226	80 bf 5c 12 00
	00 00		 cmp	 BYTE PTR [edi+4700], 0
  0022d	75 29		 jne	 SHORT $LN42@CGPShopReq

; 7604 : 	{
; 7605 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did not Open PShop",

  0022f	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00232	50		 push	 eax
  00233	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00236	50		 push	 eax
  00237	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]
  0023a	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0023d	03 c6		 add	 eax, esi
  0023f	50		 push	 eax
  00240	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00243	03 c6		 add	 eax, esi
  00245	50		 push	 eax
  00246	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@OKADFHGM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7606 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 7607 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 3);

  00251	6a 03		 push	 3

; 7608 : 		return;

  00253	e9 f3 0e 00 00	 jmp	 $LN160@CGPShopReq
$LN42@CGPShopReq:
  00258	0f 57 c0	 xorps	 xmm0, xmm0

; 7609 : 	}
; 7610 : 
; 7611 : 	char szName[MAX_ACCOUNT_LEN+1] = {0};

  0025b	66 0f d6 45 d1	 movq	 QWORD PTR _szName$[ebp+1], xmm0
  00260	66 c7 45 d9 00
	00		 mov	 WORD PTR _szName$[ebp+9], 0

; 7612 : 	memcpy(szName, lpMsg->btName, sizeof(lpMsg->btName));

  00266	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00269	f3 0f 7e 40 06	 movq	 xmm0, QWORD PTR [eax+6]
  0026e	66 0f d6 45 d0	 movq	 QWORD PTR _szName$[ebp], xmm0
  00273	66 8b 40 0e	 mov	 ax, WORD PTR [eax+14]
  00277	66 89 45 d8	 mov	 WORD PTR _szName$[ebp+8], ax

; 7613 : 	szName[MAX_ACCOUNT_LEN] = 0;

  0027b	c6 45 da 00	 mov	 BYTE PTR _szName$[ebp+10], 0

; 7614 : 	int iITEM_LOG_TYPE;
; 7615 : 	int iITEM_LOG_LEVEL;
; 7616 : 	int iITEM_LOG_DUR;
; 7617 : 	int iITEM_LOG_SERIAL;
; 7618 : 
; 7619 : 	if ( strcmp(szName, lpObj->Name) )

  0027f	8d 4f 5d	 lea	 ecx, DWORD PTR [edi+93]
  00282	8d 45 d0	 lea	 eax, DWORD PTR _szName$[ebp]
$LL153@CGPShopReq:
  00285	8a 10		 mov	 dl, BYTE PTR [eax]
  00287	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00289	75 1a		 jne	 SHORT $LN154@CGPShopReq
  0028b	84 d2		 test	 dl, dl
  0028d	74 12		 je	 SHORT $LN155@CGPShopReq
  0028f	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00292	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00295	75 0e		 jne	 SHORT $LN154@CGPShopReq
  00297	83 c0 02	 add	 eax, 2
  0029a	83 c1 02	 add	 ecx, 2
  0029d	84 d2		 test	 dl, dl
  0029f	75 e4		 jne	 SHORT $LL153@CGPShopReq
$LN155@CGPShopReq:
  002a1	33 c0		 xor	 eax, eax
  002a3	eb 05		 jmp	 SHORT $LN156@CGPShopReq
$LN154@CGPShopReq:
  002a5	1b c0		 sbb	 eax, eax
  002a7	83 c8 01	 or	 eax, 1
$LN156@CGPShopReq:

; 7620 : 	{
; 7621 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Name Mismatch [%s] - [%s]",

  002aa	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]

; 7614 : 	int iITEM_LOG_TYPE;
; 7615 : 	int iITEM_LOG_LEVEL;
; 7616 : 	int iITEM_LOG_DUR;
; 7617 : 	int iITEM_LOG_SERIAL;
; 7618 : 
; 7619 : 	if ( strcmp(szName, lpObj->Name) )

  002ad	85 c0		 test	 eax, eax
  002af	74 26		 je	 SHORT $LN43@CGPShopReq

; 7620 : 	{
; 7621 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Name Mismatch [%s] - [%s]",

  002b1	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  002b4	50		 push	 eax
  002b5	8d 45 d0	 lea	 eax, DWORD PTR _szName$[ebp]
  002b8	50		 push	 eax
  002b9	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002bc	03 c6		 add	 eax, esi
  002be	50		 push	 eax
  002bf	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  002c2	03 c6		 add	 eax, esi
  002c4	50		 push	 eax
  002c5	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PJOAJAPF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  002ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7622 : 			lpSourceObj->AccountID, lpSourceObj->Name,szName, lpObj->Name);
; 7623 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 6);

  002d0	6a 06		 push	 6

; 7624 : 
; 7625 : 		return;

  002d2	e9 74 0e 00 00	 jmp	 $LN160@CGPShopReq
$LN43@CGPShopReq:

; 7626 : 	}
; 7627 : 
; 7628 : 	if ( lpObj->CloseType != -1 )

  002d7	80 7f 0d ff	 cmp	 BYTE PTR [edi+13], -1
  002db	74 26		 je	 SHORT $LN44@CGPShopReq

; 7629 : 	{
; 7630 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is Closing Connection",

  002dd	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  002e0	50		 push	 eax
  002e1	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  002e4	50		 push	 eax
  002e5	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002e8	03 c6		 add	 eax, esi
  002ea	50		 push	 eax
  002eb	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  002ee	03 c6		 add	 eax, esi
  002f0	50		 push	 eax
  002f1	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@NMMBBGEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  002f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7631 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 7632 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,2);

  002fc	6a 02		 push	 2

; 7633 : 
; 7634 : 		return;

  002fe	e9 48 0e 00 00	 jmp	 $LN160@CGPShopReq
$LN44@CGPShopReq:
  00303	f6 87 c0 01 00
	00 0c		 test	 BYTE PTR [edi+448], 12	; 0000000cH

; 7635 : 	}
; 7636 : 
; 7637 : 	if ( (lpObj->Penalty &4) == 4 || (lpObj->Penalty &8) == 8 )

  0030a	0f 85 1a 0e 00
	00		 jne	 $LN46@CGPShopReq
  00310	f6 84 0e c0 01
	00 00 0c	 test	 BYTE PTR [esi+ecx+448], 12 ; 0000000cH

; 7642 : 
; 7643 : 		return;
; 7644 : 	}
; 7645 : 
; 7646 : 	if ( (lpSourceObj->Penalty &4) == 4 || (lpSourceObj->Penalty &8) == 8 )

  00318	0f 85 0c 0e 00
	00		 jne	 $LN46@CGPShopReq

; 7647 : 	{
; 7648 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",
; 7649 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 7650 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,9);
; 7651 : 		return;
; 7652 : 	}
; 7653 : 
; 7654 : 	EnterCriticalSection(&lpObj->m_critPShopTrade);

  0031e	8d 87 98 12 00
	00		 lea	 eax, DWORD PTR [edi+4760]
  00324	50		 push	 eax
  00325	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 7655 : 
; 7656 : 	if ( lpObj->m_bPShopTransaction == true )

  0032b	80 bf 5d 12 00
	00 01		 cmp	 BYTE PTR [edi+4701], 1
  00332	75 45		 jne	 SHORT $LN49@CGPShopReq

; 7657 : 	{
; 7658 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Already Trade With Other",

  00334	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00337	50		 push	 eax
  00338	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  0033b	50		 push	 eax
  0033c	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]
  0033f	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00342	03 c6		 add	 eax, esi
  00344	50		 push	 eax
  00345	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00348	03 c6		 add	 eax, esi
  0034a	50		 push	 eax
  0034b	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@GGINPDPA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00350	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7659 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 7660 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,4);

  00356	6a 04		 push	 4
  00358	6a 00		 push	 0
  0035a	ff 37		 push	 DWORD PTR [edi]
  0035c	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  0035f	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00364	83 c4 24	 add	 esp, 36			; 00000024H

; 7661 : 		LeaveCriticalSection(&lpObj->m_critPShopTrade);

  00367	8d 87 98 12 00
	00		 lea	 eax, DWORD PTR [edi+4760]
  0036d	50		 push	 eax
  0036e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7662 : 
; 7663 : 	}
; 7664 : 	else

  00374	e9 e1 0d 00 00	 jmp	 $LN121@CGPShopReq
$LN49@CGPShopReq:

; 7665 : 	{
; 7666 : 		lpObj->m_bPShopTransaction = true;

  00379	c6 87 5d 12 00
	00 01		 mov	 BYTE PTR [edi+4701], 1

; 7667 : 		LeaveCriticalSection(&lpObj->m_critPShopTrade);

  00380	8d 87 98 12 00
	00		 lea	 eax, DWORD PTR [edi+4760]
  00386	50		 push	 eax
  00387	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 7668 : 
; 7669 : 		if ( gObjCheckSerial0ItemList(&lpObj->Inventory1[lpMsg->btItemPos]) != FALSE )

  0038d	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00390	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00394	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  0039a	03 87 d0 11 00
	00		 add	 eax, DWORD PTR [edi+4560]
  003a0	50		 push	 eax
  003a1	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  003a6	83 c4 04	 add	 esp, 4
  003a9	85 c0		 test	 eax, eax
  003ab	74 77		 je	 SHORT $LN51@CGPShopReq

; 7670 : 		{
; 7671 : 			MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(13, 26)));

  003ad	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  003b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003b7	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003bc	50		 push	 eax
  003bd	ff 37		 push	 DWORD PTR [edi]
  003bf	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 7672 : 			GCReFillSend(aSourceIndex,(WORD)lpSourceObj->Life, 0xFD, 1, lpSourceObj->iShield);

  003c4	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]
  003c7	0f b7 84 0e 2c
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+300]
  003cf	50		 push	 eax
  003d0	6a 01		 push	 1
  003d2	68 fd 00 00 00	 push	 253			; 000000fdH
  003d7	f3 0f 2c 84 0e
	d8 00 00 00	 cvttss2si eax, DWORD PTR [esi+ecx+216]
  003e0	0f b7 c0	 movzx	 eax, ax
  003e3	50		 push	 eax
  003e4	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  003e7	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  003ec	83 c4 1c	 add	 esp, 28			; 0000001cH

; 7673 : 
; 7674 : 			LogAddTD("[ANTI-HACK][Serial 0 Item] [PShop Buy] (%s)(%s) Item(%s) Pos(%d)",

  003ef	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  003f2	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  003f6	50		 push	 eax
  003f7	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  003fd	03 8f d0 11 00
	00		 add	 ecx, DWORD PTR [edi+4560]
  00403	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00408	50		 push	 eax
  00409	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0040c	50		 push	 eax
  0040d	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00410	50		 push	 eax
  00411	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@DKCMAHPG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
  00416	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0041c	83 c4 14	 add	 esp, 20			; 00000014H

; 7675 : 				lpObj->AccountID, lpObj->Name, lpObj->Inventory1[lpMsg->btItemPos].GetName(), lpMsg->btItemPos);
; 7676 : 
; 7677 : 			return;

  0041f	e9 36 0d 00 00	 jmp	 $LN121@CGPShopReq
$LN51@CGPShopReq:

; 7678 : 		}
; 7679 : 
; 7680 : 
; 7681 : 
; 7682 : 		// New for Check Item Serials
; 7683 : 		if ( ::gObjInventorySearchSerialNumber(&gObj[aSourceIndex], lpObj->Inventory1[lpMsg->btItemPos].GetNumber()) == FALSE )

  00424	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00427	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  0042b	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00431	03 8f d0 11 00
	00		 add	 ecx, DWORD PTR [edi+4560]
  00437	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  0043c	50		 push	 eax
  0043d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00442	03 c6		 add	 eax, esi
  00444	50		 push	 eax
  00445	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  0044a	83 c4 08	 add	 esp, 8
  0044d	85 c0		 test	 eax, eax
  0044f	75 57		 jne	 SHORT $LN52@CGPShopReq

; 7684 : 		{
; 7685 : 			::GCReFillSend(aSourceIndex,(WORD)lpSourceObj->Life, -3, 1, lpSourceObj->iShield);

  00451	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]
  00454	0f b7 84 0e 2c
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+300]
  0045c	50		 push	 eax
  0045d	6a 01		 push	 1
  0045f	68 fd 00 00 00	 push	 253			; 000000fdH
  00464	f3 0f 2c 84 0e
	d8 00 00 00	 cvttss2si eax, DWORD PTR [esi+ecx+216]
  0046d	0f b7 c0	 movzx	 eax, ax
  00470	50		 push	 eax
  00471	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00474	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 7686 : 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d", gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,

  00479	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0047f	68 07 1e 00 00	 push	 7687			; 00001e07H
  00484	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00489	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0048c	03 c6		 add	 eax, esi
  0048e	50		 push	 eax
  0048f	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00492	03 c6		 add	 eax, esi
  00494	50		 push	 eax
  00495	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  0049a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004a0	83 c4 28	 add	 esp, 40			; 00000028H

; 7687 : 				__FILE__, __LINE__);
; 7688 : 
; 7689 : 			return;

  004a3	e9 b2 0c 00 00	 jmp	 $LN121@CGPShopReq
$LN52@CGPShopReq:

; 7690 : 		}
; 7691 : 
; 7692 : 		if ( ::gObjInventorySearchSerialNumber(lpObj, lpObj->Inventory1[lpMsg->btItemPos].GetNumber()) == FALSE )

  004a8	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  004ab	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  004af	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  004b5	03 8f d0 11 00
	00		 add	 ecx, DWORD PTR [edi+4560]
  004bb	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  004c0	50		 push	 eax
  004c1	57		 push	 edi
  004c2	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  004c7	83 c4 08	 add	 esp, 8
  004ca	85 c0		 test	 eax, eax
  004cc	75 47		 jne	 SHORT $LN53@CGPShopReq

; 7693 : 		{
; 7694 : 			GCReFillSend(lpObj->m_Index,(WORD)lpObj->Life, -3, 1, lpObj->iShield);

  004ce	0f b7 87 2c 01
	00 00		 movzx	 eax, WORD PTR [edi+300]
  004d5	50		 push	 eax
  004d6	6a 01		 push	 1
  004d8	68 fd 00 00 00	 push	 253			; 000000fdH
  004dd	f3 0f 2c 87 d8
	00 00 00	 cvttss2si eax, DWORD PTR [edi+216]
  004e5	0f b7 c0	 movzx	 eax, ax
  004e8	50		 push	 eax
  004e9	ff 37		 push	 DWORD PTR [edi]
  004eb	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 7695 : 			LogAdd("error-L2 : CopyItem [%s][%s] return %s %d",

  004f0	68 11 1e 00 00	 push	 7697			; 00001e11H
  004f5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  004fa	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  004fd	50		 push	 eax
  004fe	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00501	50		 push	 eax
  00502	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  00507	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0050d	83 c4 28	 add	 esp, 40			; 00000028H

; 7696 : 				lpObj->AccountID, lpObj->Name,
; 7697 : 				__FILE__, __LINE__);
; 7698 : 
; 7699 : 			return;

  00510	e9 45 0c 00 00	 jmp	 $LN121@CGPShopReq
$LN53@CGPShopReq:

; 7700 : 		}
; 7701 : 
; 7702 : 		if (gObjFixInventoryPointer(aSourceIndex) == false )

  00515	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00518	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0051d	83 c4 04	 add	 esp, 4
  00520	84 c0		 test	 al, al
  00522	75 18		 jne	 SHORT $LN54@CGPShopReq

; 7703 : 		{
; 7704 : 			LogAdd( "[Fix Inv.Ptr] False Location - %s, %d", 

  00524	68 19 1e 00 00	 push	 7705			; 00001e19H
  00529	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0052e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00533	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00539	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@CGPShopReq:

; 7705 : 				__FILE__, __LINE__);
; 7706 : 		}
; 7707 : 
; 7708 : 		if ( gObj[aSourceIndex].pTransaction == 1 )

  0053c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00541	80 bc 06 cc 11
	00 00 01	 cmp	 BYTE PTR [esi+eax+4556], 1
  00549	75 32		 jne	 SHORT $LN55@CGPShopReq

; 7709 : 		{
; 7710 : 			LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Requester Transaction == 1, IF_TYPE : %d",

  0054b	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]
  0054e	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  00555	c1 e8 06	 shr	 eax, 6
  00558	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0055d	50		 push	 eax
  0055e	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00561	03 c6		 add	 eax, esi
  00563	50		 push	 eax
  00564	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00567	03 c6		 add	 eax, esi
  00569	50		 push	 eax
  0056a	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@LBDGBLNC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  0056f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00575	83 c4 10	 add	 esp, 16			; 00000010H

; 7711 : 				lpSourceObj->AccountID, lpSourceObj->Name, lpSourceObj->m_IfState.type);
; 7712 : 			return;

  00578	e9 dd 0b 00 00	 jmp	 $LN121@CGPShopReq
$LN55@CGPShopReq:

; 7713 : 		}
; 7714 : 
; 7715 : 		iITEM_LOG_TYPE=0;
; 7716 : 		iITEM_LOG_LEVEL=0;
; 7717 : 		iITEM_LOG_DUR=0;
; 7718 : 		iITEM_LOG_SERIAL = 0;
; 7719 : 
; 7720 : 		__try

  0057d	9b		 fwait
  0057e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 7721 : 		{
; 7722 : 			if ( PSHOP_RANGE(lpMsg->btItemPos) == FALSE )

  00585	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00588	0f b6 50 10	 movzx	 edx, BYTE PTR [eax+16]
  0058c	8d 8a 34 ff ff
	ff		 lea	 ecx, DWORD PTR [edx-204]
  00592	85 c9		 test	 ecx, ecx
  00594	0f 88 5e 0b 00
	00		 js	 $LN152@CGPShopReq
  0059a	33 c0		 xor	 eax, eax
  0059c	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0059f	0f 9e c0	 setle	 al
  005a2	85 c0		 test	 eax, eax
  005a4	0f 84 4e 0b 00
	00		 je	 $LN152@CGPShopReq

; 7726 : 			}
; 7727 : 
; 7728 : 			if ( lpObj->m_bMapSvrMoveQuit == true )

  005aa	80 bf 3c 20 00
	00 01		 cmp	 BYTE PTR [edi+8252], 1
  005b1	75 27		 jne	 SHORT $LN58@CGPShopReq

; 7729 : 			{
; 7730 : 				CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  005b3	6a 02		 push	 2
  005b5	6a 00		 push	 0
  005b7	6a ff		 push	 -1
  005b9	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  005bc	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7731 : 				return;

  005c1	6a fe		 push	 -2			; fffffffeH
  005c3	9b		 fwait
  005c4	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  005c7	50		 push	 eax
  005c8	68 00 00 00 00	 push	 OFFSET ___security_cookie
  005cd	e8 00 00 00 00	 call	 __local_unwind4
  005d2	83 c4 1c	 add	 esp, 28			; 0000001cH
  005d5	e9 80 0b 00 00	 jmp	 $LN121@CGPShopReq
$LN58@CGPShopReq:

; 7732 : 			}
; 7733 : 
; 7734 : 			if ( lpObj->Inventory1[lpMsg->btItemPos].IsItem() == TRUE )

  005da	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  005e0	03 8f d0 11 00
	00		 add	 ecx, DWORD PTR [edi+4560]
  005e6	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  005eb	83 f8 01	 cmp	 eax, 1
  005ee	0f 85 a3 0a 00
	00		 jne	 $LN97@CGPShopReq

; 7735 : 			{
; 7736 : 				int n;
; 7737 : 				int invSize;
; 7738 : 				int iPShopValue = lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue;

  005f4	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  005f7	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  005fb	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00601	8b 87 d0 11 00
	00		 mov	 eax, DWORD PTR [edi+4560]
  00607	8b 74 01 7c	 mov	 esi, DWORD PTR [ecx+eax+124]
  0060b	89 b5 50 ff ff
	ff		 mov	 DWORD PTR _iPShopValue$1$[ebp], esi

; 7739 : 				short aPShopJewelValue[3];
; 7740 : 				
; 7741 : 				aPShopJewelValue[0] = lpObj->Inventory1[lpMsg->btItemPos].m_PShopBlessValue;

  00611	66 8b 94 01 80
	00 00 00	 mov	 dx, WORD PTR [ecx+eax+128]
  00619	66 89 95 4a ff
	ff ff		 mov	 WORD PTR _aPShopJewelValue$1$[ebp], dx
  00620	66 89 55 dc	 mov	 WORD PTR _aPShopJewelValue$16[ebp], dx

; 7742 : 				aPShopJewelValue[1] = lpObj->Inventory1[lpMsg->btItemPos].m_PShopSoulValue;

  00624	66 8b b4 01 82
	00 00 00	 mov	 si, WORD PTR [ecx+eax+130]
  0062c	66 89 b5 6c ff
	ff ff		 mov	 WORD PTR _aPShopJewelValue$2$[ebp], si
  00633	66 89 75 de	 mov	 WORD PTR _aPShopJewelValue$16[ebp+2], si

; 7743 : 				aPShopJewelValue[2] = lpObj->Inventory1[lpMsg->btItemPos].m_PShopChaosValue;

  00637	66 8b 84 01 84
	00 00 00	 mov	 ax, WORD PTR [ecx+eax+132]
  0063f	66 89 85 66 ff
	ff ff		 mov	 WORD PTR _aPShopJewelValue$3$[ebp], ax
  00646	66 89 45 e0	 mov	 WORD PTR _aPShopJewelValue$16[ebp+4], ax

; 7744 : 
; 7745 : 				if ( iPShopValue < 0 ||
; 7746 : 					 aPShopJewelValue[0] < 0 ||
; 7747 : 					 aPShopJewelValue[1] < 0 ||

  0064a	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _iPShopValue$1$[ebp]
  00650	85 c9		 test	 ecx, ecx
  00652	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR tv1889[ebp]
  00658	0f 88 54 0a 00
	00		 js	 $LN61@CGPShopReq
  0065e	66 85 d2	 test	 dx, dx
  00661	0f 88 4b 0a 00
	00		 js	 $LN61@CGPShopReq
  00667	66 83 bd 6c ff
	ff ff 00	 cmp	 WORD PTR _aPShopJewelValue$2$[ebp], 0
  0066f	0f 8c 3d 0a 00
	00		 jl	 $LN61@CGPShopReq
  00675	66 85 c0	 test	 ax, ax
  00678	0f 88 34 0a 00
	00		 js	 $LN61@CGPShopReq

; 7756 : 				}
; 7757 : 
; 7758 : 				if( iPShopValue > 0 )

  0067e	85 c9		 test	 ecx, ecx
  00680	7e 6f		 jle	 SHORT $LN64@CGPShopReq

; 7759 : 				{
; 7760 : 					if ( gObj[aSourceIndex].Money < lpObj->Inventory1[lpMsg->btItemPos].m_iPShopValue )

  00682	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00687	39 8c 06 cc 00
	00 00		 cmp	 DWORD PTR [esi+eax+204], ecx
  0068e	7d 29		 jge	 SHORT $LN63@CGPShopReq

; 7761 : 					{
; 7762 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Lack of Zen",

  00690	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00693	50		 push	 eax
  00694	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00697	50		 push	 eax
  00698	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]
  0069b	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0069e	03 c6		 add	 eax, esi
  006a0	50		 push	 eax
  006a1	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  006a4	03 c6		 add	 eax, esi
  006a6	50		 push	 eax
  006a7	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@BJIIHLIN@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  006ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7763 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 7764 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 7);

  006b2	6a 07		 push	 7

; 7765 : 						return;

  006b4	e9 1d 0a 00 00	 jmp	 $LN172@CGPShopReq
$LN63@CGPShopReq:

; 7766 : 					}
; 7767 : 
; 7768 : 					if ( gObjCheckMaxZen(lpObj->m_Index, iPShopValue) == FALSE )

  006b9	51		 push	 ecx
  006ba	ff 37		 push	 DWORD PTR [edi]
  006bc	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  006c1	83 c4 08	 add	 esp, 8
  006c4	85 c0		 test	 eax, eax
  006c6	75 29		 jne	 SHORT $LN64@CGPShopReq

; 7769 : 					{
; 7770 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Exceeding Zen of the Host",

  006c8	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  006cb	50		 push	 eax
  006cc	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  006cf	50		 push	 eax
  006d0	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]
  006d3	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  006d6	03 c6		 add	 eax, esi
  006d8	50		 push	 eax
  006d9	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  006dc	03 c6		 add	 eax, esi
  006de	50		 push	 eax
  006df	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@GMGAEINP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  006e4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7771 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 7772 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  006ea	6a 08		 push	 8

; 7773 : 						return;

  006ec	e9 e5 09 00 00	 jmp	 $LN172@CGPShopReq
$LN64@CGPShopReq:

; 7774 : 					}
; 7775 : 				}
; 7776 : 
; 7777 : 				int iFreeSpaceReq = 0;

  006f1	33 c0		 xor	 eax, eax
  006f3	89 85 4c ff ff
	ff		 mov	 DWORD PTR _iFreeSpaceReq$8[ebp], eax

; 7778 : 				short aPShopJewel[3];
; 7779 : 				short aPShopJewelBoundle[3][3];
; 7780 : 				
; 7781 : 				for( n = 0; n < 3; n++)

  006f9	33 f6		 xor	 esi, esi
$LN161@CGPShopReq:
  006fb	89 75 84	 mov	 DWORD PTR _n$10[ebp], esi
  006fe	83 fe 03	 cmp	 esi, 3
  00701	0f 8d b9 00 00
	00		 jge	 $LN3@CGPShopReq

; 7782 : 				{
; 7783 : 					int tmpJewelCnt = aPShopJewelValue[n];

  00707	0f bf 4c 75 dc	 movsx	 ecx, WORD PTR _aPShopJewelValue$16[ebp+esi*2]

; 7784 : 
; 7785 : 					if( tmpJewelCnt > 0 )

  0070c	85 c9		 test	 ecx, ecx
  0070e	0f 8e a6 00 00
	00		 jle	 $LN65@CGPShopReq

; 7786 : 					{
; 7787 : 						aPShopJewelBoundle[n][0] = tmpJewelCnt/30;

  00714	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00719	f7 e9		 imul	 ecx
  0071b	03 d1		 add	 edx, ecx
  0071d	c1 fa 04	 sar	 edx, 4
  00720	8b ca		 mov	 ecx, edx
  00722	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00725	03 ca		 add	 ecx, edx
  00727	8d 3c 76	 lea	 edi, DWORD PTR [esi+esi*2]
  0072a	03 ff		 add	 edi, edi
  0072c	89 bd 68 ff ff
	ff		 mov	 DWORD PTR tv1854[ebp], edi
  00732	66 89 4c 3d bc	 mov	 WORD PTR _aPShopJewelBoundle$15[ebp+edi], cx

; 7788 : 						tmpJewelCnt = tmpJewelCnt%30;

  00737	8b c1		 mov	 eax, ecx
  00739	c1 e0 04	 shl	 eax, 4
  0073c	2b c1		 sub	 eax, ecx
  0073e	f7 d8		 neg	 eax
  00740	0f bf 4c 75 dc	 movsx	 ecx, WORD PTR _aPShopJewelValue$16[ebp+esi*2]
  00745	8d 34 41	 lea	 esi, DWORD PTR [ecx+eax*2]

; 7789 : 						aPShopJewelBoundle[n][1] = tmpJewelCnt/20;

  00748	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0074d	f7 ee		 imul	 esi
  0074f	c1 fa 03	 sar	 edx, 3
  00752	8b ca		 mov	 ecx, edx
  00754	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00757	03 ca		 add	 ecx, edx
  00759	66 89 4c 3d be	 mov	 WORD PTR _aPShopJewelBoundle$15[ebp+edi+2], cx

; 7790 : 						tmpJewelCnt = tmpJewelCnt%20;

  0075e	8b c1		 mov	 eax, ecx
  00760	f7 d8		 neg	 eax
  00762	c1 e0 02	 shl	 eax, 2
  00765	2b c1		 sub	 eax, ecx
  00767	8d 3c 86	 lea	 edi, DWORD PTR [esi+eax*4]

; 7791 : 						aPShopJewelBoundle[n][2] = tmpJewelCnt/10;

  0076a	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0076f	f7 ef		 imul	 edi
  00771	c1 fa 02	 sar	 edx, 2
  00774	8b f2		 mov	 esi, edx
  00776	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00779	03 f2		 add	 esi, edx
  0077b	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv1854[ebp]
  00781	66 89 74 15 c0	 mov	 WORD PTR _aPShopJewelBoundle$15[ebp+edx+4], si

; 7792 : 						aPShopJewel[n] = tmpJewelCnt%10;

  00786	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00789	03 c0		 add	 eax, eax
  0078b	2b f8		 sub	 edi, eax
  0078d	8b 45 84	 mov	 eax, DWORD PTR _n$10[ebp]
  00790	66 89 7c 45 b4	 mov	 WORD PTR _aPShopJewel$14[ebp+eax*2], di

; 7793 : 
; 7794 : 						iFreeSpaceReq += aPShopJewel[n] + aPShopJewelBoundle[n][0] + aPShopJewelBoundle[n][1] + aPShopJewelBoundle[n][2];

  00795	0f bf 4c 15 be	 movsx	 ecx, WORD PTR _aPShopJewelBoundle$15[ebp+edx+2]
  0079a	0f bf c6	 movsx	 eax, si
  0079d	03 c8		 add	 ecx, eax
  0079f	0f bf 44 15 bc	 movsx	 eax, WORD PTR _aPShopJewelBoundle$15[ebp+edx]
  007a4	03 c8		 add	 ecx, eax
  007a6	0f bf c7	 movsx	 eax, di
  007a9	03 85 4c ff ff
	ff		 add	 eax, DWORD PTR _iFreeSpaceReq$8[ebp]
  007af	03 c1		 add	 eax, ecx
  007b1	89 85 4c ff ff
	ff		 mov	 DWORD PTR _iFreeSpaceReq$8[ebp], eax
  007b7	8b 75 84	 mov	 esi, DWORD PTR _n$10[ebp]
$LN65@CGPShopReq:

; 7778 : 				short aPShopJewel[3];
; 7779 : 				short aPShopJewelBoundle[3][3];
; 7780 : 				
; 7781 : 				for( n = 0; n < 3; n++)

  007ba	46		 inc	 esi
  007bb	e9 3b ff ff ff	 jmp	 $LN161@CGPShopReq
$LN3@CGPShopReq:

; 7802 : 				
; 7803 : 					if( lpObj->pInventoryExtend < 4 )	{

  007c0	8b bd 78 ff ff
	ff		 mov	 edi, DWORD PTR _lpObj$1$[ebp]

; 7795 : 					}
; 7796 : 				}
; 7797 : 
; 7798 : 				if( iFreeSpaceReq > 0 )

  007c6	85 c0		 test	 eax, eax
  007c8	7e 7b		 jle	 SHORT $LN69@CGPShopReq

; 7799 : 				{
; 7800 : 					int iEmptyCount = 0;

  007ca	33 d2		 xor	 edx, edx
  007cc	89 95 34 ff ff
	ff		 mov	 DWORD PTR _iEmptyCount$3[ebp], edx

; 7801 : 					invSize = MAIN_INVENTORY_SIZE;

  007d2	be cc 00 00 00	 mov	 esi, 204		; 000000ccH

; 7802 : 				
; 7803 : 					if( lpObj->pInventoryExtend < 4 )	{

  007d7	8a 87 cd 11 00
	00		 mov	 al, BYTE PTR [edi+4557]
  007dd	3c 04		 cmp	 al, 4
  007df	73 09		 jae	 SHORT $LN67@CGPShopReq

; 7804 : 						invSize = (MAIN_INVENTORY_SIZE)-(32*(4-lpObj->pInventoryExtend));

  007e1	0f b6 f0	 movzx	 esi, al
  007e4	c1 e6 05	 shl	 esi, 5
  007e7	83 c6 4c	 add	 esi, 76			; 0000004cH
$LN67@CGPShopReq:

; 7805 : 					}
; 7806 : 
; 7807 : 					for ( int x=0; x<invSize;x++)

  007ea	33 c9		 xor	 ecx, ecx
$LN162@CGPShopReq:
  007ec	89 8d 30 ff ff
	ff		 mov	 DWORD PTR _x$2[ebp], ecx
  007f2	3b ce		 cmp	 ecx, esi
  007f4	7d 16		 jge	 SHORT $LN6@CGPShopReq

; 7808 : 					{
; 7809 : 						if ( lpObj->pInventoryMap[x] == 0xFF )

  007f6	8b 87 c8 11 00
	00		 mov	 eax, DWORD PTR [edi+4552]
  007fc	80 3c 01 ff	 cmp	 BYTE PTR [ecx+eax], 255	; 000000ffH
  00800	75 07		 jne	 SHORT $LN68@CGPShopReq

; 7810 : 						{
; 7811 : 							iEmptyCount++;

  00802	42		 inc	 edx
  00803	89 95 34 ff ff
	ff		 mov	 DWORD PTR _iEmptyCount$3[ebp], edx
$LN68@CGPShopReq:

; 7805 : 					}
; 7806 : 
; 7807 : 					for ( int x=0; x<invSize;x++)

  00809	41		 inc	 ecx
  0080a	eb e0		 jmp	 SHORT $LN162@CGPShopReq
$LN6@CGPShopReq:

; 7812 : 						}
; 7813 : 					}
; 7814 : 
; 7815 : 					if( iEmptyCount < iFreeSpaceReq )

  0080c	3b 95 4c ff ff
	ff		 cmp	 edx, DWORD PTR _iFreeSpaceReq$8[ebp]
  00812	7d 31		 jge	 SHORT $LN69@CGPShopReq

; 7816 : 					{
; 7817 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Store Reward",

  00814	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00817	50		 push	 eax
  00818	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  0081b	50		 push	 eax
  0081c	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]
  0081f	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00822	03 85 7c ff ff
	ff		 add	 eax, DWORD PTR tv1889[ebp]
  00828	50		 push	 eax
  00829	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0082c	03 85 7c ff ff
	ff		 add	 eax, DWORD PTR tv1889[ebp]
  00832	50		 push	 eax
  00833	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@CGGBJBAH@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00838	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7818 : 							lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 7819 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 17);

  0083e	6a 11		 push	 17			; 00000011H

; 7820 : 						return;

  00840	e9 91 08 00 00	 jmp	 $LN172@CGPShopReq
$LN69@CGPShopReq:

; 7821 : 					}
; 7822 : 				}
; 7823 : 
; 7824 : 				bool bBoundle[3];
; 7825 : 				bBoundle[0] = false;

  00845	66 c7 85 70 ff
	ff ff 00 00	 mov	 WORD PTR _bBoundle$9[ebp], 0

; 7826 : 				bBoundle[1] = false;
; 7827 : 				bBoundle[2] = false;

  0084e	c6 85 72 ff ff
	ff 00		 mov	 BYTE PTR _bBoundle$9[ebp+2], 0

; 7828 : 
; 7829 : 				int JewelCount[3];
; 7830 : 				JewelCount[0] = 0;

  00855	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _JewelCount$13[ebp], 0

; 7831 : 				JewelCount[1] = 0;

  0085c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _JewelCount$13[ebp+4], 0

; 7832 : 				JewelCount[2] = 0;

  00863	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _JewelCount$13[ebp+8], 0

; 7833 : 					
; 7834 : 				invSize = MAIN_INVENTORY_SIZE;

  0086a	ba cc 00 00 00	 mov	 edx, 204		; 000000ccH
  0086f	89 95 68 ff ff
	ff		 mov	 DWORD PTR _invSize$2$[ebp], edx

; 7835 : 				
; 7836 : 				if( lpSourceObj->pInventoryExtend < 4 )	{

  00875	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR tv1889[ebp]
  0087b	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]
  0087e	8a 84 0e cd 11
	00 00		 mov	 al, BYTE PTR [esi+ecx+4557]
  00885	3c 04		 cmp	 al, 4
  00887	73 0f		 jae	 SHORT $LN70@CGPShopReq

; 7837 : 					invSize = (MAIN_INVENTORY_SIZE)-(32*(4-lpSourceObj->pInventoryExtend));

  00889	0f b6 d0	 movzx	 edx, al
  0088c	c1 e2 05	 shl	 edx, 5
  0088f	83 c2 4c	 add	 edx, 76			; 0000004cH
  00892	89 95 68 ff ff
	ff		 mov	 DWORD PTR _invSize$2$[ebp], edx
$LN70@CGPShopReq:

; 7838 : 				}
; 7839 : 
; 7840 : 				for( n = INVENTORY_BAG_START; n < invSize; n++)

  00898	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0089d	c7 85 2c ff ff
	ff 0d 1c 00 00	 mov	 DWORD PTR tv1535[ebp], 7181 ; 00001c0dH
  008a7	c7 85 28 ff ff
	ff 0e 1c 00 00	 mov	 DWORD PTR tv1555[ebp], 7182 ; 00001c0eH
  008b1	c7 85 60 ff ff
	ff 0f 18 00 00	 mov	 DWORD PTR tv1648[ebp], 6159 ; 0000180fH
  008bb	c7 85 5c ff ff
	ff 1e 18 00 00	 mov	 DWORD PTR tv1668[ebp], 6174 ; 0000181eH
  008c5	c7 85 58 ff ff
	ff 1f 18 00 00	 mov	 DWORD PTR tv1672[ebp], 6175 ; 0000181fH
  008cf	c7 85 54 ff ff
	ff 8d 18 00 00	 mov	 DWORD PTR tv1678[ebp], 6285 ; 0000188dH
$LN163@CGPShopReq:
  008d9	89 45 84	 mov	 DWORD PTR _n$10[ebp], eax
  008dc	3b c2		 cmp	 eax, edx
  008de	0f 8d fe 00 00
	00		 jge	 $LN9@CGPShopReq

; 7841 : 				{
; 7842 : 					if( !lpSourceObj->pInventory[n].IsItem() )

  008e4	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  008ea	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv1845[ebp], eax
  008f0	8b 8c 0e c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4544]
  008f7	03 c8		 add	 ecx, eax
  008f9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 7843 : 						continue;

  008fe	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]

; 7841 : 				{
; 7842 : 					if( !lpSourceObj->pInventory[n].IsItem() )

  00901	85 c0		 test	 eax, eax
  00903	0f 84 ca 00 00
	00		 je	 $LN8@CGPShopReq

; 7844 : 
; 7845 : 					if( lpSourceObj->pInventory[n].m_Type == ITEMGET(14,13) )

  00909	8b 84 0e c0 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4544]
  00910	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv1845[ebp]
  00916	0f b7 44 02 06	 movzx	 eax, WORD PTR [edx+eax+6]
  0091b	66 3b 85 2c ff
	ff ff		 cmp	 ax, WORD PTR tv1535[ebp]
  00922	75 08		 jne	 SHORT $LN72@CGPShopReq

; 7846 : 					{
; 7847 : 						JewelCount[0]++;

  00924	ff 45 a8	 inc	 DWORD PTR _JewelCount$13[ebp]
  00927	e9 a7 00 00 00	 jmp	 $LN8@CGPShopReq
$LN72@CGPShopReq:

; 7848 : 					}
; 7849 : 					else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(14,14) )

  0092c	66 3b 85 28 ff
	ff ff		 cmp	 ax, WORD PTR tv1555[ebp]
  00933	75 08		 jne	 SHORT $LN74@CGPShopReq

; 7850 : 					{
; 7851 : 						JewelCount[1]++;

  00935	ff 45 ac	 inc	 DWORD PTR _JewelCount$13[ebp+4]
  00938	e9 96 00 00 00	 jmp	 $LN8@CGPShopReq
$LN74@CGPShopReq:

; 7852 : 					}
; 7853 : 					else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,15) )

  0093d	66 3b 85 60 ff
	ff ff		 cmp	 ax, WORD PTR tv1648[ebp]
  00944	75 08		 jne	 SHORT $LN76@CGPShopReq

; 7854 : 					{
; 7855 : 						JewelCount[2]++;

  00946	ff 45 b0	 inc	 DWORD PTR _JewelCount$13[ebp+8]
  00949	e9 85 00 00 00	 jmp	 $LN8@CGPShopReq
$LN76@CGPShopReq:

; 7856 : 					}
; 7857 : 					else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,30) )

  0094e	66 3b 85 5c ff
	ff ff		 cmp	 ax, WORD PTR tv1668[ebp]
  00955	75 24		 jne	 SHORT $LN78@CGPShopReq

; 7858 : 					{
; 7859 : 						bBoundle[0] = true;

  00957	c6 85 70 ff ff
	ff 01		 mov	 BYTE PTR _bBoundle$9[ebp], 1

; 7860 : 						JewelCount[0] += 10 * (lpSourceObj->pInventory[n].m_Level+1);

  0095e	8b 84 0e c0 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4544]
  00965	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  0096a	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0096d	8b 55 a8	 mov	 edx, DWORD PTR _JewelCount$13[ebp]
  00970	8d 14 42	 lea	 edx, DWORD PTR [edx+eax*2]
  00973	83 c2 0a	 add	 edx, 10			; 0000000aH
  00976	89 55 a8	 mov	 DWORD PTR _JewelCount$13[ebp], edx
  00979	eb 58		 jmp	 SHORT $LN8@CGPShopReq
$LN78@CGPShopReq:

; 7861 : 					}
; 7862 : 					else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,31) )

  0097b	66 3b 85 58 ff
	ff ff		 cmp	 ax, WORD PTR tv1672[ebp]
  00982	75 24		 jne	 SHORT $LN80@CGPShopReq

; 7863 : 					{
; 7864 : 						bBoundle[1] = true;

  00984	c6 85 71 ff ff
	ff 01		 mov	 BYTE PTR _bBoundle$9[ebp+1], 1

; 7865 : 						JewelCount[1] += 10 * (lpSourceObj->pInventory[n].m_Level+1);

  0098b	8b 84 0e c0 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4544]
  00992	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00997	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0099a	8b 55 ac	 mov	 edx, DWORD PTR _JewelCount$13[ebp+4]
  0099d	8d 14 42	 lea	 edx, DWORD PTR [edx+eax*2]
  009a0	83 c2 0a	 add	 edx, 10			; 0000000aH
  009a3	89 55 ac	 mov	 DWORD PTR _JewelCount$13[ebp+4], edx
  009a6	eb 2b		 jmp	 SHORT $LN8@CGPShopReq
$LN80@CGPShopReq:

; 7866 : 					}
; 7867 : 					else if( lpSourceObj->pInventory[n].m_Type == ITEMGET(12,141) )

  009a8	66 3b 85 54 ff
	ff ff		 cmp	 ax, WORD PTR tv1678[ebp]
  009af	75 22		 jne	 SHORT $LN8@CGPShopReq

; 7868 : 					{
; 7869 : 						bBoundle[2] = true;

  009b1	c6 85 72 ff ff
	ff 01		 mov	 BYTE PTR _bBoundle$9[ebp+2], 1

; 7870 : 						JewelCount[2] += 10 * (lpSourceObj->pInventory[n].m_Level+1);

  009b8	8b 84 0e c0 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4544]
  009bf	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  009c4	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  009c7	8b 55 b0	 mov	 edx, DWORD PTR _JewelCount$13[ebp+8]
  009ca	8d 14 42	 lea	 edx, DWORD PTR [edx+eax*2]
  009cd	83 c2 0a	 add	 edx, 10			; 0000000aH
  009d0	89 55 b0	 mov	 DWORD PTR _JewelCount$13[ebp+8], edx
$LN8@CGPShopReq:

; 7838 : 				}
; 7839 : 
; 7840 : 				for( n = INVENTORY_BAG_START; n < invSize; n++)

  009d3	8b 45 84	 mov	 eax, DWORD PTR _n$10[ebp]
  009d6	40		 inc	 eax
  009d7	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _invSize$2$[ebp]
  009dd	e9 f7 fe ff ff	 jmp	 $LN163@CGPShopReq
$LN9@CGPShopReq:

; 7871 : 					}
; 7872 : 				}
; 7873 : 
; 7874 : 				for( n = 0; n < 3; n++)

  009e2	33 c0		 xor	 eax, eax
$LN164@CGPShopReq:
  009e4	89 45 84	 mov	 DWORD PTR _n$10[ebp], eax
  009e7	89 85 74 ff ff
	ff		 mov	 DWORD PTR _n$3$[ebp], eax
  009ed	83 f8 03	 cmp	 eax, 3
  009f0	0f 8d 9c 00 00
	00		 jge	 $LN12@CGPShopReq

; 7875 : 				{
; 7876 : 					if( JewelCount[n] < aPShopJewelValue[n] )

  009f6	0f bf 54 45 dc	 movsx	 edx, WORD PTR _aPShopJewelValue$16[ebp+eax*2]
  009fb	39 54 85 a8	 cmp	 DWORD PTR _JewelCount$13[ebp+eax*4], edx
  009ff	7d 51		 jge	 SHORT $LN83@CGPShopReq

; 7877 : 					{
; 7878 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No enough Jewels - Type: %d",

  00a01	50		 push	 eax
  00a02	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00a05	50		 push	 eax
  00a06	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00a09	50		 push	 eax
  00a0a	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00a0d	03 c1		 add	 eax, ecx
  00a0f	50		 push	 eax
  00a10	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00a13	03 c1		 add	 eax, ecx
  00a15	50		 push	 eax
  00a16	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@GNOMFPND@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00a1b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7879 : 						lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name, n);
; 7880 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 11+n);

  00a21	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _n$3$[ebp]
  00a27	04 0b		 add	 al, 11			; 0000000bH
$LN174@CGPShopReq:
  00a29	0f b6 c0	 movzx	 eax, al
  00a2c	50		 push	 eax
  00a2d	6a 00		 push	 0
  00a2f	ff 37		 push	 DWORD PTR [edi]
  00a31	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00a34	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7881 : 						return;

  00a39	6a fe		 push	 -2			; fffffffeH
  00a3b	9b		 fwait
  00a3c	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00a3f	50		 push	 eax
  00a40	68 00 00 00 00	 push	 OFFSET ___security_cookie
  00a45	e8 00 00 00 00	 call	 __local_unwind4
  00a4a	83 c4 34	 add	 esp, 52			; 00000034H
  00a4d	e9 08 07 00 00	 jmp	 $LN121@CGPShopReq
$LN83@CGPShopReq:

; 7882 : 					}
; 7883 : 					else if( bBoundle[n] && JewelCount[n] > aPShopJewelValue[n] )

  00a52	80 bc 05 70 ff
	ff ff 00	 cmp	 BYTE PTR _bBoundle$9[ebp+eax], 0
  00a5a	74 30		 je	 SHORT $LN85@CGPShopReq
  00a5c	39 54 85 a8	 cmp	 DWORD PTR _JewelCount$13[ebp+eax*4], edx
  00a60	7e 2a		 jle	 SHORT $LN85@CGPShopReq

; 7884 : 					{
; 7885 : 						LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Boundle Jewels - Type: %d",

  00a62	50		 push	 eax
  00a63	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00a66	50		 push	 eax
  00a67	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00a6a	50		 push	 eax
  00a6b	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00a6e	03 c1		 add	 eax, ecx
  00a70	50		 push	 eax
  00a71	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00a74	03 c1		 add	 eax, ecx
  00a76	50		 push	 eax
  00a77	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@GCLCNLCC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00a7c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7886 : 						lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name, n);
; 7887 : 						::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 14+n);

  00a82	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _n$3$[ebp]
  00a88	04 0e		 add	 al, 14			; 0000000eH

; 7888 : 						return;

  00a8a	eb 9d		 jmp	 SHORT $LN174@CGPShopReq
$LN85@CGPShopReq:

; 7871 : 					}
; 7872 : 				}
; 7873 : 
; 7874 : 				for( n = 0; n < 3; n++)

  00a8c	40		 inc	 eax
  00a8d	e9 52 ff ff ff	 jmp	 $LN164@CGPShopReq
$LN12@CGPShopReq:

; 7889 : 					}
; 7890 : 				}
; 7891 : 				
; 7892 : 				BYTE btNewItemPos = 0;
; 7893 : 				btNewItemPos = ::gObjOnlyInventoryInsertItem(aSourceIndex, lpObj->Inventory1[lpMsg->btItemPos]);

  00a92	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00a95	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00a99	69 f0 d4 00 00
	00		 imul	 esi, eax, 212
  00a9f	03 b7 d0 11 00
	00		 add	 esi, DWORD PTR [edi+4560]
  00aa5	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00aab	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00ab0	8b fc		 mov	 edi, esp
  00ab2	f3 a5		 rep movsd
  00ab4	8b 7d 8c	 mov	 edi, DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00ab7	57		 push	 edi
  00ab8	e8 00 00 00 00	 call	 ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjOnlyInventoryInsertItem
  00abd	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00ac3	8a d0		 mov	 dl, al
  00ac5	88 95 6f ff ff
	ff		 mov	 BYTE PTR _btNewItemPos$1$[ebp], dl

; 7896 : 				{
; 7897 : 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Buy Item",

  00acb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 7894 : 
; 7895 : 				if ( btNewItemPos == 0xFF )

  00ad1	80 fa ff	 cmp	 dl, 255			; 000000ffH
  00ad4	75 37		 jne	 SHORT $LN86@CGPShopReq

; 7896 : 				{
; 7897 : 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] No Room to Buy Item",

  00ad6	69 d7 40 27 00
	00		 imul	 edx, edi, 10048
  00adc	8b b5 78 ff ff
	ff		 mov	 esi, DWORD PTR _lpObj$1$[ebp]
  00ae2	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00ae5	50		 push	 eax
  00ae6	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00ae9	50		 push	 eax
  00aea	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00aed	03 c2		 add	 eax, edx
  00aef	50		 push	 eax
  00af0	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00af3	03 c2		 add	 eax, edx
  00af5	50		 push	 eax
  00af6	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@NGLHGNOL@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00afb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7898 : 						gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 7899 : 						lpObj->AccountID, lpObj->Name);
; 7900 : 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 8);

  00b01	6a 08		 push	 8
  00b03	6a 00		 push	 0
  00b05	ff 36		 push	 DWORD PTR [esi]
  00b07	57		 push	 edi

; 7901 : 
; 7902 : 					return;

  00b08	e9 d0 05 00 00	 jmp	 $LN173@CGPShopReq
$LN86@CGPShopReq:

; 7903 : 				}
; 7904 : 				
; 7905 : 				g_ElementalSystem.PShopErtel(lpObj,&gObj[aSourceIndex],&gObj[aSourceIndex].pInventory[btNewItemPos]);

  00b0d	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00b13	03 ce		 add	 ecx, esi
  00b15	0f b6 c2	 movzx	 eax, dl
  00b18	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  00b1e	03 81 c0 11 00
	00		 add	 eax, DWORD PTR [ecx+4544]
  00b24	50		 push	 eax
  00b25	51		 push	 ecx
  00b26	8b bd 78 ff ff
	ff		 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  00b2c	57		 push	 edi
  00b2d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00b32	e8 00 00 00 00	 call	 ?PShopErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@0PAVCItem@@@Z ; CElementalSystem::PShopErtel

; 7906 : 				
; 7907 : 				iITEM_LOG_TYPE = lpObj->Inventory1[lpMsg->btItemPos].m_Type;

  00b37	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00b3a	0f b6 50 10	 movzx	 edx, BYTE PTR [eax+16]
  00b3e	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  00b44	8b 87 d0 11 00
	00		 mov	 eax, DWORD PTR [edi+4560]
  00b4a	0f bf 7c 01 06	 movsx	 edi, WORD PTR [ecx+eax+6]
  00b4f	89 bd 60 ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_TYPE$1$[ebp], edi

; 7908 : 				iITEM_LOG_LEVEL = lpObj->Inventory1[lpMsg->btItemPos].m_Level;

  00b55	0f bf 7c 01 08	 movsx	 edi, WORD PTR [ecx+eax+8]
  00b5a	89 bd 5c ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_LEVEL$1$[ebp], edi

; 7909 : 				iITEM_LOG_DUR = (int)lpObj->Inventory1[lpMsg->btItemPos].m_Durability;

  00b60	f3 0f 2c 7c 01
	24		 cvttss2si edi, DWORD PTR [ecx+eax+36]
  00b66	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_DUR$1$[ebp], edi

; 7910 : 				iITEM_LOG_SERIAL = lpObj->Inventory1[lpMsg->btItemPos].m_Number;

  00b6c	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00b6f	89 85 54 ff ff
	ff		 mov	 DWORD PTR _iITEM_LOG_SERIAL$1$[ebp], eax

; 7911 : 				::gObjInventoryItemSet_PShop(lpObj->m_Index, lpMsg->btItemPos, -1);

  00b75	68 ff 00 00 00	 push	 255			; 000000ffH
  00b7a	52		 push	 edx
  00b7b	8b bd 78 ff ff
	ff		 mov	 edi, DWORD PTR _lpObj$1$[ebp]
  00b81	ff 37		 push	 DWORD PTR [edi]
  00b83	e8 00 00 00 00	 call	 ?gObjInventoryItemSet_PShop@@YAXHHE@Z ; gObjInventoryItemSet_PShop
  00b88	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7912 : 				lpObj->Inventory1[lpMsg->btItemPos].Clear();

  00b8b	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00b8e	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00b92	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00b98	03 8f d0 11 00
	00		 add	 ecx, DWORD PTR [edi+4560]
  00b9e	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 7913 : 				::GCInventoryItemDeleteSend(lpObj->m_Index, lpMsg->btItemPos, TRUE);

  00ba3	6a 01		 push	 1
  00ba5	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00ba8	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00bac	50		 push	 eax
  00bad	ff 37		 push	 DWORD PTR [edi]
  00baf	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00bb4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7914 : 
; 7915 : 				if( iPShopValue > 0 )

  00bb7	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _iPShopValue$1$[ebp]
  00bbd	85 c9		 test	 ecx, ecx
  00bbf	7e 3c		 jle	 SHORT $LN158@CGPShopReq

; 7916 : 				{
; 7917 : 					gObj[aSourceIndex].Money -= iPShopValue;

  00bc1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00bc6	29 8c 06 cc 00
	00 00		 sub	 DWORD PTR [esi+eax+204], ecx

; 7918 : 					lpObj->Money += iPShopValue;

  00bcd	01 8f cc 00 00
	00		 add	 DWORD PTR [edi+204], ecx

; 7919 : 					::GCMoneySend(aSourceIndex, lpSourceObj->Money);

  00bd3	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR tv1889[ebp]
  00bd9	8b 45 88	 mov	 eax, DWORD PTR tv692[ebp]
  00bdc	ff b4 06 cc 00
	00 00		 push	 DWORD PTR [esi+eax+204]
  00be3	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00be6	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 7920 : 					::GCMoneySend(lpObj->m_Index, lpObj->Money);

  00beb	ff b7 cc 00 00
	00		 push	 DWORD PTR [edi+204]
  00bf1	ff 37		 push	 DWORD PTR [edi]
  00bf3	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00bf8	83 c4 10	 add	 esp, 16			; 00000010H
  00bfb	eb 06		 jmp	 SHORT $LN87@CGPShopReq
$LN158@CGPShopReq:
  00bfd	8b b5 7c ff ff
	ff		 mov	 esi, DWORD PTR tv1889[ebp]
$LN87@CGPShopReq:

; 7921 : 				}
; 7922 : 
; 7923 : 				JewelCount[0] = 0;

  00c03	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR _JewelCount$13[ebp], 0

; 7924 : 				JewelCount[1] = 0;

  00c0a	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _JewelCount$13[ebp+4], 0

; 7925 : 				JewelCount[2] = 0;

  00c11	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _JewelCount$13[ebp+8], 0

; 7926 : 
; 7927 : 				for ( n = INVETORY_WEAR_SIZE ; n< invSize; n++)

  00c18	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
$LN165@CGPShopReq:
  00c1d	89 45 84	 mov	 DWORD PTR _n$10[ebp], eax
  00c20	3b 85 68 ff ff
	ff		 cmp	 eax, DWORD PTR _invSize$2$[ebp]
  00c26	0f 8d dc 01 00
	00		 jge	 $LN15@CGPShopReq

; 7928 : 				{
; 7929 : 					if ( !lpSourceObj->pInventory[n].IsItem() )

  00c2c	69 d0 d4 00 00
	00		 imul	 edx, eax, 212
  00c32	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv1844[ebp], edx
  00c38	8b 45 88	 mov	 eax, DWORD PTR tv692[ebp]
  00c3b	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  00c42	03 ca		 add	 ecx, edx
  00c44	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00c49	85 c0		 test	 eax, eax
  00c4b	0f 84 ae 01 00
	00		 je	 $LN14@CGPShopReq

; 7930 : 						continue;
; 7931 : 
; 7932 : 					int JewelType = lpSourceObj->pInventory[n].m_Type;

  00c51	8b 45 88	 mov	 eax, DWORD PTR tv692[ebp]
  00c54	8b 84 06 c0 11
	00 00		 mov	 eax, DWORD PTR [esi+eax+4544]
  00c5b	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv1844[ebp]
  00c61	0f bf 4c 02 06	 movsx	 ecx, WORD PTR [edx+eax+6]
  00c66	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _JewelType$1$[ebp], ecx

; 7933 : 					int JewelLevel = lpSourceObj->pInventory[n].m_Level;

  00c6c	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00c71	89 85 78 ff ff
	ff		 mov	 DWORD PTR _JewelLevel$1$[ebp], eax

; 7934 : 
; 7935 : 					switch(JewelType)

  00c77	81 f9 8d 18 00
	00		 cmp	 ecx, 6285		; 0000188dH
  00c7d	0f 8f 93 00 00
	00		 jg	 $LN116@CGPShopReq
  00c83	74 1f		 je	 SHORT $LN93@CGPShopReq
  00c85	81 e9 0f 18 00
	00		 sub	 ecx, 6159		; 0000180fH
  00c8b	74 17		 je	 SHORT $LN93@CGPShopReq
  00c8d	83 e9 0f	 sub	 ecx, 15			; 0000000fH
  00c90	0f 84 00 01 00
	00		 je	 $LN89@CGPShopReq
  00c96	83 e9 01	 sub	 ecx, 1
  00c99	0f 84 88 00 00
	00		 je	 $LN91@CGPShopReq
  00c9f	e9 5b 01 00 00	 jmp	 $LN14@CGPShopReq
$LN93@CGPShopReq:

; 7957 : 					case ITEMGET(12,15):
; 7958 : 					case ITEMGET(12,141):
; 7959 : 						if( JewelCount[2] < aPShopJewelValue[2] )

  00ca4	66 8b 85 66 ff
	ff ff		 mov	 ax, WORD PTR _aPShopJewelValue$3$[ebp]
  00cab	98		 cwde
  00cac	39 45 b0	 cmp	 DWORD PTR _JewelCount$13[ebp+8], eax
  00caf	0f 8d 4a 01 00
	00		 jge	 $LN14@CGPShopReq

; 7960 : 						{
; 7961 : 							gObjInventoryItemSet(aSourceIndex, n, (BYTE)-1);

  00cb5	68 ff 00 00 00	 push	 255			; 000000ffH
  00cba	ff 75 84	 push	 DWORD PTR _n$10[ebp]
  00cbd	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00cc0	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00cc5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7962 : 							lpSourceObj->pInventory[n].Clear();

  00cc8	8b 45 88	 mov	 eax, DWORD PTR tv692[ebp]
  00ccb	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  00cd2	03 8d 7c ff ff
	ff		 add	 ecx, DWORD PTR tv1844[ebp]
  00cd8	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 7963 : 							GCInventoryItemDeleteSend(aSourceIndex, n, TRUE);

  00cdd	6a 01		 push	 1
  00cdf	ff 75 84	 push	 DWORD PTR _n$10[ebp]
  00ce2	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00ce5	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00cea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7964 : 							JewelCount[2] += (JewelType == ITEMGET(12,15) ) ? 1 : ((JewelLevel+1)*10);

  00ced	81 bd 74 ff ff
	ff 0f 18 00 00	 cmp	 DWORD PTR _JewelType$1$[ebp], 6159 ; 0000180fH
  00cf7	75 07		 jne	 SHORT $LN114@CGPShopReq
  00cf9	b8 01 00 00 00	 mov	 eax, 1
  00cfe	eb 0e		 jmp	 SHORT $LN115@CGPShopReq
$LN114@CGPShopReq:
  00d00	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _JewelLevel$1$[ebp]
  00d06	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00d09	83 c0 05	 add	 eax, 5
  00d0c	03 c0		 add	 eax, eax
$LN115@CGPShopReq:
  00d0e	01 45 b0	 add	 DWORD PTR _JewelCount$13[ebp+8], eax
  00d11	e9 e9 00 00 00	 jmp	 $LN14@CGPShopReq
$LN116@CGPShopReq:

; 7934 : 
; 7935 : 					switch(JewelType)

  00d16	81 e9 0d 1c 00
	00		 sub	 ecx, 7181		; 00001c0dH
  00d1c	74 78		 je	 SHORT $LN89@CGPShopReq
  00d1e	83 e9 01	 sub	 ecx, 1
  00d21	0f 85 d8 00 00
	00		 jne	 $LN14@CGPShopReq
$LN91@CGPShopReq:

; 7945 : 						}
; 7946 : 						break;
; 7947 : 					case ITEMGET(14,14):
; 7948 : 					case ITEMGET(12,31):
; 7949 : 						if( JewelCount[1] < aPShopJewelValue[1] )

  00d27	66 8b 85 6c ff
	ff ff		 mov	 ax, WORD PTR _aPShopJewelValue$2$[ebp]
  00d2e	98		 cwde
  00d2f	39 45 ac	 cmp	 DWORD PTR _JewelCount$13[ebp+4], eax
  00d32	0f 8d c7 00 00
	00		 jge	 $LN14@CGPShopReq

; 7950 : 						{
; 7951 : 							gObjInventoryItemSet(aSourceIndex, n, (BYTE)-1);

  00d38	68 ff 00 00 00	 push	 255			; 000000ffH
  00d3d	ff 75 84	 push	 DWORD PTR _n$10[ebp]
  00d40	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00d43	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00d48	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7952 : 							lpSourceObj->pInventory[n].Clear();

  00d4b	8b 45 88	 mov	 eax, DWORD PTR tv692[ebp]
  00d4e	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  00d55	03 8d 7c ff ff
	ff		 add	 ecx, DWORD PTR tv1844[ebp]
  00d5b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 7953 : 							GCInventoryItemDeleteSend(aSourceIndex, n, TRUE);

  00d60	6a 01		 push	 1
  00d62	ff 75 84	 push	 DWORD PTR _n$10[ebp]
  00d65	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00d68	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00d6d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7954 : 							JewelCount[1] += (JewelType == ITEMGET(14,14) ) ? 1 : ((JewelLevel+1)*10);

  00d70	81 bd 74 ff ff
	ff 0e 1c 00 00	 cmp	 DWORD PTR _JewelType$1$[ebp], 7182 ; 00001c0eH
  00d7a	75 07		 jne	 SHORT $LN112@CGPShopReq
  00d7c	b8 01 00 00 00	 mov	 eax, 1
  00d81	eb 0e		 jmp	 SHORT $LN113@CGPShopReq
$LN112@CGPShopReq:
  00d83	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _JewelLevel$1$[ebp]
  00d89	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00d8c	83 c0 05	 add	 eax, 5
  00d8f	03 c0		 add	 eax, eax
$LN113@CGPShopReq:
  00d91	01 45 ac	 add	 DWORD PTR _JewelCount$13[ebp+4], eax

; 7955 : 						}
; 7956 : 						break;

  00d94	eb 69		 jmp	 SHORT $LN14@CGPShopReq
$LN89@CGPShopReq:

; 7936 : 					{
; 7937 : 					case ITEMGET(14,13):
; 7938 : 					case ITEMGET(12,30):
; 7939 : 						if( JewelCount[0] < aPShopJewelValue[0] )

  00d96	66 8b 85 4a ff
	ff ff		 mov	 ax, WORD PTR _aPShopJewelValue$1$[ebp]
  00d9d	98		 cwde
  00d9e	39 45 a8	 cmp	 DWORD PTR _JewelCount$13[ebp], eax
  00da1	7d 5c		 jge	 SHORT $LN14@CGPShopReq

; 7940 : 						{
; 7941 : 							gObjInventoryItemSet(aSourceIndex, n, (BYTE)-1);

  00da3	68 ff 00 00 00	 push	 255			; 000000ffH
  00da8	ff 75 84	 push	 DWORD PTR _n$10[ebp]
  00dab	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00dae	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00db3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7942 : 							lpSourceObj->pInventory[n].Clear();

  00db6	8b 45 88	 mov	 eax, DWORD PTR tv692[ebp]
  00db9	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  00dc0	03 8d 7c ff ff
	ff		 add	 ecx, DWORD PTR tv1844[ebp]
  00dc6	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 7943 : 							GCInventoryItemDeleteSend(aSourceIndex, n, TRUE);

  00dcb	6a 01		 push	 1
  00dcd	ff 75 84	 push	 DWORD PTR _n$10[ebp]
  00dd0	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00dd3	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00dd8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7944 : 							JewelCount[0] += (JewelType == ITEMGET(14,13) ) ? 1 : ((JewelLevel+1)*10);

  00ddb	81 bd 74 ff ff
	ff 0d 1c 00 00	 cmp	 DWORD PTR _JewelType$1$[ebp], 7181 ; 00001c0dH
  00de5	75 07		 jne	 SHORT $LN110@CGPShopReq
  00de7	b8 01 00 00 00	 mov	 eax, 1
  00dec	eb 0e		 jmp	 SHORT $LN111@CGPShopReq
$LN110@CGPShopReq:
  00dee	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _JewelLevel$1$[ebp]
  00df4	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00df7	83 c0 05	 add	 eax, 5
  00dfa	03 c0		 add	 eax, eax
$LN111@CGPShopReq:
  00dfc	01 45 a8	 add	 DWORD PTR _JewelCount$13[ebp], eax
$LN14@CGPShopReq:

; 7926 : 
; 7927 : 				for ( n = INVETORY_WEAR_SIZE ; n< invSize; n++)

  00dff	8b 45 84	 mov	 eax, DWORD PTR _n$10[ebp]
  00e02	40		 inc	 eax
  00e03	e9 15 fe ff ff	 jmp	 $LN165@CGPShopReq
$LN15@CGPShopReq:

; 7965 : 						}
; 7966 : 						break;
; 7967 : 					}
; 7968 : 				}
; 7969 : 
; 7970 : 
; 7971 : 				int iBoundleId[3] = {ITEMGET(12,30), ITEMGET(12,31), ITEMGET(12,141)};

  00e08	c7 45 9c 1e 18
	00 00		 mov	 DWORD PTR _iBoundleId$12[ebp], 6174 ; 0000181eH
  00e0f	c7 45 a0 1f 18
	00 00		 mov	 DWORD PTR _iBoundleId$12[ebp+4], 6175 ; 0000181fH
  00e16	c7 45 a4 8d 18
	00 00		 mov	 DWORD PTR _iBoundleId$12[ebp+8], 6285 ; 0000188dH

; 7972 : 				int iJewelId[3] = {ITEMGET(14,13), ITEMGET(14,14), ITEMGET(12,15)};

  00e1d	c7 45 90 0d 1c
	00 00		 mov	 DWORD PTR _iJewelId$11[ebp], 7181 ; 00001c0dH
  00e24	c7 45 94 0e 1c
	00 00		 mov	 DWORD PTR _iJewelId$11[ebp+4], 7182 ; 00001c0eH
  00e2b	c7 45 98 0f 18
	00 00		 mov	 DWORD PTR _iJewelId$11[ebp+8], 6159 ; 0000180fH

; 7973 : 
; 7974 : 				for( n = 0; n < 3; n++ )

  00e32	33 f6		 xor	 esi, esi
$LN170@CGPShopReq:
  00e34	89 75 84	 mov	 DWORD PTR _n$10[ebp], esi
  00e37	83 fe 03	 cmp	 esi, 3
  00e3a	0f 8d 47 01 00
	00		 jge	 $LN20@CGPShopReq

; 7975 : 				{
; 7976 : 					if( aPShopJewelValue[n] > 0 )

  00e40	66 83 7c 75 dc
	00		 cmp	 WORD PTR _aPShopJewelValue$16[ebp+esi*2], 0
  00e46	0f 8e 35 01 00
	00		 jle	 $LN32@CGPShopReq

; 7977 : 					{
; 7978 : 						for(int x = 0; x < aPShopJewelBoundle[n][0]; x++)

  00e4c	33 c9		 xor	 ecx, ecx
$LN166@CGPShopReq:
  00e4e	89 8d 3c ff ff
	ff		 mov	 DWORD PTR _x$5[ebp], ecx
  00e54	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00e57	0f bf 44 45 bc	 movsx	 eax, WORD PTR _aPShopJewelBoundle$15[ebp+eax*2]
  00e5c	3b c8		 cmp	 ecx, eax
  00e5e	7d 3a		 jge	 SHORT $LN23@CGPShopReq

; 7979 : 						{	
; 7980 : 							ItemSerialCreateSend(lpObj->m_Index,235,0,0,iBoundleId[n],2,1,0,0,0,lpObj->m_Index,0,0,0,0);							

  00e60	8b 07		 mov	 eax, DWORD PTR [edi]
  00e62	6a 00		 push	 0
  00e64	6a 00		 push	 0
  00e66	6a 00		 push	 0
  00e68	6a 00		 push	 0
  00e6a	50		 push	 eax
  00e6b	6a 00		 push	 0
  00e6d	6a 00		 push	 0
  00e6f	6a 00		 push	 0
  00e71	6a 01		 push	 1
  00e73	6a 02		 push	 2
  00e75	ff 74 b5 9c	 push	 DWORD PTR _iBoundleId$12[ebp+esi*4]
  00e79	6a 00		 push	 0
  00e7b	6a 00		 push	 0
  00e7d	68 eb 00 00 00	 push	 235			; 000000ebH
  00e82	50		 push	 eax
  00e83	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00e88	83 c4 3c	 add	 esp, 60			; 0000003cH

; 7981 : #if (ENABLE_CUSTOM_OFFLINETRADE == 1)
; 7982 : 							lpObj->OffTradeWaitItem++;

  00e8b	fe 87 30 27 00
	00		 inc	 BYTE PTR [edi+10032]

; 7977 : 					{
; 7978 : 						for(int x = 0; x < aPShopJewelBoundle[n][0]; x++)

  00e91	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _x$5[ebp]
  00e97	41		 inc	 ecx
  00e98	eb b4		 jmp	 SHORT $LN166@CGPShopReq
$LN23@CGPShopReq:

; 7983 : #endif
; 7984 : 						}
; 7985 : 
; 7986 : 						for(int x = 0; x < aPShopJewelBoundle[n][1]; x++)

  00e9a	33 c9		 xor	 ecx, ecx
$LN167@CGPShopReq:
  00e9c	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _x$6[ebp], ecx
  00ea2	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00ea5	0f bf 44 45 be	 movsx	 eax, WORD PTR _aPShopJewelBoundle$15[ebp+eax*2+2]
  00eaa	3b c8		 cmp	 ecx, eax
  00eac	7d 3a		 jge	 SHORT $LN26@CGPShopReq

; 7987 : 						{	
; 7988 : 							ItemSerialCreateSend(lpObj->m_Index,235,0,0,iBoundleId[n],1,1,0,0,0,lpObj->m_Index,0,0,0,0);

  00eae	8b 07		 mov	 eax, DWORD PTR [edi]
  00eb0	6a 00		 push	 0
  00eb2	6a 00		 push	 0
  00eb4	6a 00		 push	 0
  00eb6	6a 00		 push	 0
  00eb8	50		 push	 eax
  00eb9	6a 00		 push	 0
  00ebb	6a 00		 push	 0
  00ebd	6a 00		 push	 0
  00ebf	6a 01		 push	 1
  00ec1	6a 01		 push	 1
  00ec3	ff 74 b5 9c	 push	 DWORD PTR _iBoundleId$12[ebp+esi*4]
  00ec7	6a 00		 push	 0
  00ec9	6a 00		 push	 0
  00ecb	68 eb 00 00 00	 push	 235			; 000000ebH
  00ed0	50		 push	 eax
  00ed1	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00ed6	83 c4 3c	 add	 esp, 60			; 0000003cH

; 7989 : #if (ENABLE_CUSTOM_OFFLINETRADE == 1)
; 7990 : 							lpObj->OffTradeWaitItem++;

  00ed9	fe 87 30 27 00
	00		 inc	 BYTE PTR [edi+10032]

; 7983 : #endif
; 7984 : 						}
; 7985 : 
; 7986 : 						for(int x = 0; x < aPShopJewelBoundle[n][1]; x++)

  00edf	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _x$6[ebp]
  00ee5	41		 inc	 ecx
  00ee6	eb b4		 jmp	 SHORT $LN167@CGPShopReq
$LN26@CGPShopReq:

; 7991 : #endif
; 7992 : 						}
; 7993 : 
; 7994 : 						for(int x = 0; x < aPShopJewelBoundle[n][2]; x++)

  00ee8	33 c9		 xor	 ecx, ecx
$LN168@CGPShopReq:
  00eea	89 8d 38 ff ff
	ff		 mov	 DWORD PTR _x$4[ebp], ecx
  00ef0	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00ef3	0f bf 44 45 c0	 movsx	 eax, WORD PTR _aPShopJewelBoundle$15[ebp+eax*2+4]
  00ef8	3b c8		 cmp	 ecx, eax
  00efa	7d 3a		 jge	 SHORT $LN29@CGPShopReq

; 7995 : 						{	
; 7996 : 							ItemSerialCreateSend(lpObj->m_Index,235,0,0,iBoundleId[n],0,1,0,0,0,lpObj->m_Index,0,0,0,0);

  00efc	8b 07		 mov	 eax, DWORD PTR [edi]
  00efe	6a 00		 push	 0
  00f00	6a 00		 push	 0
  00f02	6a 00		 push	 0
  00f04	6a 00		 push	 0
  00f06	50		 push	 eax
  00f07	6a 00		 push	 0
  00f09	6a 00		 push	 0
  00f0b	6a 00		 push	 0
  00f0d	6a 01		 push	 1
  00f0f	6a 00		 push	 0
  00f11	ff 74 b5 9c	 push	 DWORD PTR _iBoundleId$12[ebp+esi*4]
  00f15	6a 00		 push	 0
  00f17	6a 00		 push	 0
  00f19	68 eb 00 00 00	 push	 235			; 000000ebH
  00f1e	50		 push	 eax
  00f1f	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00f24	83 c4 3c	 add	 esp, 60			; 0000003cH

; 7997 : #if (ENABLE_CUSTOM_OFFLINETRADE == 1)
; 7998 : 							lpObj->OffTradeWaitItem++;

  00f27	fe 87 30 27 00
	00		 inc	 BYTE PTR [edi+10032]

; 7991 : #endif
; 7992 : 						}
; 7993 : 
; 7994 : 						for(int x = 0; x < aPShopJewelBoundle[n][2]; x++)

  00f2d	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _x$4[ebp]
  00f33	41		 inc	 ecx
  00f34	eb b4		 jmp	 SHORT $LN168@CGPShopReq
$LN29@CGPShopReq:

; 7999 : #endif
; 8000 : 						}
; 8001 : 
; 8002 : 						for(int x = 0; x < aPShopJewel[n]; x++)

  00f36	33 c9		 xor	 ecx, ecx
$LN169@CGPShopReq:
  00f38	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _x$7[ebp], ecx
  00f3e	0f bf 44 75 b4	 movsx	 eax, WORD PTR _aPShopJewel$14[ebp+esi*2]
  00f43	3b c8		 cmp	 ecx, eax
  00f45	7d 3a		 jge	 SHORT $LN32@CGPShopReq

; 8003 : 						{	
; 8004 : 							ItemSerialCreateSend(lpObj->m_Index,235,0,0,iJewelId[n],0,1,0,0,0,lpObj->m_Index,0,0,0,0);

  00f47	8b 07		 mov	 eax, DWORD PTR [edi]
  00f49	6a 00		 push	 0
  00f4b	6a 00		 push	 0
  00f4d	6a 00		 push	 0
  00f4f	6a 00		 push	 0
  00f51	50		 push	 eax
  00f52	6a 00		 push	 0
  00f54	6a 00		 push	 0
  00f56	6a 00		 push	 0
  00f58	6a 01		 push	 1
  00f5a	6a 00		 push	 0
  00f5c	ff 74 b5 90	 push	 DWORD PTR _iJewelId$11[ebp+esi*4]
  00f60	6a 00		 push	 0
  00f62	6a 00		 push	 0
  00f64	68 eb 00 00 00	 push	 235			; 000000ebH
  00f69	50		 push	 eax
  00f6a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend
  00f6f	83 c4 3c	 add	 esp, 60			; 0000003cH

; 8005 : #if (ENABLE_CUSTOM_OFFLINETRADE == 1)
; 8006 : 							lpObj->OffTradeWaitItem++;

  00f72	fe 87 30 27 00
	00		 inc	 BYTE PTR [edi+10032]

; 7999 : #endif
; 8000 : 						}
; 8001 : 
; 8002 : 						for(int x = 0; x < aPShopJewel[n]; x++)

  00f78	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _x$7[ebp]
  00f7e	41		 inc	 ecx
  00f7f	eb b7		 jmp	 SHORT $LN169@CGPShopReq
$LN32@CGPShopReq:

; 7973 : 
; 7974 : 				for( n = 0; n < 3; n++ )

  00f81	46		 inc	 esi
  00f82	e9 ad fe ff ff	 jmp	 $LN170@CGPShopReq
$LN20@CGPShopReq:

; 8007 : #endif
; 8008 : 						}
; 8009 : 					}
; 8010 : 				}
; 8011 : 
; 8012 : 				::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, btNewItemPos, 1);

  00f87	6a 01		 push	 1
  00f89	0f b6 85 6f ff
	ff ff		 movzx	 eax, BYTE PTR _btNewItemPos$1$[ebp]
  00f90	50		 push	 eax
  00f91	ff 37		 push	 DWORD PTR [edi]
  00f93	8b 75 8c	 mov	 esi, DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  00f96	56		 push	 esi
  00f97	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 8013 : 				::CGPShopAnsSoldItem(lpObj->m_Index, aSourceIndex, lpMsg->btItemPos);

  00f9c	8b 45 80	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00f9f	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00fa3	50		 push	 eax
  00fa4	56		 push	 esi
  00fa5	ff 37		 push	 DWORD PTR [edi]
  00fa7	e8 00 00 00 00	 call	 ?CGPShopAnsSoldItem@@YAXHHH@Z ; CGPShopAnsSoldItem

; 8014 : 
; 8015 : 				LogAddTD("[PShop] [%s][%s][%s] PShop Item Buy Request Succeed : [%s][%s][%s] (Price=%d, ItemType:%d (%s), ItemLevel:%d, ItemDur:%d, Serial:%d",

  00fac	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  00fb2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fb8	ff b5 54 ff ff
	ff		 push	 DWORD PTR _iITEM_LOG_SERIAL$1$[ebp]
  00fbe	ff b5 58 ff ff
	ff		 push	 DWORD PTR _iITEM_LOG_DUR$1$[ebp]
  00fc4	ff b5 5c ff ff
	ff		 push	 DWORD PTR _iITEM_LOG_LEVEL$1$[ebp]
  00fca	8b b5 60 ff ff
	ff		 mov	 esi, DWORD PTR _iITEM_LOG_TYPE$1$[ebp]
  00fd0	6b c6 70	 imul	 eax, esi, 112
  00fd3	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00fd8	50		 push	 eax
  00fd9	56		 push	 esi
  00fda	8b b5 50 ff ff
	ff		 mov	 esi, DWORD PTR _iPShopValue$1$[ebp]
  00fe0	56		 push	 esi
  00fe1	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  00fe4	50		 push	 eax
  00fe5	8d 77 5d	 lea	 esi, DWORD PTR [edi+93]
  00fe8	56		 push	 esi
  00fe9	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00fec	50		 push	 eax
  00fed	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00ff0	03 c2		 add	 eax, edx
  00ff2	50		 push	 eax
  00ff3	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00ff6	03 c2		 add	 eax, edx
  00ff8	50		 push	 eax
  00ff9	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00ffc	03 c2		 add	 eax, edx
  00ffe	50		 push	 eax
  00fff	68 00 00 00 00	 push	 OFFSET ??_C@_0IE@NPCEKOLA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5@
  01004	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0100a	83 c4 50	 add	 esp, 80			; 00000050H

; 8016 : 					gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, gObj[aSourceIndex].Ip_addr,
; 8017 : 					lpObj->AccountID, lpObj->Name, lpObj->Ip_addr, iPShopValue, iITEM_LOG_TYPE,
; 8018 : 					ItemAttribute[iITEM_LOG_TYPE].Name, iITEM_LOG_LEVEL, iITEM_LOG_DUR, iITEM_LOG_SERIAL);
; 8019 : 
; 8020 : 				if (PShop_CheckInventoryEmpty(lpObj->m_Index) == true )

  0100d	0f b7 07	 movzx	 eax, WORD PTR [edi]
  01010	50		 push	 eax
  01011	e8 00 00 00 00	 call	 ?PShop_CheckInventoryEmpty@@YA_NF@Z ; PShop_CheckInventoryEmpty
  01016	83 c4 04	 add	 esp, 4
  01019	3c 01		 cmp	 al, 1
  0101b	0f 85 88 00 00
	00		 jne	 $LN96@CGPShopReq

; 8021 : 				{
; 8022 : 					LogAddTD("[PShop] [%s][%s] Sold All Items - Auto Closing PShop",

  01021	56		 push	 esi
  01022	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  01025	50		 push	 eax
  01026	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@HMKJEHOO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Sold?5All?5Items?5@
  0102b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8023 : 						lpObj->AccountID, lpObj->Name);::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 195)), lpObj->m_Index, 1);

  01034	6a 01		 push	 1
  01036	ff 37		 push	 DWORD PTR [edi]
  01038	68 c3 04 00 00	 push	 1219			; 000004c3H
  0103d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  01042	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01047	50		 push	 eax
  01048	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 8024 : 					lpObj->m_bPShopOpen = false;

  0104d	c6 87 5c 12 00
	00 00		 mov	 BYTE PTR [edi+4700], 0
  01054	0f 57 c0	 xorps	 xmm0, xmm0

; 8025 : 					memset(lpObj->m_szPShopText, 0, sizeof(lpObj->m_szPShopText));

  01057	0f 11 87 60 12
	00 00		 movups	 XMMWORD PTR [edi+4704], xmm0
  0105e	0f 11 87 70 12
	00 00		 movups	 XMMWORD PTR [edi+4720], xmm0
  01065	c7 87 80 12 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+4736], 0

; 8026 : 					::CGPShopAnsClose(lpObj->m_Index, 1);

  0106f	6a 01		 push	 1
  01071	ff 37		 push	 DWORD PTR [edi]
  01073	e8 00 00 00 00	 call	 ?CGPShopAnsClose@@YAXHE@Z ; CGPShopAnsClose
  01078	83 c4 14	 add	 esp, 20			; 00000014H

; 8027 : #if (ENABLE_CUSTOM_OFFLINETRADE==1)
; 8028 : 					if( lpObj->bOffTrade && lpObj->OffTradeWaitItem == 0 )

  0107b	80 bf 31 27 00
	00 00		 cmp	 BYTE PTR [edi+10033], 0
  01082	74 13		 je	 SHORT $LN97@CGPShopReq
  01084	80 bf 30 27 00
	00 00		 cmp	 BYTE PTR [edi+10032], 0
  0108b	75 0a		 jne	 SHORT $LN97@CGPShopReq

; 8029 : 					{
; 8030 : 						gObjDel(lpObj->m_Index);

  0108d	ff 37		 push	 DWORD PTR [edi]
  0108f	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  01094	83 c4 04	 add	 esp, 4
$LN97@CGPShopReq:

; 8037 : 				}
; 8038 : 
; 8039 : 			}
; 8040 : 		}

  01097	9b		 fwait
  01098	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  0109f	e8 7e 00 00 00	 call	 $LN120@CGPShopReq
  010a4	e9 b1 00 00 00	 jmp	 $LN121@CGPShopReq
$LN96@CGPShopReq:

; 8031 : 					}
; 8032 : #endif
; 8033 : 				}
; 8034 : 				else
; 8035 : 				{
; 8036 : 					lpObj->m_bPShopItemChange = true;

  010a9	c6 87 5e 12 00
	00 01		 mov	 BYTE PTR [edi+4702], 1
  010b0	eb e5		 jmp	 SHORT $LN97@CGPShopReq
$LN61@CGPShopReq:

; 7748 : 					 aPShopJewelValue[2] < 0 )
; 7749 : 				{
; 7750 : 					LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] Did Not Choose Item Price",

  010b2	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  010b5	50		 push	 eax
  010b6	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  010b9	50		 push	 eax
  010ba	8b 4d 88	 mov	 ecx, DWORD PTR tv692[ebp]
  010bd	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  010c0	03 c6		 add	 eax, esi
  010c2	50		 push	 eax
  010c3	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  010c6	03 c6		 add	 eax, esi
  010c8	50		 push	 eax
  010c9	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@PIIJDCEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  010ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7751 : 						lpSourceObj->AccountID, lpSourceObj->Name,
; 7752 : 						lpObj->AccountID, lpObj->Name);
; 7753 : 					::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 6);

  010d4	6a 06		 push	 6
$LN172@CGPShopReq:
  010d6	6a 00		 push	 0
  010d8	ff 37		 push	 DWORD PTR [edi]
  010da	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
$LN173@CGPShopReq:
  010dd	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7754 : 
; 7755 : 					return;

  010e2	6a fe		 push	 -2			; fffffffeH
  010e4	9b		 fwait
  010e5	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  010e8	50		 push	 eax
  010e9	68 00 00 00 00	 push	 OFFSET ___security_cookie
  010ee	e8 00 00 00 00	 call	 __local_unwind4
  010f3	83 c4 30	 add	 esp, 48			; 00000030H
  010f6	eb 62		 jmp	 SHORT $LN121@CGPShopReq
$LN152@CGPShopReq:

; 7723 : 			{
; 7724 : 				::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0, 5);

  010f8	6a 05		 push	 5
  010fa	6a 00		 push	 0
  010fc	ff 37		 push	 DWORD PTR [edi]
  010fe	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  01101	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem

; 7725 : 				return;

  01106	6a fe		 push	 -2			; fffffffeH
  01108	9b		 fwait
  01109	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0110c	50		 push	 eax
  0110d	68 00 00 00 00	 push	 OFFSET ___security_cookie
  01112	e8 00 00 00 00	 call	 __local_unwind4
  01117	83 c4 1c	 add	 esp, 28			; 0000001cH
  0111a	eb 3e		 jmp	 SHORT $LN121@CGPShopReq
$LN118@CGPShopReq:
$LN175@CGPShopReq:

; 8037 : 				}
; 8038 : 
; 8039 : 			}
; 8040 : 		}

  0111c	8b bd 24 ff ff
	ff		 mov	 edi, DWORD PTR _lpObj$[ebp]
$LN120@CGPShopReq:

; 8041 : 		__finally
; 8042 : 		{
; 8043 : 			lpObj->m_bPShopTransaction = false;

  01122	c6 87 5d 12 00
	00 00		 mov	 BYTE PTR [edi+4701], 0
$LN119@CGPShopReq:
$LN159@CGPShopReq:
  01129	c3		 ret	 0
$LN46@CGPShopReq:

; 7638 : 	{
; 7639 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : [%s][%s] is in Item Block",

  0112a	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  0112d	50		 push	 eax
  0112e	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  01131	50		 push	 eax
  01132	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  01135	03 c6		 add	 eax, esi
  01137	50		 push	 eax
  01138	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0113b	03 c6		 add	 eax, esi
  0113d	50		 push	 eax
  0113e	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@CHNNEDPM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  01143	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7640 : 			lpSourceObj->AccountID, lpSourceObj->Name,lpObj->AccountID, lpObj->Name);
; 7641 : 		::CGPShopAnsBuyItem(aSourceIndex, lpObj->m_Index, 0,9);

  01149	6a 09		 push	 9
$LN160@CGPShopReq:
  0114b	6a 00		 push	 0
  0114d	ff 37		 push	 DWORD PTR [edi]
  0114f	ff 75 8c	 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  01152	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  01157	83 c4 24	 add	 esp, 36			; 00000024H
$LN121@CGPShopReq:

; 8044 : 		}
; 8045 : 	}
; 8046 : }

  0115a	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0115d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01164	59		 pop	 ecx
  01165	5f		 pop	 edi
  01166	5e		 pop	 esi
  01167	5b		 pop	 ebx
  01168	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0116b	33 cd		 xor	 ecx, ebp
  0116d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01172	8b e5		 mov	 esp, ebp
  01174	5d		 pop	 ebp
  01175	c3		 ret	 0
?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ENDP ; CGPShopReqBuyItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopAnsBuyList@@YAXHHE_N@Z
_TEXT	SEGMENT
_aSourceIndex$GSCopy$1$ = -1136				; size = 4
_aTargetIndex$GSCopy$1$ = -1132				; size = 4
_lpObjTarget$1$ = -1128					; size = 4
_pMsgILC$ = -1124					; size = 55
_iCount$1$ = -1068					; size = 4
_n$1$ = -1064						; size = 4
_sOfs$1$ = -1060					; size = 4
_pMsgIL$ = -1056					; size = 28
_sendBuf$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_aSourceIndex$ = 8					; size = 4
_aTargetIndex$ = 12					; size = 4
_btResult$ = 16						; size = 1
_bResend$ = 20						; size = 1
?CGPShopAnsBuyList@@YAXHHE_N@Z PROC			; CGPShopAnsBuyList, COMDAT

; 7456 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 04 00
	00		 sub	 esp, 1136		; 00000470H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 7457 : 	if ( gDoPShopOpen == FALSE )

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0001a	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  0001d	53		 push	 ebx
  0001e	8b 5d 08	 mov	 ebx, DWORD PTR _aSourceIndex$[ebp]
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 9d 90 fb ff
	ff		 mov	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp], ebx
  00029	89 95 94 fb ff
	ff		 mov	 DWORD PTR _aTargetIndex$GSCopy$1$[ebp], edx
  0002f	0f 84 f7 02 00
	00		 je	 $LN7@CGPShopAns

; 7458 : 		return;
; 7459 : 	
; 7460 : 
; 7461 : 	PMSG_ANS_BUYLIST_FROM_PSHOP pMsgILC;	// Packet Message Item List Count
; 7462 : 	PMSG_BUYLIST_FROM_PSHOP pMsgIL;
; 7463 : 	BYTE sendBuf[1024];
; 7464 : 	int sOfs = sizeof(pMsgILC);
; 7465 : 	int pMsgILSize = sizeof(pMsgIL);
; 7466 : 
; 7467 : 	if ( btResult != 1 )

  00035	8a 4d 10	 mov	 cl, BYTE PTR _btResult$[ebp]
  00038	c7 85 dc fb ff
	ff 37 00 00 00	 mov	 DWORD PTR _sOfs$1$[ebp], 55 ; 00000037H
  00042	80 f9 01	 cmp	 cl, 1
  00045	0f 84 c2 00 00
	00		 je	 $LN6@CGPShopAns

; 7468 : 	{
; 7469 : 		LPOBJ lpObj = &gObj[aSourceIndex];
; 7470 : 		
; 7471 : 		pMsgILC.h.c = 0xC2;
; 7472 : 		pMsgILC.h.headcode = 0x3F;
; 7473 : 
; 7474 : 		if ( bResend == false )

  0004b	80 7d 14 00	 cmp	 BYTE PTR _bResend$[ebp], 0
  0004f	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  00054	be 05 00 00 00	 mov	 esi, 5
  00059	c7 85 9c fb ff
	ff c2 00 37 3f	 mov	 DWORD PTR _pMsgILC$[ebp], 1060569282 ; 3f3700c2H
  00063	0f 44 c6	 cmove	 eax, esi

; 7475 : 			pMsgILC.h.subcode = 0x05;
; 7476 : 		else
; 7477 : 			pMsgILC.h.subcode = 0x13;
; 7478 : 
; 7479 : 		pMsgILC.h.sizeH = SET_NUMBERH(sOfs);
; 7480 : 		pMsgILC.h.sizeL = SET_NUMBERL(sOfs);
; 7481 : 		pMsgILC.btCount = 0;

  00066	c6 85 d2 fb ff
	ff 00		 mov	 BYTE PTR _pMsgILC$[ebp+54], 0
  0006d	88 85 a0 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+4], al

; 7482 : 		pMsgILC.Result = btResult;
; 7483 : 		pMsgILC.NumberH = SET_NUMBERH(aTargetIndex);

  00073	8b c2		 mov	 eax, edx
  00075	c1 e8 08	 shr	 eax, 8
  00078	6a 2e		 push	 46			; 0000002eH
  0007a	88 85 a2 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+6], al
  00080	8d 85 a4 fb ff
	ff		 lea	 eax, DWORD PTR _pMsgILC$[ebp+8]
  00086	6a 00		 push	 0
  00088	50		 push	 eax
  00089	88 8d a1 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+5], cl

; 7484 : 		pMsgILC.NumberL = SET_NUMBERL(aTargetIndex);

  0008f	88 95 a3 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+7], dl
  00095	e8 00 00 00 00	 call	 _memset

; 7485 : 		memset(pMsgILC.btName, 0, sizeof(pMsgILC.btName));
; 7486 : 		memset(pMsgILC.szPShopText, 0, sizeof(pMsgILC.szPShopText));
; 7487 : 		memcpy(sendBuf, &pMsgILC, sizeof(pMsgILC));

  0009a	0f 10 85 9c fb
	ff ff		 movups	 xmm0, XMMWORD PTR _pMsgILC$[ebp]
  000a1	8b 85 cc fb ff
	ff		 mov	 eax, DWORD PTR _pMsgILC$[ebp+48]
  000a7	89 85 2c fc ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+48], eax
  000ad	66 8b 85 d0 fb
	ff ff		 mov	 ax, WORD PTR _pMsgILC$[ebp+52]
  000b4	0f 11 85 fc fb
	ff ff		 movups	 XMMWORD PTR _sendBuf$[ebp], xmm0
  000bb	66 89 85 30 fc
	ff ff		 mov	 WORD PTR _sendBuf$[ebp+52], ax
  000c2	0f 10 85 ac fb
	ff ff		 movups	 xmm0, XMMWORD PTR _pMsgILC$[ebp+16]
  000c9	8a 85 d2 fb ff
	ff		 mov	 al, BYTE PTR _pMsgILC$[ebp+54]
  000cf	88 85 32 fc ff
	ff		 mov	 BYTE PTR _sendBuf$[ebp+54], al

; 7488 : 
; 7489 : 		DataSend(aSourceIndex, sendBuf, sOfs);

  000d5	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sendBuf$[ebp]
  000db	0f 11 85 0c fc
	ff ff		 movups	 XMMWORD PTR _sendBuf$[ebp+16], xmm0
  000e2	6a 37		 push	 55			; 00000037H
  000e4	0f 10 85 bc fb
	ff ff		 movups	 xmm0, XMMWORD PTR _pMsgILC$[ebp+32]
  000eb	50		 push	 eax
  000ec	53		 push	 ebx
  000ed	0f 11 85 1c fc
	ff ff		 movups	 XMMWORD PTR _sendBuf$[ebp+32], xmm0
  000f4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f9	83 c4 18	 add	 esp, 24			; 00000018H

; 7532 : 
; 7533 : 	}
; 7534 : }

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
$LN6@CGPShopAns:

; 7490 : 	}
; 7491 : 	else
; 7492 : 	{
; 7493 : 		LPOBJ lpObjSource = &gObj[aSourceIndex];
; 7494 : 		LPOBJ lpObjTarget = &gObj[aTargetIndex];

  0010d	69 f2 40 27 00
	00		 imul	 esi, edx, 10048
  00113	bb f0 a8 00 00	 mov	 ebx, 43248		; 0000a8f0H

; 7495 : 		int iCount = 0;
; 7496 : 
; 7497 : 		for ( int n=MAIN_INVENTORY_SIZE;n<(INVENTORY_SIZE-1);n++)

  00118	c7 85 d8 fb ff
	ff cc 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 204 ; 000000ccH
  00122	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00128	33 c0		 xor	 eax, eax
  0012a	89 b5 98 fb ff
	ff		 mov	 DWORD PTR _lpObjTarget$1$[ebp], esi
  00130	89 85 d4 fb ff
	ff		 mov	 DWORD PTR _iCount$1$[ebp], eax
  00136	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@CGPShopAns:

; 7498 : 		{
; 7499 : 			if ( lpObjTarget->Inventory1[n].IsItem() == TRUE )

  00140	8b 8e d0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4560]
  00146	03 cb		 add	 ecx, ebx
  00148	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0014d	83 f8 01	 cmp	 eax, 1
  00150	0f 85 be 00 00
	00		 jne	 $LN18@CGPShopAns

; 7500 : 			{
; 7501 : 				pMsgIL.Pos = n;

  00156	8b 85 d8 fb ff
	ff		 mov	 eax, DWORD PTR _n$1$[ebp]

; 7502 : 				ItemByteConvert(pMsgIL.ItemInfo, lpObjTarget->Inventory1[n]);

  0015c	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00162	88 85 e0 fb ff
	ff		 mov	 BYTE PTR _pMsgIL$[ebp], al
  00168	8b fc		 mov	 edi, esp
  0016a	8b b6 d0 11 00
	00		 mov	 esi, DWORD PTR [esi+4560]
  00170	8d 85 e1 fb ff
	ff		 lea	 eax, DWORD PTR _pMsgIL$[ebp+1]
  00176	03 f3		 add	 esi, ebx
  00178	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  0017d	f3 a5		 rep movsd
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 7503 : 				pMsgIL.PShopItemValue = lpObjTarget->Inventory1[n].m_iPShopValue;

  00185	8b b5 98 fb ff
	ff		 mov	 esi, DWORD PTR _lpObjTarget$1$[ebp]
  0018b	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]

; 7504 : 				pMsgIL.PShopBlessValue = lpObjTarget->Inventory1[n].m_PShopBlessValue;
; 7505 : 				pMsgIL.PShopSoulValue = lpObjTarget->Inventory1[n].m_PShopSoulValue;
; 7506 : 				pMsgIL.PShopChaosValue = lpObjTarget->Inventory1[n].m_PShopChaosValue;
; 7507 : 				memcpy(&sendBuf[sOfs], &pMsgIL, pMsgILSize);

  00191	6a 1c		 push	 28			; 0000001cH
  00193	8b 86 d0 11 00
	00		 mov	 eax, DWORD PTR [esi+4560]
  00199	8b 44 03 7c	 mov	 eax, DWORD PTR [ebx+eax+124]
  0019d	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _pMsgIL$[ebp+16], eax
  001a3	8b 86 d0 11 00
	00		 mov	 eax, DWORD PTR [esi+4560]
  001a9	0f b7 84 03 80
	00 00 00	 movzx	 eax, WORD PTR [ebx+eax+128]
  001b1	66 89 85 f4 fb
	ff ff		 mov	 WORD PTR _pMsgIL$[ebp+20], ax
  001b8	8b 86 d0 11 00
	00		 mov	 eax, DWORD PTR [esi+4560]
  001be	0f b7 84 03 82
	00 00 00	 movzx	 eax, WORD PTR [ebx+eax+130]
  001c6	66 89 85 f6 fb
	ff ff		 mov	 WORD PTR _pMsgIL$[ebp+22], ax
  001cd	8b 86 d0 11 00
	00		 mov	 eax, DWORD PTR [esi+4560]
  001d3	0f b7 84 03 84
	00 00 00	 movzx	 eax, WORD PTR [ebx+eax+132]
  001db	66 89 85 f8 fb
	ff ff		 mov	 WORD PTR _pMsgIL$[ebp+24], ax
  001e2	8d 85 e0 fb ff
	ff		 lea	 eax, DWORD PTR _pMsgIL$[ebp]
  001e8	50		 push	 eax
  001e9	8b 85 dc fb ff
	ff		 mov	 eax, DWORD PTR _sOfs$1$[ebp]
  001ef	03 c1		 add	 eax, ecx
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _memcpy

; 7508 : 				iCount++;
; 7509 : 				sOfs += pMsgILSize;

  001f7	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _sOfs$1$[ebp]
  001fd	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00203	ff 85 d4 fb ff
	ff		 inc	 DWORD PTR _iCount$1$[ebp]
  00209	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0020c	89 8d dc fb ff
	ff		 mov	 DWORD PTR _sOfs$1$[ebp], ecx
  00212	eb 06		 jmp	 SHORT $LN2@CGPShopAns
$LN18@CGPShopAns:
  00214	8b 8d dc fb ff
	ff		 mov	 ecx, DWORD PTR _sOfs$1$[ebp]
$LN2@CGPShopAns:

; 7495 : 		int iCount = 0;
; 7496 : 
; 7497 : 		for ( int n=MAIN_INVENTORY_SIZE;n<(INVENTORY_SIZE-1);n++)

  0021a	ff 85 d8 fb ff
	ff		 inc	 DWORD PTR _n$1$[ebp]
  00220	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  00226	81 fb 70 c3 00
	00		 cmp	 ebx, 50032		; 0000c370H
  0022c	0f 8c 0e ff ff
	ff		 jl	 $LL4@CGPShopAns

; 7510 : 			}
; 7511 : 		}
; 7512 : 
; 7513 : 		pMsgILC.h.c = 0xC2;
; 7514 : 		pMsgILC.h.headcode = 0x3F;
; 7515 : 
; 7516 : 		if ( bResend == false )
; 7517 : 			pMsgILC.h.subcode = 0x05;
; 7518 : 		else
; 7519 : 			pMsgILC.h.subcode = 0x13;
; 7520 : 
; 7521 : 		pMsgILC.h.sizeH = SET_NUMBERH(sOfs);
; 7522 : 		pMsgILC.h.sizeL = SET_NUMBERL(sOfs);
; 7523 : 		pMsgILC.btCount = iCount;
; 7524 : 		pMsgILC.Result = btResult;
; 7525 : 		pMsgILC.NumberH = SET_NUMBERH(aTargetIndex);
; 7526 : 		pMsgILC.NumberL = SET_NUMBERL(aTargetIndex);
; 7527 : 		memcpy(pMsgILC.btName, lpObjTarget->Name, sizeof(pMsgILC.btName));

  00232	f3 0f 7e 46 5d	 movq	 xmm0, QWORD PTR [esi+93]
  00237	ba 05 00 00 00	 mov	 edx, 5
  0023c	80 7d 14 00	 cmp	 BYTE PTR _bResend$[ebp], 0
  00240	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  00245	66 0f d6 85 a4
	fb ff ff	 movq	 QWORD PTR _pMsgILC$[ebp+8], xmm0

; 7528 : 		memcpy(pMsgILC.szPShopText, lpObjTarget->m_szPShopText, sizeof(pMsgILC.szPShopText));

  0024d	0f 10 86 60 12
	00 00		 movups	 xmm0, XMMWORD PTR [esi+4704]
  00254	0f 44 c2	 cmove	 eax, edx
  00257	88 8d 9e fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+2], cl
  0025d	8b 95 94 fb ff
	ff		 mov	 edx, DWORD PTR _aTargetIndex$GSCopy$1$[ebp]
  00263	88 85 a0 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+4], al
  00269	8b c1		 mov	 eax, ecx
  0026b	c1 e8 08	 shr	 eax, 8
  0026e	88 85 9d fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+1], al
  00274	8b c2		 mov	 eax, edx
  00276	c1 e8 08	 shr	 eax, 8
  00279	88 85 a2 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+6], al
  0027f	0f b7 46 65	 movzx	 eax, WORD PTR [esi+101]
  00283	0f 11 85 ae fb
	ff ff		 movups	 XMMWORD PTR _pMsgILC$[ebp+18], xmm0
  0028a	66 89 85 ac fb
	ff ff		 mov	 WORD PTR _pMsgILC$[ebp+16], ax
  00291	0f 10 86 70 12
	00 00		 movups	 xmm0, XMMWORD PTR [esi+4720]
  00298	8b 86 80 12 00
	00		 mov	 eax, DWORD PTR [esi+4736]
  0029e	89 85 ce fb ff
	ff		 mov	 DWORD PTR _pMsgILC$[ebp+50], eax
  002a4	0f 11 85 be fb
	ff ff		 movups	 XMMWORD PTR _pMsgILC$[ebp+34], xmm0

; 7529 : 		memcpy(sendBuf, &pMsgILC, sizeof(pMsgILC));

  002ab	8b 85 cc fb ff
	ff		 mov	 eax, DWORD PTR _pMsgILC$[ebp+48]
  002b1	88 95 a3 fb ff
	ff		 mov	 BYTE PTR _pMsgILC$[ebp+7], dl
  002b7	c6 85 9c fb ff
	ff c2		 mov	 BYTE PTR _pMsgILC$[ebp], 194 ; 000000c2H
  002be	c6 85 9f fb ff
	ff 3f		 mov	 BYTE PTR _pMsgILC$[ebp+3], 63 ; 0000003fH
  002c5	c6 85 a1 fb ff
	ff 01		 mov	 BYTE PTR _pMsgILC$[ebp+5], 1
  002cc	0f 10 85 9c fb
	ff ff		 movups	 xmm0, XMMWORD PTR _pMsgILC$[ebp]
  002d3	89 85 2c fc ff
	ff		 mov	 DWORD PTR _sendBuf$[ebp+48], eax
  002d9	0f b7 85 d0 fb
	ff ff		 movzx	 eax, WORD PTR _pMsgILC$[ebp+52]
  002e0	0f 11 85 fc fb
	ff ff		 movups	 XMMWORD PTR _sendBuf$[ebp], xmm0
  002e7	66 89 85 30 fc
	ff ff		 mov	 WORD PTR _sendBuf$[ebp+52], ax
  002ee	0f 10 85 ac fb
	ff ff		 movups	 xmm0, XMMWORD PTR _pMsgILC$[ebp+16]
  002f5	8b 85 d4 fb ff
	ff		 mov	 eax, DWORD PTR _iCount$1$[ebp]
  002fb	88 85 32 fc ff
	ff		 mov	 BYTE PTR _sendBuf$[ebp+54], al

; 7530 : 
; 7531 : 		DataSend(aSourceIndex, sendBuf, sOfs);

  00301	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _sendBuf$[ebp]
  00307	51		 push	 ecx
  00308	0f 11 85 0c fc
	ff ff		 movups	 XMMWORD PTR _sendBuf$[ebp+16], xmm0
  0030f	50		 push	 eax
  00310	0f 10 85 bc fb
	ff ff		 movups	 xmm0, XMMWORD PTR _pMsgILC$[ebp+32]
  00317	ff b5 90 fb ff
	ff		 push	 DWORD PTR _aSourceIndex$GSCopy$1$[ebp]
  0031d	0f 11 85 1c fc
	ff ff		 movups	 XMMWORD PTR _sendBuf$[ebp+32], xmm0
  00324	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00329	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@CGPShopAns:

; 7532 : 
; 7533 : 	}
; 7534 : }

  0032c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032f	5f		 pop	 edi
  00330	5e		 pop	 esi
  00331	33 cd		 xor	 ecx, ebp
  00333	5b		 pop	 ebx
  00334	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00339	8b e5		 mov	 esp, ebp
  0033b	5d		 pop	 ebp
  0033c	c3		 ret	 0
?CGPShopAnsBuyList@@YAXHHE_N@Z ENDP			; CGPShopAnsBuyList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z
_TEXT	SEGMENT
tv535 = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aSourceIndex$ = 12					; size = 4
?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z PROC ; CGPShopReqBuyList, COMDAT

; 7327 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 7328 : 	if ( ::gDoPShopOpen == FALSE )

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0000b	0f 84 11 03 00
	00		 je	 $LN1@CGPShopReq

; 7329 : 		return;
; 7330 : 
; 7331 : 	if ( gObjIsConnected(MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)) == FALSE)

  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00016	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0001a	66 c1 e0 08	 shl	 ax, 8
  0001e	0f b7 c8	 movzx	 ecx, ax
  00021	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00025	0b c8		 or	 ecx, eax
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c0		 test	 eax, eax

; 7332 : 	{
; 7333 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Seller did Not CONNECTED (%d)",

  00032	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00036	75 2c		 jne	 SHORT $LN3@CGPShopReq
  00038	8b 75 0c	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  0003b	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  00041	66 c1 e0 08	 shl	 ax, 8
  00045	0f b7 c8	 movzx	 ecx, ax
  00048	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0004c	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00052	0b c8		 or	 ecx, eax
  00054	51		 push	 ecx
  00055	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00058	50		 push	 eax
  00059	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  0005c	50		 push	 eax
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@IDFNOCHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@

; 7334 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));
; 7335 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 2, 0);
; 7336 : 		return;

  00062	eb 3a		 jmp	 SHORT $LN21@CGPShopReq
$LN3@CGPShopReq:

; 7337 : 	}
; 7338 : 
; 7339 : 	LPOBJ lpObj = &gObj[MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL)];

  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006a	66 c1 e0 08	 shl	 ax, 8
  0006e	0f b7 d0	 movzx	 edx, ax
  00071	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00075	0b d0		 or	 edx, eax
  00077	69 fa 40 27 00
	00		 imul	 edi, edx, 10048
  0007d	03 f9		 add	 edi, ecx

; 7340 : 
; 7341 : 	if ( lpObj->Type != OBJ_USER )

  0007f	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00083	74 34		 je	 SHORT $LN4@CGPShopReq

; 7342 : 	{
; 7343 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Seller is Not CHARACTER (%d)"

  00085	8b 75 0c	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  00088	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  0008e	52		 push	 edx
  0008f	03 c8		 add	 ecx, eax
  00091	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00094	50		 push	 eax
  00095	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00098	50		 push	 eax
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@PCNOKFHF@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
$LN21@CGPShopReq:
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7344 : 			,gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));
; 7345 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 2, 0);

  000a4	6a 00		 push	 0
  000a6	6a 02		 push	 2
  000a8	6a ff		 push	 -1
  000aa	56		 push	 esi
  000ab	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  000b0	83 c4 20	 add	 esp, 32			; 00000020H
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi

; 7425 : }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
$LN4@CGPShopReq:

; 7346 : 		return;
; 7347 : 	}
; 7348 : 
; 7349 : 	if ( lpObj->CloseCount >= 0 )	

  000b9	80 7f 0c 00	 cmp	 BYTE PTR [edi+12], 0
  000bd	7c 34		 jl	 SHORT $LN5@CGPShopReq

; 7350 : 	{
; 7351 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Seller is Closing (%d)"

  000bf	8b 75 0c	 mov	 esi, DWORD PTR _aSourceIndex$[ebp]
  000c2	69 c6 40 27 00
	00		 imul	 eax, esi, 10048
  000c8	52		 push	 edx
  000c9	03 c8		 add	 ecx, eax
  000cb	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000ce	50		 push	 eax
  000cf	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000d2	50		 push	 eax
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@OFDKLOHJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7352 : 			,gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL) );
; 7353 : 		CGPShopAnsBuyItem(aSourceIndex, -1, 0,2);

  000de	6a 02		 push	 2
  000e0	6a 00		 push	 0
  000e2	6a ff		 push	 -1
  000e4	56		 push	 esi
  000e5	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  000ea	83 c4 20	 add	 esp, 32			; 00000020H
  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi

; 7425 : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
$LN5@CGPShopReq:
  000f3	53		 push	 ebx

; 7354 : 		return;
; 7355 : 	}
; 7356 : 
; 7357 : 	if ( gObj[aSourceIndex].CloseCount >= 0 )	

  000f4	8b 5d 0c	 mov	 ebx, DWORD PTR _aSourceIndex$[ebp]
  000f7	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  000fd	03 ce		 add	 ecx, esi
  000ff	89 75 fc	 mov	 DWORD PTR tv535[ebp], esi
  00102	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00106	7c 2a		 jl	 SHORT $LN6@CGPShopReq

; 7358 : 	{
; 7359 : 		LogAddTD("[PShop] [%s][%s] PShop Item Buy Request Failed : Buyer is Closing (%d)",

  00108	52		 push	 edx
  00109	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0010c	50		 push	 eax
  0010d	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00110	50		 push	 eax
  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KILFPGAO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Buy?5@
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7360 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,  MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL));
; 7361 : 		CGPShopAnsBuyItem(aSourceIndex, -1, 0, 2);

  0011c	6a 02		 push	 2
  0011e	6a 00		 push	 0
  00120	6a ff		 push	 -1
  00122	53		 push	 ebx
  00123	e8 00 00 00 00	 call	 ?CGPShopAnsBuyItem@@YAXHHHE@Z ; CGPShopAnsBuyItem
  00128	83 c4 20	 add	 esp, 32			; 00000020H
  0012b	5b		 pop	 ebx
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi

; 7425 : }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
$LN6@CGPShopReq:

; 7362 : 		return;
; 7363 : 	}
; 7364 : 
; 7365 : #if (ENABLETEST_NEWPVP == 1)
; 7366 : 	if (g_NewPVP.IsDuel(gObj[aSourceIndex])) {

  00132	51		 push	 ecx
  00133	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00138	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  0013d	85 c0		 test	 eax, eax
  0013f	74 0a		 je	 SHORT $LN7@CGPShopReq

; 7367 : 		 GCServerMsgStringSend(lMsg.Get(3429), aSourceIndex, 1);

  00141	6a 01		 push	 1
  00143	53		 push	 ebx
  00144	68 65 0d 00 00	 push	 3429			; 00000d65H

; 7368 : 		 return;

  00149	eb 1e		 jmp	 SHORT $LN20@CGPShopReq
$LN7@CGPShopReq:

; 7369 : 	}
; 7370 : 
; 7371 : 	if(g_NewPVP.IsObserver(gObj[aSourceIndex])) {

  0014b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00150	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00155	03 c6		 add	 eax, esi
  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  0015d	85 c0		 test	 eax, eax
  0015f	74 22		 je	 SHORT $LN8@CGPShopReq

; 7372 : 		 GCServerMsgStringSend(lMsg.Get(3430), aSourceIndex, 1);

  00161	6a 01		 push	 1
  00163	53		 push	 ebx
  00164	68 66 0d 00 00	 push	 3430			; 00000d66H
$LN20@CGPShopReq:
  00169	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0016e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH
  0017c	5b		 pop	 ebx
  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi

; 7425 : }

  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
$LN8@CGPShopReq:

; 7373 : 		 return;
; 7374 : 	}
; 7375 : #endif
; 7376 : 
; 7377 : 	if ( lpObj->m_Index == aSourceIndex )

  00183	39 1f		 cmp	 DWORD PTR [edi], ebx
  00185	75 33		 jne	 SHORT $LN9@CGPShopReq

; 7378 : 	{
; 7379 : 		LogAddTD("[PShop] [%s][%s] PShop List Requested to Him(/Her)Self",

  00187	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0018d	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00190	03 c6		 add	 eax, esi
  00192	50		 push	 eax
  00193	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00196	03 c6		 add	 eax, esi
  00198	50		 push	 eax
  00199	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@DOFEJGME@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7380 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name);
; 7381 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 2, 0);

  001a4	6a 00		 push	 0
  001a6	6a 02		 push	 2
  001a8	6a ff		 push	 -1
  001aa	53		 push	 ebx
  001ab	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  001b0	83 c4 1c	 add	 esp, 28			; 0000001cH
  001b3	5b		 pop	 ebx
  001b4	5f		 pop	 edi
  001b5	5e		 pop	 esi

; 7425 : }

  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c3		 ret	 0
$LN9@CGPShopReq:

; 7382 : 		return;
; 7383 : 	}
; 7384 : 
; 7385 : 	if ( lpObj->m_bPShopOpen == false )

  001ba	80 bf 5c 12 00
	00 00		 cmp	 BYTE PTR [edi+4700], 0
  001c1	75 3b		 jne	 SHORT $LN10@CGPShopReq

; 7386 : 	{
; 7387 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : [%s][%s] Did not Open PShop",

  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001c9	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  001cc	50		 push	 eax
  001cd	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  001d0	50		 push	 eax
  001d1	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001d4	03 c6		 add	 eax, esi
  001d6	50		 push	 eax
  001d7	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001da	03 c6		 add	 eax, esi
  001dc	50		 push	 eax
  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@NIGLANBE@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7388 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 7389 : 			lpObj->AccountID, lpObj->Name);
; 7390 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 3, 0);

  001e8	6a 00		 push	 0
  001ea	6a 03		 push	 3

; 7397 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 7398 : 			lpObj->AccountID, lpObj->Name);
; 7399 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 4, 0);

  001ec	6a ff		 push	 -1
  001ee	53		 push	 ebx
  001ef	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  001f4	83 c4 24	 add	 esp, 36			; 00000024H
  001f7	5b		 pop	 ebx
  001f8	5f		 pop	 edi
  001f9	5e		 pop	 esi

; 7425 : }

  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c3		 ret	 0
$LN10@CGPShopReq:
  001fe	f6 87 c0 01 00
	00 0c		 test	 BYTE PTR [edi+448], 12	; 0000000cH

; 7391 : 		return;
; 7392 : 	}
; 7393 : 
; 7394 : 	if ( (lpObj->Penalty &4) == 4 || (lpObj->Penalty&8) == 8 )

  00205	0f 85 e0 00 00
	00		 jne	 $LN12@CGPShopReq

; 7400 : 		return;
; 7401 : 	}
; 7402 : 
; 7403 : 	if ( !::gObjFixInventoryPointer(aSourceIndex))

  0020b	53		 push	 ebx
  0020c	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00211	83 c4 04	 add	 esp, 4
  00214	84 c0		 test	 al, al
  00216	75 18		 jne	 SHORT $LN13@CGPShopReq

; 7404 : 	{
; 7405 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  00218	68 ed 1c 00 00	 push	 7405			; 00001cedH
  0021d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00222	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00227	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0022d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@CGPShopReq:

; 7406 : 	}
; 7407 : 
; 7408 : 	if ( gObj[aSourceIndex].pTransaction == 1 )

  00230	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00236	03 ce		 add	 ecx, esi
  00238	80 b9 cc 11 00
	00 01		 cmp	 BYTE PTR [ecx+4556], 1
  0023f	75 2c		 jne	 SHORT $LN14@CGPShopReq

; 7409 : 	{
; 7410 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : Requester Transaction == 1, IF_TYPE : %d",

  00241	8b 81 b8 11 00
	00		 mov	 eax, DWORD PTR [ecx+4536]
  00247	c1 e8 06	 shr	 eax, 6
  0024a	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0024f	50		 push	 eax
  00250	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00253	50		 push	 eax
  00254	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00257	50		 push	 eax
  00258	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@BJMCDCO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  0025d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00263	83 c4 10	 add	 esp, 16			; 00000010H
  00266	5b		 pop	 ebx
  00267	5f		 pop	 edi
  00268	5e		 pop	 esi

; 7425 : }

  00269	8b e5		 mov	 esp, ebp
  0026b	5d		 pop	 ebp
  0026c	c3		 ret	 0
$LN14@CGPShopReq:

; 7411 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name, gObj[aSourceIndex].m_IfState.type);
; 7412 : 		return;
; 7413 : 	}
; 7414 : 
; 7415 : 	LogAddTD("[PShop] [%s][%s] is Receiving PShop List From [%s][%s]",

  0026d	8d 77 5d	 lea	 esi, DWORD PTR [edi+93]
  00270	56		 push	 esi
  00271	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00274	50		 push	 eax
  00275	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00278	50		 push	 eax
  00279	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0027c	50		 push	 eax
  0027d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@ODEDNFIK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Receiving?5PS@
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7416 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 7417 : 			lpObj->AccountID, lpObj->Name);
; 7418 : 
; 7419 : 	gObj[aSourceIndex].m_bPShopWantDeal = true;

  00288	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0028d	83 c4 14	 add	 esp, 20			; 00000014H
  00290	8b 55 fc	 mov	 edx, DWORD PTR tv535[ebp]

; 7420 : 	gObj[aSourceIndex].m_iPShopDealerIndex = lpObj->m_Index;
; 7421 : 	memcpy(gObj[aSourceIndex].m_szPShopDealerName, lpObj->Name, MAX_ACCOUNT_LEN);
; 7422 : 
; 7423 : 	g_ElementalSystem.SendShopElementalItem(lpObj->m_Index,aSourceIndex);

  00293	53		 push	 ebx
  00294	c6 84 02 84 12
	00 00 01	 mov	 BYTE PTR [edx+eax+4740], 1
  0029c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a1	8b 0f		 mov	 ecx, DWORD PTR [edi]
  002a3	89 8c 02 88 12
	00 00		 mov	 DWORD PTR [edx+eax+4744], ecx
  002aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b0	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  002b4	66 0f d6 84 11
	8c 12 00 00	 movq	 QWORD PTR [ecx+edx+4748], xmm0
  002bd	66 8b 46 08	 mov	 ax, WORD PTR [esi+8]
  002c1	66 89 84 11 94
	12 00 00	 mov	 WORD PTR [ecx+edx+4756], ax
  002c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  002ce	ff 37		 push	 DWORD PTR [edi]
  002d0	e8 00 00 00 00	 call	 ?SendShopElementalItem@CElementalSystem@@QAEXHH@Z ; CElementalSystem::SendShopElementalItem

; 7424 : 	::CGPShopAnsBuyList(aSourceIndex, lpObj->m_Index, 1, false);

  002d5	6a 00		 push	 0
  002d7	6a 01		 push	 1
  002d9	ff 37		 push	 DWORD PTR [edi]
  002db	53		 push	 ebx
  002dc	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  002e1	83 c4 10	 add	 esp, 16			; 00000010H
  002e4	5b		 pop	 ebx
  002e5	5f		 pop	 edi
  002e6	5e		 pop	 esi

; 7425 : }

  002e7	8b e5		 mov	 esp, ebp
  002e9	5d		 pop	 ebp
  002ea	c3		 ret	 0
$LN12@CGPShopReq:

; 7395 : 	{
; 7396 : 		LogAddTD("[PShop] [%s][%s] PShop List Request Failed : [%s][%s] is in Item Block",

  002eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f1	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  002f4	50		 push	 eax
  002f5	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  002f8	50		 push	 eax
  002f9	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002fc	03 c6		 add	 eax, esi
  002fe	50		 push	 eax
  002ff	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00302	03 c6		 add	 eax, esi
  00304	50		 push	 eax
  00305	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@MBNOENIG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5List?5Requ@
  0030a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7397 : 			gObj[aSourceIndex].AccountID, gObj[aSourceIndex].Name,
; 7398 : 			lpObj->AccountID, lpObj->Name);
; 7399 : 		::CGPShopAnsBuyList(aSourceIndex, -1, 4, 0);

  00310	6a 00		 push	 0
  00312	6a 04		 push	 4
  00314	6a ff		 push	 -1
  00316	53		 push	 ebx
  00317	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  0031c	83 c4 24	 add	 esp, 36			; 00000024H
  0031f	5b		 pop	 ebx
  00320	5f		 pop	 edi
  00321	5e		 pop	 esi
$LN1@CGPShopReq:

; 7425 : }

  00322	8b e5		 mov	 esp, ebp
  00324	5d		 pop	 ebp
  00325	c3		 ret	 0
?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ENDP ; CGPShopReqBuyList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopAnsClose@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?CGPShopAnsClose@@YAXHE@Z PROC				; CGPShopAnsClose, COMDAT

; 7306 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 7307 : 	LogAddTD("[PShop] [%s][%s] Close PShop", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	69 75 08 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  00015	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00018	03 c6		 add	 eax, esi
  0001a	50		 push	 eax
  0001b	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0001e	03 c6		 add	 eax, esi
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PJEAPNNK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Close?5PShop?$AA@
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7308 : 
; 7309 : 	PMSG_ANS_PSHOP_CLOSE pMsg;
; 7310 : 
; 7311 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x03, sizeof(pMsg));

  0002c	6a 07		 push	 7
  0002e	6a 03		 push	 3
  00030	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00033	6a 3f		 push	 63			; 0000003fH
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 7312 : 	pMsg.btResult = btResult;
; 7313 : 	pMsg.NumberH = SET_NUMBERH(aIndex);

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0003e	8b c1		 mov	 eax, ecx
  00040	8a 5d 0c	 mov	 bl, BYTE PTR _btResult$[ebp]
  00043	c1 e8 08	 shr	 eax, 8
  00046	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 7314 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 7315 : 
; 7316 : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  00049	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004c	6a 07		 push	 7
  0004e	50		 push	 eax
  0004f	51		 push	 ecx
  00050	88 5d fc	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  00053	88 4d fe	 mov	 BYTE PTR _pMsg$[ebp+6], cl
  00056	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005b	83 c4 28	 add	 esp, 40			; 00000028H

; 7317 : 
; 7318 : 	if ( btResult == 1 )

  0005e	80 fb 01	 cmp	 bl, 1
  00061	75 19		 jne	 SHORT $LN2@CGPShopAns

; 7319 : 		MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  00063	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00067	50		 push	 eax
  00068	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0006b	50		 push	 eax
  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00071	03 c6		 add	 eax, esi
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGPShopAns:
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx

; 7320 : }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?CGPShopAnsClose@@YAXHE@Z ENDP				; CGPShopAnsClose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopReqClose@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGPShopReqClose@@YAXH@Z PROC				; CGPShopReqClose, COMDAT

; 7262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7263 : 	if ( !gObjIsConnected(aIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 12		 jne	 SHORT $LN2@CGPShopReq

; 7264 : 	{
; 7265 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d", aIndex);

  00014	56		 push	 esi
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00020	83 c4 08	 add	 esp, 8
  00023	5e		 pop	 esi

; 7291 : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN2@CGPShopReq:

; 7266 : 		return;
; 7267 : 	}
; 7268 : 
; 7269 : 	if ( gObj[aIndex].Type != OBJ_USER )

  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	57		 push	 edi
  0002d	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00033	03 cf		 add	 ecx, edi
  00035	80 79 50 01	 cmp	 BYTE PTR [ecx+80], 1
  00039	74 13		 je	 SHORT $LN3@CGPShopReq

; 7270 : 	{
; 7271 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  0003b	56		 push	 esi
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00047	83 c4 08	 add	 esp, 8
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 7291 : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN3@CGPShopReq:
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h

; 297  : 		return CHECK_LIMIT(obj.m_iDuelUser, OBJMAX);

  0004e	8b 91 50 12 00
	00		 mov	 edx, DWORD PTR [ecx+4688]
  00054	85 d2		 test	 edx, edx
  00056	78 19		 js	 SHORT $LN4@CGPShopReq
  00058	33 c0		 xor	 eax, eax
  0005a	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00060	0f 9e c0	 setle	 al
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 7276 : 	if (g_NewPVP.IsDuel(gObj[aIndex])) {

  00063	85 c0		 test	 eax, eax
  00065	74 0a		 je	 SHORT $LN4@CGPShopReq

; 7277 : 		 GCServerMsgStringSend(lMsg.Get(3429), aIndex, 1);

  00067	6a 01		 push	 1
  00069	56		 push	 esi
  0006a	68 65 0d 00 00	 push	 3429			; 00000d65H

; 7278 : 		 return;

  0006f	eb 17		 jmp	 SHORT $LN12@CGPShopReq
$LN4@CGPShopReq:

; 7279 : 	}
; 7280 : 
; 7281 : 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  00071	51		 push	 ecx
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00077	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  0007c	85 c0		 test	 eax, eax
  0007e	74 1f		 je	 SHORT $LN5@CGPShopReq

; 7282 : 		 GCServerMsgStringSend(lMsg.Get(3430), aIndex, 1);

  00080	6a 01		 push	 1
  00082	56		 push	 esi
  00083	68 66 0d 00 00	 push	 3430			; 00000d66H
$LN12@CGPShopReq:
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0008d	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi

; 7291 : }

  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN5@CGPShopReq:

; 7283 : 		 return;
; 7284 : 	}
; 7285 : #endif
; 7286 : 
; 7287 : 	LogAddTD("[PShop] [%s][%s] Requested to Close PShop", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a5	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000a8	03 c7		 add	 eax, edi
  000aa	50		 push	 eax
  000ab	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000ae	03 c7		 add	 eax, edi
  000b0	50		 push	 eax
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BPLBGOKP@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Cl@
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7288 : 	gObj[aIndex].m_bPShopOpen = false;

  000bc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c1	0f 57 c0	 xorps	 xmm0, xmm0

; 7289 : 	memset(gObj[aIndex].m_szPShopText, 0, sizeof(gObj[aIndex].m_szPShopText));
; 7290 : 	CGPShopAnsClose(aIndex, 1);

  000c4	6a 01		 push	 1
  000c6	56		 push	 esi
  000c7	c6 84 07 5c 12
	00 00 00	 mov	 BYTE PTR [edi+eax+4700], 0
  000cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d4	0f 11 84 07 60
	12 00 00	 movups	 XMMWORD PTR [edi+eax+4704], xmm0
  000dc	0f 11 84 07 70
	12 00 00	 movups	 XMMWORD PTR [edi+eax+4720], xmm0
  000e4	c7 84 07 80 12
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax+4736], 0
  000ef	e8 00 00 00 00	 call	 ?CGPShopAnsClose@@YAXHE@Z ; CGPShopAnsClose
  000f4	83 c4 14	 add	 esp, 20			; 00000014H
  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi

; 7291 : }

  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
?CGPShopReqClose@@YAXH@Z ENDP				; CGPShopReqClose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopAnsOpen@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
?CGPShopAnsOpen@@YAXHE@Z PROC				; CGPShopAnsOpen, COMDAT

; 7249 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 7250 : 	PMSG_ANS_PSHOP_OPEN pMsg;
; 7251 : 
; 7252 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x02, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 02		 push	 2
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 7253 : 	pMsg.btResult = btResult;

  00015	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]
  00018	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 7254 : 
; 7255 : 	DataSend(aIndex, (LPBYTE)&pMsg, sizeof(pMsg));

  0001b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001e	6a 05		 push	 5
  00020	50		 push	 eax
  00021	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 1c	 add	 esp, 28			; 0000001cH

; 7256 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?CGPShopAnsOpen@@YAXHE@Z ENDP				; CGPShopAnsOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z
_TEXT	SEGMENT
_bEnablePShopOpen$1$ = -57				; size = 1
_pMsg$1 = -56						; size = 52
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z PROC	; CGPShopReqOpen, COMDAT

; 7077 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 7078 : 	if ( ::gDoPShopOpen == FALSE )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  00017	53		 push	 ebx
  00018	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001f	0f 84 fb 03 00
	00		 je	 $LN1@CGPShopReq

; 7079 : 		return;
; 7080 : 
; 7081 : 	if ( !gObjIsConnected(aIndex))

  00025	53		 push	 ebx
  00026	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	75 1f		 jne	 SHORT $LN5@CGPShopReq

; 7082 : 	{
; 7083 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d",aIndex);

  00032	53		 push	 ebx
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0003e	83 c4 08	 add	 esp, 8
  00041	5f		 pop	 edi
  00042	5b		 pop	 ebx

; 7236 : }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	33 cd		 xor	 ecx, ebp
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN5@CGPShopReq:

; 7084 : 		return;
; 7085 : 	}
; 7086 : 
; 7087 : 	if ( gObj[aIndex].Type != OBJ_USER )

  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00057	56		 push	 esi
  00058	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  0005e	03 ce		 add	 ecx, esi
  00060	80 79 50 01	 cmp	 BYTE PTR [ecx+80], 1
  00064	74 20		 je	 SHORT $LN6@CGPShopReq

; 7088 : 	{
; 7089 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  00066	53		 push	 ebx
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00072	83 c4 08	 add	 esp, 8
  00075	5e		 pop	 esi
  00076	5f		 pop	 edi
  00077	5b		 pop	 ebx

; 7236 : }

  00078	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007b	33 cd		 xor	 ecx, ebp
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN6@CGPShopReq:
; File c:\users\michel\desktop\source\gameserver\source\newpvp.h

; 297  : 		return CHECK_LIMIT(obj.m_iDuelUser, OBJMAX);

  00086	8b 91 50 12 00
	00		 mov	 edx, DWORD PTR [ecx+4688]
  0008c	85 d2		 test	 edx, edx
  0008e	78 19		 js	 SHORT $LN7@CGPShopReq
  00090	33 c0		 xor	 eax, eax
  00092	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00098	0f 9e c0	 setle	 al
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 7094 : 	if (g_NewPVP.IsDuel(gObj[aIndex])) {

  0009b	85 c0		 test	 eax, eax
  0009d	74 0a		 je	 SHORT $LN7@CGPShopReq

; 7095 : 		 GCServerMsgStringSend(lMsg.Get(3429), aIndex, 1);

  0009f	6a 01		 push	 1
  000a1	53		 push	 ebx
  000a2	68 65 0d 00 00	 push	 3429			; 00000d65H

; 7096 : 		 return;

  000a7	eb 17		 jmp	 SHORT $LN47@CGPShopReq
$LN7@CGPShopReq:

; 7097 : 	}
; 7098 : 
; 7099 : 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  000a9	51		 push	 ecx
  000aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000af	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  000b4	85 c0		 test	 eax, eax
  000b6	74 2c		 je	 SHORT $LN8@CGPShopReq

; 7100 : 		 GCServerMsgStringSend(lMsg.Get(3430), aIndex, 1);

  000b8	6a 01		 push	 1
  000ba	53		 push	 ebx
  000bb	68 66 0d 00 00	 push	 3430			; 00000d66H
$LN47@CGPShopReq:
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000c5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d3	5e		 pop	 esi
  000d4	5f		 pop	 edi
  000d5	5b		 pop	 ebx

; 7236 : }

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN8@CGPShopReq:

; 7101 : 		 return;
; 7102 : 	}
; 7103 : #endif
; 7104 : 
; 7105 : 	if ( gObj[aIndex].Level <= 5 )

  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ea	03 ce		 add	 ecx, esi
  000ec	0f b7 81 96 00
	00 00		 movzx	 eax, WORD PTR [ecx+150]
  000f3	66 83 f8 05	 cmp	 ax, 5
  000f7	7f 31		 jg	 SHORT $LN9@CGPShopReq

; 7106 : 	{
; 7107 : 		LogAddTD("[PShop] [%s][%s] ERROR : Level is Under 6 : %d",

  000f9	98		 cwde
  000fa	50		 push	 eax
  000fb	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000fe	50		 push	 eax
  000ff	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00102	50		 push	 eax
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7108 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Level);
; 7109 : 		::CGPShopAnsOpen( aIndex, 2);

  0010e	6a 02		 push	 2
  00110	53		 push	 ebx
  00111	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  00116	83 c4 18	 add	 esp, 24			; 00000018H
  00119	5e		 pop	 esi
  0011a	5f		 pop	 edi
  0011b	5b		 pop	 ebx

; 7236 : }

  0011c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011f	33 cd		 xor	 ecx, ebp
  00121	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
$LN9@CGPShopReq:
  0012a	f6 81 c0 01 00
	00 0c		 test	 BYTE PTR [ecx+448], 12	; 0000000cH

; 7110 : 
; 7111 : 		return;
; 7112 : 	}
; 7113 : 
; 7114 : 	if ( (gObj[aIndex].Penalty&4) == 4 || (gObj[aIndex].Penalty&8) == 8 )

  00131	0f 85 ca 02 00
	00		 jne	 $LN11@CGPShopReq

; 7118 : 
; 7119 : 		return;
; 7120 : 	}	
; 7121 : 
; 7122 : 	if ( CC_MAP_RANGE(gObj[aIndex].MapNumber) )

  00137	8a 91 23 01 00
	00		 mov	 dl, BYTE PTR [ecx+291]
  0013d	80 fa 35	 cmp	 dl, 53			; 00000035H
  00140	0f 84 9f 02 00
	00		 je	 $LN43@CGPShopReq
  00146	80 fa 12	 cmp	 dl, 18			; 00000012H
  00149	72 12		 jb	 SHORT $LN12@CGPShopReq
  0014b	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
  00150	3a c2		 cmp	 al, dl
  00152	1b c0		 sbb	 eax, eax
  00154	83 c0 01	 add	 eax, 1
  00157	0f 85 88 02 00
	00		 jne	 $LN43@CGPShopReq
$LN12@CGPShopReq:

; 7128 : 	}
; 7129 : 
; 7130 : 	if ( IT_MAP_RANGE(gObj[aIndex].MapNumber) )

  0015d	80 fa 2d	 cmp	 dl, 45			; 0000002dH
  00160	72 1f		 jb	 SHORT $LN13@CGPShopReq
  00162	b0 32		 mov	 al, 50			; 00000032H
  00164	3a c2		 cmp	 al, dl
  00166	1b c0		 sbb	 eax, eax
  00168	83 c0 01	 add	 eax, 1
  0016b	74 14		 je	 SHORT $LN13@CGPShopReq

; 7131 : 	{
; 7132 : 		::GCServerMsgStringSend("You cannot open your Personal Shop within Illusion Temple.", aIndex, 1);

  0016d	6a 01		 push	 1
  0016f	53		 push	 ebx
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@LHDFDIDM@You?5cannot?5open?5your?5Personal?5Sh@
  00175	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 7133 : 		::CGPShopAnsOpen( aIndex, 0);

  0017a	6a 00		 push	 0

; 7134 : 		return;

  0017c	e9 95 02 00 00	 jmp	 $LN46@CGPShopReq
$LN13@CGPShopReq:

; 7135 : 	}
; 7136 : 
; 7137 : 	if ( DG_MAP_RANGE(gObj[aIndex].MapNumber) )

  00181	80 fa 41	 cmp	 dl, 65			; 00000041H
  00184	72 22		 jb	 SHORT $LN14@CGPShopReq
  00186	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  0018b	3a c2		 cmp	 al, dl
  0018d	1b c0		 sbb	 eax, eax
  0018f	83 c0 01	 add	 eax, 1
  00192	74 14		 je	 SHORT $LN14@CGPShopReq

; 7138 : 	{
; 7139 : 		::GCServerMsgStringSend("You cannot open your Personal Shop within Doppelganger.", aIndex, 1);

  00194	6a 01		 push	 1
  00196	53		 push	 ebx
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@MIGHMEIJ@You?5cannot?5open?5your?5Personal?5Sh@
  0019c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 7140 : 		::CGPShopAnsOpen( aIndex, 0);

  001a1	6a 00		 push	 0

; 7141 : 		return;

  001a3	e9 6e 02 00 00	 jmp	 $LN46@CGPShopReq
$LN14@CGPShopReq:

; 7142 : 	}
; 7143 : 
; 7144 : 	if ( IF_MAP_RANGE(gObj[aIndex].MapNumber) )

  001a8	80 fa 45	 cmp	 dl, 69			; 00000045H
  001ab	72 22		 jb	 SHORT $LN15@CGPShopReq
  001ad	b8 48 00 00 00	 mov	 eax, 72			; 00000048H
  001b2	3a c2		 cmp	 al, dl
  001b4	1b c0		 sbb	 eax, eax
  001b6	83 c0 01	 add	 eax, 1
  001b9	74 14		 je	 SHORT $LN15@CGPShopReq

; 7145 : 	{
; 7146 : 		::GCServerMsgStringSend("You cannot open your Personal Shop within Imperial Fort.", aIndex, 1);

  001bb	6a 01		 push	 1
  001bd	53		 push	 ebx
  001be	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@GMNEGEAG@You?5cannot?5open?5your?5Personal?5Sh@
  001c3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 7147 : 		::CGPShopAnsOpen( aIndex, 0);

  001c8	6a 00		 push	 0

; 7148 : 		return;

  001ca	e9 47 02 00 00	 jmp	 $LN46@CGPShopReq
$LN15@CGPShopReq:

; 7149 : 	}
; 7150 : 
; 7151 : #if (__NOVUS__ == 1)
; 7152 : 	if ( gObj[aIndex].MapNumber != MAP_INDEX_LOREN_MARKET )
; 7153 : 	{
; 7154 : 		::GCServerMsgStringSend("You can open your Personal Shop only in Market!", aIndex, 1);
; 7155 : 		::CGPShopAnsOpen( aIndex, 0);
; 7156 : 		return;
; 7157 : 	}
; 7158 : #endif
; 7159 : 
; 7160 : 	bool bEnablePShopOpen = false;
; 7161 : 
; 7162 : 	if ( gObj[aIndex].m_IfState.use == FALSE )

  001cf	8b 81 b8 11 00
	00		 mov	 eax, DWORD PTR [ecx+4536]
  001d5	8b d0		 mov	 edx, eax
  001d7	c6 45 c7 00	 mov	 BYTE PTR _bEnablePShopOpen$1$[ebp], 0
  001db	83 e2 03	 and	 edx, 3
  001de	75 06		 jne	 SHORT $LN16@CGPShopReq

; 7163 : 		bEnablePShopOpen  = true;

  001e0	c6 45 c7 01	 mov	 BYTE PTR _bEnablePShopOpen$1$[ebp], 1

; 7164 : 	else

  001e4	eb 32		 jmp	 SHORT $LN21@CGPShopReq
$LN16@CGPShopReq:

; 7165 : 	{
; 7166 : 		if ( gObj[aIndex].m_IfState.use == TRUE )
; 7167 : 		{
; 7168 : 			switch ( gObj[aIndex].m_IfState.type )

  001e6	c1 e8 06	 shr	 eax, 6
  001e9	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  001ee	83 fa 01	 cmp	 edx, 1
  001f1	0f 85 c6 01 00
	00		 jne	 $LN18@CGPShopReq
  001f7	83 f8 08	 cmp	 eax, 8
  001fa	75 05		 jne	 SHORT $LN44@CGPShopReq

; 7169 : 			{
; 7170 : 				case 8:
; 7171 : 					bEnablePShopOpen = true; break;

  001fc	88 55 c7	 mov	 BYTE PTR _bEnablePShopOpen$1$[ebp], dl

; 7172 : 			}
; 7173 : 
; 7174 : 			if ( !bEnablePShopOpen  )

  001ff	eb 17		 jmp	 SHORT $LN21@CGPShopReq
$LN44@CGPShopReq:

; 7175 : 			{
; 7176 : 				LogAddTD("[PShop] [%s][%s] ERROR : m_IfState.type is Using : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  00201	50		 push	 eax
  00202	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00205	50		 push	 eax
  00206	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00209	50		 push	 eax
  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MLHOMIKA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5m_IfSta@
  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00215	83 c4 10	 add	 esp, 16			; 00000010H
$LN21@CGPShopReq:

; 7182 : 			return;
; 7183 : 		}
; 7184 : 	}
; 7185 : 
; 7186 : 	if ( !::gObjFixInventoryPointer(aIndex))

  00218	53		 push	 ebx
  00219	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0021e	83 c4 04	 add	 esp, 4
  00221	84 c0		 test	 al, al
  00223	75 18		 jne	 SHORT $LN22@CGPShopReq

; 7187 : 	{
; 7188 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__ ,__LINE__);

  00225	68 14 1c 00 00	 push	 7188			; 00001c14H
  0022a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0022f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00234	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0023a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@CGPShopReq:

; 7189 : 	}
; 7190 : 
; 7191 : 	if ( gObj[aIndex].pTransaction == 1 )

  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00243	03 ce		 add	 ecx, esi
  00245	80 b9 cc 11 00
	00 01		 cmp	 BYTE PTR [ecx+4556], 1
  0024c	75 41		 jne	 SHORT $LN23@CGPShopReq

; 7192 : 	{
; 7193 : 		LogAddTD("[PShop] [%s][%s] ERROR : Transaction == 1, IF_TYPE : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  0024e	8b 81 b8 11 00
	00		 mov	 eax, DWORD PTR [ecx+4536]
  00254	c1 e8 06	 shr	 eax, 6
  00257	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0025c	50		 push	 eax
  0025d	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00260	50		 push	 eax
  00261	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00264	50		 push	 eax
  00265	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@OHKHPELK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Transac@
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00270	83 c4 10	 add	 esp, 16			; 00000010H
$LN24@CGPShopReq:

; 7226 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 7227 : 		}
; 7228 : 	}
; 7229 : 	else
; 7230 : 	{
; 7231 : 		CGPShopAnsOpen(aIndex, 0);

  00273	6a 00		 push	 0
  00275	53		 push	 ebx
  00276	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  0027b	83 c4 08	 add	 esp, 8
  0027e	5e		 pop	 esi
  0027f	5f		 pop	 edi
  00280	5b		 pop	 ebx

; 7236 : }

  00281	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00284	33 cd		 xor	 ecx, ebp
  00286	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028b	8b e5		 mov	 esp, ebp
  0028d	5d		 pop	 ebp
  0028e	c3		 ret	 0
$LN23@CGPShopReq:

; 7194 : 		bEnablePShopOpen = false;
; 7195 : 	}
; 7196 : 
; 7197 : 	if ( bEnablePShopOpen )

  0028f	80 7d c7 00	 cmp	 BYTE PTR _bEnablePShopOpen$1$[ebp], 0
  00293	74 de		 je	 SHORT $LN24@CGPShopReq

; 7198 : 	{
; 7199 : 		if ( gObj[aIndex].m_bPShopOpen == false )

  00295	80 b9 5c 12 00
	00 00		 cmp	 BYTE PTR [ecx+4700], 0
  0029c	75 6b		 jne	 SHORT $LN26@CGPShopReq

; 7200 : 		{
; 7201 : 			gObj[aIndex].m_bPShopOpen = true;

  0029e	c6 81 5c 12 00
	00 01		 mov	 BYTE PTR [ecx+4700], 1

; 7202 : 			memcpy(gObj[aIndex].m_szPShopText, lpMsg->szPShopText, sizeof(lpMsg->szPShopText));

  002a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ab	0f 10 47 04	 movups	 xmm0, XMMWORD PTR [edi+4]
  002af	0f 11 84 31 60
	12 00 00	 movups	 XMMWORD PTR [ecx+esi+4704], xmm0
  002b7	0f 10 47 14	 movups	 xmm0, XMMWORD PTR [edi+20]
  002bb	0f 11 84 31 70
	12 00 00	 movups	 XMMWORD PTR [ecx+esi+4720], xmm0
  002c3	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  002c6	89 84 31 80 12
	00 00		 mov	 DWORD PTR [ecx+esi+4736], eax

; 7203 : 			LogAddTD("[PShop] [%s][%s] Personal Shop Opened", gObj[aIndex].AccountID, gObj[aIndex].Name);

  002cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002d3	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002d6	03 c6		 add	 eax, esi
  002d8	50		 push	 eax
  002d9	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  002dc	03 c6		 add	 eax, esi
  002de	50		 push	 eax
  002df	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HMFGEBKO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5O@
  002e4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002ea	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7232 : 		return;
; 7233 : 	}
; 7234 : 	
; 7235 : 	CGPShopAnsOpen(aIndex, 1);

  002ed	6a 01		 push	 1
  002ef	53		 push	 ebx
  002f0	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  002f5	83 c4 08	 add	 esp, 8
  002f8	5e		 pop	 esi
  002f9	5f		 pop	 edi
  002fa	5b		 pop	 ebx

; 7236 : }

  002fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fe	33 cd		 xor	 ecx, ebp
  00300	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00305	8b e5		 mov	 esp, ebp
  00307	5d		 pop	 ebp
  00308	c3		 ret	 0
$LN26@CGPShopReq:

; 7204 : #if( __NOVUS__ == 1 )
; 7205 : 			char Text[256];
; 7206 : 			ZeroMemory(Text, sizeof(Text));
; 7207 : 			sprintf(Text, "'%s' open new shop (%s)!", gObj[aIndex].Name, gObj[aIndex].m_szPShopText);
; 7208 : 			AllSendServerMsg(Text);
; 7209 : #endif
; 7210 : 		}
; 7211 : 		else
; 7212 : 		{
; 7213 : 			memcpy(gObj[aIndex].m_szPShopText, lpMsg->szPShopText, sizeof(lpMsg->szPShopText));

  00309	0f 10 47 04	 movups	 xmm0, XMMWORD PTR [edi+4]

; 7214 : 			
; 7215 : 			PMSG_ANS_PSHOP_TEXT_CHANGED pMsg;
; 7216 : 
; 7217 : 			PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x10, sizeof(pMsg));

  0030d	6a 34		 push	 52			; 00000034H
  0030f	6a 10		 push	 16			; 00000010H
  00311	0f 11 81 60 12
	00 00		 movups	 XMMWORD PTR [ecx+4704], xmm0
  00318	6a 3f		 push	 63			; 0000003fH
  0031a	0f 10 47 14	 movups	 xmm0, XMMWORD PTR [edi+20]
  0031e	0f 11 81 70 12
	00 00		 movups	 XMMWORD PTR [ecx+4720], xmm0
  00325	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00328	89 81 80 12 00
	00		 mov	 DWORD PTR [ecx+4736], eax
  0032e	8d 45 c8	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  00331	50		 push	 eax
  00332	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 7218 : 			pMsg.NumberH = SET_NUMBERH(aIndex);
; 7219 : 			pMsg.NumberL = SET_NUMBERL(aIndex);
; 7220 : 			memcpy(pMsg.btPShopText, lpMsg->szPShopText, sizeof(pMsg.btPShopText));

  00337	0f 10 47 04	 movups	 xmm0, XMMWORD PTR [edi+4]

; 7221 : 			memcpy(pMsg.btName, gObj[aIndex].Name, sizeof(pMsg.btName));

  0033b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00341	8b c3		 mov	 eax, ebx
  00343	c1 e8 08	 shr	 eax, 8
  00346	03 ce		 add	 ecx, esi
  00348	0f 11 45 ce	 movups	 XMMWORD PTR _pMsg$1[ebp+6], xmm0
  0034c	88 45 cc	 mov	 BYTE PTR _pMsg$1[ebp+4], al
  0034f	0f 10 47 14	 movups	 xmm0, XMMWORD PTR [edi+20]
  00353	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00356	89 45 ee	 mov	 DWORD PTR _pMsg$1[ebp+38], eax
  00359	88 5d cd	 mov	 BYTE PTR _pMsg$1[ebp+5], bl
  0035c	0f 11 45 de	 movups	 XMMWORD PTR _pMsg$1[ebp+22], xmm0
  00360	f3 0f 7e 41 5d	 movq	 xmm0, QWORD PTR [ecx+93]
  00365	66 0f d6 45 f2	 movq	 QWORD PTR _pMsg$1[ebp+42], xmm0
  0036a	66 8b 41 65	 mov	 ax, WORD PTR [ecx+101]
  0036e	66 89 45 fa	 mov	 WORD PTR _pMsg$1[ebp+50], ax

; 7222 : 
; 7223 : 			MsgSendV2(&gObj[aIndex], (LPBYTE)&pMsg, pMsg.h.size);

  00372	0f b6 45 c9	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00376	50		 push	 eax
  00377	8d 45 c8	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0037a	50		 push	 eax
  0037b	51		 push	 ecx
  0037c	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 7224 : 
; 7225 : 			LogAddTD("[PShop] [%s][%s] Personal Shop Already Opened - Changing PShop Name",

  00381	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00387	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0038a	03 c6		 add	 eax, esi
  0038c	50		 push	 eax
  0038d	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00390	03 c6		 add	 eax, esi
  00392	50		 push	 eax
  00393	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@CGDKDDB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Personal?5Shop?5A@
  00398	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0039e	83 c4 28	 add	 esp, 40			; 00000028H

; 7232 : 		return;
; 7233 : 	}
; 7234 : 	
; 7235 : 	CGPShopAnsOpen(aIndex, 1);

  003a1	6a 01		 push	 1
  003a3	53		 push	 ebx
  003a4	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  003a9	83 c4 08	 add	 esp, 8
  003ac	5e		 pop	 esi
  003ad	5f		 pop	 edi
  003ae	5b		 pop	 ebx

; 7236 : }

  003af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b2	33 cd		 xor	 ecx, ebp
  003b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b9	8b e5		 mov	 esp, ebp
  003bb	5d		 pop	 ebp
  003bc	c3		 ret	 0
$LN18@CGPShopReq:

; 7177 : 			}
; 7178 : 		}
; 7179 : 		else
; 7180 : 		{
; 7181 : 			LogAddTD("[PShop] [%s][%s] ERROR : Unknown m_IfState.type : %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);

  003bd	50		 push	 eax
  003be	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  003c1	50		 push	 eax
  003c2	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  003c5	50		 push	 eax
  003c6	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@PANDKIEM@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Unknown@
  003cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003d1	83 c4 10	 add	 esp, 16			; 00000010H
  003d4	5e		 pop	 esi
  003d5	5f		 pop	 edi
  003d6	5b		 pop	 ebx

; 7236 : }

  003d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003da	33 cd		 xor	 ecx, ebp
  003dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e1	8b e5		 mov	 esp, ebp
  003e3	5d		 pop	 ebp
  003e4	c3		 ret	 0
$LN43@CGPShopReq:

; 7123 : 	{
; 7124 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 197)), aIndex, 1);

  003e5	6a 01		 push	 1
  003e7	53		 push	 ebx
  003e8	68 c5 04 00 00	 push	 1221			; 000004c5H
  003ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003f2	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003f7	50		 push	 eax
  003f8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 7125 : 		::CGPShopAnsOpen( aIndex, 0);

  003fd	6a 00		 push	 0

; 7126 : 
; 7127 : 		return;

  003ff	eb 15		 jmp	 SHORT $LN46@CGPShopReq
$LN11@CGPShopReq:

; 7115 : 	{
; 7116 : 		LogAddTD("[PShop] [%s][%s] ERROR : Cant't Open Shop - Item Block" ,gObj[aIndex].AccountID, gObj[aIndex].Name);

  00401	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00404	50		 push	 eax
  00405	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00408	50		 push	 eax
  00409	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@KPCEONNB@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Cant?8t?5@
  0040e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7117 : 		::CGPShopAnsOpen( aIndex, 3);

  00414	6a 03		 push	 3
$LN46@CGPShopReq:
  00416	53		 push	 ebx
  00417	e8 00 00 00 00	 call	 ?CGPShopAnsOpen@@YAXHE@Z ; CGPShopAnsOpen
  0041c	83 c4 14	 add	 esp, 20			; 00000014H
  0041f	5e		 pop	 esi
$LN1@CGPShopReq:

; 7236 : }

  00420	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00423	5f		 pop	 edi
  00424	33 cd		 xor	 ecx, ebp
  00426	5b		 pop	 ebx
  00427	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0042c	8b e5		 mov	 esp, ebp
  0042e	5d		 pop	 ebp
  0042f	c3		 ret	 0
?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z ENDP	; CGPShopReqOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopAnsSetItemPrice@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_btResult$ = 12						; size = 1
_btItemPos$ = 16					; size = 1
?CGPShopAnsSetItemPrice@@YAXHEE@Z PROC			; CGPShopAnsSetItemPrice, COMDAT

; 7052 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 7053 : 	PMSG_ANS_PSHOP_SETITEMPRICE pMsg;
; 7054 : 
; 7055 : 	PHeadSubSetB((LPBYTE)&pMsg, 0x3F, 0x01, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	6a 3f		 push	 63			; 0000003fH
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 7056 : 	pMsg.btResult = btResult;

  00015	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]
  00018	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 7057 : 	pMsg.btItemPos = btItemPos;

  0001b	8a 45 10	 mov	 al, BYTE PTR _btItemPos$[ebp]
  0001e	88 45 fd	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 7058 : 
; 7059 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00021	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00025	50		 push	 eax
  00026	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	50		 push	 eax
  0002a	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH

; 7060 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?CGPShopAnsSetItemPrice@@YAXHEE@Z ENDP			; CGPShopAnsSetItemPrice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z
_TEXT	SEGMENT
_aChaosCnt$1$ = -20					; size = 4
_aSoulCnt$1$ = -16					; size = 4
_aBlessCnt$1$ = -12					; size = 4
tv578 = -8						; size = 4
_iItemPrice$1$ = -8					; size = 4
_sitem$1$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z PROC ; CGPShopReqSetItemPrice, COMDAT

; 6929 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 6930 : 	if ( gDoPShopOpen  == FALSE )

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0000d	75 19		 jne	 SHORT $LN2@CGPShopReq

; 6931 : 	{
; 6932 : 		CGPShopAnsSetItemPrice(aIndex, 0, lpMsg->btItemPos);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00012	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  0001c	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7038 : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
$LN2@CGPShopReq:
  00028	56		 push	 esi

; 6933 : 		return;
; 6934 : 	}
; 6935 : 
; 6936 : 	if ( !gObjIsConnected(aIndex))

  00029	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00032	83 c4 04	 add	 esp, 4
  00035	85 c0		 test	 eax, eax
  00037	75 14		 jne	 SHORT $LN3@CGPShopReq

; 6937 : 	{
; 6938 : 		LogAddTD("[PShop] ERROR : Index is not CONNECTED : %d", aIndex);

  00039	56		 push	 esi
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OJAPKEAG@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CON@
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00045	83 c4 08	 add	 esp, 8
  00048	5e		 pop	 esi

; 7038 : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN3@CGPShopReq:

; 6939 : 		return;
; 6940 : 	}
; 6941 : 
; 6942 : 	if ( gObj[aIndex].Type != OBJ_USER )

  0004d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00053	57		 push	 edi
  00054	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  0005a	80 7c 17 50 01	 cmp	 BYTE PTR [edi+edx+80], 1
  0005f	74 15		 je	 SHORT $LN4@CGPShopReq

; 6943 : 	{
; 6944 : 		LogAddTD("[PShop] ERROR : Index is not CHARACTER : %d", aIndex);

  00061	56		 push	 esi
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGHHKBPI@?$FLPShop?$FN?5ERROR?5?3?5Index?5is?5not?5CHA@
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0006d	83 c4 08	 add	 esp, 8
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi

; 7038 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
$LN4@CGPShopReq:

; 6945 : 		return;
; 6946 : 	}
; 6947 : 
; 6948 : 	if ( gObj[aIndex].Level <= 5 )

  00076	0f b7 84 17 96
	00 00 00	 movzx	 eax, WORD PTR [edi+edx+150]
  0007e	66 83 f8 05	 cmp	 ax, 5
  00082	7f 32		 jg	 SHORT $LN5@CGPShopReq

; 6949 : 	{
; 6950 : 		LogAddTD("[PShop] [%s][%s] ERROR : Level is Under 6 : %d",

  00084	98		 cwde
  00085	50		 push	 eax
  00086	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00089	03 c7		 add	 eax, edi
  0008b	50		 push	 eax
  0008c	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  0008f	03 c7		 add	 eax, edi
  00091	50		 push	 eax
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JILLNCMO@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Level?5i@
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6951 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Level);
; 6952 : 		CGPShopAnsSetItemPrice(aIndex, 5, lpMsg->btItemPos);

  0009d	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000a0	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  000a4	50		 push	 eax
  000a5	6a 05		 push	 5
  000a7	56		 push	 esi
  000a8	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  000ad	83 c4 1c	 add	 esp, 28			; 0000001cH
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi

; 7038 : }

  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
$LN5@CGPShopReq:
  000b6	53		 push	 ebx

; 6953 : 
; 6954 : 		return;
; 6955 : 	}
; 6956 : 
; 6957 : 	if ( INVENTORY_RANGE(lpMsg->btItemPos) == FALSE )

  000b7	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  000ba	b8 ec 00 00 00	 mov	 eax, 236		; 000000ecH
  000bf	8a 4b 04	 mov	 cl, BYTE PTR [ebx+4]
  000c2	3a c1		 cmp	 al, cl
  000c4	1b c0		 sbb	 eax, eax
  000c6	83 c0 01	 add	 eax, 1

; 6958 : 	{
; 6959 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Position Out of Bound : %d",

  000c9	0f b6 c1	 movzx	 eax, cl
  000cc	75 2f		 jne	 SHORT $LN6@CGPShopReq
  000ce	50		 push	 eax
  000cf	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  000d2	03 c7		 add	 eax, edi
  000d4	50		 push	 eax
  000d5	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  000d8	03 c7		 add	 eax, edi
  000da	50		 push	 eax
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@POEGOMMJ@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Po@
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6960 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->btItemPos);
; 6961 : 		CGPShopAnsSetItemPrice(aIndex, 2, lpMsg->btItemPos);

  000e6	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  000ea	50		 push	 eax
  000eb	6a 02		 push	 2

; 7005 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, iItemPrice);
; 7006 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  000ed	56		 push	 esi
  000ee	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  000f3	83 c4 1c	 add	 esp, 28			; 0000001cH
  000f6	5b		 pop	 ebx
  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi

; 7038 : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN6@CGPShopReq:

; 6962 : 
; 6963 : 		return;
; 6964 : 	}
; 6965 : 
; 6966 : 	if ( gObj[aIndex].Inventory1[lpMsg->btItemPos].IsItem() == FALSE )

  000fd	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00103	03 8c 17 d0 11
	00 00		 add	 ecx, DWORD PTR [edi+edx+4560]
  0010a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0010f	85 c0		 test	 eax, eax

; 6967 : 	{
; 6968 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Does Not Exist : %d",

  00111	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00115	75 35		 jne	 SHORT $LN7@CGPShopReq
  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011d	50		 push	 eax
  0011e	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00121	03 c7		 add	 eax, edi
  00123	50		 push	 eax
  00124	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00127	03 c7		 add	 eax, edi
  00129	50		 push	 eax
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@LNPMCBEG@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Do@
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6969 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, lpMsg->btItemPos);
; 6970 : 		CGPShopAnsSetItemPrice(aIndex, 3, lpMsg->btItemPos);

  00135	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00139	50		 push	 eax
  0013a	6a 03		 push	 3

; 7005 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, iItemPrice);
; 7006 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  0013c	56		 push	 esi
  0013d	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00142	83 c4 1c	 add	 esp, 28			; 0000001cH
  00145	5b		 pop	 ebx
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi

; 7038 : }

  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
$LN7@CGPShopReq:

; 6971 : 
; 6972 : 		return;
; 6973 : 	}
; 6974 : 
; 6975 : 	CItem * sitem = &gObj[aIndex].Inventory1[lpMsg->btItemPos];

  0014c	69 d0 d4 00 00
	00		 imul	 edx, eax, 212
  00152	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00157	03 94 07 d0 11
	00 00		 add	 edx, DWORD PTR [edi+eax+4560]

; 6976 : 	int iItemPrice = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->sItemPrice4, lpMsg->sItemPrice3), MAKE_NUMBERW(lpMsg->sItemPrice2, lpMsg->sItemPrice1));

  0015e	0f b6 43 08	 movzx	 eax, BYTE PTR [ebx+8]
  00162	66 c1 e0 08	 shl	 ax, 8
  00166	0f b7 c8	 movzx	 ecx, ax
  00169	0f b6 43 07	 movzx	 eax, BYTE PTR [ebx+7]
  0016d	0b c8		 or	 ecx, eax
  0016f	89 55 fc	 mov	 DWORD PTR _sitem$1$[ebp], edx
  00172	0f b6 43 06	 movzx	 eax, BYTE PTR [ebx+6]
  00176	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00179	89 4d f8	 mov	 DWORD PTR _iItemPrice$1$[ebp], ecx
  0017c	66 c1 e0 08	 shl	 ax, 8
  00180	0f b7 c8	 movzx	 ecx, ax
  00183	0f b6 43 05	 movzx	 eax, BYTE PTR [ebx+5]
  00187	0b c8		 or	 ecx, eax

; 6977 : 	short aBlessCnt = MAKE_NUMBERW(lpMsg->sBlessCnt2,lpMsg->sBlessCnt1);

  00189	0f b6 43 09	 movzx	 eax, BYTE PTR [ebx+9]
  0018d	09 4d f8	 or	 DWORD PTR _iItemPrice$1$[ebp], ecx
  00190	0f b6 4b 0a	 movzx	 ecx, BYTE PTR [ebx+10]
  00194	66 c1 e1 08	 shl	 cx, 8
  00198	66 0b c8	 or	 cx, ax
  0019b	0f b7 c1	 movzx	 eax, cx

; 6978 : 	short aSoulCnt = MAKE_NUMBERW(lpMsg->sSoulCnt2,lpMsg->sSoulCnt1);

  0019e	0f b6 4b 0c	 movzx	 ecx, BYTE PTR [ebx+12]
  001a2	89 45 f4	 mov	 DWORD PTR _aBlessCnt$1$[ebp], eax
  001a5	0f b6 43 0b	 movzx	 eax, BYTE PTR [ebx+11]
  001a9	66 c1 e1 08	 shl	 cx, 8
  001ad	66 0b c8	 or	 cx, ax
  001b0	0f b7 c1	 movzx	 eax, cx

; 6979 : 	short aChaosCnt = MAKE_NUMBERW(lpMsg->sChaosCnt2,lpMsg->sChaosCnt1);

  001b3	0f b6 4b 0e	 movzx	 ecx, BYTE PTR [ebx+14]
  001b7	89 45 f0	 mov	 DWORD PTR _aSoulCnt$1$[ebp], eax
  001ba	0f b6 43 0d	 movzx	 eax, BYTE PTR [ebx+13]
  001be	66 c1 e1 08	 shl	 cx, 8
  001c2	66 0b c8	 or	 cx, ax
  001c5	0f b7 c1	 movzx	 eax, cx

; 6980 : 
; 6981 : 
; 6982 : 	if ( gObjCheckSerial0ItemList(sitem) != FALSE )

  001c8	52		 push	 edx
  001c9	89 45 ec	 mov	 DWORD PTR _aChaosCnt$1$[ebp], eax
  001cc	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  001d1	83 c4 04	 add	 esp, 4
  001d4	85 c0		 test	 eax, eax
  001d6	74 77		 je	 SHORT $LN8@CGPShopReq

; 6983 : 	{
; 6984 : 		MsgOutput(aIndex, lMsg.Get(MSGGET(13, 26)));

  001d8	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  001dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001e2	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001e7	50		 push	 eax
  001e8	56		 push	 esi
  001e9	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 6985 : 		GCReFillSend(aIndex, (WORD) gObj[aIndex].Life, 0xFD, 1, gObj[aIndex].iShield);

  001ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f4	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  001fc	50		 push	 eax
  001fd	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  00206	6a 01		 push	 1
  00208	68 fd 00 00 00	 push	 253			; 000000fdH
  0020d	0f b7 c0	 movzx	 eax, ax
  00210	50		 push	 eax
  00211	56		 push	 esi
  00212	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 6986 : 
; 6987 : 		LogAddTD("[ANTI-HACK][Serial 0 Item] [PShop] (%s)(%s) Item(%s) Pos(%d)",

  00217	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  0021b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0021e	8b 4d fc	 mov	 ecx, DWORD PTR _sitem$1$[ebp]
  00221	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00227	50		 push	 eax
  00228	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0022d	50		 push	 eax
  0022e	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00231	03 c7		 add	 eax, edi
  00233	50		 push	 eax
  00234	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00237	03 c7		 add	 eax, edi
  00239	50		 push	 eax
  0023a	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@IOKIFLHM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLPSho@
  0023f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00245	83 c4 14	 add	 esp, 20			; 00000014H
  00248	5b		 pop	 ebx
  00249	5f		 pop	 edi
  0024a	5e		 pop	 esi

; 7038 : }

  0024b	8b e5		 mov	 esp, ebp
  0024d	5d		 pop	 ebp
  0024e	c3		 ret	 0
$LN8@CGPShopReq:

; 6988 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->GetName(), lpMsg->btItemPos);
; 6989 : 
; 6990 : 		return;
; 6991 : 	}
; 6992 : 
; 6993 : 
; 6994 : 	if ( gObjInventorySearchSerialNumber(&gObj[aIndex], sitem->GetNumber()) == FALSE )

  0024f	8b 4d fc	 mov	 ecx, DWORD PTR _sitem$1$[ebp]
  00252	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00257	50		 push	 eax
  00258	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0025d	03 c7		 add	 eax, edi
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00265	83 c4 08	 add	 esp, 8
  00268	85 c0		 test	 eax, eax
  0026a	75 5a		 jne	 SHORT $LN9@CGPShopReq

; 6995 : 	{
; 6996 : 		GCReFillSend(aIndex,(WORD)gObj[aIndex].Life, 0xFD, TRUE, gObj[aIndex].iShield);

  0026c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00272	0f b7 84 0f 2c
	01 00 00	 movzx	 eax, WORD PTR [edi+ecx+300]
  0027a	50		 push	 eax
  0027b	f3 0f 2c 84 0f
	d8 00 00 00	 cvttss2si eax, DWORD PTR [edi+ecx+216]
  00284	6a 01		 push	 1
  00286	68 fd 00 00 00	 push	 253			; 000000fdH
  0028b	0f b7 c0	 movzx	 eax, ax
  0028e	50		 push	 eax
  0028f	56		 push	 esi
  00290	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend

; 6997 : 		LogAdd("error-L2 : CopyItem [%s][%s] return %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, __FILE__, __LINE__);

  00295	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0029b	68 55 1b 00 00	 push	 6997			; 00001b55H
  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  002a5	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002a8	03 c7		 add	 eax, edi
  002aa	50		 push	 eax
  002ab	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  002ae	03 c7		 add	 eax, edi
  002b0	50		 push	 eax
  002b1	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBOOILII@error?9L2?5?3?5CopyItem?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ret@
  002b6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002bc	83 c4 28	 add	 esp, 40			; 00000028H
  002bf	5b		 pop	 ebx
  002c0	5f		 pop	 edi
  002c1	5e		 pop	 esi

; 7038 : }

  002c2	8b e5		 mov	 esp, ebp
  002c4	5d		 pop	 ebp
  002c5	c3		 ret	 0
$LN9@CGPShopReq:

; 6998 : 
; 6999 : 		return;
; 7000 : 	}
; 7001 : 
; 7002 : 	if ( iItemPrice < 0 || aBlessCnt < 0 || aSoulCnt < 0 || aChaosCnt < 0 )

  002c6	8b 45 f8	 mov	 eax, DWORD PTR _iItemPrice$1$[ebp]
  002c9	85 c0		 test	 eax, eax
  002cb	0f 88 5c 01 00
	00		 js	 $LN11@CGPShopReq
  002d1	66 83 7d f4 00	 cmp	 WORD PTR _aBlessCnt$1$[ebp], 0
  002d6	0f 8c 51 01 00
	00		 jl	 $LN11@CGPShopReq
  002dc	66 83 7d f0 00	 cmp	 WORD PTR _aSoulCnt$1$[ebp], 0
  002e1	0f 8c 46 01 00
	00		 jl	 $LN11@CGPShopReq
  002e7	66 83 7d ec 00	 cmp	 WORD PTR _aChaosCnt$1$[ebp], 0
  002ec	0f 8c 3b 01 00
	00		 jl	 $LN11@CGPShopReq

; 7007 : 		return;
; 7008 : 	}
; 7009 : 
; 7010 : 	if ( (gObj[aIndex].Penalty&4) == 4 || (gObj[aIndex].Penalty&8) == 8 )

  002f2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f8	f6 84 17 c0 01
	00 00 0c	 test	 BYTE PTR [edi+edx+448], 12 ; 0000000cH
  00300	0f 85 f3 00 00
	00		 jne	 $LN13@CGPShopReq

; 7014 : 
; 7015 : 		return;
; 7016 : 	}
; 7017 : 
; 7018 : 	if ( sitem->m_Type < 0 || sitem->m_Type >= ITEMGET(16,0))

  00306	8b 4d fc	 mov	 ecx, DWORD PTR _sitem$1$[ebp]
  00309	0f b7 71 06	 movzx	 esi, WORD PTR [ecx+6]
  0030d	89 75 f8	 mov	 DWORD PTR tv578[ebp], esi
  00310	66 85 f6	 test	 si, si
  00313	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00316	0f 88 bc 00 00
	00		 js	 $LN15@CGPShopReq
  0031c	bb 00 20 00 00	 mov	 ebx, 8192		; 00002000H
  00321	66 39 5d f8	 cmp	 WORD PTR tv578[ebp], bx
  00325	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00328	0f 8d aa 00 00
	00		 jge	 $LN15@CGPShopReq

; 7021 : 		return;
; 7022 : 	}
; 7023 : 
; 7024 : 	sitem->m_iPShopValue = iItemPrice;

  0032e	89 41 7c	 mov	 DWORD PTR [ecx+124], eax

; 7025 : 	sitem->m_PShopBlessValue = aBlessCnt;
; 7026 : 	sitem->m_PShopSoulValue = aSoulCnt;
; 7027 : 	sitem->m_PShopChaosValue = aChaosCnt;
; 7028 : 
; 7029 : 	ItemAttribute[sitem->m_Type].Name[31] = 0;	// Zero String Terminated
; 7030 : 
; 7031 : 	LogAddTD("[PShop] [%s][%s] Changing Item Price : %d (B: %d, S: %d, C: %d) (Type:%d (%s), Lev:%d, Serial:%d, Dur:%d",

  00331	83 ec 08	 sub	 esp, 8
  00334	8b 45 f4	 mov	 eax, DWORD PTR _aBlessCnt$1$[ebp]
  00337	66 89 81 80 00
	00 00		 mov	 WORD PTR [ecx+128], ax
  0033e	8b 45 f0	 mov	 eax, DWORD PTR _aSoulCnt$1$[ebp]
  00341	66 89 81 82 00
	00 00		 mov	 WORD PTR [ecx+130], ax
  00348	8b 45 ec	 mov	 eax, DWORD PTR _aChaosCnt$1$[ebp]
  0034b	66 89 81 84 00
	00 00		 mov	 WORD PTR [ecx+132], ax
  00352	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  00356	98		 cwde
  00357	6b c0 70	 imul	 eax, eax, 112
  0035a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00360	c6 80 1f 00 00
	00 00		 mov	 BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+31], 0
  00367	8b 45 fc	 mov	 eax, DWORD PTR _sitem$1$[ebp]
  0036a	0f bf 49 06	 movsx	 ecx, WORD PTR [ecx+6]
  0036e	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00373	0f 5a c0	 cvtps2pd xmm0, xmm0
  00376	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0037b	ff 30		 push	 DWORD PTR [eax]
  0037d	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00381	50		 push	 eax
  00382	6b c1 70	 imul	 eax, ecx, 112
  00385	05 00 00 00 00	 add	 eax, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0038a	50		 push	 eax
  0038b	51		 push	 ecx
  0038c	8b 4d fc	 mov	 ecx, DWORD PTR _sitem$1$[ebp]
  0038f	0f bf 81 84 00
	00 00		 movsx	 eax, WORD PTR [ecx+132]
  00396	50		 push	 eax
  00397	0f bf 81 82 00
	00 00		 movsx	 eax, WORD PTR [ecx+130]
  0039e	50		 push	 eax
  0039f	0f bf 81 80 00
	00 00		 movsx	 eax, WORD PTR [ecx+128]
  003a6	50		 push	 eax
  003a7	ff 71 7c	 push	 DWORD PTR [ecx+124]
  003aa	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  003ad	03 c7		 add	 eax, edi
  003af	50		 push	 eax
  003b0	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  003b3	03 c7		 add	 eax, edi
  003b5	50		 push	 eax
  003b6	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@BBHGJODA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Changing?5Item?5P@
  003bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7032 : 		gObj[aIndex].AccountID, gObj[aIndex].Name, sitem->m_iPShopValue,
; 7033 : 		sitem->m_PShopBlessValue,sitem->m_PShopSoulValue,sitem->m_PShopChaosValue,sitem->m_Type, 
; 7034 : 		ItemAttribute[sitem->m_Type].Name, sitem->m_Level, sitem->m_Number,
; 7035 : 		sitem->m_Durability);
; 7036 : 
; 7037 : 	CGPShopAnsSetItemPrice(aIndex, 1, lpMsg->btItemPos);

  003c1	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  003c5	50		 push	 eax
  003c6	6a 01		 push	 1
  003c8	56		 push	 esi
  003c9	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  003ce	83 c4 40	 add	 esp, 64			; 00000040H
  003d1	5b		 pop	 ebx
  003d2	5f		 pop	 edi
  003d3	5e		 pop	 esi

; 7038 : }

  003d4	8b e5		 mov	 esp, ebp
  003d6	5d		 pop	 ebp
  003d7	c3		 ret	 0
$LN15@CGPShopReq:

; 7019 : 	{
; 7020 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Outof Bound",gObj[aIndex].AccountID,gObj[aIndex].Name);

  003d8	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  003db	03 c7		 add	 eax, edi
  003dd	50		 push	 eax
  003de	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  003e1	03 c7		 add	 eax, edi
  003e3	50		 push	 eax
  003e4	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@ODKADHDC@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Ou@
  003e9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  003f2	5b		 pop	 ebx
  003f3	5f		 pop	 edi
  003f4	5e		 pop	 esi

; 7038 : }

  003f5	8b e5		 mov	 esp, ebp
  003f7	5d		 pop	 ebp
  003f8	c3		 ret	 0
$LN13@CGPShopReq:

; 7011 : 	{
; 7012 : 		LogAddTD("[PShop] [%s][%s] ERROR : Item Price Change - Item Block",gObj[aIndex].AccountID, gObj[aIndex].Name,sitem->m_iPShopValue);	// Deathway fix Here - Last parameter can cause crash

  003f9	8b 45 fc	 mov	 eax, DWORD PTR _sitem$1$[ebp]
  003fc	ff 70 7c	 push	 DWORD PTR [eax+124]
  003ff	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00402	03 c7		 add	 eax, edi
  00404	50		 push	 eax
  00405	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  00408	03 c7		 add	 eax, edi
  0040a	50		 push	 eax
  0040b	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@GBAILLEI@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Item?5Pr@
  00410	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7013 : 		CGPShopAnsSetItemPrice(aIndex, 6	, lpMsg->btItemPos);

  00416	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  0041a	50		 push	 eax
  0041b	6a 06		 push	 6
  0041d	56		 push	 esi
  0041e	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00423	83 c4 1c	 add	 esp, 28			; 0000001cH
  00426	5b		 pop	 ebx
  00427	5f		 pop	 edi
  00428	5e		 pop	 esi

; 7038 : }

  00429	8b e5		 mov	 esp, ebp
  0042b	5d		 pop	 ebp
  0042c	c3		 ret	 0
$LN11@CGPShopReq:

; 7003 : 	{
; 7004 : 		LogAddTD("[PShop] [%s][%s] ERROR : Personal Shop Item Price <= 0 : %d ",

  0042d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00433	50		 push	 eax
  00434	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00437	03 c7		 add	 eax, edi
  00439	50		 push	 eax
  0043a	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0043d	03 c7		 add	 eax, edi
  0043f	50		 push	 eax
  00440	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CBDABIEA@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5ERROR?5?3?5Persona@
  00445	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 7005 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, iItemPrice);
; 7006 : 		CGPShopAnsSetItemPrice(aIndex, 4, lpMsg->btItemPos);

  0044b	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  0044f	50		 push	 eax
  00450	6a 04		 push	 4
  00452	56		 push	 esi
  00453	e8 00 00 00 00	 call	 ?CGPShopAnsSetItemPrice@@YAXHEE@Z ; CGPShopAnsSetItemPrice
  00458	83 c4 1c	 add	 esp, 28			; 0000001cH
  0045b	5b		 pop	 ebx
  0045c	5f		 pop	 edi
  0045d	5e		 pop	 esi

; 7038 : }

  0045e	8b e5		 mov	 esp, ebp
  00460	5d		 pop	 ebp
  00461	c3		 ret	 0
?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ENDP ; CGPShopReqSetItemPrice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGTradeResult@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?CGTradeResult@@YAXHE@Z PROC				; CGTradeResult, COMDAT

; 6905 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6906 : 	PMSG_TRADE_RESULT pMsg;
; 6907 : 
; 6908 : 	PHeadSetB((LPBYTE)&pMsg, 0x3D, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 3d		 push	 61			; 0000003dH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6909 : 	pMsg.Result = result;

  00011	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00014	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 6910 : 
; 6911 : 	DataSend(aIndex, (unsigned char*)&pMsg, pMsg.h.size);

  00017	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001b	50		 push	 eax
  0001c	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00023	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00028	83 c4 18	 add	 esp, 24			; 00000018H

; 6912 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?CGTradeResult@@YAXHE@Z ENDP				; CGTradeResult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGTradeCancelButtonRecv@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?CGTradeCancelButtonRecv@@YAXH@Z PROC			; CGTradeCancelButtonRecv, COMDAT

; 6882 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6883 : 	int number = gObj[aIndex].TargetNumber;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0000c	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00012	57		 push	 edi

; 6884 : 	gObjTradeCancel(aIndex);

  00013	56		 push	 esi
  00014	0f bf bc 01 38
	06 00 00	 movsx	 edi, WORD PTR [ecx+eax+1592]
  0001c	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 6885 : 	CGTradeResult(aIndex, 0);

  00021	6a 00		 push	 0
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6886 : 
; 6887 : 	if ( number >= 0 )

  0002c	85 ff		 test	 edi, edi
  0002e	78 11		 js	 SHORT $LN2@CGTradeCan

; 6888 : 	{
; 6889 : 		gObjTradeCancel(number);

  00030	57		 push	 edi
  00031	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel

; 6890 : 		CGTradeResult(number, 0);

  00036	6a 00		 push	 0
  00038	57		 push	 edi
  00039	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@CGTradeCan:
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi

; 6891 : 	}
; 6892 : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?CGTradeCancelButtonRecv@@YAXH@Z ENDP			; CGTradeCancelButtonRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z
_TEXT	SEGMENT
tv269 = -4						; size = 4
_lpMsg$ = 8						; size = 4
?gObj@@3PAUOBJECTSTRUCT@@A$2 = 12			; size = 4
_aIndex$ = 12						; size = 4
?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z PROC ; CGTradeOkButtonRecv, COMDAT

; 6837 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6838 : 	int number = gObj[aIndex].TargetNumber;

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  00015	0f bf b4 07 38
	06 00 00	 movsx	 esi, WORD PTR [edi+eax+1592]

; 6839 : 
; 6840 : 	if ( number < 0 || number > OBJMAX-1 )

  0001d	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00023	0f 87 03 01 00
	00		 ja	 $LN8@CGTradeOkB

; 6841 : 		return;
; 6842 : 
; 6843 : 	if ( !gObjIsConnected(&gObj[number]))

  00029	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0002f	03 c1		 add	 eax, ecx
  00031	89 4d fc	 mov	 DWORD PTR tv269[ebp], ecx
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0003a	83 c4 04	 add	 esp, 4
  0003d	85 c0		 test	 eax, eax
  0003f	0f 84 e7 00 00
	00		 je	 $LN8@CGTradeOkB

; 6844 : 		return;
; 6845 : 
; 6846 : 	if ( gObj[aIndex].m_IfState.use < 1 || gObj[aIndex].m_IfState.state != 1 )

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004a	89 45 0c	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$2[ebp], eax
  0004d	8b 8c 07 b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+eax+4536]
  00054	8b c1		 mov	 eax, ecx
  00056	24 03		 and	 al, 3
  00058	3c 01		 cmp	 al, 1
  0005a	0f 82 cc 00 00
	00		 jb	 $LN8@CGTradeOkB
  00060	80 e1 3c	 and	 cl, 60			; 0000003cH
  00063	80 f9 04	 cmp	 cl, 4
  00066	0f 85 c0 00 00
	00		 jne	 $LN8@CGTradeOkB

; 6847 : 		return;
; 6848 : 
; 6849 : 	if ( gObj[number].m_IfState.use < 1 || gObj[number].m_IfState.state != 1 )

  0006c	8b 55 fc	 mov	 edx, DWORD PTR tv269[ebp]
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$2[ebp]
  00072	8b 8c 0a b8 11
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+4536]
  00079	8b c1		 mov	 eax, ecx
  0007b	24 03		 and	 al, 3
  0007d	3c 01		 cmp	 al, 1
  0007f	0f 82 a7 00 00
	00		 jb	 $LN8@CGTradeOkB
  00085	80 e1 3c	 and	 cl, 60			; 0000003cH
  00088	80 f9 04	 cmp	 cl, 4
  0008b	0f 85 9b 00 00
	00		 jne	 $LN8@CGTradeOkB

; 6850 : 		return;
; 6851 : 
; 6852 : 	if ( gObj[aIndex].CloseType != -1 )

  00091	8b 4d 0c	 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A$2[ebp]
  00094	80 7c 0f 0d ff	 cmp	 BYTE PTR [edi+ecx+13], -1
  00099	0f 85 8d 00 00
	00		 jne	 $LN8@CGTradeOkB

; 6853 : 		return;
; 6854 : 
; 6855 : 	if ( gObj[number].CloseType != -1 )

  0009f	80 7c 0a 0d ff	 cmp	 BYTE PTR [edx+ecx+13], -1
  000a4	0f 85 82 00 00
	00		 jne	 $LN8@CGTradeOkB

; 6856 : 		return;
; 6857 : 	
; 6858 : 	if ( lpMsg->Flag == 1 )

  000aa	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  000ad	8a 40 03	 mov	 al, BYTE PTR [eax+3]
  000b0	3c 01		 cmp	 al, 1
  000b2	75 49		 jne	 SHORT $LN11@CGTradeOkB

; 6859 : 	{
; 6860 : 		if ( gObj[aIndex].TradeOk == false )

  000b4	80 bc 0f f4 11
	00 00 00	 cmp	 BYTE PTR [edi+ecx+4596], 0
  000bc	75 65		 jne	 SHORT $LN15@CGTradeOkB

; 6861 : 		{
; 6862 : 			gObj[aIndex].TradeOk = true;

  000be	88 84 0f f4 11
	00 00		 mov	 BYTE PTR [edi+ecx+4596], al

; 6863 : 			LogAddTD("[%s][%s] Trade Accept", gObj[aIndex].AccountID, gObj[aIndex].Name);

  000c5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000cb	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000ce	03 c7		 add	 eax, edi
  000d0	50		 push	 eax
  000d1	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000d4	03 c7		 add	 eax, edi
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FLFOODFC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Accept?$AA@
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 6864 : 			GCTradeOkButtonSend(number, 1);

  000e2	6a 01		 push	 1
  000e4	56		 push	 esi
  000e5	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend
  000ea	83 c4 14	 add	 esp, 20			; 00000014H

; 6873 : 		}
; 6874 : 	}
; 6875 : 
; 6876 : 	gObjTradeOkButton(aIndex);

  000ed	53		 push	 ebx
  000ee	e8 00 00 00 00	 call	 ?gObjTradeOkButton@@YAXH@Z ; gObjTradeOkButton
  000f3	83 c4 04	 add	 esp, 4
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx

; 6877 : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN11@CGTradeOkB:

; 6865 : 		}
; 6866 : 	}
; 6867 : 	else if ( lpMsg->Flag == 0 )

  000fd	84 c0		 test	 al, al
  000ff	75 22		 jne	 SHORT $LN15@CGTradeOkB

; 6868 : 	{
; 6869 : 		if ( gObj[aIndex].TradeOk  == true )

  00101	80 bc 0f f4 11
	00 00 01	 cmp	 BYTE PTR [edi+ecx+4596], 1
  00109	75 18		 jne	 SHORT $LN15@CGTradeOkB

; 6870 : 		{
; 6871 : 			GCTradeOkButtonSend(number, 0);

  0010b	6a 00		 push	 0
  0010d	56		 push	 esi
  0010e	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 6872 : 			gObj[aIndex].TradeOk = false;

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00118	83 c4 08	 add	 esp, 8
  0011b	c6 84 07 f4 11
	00 00 00	 mov	 BYTE PTR [edi+eax+4596], 0
$LN15@CGTradeOkB:

; 6873 : 		}
; 6874 : 	}
; 6875 : 
; 6876 : 	gObjTradeOkButton(aIndex);

  00123	53		 push	 ebx
  00124	e8 00 00 00 00	 call	 ?gObjTradeOkButton@@YAXH@Z ; gObjTradeOkButton
  00129	83 c4 04	 add	 esp, 4
$LN8@CGTradeOkB:
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx

; 6877 : }

  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ENDP ; CGTradeOkButtonRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCTradeOkButtonSend@@YAHHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_flag$ = 12						; size = 1
?GCTradeOkButtonSend@@YAHHE@Z PROC			; GCTradeOkButtonSend, COMDAT

; 6825 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6826 : 	PMSG_TRADE_OKBUTTON pMsg;
; 6827 : 
; 6828 : 	PHeadSetB((LPBYTE)&pMsg, 0x3C, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 3c		 push	 60			; 0000003cH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6829 : 	pMsg.Flag = flag;

  00011	8a 45 0c	 mov	 al, BYTE PTR _flag$[ebp]
  00014	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 6830 : 
; 6831 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00017	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001b	50		 push	 eax
  0001c	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00023	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00028	83 c4 18	 add	 esp, 24			; 00000018H

; 6832 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GCTradeOkButtonSend@@YAHHE@Z ENDP			; GCTradeOkButtonSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCTradeMoneyOther@@YAHHK@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 8
_aIndex$ = 8						; size = 4
_money$ = 12						; size = 4
?GCTradeMoneyOther@@YAHHK@Z PROC			; GCTradeMoneyOther, COMDAT

; 6812 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 6813 : 	PMSG_TRADE_OTHER_GOLD pMsg;
; 6814 : 
; 6815 : 	PHeadSetB((LPBYTE)&pMsg, 0x3B, sizeof(pMsg));

  00006	6a 08		 push	 8
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 3b		 push	 59			; 0000003bH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6816 : 	pMsg.Money = money;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _money$[ebp]
  00016	89 45 fc	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 6817 : 
; 6818 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);	

  00019	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001d	50		 push	 eax
  0001e	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00021	50		 push	 eax
  00022	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00025	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002a	83 c4 18	 add	 esp, 24			; 00000018H

; 6819 : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?GCTradeMoneyOther@@YAHHK@Z ENDP			; GCTradeMoneyOther
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z
_TEXT	SEGMENT
_money$1$ = -8						; size = 4
tv328 = -4						; size = 4
_lpMsg$ = 8						; size = 4
_pMsg$ = 12						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z PROC	; CGTradeMoneyRecv, COMDAT

; 6734 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6735 : 	PMSG_DEFRESULT pMsg;
; 6736 : 	int money = 0;
; 6737 : 	int number;
; 6738 : 
; 6739 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00008	83 ec 08	 sub	 esp, 8
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00010	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00016	03 c3		 add	 eax, ebx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	0f 84 b6 00 00
	00		 je	 $LN11@CGTradeMon

; 6740 : 		return;
; 6741 : 
; 6742 : 	if ( !OBJMAX_RANGE(aIndex) )

  00029	85 f6		 test	 esi, esi
  0002b	0f 88 a0 01 00
	00		 js	 $LN17@CGTradeMon
  00031	33 c0		 xor	 eax, eax
  00033	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00039	0f 9e c0	 setle	 al
  0003c	85 c0		 test	 eax, eax
  0003e	0f 84 8d 01 00
	00		 je	 $LN17@CGTradeMon

; 6745 : 		return;
; 6746 : 	}
; 6747 : 
; 6748 : 	if ( gObj[aIndex].CloseType != -1 )

  00044	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004a	80 7c 13 0d ff	 cmp	 BYTE PTR [ebx+edx+13], -1
  0004f	8d 0c 13	 lea	 ecx, DWORD PTR [ebx+edx]
  00052	74 27		 je	 SHORT $LN4@CGTradeMon

; 6749 : 	{
; 6750 : 		LogAdd(lMsg.Get(MSGGET(1, 231)), gObj[aIndex].AccountID, gObj[aIndex].Name);

  00054	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00057	50		 push	 eax
  00058	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00060	50		 push	 eax
  00061	68 e7 01 00 00	 push	 487			; 000001e7H
  00066	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0006b	50		 push	 eax
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx

; 6798 : 	}
; 6799 : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN4@CGTradeMon:
  0007b	57		 push	 edi

; 6751 : 		return;
; 6752 : 	}
; 6753 : 
; 6754 : 	number = gObj[aIndex].TargetNumber;

  0007c	0f bf b9 38 06
	00 00		 movsx	 edi, WORD PTR [ecx+1592]

; 6755 : 
; 6756 : 	if ( !OBJMAX_RANGE(number) )

  00083	85 ff		 test	 edi, edi
  00085	0f 88 1d 01 00
	00		 js	 $LN18@CGTradeMon
  0008b	33 c0		 xor	 eax, eax
  0008d	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00093	0f 9e c0	 setle	 al
  00096	85 c0		 test	 eax, eax
  00098	0f 84 0a 01 00
	00		 je	 $LN18@CGTradeMon

; 6759 : 		return;
; 6760 : 	}
; 6761 : 
; 6762 : 	if ( gObj[number].CloseType != -1 )

  0009e	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  000a4	89 45 fc	 mov	 DWORD PTR tv328[ebp], eax
  000a7	80 7c 10 0d ff	 cmp	 BYTE PTR [eax+edx+13], -1
  000ac	74 37		 je	 SHORT $LN6@CGTradeMon

; 6763 : 	{
; 6764 : 		LogAdd(lMsg.Get(MSGGET(1, 233)), gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[number].AccountID, gObj[number].Name);

  000ae	83 c0 5d	 add	 eax, 93			; 0000005dH
  000b1	03 c2		 add	 eax, edx
  000b3	50		 push	 eax
  000b4	8b 45 fc	 mov	 eax, DWORD PTR tv328[ebp]
  000b7	83 c0 52	 add	 eax, 82			; 00000052H
  000ba	03 c2		 add	 eax, edx
  000bc	50		 push	 eax
  000bd	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000c0	50		 push	 eax
  000c1	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000c9	50		 push	 eax
  000ca	68 e9 01 00 00	 push	 489			; 000001e9H
  000cf	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000d4	50		 push	 eax
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000db	83 c4 14	 add	 esp, 20			; 00000014H
$LN19@CGTradeMon:
  000de	5f		 pop	 edi
$LN11@CGTradeMon:
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx

; 6798 : 	}
; 6799 : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
$LN6@CGTradeMon:

; 6765 : 		return;
; 6766 : 	}
; 6767 : 
; 6768 : 	if ( gObj[aIndex].m_IfState.use == FALSE && gObj[aIndex].m_IfState.type != 1 )

  000e5	8b 81 b8 11 00
	00		 mov	 eax, DWORD PTR [ecx+4536]
  000eb	a8 03		 test	 al, 3
  000ed	75 0a		 jne	 SHORT $LN7@CGTradeMon
  000ef	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000f4	83 f8 40	 cmp	 eax, 64			; 00000040H
  000f7	75 e5		 jne	 SHORT $LN19@CGTradeMon
$LN7@CGTradeMon:

; 6769 : 		return;
; 6770 : 
; 6771 : 	if ( ::gObjCanItemTouch(&gObj[aIndex], 1) == FALSE )

  000f9	6a 01		 push	 1
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00101	83 c4 08	 add	 esp, 8
  00104	85 c0		 test	 eax, eax
  00106	74 d6		 je	 SHORT $LN19@CGTradeMon

; 6772 : 		return;
; 6773 : 
; 6774 : 	if ( lpMsg->Money > 1000000000 )

  00108	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0010b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010e	89 4d f8	 mov	 DWORD PTR _money$1$[ebp], ecx
  00111	81 f9 00 ca 9a
	3b		 cmp	 ecx, 1000000000		; 3b9aca00H
  00117	77 c5		 ja	 SHORT $LN19@CGTradeMon

; 6775 : 		return;
; 6776 : 
; 6777 : 	money = lpMsg->Money;
; 6778 : 
; 6779 : 	if ( (gObj[aIndex].Money - money) < 0 )

  00119	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011e	8b 84 03 cc 00
	00 00		 mov	 eax, DWORD PTR [ebx+eax+204]
  00125	2b c1		 sub	 eax, ecx
  00127	78 b5		 js	 SHORT $LN19@CGTradeMon

; 6780 : 		return;
; 6781 : 
; 6782 : 	GCMoneySend(aIndex, gObj[aIndex].Money - money);

  00129	50		 push	 eax
  0012a	56		 push	 esi
  0012b	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 6783 : 
; 6784 : 	PHeadSetB((LPBYTE)&pMsg, 0x3A, sizeof(pMsg));

  00130	6a 04		 push	 4
  00132	8d 45 0c	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00135	6a 3a		 push	 58			; 0000003aH
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6785 : 	pMsg.result = 1;
; 6786 : 
; 6787 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0013d	0f b6 45 0d	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00141	50		 push	 eax
  00142	8d 45 0c	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00145	c6 45 0f 01	 mov	 BYTE PTR _pMsg$[ebp+3], 1
  00149	50		 push	 eax
  0014a	56		 push	 esi
  0014b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6788 : 
; 6789 : 	if ( number >= 0)
; 6790 : 	{
; 6791 : 		gObj[aIndex].TradeMoney = money;

  00150	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00155	8b 4d f8	 mov	 ecx, DWORD PTR _money$1$[ebp]

; 6792 : 		gObj[aIndex].TradeOk  = false;
; 6793 : 		gObj[number].TradeOk  = false;
; 6794 : 
; 6795 : 		GCTradeOkButtonSend(number, 2);

  00158	6a 02		 push	 2
  0015a	57		 push	 edi
  0015b	89 8c 03 f0 11
	00 00		 mov	 DWORD PTR [ebx+eax+4592], ecx
  00162	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00167	8b 4d fc	 mov	 ecx, DWORD PTR tv328[ebp]
  0016a	c6 84 03 f4 11
	00 00 00	 mov	 BYTE PTR [ebx+eax+4596], 0
  00172	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00177	c6 84 01 f4 11
	00 00 00	 mov	 BYTE PTR [ecx+eax+4596], 0
  0017f	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 6796 : 		GCTradeOkButtonSend(aIndex, 0);

  00184	6a 00		 push	 0
  00186	56		 push	 esi
  00187	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 6797 : 		GCTradeMoneyOther(number, gObj[aIndex].TradeMoney);

  0018c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00191	ff b4 03 f0 11
	00 00		 push	 DWORD PTR [ebx+eax+4592]
  00198	57		 push	 edi
  00199	e8 00 00 00 00	 call	 ?GCTradeMoneyOther@@YAHHK@Z ; GCTradeMoneyOther
  0019e	83 c4 38	 add	 esp, 56			; 00000038H
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	5b		 pop	 ebx

; 6798 : 	}
; 6799 : }

  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
$LN18@CGTradeMon:

; 6757 : 	{
; 6758 : 		LogAdd(lMsg.Get(MSGGET(1, 232)), gObj[aIndex].AccountID, gObj[aIndex].Name, number);

  001a8	57		 push	 edi
  001a9	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  001ac	50		 push	 eax
  001ad	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001b5	50		 push	 eax
  001b6	68 e8 01 00 00	 push	 488			; 000001e8H
  001bb	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001c0	50		 push	 eax
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001c7	83 c4 10	 add	 esp, 16			; 00000010H
  001ca	5f		 pop	 edi
  001cb	5e		 pop	 esi
  001cc	5b		 pop	 ebx

; 6798 : 	}
; 6799 : }

  001cd	8b e5		 mov	 esp, ebp
  001cf	5d		 pop	 ebp
  001d0	c3		 ret	 0
$LN17@CGTradeMon:

; 6743 : 	{
; 6744 : 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, aIndex);

  001d1	56		 push	 esi
  001d2	68 58 1a 00 00	 push	 6744			; 00001a58H
  001d7	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001e7	83 c4 10	 add	 esp, 16			; 00000010H
  001ea	5e		 pop	 esi
  001eb	5b		 pop	 ebx

; 6798 : 	}
; 6799 : }

  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c3		 ret	 0
?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z ENDP	; CGTradeMoneyRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCTradeOtherAdd@@YAHHEPAE@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_tradeindex$ = 12					; size = 1
_iteminfo$ = 16						; size = 4
?GCTradeOtherAdd@@YAHHEPAE@Z PROC			; GCTradeOtherAdd, COMDAT

; 6707 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6708 : 	PMSG_TRADE_OTHER_MOVE pMsg;
; 6709 : 
; 6710 : 	PHeadSetB((LPBYTE)&pMsg, 0x39, sizeof(pMsg));

  00010	6a 10		 push	 16			; 00000010H
  00012	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00015	6a 39		 push	 57			; 00000039H
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6711 : 	pMsg.TradeItemIndex = tradeindex;
; 6712 : 	pMsg.ItemInfo[I_TYPE] = iteminfo[I_TYPE];

  0001d	8b 4d 10	 mov	 ecx, DWORD PTR _iteminfo$[ebp]
  00020	8a 45 0c	 mov	 al, BYTE PTR _tradeindex$[ebp]
  00023	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+3], al
  00026	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00029	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 6713 : 	pMsg.ItemInfo[I_OPTION] = iteminfo[I_OPTION];

  0002c	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00030	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 6714 : 	pMsg.ItemInfo[I_DUR] = iteminfo[I_DUR];

  00033	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]
  00037	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 6715 : 	pMsg.ItemInfo[I_NOPTION] = iteminfo[I_NOPTION];

  0003a	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0003e	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+7], al

; 6716 : 	pMsg.ItemInfo[I_SOPTION] = iteminfo[I_SOPTION];

  00041	0f b6 41 04	 movzx	 eax, BYTE PTR [ecx+4]
  00045	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 6717 : 	pMsg.ItemInfo[5] = iteminfo[5];

  00048	0f b6 41 05	 movzx	 eax, BYTE PTR [ecx+5]
  0004c	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+9], al

; 6718 : 	pMsg.ItemInfo[6] = iteminfo[6];

  0004f	0f b6 41 06	 movzx	 eax, BYTE PTR [ecx+6]
  00053	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+10], al

; 6719 : 
; 6720 : 	pMsg.ItemInfo[7] = iteminfo[7];

  00056	0f b6 41 07	 movzx	 eax, BYTE PTR [ecx+7]
  0005a	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 6721 : 	pMsg.ItemInfo[8] = iteminfo[8];

  0005d	0f b6 41 08	 movzx	 eax, BYTE PTR [ecx+8]
  00061	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 6722 : 	pMsg.ItemInfo[9] = iteminfo[9];

  00064	0f b6 41 09	 movzx	 eax, BYTE PTR [ecx+9]
  00068	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+13], al

; 6723 : 	pMsg.ItemInfo[10] = iteminfo[10];

  0006b	0f b6 41 0a	 movzx	 eax, BYTE PTR [ecx+10]
  0006f	88 45 fa	 mov	 BYTE PTR _pMsg$[ebp+14], al

; 6724 : 	pMsg.ItemInfo[11] = iteminfo[11];

  00072	0f b6 41 0b	 movzx	 eax, BYTE PTR [ecx+11]
  00076	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+15], al

; 6725 : 	
; 6726 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00079	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0007d	50		 push	 eax
  0007e	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00081	50		 push	 eax
  00082	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00085	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6727 : }

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	83 c4 18	 add	 esp, 24			; 00000018H
  00090	33 cd		 xor	 ecx, ebp
  00092	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?GCTradeOtherAdd@@YAHHEPAE@Z ENDP			; GCTradeOtherAdd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCTradeOtherDel@@YAHHE@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_tradeindex$ = 12					; size = 1
?GCTradeOtherDel@@YAHHE@Z PROC				; GCTradeOtherDel, COMDAT

; 6687 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6688 : 	PMSG_TRADE_OTHER_DEL pMsg;
; 6689 : 
; 6690 : 	PHeadSetB((LPBYTE)&pMsg, 0x38, sizeof(pMsg ));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 38		 push	 56			; 00000038H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6691 : 	pMsg.TradeItemIndex = tradeindex;

  00011	8a 45 0c	 mov	 al, BYTE PTR _tradeindex$[ebp]
  00014	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 6692 : 
; 6693 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00017	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001b	50		 push	 eax
  0001c	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	50		 push	 eax
  00020	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00023	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00028	83 c4 18	 add	 esp, 24			; 00000018H

; 6694 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GCTradeOtherDel@@YAHHE@Z ENDP				; GCTradeOtherDel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCTradeResponseSend@@YAHEHPADGH@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_response$ = 8						; size = 1
_aIndex$ = 12						; size = 4
_id$ = 16						; size = 4
_level$ = 20						; size = 2
_GuildNumber$ = 24					; size = 4
?GCTradeResponseSend@@YAHEHPADGH@Z PROC			; GCTradeResponseSend, COMDAT

; 6666 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 10	 mov	 esi, DWORD PTR _id$[ebp]

; 6667 : 	PMSG_TRADE_RESPONSE pMsg;
; 6668 : 
; 6669 : 	PHeadSetB((LPBYTE)&pMsg, 0x37, sizeof(pMsg));

  00014	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 14		 push	 20			; 00000014H
  00019	6a 37		 push	 55			; 00000037H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6670 : 	pMsg.Response = response;

  00021	8a 45 08	 mov	 al, BYTE PTR _response$[ebp]

; 6671 : 	pMsg.Level = level;
; 6672 : 	pMsg.GuildNumber = GuildNumber;
; 6673 : 	memcpy(pMsg.Id, id, sizeof(pMsg.Id));

  00024	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]
  00028	88 45 eb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  0002b	66 8b 45 14	 mov	 ax, WORD PTR _level$[ebp]
  0002f	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+14], ax
  00033	8b 45 18	 mov	 eax, DWORD PTR _GuildNumber$[ebp]
  00036	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+16], eax
  00039	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  0003d	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+12], ax

; 6674 : 
; 6675 : 	return DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00041	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00045	50		 push	 eax
  00046	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00049	66 0f d6 45 ec	 movq	 QWORD PTR _pMsg$[ebp+4], xmm0
  0004e	50		 push	 eax
  0004f	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  00052	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6676 : }

  00057	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005a	83 c4 18	 add	 esp, 24			; 00000018H
  0005d	33 cd		 xor	 ecx, ebp
  0005f	5e		 pop	 esi
  00060	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?GCTradeResponseSend@@YAHEHPADGH@Z ENDP			; GCTradeResponseSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z
_TEXT	SEGMENT
tv849 = -16						; size = 4
tv840 = -12						; size = 4
tv856 = -8						; size = 4
tv847 = -8						; size = 4
tv841 = -8						; size = 4
tv831 = -8						; size = 4
tv828 = -8						; size = 4
tv822 = -8						; size = 4
tv820 = -8						; size = 4
_Result$2$ = -8						; size = 4
_number$1$ = -4						; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z PROC ; CGTradeResponseRecv, COMDAT

; 6492 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 6493 : 	BOOL Result = TRUE;
; 6494 : 	int number = gObj[aIndex].TargetNumber;

  00006	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000f	53		 push	 ebx

; 6495 : 
; 6496 : 	if ( OBJMAX_RANGE(aIndex) == FALSE )

  00010	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00013	56		 push	 esi
  00014	69 f2 40 27 00
	00		 imul	 esi, edx, 10048
  0001a	8d 04 0e	 lea	 eax, DWORD PTR [esi+ecx]
  0001d	89 45 f8	 mov	 DWORD PTR tv856[ebp], eax
  00020	57		 push	 edi
  00021	0f bf b8 38 06
	00 00		 movsx	 edi, WORD PTR [eax+1592]
  00028	89 7d fc	 mov	 DWORD PTR _number$1$[ebp], edi
  0002b	85 d2		 test	 edx, edx
  0002d	78 12		 js	 SHORT $LN43@CGTradeRes
  0002f	33 c0		 xor	 eax, eax
  00031	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  00037	0f 9e c0	 setle	 al
  0003a	85 c0		 test	 eax, eax
  0003c	75 2a		 jne	 SHORT $LN5@CGTradeRes
  0003e	8b 45 f8	 mov	 eax, DWORD PTR tv856[ebp]
$LN43@CGTradeRes:

; 6497 : 	{
; 6498 : 		LogAdd("error-L1 : %d (A_ID:%s) %s %d", number, gObj[aIndex].AccountID, __FILE__, __LINE__);

  00041	68 62 19 00 00	 push	 6498			; 00001962H
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0004b	83 c0 52	 add	 eax, 82			; 00000052H
  0004e	50		 push	 eax
  0004f	57		 push	 edi
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JKBNIPAM@error?9L1?5?3?5?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CFs?5?$CFd?$AA@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 6499 : 		Result = FALSE;
; 6500 : 		lpMsg->Response = false;

  0005b	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  0005f	83 c4 14	 add	 esp, 20			; 00000014H
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN5@CGTradeRes:

; 6501 : 	}
; 6502 : 
; 6503 : 	if ( OBJMAX_RANGE(number) == FALSE )

  00068	85 ff		 test	 edi, edi
  0006a	78 0f		 js	 SHORT $LN44@CGTradeRes
  0006c	33 c0		 xor	 eax, eax
  0006e	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00074	0f 9e c0	 setle	 al
  00077	85 c0		 test	 eax, eax
  00079	75 5f		 jne	 SHORT $LN6@CGTradeRes
$LN44@CGTradeRes:

; 6504 : 	{
; 6505 : 		if ( gObj[aIndex].m_IfState.use != FALSE )

  0007b	8d 86 b8 11 00
	00		 lea	 eax, DWORD PTR [esi+4536]
  00081	03 c1		 add	 eax, ecx
  00083	89 45 f8	 mov	 DWORD PTR tv847[ebp], eax
  00086	8b 10		 mov	 edx, DWORD PTR [eax]
  00088	f6 c2 03	 test	 dl, 3
  0008b	74 2a		 je	 SHORT $LN8@CGTradeRes

; 6506 : 		{
; 6507 : 			if ( gObj[aIndex].m_IfState.type == 1 )

  0008d	8b c2		 mov	 eax, edx
  0008f	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00094	83 f8 40	 cmp	 eax, 64			; 00000040H
  00097	75 1e		 jne	 SHORT $LN8@CGTradeRes

; 6508 : 			{
; 6509 : 				gObj[aIndex].m_IfState.use = FALSE;

  00099	8b 45 f8	 mov	 eax, DWORD PTR tv847[ebp]
  0009c	83 e2 fc	 and	 edx, -4			; fffffffcH

; 6510 : 				gObj[aIndex].TargetNumber = -1;

  0009f	83 c9 ff	 or	 ecx, -1
  000a2	89 10		 mov	 DWORD PTR [eax], edx
  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a9	66 89 8c 06 38
	06 00 00	 mov	 WORD PTR [esi+eax+1592], cx
  000b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN8@CGTradeRes:

; 6511 : 			}
; 6512 : 		}
; 6513 : 
; 6514 : 		LogAdd("error-L1 : target:%d (A_ID:%s) %s %d", number, gObj[aIndex].AccountID, __FILE__, __LINE__);

  000b7	68 72 19 00 00	 push	 6514			; 00001972H
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000c1	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  000c4	03 c1		 add	 eax, ecx
  000c6	50		 push	 eax
  000c7	57		 push	 edi
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HCOAINND@error?9L1?5?3?5target?3?$CFd?5?$CIA_ID?3?$CFs?$CJ?5?$CF@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d3	83 c4 14	 add	 esp, 20			; 00000014H

; 6515 : 		Result = FALSE;
; 6516 : 		lpMsg->Response = false;

  000d6	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
$LN6@CGTradeRes:

; 6517 : 	}
; 6518 : 
; 6519 : 	if ( gObjIsConnected(number) == FALSE )

  000da	57		 push	 edi
  000db	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000e0	83 c4 04	 add	 esp, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 03		 jne	 SHORT $LN9@CGTradeRes

; 6520 : 	{
; 6521 : 		Result = FALSE;
; 6522 : 		lpMsg->Response = false;

  000e7	88 43 03	 mov	 BYTE PTR [ebx+3], al
$LN9@CGTradeRes:

; 6523 : 	}
; 6524 : 	
; 6525 : 	if ( gObj[aIndex].CloseType != -1 )

  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f0	80 7c 0e 0d ff	 cmp	 BYTE PTR [esi+ecx+13], -1
  000f5	74 0a		 je	 SHORT $LN10@CGTradeRes

; 6526 : 	{
; 6527 : 		Result = FALSE;
; 6528 : 		lpMsg->Response = false;

  000f7	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN10@CGTradeRes:

; 6529 : 	}
; 6530 : 
; 6531 : 	if ( gObj[aIndex].m_bPShopOpen == true )

  00101	80 bc 0e 5c 12
	00 00 01	 cmp	 BYTE PTR [esi+ecx+4700], 1
  00109	75 0a		 jne	 SHORT $LN11@CGTradeRes

; 6532 : 	{
; 6533 : 		Result = FALSE;
; 6534 : 		lpMsg->Response = false;

  0010b	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  0010f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN11@CGTradeRes:

; 6535 : 	}
; 6536 : 
; 6537 : 	if ( gObj[number].m_bPShopOpen == true )

  00115	69 ff 40 27 00
	00		 imul	 edi, edi, 10048
  0011b	89 7d f4	 mov	 DWORD PTR tv840[ebp], edi
  0011e	80 bc 0f 5c 12
	00 00 01	 cmp	 BYTE PTR [edi+ecx+4700], 1
  00126	75 0a		 jne	 SHORT $LN12@CGTradeRes

; 6538 : 	{
; 6539 : 		Result = FALSE;
; 6540 : 		lpMsg->Response = false;

  00128	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  0012c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN12@CGTradeRes:

; 6541 : 	}
; 6542 : 
; 6543 : 	if ( gObj[aIndex].X < (gObj[number].X -2 ) || gObj[aIndex].X > (gObj[number].X +2 ) || gObj[aIndex].Y < (gObj[number].Y -2 ) || gObj[aIndex].Y > (gObj[number].Y +2 ) )

  00132	0f b6 94 0f 20
	01 00 00	 movzx	 edx, BYTE PTR [edi+ecx+288]
  0013a	0f b6 84 0e 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+288]
  00142	89 45 f8	 mov	 DWORD PTR tv831[ebp], eax
  00145	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]
  00148	39 45 f8	 cmp	 DWORD PTR tv831[ebp], eax
  0014b	7c 2b		 jl	 SHORT $LN14@CGTradeRes
  0014d	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00150	39 45 f8	 cmp	 DWORD PTR tv831[ebp], eax
  00153	7f 23		 jg	 SHORT $LN14@CGTradeRes
  00155	0f b6 94 0f 21
	01 00 00	 movzx	 edx, BYTE PTR [edi+ecx+289]
  0015d	0f b6 84 0e 21
	01 00 00	 movzx	 eax, BYTE PTR [esi+ecx+289]
  00165	89 45 f8	 mov	 DWORD PTR tv828[ebp], eax
  00168	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]
  0016b	39 45 f8	 cmp	 DWORD PTR tv828[ebp], eax
  0016e	7c 08		 jl	 SHORT $LN14@CGTradeRes
  00170	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00173	39 45 f8	 cmp	 DWORD PTR tv828[ebp], eax
  00176	7e 0a		 jle	 SHORT $LN13@CGTradeRes
$LN14@CGTradeRes:

; 6544 : 	{
; 6545 : 		Result = FALSE;
; 6546 : 		lpMsg->Response = false;

  00178	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0
  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN13@CGTradeRes:

; 6547 : 	}
; 6548 : 
; 6549 : 	if ( gObj[aIndex].m_IfState.use == FALSE || gObj[aIndex].m_IfState.type != 1 || gObj[aIndex].m_IfState.state != 0 )

  00182	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00185	89 55 f0	 mov	 DWORD PTR tv849[ebp], edx
  00188	8b 92 b8 11 00
	00		 mov	 edx, DWORD PTR [edx+4536]
  0018e	8b c2		 mov	 eax, edx
  00190	83 e0 03	 and	 eax, 3
  00193	89 45 f8	 mov	 DWORD PTR tv841[ebp], eax
  00196	0f 84 bf 03 00
	00		 je	 $LN16@CGTradeRes
  0019c	8b c2		 mov	 eax, edx
  0019e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  001a3	83 f8 40	 cmp	 eax, 64			; 00000040H
  001a6	0f 85 ac 03 00
	00		 jne	 $LN54@CGTradeRes
  001ac	f6 c2 3c	 test	 dl, 60			; 0000003cH
  001af	0f 85 a3 03 00
	00		 jne	 $LN54@CGTradeRes

; 6552 : 			gObj[aIndex].m_IfState.use, gObj[aIndex].m_IfState.type);
; 6553 : 
; 6554 : 		return;
; 6555 : 	}
; 6556 : 
; 6557 : 	if ( gObj[number].m_IfState.use == FALSE || gObj[number].m_IfState.type != 1 || gObj[number].m_IfState.state != 0 )

  001b5	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  001b8	8b 8a b8 11 00
	00		 mov	 ecx, DWORD PTR [edx+4536]
  001be	8b c1		 mov	 eax, ecx
  001c0	83 e0 03	 and	 eax, 3
  001c3	89 45 f8	 mov	 DWORD PTR tv822[ebp], eax
  001c6	0f 84 78 03 00
	00		 je	 $LN18@CGTradeRes
  001cc	8b c1		 mov	 eax, ecx
  001ce	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  001d3	83 f8 40	 cmp	 eax, 64			; 00000040H
  001d6	0f 85 65 03 00
	00		 jne	 $LN52@CGTradeRes
  001dc	f6 c1 3c	 test	 cl, 60			; 0000003cH
  001df	0f 85 5c 03 00
	00		 jne	 $LN52@CGTradeRes

; 6563 : 	}
; 6564 : 
; 6565 : 	if ( gObjFixInventoryPointer(aIndex) == false )

  001e5	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  001e8	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  001ed	83 c4 04	 add	 esp, 4
  001f0	84 c0		 test	 al, al
  001f2	75 18		 jne	 SHORT $LN19@CGTradeRes

; 6566 : 	{
; 6567 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  001f4	68 a7 19 00 00	 push	 6567			; 000019a7H
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001fe	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00209	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@CGTradeRes:

; 6568 : 	}
; 6569 : 
; 6570 : 	if ( gObj[aIndex].pTransaction == 1 )

  0020c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00212	80 bc 0e cc 11
	00 00 01	 cmp	 BYTE PTR [esi+ecx+4556], 1
  0021a	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  0021d	75 2c		 jne	 SHORT $LN20@CGTradeRes

; 6571 : 	{
; 6572 : 		LogAddTD("[%s][%s] CGTradeResponseRecv() Failed : Transaction == 1, IF_TYPE : %d",

  0021f	8b 82 b8 11 00
	00		 mov	 eax, DWORD PTR [edx+4536]
  00225	c1 e8 06	 shr	 eax, 6
  00228	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0022d	50		 push	 eax
  0022e	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00231	50		 push	 eax
  00232	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  00235	50		 push	 eax
  00236	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@CCMPCECD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeResponseRecv?$CI?$CJ?5F@
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00241	83 c4 10	 add	 esp, 16			; 00000010H
  00244	5f		 pop	 edi
  00245	5e		 pop	 esi
  00246	5b		 pop	 ebx

; 6655 : 			}
; 6656 : 		}
; 6657 : 	}
; 6658 : }

  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN20@CGTradeRes:

; 6573 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);
; 6574 : 
; 6575 : 		return;
; 6576 : 	}
; 6577 : 
; 6578 : 	if ( lpMsg->Response == false )

  0024b	80 7b 03 00	 cmp	 BYTE PTR [ebx+3], 0
  0024f	75 17		 jne	 SHORT $LN21@CGTradeRes

; 6579 : 	{
; 6580 : 		GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, 0, 0);

  00251	6a 00		 push	 0
  00253	6a 00		 push	 0
  00255	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00258	50		 push	 eax
  00259	ff 75 fc	 push	 DWORD PTR _number$1$[ebp]
  0025c	6a 00		 push	 0
  0025e	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 6581 : 		Result = FALSE;
; 6582 : 	}
; 6583 : 	else

  00263	e9 83 01 00 00	 jmp	 $LN57@CGTradeRes
$LN21@CGTradeRes:
  00268	8d 87 e8 11 00
	00		 lea	 eax, DWORD PTR [edi+4584]

; 6584 : 	{
; 6585 : 		Result = TRUE;

  0026e	33 ff		 xor	 edi, edi
  00270	8b d8		 mov	 ebx, eax
$LL4@CGTradeRes:

; 6586 : 
; 6587 : 		for ( int i=0;i<TRADE_BOX_SIZE;i++)
; 6588 : 		{
; 6589 : 			gObj[aIndex].Trade[i].Clear();

  00272	8b 8c 0e e8 11
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+4584]
  00279	03 cf		 add	 ecx, edi
  0027b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 6590 : 			gObj[number].Trade[i].Clear();

  00280	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00285	8b 0c 03	 mov	 ecx, DWORD PTR [ebx+eax]
  00288	03 cf		 add	 ecx, edi
  0028a	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  0028f	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00295	81 ff 80 1a 00
	00		 cmp	 edi, 6784		; 00001a80H
  0029b	7d 08		 jge	 SHORT $LN50@CGTradeRes

; 6584 : 	{
; 6585 : 		Result = TRUE;

  0029d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002a3	eb cd		 jmp	 SHORT $LL4@CGTradeRes
$LN50@CGTradeRes:

; 6591 : 		}
; 6592 : 
; 6593 : 		memset(gObj[aIndex].TradeMap, (BYTE)-1, TRADE_BOX_MAP_SIZE );

  002a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002aa	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff

; 6594 : 		memset(gObj[number].TradeMap, (BYTE)-1, TRADE_BOX_MAP_SIZE );

  002b1	8b 7d f4	 mov	 edi, DWORD PTR tv840[ebp]

; 6595 : 		gObj[aIndex].m_IfState.state = 1;
; 6596 : 		gObj[number].m_IfState.state = 1;
; 6597 : 		gObj[aIndex].TradeMoney = 0;
; 6598 : 		gObj[number].TradeMoney = 0;
; 6599 : 
; 6600 : 		if (::gObjInventoryTrans(aIndex) == FALSE )

  002b4	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  002b7	8b 84 06 ec 11
	00 00		 mov	 eax, DWORD PTR [esi+eax+4588]
  002be	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  002c1	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  002c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ca	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
  002d1	8b 84 07 ec 11
	00 00		 mov	 eax, DWORD PTR [edi+eax+4588]
  002d8	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  002db	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002e5	8b 84 31 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+esi+4536]
  002ec	83 e0 c7	 and	 eax, -57		; ffffffc7H
  002ef	83 c8 04	 or	 eax, 4
  002f2	89 84 31 b8 11
	00 00		 mov	 DWORD PTR [ecx+esi+4536], eax
  002f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ff	8b 84 39 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+edi+4536]
  00306	83 e0 c7	 and	 eax, -57		; ffffffc7H
  00309	83 c8 04	 or	 eax, 4
  0030c	89 84 39 b8 11
	00 00		 mov	 DWORD PTR [ecx+edi+4536], eax
  00313	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00318	c7 84 06 f0 11
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+eax+4592], 0
  00323	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00328	c7 84 07 f0 11
	00 00 00 00 00
	00		 mov	 DWORD PTR [edi+eax+4592], 0
  00333	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans

; 6601 : 			Result = 2;
; 6602 : 
; 6603 : 		if (::gObjInventoryTrans(number) == FALSE )

  00338	ff 75 fc	 push	 DWORD PTR _number$1$[ebp]
  0033b	85 c0		 test	 eax, eax
  0033d	b9 02 00 00 00	 mov	 ecx, 2
  00342	b8 01 00 00 00	 mov	 eax, 1
  00347	0f 44 c1	 cmove	 eax, ecx
  0034a	89 45 f8	 mov	 DWORD PTR _Result$2$[ebp], eax
  0034d	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans
  00352	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00355	83 c4 08	 add	 esp, 8
  00358	85 c0		 test	 eax, eax
  0035a	75 09		 jne	 SHORT $LN24@CGTradeRes

; 6604 : 			Result = 3;

  0035c	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _Result$2$[ebp], 3

; 6605 : 
; 6606 : 		if ( Result != TRUE )

  00363	eb 0a		 jmp	 SHORT $LN46@CGTradeRes
$LN24@CGTradeRes:
  00365	83 7d f8 01	 cmp	 DWORD PTR _Result$2$[ebp], 1
  00369	0f 84 4f 01 00
	00		 je	 $LN25@CGTradeRes
$LN46@CGTradeRes:

; 6607 : 		{
; 6608 : 			lpMsg->Response = false;

  0036f	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0

; 6609 : 			GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, 0, 0);

  00373	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00378	6a 00		 push	 0
  0037a	83 c0 5d	 add	 eax, 93			; 0000005dH
  0037d	6a 00		 push	 0
  0037f	03 c6		 add	 eax, esi
  00381	50		 push	 eax
  00382	ff 75 fc	 push	 DWORD PTR _number$1$[ebp]
  00385	6a 00		 push	 0
  00387	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 6610 : 			GCTradeResponseSend(lpMsg->Response, aIndex, gObj[number].Name, 0, 0);

  0038c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00391	6a 00		 push	 0
  00393	83 c0 5d	 add	 eax, 93			; 0000005dH
  00396	6a 00		 push	 0
  00398	03 c7		 add	 eax, edi
  0039a	50		 push	 eax
  0039b	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  0039e	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 6611 : 
; 6612 : 			if ( Result == 2 )

  003a8	8b 45 f8	 mov	 eax, DWORD PTR _Result$2$[ebp]
  003ab	83 c4 28	 add	 esp, 40			; 00000028H
  003ae	83 f8 02	 cmp	 eax, 2
  003b1	75 0d		 jne	 SHORT $LN27@CGTradeRes

; 6613 : 			{
; 6614 : 				LogAddTD("[%s][%s] Made Trade Error (in Transaction) [%s][%s]",

  003b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003b8	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  003bb	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]
  003be	eb 10		 jmp	 SHORT $LN58@CGTradeRes
$LN27@CGTradeRes:

; 6615 : 					gObj[aIndex].AccountID, gObj[aIndex].Name,
; 6616 : 					gObj[number].AccountID, gObj[number].Name);
; 6617 : 			}
; 6618 : 			else if ( Result == 3 )

  003c0	83 f8 03	 cmp	 eax, 3
  003c3	75 29		 jne	 SHORT $LN45@CGTradeRes

; 6619 : 			{
; 6620 : 				LogAddTD("[%s][%s] Made Trade Error (in Transaction) [%s][%s]",

  003c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003ca	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  003cd	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
$LN58@CGTradeRes:
  003d0	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  003d3	50		 push	 eax
  003d4	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  003d7	50		 push	 eax
  003d8	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  003db	50		 push	 eax
  003dc	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  003df	50		 push	 eax
  003e0	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KMOKLCNA@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Made?5Trade?5Error?5?$CIin?5Tr@
  003e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
$LN57@CGTradeRes:
  003eb	83 c4 14	 add	 esp, 20			; 00000014H
$LN45@CGTradeRes:

; 6634 : 				gObj[number].AccountID, gObj[number].Name,
; 6635 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 6636 : 		}
; 6637 : 	}
; 6638 : 
; 6639 : 	if ( Result == FALSE )
; 6640 : 	{
; 6641 : 		if ( gObj[aIndex].m_IfState.use != FALSE && gObj[aIndex].m_IfState.type == 1 )

  003ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003f4	8b 8c 16 b8 11
	00 00		 mov	 ecx, DWORD PTR [esi+edx+4536]
  003fb	8d 1c 16	 lea	 ebx, DWORD PTR [esi+edx]
  003fe	f6 c1 03	 test	 cl, 3
  00401	74 4b		 je	 SHORT $LN56@CGTradeRes
  00403	8b c1		 mov	 eax, ecx
  00405	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0040a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0040d	75 3f		 jne	 SHORT $LN56@CGTradeRes

; 6642 : 		{
; 6643 : 			gObj[aIndex].m_IfState.use = FALSE;

  0040f	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00412	89 8b b8 11 00
	00		 mov	 DWORD PTR [ebx+4536], ecx

; 6644 : 			gObj[aIndex].TargetNumber = -1;

  00418	83 cb ff	 or	 ebx, -1
  0041b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00420	66 89 9c 06 38
	06 00 00	 mov	 WORD PTR [esi+eax+1592], bx

; 6645 : 			LogAddTD("Interface State : %d", gObj[aIndex].m_IfState.use);

  00428	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0042d	8b 84 06 b8 11
	00 00		 mov	 eax, DWORD PTR [esi+eax+4536]
  00434	83 e0 03	 and	 eax, 3
  00437	50		 push	 eax
  00438	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@
  0043d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00443	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00449	83 c4 08	 add	 esp, 8
  0044c	eb 03		 jmp	 SHORT $LN31@CGTradeRes
$LN56@CGTradeRes:
  0044e	83 cb ff	 or	 ebx, -1
$LN31@CGTradeRes:

; 6646 : 		}
; 6647 : 
; 6648 : 		if ( gObj[number].TargetNumber == aIndex )

  00451	0f bf 84 17 38
	06 00 00	 movsx	 eax, WORD PTR [edi+edx+1592]
  00459	3b 45 0c	 cmp	 eax, DWORD PTR _aIndex$[ebp]
  0045c	0f 85 1d 01 00
	00		 jne	 $LN33@CGTradeRes

; 6649 : 		{
; 6650 : 			if ( gObj[number].m_IfState.use != FALSE && gObj[number].m_IfState.type == 1 )

  00462	8b 8c 17 b8 11
	00 00		 mov	 ecx, DWORD PTR [edi+edx+4536]
  00469	f6 c1 03	 test	 cl, 3
  0046c	0f 84 0d 01 00
	00		 je	 $LN33@CGTradeRes
  00472	8b c1		 mov	 eax, ecx
  00474	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00479	83 f8 40	 cmp	 eax, 64			; 00000040H
  0047c	0f 85 fd 00 00
	00		 jne	 $LN33@CGTradeRes

; 6651 : 			{
; 6652 : 				gObj[number].m_IfState.use = FALSE;

  00482	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00485	89 8c 17 b8 11
	00 00		 mov	 DWORD PTR [edi+edx+4536], ecx

; 6653 : 				gObj[number].TargetNumber = -1;

  0048c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00491	66 89 9c 07 38
	06 00 00	 mov	 WORD PTR [edi+eax+1592], bx

; 6654 : 				LogAddTD("Interface State : %d", gObj[number].m_IfState.use);

  00499	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0049e	8b 84 07 b8 11
	00 00		 mov	 eax, DWORD PTR [edi+eax+4536]
  004a5	83 e0 03	 and	 eax, 3
  004a8	50		 push	 eax
  004a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJPPKIGA@Interface?5State?5?3?5?$CFd?$AA@
  004ae	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004b4	83 c4 08	 add	 esp, 8
  004b7	5f		 pop	 edi
  004b8	5e		 pop	 esi
  004b9	5b		 pop	 ebx

; 6655 : 			}
; 6656 : 		}
; 6657 : 	}
; 6658 : }

  004ba	8b e5		 mov	 esp, ebp
  004bc	5d		 pop	 ebp
  004bd	c3		 ret	 0
$LN25@CGTradeRes:

; 6621 : 					gObj[number].AccountID, gObj[number].Name,
; 6622 : 					gObj[aIndex].AccountID, gObj[aIndex].Name);
; 6623 : 			}
; 6624 : 
; 6625 : 			Result = FALSE;
; 6626 : 		}
; 6627 : 		else
; 6628 : 		{
; 6629 : 			lpMsg->Response = true;

  004be	c6 43 03 01	 mov	 BYTE PTR [ebx+3], 1

; 6630 : 			GCTradeResponseSend(lpMsg->Response, number, gObj[aIndex].Name, gObj[aIndex].Level, gObj[aIndex].GuildNumber);

  004c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004c8	ff b4 31 14 06
	00 00		 push	 DWORD PTR [ecx+esi+1556]
  004cf	0f b7 84 31 96
	00 00 00	 movzx	 eax, WORD PTR [ecx+esi+150]
  004d7	50		 push	 eax
  004d8	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  004db	03 c6		 add	 eax, esi
  004dd	50		 push	 eax
  004de	ff 75 fc	 push	 DWORD PTR _number$1$[ebp]
  004e1	6a 01		 push	 1
  004e3	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 6631 : 			GCTradeResponseSend(lpMsg->Response, aIndex, gObj[number].Name, gObj[number].Level, gObj[number].GuildNumber);

  004e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004ee	ff b4 39 14 06
	00 00		 push	 DWORD PTR [ecx+edi+1556]
  004f5	0f b7 84 39 96
	00 00 00	 movzx	 eax, WORD PTR [ecx+edi+150]
  004fd	50		 push	 eax
  004fe	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00501	03 c7		 add	 eax, edi
  00503	50		 push	 eax
  00504	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  00507	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  0050b	50		 push	 eax
  0050c	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend

; 6632 : 
; 6633 : 			LogAddTD("[%s][%s] Trade Ready [%s][%s]", 

  00511	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00516	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00519	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  0051c	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0051f	50		 push	 eax
  00520	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00523	50		 push	 eax
  00524	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00527	50		 push	 eax
  00528	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  0052b	50		 push	 eax
  0052c	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GMBGLGLP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Trade?5Ready?5?$FL?$CFs?$FN?$FL?$CFs?$FN?$AA@
  00531	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00537	83 c4 3c	 add	 esp, 60			; 0000003cH
  0053a	5f		 pop	 edi
  0053b	5e		 pop	 esi
  0053c	5b		 pop	 ebx

; 6655 : 			}
; 6656 : 		}
; 6657 : 	}
; 6658 : }

  0053d	8b e5		 mov	 esp, ebp
  0053f	5d		 pop	 ebp
  00540	c3		 ret	 0
$LN52@CGTradeRes:
  00541	8b 45 f8	 mov	 eax, DWORD PTR tv822[ebp]
$LN18@CGTradeRes:

; 6558 : 	{
; 6559 : 		LogAddTD("(%s)(%s) Trade Interface State Error : use:%d type:%d", gObj[number].AccountID, gObj[number].Name, 

  00544	c1 e9 06	 shr	 ecx, 6
  00547	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0054d	51		 push	 ecx
  0054e	50		 push	 eax
  0054f	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00552	50		 push	 eax
  00553	8d 42 52	 lea	 eax, DWORD PTR [edx+82]

; 6560 : 			gObj[number].m_IfState.use, gObj[number].m_IfState.type);
; 6561 : 
; 6562 : 		return;

  00556	eb 18		 jmp	 SHORT $LN59@CGTradeRes
$LN54@CGTradeRes:
  00558	8b 45 f8	 mov	 eax, DWORD PTR tv841[ebp]
$LN16@CGTradeRes:

; 6550 : 	{
; 6551 : 		LogAddTD("(%s)(%s) Trade Interface State Error : use:%d type:%d", gObj[aIndex].AccountID, gObj[aIndex].Name, 

  0055b	8b 4d f0	 mov	 ecx, DWORD PTR tv849[ebp]
  0055e	c1 ea 06	 shr	 edx, 6
  00561	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00567	52		 push	 edx
  00568	50		 push	 eax
  00569	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0056c	50		 push	 eax
  0056d	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
$LN59@CGTradeRes:
  00570	50		 push	 eax
  00571	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@NABAHPDJ@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Trade?5Interface?5State?5E@
  00576	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0057c	83 c4 14	 add	 esp, 20			; 00000014H
$LN33@CGTradeRes:
  0057f	5f		 pop	 edi
  00580	5e		 pop	 esi
  00581	5b		 pop	 ebx

; 6655 : 			}
; 6656 : 		}
; 6657 : 	}
; 6658 : }

  00582	8b e5		 mov	 esp, ebp
  00584	5d		 pop	 ebp
  00585	c3		 ret	 0
?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ENDP ; CGTradeResponseRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z
_TEXT	SEGMENT
tv719 = -32						; size = 4
tv713 = -32						; size = 4
_lpObj$1$ = -28						; size = 4
tv715 = -24						; size = 4
_lpMsg$GSCopy$1$ = -24					; size = 4
_pMsg$ = -20						; size = 13
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z PROC	; CGTradeRequestSend, COMDAT

; 6332 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6333 : 	int number;
; 6334 : 
; 6335 : 	if (bCanTrade == FALSE )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bCanTrade@@3HA, 0 ; bCanTrade
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001f	89 7d e8	 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], edi
  00022	75 46		 jne	 SHORT $LN2@CGTradeReq

; 6336 : 	{
; 6337 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 125)), aIndex, 1);

  00024	6a 01		 push	 1
  00026	56		 push	 esi
  00027	68 7d 04 00 00	 push	 1149			; 0000047dH
  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00031	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6338 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 126)), aIndex, 1);

  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00044	6a 01		 push	 1
  00046	56		 push	 esi
  00047	68 7e 04 00 00	 push	 1150			; 0000047eH
  0004c	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN2@CGTradeReq:

; 6339 : 		return;
; 6340 : 	}
; 6341 : 
; 6342 : 	if ( gObj[aIndex].CloseType != -1 )

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	53		 push	 ebx
  00070	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00076	03 c3		 add	 eax, ebx
  00078	89 45 e4	 mov	 DWORD PTR _lpObj$1$[ebp], eax
  0007b	80 78 0d ff	 cmp	 BYTE PTR [eax+13], -1
  0007f	0f 85 c9 04 00
	00		 jne	 $LN52@CGTradeReq

; 6343 : 		return;
; 6344 : 
; 6345 : 	LPOBJ lpObj = &gObj[aIndex];
; 6346 : 
; 6347 : 	if ( !PacketCheckTime(lpObj))

  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0008b	83 c4 04	 add	 esp, 4
  0008e	85 c0		 test	 eax, eax
  00090	0f 84 b8 04 00
	00		 je	 $LN52@CGTradeReq

; 6348 : 		return;
; 6349 : 
; 6350 : 	number = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00096	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0009a	66 c1 e0 08	 shl	 ax, 8
  0009e	0f b7 f8	 movzx	 edi, ax
  000a1	8b 45 e8	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  000a4	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  000a8	0b f8		 or	 edi, eax

; 6351 : 
; 6352 : 	if ( OBJMAX_RANGE(number) == FALSE )

  000aa	0f 8c 85 04 00
	00		 jl	 $LN48@CGTradeReq
  000b0	33 c0		 xor	 eax, eax
  000b2	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  000b8	0f 9e c0	 setle	 al
  000bb	85 c0		 test	 eax, eax
  000bd	0f 84 72 04 00
	00		 je	 $LN48@CGTradeReq

; 6355 : 		return;
; 6356 : 	}
; 6357 : 
; 6358 : 	if ( number == aIndex )

  000c3	3b fe		 cmp	 edi, esi
  000c5	0f 84 83 04 00
	00		 je	 $LN52@CGTradeReq

; 6359 : 		return;
; 6360 : 
; 6361 : 	if ( !gObjIsConnected(number))

  000cb	57		 push	 edi
  000cc	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 84 72 04 00
	00		 je	 $LN52@CGTradeReq

; 6362 : 		return;
; 6363 : 
; 6364 : 	if ( gObj[number].Type == OBJ_MONSTER )

  000dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000e2	69 c7 40 27 00
	00		 imul	 eax, edi, 10048
  000e8	89 45 e8	 mov	 DWORD PTR tv715[ebp], eax
  000eb	80 7c 08 50 02	 cmp	 BYTE PTR [eax+ecx+80], 2
  000f0	0f 84 58 04 00
	00		 je	 $LN52@CGTradeReq

; 6365 : 		return;
; 6366 : 
; 6367 : 	if ( gObj[number].CloseCount >= 0 )

  000f6	80 7c 08 0c 00	 cmp	 BYTE PTR [eax+ecx+12], 0
  000fb	0f 8d 4d 04 00
	00		 jge	 $LN52@CGTradeReq

; 6368 : 		return;
; 6369 : 
; 6370 : #if (ENABLETEST_NEWPVP == 1)
; 6371 : 	if (g_NewPVP.IsDuel(gObj[aIndex]) || g_NewPVP.IsDuel(gObj[number])) {

  00101	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
  00104	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00109	50		 push	 eax
  0010a	89 45 e0	 mov	 DWORD PTR tv719[ebp], eax
  0010d	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  00112	85 c0		 test	 eax, eax
  00114	0f 85 ef 03 00
	00		 jne	 $LN11@CGTradeReq
  0011a	8b 45 e8	 mov	 eax, DWORD PTR tv715[ebp]
  0011d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00122	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  0012e	85 c0		 test	 eax, eax
  00130	0f 85 d3 03 00
	00		 jne	 $LN11@CGTradeReq

; 6373 : 		 return;
; 6374 : 	}
; 6375 : 
; 6376 : 	if (g_NewPVP.IsObserver(gObj[aIndex])) {

  00136	ff 75 e0	 push	 DWORD PTR tv719[ebp]
  00139	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0013e	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00143	85 c0		 test	 eax, eax
  00145	0f 85 be 03 00
	00		 jne	 $LN11@CGTradeReq

; 6377 : 		 GCServerMsgStringSend(lMsg.Get(MSGGET(2, 199)), aIndex, 1);
; 6378 : 		 return;
; 6379 : 	}
; 6380 : #endif
; 6381 : 
; 6382 : 	if ( DS_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  0014b	8b 45 e8	 mov	 eax, DWORD PTR tv715[ebp]
  0014e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00154	03 c2		 add	 eax, edx
  00156	89 45 e0	 mov	 DWORD PTR tv713[ebp], eax
  00159	8a 88 23 01 00
	00		 mov	 cl, BYTE PTR [eax+291]
  0015f	80 f9 09	 cmp	 cl, 9
  00162	0f 84 a1 03 00
	00		 je	 $LN11@CGTradeReq
  00168	33 c0		 xor	 eax, eax
  0016a	80 f9 20	 cmp	 cl, 32			; 00000020H
  0016d	0f 94 c0	 sete	 al
  00170	85 c0		 test	 eax, eax
  00172	0f 85 91 03 00
	00		 jne	 $LN11@CGTradeReq

; 6383 : 	{
; 6384 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(2, 199)), aIndex, 1);
; 6385 : 		return;
; 6386 : 	}
; 6387 : 
; 6388 : 	if ( IT_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  00178	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  0017b	72 2f		 jb	 SHORT $LN14@CGTradeReq
  0017d	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  00182	3a c1		 cmp	 al, cl
  00184	1b c0		 sbb	 eax, eax
  00186	83 c0 01	 add	 eax, 1
  00189	74 21		 je	 SHORT $LN14@CGTradeReq

; 6389 : 	{
; 6390 : 		::GCServerMsgStringSend("You cannot trade inside Illusion Temple.", aIndex, 1);

  0018b	6a 01		 push	 1
  0018d	56		 push	 esi
  0018e	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@GFPCHONE@You?5cannot?5trade?5inside?5Illusion@
  00193	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00198	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019b	5b		 pop	 ebx
  0019c	5f		 pop	 edi
  0019d	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  0019e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a1	33 cd		 xor	 ecx, ebp
  001a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
$LN14@CGTradeReq:

; 6391 : 		return;
; 6392 : 	}
; 6393 : 
; 6394 : 	if ( DG_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  001ac	80 f9 41	 cmp	 cl, 65			; 00000041H
  001af	72 2f		 jb	 SHORT $LN15@CGTradeReq
  001b1	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  001b6	3a c1		 cmp	 al, cl
  001b8	1b c0		 sbb	 eax, eax
  001ba	83 c0 01	 add	 eax, 1
  001bd	74 21		 je	 SHORT $LN15@CGTradeReq

; 6395 : 	{
; 6396 : 		::GCServerMsgStringSend("You cannot trade inside Doppelganger.", aIndex, 1);

  001bf	6a 01		 push	 1
  001c1	56		 push	 esi
  001c2	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@MDHDJBIA@You?5cannot?5trade?5inside?5Doppelga@
  001c7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001cf	5b		 pop	 ebx
  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  001d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d5	33 cd		 xor	 ecx, ebp
  001d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c3		 ret	 0
$LN15@CGTradeReq:

; 6397 : 		return;
; 6398 : 	}
; 6399 : 
; 6400 : 	if ( IF_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  001e0	80 f9 45	 cmp	 cl, 69			; 00000045H
  001e3	72 2f		 jb	 SHORT $LN16@CGTradeReq
  001e5	b8 48 00 00 00	 mov	 eax, 72			; 00000048H
  001ea	3a c1		 cmp	 al, cl
  001ec	1b c0		 sbb	 eax, eax
  001ee	83 c0 01	 add	 eax, 1
  001f1	74 21		 je	 SHORT $LN16@CGTradeReq

; 6401 : 	{
; 6402 : 		::GCServerMsgStringSend("You cannot trade inside Imperial Fort.", aIndex, 1);

  001f3	6a 01		 push	 1
  001f5	56		 push	 esi
  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BFADMIPH@You?5cannot?5trade?5inside?5Imperial@
  001fb	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00200	83 c4 0c	 add	 esp, 12			; 0000000cH
  00203	5b		 pop	 ebx
  00204	5f		 pop	 edi
  00205	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  00206	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00209	33 cd		 xor	 ecx, ebp
  0020b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c3		 ret	 0
$LN16@CGTradeReq:

; 6403 : 		return;
; 6404 : 	}
; 6405 : 
; 6406 : 	if ( gObj[aIndex].m_bPShopOpen == true )

  00214	80 bc 13 5c 12
	00 00 01	 cmp	 BYTE PTR [ebx+edx+4700], 1
  0021c	0f 84 2c 03 00
	00		 je	 $LN52@CGTradeReq

; 6407 : 		return;
; 6408 : 
; 6409 : 	if ( gObj[number].m_bPShopOpen == true )

  00222	8b 45 e0	 mov	 eax, DWORD PTR tv713[ebp]
  00225	80 b8 5c 12 00
	00 01		 cmp	 BYTE PTR [eax+4700], 1
  0022c	0f 84 1c 03 00
	00		 je	 $LN52@CGTradeReq

; 6410 : 		return;
; 6411 : 
; 6412 : 	if ( CC_MAP_RANGE(gObj[number].MapNumber) != FALSE )

  00232	80 f9 35	 cmp	 cl, 53			; 00000035H
  00235	0f 84 c4 02 00
	00		 je	 $LN50@CGTradeReq
  0023b	80 f9 12	 cmp	 cl, 18			; 00000012H
  0023e	72 0f		 jb	 SHORT $LN19@CGTradeReq
  00240	b0 17		 mov	 al, 23			; 00000017H
  00242	3a c1		 cmp	 al, cl
  00244	1b c0		 sbb	 eax, eax
  00246	83 c0 01	 add	 eax, 1
  00249	0f 85 b0 02 00
	00		 jne	 $LN50@CGTradeReq
$LN19@CGTradeReq:

; 6416 : 	}
; 6417 : 
; 6418 : 	if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) != FALSE )

  0024f	8a 8c 13 23 01
	00 00		 mov	 cl, BYTE PTR [ebx+edx+291]
  00256	80 f9 34	 cmp	 cl, 52			; 00000034H
  00259	74 10		 je	 SHORT $LN51@CGTradeReq
  0025b	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0025e	72 56		 jb	 SHORT $LN21@CGTradeReq
  00260	b0 11		 mov	 al, 17			; 00000011H
  00262	3a c1		 cmp	 al, cl
  00264	1b c0		 sbb	 eax, eax
  00266	83 c0 01	 add	 eax, 1
  00269	74 4b		 je	 SHORT $LN21@CGTradeReq
$LN51@CGTradeReq:

; 6419 : 	{
; 6420 : 		if ( g_BloodCastle.GetCurrentState(g_BloodCastle.GetBridgeLevel(gObj[aIndex].MapNumber)) != 1 || g_BloodCastle.CheckCanEnter(gObj[aIndex].MapNumber-MAP_INDEX_BLOODCASTLE1) == false )

  0026b	0f b6 c1	 movzx	 eax, cl
  0026e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel
  00279	50		 push	 eax
  0027a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0027f	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00284	83 f8 01	 cmp	 eax, 1
  00287	0f 85 68 02 00
	00		 jne	 $LN22@CGTradeReq
  0028d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00292	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00297	0f b6 84 03 23
	01 00 00	 movzx	 eax, BYTE PTR [ebx+eax+291]
  0029f	83 e8 0b	 sub	 eax, 11			; 0000000bH
  002a2	50		 push	 eax
  002a3	e8 00 00 00 00	 call	 ?CheckCanEnter@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckCanEnter
  002a8	84 c0		 test	 al, al
  002aa	0f 84 45 02 00
	00		 je	 $LN22@CGTradeReq
  002b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN21@CGTradeReq:

; 6424 : 		}	
; 6425 : 	}
; 6426 : 
; 6427 : 	if ( gObj[aIndex].MapNumber == MAP_INDEX_PKFIELD )

  002b6	80 bc 13 23 01
	00 00 40	 cmp	 BYTE PTR [ebx+edx+291], 64 ; 00000040H
  002be	75 21		 jne	 SHORT $LN23@CGTradeReq

; 6428 : 	{
; 6429 : 		::GCServerMsgStringSend("Trade not allowed on duel arena", aIndex, 1);

  002c0	6a 01		 push	 1
  002c2	56		 push	 esi
  002c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@CHOLFFAK@Trade?5not?5allowed?5on?5duel?5arena?$AA@
  002c8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  002d0	5b		 pop	 ebx
  002d1	5f		 pop	 edi
  002d2	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  002d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d6	33 cd		 xor	 ecx, ebp
  002d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002dd	8b e5		 mov	 esp, ebp
  002df	5d		 pop	 ebp
  002e0	c3		 ret	 0
$LN23@CGTradeReq:

; 6430 : 		return;
; 6431 : 	}
; 6432 : 
; 6433 : 	if ( (gObj[number].m_Option &1) != 1 )

  002e1	8b 45 e8	 mov	 eax, DWORD PTR tv715[ebp]
  002e4	f6 84 10 24 12
	00 00 01	 test	 BYTE PTR [eax+edx+4644], 1
  002ec	75 26		 jne	 SHORT $LN24@CGTradeReq

; 6434 : 	{
; 6435 : 		::GCTradeResponseSend(0, aIndex, gObj[number].Name, 0, 0);

  002ee	6a 00		 push	 0
  002f0	83 c0 5d	 add	 eax, 93			; 0000005dH
  002f3	6a 00		 push	 0
  002f5	03 c2		 add	 eax, edx
  002f7	50		 push	 eax
  002f8	56		 push	 esi
  002f9	6a 00		 push	 0
  002fb	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  00300	83 c4 14	 add	 esp, 20			; 00000014H
  00303	5b		 pop	 ebx
  00304	5f		 pop	 edi
  00305	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  00306	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00309	33 cd		 xor	 ecx, ebp
  0030b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00310	8b e5		 mov	 esp, ebp
  00312	5d		 pop	 ebp
  00313	c3		 ret	 0
$LN24@CGTradeReq:

; 6436 : 		return;
; 6437 : 	}
; 6438 : 
; 6439 : 	if ( lpObj->m_IfState.use > 0 )

  00314	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$1$[ebp]
  00317	f6 81 b8 11 00
	00 03		 test	 BYTE PTR [ecx+4536], 3
  0031e	76 26		 jbe	 SHORT $LN25@CGTradeReq

; 6440 : 	{
; 6441 : 		::GCTradeResponseSend(3, aIndex, gObj[number].Name, 0, 0);

  00320	6a 00		 push	 0
  00322	83 c0 5d	 add	 eax, 93			; 0000005dH
  00325	6a 00		 push	 0
  00327	03 c2		 add	 eax, edx
  00329	50		 push	 eax
  0032a	56		 push	 esi
  0032b	6a 03		 push	 3
  0032d	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  00332	83 c4 14	 add	 esp, 20			; 00000014H
  00335	5b		 pop	 ebx
  00336	5f		 pop	 edi
  00337	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  00338	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033b	33 cd		 xor	 ecx, ebp
  0033d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00342	8b e5		 mov	 esp, ebp
  00344	5d		 pop	 ebp
  00345	c3		 ret	 0
$LN25@CGTradeReq:

; 6442 : 		return;
; 6443 : 	}
; 6444 : 
; 6445 : 	if (gObj[number].m_IfState.use > 0 )

  00346	f6 84 10 b8 11
	00 00 03	 test	 BYTE PTR [eax+edx+4536], 3
  0034e	76 26		 jbe	 SHORT $LN26@CGTradeReq

; 6446 : 	{
; 6447 : 		::GCTradeResponseSend(2, aIndex, gObj[number].Name, 0, 0);

  00350	6a 00		 push	 0
  00352	83 c0 5d	 add	 eax, 93			; 0000005dH
  00355	6a 00		 push	 0
  00357	03 c2		 add	 eax, edx
  00359	50		 push	 eax
  0035a	56		 push	 esi
  0035b	6a 02		 push	 2
  0035d	e8 00 00 00 00	 call	 ?GCTradeResponseSend@@YAHEHPADGH@Z ; GCTradeResponseSend
  00362	83 c4 14	 add	 esp, 20			; 00000014H
  00365	5b		 pop	 ebx
  00366	5f		 pop	 edi
  00367	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  00368	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0036b	33 cd		 xor	 ecx, ebp
  0036d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00372	8b e5		 mov	 esp, ebp
  00374	5d		 pop	 ebp
  00375	c3		 ret	 0
$LN26@CGTradeReq:

; 6448 : 		return;
; 6449 : 	}
; 6450 : 
; 6451 : 	if ( ::gObjFixInventoryPointer(aIndex) == false )

  00376	56		 push	 esi
  00377	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0037c	83 c4 04	 add	 esp, 4
  0037f	84 c0		 test	 al, al
  00381	75 18		 jne	 SHORT $LN27@CGTradeReq

; 6452 : 	{
; 6453 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  00383	68 35 19 00 00	 push	 6453			; 00001935H
  00388	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0038d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00392	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00398	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@CGTradeReq:

; 6454 : 	}
; 6455 : 
; 6456 : 	if ( gObj[aIndex].pTransaction == 1 )

  0039b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003a1	03 cb		 add	 ecx, ebx
  003a3	80 b9 cc 11 00
	00 01		 cmp	 BYTE PTR [ecx+4556], 1
  003aa	75 36		 jne	 SHORT $LN28@CGTradeReq

; 6457 : 	{
; 6458 : 		LogAddTD("[%s][%s] CGTradeRequestSend() Failed : Transaction == 1, IF_TYPE : %d",

  003ac	8b 81 b8 11 00
	00		 mov	 eax, DWORD PTR [ecx+4536]
  003b2	c1 e8 06	 shr	 eax, 6
  003b5	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  003ba	50		 push	 eax
  003bb	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  003be	50		 push	 eax
  003bf	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  003c2	50		 push	 eax
  003c3	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@MCMMANNG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGTradeRequestSend?$CI?$CJ?5Fa@
  003c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003ce	83 c4 10	 add	 esp, 16			; 00000010H
  003d1	5b		 pop	 ebx
  003d2	5f		 pop	 edi
  003d3	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  003d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d7	33 cd		 xor	 ecx, ebp
  003d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003de	8b e5		 mov	 esp, ebp
  003e0	5d		 pop	 ebp
  003e1	c3		 ret	 0
$LN28@CGTradeReq:

; 6459 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);
; 6460 : 
; 6461 : 		return;
; 6462 : 	}
; 6463 : 
; 6464 : 	lpObj->m_IfState.use = 1;
; 6465 : 	lpObj->m_IfState.state = 0;
; 6466 : 	lpObj->m_IfState.type = 1;

  003e2	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$1$[ebp]

; 6467 : 	lpObj->TargetNumber = number;
; 6468 : 	gObj[number].m_IfState.use = 1;

  003e5	8b 55 e8	 mov	 edx, DWORD PTR tv715[ebp]
  003e8	8b 81 b8 11 00
	00		 mov	 eax, DWORD PTR [ecx+4536]
  003ee	25 41 00 ff ff	 and	 eax, -65471		; ffff0041H
  003f3	66 89 b9 38 06
	00 00		 mov	 WORD PTR [ecx+1592], di
  003fa	83 c8 41	 or	 eax, 65			; 00000041H
  003fd	89 81 b8 11 00
	00		 mov	 DWORD PTR [ecx+4536], eax
  00403	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00409	8b 84 11 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+edx+4536]
  00410	83 e0 fd	 and	 eax, -3			; fffffffdH
  00413	83 c8 01	 or	 eax, 1
  00416	89 84 11 b8 11
	00 00		 mov	 DWORD PTR [ecx+edx+4536], eax

; 6469 : 	gObj[number].m_IfState.state = 0;

  0041d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00422	83 a4 02 b8 11
	00 00 c3	 and	 DWORD PTR [edx+eax+4536], -61 ; ffffffc3H

; 6470 : 	gObj[number].m_IfState.type = 1;

  0042a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00430	8b 84 11 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+edx+4536]
  00437	25 7f 00 ff ff	 and	 eax, -65409		; ffff007fH
  0043c	83 c8 40	 or	 eax, 64			; 00000040H
  0043f	89 84 11 b8 11
	00 00		 mov	 DWORD PTR [ecx+edx+4536], eax

; 6471 : 	gObj[number].TargetNumber = aIndex;

  00446	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0044b	66 89 b4 02 38
	06 00 00	 mov	 WORD PTR [edx+eax+1592], si

; 6472 : 	lpObj->m_InterfaceTime = GetTickCount();

  00453	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  00459	ff d6		 call	 esi
  0045b	8b 4d e4	 mov	 ecx, DWORD PTR _lpObj$1$[ebp]
  0045e	89 81 bc 11 00
	00		 mov	 DWORD PTR [ecx+4540], eax

; 6473 : 	gObj[number].m_InterfaceTime = GetTickCount();

  00464	ff d6		 call	 esi
  00466	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0046c	8b 75 e8	 mov	 esi, DWORD PTR tv715[ebp]

; 6474 : 
; 6475 : 	PMSG_TRADE_REQUESTSEND pMsg;
; 6476 : 
; 6477 : 	pMsg.h.c = 0xC3;
; 6478 : 	pMsg.h.headcode = 0x36;
; 6479 : 	pMsg.h.size = sizeof(pMsg);
; 6480 : 	memcpy(pMsg.szId, gObj[aIndex].Name, sizeof(pMsg.szId));
; 6481 : 
; 6482 : 	DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);

  0046f	6a 0d		 push	 13			; 0000000dH
  00471	89 84 0e bc 11
	00 00		 mov	 DWORD PTR [esi+ecx+4540], eax
  00478	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0047d	66 c7 45 ec c3
	0d		 mov	 WORD PTR _pMsg$[ebp], 3523 ; 00000dc3H
  00483	c6 45 ee 36	 mov	 BYTE PTR _pMsg$[ebp+2], 54 ; 00000036H
  00487	f3 0f 7e 44 03
	5d		 movq	 xmm0, QWORD PTR [ebx+eax+93]
  0048d	66 0f d6 45 ef	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  00492	66 8b 44 03 65	 mov	 ax, WORD PTR [ebx+eax+101]
  00497	66 89 45 f7	 mov	 WORD PTR _pMsg$[ebp+11], ax
  0049b	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0049e	50		 push	 eax
  0049f	57		 push	 edi
  004a0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 6483 : 
; 6484 : 	LogAddTD(lMsg.Get(MSGGET(1, 230)), gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Ip_addr,

  004a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ad	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  004b0	8d 14 03	 lea	 edx, DWORD PTR [ebx+eax]
  004b3	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  004b6	50		 push	 eax
  004b7	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  004ba	50		 push	 eax
  004bb	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  004be	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004c3	50		 push	 eax
  004c4	8d 42 1c	 lea	 eax, DWORD PTR [edx+28]
  004c7	50		 push	 eax
  004c8	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  004cb	50		 push	 eax
  004cc	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  004cf	50		 push	 eax
  004d0	68 e6 01 00 00	 push	 486			; 000001e6H
  004d5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  004da	50		 push	 eax
  004db	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004e1	83 c4 1c	 add	 esp, 28			; 0000001cH
  004e4	5b		 pop	 ebx
  004e5	5f		 pop	 edi
  004e6	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  004e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ea	33 cd		 xor	 ecx, ebp
  004ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004f1	8b e5		 mov	 esp, ebp
  004f3	5d		 pop	 ebp
  004f4	c3		 ret	 0
$LN22@CGTradeReq:

; 6421 : 		{
; 6422 : 			::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 188)), aIndex, 1);

  004f5	6a 01		 push	 1
  004f7	56		 push	 esi
  004f8	68 bc 04 00 00	 push	 1212			; 000004bcH

; 6423 : 			return;

  004fd	eb 12		 jmp	 SHORT $LN54@CGTradeReq
$LN50@CGTradeReq:

; 6413 : 	{
; 6414 : 		::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 196)), aIndex, 1);

  004ff	6a 01		 push	 1
  00501	56		 push	 esi
  00502	68 c4 04 00 00	 push	 1220			; 000004c4H

; 6415 : 		return;

  00507	eb 08		 jmp	 SHORT $LN54@CGTradeReq
$LN11@CGTradeReq:

; 6372 : 		 GCServerMsgStringSend(lMsg.Get(MSGGET(2, 199)), aIndex, 1);

  00509	6a 01		 push	 1
  0050b	56		 push	 esi
  0050c	68 c7 02 00 00	 push	 711			; 000002c7H
$LN54@CGTradeReq:
  00511	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00516	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0051b	50		 push	 eax
  0051c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00521	83 c4 0c	 add	 esp, 12			; 0000000cH
  00524	5b		 pop	 ebx
  00525	5f		 pop	 edi
  00526	5e		 pop	 esi

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  00527	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0052a	33 cd		 xor	 ecx, ebp
  0052c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00531	8b e5		 mov	 esp, ebp
  00533	5d		 pop	 ebp
  00534	c3		 ret	 0
$LN48@CGTradeReq:

; 6353 : 	{
; 6354 : 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, number);

  00535	57		 push	 edi
  00536	68 d2 18 00 00	 push	 6354			; 000018d2H
  0053b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00540	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  00545	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0054b	83 c4 10	 add	 esp, 16			; 00000010H
$LN52@CGTradeReq:

; 6485 : 		gObj[number].AccountID, gObj[number].Name, gObj[number].Ip_addr);
; 6486 : }

  0054e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00551	5b		 pop	 ebx
  00552	5f		 pop	 edi
  00553	33 cd		 xor	 ecx, ebp
  00555	5e		 pop	 esi
  00556	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0055b	8b e5		 mov	 esp, ebp
  0055d	5d		 pop	 ebp
  0055e	c3		 ret	 0
?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ENDP	; CGTradeRequestSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 8
_lpMsg$ = 8						; size = 4
_n$1$ = 12						; size = 4
_aIndex$ = 12						; size = 4
?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z PROC ; CGModifyRequestItem, COMDAT

; 6202 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 6203 : 	LPOBJ lpObj = &gObj[aIndex];

  00007	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 6204 : 	PMSG_ITEMDURREPAIR_RESULT pResult;
; 6205 : 
; 6206 : 	PHeadSetB((LPBYTE)&pResult, 0x34, sizeof(pResult));

  0000d	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00014	57		 push	 edi
  00015	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  0001b	6a 08		 push	 8
  0001d	6a 34		 push	 52			; 00000034H
  0001f	50		 push	 eax
  00020	03 df		 add	 ebx, edi
  00022	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6207 : 	pResult.Money = 0;
; 6208 : 
; 6209 : 
; 6210 : 	if ( gObj[aIndex].CloseType != -1 )

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
  00036	80 7c 07 0d ff	 cmp	 BYTE PTR [edi+eax+13], -1
  0003b	75 2d		 jne	 SHORT $LN43@CGModifyRe

; 6211 : 	{
; 6212 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6213 : 		return;
; 6214 : 	}
; 6215 : 
; 6216 : 	if ( !PacketCheckTime(lpObj))

  0003d	53		 push	 ebx
  0003e	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00043	83 c4 04	 add	 esp, 4
  00046	85 c0		 test	 eax, eax
  00048	74 20		 je	 SHORT $LN43@CGModifyRe

; 6217 : 	{
; 6218 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 6219 : 		return;
; 6220 : 	}
; 6221 : 
; 6222 : 	if (lpMsg->Requestpos == 1 && gObj[aIndex].Level < 50 )

  0004a	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0004d	80 78 04 01	 cmp	 BYTE PTR [eax+4], 1
  00051	75 30		 jne	 SHORT $LN7@CGModifyRe
  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00058	66 83 bc 07 96
	00 00 00 32	 cmp	 WORD PTR [edi+eax+150], 50 ; 00000032H
  00061	7d 20		 jge	 SHORT $LN7@CGModifyRe

; 6223 : 	{
; 6224 : 		pResult.Money = 0;

  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
$LN43@CGModifyRe:

; 6225 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0006a	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0006e	50		 push	 eax
  0006f	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00072	50		 push	 eax
  00073	56		 push	 esi
  00074	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx

; 6317 : }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
$LN7@CGModifyRe:

; 6226 : 		return;
; 6227 : 	}
; 6228 : 
; 6229 : 	if ( lpMsg->Position == 0xFF )

  00083	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00086	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00089	3c ff		 cmp	 al, 255			; 000000ffH
  0008b	0f 85 72 01 00
	00		 jne	 $LN8@CGModifyRe

; 6230 : 	{
; 6231 : 		for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00091	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _n$1$[ebp], 0
  00098	33 f6		 xor	 esi, esi
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL4@CGModifyRe:

; 6232 : 		{
; 6233 : 			if ( lpObj->pInventory[n].IsItem())

  000a0	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  000a6	03 ce		 add	 ecx, esi
  000a8	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ad	85 c0		 test	 eax, eax
  000af	0f 84 28 01 00
	00		 je	 $LN2@CGModifyRe

; 6234 : 			{
; 6235 : 				if ( IsCashItem(lpObj->pInventory[n].m_Type ) == TRUE )

  000b5	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  000bb	0f bf 44 06 06	 movsx	 eax, WORD PTR [esi+eax+6]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ?IsCashItem@@YAHH@Z	; IsCashItem
  000c6	83 c4 04	 add	 esp, 4
  000c9	83 f8 01	 cmp	 eax, 1
  000cc	0f 84 0b 01 00
	00		 je	 $LN2@CGModifyRe

; 6236 : 					continue;
; 6237 : 
; 6238 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,20) && (lpObj->pInventory[n].m_Level == 0 ||lpObj->pInventory[n].m_Level == 1 ))

  000d2	8b 93 c0 11 00
	00		 mov	 edx, DWORD PTR [ebx+4544]
  000d8	b9 14 1a 00 00	 mov	 ecx, 6676		; 00001a14H
  000dd	03 d6		 add	 edx, esi
  000df	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  000e3	66 3b c1	 cmp	 ax, cx
  000e6	75 2c		 jne	 SHORT $LN13@CGModifyRe
  000e8	0f b7 4a 08	 movzx	 ecx, WORD PTR [edx+8]
  000ec	66 85 c9	 test	 cx, cx
  000ef	0f 84 e8 00 00
	00		 je	 $LN2@CGModifyRe
  000f5	66 83 f9 01	 cmp	 cx, 1
  000f9	0f 84 de 00 00
	00		 je	 $LN2@CGModifyRe

; 6239 : 					continue;
; 6240 : 
; 6241 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,20) && lpObj->pInventory[n].m_Level == 2 )

  000ff	b9 14 1a 00 00	 mov	 ecx, 6676		; 00001a14H
  00104	66 3b c1	 cmp	 ax, cx
  00107	75 0b		 jne	 SHORT $LN13@CGModifyRe
  00109	66 83 7a 08 02	 cmp	 WORD PTR [edx+8], 2
  0010e	0f 84 c9 00 00
	00		 je	 $LN2@CGModifyRe
$LN13@CGModifyRe:

; 6242 : 					continue;
; 6243 : 
; 6244 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,4) || lpObj->pInventory[n].m_Type == ITEMGET(13,5) )

  00114	b9 04 1a 00 00	 mov	 ecx, 6660		; 00001a04H
  00119	66 3b c1	 cmp	 ax, cx
  0011c	0f 84 bb 00 00
	00		 je	 $LN2@CGModifyRe
  00122	b9 05 1a 00 00	 mov	 ecx, 6661		; 00001a05H
  00127	66 3b c1	 cmp	 ax, cx
  0012a	0f 84 ad 00 00
	00		 je	 $LN2@CGModifyRe

; 6245 : 					continue;
; 6246 : 				
; 6247 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,37) )

  00130	b9 25 1a 00 00	 mov	 ecx, 6693		; 00001a25H
  00135	66 3b c1	 cmp	 ax, cx
  00138	0f 84 9f 00 00
	00		 je	 $LN2@CGModifyRe

; 6248 : 					continue;
; 6249 : 
; 6250 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,38) )

  0013e	b9 26 1a 00 00	 mov	 ecx, 6694		; 00001a26H
  00143	66 3b c1	 cmp	 ax, cx
  00146	0f 84 91 00 00
	00		 je	 $LN2@CGModifyRe

; 6251 : 					continue;
; 6252 : 
; 6253 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,39) )

  0014c	b9 27 1a 00 00	 mov	 ecx, 6695		; 00001a27H
  00151	66 3b c1	 cmp	 ax, cx
  00154	0f 84 83 00 00
	00		 je	 $LN2@CGModifyRe

; 6254 : 					continue;
; 6255 : 
; 6256 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,40) )

  0015a	b9 28 1a 00 00	 mov	 ecx, 6696		; 00001a28H
  0015f	66 3b c1	 cmp	 ax, cx
  00162	74 79		 je	 SHORT $LN2@CGModifyRe

; 6257 : 					continue;
; 6258 : 
; 6259 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,68) )

  00164	b9 44 1a 00 00	 mov	 ecx, 6724		; 00001a44H
  00169	66 3b c1	 cmp	 ax, cx
  0016c	74 6f		 je	 SHORT $LN2@CGModifyRe

; 6260 : 					continue;
; 6261 : 
; 6262 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,76) || lpObj->pInventory[n].m_Type == ITEMGET(13,77) || lpObj->pInventory[n].m_Type == ITEMGET(13,78)) 

  0016e	b9 4c 1a 00 00	 mov	 ecx, 6732		; 00001a4cH
  00173	66 3b c1	 cmp	 ax, cx
  00176	74 65		 je	 SHORT $LN2@CGModifyRe
  00178	b9 4d 1a 00 00	 mov	 ecx, 6733		; 00001a4dH
  0017d	66 3b c1	 cmp	 ax, cx
  00180	74 5b		 je	 SHORT $LN2@CGModifyRe
  00182	b9 4e 1a 00 00	 mov	 ecx, 6734		; 00001a4eH
  00187	66 3b c1	 cmp	 ax, cx
  0018a	74 51		 je	 SHORT $LN2@CGModifyRe

; 6263 : 					continue;
; 6264 : 
; 6265 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(12,26) &&

  0018c	b9 1a 18 00 00	 mov	 ecx, 6170		; 0000181aH
  00191	66 3b c1	 cmp	 ax, cx
  00194	75 22		 jne	 SHORT $LN23@CGModifyRe
  00196	0f b7 4a 08	 movzx	 ecx, WORD PTR [edx+8]
  0019a	66 83 f9 01	 cmp	 cx, 1
  0019e	74 3d		 je	 SHORT $LN2@CGModifyRe
  001a0	66 83 f9 02	 cmp	 cx, 2
  001a4	74 37		 je	 SHORT $LN2@CGModifyRe
  001a6	66 83 f9 03	 cmp	 cx, 3
  001aa	74 31		 je	 SHORT $LN2@CGModifyRe
  001ac	66 83 f9 04	 cmp	 cx, 4
  001b0	74 2b		 je	 SHORT $LN2@CGModifyRe
  001b2	66 83 f9 05	 cmp	 cx, 5
  001b6	74 25		 je	 SHORT $LN2@CGModifyRe
$LN23@CGModifyRe:

; 6266 : 					(lpObj->pInventory[n].m_Level == 1 ||
; 6267 : 					 lpObj->pInventory[n].m_Level == 2 || 
; 6268 : 					 lpObj->pInventory[n].m_Level == 3 || 
; 6269 : 					 lpObj->pInventory[n].m_Level == 4 || 
; 6270 : 					 lpObj->pInventory[n].m_Level == 5 ))
; 6271 : 					 continue;
; 6272 : 
; 6273 : 				if ( lpObj->pInventory[n].m_Type == ITEMGET(13,107) )

  001b8	b9 6b 1a 00 00	 mov	 ecx, 6763		; 00001a6bH
  001bd	66 3b c1	 cmp	 ax, cx
  001c0	74 1b		 je	 SHORT $LN2@CGModifyRe

; 6274 : 					 continue;
; 6275 : 
; 6276 : 				if ( lpObj->pInventory[n].m_bLuckySet == TRUE )

  001c2	80 ba ce 00 00
	00 01		 cmp	 BYTE PTR [edx+206], 1
  001c9	74 12		 je	 SHORT $LN2@CGModifyRe

; 6277 : 					continue;
; 6278 : 					
; 6279 : 				ItemDurRepaire(lpObj,&lpObj->pInventory[n] , n, lpMsg->Requestpos);

  001cb	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  001cf	50		 push	 eax
  001d0	ff 75 0c	 push	 DWORD PTR _n$1$[ebp]
  001d3	52		 push	 edx
  001d4	53		 push	 ebx
  001d5	e8 00 00 00 00	 call	 ?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire
  001da	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@CGModifyRe:

; 6230 : 	{
; 6231 : 		for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  001dd	ff 45 0c	 inc	 DWORD PTR _n$1$[ebp]
  001e0	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  001e6	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  001ec	0f 8c ae fe ff
	ff		 jl	 $LL4@CGModifyRe

; 6280 : 			}
; 6281 : 		}
; 6282 : 
; 6283 : 		gObjCalCharacter(lpObj->m_Index);

  001f2	ff 33		 push	 DWORD PTR [ebx]
  001f4	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  001f9	83 c4 04	 add	 esp, 4
  001fc	5f		 pop	 edi
  001fd	5e		 pop	 esi
  001fe	5b		 pop	 ebx

; 6317 : }

  001ff	8b e5		 mov	 esp, ebp
  00201	5d		 pop	 ebp
  00202	c3		 ret	 0
$LN8@CGModifyRe:

; 6284 : 		return;
; 6285 : 	}
; 6286 : 
; 6287 : 	if ( lpMsg->Position > MAIN_INVENTORY_SIZE-1)

  00203	3c cb		 cmp	 al, 203			; 000000cbH
  00205	0f 87 a2 00 00
	00		 ja	 $LN1@CGModifyRe

; 6288 : 	{
; 6289 : 		pResult.Money = 0;
; 6290 : 		return;
; 6291 : 	}
; 6292 : 
; 6293 : 	if ( IsCashItem(lpObj->pInventory[lpMsg->Position].m_Type ) == TRUE )

  0020b	0f b6 c0	 movzx	 eax, al
  0020e	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00214	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0021a	0f bf 44 01 06	 movsx	 eax, WORD PTR [ecx+eax+6]
  0021f	50		 push	 eax
  00220	e8 00 00 00 00	 call	 ?IsCashItem@@YAHH@Z	; IsCashItem
  00225	83 c4 04	 add	 esp, 4
  00228	83 f8 01	 cmp	 eax, 1
  0022b	0f 84 7c 00 00
	00		 je	 $LN1@CGModifyRe

; 6294 : 		return;
; 6295 : 
; 6296 : 
; 6297 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,20) && (lpObj->pInventory[lpMsg->Position].m_Level == 0 ||lpObj->pInventory[lpMsg->Position].m_Level == 1 ))

  00231	0f b6 77 03	 movzx	 esi, BYTE PTR [edi+3]
  00235	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  0023a	69 ce d4 00 00
	00		 imul	 ecx, esi, 212
  00240	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  00246	0f b7 41 06	 movzx	 eax, WORD PTR [ecx+6]
  0024a	66 3b c2	 cmp	 ax, dx
  0024d	75 20		 jne	 SHORT $LN31@CGModifyRe
  0024f	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  00253	66 85 d2	 test	 dx, dx
  00256	74 55		 je	 SHORT $LN1@CGModifyRe
  00258	66 83 fa 01	 cmp	 dx, 1
  0025c	74 4f		 je	 SHORT $LN1@CGModifyRe

; 6298 : 		return;
; 6299 : 
; 6300 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,20) && lpObj->pInventory[lpMsg->Position].m_Level == 2 )

  0025e	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  00263	66 3b c2	 cmp	 ax, dx
  00266	75 07		 jne	 SHORT $LN31@CGModifyRe
  00268	66 83 79 08 02	 cmp	 WORD PTR [ecx+8], 2
  0026d	74 3e		 je	 SHORT $LN1@CGModifyRe
$LN31@CGModifyRe:

; 6301 : 		return;
; 6302 : 
; 6303 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,37) )

  0026f	ba 25 1a 00 00	 mov	 edx, 6693		; 00001a25H
  00274	66 3b c2	 cmp	 ax, dx
  00277	74 34		 je	 SHORT $LN1@CGModifyRe

; 6304 : 		return;
; 6305 : 
; 6306 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,38) )

  00279	ba 26 1a 00 00	 mov	 edx, 6694		; 00001a26H
  0027e	66 3b c2	 cmp	 ax, dx
  00281	74 2a		 je	 SHORT $LN1@CGModifyRe

; 6307 : 		return;
; 6308 : 
; 6309 : 	if ( lpObj->pInventory[lpMsg->Position].m_Type == ITEMGET(13,107) )

  00283	ba 6b 1a 00 00	 mov	 edx, 6763		; 00001a6bH
  00288	66 3b c2	 cmp	 ax, dx
  0028b	74 20		 je	 SHORT $LN1@CGModifyRe

; 6310 : 		return;
; 6311 : 
; 6312 : 	if ( lpObj->pInventory[lpMsg->Position].m_bLuckySet == TRUE )

  0028d	80 b9 ce 00 00
	00 01		 cmp	 BYTE PTR [ecx+206], 1
  00294	74 17		 je	 SHORT $LN1@CGModifyRe

; 6313 : 		return;
; 6314 : 
; 6315 : 	ItemDurRepaire(lpObj, &lpObj->pInventory[lpMsg->Position], lpMsg->Position, lpMsg->Requestpos);

  00296	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0029a	50		 push	 eax
  0029b	56		 push	 esi
  0029c	51		 push	 ecx
  0029d	53		 push	 ebx
  0029e	e8 00 00 00 00	 call	 ?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ; ItemDurRepaire

; 6316 : 	gObjCalCharacter(lpObj->m_Index);

  002a3	ff 33		 push	 DWORD PTR [ebx]
  002a5	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  002aa	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@CGModifyRe:
  002ad	5f		 pop	 edi
  002ae	5e		 pop	 esi
  002af	5b		 pop	 ebx

; 6317 : }

  002b0	8b e5		 mov	 esp, ebp
  002b2	5d		 pop	 ebp
  002b3	c3		 ret	 0
?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ENDP ; CGModifyRequestItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 8
_lpObj$ = 8						; size = 4
_DurItem$ = 12						; size = 4
_pos$ = 16						; size = 4
_RequestPos$ = 20					; size = 4
?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z PROC ; ItemDurRepaire, COMDAT

; 6002 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 6003 : 	PMSG_ITEMDURREPAIR_RESULT pResult;
; 6004 : 	int result = TRUE;
; 6005 : 
; 6006 : 	PHeadSetB((LPBYTE)&pResult, 0x34, sizeof(pResult));

  00006	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	6a 08		 push	 8
  0000d	6a 34		 push	 52			; 00000034H
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 6007 : 	int itemtype = DurItem->m_Type;
; 6008 : 
; 6009 : 	if ( lpObj->m_IfState.type != 13 )

  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _DurItem$[ebp]
  0001e	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  00024	0f bf 4f 06	 movsx	 ecx, WORD PTR [edi+6]
  00028	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0002d	3d 40 03 00 00	 cmp	 eax, 832		; 00000340H
  00032	74 18		 je	 SHORT $LN3@ItemDurRep

; 6010 : 	{
; 6011 : 		if ( itemtype ==ITEMGET(13,4)  || itemtype == ITEMGET(13,5))

  00034	81 f9 04 1a 00
	00		 cmp	 ecx, 6660		; 00001a04H
  0003a	0f 84 1e 02 00
	00		 je	 $LN7@ItemDurRep
  00040	81 f9 05 1a 00
	00		 cmp	 ecx, 6661		; 00001a05H
  00046	0f 84 12 02 00
	00		 je	 $LN7@ItemDurRep
$LN3@ItemDurRep:

; 6012 : 		{
; 6013 : 			pResult.Money = 0;
; 6014 : 			DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6015 : 
; 6016 : 			return;
; 6017 : 		}
; 6018 : 	}
; 6019 : 
; 6020 : 	if( DurItem->m_bLuckySet == TRUE )

  0004c	80 bf ce 00 00
	00 01		 cmp	 BYTE PTR [edi+206], 1
  00053	0f 84 05 02 00
	00		 je	 $LN7@ItemDurRep

; 6021 : 	{
; 6022 : 		pResult.Money = 0;
; 6023 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6024 : 		return;
; 6025 : 	}
; 6026 : 
; 6027 : 	if (itemtype == ITEMGET(13,64) || 
; 6028 : 		itemtype == ITEMGET(13,65) ||

  00059	81 f9 40 1a 00
	00		 cmp	 ecx, 6720		; 00001a40H
  0005f	0f 84 f9 01 00
	00		 je	 $LN7@ItemDurRep
  00065	81 f9 41 1a 00
	00		 cmp	 ecx, 6721		; 00001a41H
  0006b	0f 84 ed 01 00
	00		 je	 $LN7@ItemDurRep
  00071	81 f9 43 1a 00
	00		 cmp	 ecx, 6723		; 00001a43H
  00077	0f 84 e1 01 00
	00		 je	 $LN7@ItemDurRep

; 6033 : 		return;
; 6034 : 	}
; 6035 : 
; 6036 : 	if ( itemtype == ITEMGET(13,80) )

  0007d	81 f9 50 1a 00
	00		 cmp	 ecx, 6736		; 00001a50H
  00083	0f 84 d5 01 00
	00		 je	 $LN7@ItemDurRep

; 6037 : 	{
; 6038 : 		pResult.Money = 0;
; 6039 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6040 : 		return;
; 6041 : 	}
; 6042 : 
; 6043 : 	if ( itemtype == ITEMGET(13,106) )

  00089	81 f9 6a 1a 00
	00		 cmp	 ecx, 6762		; 00001a6aH
  0008f	0f 84 c9 01 00
	00		 je	 $LN7@ItemDurRep

; 6044 : 	{
; 6045 : 		pResult.Money = 0;
; 6046 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6047 : 		return;
; 6048 : 	}
; 6049 : 
; 6050 : 	if ( itemtype == ITEMGET(13,123) )

  00095	81 f9 7b 1a 00
	00		 cmp	 ecx, 6779		; 00001a7bH
  0009b	0f 84 bd 01 00
	00		 je	 $LN7@ItemDurRep

; 6051 : 	{
; 6052 : 		pResult.Money = 0;
; 6053 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6054 : 		return;
; 6055 : 	}
; 6056 : 
; 6057 : 	if( itemtype ==ITEMGET(4,7) ||
; 6058 : 		itemtype ==ITEMGET(4,15) ||

  000a1	81 f9 07 08 00
	00		 cmp	 ecx, 2055		; 00000807H
  000a7	0f 84 b1 01 00
	00		 je	 $LN7@ItemDurRep
  000ad	81 f9 0f 08 00
	00		 cmp	 ecx, 2063		; 0000080fH
  000b3	0f 84 a5 01 00
	00		 je	 $LN7@ItemDurRep
  000b9	81 f9 0a 1a 00
	00		 cmp	 ecx, 6666		; 00001a0aH
  000bf	0f 84 99 01 00
	00		 je	 $LN7@ItemDurRep

; 6059 : 		itemtype == ITEMGET(13,10) )
; 6060 : 	{
; 6061 : 		pResult.Money = 0;
; 6062 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6063 : 		return;
; 6064 : 	}
; 6065 : 
; 6066 : 	if( itemtype == ITEMGET(0,41) )

  000c5	83 f9 29	 cmp	 ecx, 41			; 00000029H
  000c8	0f 84 90 01 00
	00		 je	 $LN7@ItemDurRep

; 6067 : 	{
; 6068 : 		pResult.Money = 0;
; 6069 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6070 : 		return;
; 6071 : 	}
; 6072 : 	
; 6073 : 	if ( itemtype >= ITEMGET(14,0) ||
; 6074 : 		( itemtype >= ITEMGET(13,0) && itemtype  < ITEMGET(13,4) ) ||
; 6075 : 		( itemtype >= ITEMGET(12,7) && itemtype < ITEMGET(12,36) ) ||
; 6076 : 		( itemtype > ITEMGET(12,43) && itemtype < ITEMGET(12,49) ) ||
; 6077 : 		( itemtype > ITEMGET(12,50) && itemtype < ITEMGET(12,262) ) ||

  000ce	81 f9 00 1c 00
	00		 cmp	 ecx, 7168		; 00001c00H
  000d4	0f 8d 84 01 00
	00		 jge	 $LN7@ItemDurRep
  000da	81 f9 00 1a 00
	00		 cmp	 ecx, 6656		; 00001a00H
  000e0	7c 0c		 jl	 SHORT $LN16@ItemDurRep
  000e2	81 f9 04 1a 00
	00		 cmp	 ecx, 6660		; 00001a04H
  000e8	0f 8c 70 01 00
	00		 jl	 $LN7@ItemDurRep
$LN16@ItemDurRep:
  000ee	81 f9 07 18 00
	00		 cmp	 ecx, 6151		; 00001807H
  000f4	7c 0c		 jl	 SHORT $LN17@ItemDurRep
  000f6	81 f9 24 18 00
	00		 cmp	 ecx, 6180		; 00001824H
  000fc	0f 8c 5c 01 00
	00		 jl	 $LN7@ItemDurRep
$LN17@ItemDurRep:
  00102	81 f9 2b 18 00
	00		 cmp	 ecx, 6187		; 0000182bH
  00108	7e 0c		 jle	 SHORT $LN18@ItemDurRep
  0010a	81 f9 31 18 00
	00		 cmp	 ecx, 6193		; 00001831H
  00110	0f 8c 48 01 00
	00		 jl	 $LN7@ItemDurRep
$LN18@ItemDurRep:
  00116	81 f9 32 18 00
	00		 cmp	 ecx, 6194		; 00001832H
  0011c	7e 0c		 jle	 SHORT $LN19@ItemDurRep
  0011e	81 f9 06 19 00
	00		 cmp	 ecx, 6406		; 00001906H
  00124	0f 8c 34 01 00
	00		 jl	 $LN7@ItemDurRep
$LN19@ItemDurRep:
  0012a	81 f9 0b 19 00
	00		 cmp	 ecx, 6411		; 0000190bH
  00130	7e 0c		 jle	 SHORT $LN14@ItemDurRep
  00132	81 f9 00 1a 00
	00		 cmp	 ecx, 6656		; 00001a00H
  00138	0f 8c 20 01 00
	00		 jl	 $LN7@ItemDurRep
$LN14@ItemDurRep:

; 6078 : 		( itemtype > ITEMGET(12,267) && itemtype < ITEMGET(13,0) ) )
; 6079 : 	{
; 6080 : #if (CUSTOM_WINGS == 1)
; 6081 : 		if( itemtype >= ITEMGET(12,440) && itemtype <= ITEMGET(12,445) )
; 6082 : 		{
; 6083 : 
; 6084 : 		}
; 6085 : 		else
; 6086 : 		{
; 6087 : 			pResult.Money = 0;
; 6088 : 			DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6089 : 			return;
; 6090 : 		}
; 6091 : #else
; 6092 : 		pResult.Money = 0;
; 6093 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6094 : 		return;
; 6095 : #endif
; 6096 : 	}
; 6097 : 
; 6098 : 	if ( itemtype == ITEMGET(13,38) )

  0013e	81 f9 26 1a 00
	00		 cmp	 ecx, 6694		; 00001a26H
  00144	0f 84 14 01 00
	00		 je	 $LN7@ItemDurRep

; 6099 : 	{
; 6100 : 		pResult.Money = 0;
; 6101 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6102 : 
; 6103 : 		return;
; 6104 : 	}
; 6105 : 
; 6106 : 	if ( itemtype == ITEMGET(13,39) )

  0014a	81 f9 27 1a 00
	00		 cmp	 ecx, 6695		; 00001a27H
  00150	0f 84 08 01 00
	00		 je	 $LN7@ItemDurRep

; 6107 : 	{
; 6108 : 		pResult.Money = 0;
; 6109 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6110 : 
; 6111 : 		return;
; 6112 : 	}
; 6113 : 
; 6114 : 	if ( itemtype == ITEMGET(13,40) )

  00156	81 f9 28 1a 00
	00		 cmp	 ecx, 6696		; 00001a28H
  0015c	0f 84 fc 00 00
	00		 je	 $LN7@ItemDurRep

; 6115 : 	{
; 6116 : 		pResult.Money = 0;
; 6117 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6118 : 
; 6119 : 		return;
; 6120 : 	}
; 6121 : 
; 6122 : 	if ( itemtype == ITEMGET(13,41) )

  00162	81 f9 29 1a 00
	00		 cmp	 ecx, 6697		; 00001a29H
  00168	0f 84 f0 00 00
	00		 je	 $LN7@ItemDurRep

; 6123 : 	{
; 6124 : 		pResult.Money = 0;
; 6125 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6126 : 
; 6127 : 		return;
; 6128 : 	}
; 6129 : 
; 6130 : 	if ( itemtype == ITEMGET(13,42) )

  0016e	81 f9 2a 1a 00
	00		 cmp	 ecx, 6698		; 00001a2aH
  00174	0f 84 e4 00 00
	00		 je	 $LN7@ItemDurRep

; 6131 : 	{
; 6132 : 		pResult.Money = 0;
; 6133 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6134 : 
; 6135 : 		return;
; 6136 : 	}
; 6137 : 
; 6138 : 	if ( itemtype == ITEMGET(13,68) )

  0017a	81 f9 44 1a 00
	00		 cmp	 ecx, 6724		; 00001a44H
  00180	0f 84 d8 00 00
	00		 je	 $LN7@ItemDurRep

; 6139 : 	{
; 6140 : 		pResult.Money = 0;
; 6141 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6142 : 
; 6143 : 		return;
; 6144 : 	}
; 6145 : 
; 6146 : 	if ( itemtype == ITEMGET(13,66) )

  00186	81 f9 42 1a 00
	00		 cmp	 ecx, 6722		; 00001a42H
  0018c	0f 84 cc 00 00
	00		 je	 $LN7@ItemDurRep

; 6147 : 	{
; 6148 : 		pResult.Money = 0;
; 6149 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6150 : 
; 6151 : 		return;
; 6152 : 	}
; 6153 : 
; 6154 : 	if ( itemtype == ITEMGET(13,76) || itemtype == ITEMGET(13,77) || itemtype == ITEMGET(13,78))

  00192	81 f9 4c 1a 00
	00		 cmp	 ecx, 6732		; 00001a4cH
  00198	0f 84 c0 00 00
	00		 je	 $LN7@ItemDurRep
  0019e	81 f9 4d 1a 00
	00		 cmp	 ecx, 6733		; 00001a4dH
  001a4	0f 84 b4 00 00
	00		 je	 $LN7@ItemDurRep
  001aa	81 f9 4e 1a 00
	00		 cmp	 ecx, 6734		; 00001a4eH
  001b0	0f 84 a8 00 00
	00		 je	 $LN7@ItemDurRep

; 6155 : 	{
; 6156 : 		pResult.Money = 0;
; 6157 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6158 : 
; 6159 : 		return;
; 6160 : 	}
; 6161 : 
; 6162 : 
; 6163 : 	if ( itemtype == ITEMGET(13,122) )

  001b6	81 f9 7a 1a 00
	00		 cmp	 ecx, 6778		; 00001a7aH
  001bc	0f 84 9c 00 00
	00		 je	 $LN7@ItemDurRep

; 6164 : 	{
; 6165 : 		pResult.Money = 0;
; 6166 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6167 : 
; 6168 : 		return;
; 6169 : 	}
; 6170 : 
; 6171 : 	pResult.Money = GetNeedMoneyItemDurRepaire(DurItem, RequestPos);

  001c2	ff 75 14	 push	 DWORD PTR _RequestPos$[ebp]
  001c5	57		 push	 edi
  001c6	e8 00 00 00 00	 call	 ?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z ; GetNeedMoneyItemDurRepaire
  001cb	8b c8		 mov	 ecx, eax
  001cd	83 c4 08	 add	 esp, 8

; 6172 : 
; 6173 : 	if ( pResult.Money <= 0 )

  001d0	85 c9		 test	 ecx, ecx
  001d2	0f 8e 86 00 00
	00		 jle	 $LN7@ItemDurRep

; 6174 : 	{
; 6175 : 		pResult.Money = 0;
; 6176 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);
; 6177 : 
; 6178 : 		return;
; 6179 : 	}
; 6180 : 
; 6181 : 	if ( (lpObj->Money - pResult.Money) < 1 )

  001d8	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  001de	2b c1		 sub	 eax, ecx
  001e0	83 f8 01	 cmp	 eax, 1
  001e3	7c 79		 jl	 SHORT $LN7@ItemDurRep

; 6182 : 		pResult.Money = 0;
; 6183 : 	else
; 6184 : 	{
; 6185 : 		lpObj->Money -= pResult.Money;

  001e5	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax

; 6186 : 		pResult.Money = lpObj->Money;
; 6187 : 		DurItem->m_Durability = (float)((int)DurItem->m_BaseDurability);
; 6188 : 		DurItem->Convert(DurItem->m_Type, DurItem->m_Option1, DurItem->m_Option2, DurItem->m_Option3,

  001eb	8b cf		 mov	 ecx, edi
  001ed	89 45 fc	 mov	 DWORD PTR _pResult$[ebp+4], eax
  001f0	f3 0f 2c 47 2c	 cvttss2si eax, DWORD PTR [edi+44]
  001f5	6a 03		 push	 3
  001f7	68 ff 00 00 00	 push	 255			; 000000ffH
  001fc	6a 00		 push	 0
  001fe	66 0f 6e c0	 movd	 xmm0, eax
  00202	0f b6 87 c6 00
	00 00		 movzx	 eax, BYTE PTR [edi+198]
  00209	50		 push	 eax
  0020a	0f b6 87 aa 00
	00 00		 movzx	 eax, BYTE PTR [edi+170]
  00211	50		 push	 eax
  00212	0f b6 87 93 00
	00 00		 movzx	 eax, BYTE PTR [edi+147]
  00219	50		 push	 eax
  0021a	0f b6 87 92 00
	00 00		 movzx	 eax, BYTE PTR [edi+146]
  00221	50		 push	 eax
  00222	0f b6 87 91 00
	00 00		 movzx	 eax, BYTE PTR [edi+145]
  00229	50		 push	 eax
  0022a	0f b6 87 90 00
	00 00		 movzx	 eax, BYTE PTR [edi+144]
  00231	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00234	50		 push	 eax
  00235	0f bf 47 06	 movsx	 eax, WORD PTR [edi+6]
  00239	50		 push	 eax
  0023a	f3 0f 11 47 24	 movss	 DWORD PTR [edi+36], xmm0
  0023f	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert

; 6189 : 			DurItem->m_NewOption, DurItem->m_SetOption,DurItem->m_ItemOptionEx,0,-1, CURRENT_DB_VERSION);
; 6190 : 		GCItemDurSend(lpObj->m_Index, pos, (BYTE)DurItem->m_Durability, FALSE);

  00244	f3 0f 2c 47 24	 cvttss2si eax, DWORD PTR [edi+36]
  00249	6a 00		 push	 0
  0024b	0f b6 c0	 movzx	 eax, al
  0024e	50		 push	 eax
  0024f	ff 75 10	 push	 DWORD PTR _pos$[ebp]
  00252	ff 36		 push	 DWORD PTR [esi]
  00254	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00259	83 c4 10	 add	 esp, 16			; 00000010H

; 6191 : 	}
; 6192 : 
; 6193 : 	DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  0025c	eb 07		 jmp	 SHORT $LN32@ItemDurRep
$LN7@ItemDurRep:

; 6029 : 		itemtype == ITEMGET(13,67))
; 6030 : 	{
; 6031 : 		pResult.Money = 0;

  0025e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
$LN32@ItemDurRep:

; 6032 : 		DataSend(lpObj->m_Index, (LPBYTE)&pResult, pResult.h.size);

  00265	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00269	50		 push	 eax
  0026a	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0026d	50		 push	 eax
  0026e	ff 36		 push	 DWORD PTR [esi]
  00270	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00275	83 c4 0c	 add	 esp, 12			; 0000000cH
  00278	5f		 pop	 edi
  00279	5e		 pop	 esi

; 6194 : }

  0027a	8b e5		 mov	 esp, ebp
  0027c	5d		 pop	 ebp
  0027d	c3		 ret	 0
?ItemDurRepaire@@YAXPAUOBJECTSTRUCT@@PAVCItem@@HH@Z ENDP ; ItemDurRepaire
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z
_TEXT	SEGMENT
_lc6$1$ = -16						; size = 4
_lc5$1 = -16						; size = 4
_ItemDurability$1$ = -12				; size = 4
tv156 = -8						; size = 8
_DurItem$ = 8						; size = 4
_RequestPos$ = 12					; size = 4
?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z PROC	; GetNeedMoneyItemDurRepaire, COMDAT

; 5920 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 5921 : 	int iMoney = 0;
; 5922 : 	int type = DurItem->m_Type;

  0000b	8b 7d 08	 mov	 edi, DWORD PTR _DurItem$[ebp]
  0000e	0f bf 77 06	 movsx	 esi, WORD PTR [edi+6]

; 5923 : 	float ItemDurability = DurItem->m_Durability;

  00012	f3 0f 10 57 24	 movss	 xmm2, DWORD PTR [edi+36]
  00017	f3 0f 11 54 24
	0c		 movss	 DWORD PTR _ItemDurability$1$[esp+24], xmm2

; 5924 : 	float BaseDurability = DurItem->m_BaseDurability;
; 5925 : 
; 5926 : 	if ( type == ITEMGET(13,10) ) // Transformation Ring

  0001d	81 fe 0a 1a 00
	00		 cmp	 esi, 6666		; 00001a0aH
  00023	75 08		 jne	 SHORT $LN2@GetNeedMon
$LN23@GetNeedMon:

; 5927 : 		return 0;

  00025	33 c0		 xor	 eax, eax

; 5987 : }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
$LN2@GetNeedMon:

; 5928 : 
; 5929 : 	if ( ::HasItemDurability(type ) != FALSE )

  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ?HasItemDurability@@YAHH@Z ; HasItemDurability
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	0f 84 75 01 00
	00		 je	 $LN3@GetNeedMon

; 5930 : 	{
; 5931 : 		float lc4;
; 5932 : 		float lc5 = 0;
; 5933 : 		lc4 = DurItem->m_BaseDurability;

  0003e	f3 0f 10 4f 2c	 movss	 xmm1, DWORD PTR [edi+44]

; 5934 : 
; 5935 : 		if ( ItemDurability == lc4 )

  00043	f3 0f 10 44 24
	0c		 movss	 xmm0, DWORD PTR _ItemDurability$1$[esp+24]
  00049	0f 2e c1	 ucomiss xmm0, xmm1
  0004c	9f		 lahf
  0004d	f6 c4 44	 test	 ah, 68			; 00000044H
  00050	7b d3		 jnp	 SHORT $LN23@GetNeedMon

; 5936 : 			return 0;
; 5937 : 
; 5938 : 		float lc6 = 1.0f - ItemDurability / lc4;

  00052	f3 0f 5e c1	 divss	 xmm0, xmm1
  00056	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0005e	f3 0f 5c c8	 subss	 xmm1, xmm0
  00062	f3 0f 11 4c 24
	08		 movss	 DWORD PTR _lc6$1$[esp+24], xmm1

; 5939 : 		int lc7;
; 5940 : 
; 5941 : 		if ( type == ITEMGET(13,4)|| type ==ITEMGET(13,5) ) // Pets

  00068	81 fe 04 1a 00
	00		 cmp	 esi, 6660		; 00001a04H
  0006e	74 14		 je	 SHORT $LN8@GetNeedMon
  00070	81 fe 05 1a 00
	00		 cmp	 esi, 6661		; 00001a05H
  00076	74 0c		 je	 SHORT $LN8@GetNeedMon

; 5943 : 		else
; 5944 : 			lc7 = DurItem->m_BuyMoney/3;

  00078	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0007d	f7 67 78	 mul	 DWORD PTR [edi+120]
  00080	d1 ea		 shr	 edx, 1
  00082	eb 03		 jmp	 SHORT $LN7@GetNeedMon
$LN8@GetNeedMon:

; 5942 : 			lc7 = DurItem->m_BuyMoney;

  00084	8b 57 78	 mov	 edx, DWORD PTR [edi+120]
$LN7@GetNeedMon:

; 5945 : 
; 5946 : 		if ( lc7 > 400000000 ) lc7 = 400000000;

  00087	81 fa 00 84 d7
	17		 cmp	 edx, 400000000		; 17d78400H
  0008d	7e 07		 jle	 SHORT $LN9@GetNeedMon
  0008f	ba 00 84 d7 17	 mov	 edx, 400000000		; 17d78400H

; 5947 : 
; 5948 : 		if ( lc7 >= 1000 )

  00094	eb 08		 jmp	 SHORT $LN22@GetNeedMon
$LN9@GetNeedMon:
  00096	81 fa e8 03 00
	00		 cmp	 edx, 1000		; 000003e8H
  0009c	7c 16		 jl	 SHORT $LN10@GetNeedMon
$LN22@GetNeedMon:

; 5949 : 			lc7 = lc7/100*100;

  0009e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000a3	f7 ea		 imul	 edx
  000a5	c1 fa 05	 sar	 edx, 5
  000a8	8b c2		 mov	 eax, edx
  000aa	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ad	03 c2		 add	 eax, edx
  000af	6b d0 64	 imul	 edx, eax, 100
  000b2	eb 1b		 jmp	 SHORT $LN12@GetNeedMon
$LN10@GetNeedMon:

; 5950 : 		else if ( lc7 >= 100 )

  000b4	83 fa 64	 cmp	 edx, 100		; 00000064H
  000b7	7c 16		 jl	 SHORT $LN12@GetNeedMon

; 5951 : 			lc7 = lc7/10*10;

  000b9	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  000be	f7 ea		 imul	 edx
  000c0	c1 fa 02	 sar	 edx, 2
  000c3	8b c2		 mov	 eax, edx
  000c5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c8	03 c2		 add	 eax, edx
  000ca	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  000cd	03 d2		 add	 edx, edx
$LN12@GetNeedMon:

; 5952 : 
; 5953 : 		float lc8 = (float)sqrt(double(lc7));
; 5954 : 		float lc9 = (float)sqrt(sqrt(double(lc7))); 

  000cf	66 0f 6e c2	 movd	 xmm0, edx
  000d3	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000d7	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  000dc	f2 0f 11 44 24
	10		 movsd	 QWORD PTR tv156[esp+24], xmm0
  000e2	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  000e7	0f 57 c9	 xorps	 xmm1, xmm1
  000ea	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
  000ee	f2 0f 10 44 24
	10		 movsd	 xmm0, QWORD PTR tv156[esp+24]
  000f4	66 0f 5a c0	 cvtpd2ps xmm0, xmm0

; 5955 : 		lc5 = 3.0f * lc8 * lc9;

  000f8	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
  00100	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00104	0f 57 c0	 xorps	 xmm0, xmm0

; 5956 : 		lc5 *= lc6;
; 5957 : 		lc5 += 1.0f;
; 5958 : 
; 5959 : 		if ( ItemDurability <= 0.0f )

  00107	0f 2f 44 24 0c	 comiss	 xmm0, DWORD PTR _ItemDurability$1$[esp+24]
  0010c	f3 0f 59 4c 24
	08		 mulss	 xmm1, DWORD PTR _lc6$1$[esp+24]
  00112	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f800000
  0011a	f3 0f 11 4c 24
	08		 movss	 DWORD PTR _lc5$1[esp+24], xmm1
  00120	72 31		 jb	 SHORT $LN15@GetNeedMon

; 5960 : 		{
; 5961 : 			if ( type == ITEMGET(13,4)|| type ==ITEMGET(13,5) ) // Pets

  00122	81 fe 04 1a 00
	00		 cmp	 esi, 6660		; 00001a04H
  00128	74 21		 je	 SHORT $LN16@GetNeedMon
  0012a	81 fe 05 1a 00
	00		 cmp	 esi, 6661		; 00001a05H
  00130	74 19		 je	 SHORT $LN16@GetNeedMon

; 5963 : 			else
; 5964 : 				lc5 *= ::GetAllRepairItemRate(type);

  00132	56		 push	 esi
  00133	e8 00 00 00 00	 call	 ?GetAllRepairItemRate@@YAMH@Z ; GetAllRepairItemRate
  00138	d8 4c 24 0c	 fmul	 DWORD PTR _lc5$1[esp+28]
  0013c	83 c4 04	 add	 esp, 4
  0013f	d9 5c 24 08	 fstp	 DWORD PTR _lc5$1[esp+24]
  00143	f3 0f 10 4c 24
	08		 movss	 xmm1, DWORD PTR _lc5$1[esp+24]
  00149	eb 08		 jmp	 SHORT $LN15@GetNeedMon
$LN16@GetNeedMon:

; 5962 : 				lc5 *= 2;

  0014b	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
$LN15@GetNeedMon:

; 5965 : 
; 5966 : 		}
; 5967 : 
; 5968 : 		if ( RequestPos == TRUE )

  00153	83 7d 0c 01	 cmp	 DWORD PTR _RequestPos$[ebp], 1
  00157	75 0f		 jne	 SHORT $LN17@GetNeedMon

; 5969 : 		{
; 5970 : 			lc5 += lc5 * 1.5f;

  00159	0f 28 c1	 movaps	 xmm0, xmm1
  0015c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3fc00000
  00164	f3 0f 58 c8	 addss	 xmm1, xmm0
$LN17@GetNeedMon:

; 5971 : 		}
; 5972 : 
; 5973 : 		iMoney = (int)lc5;

  00168	f3 0f 2c c9	 cvttss2si ecx, xmm1

; 5974 : 
; 5975 : 		if ( iMoney >= 1000 )

  0016c	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  00172	7c 1c		 jl	 SHORT $LN18@GetNeedMon

; 5976 : 			iMoney = iMoney/100*100;

  00174	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00179	f7 e9		 imul	 ecx
  0017b	c1 fa 05	 sar	 edx, 5
  0017e	8b c2		 mov	 eax, edx
  00180	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00183	03 c2		 add	 eax, edx
  00185	6b c8 64	 imul	 ecx, eax, 100

; 5984 : 	}
; 5985 : 
; 5986 : 	return iMoney;

  00188	8b c1		 mov	 eax, ecx

; 5987 : }

  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
$LN18@GetNeedMon:

; 5977 : 		else if ( iMoney >= 100 )

  00190	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00193	7c 21		 jl	 SHORT $LN4@GetNeedMon

; 5978 : 			iMoney = iMoney/10*10;

  00195	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0019a	f7 e9		 imul	 ecx
  0019c	c1 fa 02	 sar	 edx, 2
  0019f	8b c2		 mov	 eax, edx
  001a1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001a4	03 c2		 add	 eax, edx
  001a6	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  001a9	03 c9		 add	 ecx, ecx

; 5984 : 	}
; 5985 : 
; 5986 : 	return iMoney;

  001ab	8b c1		 mov	 eax, ecx

; 5987 : }

  001ad	5f		 pop	 edi
  001ae	5e		 pop	 esi
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
$LN3@GetNeedMon:

; 5979 : 		
; 5980 : 	}
; 5981 : 	else
; 5982 : 	{
; 5983 : 		iMoney = -1;

  001b3	83 c9 ff	 or	 ecx, -1
$LN4@GetNeedMon:

; 5987 : }

  001b6	5f		 pop	 edi
  001b7	8b c1		 mov	 eax, ecx
  001b9	5e		 pop	 esi
  001ba	8b e5		 mov	 esp, ebp
  001bc	5d		 pop	 ebp
  001bd	c3		 ret	 0
?GetNeedMoneyItemDurRepaire@@YAHPAVCItem@@H@Z ENDP	; GetNeedMoneyItemDurRepaire
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z
_TEXT	SEGMENT
_tShop$1$ = -36						; size = 4
_type$1$ = -32						; size = 4
_lpMsg$GSCopy$1$ = -32					; size = 4
_Divisor$1 = -25					; size = 1
tv957 = -24						; size = 4
_iAddZen$2 = -24					; size = 4
_pResult$ = -20						; size = 8
_NewOption$3 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z PROC	; CGSellRequestRecv, COMDAT

; 5696 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx

; 5697 : 	PMSG_SELLRESULT pResult;
; 5698 : 	LPOBJ lpObj = &gObj[aIndex];

  00011	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 5699 : 
; 5700 : 	PHeadSetB((LPBYTE)&pResult, 0x33, sizeof(pResult));

  00017	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00022	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  00028	6a 08		 push	 8
  0002a	6a 33		 push	 51			; 00000033H
  0002c	50		 push	 eax
  0002d	89 75 e0	 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], esi
  00030	89 4d e8	 mov	 DWORD PTR tv957[ebp], ecx
  00033	03 d9		 add	 ebx, ecx
  00035	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 5701 : 	pResult.Result = false;
; 5702 : 	pResult.Money = 0;
; 5703 : 
; 5704 : 	if ( gObj[aIndex].CloseType != -1 )

  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	8b 4d e8	 mov	 ecx, DWORD PTR tv957[ebp]
  00045	c6 45 ef 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  00049	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+4], 0
  00050	80 7c 01 0d ff	 cmp	 BYTE PTR [ecx+eax+13], -1
  00055	0f 85 80 05 00
	00		 jne	 $LN8@CGSellRequ

; 5705 : 	{
; 5706 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5707 : 		return;
; 5708 : 	}
; 5709 : 
; 5710 : 	if ( lpObj->m_IfState.use > 0 && lpObj->m_IfState.type != 3 )

  0005b	8b 83 b8 11 00
	00		 mov	 eax, DWORD PTR [ebx+4536]
  00061	a8 03		 test	 al, 3
  00063	76 10		 jbe	 SHORT $LN3@CGSellRequ
  00065	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0006a	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0006f	0f 85 66 05 00
	00		 jne	 $LN8@CGSellRequ
$LN3@CGSellRequ:

; 5711 : 	{
; 5712 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5713 : 		return;
; 5714 : 	}
; 5715 : 
; 5716 : 	if ( !PacketCheckTime(lpObj))

  00075	53		 push	 ebx
  00076	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0007b	83 c4 04	 add	 esp, 4
  0007e	85 c0		 test	 eax, eax
  00080	0f 84 55 05 00
	00		 je	 $LN8@CGSellRequ

; 5717 : 	{
; 5718 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5719 : 		return;
; 5720 : 	}
; 5721 : 
; 5722 : 	if ( !::gObjFixInventoryPointer(aIndex))

  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  0008c	83 c4 04	 add	 esp, 4
  0008f	84 c0		 test	 al, al
  00091	75 18		 jne	 SHORT $LN5@CGSellRequ

; 5723 : 	{
; 5724 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  00093	68 5c 16 00 00	 push	 5724			; 0000165cH
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@CGSellRequ:

; 5725 : 	}
; 5726 : 
; 5727 : 	if ( gObj[aIndex].pTransaction == 1 )

  000ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b1	8b 4d e8	 mov	 ecx, DWORD PTR tv957[ebp]
  000b4	80 bc 11 cc 11
	00 00 01	 cmp	 BYTE PTR [ecx+edx+4556], 1
  000bc	75 3b		 jne	 SHORT $LN6@CGSellRequ

; 5728 : 	{
; 5729 : 		LogAddTD("[%s][%s] CGSellRequestRecv() Failed : Transaction == 1, IF_TYPE : %d",

  000be	8b 84 11 b8 11
	00 00		 mov	 eax, DWORD PTR [ecx+edx+4536]
  000c5	c1 e8 06	 shr	 eax, 6
  000c8	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  000cd	50		 push	 eax
  000ce	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  000d1	03 c1		 add	 eax, ecx
  000d3	50		 push	 eax
  000d4	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  000d7	03 c1		 add	 eax, ecx
  000d9	50		 push	 eax
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@KJAJLIMD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGSellRequestRecv?$CI?$CJ?5Fai@
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e5	83 c4 10	 add	 esp, 16			; 00000010H
  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx

; 5912 : 	}
; 5913 : 
; 5914 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5915 : }

  000eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ee	33 cd		 xor	 ecx, ebp
  000f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
$LN6@CGSellRequ:

; 5730 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);
; 5731 : 
; 5732 : 		return;
; 5733 : 	}
; 5734 : 
; 5735 : 	int tShop = lpObj->TargetShopNumber;

  000f9	0f bf 83 3a 06
	00 00		 movsx	 eax, WORD PTR [ebx+1594]
  00100	89 45 dc	 mov	 DWORD PTR _tShop$1$[ebp], eax

; 5736 : 
; 5737 : 	if ( tShop < 0 || tShop > MAX_SHOP-1 )

  00103	3d f3 01 00 00	 cmp	 eax, 499		; 000001f3H
  00108	0f 87 cd 04 00
	00		 ja	 $LN8@CGSellRequ

; 5740 : 		return;
; 5741 : 	}
; 5742 : 
; 5743 : 	if ( !gObjCanItemTouch(lpObj, 3))

  0010e	6a 03		 push	 3
  00110	53		 push	 ebx
  00111	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00116	83 c4 08	 add	 esp, 8
  00119	85 c0		 test	 eax, eax
  0011b	0f 84 ba 04 00
	00		 je	 $LN8@CGSellRequ

; 5744 : 	{
; 5745 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5746 : 		return;
; 5747 : 	}
; 5748 : 
; 5749 : 	if ( lpMsg->Pos > MAIN_INVENTORY_SIZE-1 )

  00121	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  00124	3c cb		 cmp	 al, 203			; 000000cbH
  00126	76 41		 jbe	 SHORT $LN10@CGSellRequ

; 5750 : 	{
; 5751 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00128	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0012c	50		 push	 eax
  0012d	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  00130	50		 push	 eax
  00131	57		 push	 edi
  00132	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5752 : 		LogAdd(lMsg.Get(MSGGET(1, 227)), lpMsg->Pos);

  00137	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00143	50		 push	 eax
  00144	68 e3 01 00 00	 push	 483			; 000001e3H
  00149	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0014e	50		 push	 eax
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00155	83 c4 08	 add	 esp, 8
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx

; 5912 : 	}
; 5913 : 
; 5914 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5915 : }

  0015b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015e	33 cd		 xor	 ecx, ebp
  00160	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
$LN10@CGSellRequ:

; 5753 : 		return;
; 5754 : 	}
; 5755 : 
; 5756 : 	if ( gObjCheckSerial0ItemList(&lpObj->pInventory[lpMsg->Pos]) != FALSE )

  00169	0f b6 c0	 movzx	 eax, al
  0016c	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  00172	03 83 c0 11 00
	00		 add	 eax, DWORD PTR [ebx+4544]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  0017e	83 c4 04	 add	 esp, 4
  00181	85 c0		 test	 eax, eax
  00183	74 66		 je	 SHORT $LN11@CGSellRequ

; 5757 : 	{
; 5758 : 		MsgOutput(aIndex, lMsg.Get(MSGGET(13, 26)));

  00185	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0018a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0018f	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00194	50		 push	 eax
  00195	57		 push	 edi
  00196	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 5759 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0019b	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0019f	50		 push	 eax
  001a0	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  001a3	50		 push	 eax
  001a4	57		 push	 edi
  001a5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5760 : 
; 5761 : 		LogAddTD("[ANTI-HACK][Serial 0 Item] [Sell Item] (%s)(%s) Item(%s) Pos(%d)",

  001aa	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  001ae	83 c4 14	 add	 esp, 20			; 00000014H
  001b1	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  001b7	50		 push	 eax
  001b8	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  001be	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  001c3	50		 push	 eax
  001c4	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  001c7	50		 push	 eax
  001c8	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  001cb	50		 push	 eax
  001cc	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@IPNHKJAG@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLSell@
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001d7	83 c4 14	 add	 esp, 20			; 00000014H
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx

; 5912 : 	}
; 5913 : 
; 5914 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5915 : }

  001dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e0	33 cd		 xor	 ecx, ebp
  001e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c3		 ret	 0
$LN11@CGSellRequ:

; 5762 : 			lpObj->AccountID, lpObj->Name, lpObj->pInventory[lpMsg->Pos].GetName(), lpMsg->Pos);
; 5763 : 
; 5764 : 		return;
; 5765 : 	}
; 5766 : 
; 5767 : 	if (gc_bBlockFullExcellent == 1) {

  001eb	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gc_bBlockFullExcellent@@3HA, 1 ; gc_bBlockFullExcellent
  001f2	75 1d		 jne	 SHORT $LN13@CGSellRequ

; 5768 : 		if (lpObj->pInventory[lpMsg->Pos].IsFullExcellent()) {

  001f4	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  001f8	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  001fe	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  00204	e8 00 00 00 00	 call	 ?IsFullExcellent@CItem@@QAE_NXZ ; CItem::IsFullExcellent
  00209	84 c0		 test	 al, al
  0020b	0f 85 ca 03 00
	00		 jne	 $LN8@CGSellRequ
$LN13@CGSellRequ:

; 5769 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5770 : 			return;
; 5771 : 		}
; 5772 : 	}
; 5773 : 
; 5774 : 	if (gc_bBlockFullAncient == 1) {

  00211	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gc_bBlockFullAncient@@3HA, 1 ; gc_bBlockFullAncient
  00218	75 1d		 jne	 SHORT $LN15@CGSellRequ

; 5775 : 		if (lpObj->pInventory[lpMsg->Pos].IsFullAncient()) {

  0021a	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  0021e	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00224	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  0022a	e8 00 00 00 00	 call	 ?IsFullAncient@CItem@@QAEHXZ ; CItem::IsFullAncient
  0022f	85 c0		 test	 eax, eax
  00231	0f 85 a4 03 00
	00		 jne	 $LN8@CGSellRequ
$LN15@CGSellRequ:

; 5776 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5777 : 			return;
; 5778 : 		}
; 5779 : 	}
; 5780 : 
; 5781 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,11) ) // Box of Luck

  00237	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  0023b	ba 0b 1c 00 00	 mov	 edx, 7179		; 00001c0bH
  00240	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00246	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0024c	03 c1		 add	 eax, ecx
  0024e	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  00252	66 3b ca	 cmp	 cx, dx
  00255	0f 84 80 03 00
	00		 je	 $LN8@CGSellRequ

; 5782 : 	{
; 5783 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5784 : 		return;
; 5785 : 	}
; 5786 : 
; 5787 : 	if ( lpObj->pInventory[lpMsg->Pos].m_QuestItem != false) 

  0025b	80 b8 a9 00 00
	00 00		 cmp	 BYTE PTR [eax+169], 0
  00262	0f 85 73 03 00
	00		 jne	 $LN8@CGSellRequ

; 5788 : 	{
; 5789 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5790 : 		return;
; 5791 : 	}
; 5792 : 
; 5793 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,20) && lpObj->pInventory[lpMsg->Pos].m_Level == 1) // Wizards Ring +1

  00268	ba 14 1a 00 00	 mov	 edx, 6676		; 00001a14H
  0026d	66 3b ca	 cmp	 cx, dx
  00270	75 1b		 jne	 SHORT $LN19@CGSellRequ
  00272	66 83 78 08 01	 cmp	 WORD PTR [eax+8], 1
  00277	0f 84 5e 03 00
	00		 je	 $LN8@CGSellRequ

; 5794 : 	{
; 5795 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5796 : 		return;
; 5797 : 	}
; 5798 : 
; 5799 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(13,20) && lpObj->pInventory[lpMsg->Pos].m_Level == 2) // Wizards Ring +2

  0027d	66 3b ca	 cmp	 cx, dx
  00280	75 0b		 jne	 SHORT $LN19@CGSellRequ
  00282	66 83 78 08 02	 cmp	 WORD PTR [eax+8], 2
  00287	0f 84 4e 03 00
	00		 je	 $LN8@CGSellRequ
$LN19@CGSellRequ:

; 5800 : 	{
; 5801 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5802 : 		return;
; 5803 : 	}
; 5804 : 
; 5805 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(12,26) &&

  0028d	ba 1a 18 00 00	 mov	 edx, 6170		; 0000181aH
  00292	66 3b ca	 cmp	 cx, dx
  00295	75 36		 jne	 SHORT $LN20@CGSellRequ
  00297	0f b7 48 08	 movzx	 ecx, WORD PTR [eax+8]
  0029b	66 83 f9 01	 cmp	 cx, 1
  0029f	0f 84 36 03 00
	00		 je	 $LN8@CGSellRequ
  002a5	66 83 f9 02	 cmp	 cx, 2
  002a9	0f 84 2c 03 00
	00		 je	 $LN8@CGSellRequ
  002af	66 83 f9 03	 cmp	 cx, 3
  002b3	0f 84 22 03 00
	00		 je	 $LN8@CGSellRequ
  002b9	66 83 f9 04	 cmp	 cx, 4
  002bd	0f 84 18 03 00
	00		 je	 $LN8@CGSellRequ
  002c3	66 83 f9 05	 cmp	 cx, 5
  002c7	0f 84 0e 03 00
	00		 je	 $LN8@CGSellRequ
$LN20@CGSellRequ:

; 5806 : 		(lpObj->pInventory[lpMsg->Pos].m_Level == 1 ||
; 5807 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 2 || 
; 5808 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 3 || 
; 5809 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 4 || 
; 5810 : 		 lpObj->pInventory[lpMsg->Pos].m_Level == 5 ))
; 5811 : 	{
; 5812 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5813 : 		return;
; 5814 : 	}
; 5815 : 
; 5816 : 	if ( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony(&lpObj->pInventory[lpMsg->Pos]) == TRUE )

  002cd	50		 push	 eax
  002ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  002d3	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  002d8	83 f8 01	 cmp	 eax, 1
  002db	75 3b		 jne	 SHORT $LN22@CGSellRequ

; 5817 : 	{
; 5818 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 37)), lpObj->m_Index, 1);

  002dd	50		 push	 eax
  002de	ff 33		 push	 DWORD PTR [ebx]
  002e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002e5	68 25 0d 00 00	 push	 3365			; 00000d25H
  002ea	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002ef	50		 push	 eax
  002f0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 5819 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  002f5	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002f9	50		 push	 eax
  002fa	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  002fd	50		 push	 eax
  002fe	57		 push	 edi
  002ff	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00304	83 c4 18	 add	 esp, 24			; 00000018H
  00307	5f		 pop	 edi
  00308	5e		 pop	 esi
  00309	5b		 pop	 ebx

; 5912 : 	}
; 5913 : 
; 5914 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5915 : }

  0030a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0030d	33 cd		 xor	 ecx, ebp
  0030f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00314	8b e5		 mov	 esp, ebp
  00316	5d		 pop	 ebp
  00317	c3		 ret	 0
$LN22@CGSellRequ:

; 5820 : 		return;
; 5821 : 	}
; 5822 : 
; 5823 : 	if ( IsCashItem(lpObj->pInventory[lpMsg->Pos].m_Type) == TRUE 
; 5824 : 		&& !lpObj->pInventory[lpMsg->Pos].m_bExpired )

  00318	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  0031c	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00322	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00328	0f bf 44 01 06	 movsx	 eax, WORD PTR [ecx+eax+6]
  0032d	50		 push	 eax
  0032e	e8 00 00 00 00	 call	 ?IsCashItem@@YAHH@Z	; IsCashItem
  00333	83 c4 04	 add	 esp, 4
  00336	83 f8 01	 cmp	 eax, 1
  00339	75 1e		 jne	 SHORT $LN23@CGSellRequ
  0033b	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  0033f	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00345	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0034b	80 bc 01 d0 00
	00 00 00	 cmp	 BYTE PTR [ecx+eax+208], 0
  00353	0f 84 82 02 00
	00		 je	 $LN8@CGSellRequ
$LN23@CGSellRequ:

; 5825 : 	{
; 5826 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5827 : 		return;
; 5828 : 	}
; 5829 : 
; 5830 : 	if ( lpObj->pInventory[lpMsg->Pos].m_Type == ITEMGET(14,12) && lpObj->pInventory[lpMsg->Pos].m_Level == 1) // Heart+1

  00359	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  0035d	b8 0c 1c 00 00	 mov	 eax, 7180		; 00001c0cH
  00362	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  00368	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  0036e	66 39 41 06	 cmp	 WORD PTR [ecx+6], ax
  00372	75 3d		 jne	 SHORT $LN24@CGSellRequ
  00374	66 83 79 08 01	 cmp	 WORD PTR [ecx+8], 1
  00379	75 36		 jne	 SHORT $LN24@CGSellRequ

; 5831 : 	{
; 5832 : 		pResult.Result = true;
; 5833 : 		pResult.Money = lpObj->Money;
; 5834 : 		gObjInventoryItemSet(aIndex, lpMsg->Pos, -1);

  0037b	68 ff 00 00 00	 push	 255			; 000000ffH
  00380	52		 push	 edx
  00381	c6 45 ef 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00385	8b 83 cc 00 00
	00		 mov	 eax, DWORD PTR [ebx+204]
  0038b	57		 push	 edi
  0038c	89 45 f0	 mov	 DWORD PTR _pResult$[ebp+4], eax
  0038f	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 5835 : 		lpObj->pInventory[lpMsg->Pos].Clear();

  00394	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00398	83 c4 0c	 add	 esp, 12			; 0000000cH
  0039b	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  003a1	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  003a7	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 5836 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5837 : 
; 5838 : 		return;

  003ac	e9 2a 02 00 00	 jmp	 $LN8@CGSellRequ
$LN24@CGSellRequ:

; 5839 : 	}
; 5840 : 
; 5841 : #if ( __CUSTOM__ == 1)
; 5842 : 
; 5843 : 	if ( lpObj->pInventory[lpMsg->Pos].m_bLOCKED )

  003b1	80 b9 d1 00 00
	00 00		 cmp	 BYTE PTR [ecx+209], 0
  003b8	74 10		 je	 SHORT $LN25@CGSellRequ

; 5844 : 	{
; 5845 : 		DataSend(lpObj->m_Index,(LPBYTE)&pResult,pResult.h.size);

  003ba	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  003be	50		 push	 eax
  003bf	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  003c2	50		 push	 eax
  003c3	ff 33		 push	 DWORD PTR [ebx]

; 5846 : 		return;

  003c5	e9 1b 02 00 00	 jmp	 $LN38@CGSellRequ
$LN25@CGSellRequ:

; 5847 : 	}
; 5848 : 
; 5849 : #endif
; 5850 : 
; 5851 : 	if ( lpObj->pInventory[lpMsg->Pos].IsItem() == FALSE )

  003ca	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003cf	85 c0		 test	 eax, eax
  003d1	75 5f		 jne	 SHORT $LN26@CGSellRequ

; 5852 : 	{
; 5853 : 		pResult.Result = false;

  003d3	88 45 ef	 mov	 BYTE PTR _pResult$[ebp+3], al

; 5854 : 		pResult.Money = lpObj->Money;
; 5855 : 		LogAdd(lMsg.Get(MSGGET(1, 228)), __FILE__, __LINE__, lpObj->Name, lpMsg->Pos);

  003d6	8d 73 5d	 lea	 esi, DWORD PTR [ebx+93]
  003d9	8b 83 cc 00 00
	00		 mov	 eax, DWORD PTR [ebx+204]
  003df	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003e4	89 45 f0	 mov	 DWORD PTR _pResult$[ebp+4], eax
  003e7	8b 45 e0	 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  003ea	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  003ee	50		 push	 eax
  003ef	56		 push	 esi
  003f0	68 df 16 00 00	 push	 5855			; 000016dfH
  003f5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  003fa	68 e4 01 00 00	 push	 484			; 000001e4H
  003ff	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00404	50		 push	 eax
  00405	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 5856 : 		LogAdd("ID:%s CharID:%s ", lpObj->AccountID, lpObj->Name);

  0040b	56		 push	 esi
  0040c	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  0040f	50		 push	 eax
  00410	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NPCMBJOG@ID?3?$CFs?5CharID?3?$CFs?5?$AA@
  00415	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 5857 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0041b	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0041f	50		 push	 eax
  00420	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  00423	50		 push	 eax
  00424	57		 push	 edi
  00425	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0042a	83 c4 2c	 add	 esp, 44			; 0000002cH

; 5858 : 
; 5859 : 	}
; 5860 : 	else

  0042d	e9 a9 01 00 00	 jmp	 $LN8@CGSellRequ
$LN26@CGSellRequ:

; 5861 : 	{
; 5862 : 		BYTE NewOption[MAX_EXOPTION_SIZE];
; 5863 : 		DWORD iAddZen = 0;
; 5864 : 		int type = lpObj->pInventory[lpMsg->Pos].m_Type;

  00432	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00436	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0043c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iAddZen$2[ebp], 0
  00443	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  00449	0f bf 41 06	 movsx	 eax, WORD PTR [ecx+6]
  0044d	89 45 e0	 mov	 DWORD PTR _type$1$[ebp], eax

; 5865 : 		BYTE Divisor;
; 5866 : 
; 5867 : 		if ( type == ITEMGET(13,4) || type == ITEMGET(13,5)) // Pets

  00450	3d 04 1a 00 00	 cmp	 eax, 6660		; 00001a04H
  00455	74 0e		 je	 SHORT $LN30@CGSellRequ
  00457	3d 05 1a 00 00	 cmp	 eax, 6661		; 00001a05H
  0045c	74 07		 je	 SHORT $LN30@CGSellRequ

; 5869 : 		else
; 5870 : 			lpObj->pInventory[lpMsg->Pos].Value();

  0045e	e8 00 00 00 00	 call	 ?Value@CItem@@QAEXXZ	; CItem::Value
  00463	eb 05		 jmp	 SHORT $LN29@CGSellRequ
$LN30@CGSellRequ:

; 5868 : 			lpObj->pInventory[lpMsg->Pos].PetValue();

  00465	e8 00 00 00 00	 call	 ?PetValue@CItem@@QAEXXZ	; CItem::PetValue
$LN29@CGSellRequ:

; 5871 : 
; 5872 : 		
; 5873 : 		if( g_ItemPrice.GetPrice(tShop, type, lpObj->pInventory[lpMsg->Pos].m_Level, iAddZen, Divisor) )

  0046a	8d 45 e7	 lea	 eax, DWORD PTR _Divisor$1[ebp]
  0046d	50		 push	 eax
  0046e	8d 45 e8	 lea	 eax, DWORD PTR _iAddZen$2[ebp]
  00471	50		 push	 eax
  00472	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00476	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0047c	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00482	0f b6 44 01 08	 movzx	 eax, BYTE PTR [ecx+eax+8]
  00487	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemPrice@@3VItemPrice@@A ; g_ItemPrice
  0048c	50		 push	 eax
  0048d	ff 75 e0	 push	 DWORD PTR _type$1$[ebp]
  00490	ff 75 dc	 push	 DWORD PTR _tShop$1$[ebp]
  00493	e8 00 00 00 00	 call	 ?GetPrice@ItemPrice@@QAE_NFGEAAKAAE@Z ; ItemPrice::GetPrice
  00498	84 c0		 test	 al, al
  0049a	74 0d		 je	 SHORT $LN31@CGSellRequ

; 5874 : 		{
; 5875 : 			iAddZen /= Divisor;

  0049c	0f b6 4d e7	 movzx	 ecx, BYTE PTR _Divisor$1[ebp]
  004a0	33 d2		 xor	 edx, edx
  004a2	8b 45 e8	 mov	 eax, DWORD PTR _iAddZen$2[ebp]
  004a5	f7 f1		 div	 ecx

; 5876 : 		}
; 5877 : 		else

  004a7	eb 14		 jmp	 SHORT $LN39@CGSellRequ
$LN31@CGSellRequ:

; 5878 : 		{
; 5879 : 			iAddZen = lpObj->pInventory[lpMsg->Pos].m_SellMoney;

  004a9	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  004ad	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  004b3	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  004b9	8b 44 01 74	 mov	 eax, DWORD PTR [ecx+eax+116]
$LN39@CGSellRequ:

; 5880 : 		}
; 5881 : 
; 5882 : 		if ( gObjCheckMaxZen(aIndex, iAddZen) == FALSE )

  004bd	50		 push	 eax
  004be	57		 push	 edi
  004bf	89 45 e8	 mov	 DWORD PTR _iAddZen$2[ebp], eax
  004c2	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  004c7	83 c4 08	 add	 esp, 8
  004ca	85 c0		 test	 eax, eax
  004cc	0f 84 09 01 00
	00		 je	 $LN8@CGSellRequ

; 5883 : 		{
; 5884 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5885 : 			return;
; 5886 : 		}
; 5887 : 
; 5888 : 		lpObj->Money += iAddZen;

  004d2	8b 45 e8	 mov	 eax, DWORD PTR _iAddZen$2[ebp]
  004d5	01 83 cc 00 00
	00		 add	 DWORD PTR [ebx+204], eax

; 5889 : 		pResult.Result =true;

  004db	c6 45 ef 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 5890 : 		pResult.Money = lpObj->Money;

  004df	8b 83 cc 00 00
	00		 mov	 eax, DWORD PTR [ebx+204]
  004e5	89 45 f0	 mov	 DWORD PTR _pResult$[ebp+4], eax

; 5891 : 		
; 5892 : 		ItemIsBufExOption(NewOption, &lpObj->pInventory[lpMsg->Pos]);

  004e8	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  004ec	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  004f2	03 83 c0 11 00
	00		 add	 eax, DWORD PTR [ebx+4544]
  004f8	50		 push	 eax
  004f9	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$3[ebp]
  004fc	50		 push	 eax
  004fd	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 5893 : 
; 5894 : 		LogAddTD(lMsg.Get(MSGGET(1, 229)), lpObj->AccountID, lpObj->Name, tShop,

  00502	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00506	83 c4 08	 add	 esp, 8
  00509	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0050f	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  00515	0f b6 81 aa 00
	00 00		 movzx	 eax, BYTE PTR [ecx+170]
  0051c	50		 push	 eax
  0051d	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$3[ebp+6]
  00521	50		 push	 eax
  00522	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$3[ebp+5]
  00526	50		 push	 eax
  00527	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$3[ebp+4]
  0052b	50		 push	 eax
  0052c	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$3[ebp+3]
  00530	50		 push	 eax
  00531	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$3[ebp+2]
  00535	50		 push	 eax
  00536	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$3[ebp+1]
  0053a	50		 push	 eax
  0053b	0f b6 45 f4	 movzx	 eax, BYTE PTR _NewOption$3[ebp]
  0053f	50		 push	 eax
  00540	f3 0f 2c 41 24	 cvttss2si eax, DWORD PTR [ecx+36]
  00545	50		 push	 eax
  00546	ff 31		 push	 DWORD PTR [ecx]
  00548	0f b6 81 92 00
	00 00		 movzx	 eax, BYTE PTR [ecx+146]
  0054f	50		 push	 eax
  00550	0f b6 81 91 00
	00 00		 movzx	 eax, BYTE PTR [ecx+145]
  00557	50		 push	 eax
  00558	0f b6 81 90 00
	00 00		 movzx	 eax, BYTE PTR [ecx+144]
  0055f	50		 push	 eax
  00560	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  00564	50		 push	 eax
  00565	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0056a	50		 push	 eax
  0056b	ff 75 e8	 push	 DWORD PTR _iAddZen$2[ebp]
  0056e	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00571	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00576	ff 75 dc	 push	 DWORD PTR _tShop$1$[ebp]
  00579	50		 push	 eax
  0057a	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  0057d	50		 push	 eax
  0057e	68 e5 01 00 00	 push	 485			; 000001e5H
  00583	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00588	50		 push	 eax
  00589	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5895 : 			iAddZen, lpObj->pInventory[lpMsg->Pos].GetName(), 
; 5896 : 			lpObj->pInventory[lpMsg->Pos].m_Level, lpObj->pInventory[lpMsg->Pos].m_Option1,
; 5897 : 			lpObj->pInventory[lpMsg->Pos].m_Option2, lpObj->pInventory[lpMsg->Pos].m_Option3,
; 5898 : 			lpObj->pInventory[lpMsg->Pos].m_Number, (int)lpObj->pInventory[lpMsg->Pos].m_Durability,
; 5899 : 			NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5], NewOption[6], 
; 5900 : 			lpObj->pInventory[lpMsg->Pos].m_SetOption);
; 5901 : 
; 5902 : 
; 5903 : 		g_ElementalSystem.ClearErtel(lpObj,&lpObj->pInventory[lpMsg->Pos]);

  0058f	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00593	83 c4 50	 add	 esp, 80			; 00000050H
  00596	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  0059c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  005a1	03 83 c0 11 00
	00		 add	 eax, DWORD PTR [ebx+4544]
  005a7	50		 push	 eax
  005a8	53		 push	 ebx
  005a9	e8 00 00 00 00	 call	 ?ClearErtel@CElementalSystem@@QAEXPAUOBJECTSTRUCT@@PAVCItem@@@Z ; CElementalSystem::ClearErtel

; 5904 : 		::gObjInventoryDeleteItem(aIndex, lpMsg->Pos);

  005ae	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  005b2	50		 push	 eax
  005b3	57		 push	 edi
  005b4	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 5905 : 
; 5906 : 		if ( lpMsg->Pos == 10 || lpMsg->Pos == 11 )

  005b9	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  005bc	83 c4 08	 add	 esp, 8
  005bf	3c 0a		 cmp	 al, 10			; 0000000aH
  005c1	74 04		 je	 SHORT $LN35@CGSellRequ
  005c3	3c 0b		 cmp	 al, 11			; 0000000bH
  005c5	75 0b		 jne	 SHORT $LN34@CGSellRequ
$LN35@CGSellRequ:

; 5907 : 		{
; 5908 : 			::gObjUseSkill.SkillChangeUse(aIndex);

  005c7	57		 push	 edi
  005c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  005cd	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN34@CGSellRequ:

; 5909 : 		}
; 5910 : 
; 5911 : 		::gObjMakePreviewCharSet(aIndex);

  005d2	57		 push	 edi
  005d3	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  005d8	83 c4 04	 add	 esp, 4
$LN8@CGSellRequ:

; 5738 : 	{
; 5739 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  005db	0f b6 45 ed	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  005df	50		 push	 eax
  005e0	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  005e3	50		 push	 eax
  005e4	57		 push	 edi
$LN38@CGSellRequ:
  005e5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5912 : 	}
; 5913 : 
; 5914 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5915 : }

  005ea	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  005f0	33 cd		 xor	 ecx, ebp
  005f2	5f		 pop	 edi
  005f3	5e		 pop	 esi
  005f4	5b		 pop	 ebx
  005f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005fa	8b e5		 mov	 esp, ebp
  005fc	5d		 pop	 ebp
  005fd	c3		 ret	 0
?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z ENDP	; CGSellRequestRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z
_TEXT	SEGMENT
tv697 = -264						; size = 4
_bNoItem$1$ = -260					; size = 4
_lpShop$1$ = -256					; size = 4
tv764 = -252						; size = 4
_Divisor$1 = -245					; size = 1
_tShop$1$ = -244					; size = 4
_tmpPrice$1$ = -244					; size = 4
_iStoreTaxMoney$1$ = -240				; size = 4
_iItemValue$2 = -236					; size = 4
_aIndex$GSCopy$1$ = -232				; size = 4
_iStorePrice$1$ = -228					; size = 4
_lpMsg$GSCopy$1$ = -224					; size = 4
_pResult$ = -220					; size = 16
_tmpNotice$3 = -204					; size = 200
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z PROC	; CGBuyRequestRecv, COMDAT

; 5457 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx

; 5458 : 	LPOBJ lpObj = &gObj[aIndex];

  00014	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 5459 : 	PMSG_BUYRESULT pResult;
; 5460 : 
; 5461 : 	PHeadSetB((LPBYTE)&pResult, 0x32, sizeof(pResult));

  0001a	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00020	56		 push	 esi
  00021	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00024	57		 push	 edi
  00025	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00028	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0002e	6a 10		 push	 16			; 00000010H
  00030	6a 32		 push	 50			; 00000032H
  00032	50		 push	 eax
  00033	89 bd 20 ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], edi
  00039	89 b5 18 ff ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], esi
  0003f	03 d9		 add	 ebx, ecx
  00041	89 8d 04 ff ff
	ff		 mov	 DWORD PTR tv764[ebp], ecx
  00047	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 5462 : 	pResult.Result = -1;
; 5463 : 
; 5464 : 
; 5465 : 	if ( !PacketCheckTime(lpObj))

  0004c	53		 push	 ebx
  0004d	c6 85 27 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00054	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 87 06 00
	00		 je	 $LN13@CGBuyReque

; 5466 : 	{
; 5467 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5468 : 		return;
; 5469 : 	}
; 5470 : 
; 5471 : 	if ( gObj[aIndex].CloseType != -1 )

  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00069	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR tv764[ebp]
  0006f	80 7c 01 0d ff	 cmp	 BYTE PTR [ecx+eax+13], -1
  00074	0f 85 71 06 00
	00		 jne	 $LN13@CGBuyReque

; 5472 : 	{
; 5473 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5474 : 		return;
; 5475 : 	}
; 5476 : 
; 5477 : 	if ( !::gObjFixInventoryPointer(aIndex))

  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00080	83 c4 04	 add	 esp, 4
  00083	84 c0		 test	 al, al
  00085	75 18		 jne	 SHORT $LN6@CGBuyReque

; 5478 : 	{
; 5479 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  00087	68 67 15 00 00	 push	 5479			; 00001567H
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CGBuyReque:

; 5480 : 	}
; 5481 : 
; 5482 : 	if ( gObj[aIndex].m_ShopTime == 0 )

  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a5	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR tv764[ebp]
  000ab	80 bc 08 80 05
	00 00 00	 cmp	 BYTE PTR [eax+ecx+1408], 0
  000b3	75 0e		 jne	 SHORT $LN7@CGBuyReque

; 5483 : 		gObj[aIndex].m_ShopTime = 1;

  000b5	c6 84 08 80 05
	00 00 01	 mov	 BYTE PTR [eax+ecx+1408], 1
  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN7@CGBuyReque:

; 5484 : 
; 5485 : 	if ( gObj[aIndex].m_ShopTime > 	60 )

  000c3	80 bc 08 80 05
	00 00 3c	 cmp	 BYTE PTR [eax+ecx+1408], 60 ; 0000003cH

; 5486 : 	{
; 5487 : 		if ( lpObj->m_IfState.use != 0 && lpObj->m_IfState.type == 3 )

  000cb	8b 83 b8 11 00
	00		 mov	 eax, DWORD PTR [ebx+4536]
  000d1	76 38		 jbe	 SHORT $LN8@CGBuyReque
  000d3	a8 03		 test	 al, 3
  000d5	0f 84 10 06 00
	00		 je	 $LN13@CGBuyReque
  000db	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  000e0	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000e5	0f 85 00 06 00
	00		 jne	 $LN13@CGBuyReque

; 5488 : 		{
; 5489 : 			pResult.Result = (BYTE)-2;
; 5490 : 			lpObj->TargetShopNumber = -1;

  000eb	83 c8 ff	 or	 eax, -1
  000ee	c6 85 27 ff ff
	ff fe		 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH

; 5491 : 			lpObj->m_IfState.use = 0;
; 5492 : 			lpObj->m_IfState.type = 0;

  000f5	81 a3 b8 11 00
	00 3c 00 ff ff	 and	 DWORD PTR [ebx+4536], -65476 ; ffff003cH
  000ff	66 89 83 3a 06
	00 00		 mov	 WORD PTR [ebx+1594], ax

; 5493 : 		}
; 5494 : 
; 5495 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5496 : 		return;

  00106	e9 e0 05 00 00	 jmp	 $LN13@CGBuyReque
$LN8@CGBuyReque:

; 5497 : 	}
; 5498 : 
; 5499 : 	if ( lpObj->m_IfState.use > 0 )

  0010b	a8 03		 test	 al, 3
  0010d	76 10		 jbe	 SHORT $LN11@CGBuyReque

; 5500 : 	{
; 5501 : 		if ( lpObj->m_IfState.type != 3 )

  0010f	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00114	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00119	0f 85 cc 05 00
	00		 jne	 $LN13@CGBuyReque
$LN11@CGBuyReque:

; 5502 : 		{
; 5503 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5504 : 			return;
; 5505 : 		}
; 5506 : 	}
; 5507 : 
; 5508 : 	int tShop = lpObj->TargetShopNumber;

  0011f	0f bf 83 3a 06
	00 00		 movsx	 eax, WORD PTR [ebx+1594]
  00126	89 85 0c ff ff
	ff		 mov	 DWORD PTR _tShop$1$[ebp], eax

; 5509 : 
; 5510 : 	if ( tShop < 0 || tShop > MAX_SHOP-1 )

  0012c	3d f3 01 00 00	 cmp	 eax, 499		; 000001f3H
  00131	0f 87 b4 05 00
	00		 ja	 $LN13@CGBuyReque

; 5513 : 		return;
; 5514 : 	}
; 5515 : 
; 5516 : 	if ( lpMsg->Pos > MAX_ITEM_IN_SHOP-1 )

  00137	80 7f 03 77	 cmp	 BYTE PTR [edi+3], 119	; 00000077H
  0013b	0f 87 aa 05 00
	00		 ja	 $LN13@CGBuyReque

; 5517 : 	{
; 5518 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5519 : 		return;
; 5520 : 	}
; 5521 : 
; 5522 : 	CShop* lpShop = g_ShopManager.Get(tShop);

  00141	50		 push	 eax
  00142	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopManager@@3VShopManager@@A ; g_ShopManager
  00147	e8 00 00 00 00	 call	 ?Get@ShopManager@@QAEPAVCShop@@H@Z ; ShopManager::Get
  0014c	8b f8		 mov	 edi, eax
  0014e	89 bd 00 ff ff
	ff		 mov	 DWORD PTR _lpShop$1$[ebp], edi

; 5523 : 	if (!lpShop) {

  00154	85 ff		 test	 edi, edi
  00156	0f 84 a7 05 00
	00		 je	 $LN1@CGBuyReque

; 5524 : 		return;
; 5525 : 	}
; 5526 : 
; 5527 : 	if (lpShop->m_CreditPrice) {

  0015c	80 bf 04 6a 00
	00 00		 cmp	 BYTE PTR [edi+27140], 0

; 5528 : 		if (!lpShop->m_item[lpMsg->Pos].IsItem()) {

  00163	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00169	0f 84 61 01 00
	00		 je	 $LN16@CGBuyReque
  0016f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00173	69 c9 d4 00 00
	00		 imul	 ecx, ecx, 212
  00179	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  0017f	03 cf		 add	 ecx, edi
  00181	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00186	85 c0		 test	 eax, eax
  00188	0f 84 5d 05 00
	00		 je	 $LN13@CGBuyReque

; 5529 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5530 : 			return;
; 5531 : 		}
; 5532 : 		int	tmpPrice = lpShop->m_CreditPriceTable[lpMsg->Pos];

  0018e	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00194	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00198	0f bf 94 47 06
	6a 00 00	 movsx	 edx, WORD PTR [edi+eax*2+27142]

; 5533 : 		if (lpObj->m_Credits < tmpPrice) {

  001a0	8b 83 38 27 00
	00		 mov	 eax, DWORD PTR [ebx+10040]
  001a6	89 95 0c ff ff
	ff		 mov	 DWORD PTR _tmpPrice$1$[ebp], edx
  001ac	3b c2		 cmp	 eax, edx
  001ae	73 0c		 jae	 SHORT $LN18@CGBuyReque
$LN51@CGBuyReque:

; 5534 : 			pResult.Result = -1;

  001b0	c6 85 27 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH

; 5535 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5536 : 			return;

  001b7	e9 2f 05 00 00	 jmp	 $LN13@CGBuyReque
$LN18@CGBuyReque:

; 5537 : 		}
; 5538 : 		lpObj->m_Credits -= tmpPrice;

  001bc	2b c2		 sub	 eax, edx

; 5539 : 		pResult.Result = gObjShopBuyInventoryInsertItem(aIndex, lpShop->m_item[lpMsg->Pos]);

  001be	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  001c4	89 83 38 27 00
	00		 mov	 DWORD PTR [ebx+10040], eax
  001ca	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  001ce	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  001d3	69 f0 d4 00 00
	00		 imul	 esi, eax, 212
  001d9	81 c6 88 00 00
	00		 add	 esi, 136		; 00000088H
  001df	03 f7		 add	 esi, edi
  001e1	8b fc		 mov	 edi, esp
  001e3	f3 a5		 rep movsd
  001e5	8b b5 18 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  001eb	56		 push	 esi
  001ec	e8 00 00 00 00	 call	 ?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjShopBuyInventoryInsertItem
  001f1	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  001f7	88 85 27 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al

; 5540 : 		if (pResult.Result != 0xFF) {

  001fd	3c ff		 cmp	 al, 255			; 000000ffH
  001ff	0f 84 e6 04 00
	00		 je	 $LN13@CGBuyReque

; 5541 : 			char tmpNotice[200] = { 0 };
; 5542 : 			sprintf(tmpNotice, "Item has been purchased, balance: %d", lpObj->m_Credits);

  00205	68 c8 00 00 00	 push	 200			; 000000c8H
  0020a	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _tmpNotice$3[ebp]
  00210	6a 00		 push	 0
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 _memset
  00218	ff b3 38 27 00
	00		 push	 DWORD PTR [ebx+10040]
  0021e	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _tmpNotice$3[ebp]
  00224	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MFLOOBGJ@Item?5has?5been?5purchased?0?5balance@
  00229	50		 push	 eax
  0022a	e8 00 00 00 00	 call	 _sprintf

; 5543 : 			GCServerMsgStringSend(tmpNotice, aIndex, 1);

  0022f	6a 01		 push	 1
  00231	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _tmpNotice$3[ebp]
  00237	56		 push	 esi
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 5544 : 			requestDbUpdateCredits(lpObj, lpObj->m_Credits, tmpPrice);

  0023e	8b b5 0c ff ff
	ff		 mov	 esi, DWORD PTR _tmpPrice$1$[ebp]
  00244	0f b7 83 38 27
	00 00		 movzx	 eax, WORD PTR [ebx+10040]
  0024b	56		 push	 esi
  0024c	50		 push	 eax
  0024d	53		 push	 ebx
  0024e	e8 00 00 00 00	 call	 ?requestDbUpdateCredits@@YAXPAUOBJECTSTRUCT@@FF@Z ; requestDbUpdateCredits

; 5545 : 			g_CreditLog.Output("[%s] [%s] item has been purchased (%s, price: %d), balance: %d",

  00253	8b bd 20 ff ff
	ff		 mov	 edi, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00259	83 c4 30	 add	 esp, 48			; 00000030H
  0025c	ff b3 38 27 00
	00		 push	 DWORD PTR [ebx+10040]
  00262	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00266	56		 push	 esi
  00267	8b b5 00 ff ff
	ff		 mov	 esi, DWORD PTR _lpShop$1$[ebp]
  0026d	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  00273	8d 8e 88 00 00
	00		 lea	 ecx, DWORD PTR [esi+136]
  00279	03 c8		 add	 ecx, eax
  0027b	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00280	50		 push	 eax
  00281	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00284	50		 push	 eax
  00285	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00288	50		 push	 eax
  00289	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@ONDPGNEF@?$FL?$CFs?$FN?5?$FL?$CFs?$FN?5item?5has?5been?5purchase@
  0028e	68 00 00 00 00	 push	 OFFSET ?g_CreditLog@@3VCLogToFile@@A ; g_CreditLog
  00293	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 5546 : 				lpObj->AccountID, lpObj->Name, lpShop->m_item[lpMsg->Pos].GetName(), tmpPrice, lpObj->m_Credits);
; 5547 : 			ItemByteConvert((LPBYTE)&pResult.ItemInfo, lpShop->m_item[lpMsg->Pos]);

  00298	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0029c	81 c6 88 00 00
	00		 add	 esi, 136		; 00000088H
  002a2	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  002a8	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  002ae	8b fc		 mov	 edi, esp
  002b0	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  002b5	03 f0		 add	 esi, eax
  002b7	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp+4]
  002bd	f3 a5		 rep movsd
  002bf	50		 push	 eax
  002c0	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  002c5	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H

; 5548 : 		}
; 5549 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5550 : 		return;

  002cb	e9 15 04 00 00	 jmp	 $LN52@CGBuyReque
$LN16@CGBuyReque:

; 5551 : 	}
; 5552 : 
; 5553 : 	if ( lpShop->m_item[lpMsg->Pos].IsItem() == TRUE )

  002d0	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  002d4	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  002da	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  002e0	03 cf		 add	 ecx, edi
  002e2	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002e7	83 f8 01	 cmp	 eax, 1
  002ea	0f 85 fb 03 00
	00		 jne	 $LN13@CGBuyReque

; 5554 : 	{
; 5555 : 		DWORD iItemValue;
; 5556 : 		DWORD iStorePrice;
; 5557 : 		DWORD iStoreTaxMoney = 0;
; 5558 : 		BYTE Divisor;
; 5559 : 
; 5560 : 		if( g_ItemPrice.GetPrice(tShop, 

  002f0	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  002f6	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  002fa	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00300	8d 85 0b ff ff
	ff		 lea	 eax, DWORD PTR _Divisor$1[ebp]
  00306	50		 push	 eax
  00307	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR _iItemValue$2[ebp]
  0030d	50		 push	 eax
  0030e	0f b6 84 39 90
	00 00 00	 movzx	 eax, BYTE PTR [ecx+edi+144]
  00316	50		 push	 eax
  00317	0f b7 84 39 8e
	00 00 00	 movzx	 eax, WORD PTR [ecx+edi+142]
  0031f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemPrice@@3VItemPrice@@A ; g_ItemPrice
  00324	50		 push	 eax
  00325	ff b5 0c ff ff
	ff		 push	 DWORD PTR _tShop$1$[ebp]
  0032b	e8 00 00 00 00	 call	 ?GetPrice@ItemPrice@@QAE_NFGEAAKAAE@Z ; ItemPrice::GetPrice
  00330	84 c0		 test	 al, al
  00332	75 1f		 jne	 SHORT $LN49@CGBuyReque

; 5561 : 			lpShop->m_item[lpMsg->Pos].m_Type, 
; 5562 : 			lpShop->m_item[lpMsg->Pos].m_Level,
; 5563 : 			iItemValue, Divisor) )
; 5564 : 		{
; 5565 : 			
; 5566 : 		}
; 5567 : 		else
; 5568 : 		{
; 5569 : 			iItemValue = lpShop->m_item[lpMsg->Pos].m_BuyMoney;

  00334	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  0033a	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  0033e	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  00344	8b 84 38 00 01
	00 00		 mov	 eax, DWORD PTR [eax+edi+256]
  0034b	89 85 14 ff ff
	ff		 mov	 DWORD PTR _iItemValue$2[ebp], eax
  00351	eb 06		 jmp	 SHORT $LN50@CGBuyReque
$LN49@CGBuyReque:
  00353	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _iItemValue$2[ebp]
$LN50@CGBuyReque:

; 5570 : 		}
; 5571 : 
; 5572 : 		iStorePrice = iItemValue;
; 5573 : 		iStoreTaxMoney = (int)((__int64)iItemValue * (__int64)g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index) / (__int64)100);

  00359	ff 33		 push	 DWORD PTR [ebx]
  0035b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00360	89 85 1c ff ff
	ff		 mov	 DWORD PTR _iStorePrice$1$[ebp], eax
  00366	e8 00 00 00 00	 call	 ?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateStore
  0036b	6a 00		 push	 0
  0036d	ff b5 14 ff ff
	ff		 push	 DWORD PTR _iItemValue$2[ebp]
  00373	99		 cdq
  00374	52		 push	 edx
  00375	50		 push	 eax
  00376	e8 00 00 00 00	 call	 __allmul
  0037b	6a 00		 push	 0
  0037d	6a 64		 push	 100			; 00000064H
  0037f	52		 push	 edx
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 __alldiv
  00386	8b c8		 mov	 ecx, eax

; 5574 : 		iStorePrice += iStoreTaxMoney;

  00388	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _iStorePrice$1$[ebp]
  0038e	03 c1		 add	 eax, ecx
  00390	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _iStoreTaxMoney$1$[ebp], ecx
  00396	89 85 1c ff ff
	ff		 mov	 DWORD PTR _iStorePrice$1$[ebp], eax

; 5575 : 
; 5576 : 		/*if( g_ArcaBattle.IsArcaBattleServer() && iBuyMoney > 0 )
; 5577 : 		{
; 5578 : 			iBuyMoney *= 3;
; 5579 : 		}*/
; 5580 : 			
; 5581 : 		if ( iStorePrice < 0 )
; 5582 : 			iStorePrice  = 0;
; 5583 : 
; 5584 : 		if ( iStoreTaxMoney < 0 )
; 5585 : 			iStoreTaxMoney = 0;
; 5586 : 
; 5587 : 		if ( lpObj->Money < iStorePrice )

  0039c	39 83 cc 00 00
	00		 cmp	 DWORD PTR [ebx+204], eax
  003a2	0f 82 08 fe ff
	ff		 jb	 $LN51@CGBuyReque

; 5588 : 			pResult.Result = -1;
; 5589 : 		else
; 5590 : 		{
; 5591 : 			BOOL bNoItem = TRUE;
; 5592 : 
; 5593 : 			if ( (lpShop->m_item[lpMsg->Pos].m_Type >= ITEMGET(14,0) && lpShop->m_item[lpMsg->Pos].m_Type <= ITEMGET(14,8)) ||

  003a8	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  003ae	b9 00 1c 00 00	 mov	 ecx, 7168		; 00001c00H
  003b3	c7 85 fc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _bNoItem$1$[ebp], 1
  003bd	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  003c1	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  003c7	0f b7 94 38 8e
	00 00 00	 movzx	 edx, WORD PTR [eax+edi+142]
  003cf	66 3b d1	 cmp	 dx, cx
  003d2	7c 0a		 jl	 SHORT $LN29@CGBuyReque
  003d4	b9 08 1c 00 00	 mov	 ecx, 7176		; 00001c08H
  003d9	66 3b d1	 cmp	 dx, cx
  003dc	7e 1c		 jle	 SHORT $LN28@CGBuyReque
$LN29@CGBuyReque:
  003de	b9 23 1c 00 00	 mov	 ecx, 7203		; 00001c23H
  003e3	66 3b d1	 cmp	 dx, cx
  003e6	0f 8c 99 00 00
	00		 jl	 $LN31@CGBuyReque
  003ec	b9 28 1c 00 00	 mov	 ecx, 7208		; 00001c28H
  003f1	66 3b d1	 cmp	 dx, cx
  003f4	0f 8f 8b 00 00
	00		 jg	 $LN31@CGBuyReque
$LN28@CGBuyReque:

; 5594 : 				 (lpShop->m_item[lpMsg->Pos].m_Type >= ITEMGET(14,35) && lpShop->m_item[lpMsg->Pos].m_Type <= ITEMGET(14,40)))
; 5595 : 			{
; 5596 : 				int dur = (int)lpShop->m_item[lpMsg->Pos].m_Durability;

  003fa	f3 0f 2c 8c 38
	ac 00 00 00	 cvttss2si ecx, DWORD PTR [eax+edi+172]

; 5597 : 
; 5598 : 				if ( dur == 0 )
; 5599 : 					dur = 1;
; 5600 : 
; 5601 : 				if ( ::gObjSearchItem(&gObj[aIndex], lpShop->m_item[lpMsg->Pos].m_Type,dur, lpShop->m_item[lpMsg->Pos].m_Level) == TRUE )

  00403	0f bf 84 38 90
	00 00 00	 movsx	 eax, WORD PTR [eax+edi+144]
  0040b	50		 push	 eax
  0040c	c7 85 f8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv697[ebp], 1
  00416	0f bf c2	 movsx	 eax, dx
  00419	85 c9		 test	 ecx, ecx
  0041b	0f 44 8d f8 fe
	ff ff		 cmove	 ecx, DWORD PTR tv697[ebp]
  00422	51		 push	 ecx
  00423	50		 push	 eax
  00424	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00429	03 85 04 ff ff
	ff		 add	 eax, DWORD PTR tv764[ebp]
  0042f	50		 push	 eax
  00430	e8 00 00 00 00	 call	 ?gObjSearchItem@@YAHPAUOBJECTSTRUCT@@HHH@Z ; gObjSearchItem
  00435	83 c4 10	 add	 esp, 16			; 00000010H
  00438	83 f8 01	 cmp	 eax, 1
  0043b	75 48		 jne	 SHORT $LN31@CGBuyReque

; 5602 : 				{
; 5603 : 					bNoItem = FALSE;
; 5604 : 					lpObj->Money -= iStorePrice;

  0043d	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _iStorePrice$1$[ebp]

; 5605 : 					::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney);

  00443	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00448	ff b5 10 ff ff
	ff		 push	 DWORD PTR _iStoreTaxMoney$1$[ebp]
  0044e	29 83 cc 00 00
	00		 sub	 DWORD PTR [ebx+204], eax
  00454	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bNoItem$1$[ebp], 0
  0045e	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 5606 : 
; 5607 : 					if ( lpObj->Money < 0 )

  00463	83 bb cc 00 00
	00 00		 cmp	 DWORD PTR [ebx+204], 0
  0046a	7d 0a		 jge	 SHORT $LN32@CGBuyReque

; 5608 : 						lpObj->Money = 0;

  0046c	c7 83 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+204], 0
$LN32@CGBuyReque:

; 5609 : 
; 5610 : 		
; 5611 : 					::GCMoneySend(aIndex, lpObj->Money);

  00476	ff b3 cc 00 00
	00		 push	 DWORD PTR [ebx+204]
  0047c	56		 push	 esi
  0047d	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00482	83 c4 08	 add	 esp, 8
$LN31@CGBuyReque:

; 5612 : 				}
; 5613 : 			}
; 5614 : 
; 5615 : 			if ( lpShop->m_item[lpMsg->Pos].m_Type >= ITEMGET(13,71) && lpShop->m_item[lpMsg->Pos].m_Type <= ITEMGET(13,75) )

  00485	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  0048b	ba 47 1a 00 00	 mov	 edx, 6727		; 00001a47H
  00490	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00494	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0049a	0f b7 84 39 8e
	00 00 00	 movzx	 eax, WORD PTR [ecx+edi+142]
  004a2	66 3b c2	 cmp	 ax, dx
  004a5	0f 8c dd 00 00
	00		 jl	 $LN42@CGBuyReque
  004ab	ba 4b 1a 00 00	 mov	 edx, 6731		; 00001a4bH
  004b0	66 3b c2	 cmp	 ax, dx
  004b3	0f 8f cf 00 00
	00		 jg	 $LN42@CGBuyReque

; 5616 : 			{
; 5617 : 				bNoItem = FALSE;
; 5618 : 
; 5619 : 				if( CheckInventoryEmptySpace(lpObj,4,2) == FALSE )

  004b9	6a 02		 push	 2
  004bb	6a 04		 push	 4
  004bd	53		 push	 ebx
  004be	e8 00 00 00 00	 call	 ?CheckInventoryEmptySpace@@YAHPAUOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
  004c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c6	85 c0		 test	 eax, eax
  004c8	75 13		 jne	 SHORT $LN34@CGBuyReque

; 5620 : 				{
; 5621 : 					MsgOutput(aIndex,"You have no enough empty space");

  004ca	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@FPLNFNIC@You?5have?5no?5enough?5empty?5space?$AA@
  004cf	56		 push	 esi
  004d0	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  004d5	83 c4 08	 add	 esp, 8

; 5622 : 				}
; 5623 : 				else

  004d8	e9 0e 02 00 00	 jmp	 $LN13@CGBuyReque
$LN34@CGBuyReque:

; 5624 : 				{
; 5625 : 					int type = -1;
; 5626 : 
; 5627 : 					switch( lpShop->m_item[lpMsg->Pos].m_Type )

  004dd	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  004e3	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  004e7	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  004ed	0f bf 84 38 8e
	00 00 00	 movsx	 eax, WORD PTR [eax+edi+142]
  004f5	05 b9 e5 ff ff	 add	 eax, -6727		; ffffe5b9H
  004fa	83 f8 04	 cmp	 eax, 4
  004fd	0f 87 e8 01 00
	00		 ja	 $LN13@CGBuyReque
  00503	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN54@CGBuyReque[eax*4]
$LN36@CGBuyReque:

; 5628 : 					{
; 5629 : 					case ITEMGET(13,71):	type = 0;	break;

  0050a	33 c0		 xor	 eax, eax
  0050c	eb 1a		 jmp	 SHORT $LN48@CGBuyReque
$LN37@CGBuyReque:

; 5630 : 					case ITEMGET(13,72):	type = 1;	break;

  0050e	b8 01 00 00 00	 mov	 eax, 1
  00513	eb 13		 jmp	 SHORT $LN48@CGBuyReque
$LN38@CGBuyReque:

; 5631 : 					case ITEMGET(13,73):	type = 2;	break;

  00515	b8 02 00 00 00	 mov	 eax, 2
  0051a	eb 0c		 jmp	 SHORT $LN48@CGBuyReque
$LN39@CGBuyReque:

; 5632 : 					case ITEMGET(13,74):	type = 3;	break;

  0051c	b8 03 00 00 00	 mov	 eax, 3
  00521	eb 05		 jmp	 SHORT $LN48@CGBuyReque
$LN40@CGBuyReque:

; 5633 : 					case ITEMGET(13,75):	type = 4;	break;

  00523	b8 04 00 00 00	 mov	 eax, 4
$LN48@CGBuyReque:

; 5634 : 					}
; 5635 : 
; 5636 : 					if( type != -1 )
; 5637 : 					{
; 5638 : 						if ( gGamblingEvent.BuyRequest(aIndex,236,0,0,type) == TRUE )

  00528	50		 push	 eax
  00529	6a 00		 push	 0
  0052b	6a 00		 push	 0
  0052d	68 ec 00 00 00	 push	 236			; 000000ecH
  00532	56		 push	 esi
  00533	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGamblingEvent@@3VCGamblingEvent@@A ; gGamblingEvent
  00538	e8 00 00 00 00	 call	 ?BuyRequest@CGamblingEvent@@QAEEHEEEE@Z ; CGamblingEvent::BuyRequest
  0053d	3c 01		 cmp	 al, 1
  0053f	0f 85 a6 01 00
	00		 jne	 $LN13@CGBuyReque

; 5639 : 						{
; 5640 : 							bNoItem = FALSE;
; 5641 : 							lpObj->Money -= iStorePrice;

  00545	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _iStorePrice$1$[ebp]

; 5642 : 							::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney);

  0054b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00550	ff b5 10 ff ff
	ff		 push	 DWORD PTR _iStoreTaxMoney$1$[ebp]
  00556	29 83 cc 00 00
	00		 sub	 DWORD PTR [ebx+204], eax
  0055c	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 5643 : 		
; 5644 : 							if ( lpObj->Money < 0 )

  00561	83 bb cc 00 00
	00 00		 cmp	 DWORD PTR [ebx+204], 0
  00568	7d 0a		 jge	 SHORT $LN43@CGBuyReque

; 5645 : 								lpObj->Money = 0;	

  0056a	c7 83 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+204], 0
$LN43@CGBuyReque:

; 5646 : 				
; 5647 : 							::GCMoneySend(aIndex, lpObj->Money);

  00574	ff b3 cc 00 00
	00		 push	 DWORD PTR [ebx+204]
  0057a	56		 push	 esi
  0057b	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00580	83 c4 08	 add	 esp, 8

; 5648 : 						}
; 5649 : 					}
; 5650 : 				}
; 5651 : 			}
; 5652 : 
; 5653 : 			if ( bNoItem != FALSE )

  00583	e9 63 01 00 00	 jmp	 $LN13@CGBuyReque
$LN42@CGBuyReque:
  00588	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR _bNoItem$1$[ebp], 0
  0058f	0f 84 56 01 00
	00		 je	 $LN13@CGBuyReque

; 5654 : 			{
; 5655 : 				pResult.Result = gObjShopBuyInventoryInsertItem(aIndex, lpShop->m_item[lpMsg->Pos]);

  00595	8d b1 88 00 00
	00		 lea	 esi, DWORD PTR [ecx+136]
  0059b	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  005a1	03 f7		 add	 esi, edi
  005a3	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  005a8	8b fc		 mov	 edi, esp
  005aa	f3 a5		 rep movsd
  005ac	8b b5 18 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  005b2	56		 push	 esi
  005b3	e8 00 00 00 00	 call	 ?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjShopBuyInventoryInsertItem
  005b8	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  005be	88 85 27 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al

; 5656 : 				
; 5657 : 				if ( pResult.Result != 0xFF )

  005c4	3c ff		 cmp	 al, 255			; 000000ffH
  005c6	0f 84 1f 01 00
	00		 je	 $LN13@CGBuyReque

; 5658 : 				{
; 5659 : 					ItemByteConvert((LPBYTE)&pResult.ItemInfo, lpShop->m_item[lpMsg->Pos]);

  005cc	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  005d2	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  005d8	8b b5 00 ff ff
	ff		 mov	 esi, DWORD PTR _lpShop$1$[ebp]
  005de	8b fc		 mov	 edi, esp
  005e0	81 c6 88 00 00
	00		 add	 esi, 136		; 00000088H
  005e6	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  005eb	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  005ef	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  005f5	03 f0		 add	 esi, eax
  005f7	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp+4]
  005fd	f3 a5		 rep movsd
  005ff	50		 push	 eax
  00600	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 5660 : 					lpObj->Money -= iStorePrice;

  00605	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _iStorePrice$1$[ebp]
  0060b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00611	29 83 cc 00 00
	00		 sub	 DWORD PTR [ebx+204], eax

; 5661 : 					::g_CastleSiegeSync.AddTributeMoney(iStoreTaxMoney);

  00617	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  0061c	ff b5 10 ff ff
	ff		 push	 DWORD PTR _iStoreTaxMoney$1$[ebp]
  00622	e8 00 00 00 00	 call	 ?AddTributeMoney@CCastleSiegeSync@@QAEXH@Z ; CCastleSiegeSync::AddTributeMoney

; 5662 : 
; 5663 : 					if ( lpObj->Money < 0 )

  00627	83 bb cc 00 00
	00 00		 cmp	 DWORD PTR [ebx+204], 0
  0062e	7d 0a		 jge	 SHORT $LN46@CGBuyReque

; 5664 : 						lpObj->Money = 0;

  00630	c7 83 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+204], 0
$LN46@CGBuyReque:

; 5665 : 
; 5666 : 					GCMoneySend(aIndex, lpObj->Money);

  0063a	ff b3 cc 00 00
	00		 push	 DWORD PTR [ebx+204]
  00640	ff b5 18 ff ff
	ff		 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  00646	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0064b	83 c4 08	 add	 esp, 8

; 5667 : 					int iTaxRate = g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index);

  0064e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  00653	ff 33		 push	 DWORD PTR [ebx]
  00655	e8 00 00 00 00	 call	 ?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateStore

; 5668 : 
; 5669 : 					LogAddTD("[%s][%s] (%d) Shop buy [%d][%d][%d][%s] LEV:%d, DUR:%d, OP:[%d][%d][%d]",

  0065a	8b bd 00 ff ff
	ff		 mov	 edi, DWORD PTR _lpShop$1$[ebp]
  00660	8b f0		 mov	 esi, eax
  00662	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00668	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0066c	69 d1 d4 00 00
	00		 imul	 edx, ecx, 212
  00672	0f b6 8c 3a 1a
	01 00 00	 movzx	 ecx, BYTE PTR [edx+edi+282]
  0067a	f3 0f 10 84 3a
	ac 00 00 00	 movss	 xmm0, DWORD PTR [edx+edi+172]
  00683	0f bf 84 3a 90
	00 00 00	 movsx	 eax, WORD PTR [edx+edi+144]
  0068b	51		 push	 ecx
  0068c	0f b6 8c 3a 19
	01 00 00	 movzx	 ecx, BYTE PTR [edx+edi+281]
  00694	51		 push	 ecx
  00695	0f b6 8c 3a 18
	01 00 00	 movzx	 ecx, BYTE PTR [edx+edi+280]
  0069d	51		 push	 ecx
  0069e	0f 5a c0	 cvtps2pd xmm0, xmm0
  006a1	83 ec 08	 sub	 esp, 8
  006a4	8d 8f 88 00 00
	00		 lea	 ecx, DWORD PTR [edi+136]
  006aa	03 ca		 add	 ecx, edx
  006ac	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  006b1	50		 push	 eax
  006b2	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  006b7	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _iItemValue$2[ebp]
  006bd	50		 push	 eax
  006be	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _iStoreTaxMoney$1$[ebp]
  006c4	03 c1		 add	 eax, ecx
  006c6	50		 push	 eax
  006c7	56		 push	 esi
  006c8	51		 push	 ecx
  006c9	ff b5 0c ff ff
	ff		 push	 DWORD PTR _tShop$1$[ebp]
  006cf	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  006d2	50		 push	 eax
  006d3	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  006d6	50		 push	 eax
  006d7	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@PNDIMLBH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CI?$CFd?$CJ?5Shop?5buy?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$FL@
  006dc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006e2	83 c4 38	 add	 esp, 56			; 00000038H
$LN52@CGBuyReque:
  006e5	8b b5 18 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
$LN13@CGBuyReque:

; 5511 : 	{
; 5512 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  006eb	0f b6 85 25 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  006f2	50		 push	 eax
  006f3	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  006f9	50		 push	 eax
  006fa	56		 push	 esi
  006fb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00700	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGBuyReque:

; 5670 : 						lpObj->AccountID, lpObj->Name, tShop, iItemValue, iTaxRate, iItemValue+iStoreTaxMoney, lpShop->m_item[lpMsg->Pos].GetName(),
; 5671 : 						lpShop->m_item[lpMsg->Pos].m_Level, lpShop->m_item[lpMsg->Pos].m_Durability,
; 5672 : 						lpShop->m_item[lpMsg->Pos].m_Option1, lpShop->m_item[lpMsg->Pos].m_Option2,
; 5673 : 						lpShop->m_item[lpMsg->Pos].m_Option3);
; 5674 : 				}
; 5675 : 			}
; 5676 : 		}
; 5677 : 	}
; 5678 : 
; 5679 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 5680 : }

  00703	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00706	5f		 pop	 edi
  00707	5e		 pop	 esi
  00708	33 cd		 xor	 ecx, ebp
  0070a	5b		 pop	 ebx
  0070b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00710	8b e5		 mov	 esp, ebp
  00712	5d		 pop	 ebp
  00713	c3		 ret	 0
$LN54@CGBuyReque:
  00714	00 00 00 00	 DD	 $LN36@CGBuyReque
  00718	00 00 00 00	 DD	 $LN37@CGBuyReque
  0071c	00 00 00 00	 DD	 $LN38@CGBuyReque
  00720	00 00 00 00	 DD	 $LN39@CGBuyReque
  00724	00 00 00 00	 DD	 $LN40@CGBuyReque
?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z ENDP	; CGBuyRequestRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$GSCopy$1$ = -4120				; size = 4
_n$1$ = -4116						; size = 4
_pMsg$ = -4112						; size = 6
_lOfs$1$ = -4104					; size = 4
_SendByte$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z PROC	; GCUserWarehouseSend, COMDAT

; 5403 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 18 10 00 00	 mov	 eax, 4120		; 00001018H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0001c	57		 push	 edi
  0001d	89 b5 e8 ef ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$1$[ebp], esi

; 5404 : 	if ( lpObj->m_IfState.type != 6 )

  00023	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  00029	8b c1		 mov	 eax, ecx
  0002b	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00030	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  00035	0f 85 53 01 00
	00		 jne	 $LN8@GCUserWare

; 5405 : 		return;
; 5406 : 
; 5407 : 	if ( lpObj->m_IfState.type == 6 && lpObj->m_IfState.state == 1 )

  0003b	80 e1 3c	 and	 cl, 60			; 0000003cH
  0003e	80 f9 04	 cmp	 cl, 4
  00041	0f 84 47 01 00
	00		 je	 $LN8@GCUserWare

; 5408 : 		return;
; 5409 : 
; 5410 : 	PMSG_SHOPITEMCOUNT pMsg;
; 5411 : 	BYTE SendByte[4096];
; 5412 : 	int lOfs = sizeof(pMsg);
; 5413 : 
; 5414 : 	PHeadSetW((LPBYTE)&pMsg, 0x31, 0);

  00047	6a 00		 push	 0
  00049	8d 85 f0 ef ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0004f	c7 85 f8 ef ff
	ff 06 00 00 00	 mov	 DWORD PTR _lOfs$1$[ebp], 6
  00059	6a 31		 push	 49			; 00000031H
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5415 : 	pMsg.count = 0;
; 5416 : 	pMsg.Type = 0;

  00064	66 c7 85 f4 ef
	ff ff 00 00	 mov	 WORD PTR _pMsg$[ebp+4], 0

; 5417 : 
; 5418 : 	for ( int n=0;n<WAREHOUSE_SIZE;n++)

  0006d	c7 85 ec ef ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  00077	33 db		 xor	 ebx, ebx
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@GCUserWare:

; 5419 : 	{
; 5420 : 		if ( lpObj->pWarehouse[n].IsItem() == TRUE )

  00080	8b 8e f8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4600]
  00086	03 cb		 add	 ecx, ebx
  00088	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0008d	83 f8 01	 cmp	 eax, 1
  00090	75 62		 jne	 SHORT $LN14@GCUserWare

; 5421 : 		{
; 5422 : 			SendByte[lOfs] = n;

  00092	8b 85 f8 ef ff
	ff		 mov	 eax, DWORD PTR _lOfs$1$[ebp]

; 5423 : 			lOfs++;
; 5424 : 			ItemByteConvert(&SendByte[lOfs], lpObj->pWarehouse[n] );

  00098	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0009e	8b b6 f8 11 00
	00		 mov	 esi, DWORD PTR [esi+4600]
  000a4	8b fc		 mov	 edi, esp
  000a6	8b 8d ec ef ff
	ff		 mov	 ecx, DWORD PTR _n$1$[ebp]
  000ac	03 f3		 add	 esi, ebx
  000ae	88 8c 05 fc ef
	ff ff		 mov	 BYTE PTR _SendByte$[ebp+eax], cl
  000b5	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  000ba	40		 inc	 eax
  000bb	f3 a5		 rep movsd
  000bd	8d 8d fc ef ff
	ff		 lea	 ecx, DWORD PTR _SendByte$[ebp]
  000c3	89 85 f8 ef ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], eax
  000c9	03 c1		 add	 eax, ecx
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 5425 : 			lOfs += MAX_ITEM_INFO;

  000d1	8b 8d f8 ef ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
  000d7	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  000dd	8b b5 e8 ef ff
	ff		 mov	 esi, DWORD PTR _lpObj$GSCopy$1$[ebp]
  000e3	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 5426 : 			pMsg.count ++;

  000e6	fe 85 f5 ef ff
	ff		 inc	 BYTE PTR _pMsg$[ebp+5]
  000ec	89 8d f8 ef ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
  000f2	eb 06		 jmp	 SHORT $LN2@GCUserWare
$LN14@GCUserWare:
  000f4	8b 8d f8 ef ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
$LN2@GCUserWare:

; 5417 : 
; 5418 : 	for ( int n=0;n<WAREHOUSE_SIZE;n++)

  000fa	ff 85 ec ef ff
	ff		 inc	 DWORD PTR _n$1$[ebp]
  00100	81 c3 d4 00 00
	00		 add	 ebx, 212		; 000000d4H
  00106	81 fb c0 c6 00
	00		 cmp	 ebx, 50880		; 0000c6c0H
  0010c	0f 8c 6e ff ff
	ff		 jl	 $LL4@GCUserWare

; 5427 : 		}
; 5428 : 	}
; 5429 : 
; 5430 : 	pMsg.h.sizeH = SET_NUMBERH(lOfs);

  00112	8b c1		 mov	 eax, ecx

; 5431 : 	pMsg.h.sizeL = SET_NUMBERL(lOfs);

  00114	88 8d f2 ef ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+2], cl
  0011a	c1 e8 08	 shr	 eax, 8
  0011d	88 85 f1 ef ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+1], al

; 5432 : 	memcpy(SendByte, &pMsg, sizeof(pMsg));

  00123	8b 85 f0 ef ff
	ff		 mov	 eax, DWORD PTR _pMsg$[ebp]
  00129	89 85 fc ef ff
	ff		 mov	 DWORD PTR _SendByte$[ebp], eax
  0012f	66 8b 85 f4 ef
	ff ff		 mov	 ax, WORD PTR _pMsg$[ebp+4]
  00136	66 89 85 00 f0
	ff ff		 mov	 WORD PTR _SendByte$[ebp+4], ax

; 5433 : 
; 5434 : 	DataSend(lpObj->m_Index, SendByte, lOfs);

  0013d	8d 85 fc ef ff
	ff		 lea	 eax, DWORD PTR _SendByte$[ebp]
  00143	51		 push	 ecx
  00144	50		 push	 eax
  00145	ff 36		 push	 DWORD PTR [esi]
  00147	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5435 : 	GCWarehouseInventoryMoneySend(lpObj->m_Index, 1, lpObj->Money, lpObj->WarehouseMoney);

  0014c	ff b6 08 12 00
	00		 push	 DWORD PTR [esi+4616]
  00152	ff b6 cc 00 00
	00		 push	 DWORD PTR [esi+204]
  00158	6a 01		 push	 1
  0015a	ff 36		 push	 DWORD PTR [esi]
  0015c	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend

; 5436 : 
; 5437 : 	if ( lpObj->m_IfState.type == 6 )

  00161	8b 8e b8 11 00
	00		 mov	 ecx, DWORD PTR [esi+4536]
  00167	83 c4 1c	 add	 esp, 28			; 0000001cH
  0016a	8b c1		 mov	 eax, ecx
  0016c	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00171	3d 80 01 00 00	 cmp	 eax, 384		; 00000180H
  00176	75 16		 jne	 SHORT $LN8@GCUserWare

; 5438 : 	{
; 5439 : 		lpObj->m_IfState.state = 1;

  00178	83 e1 c7	 and	 ecx, -57		; ffffffc7H

; 5440 : 		lpObj->WarehouseSave = TRUE;

  0017b	c7 86 0c 12 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+4620], 1
  00185	83 c9 04	 or	 ecx, 4
  00188	89 8e b8 11 00
	00		 mov	 DWORD PTR [esi+4536], ecx
$LN8@GCUserWare:

; 5441 : 	}
; 5442 : }

  0018e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00191	5f		 pop	 edi
  00192	5e		 pop	 esi
  00193	33 cd		 xor	 ecx, ebp
  00195	5b		 pop	 ebx
  00196	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c3		 ret	 0
?GCUserWarehouseSend@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; GCUserWarehouseSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z
_TEXT	SEGMENT
tv661 = -2084						; size = 4
_pShopItemCount$ = -2080				; size = 6
_lpMsg$GSCopy$1$ = -2072				; size = 4
_lpShop$1$ = -2072					; size = 4
tv654 = -2068						; size = 4
tv652 = -2068						; size = 4
_ShopNum$1$ = -2068					; size = 4
_pResult$ = -2064					; size = 11
_SendByte$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z PROC	; CGTalkRequestRecv, COMDAT

; 5171 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 08 00
	00		 sub	 esp, 2084		; 00000824H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001a	56		 push	 esi

; 5172 : 	LPOBJ lpObj = &gObj[aIndex];

  0001b	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00021	57		 push	 edi
  00022	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	89 85 e8 f7 ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], eax
  0002e	03 fe		 add	 edi, esi
  00030	89 b5 dc f7 ff
	ff		 mov	 DWORD PTR tv661[ebp], esi

; 5173 : 	int DealerNumber ;
; 5174 : 	PMSG_TALKRESULT pResult;
; 5175 : 	PMSG_SHOPITEMCOUNT pShopItemCount;
; 5176 : 
; 5177 : 	if ( !PacketCheckTime(lpObj))

  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0003c	83 c4 04	 add	 esp, 4
  0003f	85 c0		 test	 eax, eax
  00041	0f 84 89 05 00
	00		 je	 $LN10@CGTalkRequ

; 5178 : 		return;
; 5179 : 
; 5180 : 	if ( gObj[aIndex].CloseType != -1 )

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0004c	80 7c 06 0d ff	 cmp	 BYTE PTR [esi+eax+13], -1
  00051	0f 85 79 05 00
	00		 jne	 $LN10@CGTalkRequ

; 5181 : 		return;
; 5182 : 
; 5183 : 	if ( !gObjIsConnectedGP(aIndex) )

  00057	53		 push	 ebx
  00058	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0005d	83 c4 04	 add	 esp, 4
  00060	85 c0		 test	 eax, eax
  00062	75 31		 jne	 SHORT $LN4@CGTalkRequ

; 5184 : 	{
; 5185 : 		LogAddTD("[ANTI-HACK][NPC Talk] Couldn't talk.. (%s)(%s)",

  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006a	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0006d	03 c6		 add	 eax, esi
  0006f	50		 push	 eax
  00070	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00073	03 c6		 add	 eax, esi
  00075	50		 push	 eax
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@GINMLCLK@?$FLANTI?9HACK?$FN?$FLNPC?5Talk?$FN?5Couldn?8t?5t@
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5282 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 122)), aIndex);

  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 5394 : 	}
; 5395 : }

  00087	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008a	33 cd		 xor	 ecx, ebp
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LN4@CGTalkRequ:

; 5186 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);
; 5187 : 
; 5188 : 		return;
; 5189 : 	}
; 5190 : 
; 5191 : 	BYTE SendByte[2048];
; 5192 : 	int lOfs = 0;
; 5193 : 
; 5194 : 	if ( lpObj->m_IfState.use > 0 )

  00095	f6 87 b8 11 00
	00 03		 test	 BYTE PTR [edi+4536], 3
  0009c	0f 87 2e 05 00
	00		 ja	 $LN10@CGTalkRequ

; 5195 : 		return;
; 5196 : 
; 5197 : 	DealerNumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  000a2	8b 95 e8 f7 ff
	ff		 mov	 edx, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  000a8	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  000ac	66 c1 e0 08	 shl	 ax, 8
  000b0	0f b7 c8	 movzx	 ecx, ax
  000b3	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  000b7	0b c8		 or	 ecx, eax

; 5198 : 	
; 5199 : 	if ( DealerNumber < 0 || DealerNumber > OBJMAX-1)

  000b9	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  000bf	0f 87 0b 05 00
	00		 ja	 $LN10@CGTalkRequ

; 5200 : 		return;
; 5201 : 
; 5202 : 	if ( lpObj->MapNumber != gObj[DealerNumber].MapNumber )

  000c5	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  000cb	69 f1 40 27 00
	00		 imul	 esi, ecx, 10048
  000d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d7	03 ce		 add	 ecx, esi
  000d9	3a 81 23 01 00
	00		 cmp	 al, BYTE PTR [ecx+291]
  000df	0f 85 eb 04 00
	00		 jne	 $LN10@CGTalkRequ

; 5203 : 		return;
; 5204 : 
; 5205 : 	if ( (lpObj->X < (gObj[DealerNumber].X-5) )|| (lpObj->X> (gObj[DealerNumber].X+5) )||(lpObj->Y < (gObj[DealerNumber].Y-5)) ||(lpObj->Y > (gObj[DealerNumber].Y+5)))

  000e5	0f b6 91 20 01
	00 00		 movzx	 edx, BYTE PTR [ecx+288]
  000ec	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  000f3	89 85 ec f7 ff
	ff		 mov	 DWORD PTR tv654[ebp], eax
  000f9	8d 42 fb	 lea	 eax, DWORD PTR [edx-5]
  000fc	39 85 ec f7 ff
	ff		 cmp	 DWORD PTR tv654[ebp], eax
  00102	0f 8c c8 04 00
	00		 jl	 $LN10@CGTalkRequ
  00108	8d 42 05	 lea	 eax, DWORD PTR [edx+5]
  0010b	39 85 ec f7 ff
	ff		 cmp	 DWORD PTR tv654[ebp], eax
  00111	0f 8f b9 04 00
	00		 jg	 $LN10@CGTalkRequ
  00117	0f b6 91 21 01
	00 00		 movzx	 edx, BYTE PTR [ecx+289]
  0011e	0f b6 87 21 01
	00 00		 movzx	 eax, BYTE PTR [edi+289]
  00125	89 85 ec f7 ff
	ff		 mov	 DWORD PTR tv652[ebp], eax
  0012b	8d 42 fb	 lea	 eax, DWORD PTR [edx-5]
  0012e	39 85 ec f7 ff
	ff		 cmp	 DWORD PTR tv652[ebp], eax
  00134	0f 8c 96 04 00
	00		 jl	 $LN10@CGTalkRequ
  0013a	8d 42 05	 lea	 eax, DWORD PTR [edx+5]
  0013d	39 85 ec f7 ff
	ff		 cmp	 DWORD PTR tv652[ebp], eax
  00143	0f 8f 87 04 00
	00		 jg	 $LN10@CGTalkRequ

; 5206 : 	{
; 5207 : 		return;
; 5208 : 	}
; 5209 : 
; 5210 : 	int ShopNum = gObj[DealerNumber].ShopNumber;
; 5211 : 
; 5212 : 	if ( gObj[DealerNumber].Type == OBJ_NPC )

  00149	80 79 50 03	 cmp	 BYTE PTR [ecx+80], 3
  0014d	0f bf 81 3c 06
	00 00		 movsx	 eax, WORD PTR [ecx+1596]
  00154	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _ShopNum$1$[ebp], eax
  0015a	75 13		 jne	 SHORT $LN12@CGTalkRequ

; 5213 : 	{
; 5214 : 		if ( NpcTalk(&gObj[DealerNumber], lpObj) == TRUE )

  0015c	57		 push	 edi
  0015d	51		 push	 ecx
  0015e	e8 00 00 00 00	 call	 ?NpcTalk@@YAHPAUOBJECTSTRUCT@@0@Z ; NpcTalk
  00163	83 c4 08	 add	 esp, 8
  00166	83 f8 01	 cmp	 eax, 1
  00169	0f 84 61 04 00
	00		 je	 $LN10@CGTalkRequ
$LN12@CGTalkRequ:

; 5215 : 			return;
; 5216 : 	}
; 5217 : 
; 5218 : 	if ( ::gObjFixInventoryPointer(aIndex) == false )

  0016f	53		 push	 ebx
  00170	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00175	83 c4 04	 add	 esp, 4
  00178	84 c0		 test	 al, al
  0017a	75 18		 jne	 SHORT $LN13@CGTalkRequ

; 5219 : 	{
; 5220 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0017c	68 64 14 00 00	 push	 5220			; 00001464H
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@CGTalkRequ:

; 5221 : 	}
; 5222 : 
; 5223 : 	if ( gObj[DealerNumber].Class == 234 )	// Npc Server Division

  00194	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00199	b9 ea 00 00 00	 mov	 ecx, 234		; 000000eaH
  0019e	66 39 8c 30 90
	00 00 00	 cmp	 WORD PTR [eax+esi+144], cx
  001a6	75 2d		 jne	 SHORT $LN14@CGTalkRequ

; 5224 : 	{
; 5225 : 		pResult.h.c = 0xC3;
; 5226 : 		pResult.h.headcode = 0x30;
; 5227 : 		pResult.h.size = sizeof(pResult);
; 5228 : 		pResult.result = 0;
; 5229 : 		pResult.result = 5;
; 5230 : 
; 5231 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  001a8	6a 0b		 push	 11			; 0000000bH
  001aa	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  001b0	c7 85 f0 f7 ff
	ff c3 0b 30 05	 mov	 DWORD PTR _pResult$[ebp], 87034819 ; 05300bc3H
  001ba	50		 push	 eax
  001bb	53		 push	 ebx
  001bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5282 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 122)), aIndex);

  001c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c4	5f		 pop	 edi
  001c5	5e		 pop	 esi
  001c6	5b		 pop	 ebx

; 5394 : 	}
; 5395 : }

  001c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ca	33 cd		 xor	 ecx, ebp
  001cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d1	8b e5		 mov	 esp, ebp
  001d3	5d		 pop	 ebp
  001d4	c3		 ret	 0
$LN14@CGTalkRequ:

; 5232 : 		return;
; 5233 : 	}
; 5234 : 
; 5235 : 	if ( gObj[DealerNumber].Type == OBJ_NPC && ShopNum < 0)

  001d5	80 7c 30 50 03	 cmp	 BYTE PTR [eax+esi+80], 3
  001da	8b 85 ec f7 ff
	ff		 mov	 eax, DWORD PTR _ShopNum$1$[ebp]
  001e0	75 08		 jne	 SHORT $LN15@CGTalkRequ
  001e2	85 c0		 test	 eax, eax
  001e4	0f 88 e6 03 00
	00		 js	 $LN10@CGTalkRequ
$LN15@CGTalkRequ:

; 5236 : 		return;
; 5237 : 
; 5238 : 	CShop* lpShop = g_ShopManager.Get(ShopNum);

  001ea	50		 push	 eax
  001eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopManager@@3VShopManager@@A ; g_ShopManager
  001f0	e8 00 00 00 00	 call	 ?Get@ShopManager@@QAEPAVCShop@@H@Z ; ShopManager::Get
  001f5	89 85 e8 f7 ff
	ff		 mov	 DWORD PTR _lpShop$1$[ebp], eax

; 5239 : 
; 5240 : 	if( lpShop )

  001fb	85 c0		 test	 eax, eax
  001fd	74 30		 je	 SHORT $LN17@CGTalkRequ

; 5241 : 	{
; 5242 : 		if ( lpShop->ItemCount < TRUE )

  001ff	83 b8 84 00 00
	00 01		 cmp	 DWORD PTR [eax+132], 1
  00206	7d 27		 jge	 SHORT $LN17@CGTalkRequ

; 5243 : 		{
; 5244 : 			if ( (rand()%2) != 0 )

  00208	e8 00 00 00 00	 call	 _rand
  0020d	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00212	79 05		 jns	 SHORT $LN45@CGTalkRequ
  00214	48		 dec	 eax
  00215	83 c8 fe	 or	 eax, -2			; fffffffeH
  00218	40		 inc	 eax
$LN45@CGTalkRequ:

; 5245 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 119)), aIndex);

  00219	53		 push	 ebx
  0021a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0021f	74 07		 je	 SHORT $LN18@CGTalkRequ
  00221	68 77 04 00 00	 push	 1143			; 00000477H

; 5246 : 			else

  00226	eb 3e		 jmp	 SHORT $LN47@CGTalkRequ
$LN18@CGTalkRequ:

; 5247 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 120)), aIndex);

  00228	68 78 04 00 00	 push	 1144			; 00000478H

; 5248 : 
; 5249 : 			return;

  0022d	eb 37		 jmp	 SHORT $LN47@CGTalkRequ
$LN17@CGTalkRequ:

; 5250 : 		}
; 5251 : 	}
; 5252 : 
; 5253 : 	if ( gPkLimitFree == FALSE )

  0022f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00236	75 55		 jne	 SHORT $LN22@CGTalkRequ

; 5254 : 	{
; 5255 : 		int bPk = FALSE;
; 5256 : 
; 5257 : #if (ENABLE_FIX_NPCTALKPK == 1)
; 5258 : 		if( lpObj->m_PK_Level > 4 )

  00238	80 bf 19 01 00
	00 04		 cmp	 BYTE PTR [edi+281], 4
  0023f	7e 4c		 jle	 SHORT $LN22@CGTalkRequ

; 5259 : 		{
; 5260 : 			bPk = TRUE;
; 5261 : 		}
; 5262 : #else
; 5263 : 
; 5264 : 		if( lpObj->PartyNumber >= 0 )
; 5265 : 		{
; 5266 : 			if( gParty.GetPartyPkLevel(lpObj->PartyNumber) > 4 )
; 5267 : 			{
; 5268 : 				bPk = TRUE;
; 5269 : 			}
; 5270 : 		}
; 5271 : 		else if( lpObj->m_PK_Level > 4 )
; 5272 : 		{
; 5273 : 			bPk = TRUE;
; 5274 : 		}
; 5275 : #endif
; 5276 : 
; 5277 : 		if ( bPk == TRUE )
; 5278 : 		{
; 5279 : 			if ( (rand()%2) != 0 )

  00241	e8 00 00 00 00	 call	 _rand
  00246	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0024b	79 05		 jns	 SHORT $LN46@CGTalkRequ
  0024d	48		 dec	 eax
  0024e	83 c8 fe	 or	 eax, -2			; fffffffeH
  00251	40		 inc	 eax
$LN46@CGTalkRequ:

; 5280 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 121)), aIndex);

  00252	53		 push	 ebx
  00253	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00258	74 07		 je	 SHORT $LN23@CGTalkRequ
  0025a	68 79 04 00 00	 push	 1145			; 00000479H

; 5281 : 			else

  0025f	eb 05		 jmp	 SHORT $LN47@CGTalkRequ
$LN23@CGTalkRequ:

; 5282 : 				ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 122)), aIndex);

  00261	68 7a 04 00 00	 push	 1146			; 0000047aH
$LN47@CGTalkRequ:
  00266	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0026b	50		 push	 eax
  0026c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00271	03 c6		 add	 eax, esi
  00273	50		 push	 eax
  00274	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  00279	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027c	5f		 pop	 edi
  0027d	5e		 pop	 esi
  0027e	5b		 pop	 ebx

; 5394 : 	}
; 5395 : }

  0027f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00282	33 cd		 xor	 ecx, ebp
  00284	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c3		 ret	 0
$LN22@CGTalkRequ:

; 5283 : 			return;
; 5284 : 		}
; 5285 : 	}
; 5286 : 
; 5287 : 	if ( gMerryXMasNpcEvent == TRUE )

  0028d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gMerryXMasNpcEvent@@3HA, 1 ; gMerryXMasNpcEvent
  00294	75 32		 jne	 SHORT $LN26@CGTalkRequ

; 5288 : 	{
; 5289 : 		if ( (rand()%6) == 0 )

  00296	e8 00 00 00 00	 call	 _rand
  0029b	99		 cdq
  0029c	b9 06 00 00 00	 mov	 ecx, 6
  002a1	f7 f9		 idiv	 ecx
  002a3	85 d2		 test	 edx, edx
  002a5	75 21		 jne	 SHORT $LN26@CGTalkRequ

; 5290 : 		{
; 5291 : 			ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 123)), aIndex);

  002a7	53		 push	 ebx
  002a8	68 7b 04 00 00	 push	 1147			; 0000047bH
  002ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002b2	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002b7	50		 push	 eax
  002b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002bd	03 c6		 add	 eax, esi
  002bf	50		 push	 eax
  002c0	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  002c5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@CGTalkRequ:

; 5292 : 		}
; 5293 : 	}
; 5294 : 
; 5295 : 	if ( ::gHappyNewYearNpcEvent == TRUE )

  002c8	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gHappyNewYearNpcEvent@@3HA, 1 ; gHappyNewYearNpcEvent
  002cf	75 32		 jne	 SHORT $LN28@CGTalkRequ

; 5296 : 	{
; 5297 : 		if ( (rand()%6) == 0 )

  002d1	e8 00 00 00 00	 call	 _rand
  002d6	99		 cdq
  002d7	b9 06 00 00 00	 mov	 ecx, 6
  002dc	f7 f9		 idiv	 ecx
  002de	85 d2		 test	 edx, edx
  002e0	75 21		 jne	 SHORT $LN28@CGTalkRequ

; 5298 : 		{
; 5299 : 			ChatTargetSend(&gObj[DealerNumber], lMsg.Get(MSGGET(4, 124)), aIndex);

  002e2	53		 push	 ebx
  002e3	68 7c 04 00 00	 push	 1148			; 0000047cH
  002e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002ed	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002f2	50		 push	 eax
  002f3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f8	03 c6		 add	 eax, esi
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ; ChatTargetSend
  00300	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@CGTalkRequ:

; 5300 : 		}
; 5301 : 	}
; 5302 : 
; 5303 : 	lpObj->TargetShopNumber = ShopNum;
; 5304 : 	lpObj->m_IfState.use = 1;

  00303	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  00309	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _ShopNum$1$[ebp]
  0030f	83 e0 fd	 and	 eax, -3			; fffffffdH
  00312	83 c8 01	 or	 eax, 1
  00315	66 89 8f 3a 06
	00 00		 mov	 WORD PTR [edi+1594], cx

; 5305 : 	lpObj->m_IfState.type = 3;

  0031c	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH

; 5306 : 	lpObj->m_ShopTime = 0;

  00321	c6 87 80 05 00
	00 00		 mov	 BYTE PTR [edi+1408], 0
  00328	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  0032d	89 87 b8 11 00
	00		 mov	 DWORD PTR [edi+4536], eax

; 5307 : 	pResult.h.c = 0xC3;

  00333	c7 85 f0 f7 ff
	ff c3 0b 30 00	 mov	 DWORD PTR _pResult$[ebp], 3148739 ; 00300bc3H

; 5308 : 	pResult.h.headcode = 0x30;
; 5309 : 	pResult.h.size = sizeof(pResult);
; 5310 : 	pResult.result = 0;
; 5311 : 
; 5312 : 	if ( ShopNum == 100 )

  0033d	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00340	75 6c		 jne	 SHORT $LN29@CGTalkRequ

; 5313 : 	{
; 5314 : 		if ( gObj[aIndex].m_ReqWarehouseOpen != false )

  00342	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00347	8b 8d dc f7 ff
	ff		 mov	 ecx, DWORD PTR tv661[ebp]
  0034d	80 bc 01 b0 14
	00 00 00	 cmp	 BYTE PTR [ecx+eax+5296], 0
  00355	0f 85 75 02 00
	00		 jne	 $LN10@CGTalkRequ

; 5315 : 			return;
; 5316 : 		
; 5317 : 		gObj[aIndex].m_ReqWarehouseOpen = true;

  0035b	c6 84 01 b0 14
	00 00 01	 mov	 BYTE PTR [ecx+eax+5296], 1

; 5318 : 		lpObj->m_IfState.type = 6;

  00363	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]
  00369	25 bf 01 ff ff	 and	 eax, -65089		; ffff01bfH
  0036e	0d 80 01 00 00	 or	 eax, 384		; 00000180H

; 5319 : 		lpObj->m_IfState.state = 0;

  00373	83 e0 c3	 and	 eax, -61		; ffffffc3H
  00376	89 87 b8 11 00
	00		 mov	 DWORD PTR [edi+4536], eax

; 5364 : 	}
; 5365 : 
; 5366 : 	if ( ShopNum == 100 )
; 5367 : 	{
; 5368 : 		gObj[aIndex].WarehouseCount = 0;

  0037c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00381	c6 84 01 01 12
	00 00 00	 mov	 BYTE PTR [ecx+eax+4609], 0

; 5369 : 		GDGetWarehouseList(aIndex, gObj[aIndex].AccountID);

  00389	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0038e	83 c0 52	 add	 eax, 82			; 00000052H
  00391	03 c1		 add	 eax, ecx
  00393	50		 push	 eax
  00394	53		 push	 ebx
  00395	e8 00 00 00 00	 call	 ?GDGetWarehouseList@@YAXHPAD@Z ; GDGetWarehouseList
  0039a	83 c4 08	 add	 esp, 8
  0039d	5f		 pop	 edi
  0039e	5e		 pop	 esi
  0039f	5b		 pop	 ebx

; 5394 : 	}
; 5395 : }

  003a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a3	33 cd		 xor	 ecx, ebp
  003a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003aa	8b e5		 mov	 esp, ebp
  003ac	5d		 pop	 ebp
  003ad	c3		 ret	 0
$LN29@CGTalkRequ:

; 5320 : 	}
; 5321 : 	else if ( ShopNum == 101 )

  003ae	83 f9 65	 cmp	 ecx, 101		; 00000065H
  003b1	0f 85 59 01 00
	00		 jne	 $LN32@CGTalkRequ

; 5322 : 	{
; 5323 : 		if ( bCanChaosBox == TRUE )

  003b7	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanChaosBox@@3HA, 1 ; bCanChaosBox
  003be	0f 85 0c 02 00
	00		 jne	 $LN10@CGTalkRequ

; 5324 : 		{
; 5325 : 			if ( lpObj->m_bPShopOpen == true )

  003c4	80 bf 5c 12 00
	00 01		 cmp	 BYTE PTR [edi+4700], 1
  003cb	75 43		 jne	 SHORT $LN35@CGTalkRequ

; 5326 : 			{
; 5327 : 				LogAdd("[%s][%s] is Already Opening PShop, ChaosBox Failed",

  003cd	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  003d0	50		 push	 eax
  003d1	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  003d4	50		 push	 eax
  003d5	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@KJEEOOOJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5is?5Already?5Opening?5PSho@
  003da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5328 : 					lpObj->AccountID, lpObj->Name);
; 5329 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(4, 194)), lpObj->m_Index, 1);

  003e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003e8	6a 01		 push	 1
  003ea	ff 37		 push	 DWORD PTR [edi]
  003ec	68 c2 04 00 00	 push	 1218			; 000004c2H
  003f1	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003f6	50		 push	 eax
  003f7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ff	5f		 pop	 edi
  00400	5e		 pop	 esi
  00401	5b		 pop	 ebx

; 5394 : 	}
; 5395 : }

  00402	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00405	33 cd		 xor	 ecx, ebp
  00407	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040c	8b e5		 mov	 esp, ebp
  0040e	5d		 pop	 ebp
  0040f	c3		 ret	 0
$LN35@CGTalkRequ:

; 5330 : 
; 5331 : 				return;
; 5332 : 			}
; 5333 : 
; 5334 : 			lpObj->m_IfState.type = 7;

  00410	8b 87 b8 11 00
	00		 mov	 eax, DWORD PTR [edi+4536]

; 5335 : 			lpObj->m_IfState.state = 0;
; 5336 : 			pResult.result = 3;
; 5337 : 
; 5338 : 			if( gObj[DealerNumber].Class == 450 )

  00416	ba c2 01 00 00	 mov	 edx, 450		; 000001c2H
  0041b	25 ff 01 ff ff	 and	 eax, -65025		; ffff01ffH
  00420	0d c0 01 00 00	 or	 eax, 448		; 000001c0H
  00425	83 e0 c3	 and	 eax, -61		; ffffffc3H
  00428	89 87 b8 11 00
	00		 mov	 DWORD PTR [edi+4536], eax
  0042e	b0 03		 mov	 al, 3
  00430	88 85 f3 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al
  00436	0f b6 c8	 movzx	 ecx, al
  00439	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0043e	66 39 94 06 90
	00 00 00	 cmp	 WORD PTR [esi+eax+144], dx
  00446	ba 16 00 00 00	 mov	 edx, 22			; 00000016H
  0044b	0f 44 ca	 cmove	 ecx, edx
  0044e	88 8d f3 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], cl

; 5339 : 			{
; 5340 : 				pResult.result = 22;
; 5341 : 			}
; 5342 : 
; 5343 : 			lpObj->bIsChaosMixCompleted = false;

  00454	c6 87 09 16 00
	00 00		 mov	 BYTE PTR [edi+5641], 0

; 5344 : 			pResult.level1 = gDQChaosSuccessRateLevel1;

  0045b	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel1@@3HA
  00460	88 85 f4 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+4], al

; 5345 : 			pResult.level2 = gDQChaosSuccessRateLevel2;

  00466	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel2@@3HA
  0046b	88 85 f5 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+5], al

; 5346 : 			pResult.level3 = gDQChaosSuccessRateLevel3;

  00471	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel3@@3HA
  00476	88 85 f6 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+6], al

; 5347 : 			pResult.level4 = gDQChaosSuccessRateLevel4;

  0047c	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel4@@3HA
  00481	88 85 f7 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+7], al

; 5348 : 			pResult.level5 = gDQChaosSuccessRateLevel5;

  00487	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel5@@3HA
  0048c	88 85 f8 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+8], al

; 5349 : 			pResult.level6 = gDQChaosSuccessRateLevel6;

  00492	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel6@@3HA
  00497	88 85 f9 f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+9], al

; 5350 : 			pResult.level7 = gDQChaosSuccessRateLevel7;

  0049d	a0 00 00 00 00	 mov	 al, BYTE PTR ?gDQChaosSuccessRateLevel7@@3HA
  004a2	88 85 fa f7 ff
	ff		 mov	 BYTE PTR _pResult$[ebp+10], al

; 5351 : 
; 5352 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  004a8	0f b6 85 f1 f7
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  004af	50		 push	 eax
  004b0	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  004b6	50		 push	 eax
  004b7	53		 push	 ebx
  004b8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5353 : 			gObjInventoryTrans(lpObj->m_Index);

  004bd	ff 37		 push	 DWORD PTR [edi]
  004bf	e8 00 00 00 00	 call	 ?gObjInventoryTrans@@YAHH@Z ; gObjInventoryTrans

; 5354 : 
; 5355 : 			LogAddTD("[%s][%s] Open Chaos Box", lpObj->AccountID, lpObj->Name);

  004c4	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  004c7	50		 push	 eax
  004c8	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  004cb	50		 push	 eax
  004cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EKFBANFN@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Open?5Chaos?5Box?$AA@
  004d1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 5356 : 			gObjItemTextSave(lpObj);

  004d7	57		 push	 edi
  004d8	e8 00 00 00 00	 call	 ?gObjItemTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjItemTextSave

; 5357 : 			gObjWarehouseTextSave(lpObj);

  004dd	57		 push	 edi
  004de	e8 00 00 00 00	 call	 ?gObjWarehouseTextSave@@YAXPAUOBJECTSTRUCT@@@Z ; gObjWarehouseTextSave
  004e3	83 c4 24	 add	 esp, 36			; 00000024H

; 5358 : 			GCAnsCsMapSvrTaxInfo( lpObj->m_Index, 1, ::g_CastleSiegeSync.GetTaxRateChaos(lpObj->m_Index));

  004e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  004eb	ff 37		 push	 DWORD PTR [edi]
  004ed	e8 00 00 00 00	 call	 ?GetTaxRateChaos@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateChaos
  004f2	50		 push	 eax
  004f3	6a 01		 push	 1
  004f5	ff 37		 push	 DWORD PTR [edi]
  004f7	e8 00 00 00 00	 call	 ?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z ; GCAnsCsMapSvrTaxInfo
  004fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ff	5f		 pop	 edi
  00500	5e		 pop	 esi
  00501	5b		 pop	 ebx

; 5394 : 	}
; 5395 : }

  00502	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00505	33 cd		 xor	 ecx, ebp
  00507	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0050c	8b e5		 mov	 esp, ebp
  0050e	5d		 pop	 ebp
  0050f	c3		 ret	 0
$LN32@CGTalkRequ:

; 5359 : 		}
; 5360 : 	}
; 5361 : 	else
; 5362 : 	{
; 5363 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00510	6a 0b		 push	 11			; 0000000bH
  00512	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00518	50		 push	 eax
  00519	53		 push	 ebx
  0051a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 5370 : 
; 5371 : 		return;
; 5372 : 	}
; 5373 : 
; 5374 : 	if ( ShopNum == 101 )
; 5375 : 	{
; 5376 : 		return;
; 5377 : 	}
; 5378 : 	else if( lpShop )

  0051f	8b b5 e8 f7 ff
	ff		 mov	 esi, DWORD PTR _lpShop$1$[ebp]
  00525	83 c4 0c	 add	 esp, 12			; 0000000cH
  00528	85 f6		 test	 esi, esi
  0052a	0f 84 a0 00 00
	00		 je	 $LN10@CGTalkRequ

; 5379 : 	{
; 5380 : 		lOfs = 0;
; 5381 : 		lOfs += sizeof(pShopItemCount);
; 5382 : 
; 5383 : 		int size = lOfs + lpShop->SendItemDataLen;

  00530	8b b6 00 6a 00
	00		 mov	 esi, DWORD PTR [esi+27136]

; 5384 : 		PHeadSetW((LPBYTE)&pShopItemCount, 0x31, size);

  00536	8d 85 e0 f7 ff
	ff		 lea	 eax, DWORD PTR _pShopItemCount$[ebp]
  0053c	83 c6 06	 add	 esi, 6
  0053f	56		 push	 esi
  00540	6a 31		 push	 49			; 00000031H
  00542	50		 push	 eax
  00543	e8 00 00 00 00	 call	 ?PHeadSetW@@YAXPAEEH@Z	; PHeadSetW

; 5385 : 		pShopItemCount.Type = 0;
; 5386 : 		pShopItemCount.count = lpShop->ItemCount;

  00548	8b 8d e8 f7 ff
	ff		 mov	 ecx, DWORD PTR _lpShop$1$[ebp]
  0054e	c6 85 e4 f7 ff
	ff 00		 mov	 BYTE PTR _pShopItemCount$[ebp+4], 0
  00555	8a 81 84 00 00
	00		 mov	 al, BYTE PTR [ecx+132]
  0055b	88 85 e5 f7 ff
	ff		 mov	 BYTE PTR _pShopItemCount$[ebp+5], al

; 5387 : 		memcpy(SendByte, &pShopItemCount, sizeof(pShopItemCount));

  00561	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _pShopItemCount$[ebp]
  00567	89 85 fc f7 ff
	ff		 mov	 DWORD PTR _SendByte$[ebp], eax
  0056d	66 8b 85 e4 f7
	ff ff		 mov	 ax, WORD PTR _pShopItemCount$[ebp+4]
  00574	66 89 85 00 f8
	ff ff		 mov	 WORD PTR _SendByte$[ebp+4], ax

; 5388 : 		memcpy(&SendByte[lOfs], lpShop->SendItemData, lpShop->SendItemDataLen);

  0057b	8d 81 e8 63 00
	00		 lea	 eax, DWORD PTR [ecx+25576]
  00581	ff b1 00 6a 00
	00		 push	 DWORD PTR [ecx+27136]
  00587	50		 push	 eax
  00588	8d 85 02 f8 ff
	ff		 lea	 eax, DWORD PTR _SendByte$[ebp+6]
  0058e	50		 push	 eax
  0058f	e8 00 00 00 00	 call	 _memcpy

; 5389 : 
; 5390 : 		DataSend(aIndex, SendByte, size);

  00594	56		 push	 esi
  00595	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _SendByte$[ebp]
  0059b	50		 push	 eax
  0059c	53		 push	 ebx
  0059d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  005a2	83 c4 24	 add	 esp, 36			; 00000024H

; 5391 : 		GCAnsCsMapSvrTaxInfo(lpObj->m_Index,2, g_CastleSiegeSync.GetTaxRateStore(lpObj->m_Index));

  005a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  005aa	ff 37		 push	 DWORD PTR [edi]
  005ac	e8 00 00 00 00	 call	 ?GetTaxRateStore@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::GetTaxRateStore
  005b1	50		 push	 eax
  005b2	6a 02		 push	 2
  005b4	ff 37		 push	 DWORD PTR [edi]
  005b6	e8 00 00 00 00	 call	 ?GCAnsCsMapSvrTaxInfo@@YAXHEE@Z ; GCAnsCsMapSvrTaxInfo

; 5392 : 
; 5393 : 		g_ItemPrice.SendPrice(aIndex, ShopNum);

  005bb	8b 85 ec f7 ff
	ff		 mov	 eax, DWORD PTR _ShopNum$1$[ebp]
  005c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  005c4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ItemPrice@@3VItemPrice@@A ; g_ItemPrice
  005c9	50		 push	 eax
  005ca	53		 push	 ebx
  005cb	e8 00 00 00 00	 call	 ?SendPrice@ItemPrice@@QAEXHH@Z ; ItemPrice::SendPrice
$LN10@CGTalkRequ:

; 5394 : 	}
; 5395 : }

  005d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005d3	5f		 pop	 edi
  005d4	5e		 pop	 esi
  005d5	33 cd		 xor	 ecx, ebp
  005d7	5b		 pop	 ebx
  005d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005dd	8b e5		 mov	 esp, ebp
  005df	5d		 pop	 ebp
  005e0	c3		 ret	 0
?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z ENDP	; CGTalkRequestRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCEquipmentChange@@YAXHH@Z
_TEXT	SEGMENT
_lpObj$1$ = -32						; size = 4
_aIndex$GSCopy$1$ = -28					; size = 4
_pChange$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?GCEquipmentChange@@YAXHH@Z PROC			; GCEquipmentChange, COMDAT

; 5143 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _pos$[ebp]
  00017	56		 push	 esi

; 5144 : 	PMSG_USEREQUIPMENTCHANGED pChange;
; 5145 : 	LPOBJ lpObj = &gObj[aIndex];

  00018	69 f0 40 27 00
	00		 imul	 esi, eax, 10048
  0001e	57		 push	 edi

; 5146 : 
; 5147 : 	PHeadSetB((LPBYTE)&pChange, 0x25, sizeof(PMSG_USEREQUIPMENTCHANGED));

  0001f	6a 11		 push	 17			; 00000011H
  00021	89 45 e4	 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], eax
  00024	8d 45 e8	 lea	 eax, DWORD PTR _pChange$[ebp]
  00027	6a 25		 push	 37			; 00000025H
  00029	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002f	50		 push	 eax
  00030	89 75 e0	 mov	 DWORD PTR _lpObj$1$[ebp], esi
  00033	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 5148 : 	pChange.NumberH = SET_NUMBERH(aIndex);

  00038	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$1$[ebp]

; 5149 : 	pChange.NumberL = SET_NUMBERL(aIndex);
; 5150 : 	ItemByteConvert(pChange.ItemInfo, lpObj->pInventory[pos]);

  0003b	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00041	8b c1		 mov	 eax, ecx
  00043	88 4d ec	 mov	 BYTE PTR _pChange$[ebp+4], cl
  00046	c1 e8 08	 shr	 eax, 8
  00049	8b fc		 mov	 edi, esp
  0004b	88 45 eb	 mov	 BYTE PTR _pChange$[ebp+3], al
  0004e	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00053	8b b6 c0 11 00
	00		 mov	 esi, DWORD PTR [esi+4544]
  00059	69 c3 d4 00 00
	00		 imul	 eax, ebx, 212
  0005f	03 f0		 add	 esi, eax
  00061	8d 45 ed	 lea	 eax, DWORD PTR _pChange$[ebp+5]
  00064	f3 a5		 rep movsd
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 5151 : 	pChange.ItemInfo[I_OPTION] = pos << 4;

  0006c	8a c3		 mov	 al, bl

; 5152 : 	pChange.ItemInfo[I_OPTION] |= LevelSmallConvert(aIndex, pos) & MAX_ITEM_LEVEL;

  0006e	53		 push	 ebx
  0006f	ff 75 e4	 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  00072	c0 e0 04	 shl	 al, 4
  00075	88 45 ee	 mov	 BYTE PTR _pChange$[ebp+6], al
  00078	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  0007d	24 0f		 and	 al, 15			; 0000000fH
  0007f	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00085	08 45 ee	 or	 BYTE PTR _pChange$[ebp+6], al

; 5153 : 
; 5154 : 	MsgSendV2(lpObj, (LPBYTE)&pChange, pChange.h.size);

  00088	0f b6 45 e9	 movzx	 eax, BYTE PTR _pChange$[ebp+1]
  0008c	50		 push	 eax
  0008d	8d 45 e8	 lea	 eax, DWORD PTR _pChange$[ebp]
  00090	50		 push	 eax
  00091	ff 75 e0	 push	 DWORD PTR _lpObj$1$[ebp]
  00094	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 5155 : 
; 5156 : }

  00099	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	33 cd		 xor	 ecx, ebp
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
?GCEquipmentChange@@YAXHH@Z ENDP			; GCEquipmentChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z
_TEXT	SEGMENT
_money$1$ = -296					; size = 4
_DurSSend$1 = -296					; size = 4
_ItemInfo$3$ = -291					; size = 1
_ItemInfo$2$ = -290					; size = 1
_ItemInfo$1$ = -289					; size = 1
_iZen$1$ = -288						; size = 4
_type$1$ = -288						; size = 4
_source$1$ = -288					; size = 4
_target$1$ = -284					; size = 4
_it_type$1$ = -280					; size = 4
_result$ = -280						; size = 1
tv313 = -280						; size = 4
tv1519 = -276						; size = 4
_DurTSend$2 = -276					; size = 4
_szTemp$3 = -272					; size = 256
_ItemInfo$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z PROC ; CGInventoryItemMove, COMDAT

; 4666 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4667 : 	BYTE result;
; 4668 : 	BYTE ItemInfo[MAX_ITEM_INFO];
; 4669 : 
; 4670 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0001d	57		 push	 edi
  0001e	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00021	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  00027	03 c3		 add	 eax, ebx
  00029	89 9d ec fe ff
	ff		 mov	 DWORD PTR tv1519[ebp], ebx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00035	83 c4 04	 add	 esp, 4
  00038	85 c0		 test	 eax, eax
  0003a	75 25		 jne	 SHORT $LN2@CGInventor
$LN173@CGInventor:

; 4671 : 	{
; 4672 : 		::GCItemMoveResultSend(aIndex, -1, 0, ItemInfo);

  0003c	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  0003f	50		 push	 eax
  00040	6a 00		 push	 0
  00042	68 ff 00 00 00	 push	 255			; 000000ffH
  00047	57		 push	 edi
  00048	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 5139 : 	}
; 5140 : }

  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	33 cd		 xor	 ecx, ebp
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN2@CGInventor:

; 4673 : 		return;
; 4674 : 	}
; 4675 : 
; 4676 : 	if ( !::gObjIsConnectedGP(aIndex))

  00061	57		 push	 edi
  00062	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  00067	83 c4 04	 add	 esp, 4
  0006a	85 c0		 test	 eax, eax
  0006c	75 3c		 jne	 SHORT $LN3@CGInventor

; 4677 : 	{
; 4678 : 		LogAddC(2,"[%s][%d] error-L3", __FILE__, __LINE__);

  0006e	68 46 12 00 00	 push	 4678			; 00001246H
$LN174@CGInventor:
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JIBNBHEG@?$FL?$CFs?$FN?$FL?$CFd?$FN?5error?9L3?$AA@
  0007d	6a 02		 push	 2
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 4679 : 		::GCItemMoveResultSend(aIndex, -1, 0, ItemInfo);

  00085	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00088	50		 push	 eax
  00089	6a 00		 push	 0
  0008b	68 ff 00 00 00	 push	 255			; 000000ffH
  00090	57		 push	 edi
  00091	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00096	83 c4 20	 add	 esp, 32			; 00000020H
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 5139 : 	}
; 5140 : }

  0009c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009f	33 cd		 xor	 ecx, ebp
  000a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
$LN3@CGInventor:

; 4680 : 		return;
; 4681 : 	}
; 4682 : 
; 4683 : 	LPOBJ lpObj = &gObj[aIndex];

  000aa	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 4684 : 	int it_type = 0;

  000b0	33 d2		 xor	 edx, edx
  000b2	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _it_type$1$[ebp], edx

; 4685 : 
; 4686 : 	if ( lpObj->m_ReqWarehouseOpen != false )

  000b8	38 93 b0 14 00
	00		 cmp	 BYTE PTR [ebx+5296], dl
  000be	74 07		 je	 SHORT $LN4@CGInventor

; 4687 : 	{
; 4688 : 		LogAddC(2,"[%s][%d] error-L3", __FILE__, __LINE__);

  000c0	68 50 12 00 00	 push	 4688			; 00001250H

; 4689 : 		GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4690 : 
; 4691 : 		return;

  000c5	eb ac		 jmp	 SHORT $LN174@CGInventor
$LN4@CGInventor:

; 4692 : 	}
; 4693 : 
; 4694 : 	int source = lpMsg->source_item_num;

  000c7	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]

; 4695 : 	int target = lpMsg->target_item_num;

  000cb	0f b6 4e 12	 movzx	 ecx, BYTE PTR [esi+18]
  000cf	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _source$1$[ebp], eax

; 4696 : 
; 4697 : 	if ( lpMsg->tFlag == 2 || lpMsg->sFlag == 2 )

  000d5	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  000d8	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _target$1$[ebp], ecx
  000de	3c 02		 cmp	 al, 2
  000e0	74 06		 je	 SHORT $LN6@CGInventor
  000e2	80 7e 03 02	 cmp	 BYTE PTR [esi+3], 2
  000e6	75 0b		 jne	 SHORT $LN5@CGInventor
$LN6@CGInventor:

; 4698 : 		it_type = 6;

  000e8	ba 06 00 00 00	 mov	 edx, 6
  000ed	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _it_type$1$[ebp], edx
$LN5@CGInventor:

; 4699 : 
; 4700 : 	if ( lpMsg->tFlag == 0 && lpMsg->sFlag == 0 )

  000f3	84 c0		 test	 al, al
  000f5	75 24		 jne	 SHORT $LN10@CGInventor
  000f7	38 46 03	 cmp	 BYTE PTR [esi+3], al
  000fa	c7 85 e8 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR tv313[ebp], 8
  00104	0f 44 95 e8 fe
	ff ff		 cmove	 edx, DWORD PTR tv313[ebp]
  0010b	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _it_type$1$[ebp], edx

; 4701 : 		it_type = 8;
; 4702 : 
; 4703 : 	if ( (lpMsg->tFlag == 0 && lpMsg->sFlag == 4) ||
; 4704 : 		(lpMsg->tFlag == 4 && lpMsg->sFlag == 0) ||

  00111	84 c0		 test	 al, al
  00113	75 06		 jne	 SHORT $LN10@CGInventor
  00115	80 7e 03 04	 cmp	 BYTE PTR [esi+3], 4
  00119	74 13		 je	 SHORT $LN9@CGInventor
$LN10@CGInventor:
  0011b	3c 04		 cmp	 al, 4
  0011d	75 1a		 jne	 SHORT $LN8@CGInventor
  0011f	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00123	74 09		 je	 SHORT $LN9@CGInventor
  00125	3a c0		 cmp	 al, al
  00127	75 10		 jne	 SHORT $LN8@CGInventor
  00129	38 46 03	 cmp	 BYTE PTR [esi+3], al
  0012c	75 0b		 jne	 SHORT $LN8@CGInventor
$LN9@CGInventor:

; 4705 : 		(lpMsg->tFlag == 4 && lpMsg->sFlag == 4) )
; 4706 : 		it_type = 8;

  0012e	ba 08 00 00 00	 mov	 edx, 8
  00133	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _it_type$1$[ebp], edx
$LN8@CGInventor:

; 4707 : 
; 4708 : 	if ( lpMsg->tFlag == lpMsg->sFlag &&

  00139	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  0013c	75 0c		 jne	 SHORT $LN12@CGInventor
  0013e	3b 8d e0 fe ff
	ff		 cmp	 ecx, DWORD PTR _source$1$[ebp]
  00144	0f 84 f2 fe ff
	ff		 je	 $LN173@CGInventor
$LN12@CGInventor:

; 4709 : 		 target == source)
; 4710 : 	{
; 4711 : 		GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4712 : 		return;
; 4713 : 	}
; 4714 : 
; 4715 : 	if (::gObjCanItemTouch(lpObj, it_type) == FALSE)

  0014a	52		 push	 edx
  0014b	53		 push	 ebx
  0014c	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00151	83 c4 08	 add	 esp, 8
  00154	85 c0		 test	 eax, eax
  00156	75 30		 jne	 SHORT $LN15@CGInventor

; 4716 : 	{
; 4717 : 		if ( lpMsg->sItemInfo[I_TYPE] == ITEMGET(4,7) || lpMsg->sItemInfo[I_TYPE] == ITEMGET(4,15) )

  00158	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  0015c	3d 07 08 00 00	 cmp	 eax, 2055		; 00000807H
  00161	74 0b		 je	 SHORT $LN16@CGInventor
  00163	3d 0f 08 00 00	 cmp	 eax, 2063		; 0000080fH
  00168	0f 85 ce fe ff
	ff		 jne	 $LN173@CGInventor
$LN16@CGInventor:

; 4718 : 		{
; 4719 : 			if ( target >= 12 || source < 12 )

  0016e	83 bd e4 fe ff
	ff 0c		 cmp	 DWORD PTR _target$1$[ebp], 12 ; 0000000cH
  00175	0f 8d c1 fe ff
	ff		 jge	 $LN173@CGInventor
  0017b	83 bd e0 fe ff
	ff 0c		 cmp	 DWORD PTR _source$1$[ebp], 12 ; 0000000cH
  00182	0f 8c b4 fe ff
	ff		 jl	 $LN173@CGInventor
$LN15@CGInventor:

; 4720 : 			{
; 4721 : 				::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4722 : 				return;
; 4723 : 			}
; 4724 : 		}
; 4725 : 		else
; 4726 : 		{
; 4727 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4728 : 			return;
; 4729 : 		}
; 4730 : 	}
; 4731 : 
; 4732 : 	if ( lpObj->DieRegen != FALSE )

  00188	80 bb 8a 05 00
	00 00		 cmp	 BYTE PTR [ebx+1418], 0
  0018f	0f 85 a7 fe ff
	ff		 jne	 $LN173@CGInventor

; 4733 : 	{
; 4734 : 		::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4735 : 		return;
; 4736 : 	}
; 4737 : 
; 4738 : 	ItemInfo[I_TYPE] = lpMsg->sItemInfo[I_TYPE];

  00195	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00198	88 85 df fe ff
	ff		 mov	 BYTE PTR _ItemInfo$1$[ebp], al
  0019e	88 45 f0	 mov	 BYTE PTR _ItemInfo$[ebp], al

; 4739 : 	ItemInfo[I_OPTION] = lpMsg->sItemInfo[I_OPTION];

  001a1	8a 46 06	 mov	 al, BYTE PTR [esi+6]
  001a4	88 45 f1	 mov	 BYTE PTR _ItemInfo$[ebp+1], al

; 4740 : 	ItemInfo[I_DUR] = lpMsg->sItemInfo[I_DUR];

  001a7	8a 46 07	 mov	 al, BYTE PTR [esi+7]
  001aa	88 45 f2	 mov	 BYTE PTR _ItemInfo$[ebp+2], al

; 4741 : 	ItemInfo[I_NOPTION] = lpMsg->sItemInfo[I_NOPTION];

  001ad	8a 46 08	 mov	 al, BYTE PTR [esi+8]

; 4742 : 	ItemInfo[I_SOPTION] = lpMsg->sItemInfo[I_SOPTION];
; 4743 : 	ItemInfo[I_380OPTION] = lpMsg->sItemInfo[I_380OPTION];
; 4744 : 	ItemInfo[I_JOHOPTION] = lpMsg->sItemInfo[I_JOHOPTION];
; 4745 : 
; 4746 : 	ItemInfo[7] = lpMsg->sItemInfo[7];
; 4747 : 	ItemInfo[8] = lpMsg->sItemInfo[8];
; 4748 : 	ItemInfo[9] = lpMsg->sItemInfo[9];
; 4749 : 	ItemInfo[10] = lpMsg->sItemInfo[10];
; 4750 : 	ItemInfo[11] = lpMsg->sItemInfo[11];
; 4751 : 
; 4752 : 	if ( lpMsg->sFlag == 3 || lpMsg->tFlag == 3 )

  001b0	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  001b3	88 85 de fe ff
	ff		 mov	 BYTE PTR _ItemInfo$2$[ebp], al
  001b9	88 45 f3	 mov	 BYTE PTR _ItemInfo$[ebp+3], al
  001bc	8a 46 09	 mov	 al, BYTE PTR [esi+9]
  001bf	88 45 f4	 mov	 BYTE PTR _ItemInfo$[ebp+4], al
  001c2	8a 46 0a	 mov	 al, BYTE PTR [esi+10]
  001c5	88 85 dd fe ff
	ff		 mov	 BYTE PTR _ItemInfo$3$[ebp], al
  001cb	88 45 f5	 mov	 BYTE PTR _ItemInfo$[ebp+5], al
  001ce	8a 46 0b	 mov	 al, BYTE PTR [esi+11]
  001d1	88 45 f6	 mov	 BYTE PTR _ItemInfo$[ebp+6], al
  001d4	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  001d7	88 45 f7	 mov	 BYTE PTR _ItemInfo$[ebp+7], al
  001da	8a 46 0d	 mov	 al, BYTE PTR [esi+13]
  001dd	88 45 f8	 mov	 BYTE PTR _ItemInfo$[ebp+8], al
  001e0	8a 46 0e	 mov	 al, BYTE PTR [esi+14]
  001e3	88 45 f9	 mov	 BYTE PTR _ItemInfo$[ebp+9], al
  001e6	8a 46 0f	 mov	 al, BYTE PTR [esi+15]
  001e9	88 45 fa	 mov	 BYTE PTR _ItemInfo$[ebp+10], al
  001ec	8a 46 10	 mov	 al, BYTE PTR [esi+16]
  001ef	88 45 fb	 mov	 BYTE PTR _ItemInfo$[ebp+11], al
  001f2	80 f9 03	 cmp	 cl, 3
  001f5	74 06		 je	 SHORT $LN21@CGInventor
  001f7	80 7e 11 03	 cmp	 BYTE PTR [esi+17], 3
  001fb	75 77		 jne	 SHORT $LN24@CGInventor
$LN21@CGInventor:

; 4753 : 	{
; 4754 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 7 )

  001fd	8b 93 b8 11 00
	00		 mov	 edx, DWORD PTR [ebx+4536]
  00203	8b c2		 mov	 eax, edx
  00205	24 03		 and	 al, 3
  00207	3c 01		 cmp	 al, 1
  00209	0f 82 ae 0b 00
	00		 jb	 $LN23@CGInventor
  0020f	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00215	81 fa c0 01 00
	00		 cmp	 edx, 448		; 000001c0H
  0021b	0f 85 9c 0b 00
	00		 jne	 $LN23@CGInventor

; 4758 : 
; 4759 : 			return;
; 4760 : 		}
; 4761 : 
; 4762 : 		if ( lpObj->ChaosLock == TRUE )

  00221	83 bb 20 12 00
	00 01		 cmp	 DWORD PTR [ebx+4640], 1
  00228	75 4a		 jne	 SHORT $LN24@CGInventor

; 4763 : 		{
; 4764 : 			LogAddTD("[%s][%s] error-L3 : CBMixing", gObj[aIndex].AccountID, gObj[aIndex].Name);

  0022a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00230	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00233	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00239	50		 push	 eax
  0023a	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0023d	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00243	50		 push	 eax
  00244	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NBPOCOLJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5CBMixing?$AA@
$LN171@CGInventor:
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4765 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0024f	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00252	50		 push	 eax
  00253	6a 00		 push	 0
  00255	68 ff 00 00 00	 push	 255			; 000000ffH
$LN172@CGInventor:
  0025a	57		 push	 edi
  0025b	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00260	83 c4 1c	 add	 esp, 28			; 0000001cH
  00263	5f		 pop	 edi
  00264	5e		 pop	 esi
  00265	5b		 pop	 ebx

; 5139 : 	}
; 5140 : }

  00266	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00269	33 cd		 xor	 ecx, ebp
  0026b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00270	8b e5		 mov	 esp, ebp
  00272	5d		 pop	 ebp
  00273	c3		 ret	 0
$LN24@CGInventor:

; 4766 : 		
; 4767 : 			return;
; 4768 : 		}
; 4769 : 	}
; 4770 : 
; 4771 : 	if ( lpMsg->sFlag == 5 || lpMsg->tFlag == 5 )

  00274	80 f9 05	 cmp	 cl, 5
  00277	74 06		 je	 SHORT $LN26@CGInventor
  00279	80 7e 11 05	 cmp	 BYTE PTR [esi+17], 5
  0027d	75 51		 jne	 SHORT $LN29@CGInventor
$LN26@CGInventor:

; 4772 : 	{
; 4773 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 13 )

  0027f	8b 93 b8 11 00
	00		 mov	 edx, DWORD PTR [ebx+4536]
  00285	8b c2		 mov	 eax, edx
  00287	24 03		 and	 al, 3
  00289	3c 01		 cmp	 al, 1
  0028b	0f 82 fa 0a 00
	00		 jb	 $LN28@CGInventor
  00291	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00297	81 fa 40 03 00
	00		 cmp	 edx, 832		; 00000340H
  0029d	0f 85 e8 0a 00
	00		 jne	 $LN28@CGInventor

; 4779 : 		}
; 4780 : 
; 4781 : 		if ( lpObj->ChaosLock == TRUE )

  002a3	83 bb 20 12 00
	00 01		 cmp	 DWORD PTR [ebx+4640], 1
  002aa	75 24		 jne	 SHORT $LN29@CGInventor

; 4782 : 		{
; 4783 : 			LogAddTD("[%s][%s] error-L3 : DarkTrainerBoxMixing", gObj[aIndex].AccountID, gObj[aIndex].Name);

  002ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002b2	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  002b5	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  002bb	50		 push	 eax
  002bc	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  002bf	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  002c5	50		 push	 eax
  002c6	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@GOOLKLEE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5DarkTrainerB@

; 4784 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4785 : 		
; 4786 : 			return;

  002cb	e9 79 ff ff ff	 jmp	 $LN171@CGInventor
$LN29@CGInventor:

; 4787 : 		}
; 4788 : 	}
; 4789 : 
; 4790 : 	if ( lpMsg->sFlag == 6 || lpMsg->sFlag == 7 || lpMsg->sFlag == 8 ||
; 4791 : 		 lpMsg->tFlag == 6 || lpMsg->tFlag == 7 || lpMsg->tFlag == 8 )

  002d0	80 f9 06	 cmp	 cl, 6
  002d3	74 19		 je	 SHORT $LN31@CGInventor
  002d5	80 f9 07	 cmp	 cl, 7
  002d8	74 14		 je	 SHORT $LN31@CGInventor
  002da	80 f9 08	 cmp	 cl, 8
  002dd	74 0f		 je	 SHORT $LN31@CGInventor
  002df	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  002e2	3c 06		 cmp	 al, 6
  002e4	74 08		 je	 SHORT $LN31@CGInventor
  002e6	3c 07		 cmp	 al, 7
  002e8	74 04		 je	 SHORT $LN31@CGInventor
  002ea	3c 08		 cmp	 al, 8
  002ec	75 51		 jne	 SHORT $LN34@CGInventor
$LN31@CGInventor:

; 4792 : 	{
; 4793 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type !=7 )

  002ee	8b 93 b8 11 00
	00		 mov	 edx, DWORD PTR [ebx+4536]
  002f4	8b c2		 mov	 eax, edx
  002f6	24 03		 and	 al, 3
  002f8	3c 01		 cmp	 al, 1
  002fa	0f 82 59 0a 00
	00		 jb	 $LN53@CGInventor
  00300	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00306	81 fa c0 01 00
	00		 cmp	 edx, 448		; 000001c0H
  0030c	0f 85 47 0a 00
	00		 jne	 $LN53@CGInventor

; 4794 : 		{
; 4795 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4796 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 4797 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4798 : 
; 4799 : 			return;
; 4800 : 		}
; 4801 : 
; 4802 : 		if ( lpObj->ChaosLock == TRUE )

  00312	83 bb 20 12 00
	00 01		 cmp	 DWORD PTR [ebx+4640], 1
  00319	75 24		 jne	 SHORT $LN34@CGInventor
$LN176@CGInventor:

; 4803 : 		{
; 4804 : 			LogAddTD("[%s][%s] error-L3 : JewelOfHarmony Mixing",

  0031b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00321	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00324	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  0032a	50		 push	 eax
  0032b	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0032e	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00334	50		 push	 eax
  00335	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@JNCNGNMJ@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5JewelOfHarmo@

; 4805 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4806 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4807 : 
; 4808 : 			return;

  0033a	e9 0a ff ff ff	 jmp	 $LN171@CGInventor
$LN34@CGInventor:

; 4809 : 		}
; 4810 : 	}
; 4811 : 
; 4812 : 	if ( lpMsg->sFlag == 9 || lpMsg->tFlag == 9 )

  0033f	80 f9 09	 cmp	 cl, 9
  00342	74 06		 je	 SHORT $LN36@CGInventor
  00344	80 7e 11 09	 cmp	 BYTE PTR [esi+17], 9
  00348	75 2d		 jne	 SHORT $LN39@CGInventor
$LN36@CGInventor:

; 4813 : 	{
; 4814 : 		if ( lpObj->m_IfState.use	 < 1 || lpObj->m_IfState.type !=7 )

  0034a	8b 93 b8 11 00
	00		 mov	 edx, DWORD PTR [ebx+4536]
  00350	8b c2		 mov	 eax, edx
  00352	24 03		 and	 al, 3
  00354	3c 01		 cmp	 al, 1
  00356	0f 82 fd 09 00
	00		 jb	 $LN53@CGInventor
  0035c	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00362	81 fa c0 01 00
	00		 cmp	 edx, 448		; 000001c0H
  00368	0f 85 eb 09 00
	00		 jne	 $LN53@CGInventor

; 4815 : 		{
; 4816 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4817 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 4818 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4819 : 
; 4820 : 			return;
; 4821 : 		}
; 4822 : 
; 4823 : 		if ( lpObj->ChaosLock == TRUE )

  0036e	83 bb 20 12 00
	00 01		 cmp	 DWORD PTR [ebx+4640], 1
  00375	74 a4		 je	 SHORT $LN176@CGInventor
$LN39@CGInventor:

; 4824 : 		{
; 4825 : 			LogAddTD("[%s][%s] error-L3 : JewelOfHarmony Mixing",
; 4826 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4827 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4828 : 
; 4829 : 			return;
; 4830 : 		}
; 4831 : 	}
; 4832 : 
; 4833 : 	if ( lpMsg->sFlag == 11 || lpMsg->sFlag == 12 || lpMsg->sFlag == 13 || lpMsg->sFlag == 14 ||
; 4834 : 		 lpMsg->tFlag == 11 || lpMsg->tFlag == 12 || lpMsg->tFlag == 13 || lpMsg->tFlag == 14 )

  00377	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  0037a	74 22		 je	 SHORT $LN41@CGInventor
  0037c	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  0037f	74 1d		 je	 SHORT $LN41@CGInventor
  00381	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  00384	74 18		 je	 SHORT $LN41@CGInventor
  00386	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  00389	74 13		 je	 SHORT $LN41@CGInventor
  0038b	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0038e	3c 0b		 cmp	 al, 11			; 0000000bH
  00390	74 0c		 je	 SHORT $LN41@CGInventor
  00392	3c 0c		 cmp	 al, 12			; 0000000cH
  00394	74 08		 je	 SHORT $LN41@CGInventor
  00396	3c 0d		 cmp	 al, 13			; 0000000dH
  00398	74 04		 je	 SHORT $LN41@CGInventor
  0039a	3c 0e		 cmp	 al, 14			; 0000000eH
  0039c	75 51		 jne	 SHORT $LN44@CGInventor
$LN41@CGInventor:

; 4835 : 	{
; 4836 : 		if ( lpObj->m_IfState.use	 < 1 || lpObj->m_IfState.type !=7 )

  0039e	8b 93 b8 11 00
	00		 mov	 edx, DWORD PTR [ebx+4536]
  003a4	8b c2		 mov	 eax, edx
  003a6	24 03		 and	 al, 3
  003a8	3c 01		 cmp	 al, 1
  003aa	0f 82 a9 09 00
	00		 jb	 $LN53@CGInventor
  003b0	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  003b6	81 fa c0 01 00
	00		 cmp	 edx, 448		; 000001c0H
  003bc	0f 85 97 09 00
	00		 jne	 $LN53@CGInventor

; 4837 : 		{
; 4838 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4839 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 4840 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4841 : 
; 4842 : 			return;
; 4843 : 		}
; 4844 : 
; 4845 : 		if ( lpObj->ChaosLock == TRUE )

  003c2	83 bb 20 12 00
	00 01		 cmp	 DWORD PTR [ebx+4640], 1
  003c9	75 24		 jne	 SHORT $LN44@CGInventor

; 4846 : 		{
; 4847 : 			LogAddTD("[%s][%s] error-L3 : SocketItem Mixing",

  003cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003d1	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  003d4	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  003da	50		 push	 eax
  003db	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  003de	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  003e4	50		 push	 eax
  003e5	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JPIJOKEC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5SocketItem?5M@

; 4848 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4849 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4850 : 
; 4851 : 			return;

  003ea	e9 5a fe ff ff	 jmp	 $LN171@CGInventor
$LN44@CGInventor:

; 4852 : 		}
; 4853 : 	}
; 4854 : 
; 4855 : 	if ( lpMsg->sFlag == 15 || lpMsg->sFlag == 16 ||
; 4856 : 		 lpMsg->tFlag == 15 || lpMsg->tFlag == 16 )

  003ef	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  003f2	74 10		 je	 SHORT $LN46@CGInventor
  003f4	80 f9 10	 cmp	 cl, 16			; 00000010H
  003f7	74 0b		 je	 SHORT $LN46@CGInventor
  003f9	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  003fc	3c 0f		 cmp	 al, 15			; 0000000fH
  003fe	74 04		 je	 SHORT $LN46@CGInventor
  00400	3c 10		 cmp	 al, 16			; 00000010H
  00402	75 51		 jne	 SHORT $LN49@CGInventor
$LN46@CGInventor:

; 4857 : 	{
; 4858 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type !=7 )

  00404	8b 93 b8 11 00
	00		 mov	 edx, DWORD PTR [ebx+4536]
  0040a	8b c2		 mov	 eax, edx
  0040c	24 03		 and	 al, 3
  0040e	3c 01		 cmp	 al, 1
  00410	0f 82 43 09 00
	00		 jb	 $LN53@CGInventor
  00416	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  0041c	81 fa c0 01 00
	00		 cmp	 edx, 448		; 000001c0H
  00422	0f 85 31 09 00
	00		 jne	 $LN53@CGInventor

; 4859 : 		{
; 4860 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4861 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",
; 4862 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4863 : 			return;
; 4864 : 		}
; 4865 : 
; 4866 : 		if ( lpObj->ChaosLock == TRUE )

  00428	83 bb 20 12 00
	00 01		 cmp	 DWORD PTR [ebx+4640], 1
  0042f	75 24		 jne	 SHORT $LN49@CGInventor

; 4867 : 		{
; 4868 : 			LogAddTD("[%s][%s] error-L3 : LuckyItem Mixing",

  00431	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00437	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0043a	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00440	50		 push	 eax
  00441	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00444	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  0044a	50		 push	 eax
  0044b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LHICMFIE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5LuckyItem?5Mi@

; 4869 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4870 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4871 : 			return;

  00450	e9 f4 fd ff ff	 jmp	 $LN171@CGInventor
$LN49@CGInventor:

; 4872 : 		}
; 4873 : 	}
; 4874 : 
; 4875 : 	if ( lpMsg->sFlag == 17 || lpMsg->tFlag == 17 )

  00455	80 f9 11	 cmp	 cl, 17			; 00000011H
  00458	74 06		 je	 SHORT $LN51@CGInventor
  0045a	80 7e 11 11	 cmp	 BYTE PTR [esi+17], 17	; 00000011H
  0045e	75 51		 jne	 SHORT $LN54@CGInventor
$LN51@CGInventor:

; 4876 : 	{
; 4877 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type !=7 )

  00460	8b 93 b8 11 00
	00		 mov	 edx, DWORD PTR [ebx+4536]
  00466	8b c2		 mov	 eax, edx
  00468	24 03		 and	 al, 3
  0046a	3c 01		 cmp	 al, 1
  0046c	0f 82 e7 08 00
	00		 jb	 $LN53@CGInventor
  00472	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  00478	81 fa c0 01 00
	00		 cmp	 edx, 448		; 000001c0H
  0047e	0f 85 d5 08 00
	00		 jne	 $LN53@CGInventor

; 4883 : 		}
; 4884 : 
; 4885 : 		if ( lpObj->ChaosLock == TRUE )

  00484	83 bb 20 12 00
	00 01		 cmp	 DWORD PTR [ebx+4640], 1
  0048b	75 24		 jne	 SHORT $LN54@CGInventor

; 4886 : 		{
; 4887 : 			LogAddTD("[%s][%s] error-L3 : Elemental Mixing",

  0048d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00493	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00496	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  0049c	50		 push	 eax
  0049d	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  004a0	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  004a6	50		 push	 eax
  004a7	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GLNEHHDC@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5Elemental?5Mi@

; 4888 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4889 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4890 : 			return;

  004ac	e9 98 fd ff ff	 jmp	 $LN171@CGInventor
$LN54@CGInventor:

; 4891 : 		}
; 4892 : 	}
; 4893 : 
; 4894 : 	if ( lpMsg->sFlag == 2 || lpMsg->tFlag == 2 )

  004b1	80 f9 02	 cmp	 cl, 2
  004b4	74 06		 je	 SHORT $LN56@CGInventor
  004b6	80 7e 11 02	 cmp	 BYTE PTR [esi+17], 2
  004ba	75 24		 jne	 SHORT $LN57@CGInventor
$LN56@CGInventor:

; 4895 : 	{
; 4896 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 6 )

  004bc	8b 93 b8 11 00
	00		 mov	 edx, DWORD PTR [ebx+4536]
  004c2	8b c2		 mov	 eax, edx
  004c4	24 03		 and	 al, 3
  004c6	3c 01		 cmp	 al, 1
  004c8	0f 82 56 08 00
	00		 jb	 $LN58@CGInventor
  004ce	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  004d4	81 fa 80 01 00
	00		 cmp	 edx, 384		; 00000180H
  004da	0f 85 44 08 00
	00		 jne	 $LN58@CGInventor
$LN57@CGInventor:

; 4902 : 		}
; 4903 : 	}
; 4904 : 
; 4905 : 	if ( lpMsg->sFlag == 1 && lpMsg->tFlag == 0 )

  004e0	80 f9 01	 cmp	 cl, 1
  004e3	75 54		 jne	 SHORT $LN60@CGInventor
  004e5	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  004e9	75 4e		 jne	 SHORT $LN60@CGInventor

; 4906 : 	{
; 4907 : 		if ( lpObj->m_IfState.use < 1 || lpObj->m_IfState.type != 1 )

  004eb	8b 93 b8 11 00
	00		 mov	 edx, DWORD PTR [ebx+4536]
  004f1	8b c2		 mov	 eax, edx
  004f3	24 03		 and	 al, 3
  004f5	3a c1		 cmp	 al, cl
  004f7	72 0b		 jb	 SHORT $LN61@CGInventor
  004f9	81 e2 c0 ff 00
	00		 and	 edx, 65472		; 0000ffc0H
  004ff	83 fa 40	 cmp	 edx, 64			; 00000040H
  00502	74 35		 je	 SHORT $LN60@CGInventor
$LN61@CGInventor:

; 4908 : 		{
; 4909 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00504	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00507	50		 push	 eax
  00508	6a 00		 push	 0
  0050a	68 ff 00 00 00	 push	 255			; 000000ffH
  0050f	57		 push	 edi
  00510	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4910 : 			LogAdd("[%s][%s] error-L1 : used not Trade", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00515	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0051b	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0051e	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00524	50		 push	 eax
  00525	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00528	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  0052e	50		 push	 eax
  0052f	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LILEALBE@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Tra@

; 4911 : 
; 4912 : 			return;

  00534	e9 b4 08 00 00	 jmp	 $LN151@CGInventor
$LN60@CGInventor:

; 4913 : 		}
; 4914 : 	}
; 4915 : 
; 4916 : 	if ( lpMsg->sFlag == 2 && lpMsg->tFlag == 0 )

  00539	80 f9 02	 cmp	 cl, 2
  0053c	0f 85 0e 01 00
	00		 jne	 $LN147@CGInventor
  00542	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00546	0f 85 04 01 00
	00		 jne	 $LN147@CGInventor

; 4917 : 	{
; 4918 : 		int money = ::GetWarehouseUsedHowMuch(lpObj->Level,lpObj->MasterLevel, lpObj->WarehousePW);

  0054c	0f bf 83 02 12
	00 00		 movsx	 eax, WORD PTR [ebx+4610]
  00553	50		 push	 eax
  00554	0f bf 83 a8 00
	00 00		 movsx	 eax, WORD PTR [ebx+168]
  0055b	50		 push	 eax
  0055c	0f bf 83 96 00
	00 00		 movsx	 eax, WORD PTR [ebx+150]
  00563	50		 push	 eax
  00564	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHHH@Z ; GetWarehouseUsedHowMuch

; 4919 : 
; 4920 : 		if ( (lpObj->Money - money ) < 1 && (lpObj->WarehouseMoney - money) < 1)

  00569	8b 8b cc 00 00
	00		 mov	 ecx, DWORD PTR [ebx+204]
  0056f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00572	2b c8		 sub	 ecx, eax
  00574	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _money$1$[ebp], eax
  0057a	83 f9 01	 cmp	 ecx, 1
  0057d	7d 67		 jge	 SHORT $LN63@CGInventor
  0057f	8b 8b 08 12 00
	00		 mov	 ecx, DWORD PTR [ebx+4616]
  00585	2b c8		 sub	 ecx, eax
  00587	83 f9 01	 cmp	 ecx, 1
  0058a	7d 5a		 jge	 SHORT $LN63@CGInventor

; 4921 : 		{
; 4922 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  0058c	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  0058f	50		 push	 eax
  00590	6a 00		 push	 0
  00592	68 ff 00 00 00	 push	 255			; 000000ffH
  00597	57		 push	 edi
  00598	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0059d	83 c4 10	 add	 esp, 16			; 00000010H

; 4923 : 			char szTemp[256];
; 4924 : 			sprintf_s(szTemp, lMsg.Get(MSGGET(6, 69)), money);

  005a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  005a5	ff b5 d8 fe ff
	ff		 push	 DWORD PTR _money$1$[ebp]
  005ab	68 45 06 00 00	 push	 1605			; 00000645H
  005b0	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  005b5	50		 push	 eax
  005b6	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$3[ebp]
  005bc	50		 push	 eax
  005bd	e8 00 00 00 00	 call	 ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ; sprintf_s<256>

; 4925 : 			::GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  005c2	6a 01		 push	 1
  005c4	ff 33		 push	 DWORD PTR [ebx]
  005c6	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$3[ebp]
  005cc	50		 push	 eax
  005cd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  005d2	83 c4 18	 add	 esp, 24			; 00000018H
  005d5	5f		 pop	 edi
  005d6	5e		 pop	 esi
  005d7	5b		 pop	 ebx

; 5139 : 	}
; 5140 : }

  005d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005db	33 cd		 xor	 ecx, ebp
  005dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e2	8b e5		 mov	 esp, ebp
  005e4	5d		 pop	 ebp
  005e5	c3		 ret	 0
$LN63@CGInventor:

; 4926 : 
; 4927 : 			return;
; 4928 : 		}
; 4929 : 
; 4930 : 		if ( ::bCanWarehouseLock == TRUE )

  005e6	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?bCanWarehouseLock@@3HA, 1 ; bCanWarehouseLock
  005ed	75 56		 jne	 SHORT $LN145@CGInventor

; 4931 : 		{
; 4932 : 			if ( gObj[aIndex].WarehouseLock == 1 )

  005ef	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005f4	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv1519[ebp]
  005fa	80 bc 01 04 12
	00 00 01	 cmp	 BYTE PTR [ecx+eax+4612], 1
  00602	75 41		 jne	 SHORT $LN145@CGInventor

; 4933 : 			{
; 4934 : 				::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00604	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00607	50		 push	 eax
  00608	6a 00		 push	 0
  0060a	68 ff 00 00 00	 push	 255			; 000000ffH
  0060f	57		 push	 edi
  00610	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00615	83 c4 10	 add	 esp, 16			; 00000010H

; 4935 : 				::GCServerMsgStringSend(lMsg.Get(MSGGET(6, 70)), lpObj->m_Index, 1);

  00618	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0061d	6a 01		 push	 1
  0061f	ff 33		 push	 DWORD PTR [ebx]
  00621	68 46 06 00 00	 push	 1606			; 00000646H
  00626	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0062b	50		 push	 eax
  0062c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00631	83 c4 0c	 add	 esp, 12			; 0000000cH
  00634	5f		 pop	 edi
  00635	5e		 pop	 esi
  00636	5b		 pop	 ebx

; 5139 : 	}
; 5140 : }

  00637	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0063a	33 cd		 xor	 ecx, ebp
  0063c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00641	8b e5		 mov	 esp, ebp
  00643	5d		 pop	 ebp
  00644	c3		 ret	 0
$LN145@CGInventor:

; 4936 : 
; 4937 : 				return;

  00645	8a 4d f5	 mov	 cl, BYTE PTR _ItemInfo$[ebp+5]
  00648	8a 45 f3	 mov	 al, BYTE PTR _ItemInfo$[ebp+3]
  0064b	8a 55 f0	 mov	 dl, BYTE PTR _ItemInfo$[ebp]
  0064e	eb 12		 jmp	 SHORT $LN65@CGInventor
$LN147@CGInventor:
  00650	8a 8d dd fe ff
	ff		 mov	 cl, BYTE PTR _ItemInfo$3$[ebp]
  00656	8a 85 de fe ff
	ff		 mov	 al, BYTE PTR _ItemInfo$2$[ebp]
  0065c	8a 95 df fe ff
	ff		 mov	 dl, BYTE PTR _ItemInfo$1$[ebp]
$LN65@CGInventor:

; 4938 : 			}
; 4939 : 		}
; 4940 : 	}
; 4941 : 
; 4942 : 	if( it_type != 8 )

  00662	83 bd e8 fe ff
	ff 08		 cmp	 DWORD PTR _it_type$1$[ebp], 8
  00669	74 37		 je	 SHORT $LN68@CGInventor

; 4943 : 	{
; 4944 : 		int type = (ItemInfo[I_TYPE] + ((ItemInfo[I_NOPTION] & 0x80 )*2)) + ((ItemInfo[I_380OPTION] & 0xF0)<<5);

  0066b	0f b6 c9	 movzx	 ecx, cl
  0066e	0f b6 c0	 movzx	 eax, al
  00671	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00677	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0067c	c1 e1 04	 shl	 ecx, 4
  0067f	03 c8		 add	 ecx, eax
  00681	0f b6 c2	 movzx	 eax, dl
  00684	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]

; 4945 : 		LPITEM_ATTRIBUTE lpItemAttr = GetItemAttr(type);

  00687	50		 push	 eax
  00688	e8 00 00 00 00	 call	 ?GetItemAttr@@YAPAUITEM_ATTRIBUTE@@H@Z ; GetItemAttr
  0068d	83 c4 04	 add	 esp, 4

; 4946 : 
; 4947 : 		if ( lpItemAttr == NULL )

  00690	85 c0		 test	 eax, eax
  00692	0f 84 a4 f9 ff
	ff		 je	 $LN173@CGInventor

; 4948 : 		{
; 4949 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4950 : 			return;
; 4951 : 		}
; 4952 : 
; 4953 : 		if ( lpItemAttr->QuestItem != false )

  00698	80 78 60 00	 cmp	 BYTE PTR [eax+96], 0
  0069c	0f 85 9a f9 ff
	ff		 jne	 $LN173@CGInventor
$LN68@CGInventor:

; 4954 : 		{
; 4955 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);
; 4956 : 			return;
; 4957 : 		}
; 4958 : 	}
; 4959 : 
; 4960 : 	if ( (lpMsg->sFlag == 0 && lpMsg->tFlag == 0) ||
; 4961 :  		 (lpMsg->sFlag == 2 && lpMsg->tFlag == 0) ||
; 4962 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 2) ||
; 4963 :  		 (lpMsg->sFlag == 2 && lpMsg->tFlag == 2) ||
; 4964 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 3) ||
; 4965 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 5) ||
; 4966 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 6) ||
; 4967 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 7) ||
; 4968 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 8) ||
; 4969 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 9) ||
; 4970 : 		 (lpMsg->sFlag == 9 && lpMsg->tFlag == 9) ||
; 4971 : 		 (lpMsg->sFlag == 9 && lpMsg->tFlag == 0) ||
; 4972 : 
; 4973 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 10) ||
; 4974 : 		 (lpMsg->sFlag == 10 && lpMsg->tFlag == 10) ||
; 4975 : 		 (lpMsg->sFlag == 10 && lpMsg->tFlag == 0) ||
; 4976 : 
; 4977 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 4) ||
; 4978 : 		 (lpMsg->sFlag == 4 && lpMsg->tFlag == 0) ||
; 4979 : 		 (lpMsg->sFlag == 4 && lpMsg->tFlag == 4) ||
; 4980 : 		 (lpMsg->sFlag == 5 && lpMsg->tFlag == 0) ||
; 4981 : 		 (lpMsg->sFlag == 5 && lpMsg->tFlag == 5) ||
; 4982 : 		 (lpMsg->sFlag == 6 && lpMsg->tFlag == 0) ||
; 4983 : 		 (lpMsg->sFlag == 6 && lpMsg->tFlag == 6) ||
; 4984 : 		 (lpMsg->sFlag == 7 && lpMsg->tFlag == 0) ||
; 4985 : 		 (lpMsg->sFlag == 7 && lpMsg->tFlag == 7) ||
; 4986 : 		 (lpMsg->sFlag == 8 && lpMsg->tFlag == 0) ||
; 4987 : 		 (lpMsg->sFlag == 8 && lpMsg->tFlag == 8) ||
; 4988 : 
; 4989 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 11) ||
; 4990 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 12) ||
; 4991 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 13) ||
; 4992 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 14) ||
; 4993 : 		 (lpMsg->sFlag == 11 && lpMsg->tFlag == 0) ||
; 4994 : 		 (lpMsg->sFlag == 12 && lpMsg->tFlag == 0) ||
; 4995 : 		 (lpMsg->sFlag == 13 && lpMsg->tFlag == 0) ||
; 4996 : 		 (lpMsg->sFlag == 14 && lpMsg->tFlag == 0) ||
; 4997 : 		 (lpMsg->sFlag == 11 && lpMsg->tFlag == 11) ||
; 4998 : 		 (lpMsg->sFlag == 12 && lpMsg->tFlag == 12) ||
; 4999 : 		 (lpMsg->sFlag == 13 && lpMsg->tFlag == 13) ||
; 5000 : 		 (lpMsg->sFlag == 14 && lpMsg->tFlag == 14) ||
; 5001 : 
; 5002 : 		 (lpMsg->sFlag == 15 && lpMsg->tFlag == 0) ||
; 5003 : 		 (lpMsg->sFlag == 16 && lpMsg->tFlag == 0) ||
; 5004 : 		 (lpMsg->sFlag == 15 && lpMsg->tFlag == 15) ||
; 5005 : 		 (lpMsg->sFlag == 16 && lpMsg->tFlag == 16) ||
; 5006 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 15) ||
; 5007 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 16) ||
; 5008 : 
; 5009 : 		 (lpMsg->sFlag == 17 && lpMsg->tFlag == 0) ||
; 5010 : 		 (lpMsg->sFlag == 17 && lpMsg->tFlag == 17) ||
; 5011 : 		 (lpMsg->sFlag == 0 && lpMsg->tFlag == 17) ||
; 5012 : 
; 5013 : 		 (lpMsg->sFlag == 3 && lpMsg->tFlag == 0) ||

  006a2	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  006a5	84 c9		 test	 cl, cl
  006a7	75 0b		 jne	 SHORT $LN71@CGInventor
  006a9	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  006ac	84 c0		 test	 al, al
  006ae	0f 84 91 02 00
	00		 je	 $LN70@CGInventor
$LN71@CGInventor:
  006b4	80 f9 02	 cmp	 cl, 2
  006b7	75 0b		 jne	 SHORT $LN72@CGInventor
  006b9	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  006bc	84 c0		 test	 al, al
  006be	0f 84 81 02 00
	00		 je	 $LN70@CGInventor
$LN72@CGInventor:
  006c4	84 c9		 test	 cl, cl
  006c6	75 0b		 jne	 SHORT $LN73@CGInventor
  006c8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  006cb	3c 02		 cmp	 al, 2
  006cd	0f 84 72 02 00
	00		 je	 $LN70@CGInventor
$LN73@CGInventor:
  006d3	80 f9 02	 cmp	 cl, 2
  006d6	75 0b		 jne	 SHORT $LN74@CGInventor
  006d8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  006db	3a c1		 cmp	 al, cl
  006dd	0f 84 62 02 00
	00		 je	 $LN70@CGInventor
$LN74@CGInventor:
  006e3	84 c9		 test	 cl, cl
  006e5	75 47		 jne	 SHORT $LN80@CGInventor
  006e7	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  006ea	3c 03		 cmp	 al, 3
  006ec	0f 84 53 02 00
	00		 je	 $LN70@CGInventor
  006f2	84 c9		 test	 cl, cl
  006f4	75 38		 jne	 SHORT $LN80@CGInventor
  006f6	3c 05		 cmp	 al, 5
  006f8	0f 84 47 02 00
	00		 je	 $LN70@CGInventor
  006fe	84 c9		 test	 cl, cl
  00700	75 2c		 jne	 SHORT $LN80@CGInventor
  00702	3c 06		 cmp	 al, 6
  00704	0f 84 3b 02 00
	00		 je	 $LN70@CGInventor
  0070a	84 c9		 test	 cl, cl
  0070c	75 20		 jne	 SHORT $LN80@CGInventor
  0070e	3c 07		 cmp	 al, 7
  00710	0f 84 2f 02 00
	00		 je	 $LN70@CGInventor
  00716	84 c9		 test	 cl, cl
  00718	75 14		 jne	 SHORT $LN80@CGInventor
  0071a	3c 08		 cmp	 al, 8
  0071c	0f 84 23 02 00
	00		 je	 $LN70@CGInventor
  00722	84 c9		 test	 cl, cl
  00724	75 08		 jne	 SHORT $LN80@CGInventor
  00726	3c 09		 cmp	 al, 9
  00728	0f 84 17 02 00
	00		 je	 $LN70@CGInventor
$LN80@CGInventor:
  0072e	80 f9 09	 cmp	 cl, 9
  00731	75 17		 jne	 SHORT $LN82@CGInventor
  00733	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00736	3a c1		 cmp	 al, cl
  00738	0f 84 07 02 00
	00		 je	 $LN70@CGInventor
  0073e	3a c9		 cmp	 cl, cl
  00740	75 08		 jne	 SHORT $LN82@CGInventor
  00742	84 c0		 test	 al, al
  00744	0f 84 fb 01 00
	00		 je	 $LN70@CGInventor
$LN82@CGInventor:
  0074a	84 c9		 test	 cl, cl
  0074c	75 0b		 jne	 SHORT $LN83@CGInventor
  0074e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00751	3c 0a		 cmp	 al, 10			; 0000000aH
  00753	0f 84 ec 01 00
	00		 je	 $LN70@CGInventor
$LN83@CGInventor:
  00759	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  0075c	75 17		 jne	 SHORT $LN85@CGInventor
  0075e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00761	3a c1		 cmp	 al, cl
  00763	0f 84 dc 01 00
	00		 je	 $LN70@CGInventor
  00769	3a c9		 cmp	 cl, cl
  0076b	75 08		 jne	 SHORT $LN85@CGInventor
  0076d	84 c0		 test	 al, al
  0076f	0f 84 d0 01 00
	00		 je	 $LN70@CGInventor
$LN85@CGInventor:
  00775	84 c9		 test	 cl, cl
  00777	75 0b		 jne	 SHORT $LN86@CGInventor
  00779	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0077c	3c 04		 cmp	 al, 4
  0077e	0f 84 c1 01 00
	00		 je	 $LN70@CGInventor
$LN86@CGInventor:
  00784	80 f9 04	 cmp	 cl, 4
  00787	75 17		 jne	 SHORT $LN88@CGInventor
  00789	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0078c	84 c0		 test	 al, al
  0078e	0f 84 b1 01 00
	00		 je	 $LN70@CGInventor
  00794	3a c9		 cmp	 cl, cl
  00796	75 08		 jne	 SHORT $LN88@CGInventor
  00798	3a c1		 cmp	 al, cl
  0079a	0f 84 a5 01 00
	00		 je	 $LN70@CGInventor
$LN88@CGInventor:
  007a0	80 f9 05	 cmp	 cl, 5
  007a3	75 17		 jne	 SHORT $LN90@CGInventor
  007a5	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  007a8	84 c0		 test	 al, al
  007aa	0f 84 95 01 00
	00		 je	 $LN70@CGInventor
  007b0	3a c9		 cmp	 cl, cl
  007b2	75 08		 jne	 SHORT $LN90@CGInventor
  007b4	3a c1		 cmp	 al, cl
  007b6	0f 84 89 01 00
	00		 je	 $LN70@CGInventor
$LN90@CGInventor:
  007bc	80 f9 06	 cmp	 cl, 6
  007bf	75 17		 jne	 SHORT $LN92@CGInventor
  007c1	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  007c4	84 c0		 test	 al, al
  007c6	0f 84 79 01 00
	00		 je	 $LN70@CGInventor
  007cc	3a c9		 cmp	 cl, cl
  007ce	75 08		 jne	 SHORT $LN92@CGInventor
  007d0	3a c1		 cmp	 al, cl
  007d2	0f 84 6d 01 00
	00		 je	 $LN70@CGInventor
$LN92@CGInventor:
  007d8	80 f9 07	 cmp	 cl, 7
  007db	75 17		 jne	 SHORT $LN94@CGInventor
  007dd	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  007e0	84 c0		 test	 al, al
  007e2	0f 84 5d 01 00
	00		 je	 $LN70@CGInventor
  007e8	3a c9		 cmp	 cl, cl
  007ea	75 08		 jne	 SHORT $LN94@CGInventor
  007ec	3a c1		 cmp	 al, cl
  007ee	0f 84 51 01 00
	00		 je	 $LN70@CGInventor
$LN94@CGInventor:
  007f4	80 f9 08	 cmp	 cl, 8
  007f7	75 17		 jne	 SHORT $LN96@CGInventor
  007f9	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  007fc	84 c0		 test	 al, al
  007fe	0f 84 41 01 00
	00		 je	 $LN70@CGInventor
  00804	3a c9		 cmp	 cl, cl
  00806	75 08		 jne	 SHORT $LN96@CGInventor
  00808	3a c1		 cmp	 al, cl
  0080a	0f 84 35 01 00
	00		 je	 $LN70@CGInventor
$LN96@CGInventor:
  00810	84 c9		 test	 cl, cl
  00812	75 2f		 jne	 SHORT $LN100@CGInventor
  00814	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00817	3c 0b		 cmp	 al, 11			; 0000000bH
  00819	0f 84 26 01 00
	00		 je	 $LN70@CGInventor
  0081f	84 c9		 test	 cl, cl
  00821	75 20		 jne	 SHORT $LN100@CGInventor
  00823	3c 0c		 cmp	 al, 12			; 0000000cH
  00825	0f 84 1a 01 00
	00		 je	 $LN70@CGInventor
  0082b	84 c9		 test	 cl, cl
  0082d	75 14		 jne	 SHORT $LN100@CGInventor
  0082f	3c 0d		 cmp	 al, 13			; 0000000dH
  00831	0f 84 0e 01 00
	00		 je	 $LN70@CGInventor
  00837	84 c9		 test	 cl, cl
  00839	75 08		 jne	 SHORT $LN100@CGInventor
  0083b	3c 0e		 cmp	 al, 14			; 0000000eH
  0083d	0f 84 02 01 00
	00		 je	 $LN70@CGInventor
$LN100@CGInventor:
  00843	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00846	75 0b		 jne	 SHORT $LN101@CGInventor
  00848	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0084b	84 c0		 test	 al, al
  0084d	0f 84 f2 00 00
	00		 je	 $LN70@CGInventor
$LN101@CGInventor:
  00853	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  00856	75 0b		 jne	 SHORT $LN102@CGInventor
  00858	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0085b	84 c0		 test	 al, al
  0085d	0f 84 e2 00 00
	00		 je	 $LN70@CGInventor
$LN102@CGInventor:
  00863	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  00866	75 0b		 jne	 SHORT $LN103@CGInventor
  00868	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0086b	84 c0		 test	 al, al
  0086d	0f 84 d2 00 00
	00		 je	 $LN70@CGInventor
$LN103@CGInventor:
  00873	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  00876	75 0b		 jne	 SHORT $LN104@CGInventor
  00878	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0087b	84 c0		 test	 al, al
  0087d	0f 84 c2 00 00
	00		 je	 $LN70@CGInventor
$LN104@CGInventor:
  00883	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00886	75 0b		 jne	 SHORT $LN105@CGInventor
  00888	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0088b	3a c1		 cmp	 al, cl
  0088d	0f 84 b2 00 00
	00		 je	 $LN70@CGInventor
$LN105@CGInventor:
  00893	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  00896	75 0b		 jne	 SHORT $LN106@CGInventor
  00898	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0089b	3a c1		 cmp	 al, cl
  0089d	0f 84 a2 00 00
	00		 je	 $LN70@CGInventor
$LN106@CGInventor:
  008a3	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  008a6	75 0b		 jne	 SHORT $LN107@CGInventor
  008a8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008ab	3a c1		 cmp	 al, cl
  008ad	0f 84 92 00 00
	00		 je	 $LN70@CGInventor
$LN107@CGInventor:
  008b3	80 f9 0e	 cmp	 cl, 14			; 0000000eH
  008b6	75 0b		 jne	 SHORT $LN108@CGInventor
  008b8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008bb	3a c1		 cmp	 al, cl
  008bd	0f 84 82 00 00
	00		 je	 $LN70@CGInventor
$LN108@CGInventor:
  008c3	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  008c6	75 07		 jne	 SHORT $LN109@CGInventor
  008c8	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008cb	84 c0		 test	 al, al
  008cd	74 76		 je	 SHORT $LN70@CGInventor
$LN109@CGInventor:
  008cf	80 f9 10	 cmp	 cl, 16			; 00000010H
  008d2	75 07		 jne	 SHORT $LN110@CGInventor
  008d4	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008d7	84 c0		 test	 al, al
  008d9	74 6a		 je	 SHORT $LN70@CGInventor
$LN110@CGInventor:
  008db	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  008de	75 07		 jne	 SHORT $LN111@CGInventor
  008e0	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008e3	3a c1		 cmp	 al, cl
  008e5	74 5e		 je	 SHORT $LN70@CGInventor
$LN111@CGInventor:
  008e7	80 f9 10	 cmp	 cl, 16			; 00000010H
  008ea	75 07		 jne	 SHORT $LN112@CGInventor
  008ec	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008ef	3a c1		 cmp	 al, cl
  008f1	74 52		 je	 SHORT $LN70@CGInventor
$LN112@CGInventor:
  008f3	84 c9		 test	 cl, cl
  008f5	75 0f		 jne	 SHORT $LN114@CGInventor
  008f7	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  008fa	3c 0f		 cmp	 al, 15			; 0000000fH
  008fc	74 47		 je	 SHORT $LN70@CGInventor
  008fe	84 c9		 test	 cl, cl
  00900	75 04		 jne	 SHORT $LN114@CGInventor
  00902	3c 10		 cmp	 al, 16			; 00000010H
  00904	74 3f		 je	 SHORT $LN70@CGInventor
$LN114@CGInventor:
  00906	80 f9 11	 cmp	 cl, 17			; 00000011H
  00909	75 0f		 jne	 SHORT $LN116@CGInventor
  0090b	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  0090e	84 c0		 test	 al, al
  00910	74 33		 je	 SHORT $LN70@CGInventor
  00912	3a c9		 cmp	 cl, cl
  00914	75 04		 jne	 SHORT $LN116@CGInventor
  00916	3a c1		 cmp	 al, cl
  00918	74 2b		 je	 SHORT $LN70@CGInventor
$LN116@CGInventor:
  0091a	84 c9		 test	 cl, cl
  0091c	75 07		 jne	 SHORT $LN117@CGInventor
  0091e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00921	3c 11		 cmp	 al, 17			; 00000011H
  00923	74 20		 je	 SHORT $LN70@CGInventor
$LN117@CGInventor:
  00925	80 f9 03	 cmp	 cl, 3
  00928	0f 85 b8 02 00
	00		 jne	 $LN69@CGInventor
  0092e	8a 46 11	 mov	 al, BYTE PTR [esi+17]
  00931	84 c0		 test	 al, al
  00933	74 10		 je	 SHORT $LN70@CGInventor
  00935	3a c9		 cmp	 cl, cl
  00937	0f 85 a9 02 00
	00		 jne	 $LN69@CGInventor
  0093d	3a c1		 cmp	 al, cl
  0093f	0f 85 a1 02 00
	00		 jne	 $LN69@CGInventor
$LN70@CGInventor:

; 5014 : 		 (lpMsg->sFlag == 3 && lpMsg->tFlag == 3) )
; 5015 : 	{
; 5016 : 		BOOL DurSSend;
; 5017 : 		BOOL DurTSend;
; 5018 : 
; 5019 : 		result = gObjInventoryMoveItem(aIndex, source, target, DurSSend, DurTSend, lpMsg->sFlag, lpMsg->tFlag, (LPBYTE)&ItemInfo);

  00945	8d 55 f0	 lea	 edx, DWORD PTR _ItemInfo$[ebp]
  00948	52		 push	 edx
  00949	50		 push	 eax
  0094a	51		 push	 ecx
  0094b	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _DurTSend$2[ebp]
  00951	50		 push	 eax
  00952	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _DurSSend$1[ebp]
  00958	50		 push	 eax
  00959	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _target$1$[ebp]
  0095f	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _source$1$[ebp]
  00965	57		 push	 edi
  00966	e8 00 00 00 00	 call	 ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ; gObjInventoryMoveItem
  0096b	88 85 e8 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], al

; 5020 : 		::GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  00971	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00974	50		 push	 eax
  00975	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _target$1$[ebp]
  0097b	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _result$[ebp]
  00981	57		 push	 edi
  00982	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00987	83 c4 30	 add	 esp, 48			; 00000030H

; 5021 : 
; 5022 : 		if ( DurSSend != FALSE )

  0098a	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _DurSSend$1[ebp], 0
  00991	74 28		 je	 SHORT $LN119@CGInventor

; 5023 : 			::GCItemDurSend(aIndex, source, (BYTE)lpObj->pInventory[source].m_Durability, FALSE);

  00993	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _source$1$[ebp]
  00999	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0099f	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  009a5	6a 00		 push	 0
  009a7	f3 0f 2c 44 08
	24		 cvttss2si eax, DWORD PTR [eax+ecx+36]
  009ad	0f b6 c0	 movzx	 eax, al
  009b0	50		 push	 eax
  009b1	52		 push	 edx
  009b2	57		 push	 edi
  009b3	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  009b8	83 c4 10	 add	 esp, 16			; 00000010H
$LN119@CGInventor:

; 5024 : 
; 5025 : 		if ( DurTSend != FALSE )

  009bb	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _DurTSend$2[ebp], 0
  009c2	74 28		 je	 SHORT $LN120@CGInventor

; 5026 : 			::GCItemDurSend(aIndex, target, (BYTE)lpObj->pInventory[target].m_Durability, FALSE);

  009c4	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _target$1$[ebp]
  009ca	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  009d0	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  009d6	6a 00		 push	 0
  009d8	f3 0f 2c 44 08
	24		 cvttss2si eax, DWORD PTR [eax+ecx+36]
  009de	0f b6 c0	 movzx	 eax, al
  009e1	50		 push	 eax
  009e2	52		 push	 edx
  009e3	57		 push	 edi
  009e4	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  009e9	83 c4 10	 add	 esp, 16			; 00000010H
$LN120@CGInventor:

; 5027 : 
; 5028 : 		int type = lpMsg->sItemInfo[0] + ((lpMsg->sItemInfo[3]&0x80)*2)+((lpMsg->sItemInfo[5]&0xF0)<<5);

  009ec	0f b6 4e 0a	 movzx	 ecx, BYTE PTR [esi+10]
  009f0	0f 57 c9	 xorps	 xmm1, xmm1
  009f3	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  009f7	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  009fd	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00a02	c1 e1 04	 shl	 ecx, 4
  00a05	03 c8		 add	 ecx, eax
  00a07	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00a0b	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00a0e	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _type$1$[ebp], edx

; 5029 : 
; 5030 : 		if( type == ITEMGET(14, 29) ||
; 5031 : 			type == ITEMGET(12, 144) ||

  00a14	81 fa 1d 1c 00
	00		 cmp	 edx, 7197		; 00001c1dH
  00a1a	74 10		 je	 SHORT $LN122@CGInventor
  00a1c	81 fa 90 18 00
	00		 cmp	 edx, 6288		; 00001890H
  00a22	74 08		 je	 SHORT $LN122@CGInventor
  00a24	81 fa 92 18 00
	00		 cmp	 edx, 6290		; 00001892H
  00a2a	75 45		 jne	 SHORT $LN124@CGInventor
$LN122@CGInventor:

; 5032 : 			type == ITEMGET(12, 146) )
; 5033 : 		{
; 5034 : 			if( lpObj->pInventory[target].m_Durability == 0.0f )

  00a2c	69 8d e4 fe ff
	ff d4 00 00 00	 imul	 ecx, DWORD PTR _target$1$[ebp], 212
  00a36	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00a3c	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00a42	0f 2e c1	 ucomiss xmm0, xmm1
  00a45	9f		 lahf
  00a46	f6 c4 44	 test	 ah, 68			; 00000044H
  00a49	7a 26		 jp	 SHORT $LN124@CGInventor

; 5035 : 			{
; 5036 : 				if( lpMsg->sFlag == 0 &&

  00a4b	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00a4f	75 20		 jne	 SHORT $LN124@CGInventor
  00a51	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00a55	75 1a		 jne	 SHORT $LN124@CGInventor

; 5037 : 					lpMsg->tFlag == 0 )
; 5038 : 				{
; 5039 : 					::GCInventoryItemDeleteSend(aIndex, target, FALSE);

  00a57	6a 00		 push	 0
  00a59	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _target$1$[ebp]
  00a5f	57		 push	 edi
  00a60	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00a65	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _type$1$[ebp]
  00a6b	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a6e	0f 57 c9	 xorps	 xmm1, xmm1
$LN124@CGInventor:

; 5040 : 				}
; 5041 : 			}
; 5042 : 		}
; 5043 : 
; 5044 : 		if( type == ITEMGET(14,110) || type == ITEMGET(14,101) )

  00a71	81 fa 6e 1c 00
	00		 cmp	 edx, 7278		; 00001c6eH
  00a77	74 08		 je	 SHORT $LN126@CGInventor
  00a79	81 fa 65 1c 00
	00		 cmp	 edx, 7269		; 00001c65H
  00a7f	75 42		 jne	 SHORT $LN128@CGInventor
$LN126@CGInventor:

; 5045 : 		{
; 5046 : 			if( lpObj->pInventory[target].m_Durability == 0.0f )

  00a81	69 8d e4 fe ff
	ff d4 00 00 00	 imul	 ecx, DWORD PTR _target$1$[ebp], 212
  00a8b	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00a91	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00a97	0f 2e c1	 ucomiss xmm0, xmm1
  00a9a	9f		 lahf
  00a9b	f6 c4 44	 test	 ah, 68			; 00000044H
  00a9e	7a 23		 jp	 SHORT $LN128@CGInventor

; 5047 : 			{
; 5048 : 				if( lpMsg->sFlag == 0 &&

  00aa0	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00aa4	75 1d		 jne	 SHORT $LN128@CGInventor
  00aa6	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00aaa	75 17		 jne	 SHORT $LN128@CGInventor

; 5049 : 					lpMsg->tFlag == 0 )
; 5050 : 				{
; 5051 : 					::GCInventoryItemDeleteSend(aIndex, target, FALSE);

  00aac	6a 00		 push	 0
  00aae	ff b5 e4 fe ff
	ff		 push	 DWORD PTR _target$1$[ebp]
  00ab4	57		 push	 edi
  00ab5	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00aba	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _type$1$[ebp]
  00ac0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN128@CGInventor:

; 5052 : 				}
; 5053 : 			}
; 5054 : 		}
; 5055 : 
; 5056 : 		if( type == ITEMGET(13, 135) )

  00ac3	81 fa 87 1a 00
	00		 cmp	 edx, 6791		; 00001a87H
  00ac9	75 3c		 jne	 SHORT $LN131@CGInventor

; 5057 : 		{
; 5058 : 			if( lpObj->pInventory[target].m_Durability == 0.0f )

  00acb	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _target$1$[ebp]
  00ad1	0f 57 c9	 xorps	 xmm1, xmm1
  00ad4	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00ada	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  00ae0	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00ae6	0f 2e c1	 ucomiss xmm0, xmm1
  00ae9	9f		 lahf
  00aea	f6 c4 44	 test	 ah, 68			; 00000044H
  00aed	7a 18		 jp	 SHORT $LN131@CGInventor

; 5059 : 			{
; 5060 : 				if( lpMsg->sFlag == 0 &&

  00aef	80 7e 03 00	 cmp	 BYTE PTR [esi+3], 0
  00af3	75 12		 jne	 SHORT $LN131@CGInventor
  00af5	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00af9	75 0c		 jne	 SHORT $LN131@CGInventor

; 5061 : 					lpMsg->tFlag == 0 )
; 5062 : 				{
; 5063 : 					::GCInventoryItemDeleteSend(aIndex, target, FALSE);

  00afb	6a 00		 push	 0
  00afd	52		 push	 edx
  00afe	57		 push	 edi
  00aff	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00b04	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN131@CGInventor:

; 5064 : 				}
; 5065 : 			}
; 5066 : 		}
; 5067 : 
; 5068 : 		if ( result != 0xFF && lpMsg->sFlag == 2 && lpMsg->tFlag == 0)

  00b07	80 bd e8 fe ff
	ff ff		 cmp	 BYTE PTR _result$[ebp], 255 ; 000000ffH
  00b0e	0f 84 e2 02 00
	00		 je	 $LN142@CGInventor
  00b14	80 7e 03 02	 cmp	 BYTE PTR [esi+3], 2
  00b18	0f 85 d8 02 00
	00		 jne	 $LN142@CGInventor
  00b1e	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00b22	0f 85 ce 02 00
	00		 jne	 $LN142@CGInventor

; 5069 : 		{
; 5070 : 			int money = ::GetWarehouseUsedHowMuch(lpObj->Level,lpObj->MasterLevel, lpObj->WarehousePW);

  00b28	0f bf 83 02 12
	00 00		 movsx	 eax, WORD PTR [ebx+4610]
  00b2f	50		 push	 eax
  00b30	0f bf 83 a8 00
	00 00		 movsx	 eax, WORD PTR [ebx+168]
  00b37	50		 push	 eax
  00b38	0f bf 83 96 00
	00 00		 movsx	 eax, WORD PTR [ebx+150]
  00b3f	50		 push	 eax
  00b40	e8 00 00 00 00	 call	 ?GetWarehouseUsedHowMuch@@YAHHHH@Z ; GetWarehouseUsedHowMuch
  00b45	8b f0		 mov	 esi, eax
  00b47	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5071 : 
; 5072 : 			if ( (lpObj->Money - money) > 0 )

  00b4a	8b 83 cc 00 00
	00		 mov	 eax, DWORD PTR [ebx+204]
  00b50	8b c8		 mov	 ecx, eax
  00b52	2b ce		 sub	 ecx, esi
  00b54	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _iZen$1$[ebp], eax
  00b5a	85 c9		 test	 ecx, ecx
  00b5c	7e 3a		 jle	 SHORT $LN133@CGInventor

; 5073 : 			{
; 5074 : 				int iZen = lpObj->Money;
; 5075 : 				lpObj->Money -= money;
; 5076 : 				GCMoneySend(lpObj->m_Index, lpObj->Money);

  00b5e	51		 push	 ecx
  00b5f	ff 33		 push	 DWORD PTR [ebx]
  00b61	89 8b cc 00 00
	00		 mov	 DWORD PTR [ebx+204], ecx
  00b67	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend

; 5077 : 
; 5078 : 				LogAdd("Pay WareHouse Money(In Inventory) : %d - %d = %d",

  00b6c	ff b3 cc 00 00
	00		 push	 DWORD PTR [ebx+204]
  00b72	56		 push	 esi
  00b73	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _iZen$1$[ebp]
  00b79	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@BBIIADPJ@Pay?5WareHouse?5Money?$CIIn?5Inventory@
  00b7e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00b84	83 c4 18	 add	 esp, 24			; 00000018H
  00b87	5f		 pop	 edi
  00b88	5e		 pop	 esi
  00b89	5b		 pop	 ebx

; 5139 : 	}
; 5140 : }

  00b8a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b8d	33 cd		 xor	 ecx, ebp
  00b8f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b94	8b e5		 mov	 esp, ebp
  00b96	5d		 pop	 ebp
  00b97	c3		 ret	 0
$LN133@CGInventor:

; 5079 : 					iZen, money, lpObj->Money);
; 5080 : 			}
; 5081 : 			else if ( (lpObj->WarehouseMoney - money) > 0 )

  00b98	8b 8b 08 12 00
	00		 mov	 ecx, DWORD PTR [ebx+4616]
  00b9e	8b c1		 mov	 eax, ecx
  00ba0	2b c6		 sub	 eax, esi
  00ba2	85 c0		 test	 eax, eax
  00ba4	0f 8e 4c 02 00
	00		 jle	 $LN142@CGInventor

; 5082 : 			{
; 5083 : 				int iZen = lpObj->WarehouseMoney;
; 5084 : 				lpObj->WarehouseMoney -= money;
; 5085 : 	
; 5086 : 				LogAdd("Pay WareHouse Money(In WareHouse) : %d - %d = %d",

  00baa	50		 push	 eax
  00bab	56		 push	 esi
  00bac	51		 push	 ecx
  00bad	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OHHNKGKH@Pay?5WareHouse?5Money?$CIIn?5WareHouse@
  00bb2	89 83 08 12 00
	00		 mov	 DWORD PTR [ebx+4616], eax
  00bb8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 5087 : 					iZen, money, lpObj->WarehouseMoney);
; 5088 : 
; 5089 : 				GCWarehouseInventoryMoneySend(aIndex, 1, lpObj->Money, lpObj->WarehouseMoney);

  00bbe	ff b3 08 12 00
	00		 push	 DWORD PTR [ebx+4616]
  00bc4	ff b3 cc 00 00
	00		 push	 DWORD PTR [ebx+204]
  00bca	6a 01		 push	 1
  00bcc	57		 push	 edi
  00bcd	e8 00 00 00 00	 call	 ?GCWarehouseInventoryMoneySend@@YAXHEHH@Z ; GCWarehouseInventoryMoneySend
  00bd2	83 c4 20	 add	 esp, 32			; 00000020H
  00bd5	5f		 pop	 edi
  00bd6	5e		 pop	 esi
  00bd7	5b		 pop	 ebx

; 5139 : 	}
; 5140 : }

  00bd8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bdb	33 cd		 xor	 ecx, ebp
  00bdd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00be2	8b e5		 mov	 esp, ebp
  00be4	5d		 pop	 ebp
  00be5	c3		 ret	 0
$LN69@CGInventor:

; 5090 : 			}
; 5091 : 		}
; 5092 : 
; 5093 : 		return;
; 5094 : 	}
; 5095 : 
; 5096 : 	if ( lpMsg->sFlag == 1 && lpMsg->tFlag == 1 )

  00be6	80 f9 01	 cmp	 cl, 1
  00be9	0f 85 fa 00 00
	00		 jne	 $LN137@CGInventor
  00bef	38 4e 11	 cmp	 BYTE PTR [esi+17], cl
  00bf2	75 29		 jne	 SHORT $LN136@CGInventor

; 5097 : 	{
; 5098 : 		result = gObjTradeTradeMove(lpObj, source, target);

  00bf4	8b b5 e4 fe ff
	ff		 mov	 esi, DWORD PTR _target$1$[ebp]
  00bfa	56		 push	 esi
  00bfb	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _source$1$[ebp]
  00c01	53		 push	 ebx
  00c02	e8 00 00 00 00	 call	 ?gObjTradeTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjTradeTradeMove
  00c07	88 85 e8 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], al

; 5099 : 		GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  00c0d	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00c10	50		 push	 eax
  00c11	56		 push	 esi
  00c12	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _result$[ebp]

; 5100 : 
; 5101 : 		return;

  00c18	e9 3d f6 ff ff	 jmp	 $LN172@CGInventor
$LN136@CGInventor:

; 5102 : 	}
; 5103 : 
; 5104 : 	if ( lpMsg->sFlag == 1 && lpMsg->tFlag == 0 )

  00c1d	80 f9 01	 cmp	 cl, 1
  00c20	0f 85 c3 00 00
	00		 jne	 $LN137@CGInventor
  00c26	80 7e 11 00	 cmp	 BYTE PTR [esi+17], 0
  00c2a	0f 85 b9 00 00
	00		 jne	 $LN137@CGInventor

; 5105 : 	{
; 5106 : 		result = gObjTradeInventoryMove(lpObj, source, target);

  00c30	8b b5 e4 fe ff
	ff		 mov	 esi, DWORD PTR _target$1$[ebp]
  00c36	56		 push	 esi
  00c37	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _source$1$[ebp]
  00c3d	53		 push	 ebx
  00c3e	e8 00 00 00 00	 call	 ?gObjTradeInventoryMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjTradeInventoryMove
  00c43	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c46	88 85 e8 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], al

; 5107 : 
; 5108 : 		if ( result == 0xFF )

  00c4c	3c ff		 cmp	 al, 255			; 000000ffH

; 5109 : 		{
; 5110 : 			GCItemMoveResultSend(aIndex, 0xFF, target, (LPBYTE)&ItemInfo);

  00c4e	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00c51	50		 push	 eax
  00c52	56		 push	 esi
  00c53	75 23		 jne	 SHORT $LN138@CGInventor
  00c55	68 ff 00 00 00	 push	 255			; 000000ffH
  00c5a	57		 push	 edi
  00c5b	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 5111 : 			CGTradeCancelButtonRecv(aIndex);

  00c60	57		 push	 edi
  00c61	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv

; 5116 : 		}
; 5117 : 
; 5118 : 		if ( result == 0xFF )
; 5119 : 		{
; 5120 : 			lpObj->m_IfState.state = 0;

  00c66	83 a3 b8 11 00
	00 c3		 and	 DWORD PTR [ebx+4536], -61 ; ffffffc3H

; 5121 : 			GCItemListSend(aIndex);

  00c6d	57		 push	 edi
  00c6e	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  00c73	83 c4 18	 add	 esp, 24			; 00000018H
  00c76	eb 0f		 jmp	 SHORT $LN140@CGInventor
$LN138@CGInventor:

; 5112 : 		}
; 5113 : 		else
; 5114 : 		{
; 5115 : 			GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  00c78	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _result$[ebp]
  00c7e	57		 push	 edi
  00c7f	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00c84	83 c4 10	 add	 esp, 16			; 00000010H
$LN140@CGInventor:

; 5122 : 		}
; 5123 : 		
; 5124 : 		if ( lpObj->TargetNumber >= 0 )

  00c87	66 83 bb 38 06
	00 00 00	 cmp	 WORD PTR [ebx+1592], 0
  00c8f	0f 8c 61 01 00
	00		 jl	 $LN142@CGInventor

; 5125 : 		{
; 5126 : 			lpObj->TradeOk = false;
; 5127 : 			gObj[gObj[aIndex].TargetNumber].TradeOk = false;

  00c95	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv1519[ebp]
  00c9b	c6 83 f4 11 00
	00 00		 mov	 BYTE PTR [ebx+4596], 0
  00ca2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 5128 : 			GCTradeOkButtonSend(lpObj->TargetNumber, 2);

  00ca8	6a 02		 push	 2
  00caa	0f bf 84 08 38
	06 00 00	 movsx	 eax, WORD PTR [eax+ecx+1592]
  00cb2	69 c0 40 27 00
	00		 imul	 eax, eax, 10048
  00cb8	c6 84 08 f4 11
	00 00 00	 mov	 BYTE PTR [eax+ecx+4596], 0
  00cc0	0f bf 83 38 06
	00 00		 movsx	 eax, WORD PTR [ebx+1592]
  00cc7	50		 push	 eax
  00cc8	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend

; 5129 : 			GCTradeOkButtonSend(aIndex, 0);

  00ccd	6a 00		 push	 0
  00ccf	57		 push	 edi
  00cd0	e8 00 00 00 00	 call	 ?GCTradeOkButtonSend@@YAHHE@Z ; GCTradeOkButtonSend
  00cd5	83 c4 10	 add	 esp, 16			; 00000010H
  00cd8	5f		 pop	 edi
  00cd9	5e		 pop	 esi
  00cda	5b		 pop	 ebx

; 5139 : 	}
; 5140 : }

  00cdb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cde	33 cd		 xor	 ecx, ebp
  00ce0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ce5	8b e5		 mov	 esp, ebp
  00ce7	5d		 pop	 ebp
  00ce8	c3		 ret	 0
$LN137@CGInventor:

; 5130 : 		}
; 5131 : 
; 5132 : 		return;
; 5133 : 	}
; 5134 : 
; 5135 : 	if ( lpMsg->sFlag == 0 && lpMsg->tFlag == 1 )

  00ce9	84 c9		 test	 cl, cl
  00ceb	0f 85 05 01 00
	00		 jne	 $LN142@CGInventor
  00cf1	80 7e 11 01	 cmp	 BYTE PTR [esi+17], 1
  00cf5	0f 85 fb 00 00
	00		 jne	 $LN142@CGInventor

; 5136 : 	{
; 5137 : 		result = gObjInventoryTradeMove(lpObj, source, target);

  00cfb	8b b5 e4 fe ff
	ff		 mov	 esi, DWORD PTR _target$1$[ebp]
  00d01	56		 push	 esi
  00d02	ff b5 e0 fe ff
	ff		 push	 DWORD PTR _source$1$[ebp]
  00d08	53		 push	 ebx
  00d09	e8 00 00 00 00	 call	 ?gObjInventoryTradeMove@@YAEPAUOBJECTSTRUCT@@EE@Z ; gObjInventoryTradeMove
  00d0e	88 85 e8 fe ff
	ff		 mov	 BYTE PTR _result$[ebp], al

; 5138 : 		GCItemMoveResultSend(aIndex, result, target, (LPBYTE)&ItemInfo);

  00d14	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00d17	50		 push	 eax
  00d18	56		 push	 esi
  00d19	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _result$[ebp]
  00d1f	e9 36 f5 ff ff	 jmp	 $LN172@CGInventor
$LN58@CGInventor:

; 4897 : 		{
; 4898 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00d24	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00d27	50		 push	 eax
  00d28	6a 00		 push	 0
  00d2a	68 ff 00 00 00	 push	 255			; 000000ffH
  00d2f	57		 push	 edi
  00d30	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4899 : 			LogAdd("[%s][%s] error-L1 : used not Warehouse", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00d35	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d3b	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00d3e	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00d44	50		 push	 eax
  00d45	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00d48	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00d4e	50		 push	 eax
  00d4f	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JCEGNOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5War@

; 4900 : 
; 4901 : 			return;

  00d54	e9 94 00 00 00	 jmp	 $LN151@CGInventor
$LN53@CGInventor:

; 4878 : 		{
; 4879 : 			GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00d59	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00d5c	50		 push	 eax
  00d5d	6a 00		 push	 0
  00d5f	68 ff 00 00 00	 push	 255			; 000000ffH
  00d64	57		 push	 edi
  00d65	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4880 : 			LogAdd("[%s][%s] error-L1 : used not ChaosBox",

  00d6a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d70	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00d73	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00d79	50		 push	 eax
  00d7a	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00d7d	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00d83	50		 push	 eax
  00d84	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BBKNKKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@

; 4881 : 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4882 : 			return;

  00d89	eb 62		 jmp	 SHORT $LN151@CGInventor
$LN28@CGInventor:

; 4774 : 		{
; 4775 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00d8b	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00d8e	50		 push	 eax
  00d8f	6a 00		 push	 0
  00d91	68 ff 00 00 00	 push	 255			; 000000ffH
  00d96	57		 push	 edi
  00d97	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4776 : 			LogAdd("[%s][%s] error-L1 : used not DarkTrainerBox", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00d9c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00da2	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00da5	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00dab	50		 push	 eax
  00dac	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00daf	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00db5	50		 push	 eax
  00db6	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@KBDLDMLI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Dar@

; 4777 : 
; 4778 : 			return;

  00dbb	eb 30		 jmp	 SHORT $LN151@CGInventor
$LN23@CGInventor:

; 4755 : 		{
; 4756 : 			::GCItemMoveResultSend(aIndex, -1, 0, (LPBYTE)&ItemInfo);

  00dbd	8d 45 f0	 lea	 eax, DWORD PTR _ItemInfo$[ebp]
  00dc0	50		 push	 eax
  00dc1	6a 00		 push	 0
  00dc3	68 ff 00 00 00	 push	 255			; 000000ffH
  00dc8	57		 push	 edi
  00dc9	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend

; 4757 : 			LogAdd("[%s][%s] error-L1 : used not Chaosbox", gObj[aIndex].AccountID, gObj[aIndex].Name);

  00dce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00dd4	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00dd7	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00ddd	50		 push	 eax
  00dde	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00de1	03 85 ec fe ff
	ff		 add	 eax, DWORD PTR tv1519[ebp]
  00de7	50		 push	 eax
  00de8	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KBCIHFJL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L1?5?3?5used?5not?5Cha@
$LN151@CGInventor:
  00ded	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00df3	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN142@CGInventor:

; 5139 : 	}
; 5140 : }

  00df6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00df9	5f		 pop	 edi
  00dfa	5e		 pop	 esi
  00dfb	33 cd		 xor	 ecx, ebp
  00dfd	5b		 pop	 ebx
  00dfe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e03	8b e5		 mov	 esp, ebp
  00e05	5d		 pop	 ebp
  00e06	c3		 ret	 0
?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ENDP ; CGInventoryItemMove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCItemMoveResultSend@@YAXHEEQAE@Z
_TEXT	SEGMENT
_pMsg$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_pos$ = 16						; size = 1
_ItemInfo$ = 20						; size = 4
?GCItemMoveResultSend@@YAXHEEQAE@Z PROC			; GCItemMoveResultSend, COMDAT

; 4624 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi

; 4625 : 	PMSG_INVENTORYITEMMOVE_RESULT pMsg;
; 4626 : 
; 4627 : 	pMsg.h.c = 0xC3;
; 4628 : 	pMsg.h.headcode = 0x24;
; 4629 : 	pMsg.h.size = sizeof(pMsg);
; 4630 : 	pMsg.result = result;
; 4631 : 	pMsg.Pos = pos;
; 4632 : 	pMsg.ItemInfo[I_TYPE] = ItemInfo[I_TYPE];

  00012	8b 75 14	 mov	 esi, DWORD PTR _ItemInfo$[ebp]
  00015	8a 7d 10	 mov	 bh, BYTE PTR _pos$[ebp]
  00018	8a 5d 0c	 mov	 bl, BYTE PTR _result$[ebp]
  0001b	57		 push	 edi
  0001c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0001f	88 45 ed	 mov	 BYTE PTR _pMsg$[ebp+5], al

; 4633 : 	pMsg.ItemInfo[I_OPTION] = ItemInfo[I_OPTION];

  00022	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00026	88 45 ee	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 4634 : 	pMsg.ItemInfo[I_DUR] = ItemInfo[I_DUR];

  00029	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  0002d	88 45 ef	 mov	 BYTE PTR _pMsg$[ebp+7], al

; 4635 : 	pMsg.ItemInfo[I_NOPTION] = ItemInfo[I_NOPTION];

  00030	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00034	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+8], al

; 4636 : 
; 4637 : 	pMsg.ItemInfo[I_SOPTION] = ItemInfo[I_SOPTION];

  00037	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  0003b	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+9], al

; 4638 : 	pMsg.ItemInfo[I_380OPTION] = ItemInfo[I_380OPTION];

  0003e	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00042	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00045	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+10], al

; 4639 : 	pMsg.ItemInfo[I_JOHOPTION] = ItemInfo[I_JOHOPTION];

  00048	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  0004c	88 45 f3	 mov	 BYTE PTR _pMsg$[ebp+11], al

; 4640 : 
; 4641 : 	pMsg.ItemInfo[7] = ItemInfo[7];

  0004f	0f b6 46 07	 movzx	 eax, BYTE PTR [esi+7]
  00053	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 4642 : 	pMsg.ItemInfo[8] = ItemInfo[8];

  00056	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  0005a	88 45 f5	 mov	 BYTE PTR _pMsg$[ebp+13], al

; 4643 : 	pMsg.ItemInfo[9] = ItemInfo[9];

  0005d	0f b6 46 09	 movzx	 eax, BYTE PTR [esi+9]
  00061	88 45 f6	 mov	 BYTE PTR _pMsg$[ebp+14], al

; 4644 : 	pMsg.ItemInfo[10] = ItemInfo[10];

  00064	0f b6 46 0a	 movzx	 eax, BYTE PTR [esi+10]
  00068	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+15], al

; 4645 : 	pMsg.ItemInfo[11] = ItemInfo[11];

  0006b	0f b6 46 0b	 movzx	 eax, BYTE PTR [esi+11]
  0006f	88 45 f8	 mov	 BYTE PTR _pMsg$[ebp+16], al

; 4646 : 
; 4647 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  00072	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00075	6a 11		 push	 17			; 00000011H
  00077	50		 push	 eax
  00078	57		 push	 edi
  00079	66 c7 45 e8 c3
	11		 mov	 WORD PTR _pMsg$[ebp], 4547 ; 000011c3H
  0007f	c6 45 ea 24	 mov	 BYTE PTR _pMsg$[ebp+2], 36 ; 00000024H
  00083	88 5d eb	 mov	 BYTE PTR _pMsg$[ebp+3], bl
  00086	88 7d ec	 mov	 BYTE PTR _pMsg$[ebp+4], bh
  00089	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4648 : 
; 4649 : 	if( result != (BYTE)-1 )

  00091	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00094	74 39		 je	 SHORT $LN3@GCItemMove

; 4650 : 	{
; 4651 : 		if( (ItemInfo[I_380OPTION]&2) == 2 && (ItemInfo[I_380OPTION]&4) == 0 )

  00096	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  00099	a8 02		 test	 al, 2
  0009b	74 32		 je	 SHORT $LN3@GCItemMove
  0009d	a8 04		 test	 al, 4
  0009f	75 2e		 jne	 SHORT $LN3@GCItemMove

; 4652 : 		{
; 4653 : 			CItem* lpItem = &gObj[aIndex].pInventory[pos];

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a6	69 cf 40 27 00
	00		 imul	 ecx, edi, 10048
  000ac	0f b6 f7	 movzx	 esi, bh
  000af	69 d6 d4 00 00
	00		 imul	 edx, esi, 212
  000b5	03 94 01 c0 11
	00 00		 add	 edx, DWORD PTR [ecx+eax+4544]

; 4654 : 
; 4655 : 			g_CashShop.GCSendItemInfo(aIndex,lpItem->m_Type,pos,lpItem->m_Number);

  000bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  000c1	ff 32		 push	 DWORD PTR [edx]
  000c3	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  000c7	56		 push	 esi
  000c8	50		 push	 eax
  000c9	57		 push	 edi
  000ca	e8 00 00 00 00	 call	 ?GCSendItemInfo@CCashShop@@QAEXHHHK@Z ; CCashShop::GCSendItemInfo
$LN3@GCItemMove:

; 4656 : 		}
; 4657 : 	}
; 4658 : }

  000cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	33 cd		 xor	 ecx, ebp
  000d6	5b		 pop	 ebx
  000d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
?GCItemMoveResultSend@@YAXHEEQAE@Z ENDP			; GCItemMoveResultSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\snakebegins.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\source\snakebegins.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z
_TEXT	SEGMENT
_NOption$1 = -188					; size = 1
_PetLevel$1$ = -184					; size = 4
_PetExp$1$ = -180					; size = 4
_SocketBonus$2 = -176					; size = 1
_bIsItem$1$ = -172					; size = 4
_lpMsg$GSCopy$1$ = -168					; size = 4
_CopyItem$1$ = -164					; size = 4
_SOption$3 = -160					; size = 1
_btItemEffectEx$4 = -156				; size = 1
_Option1$5 = -152					; size = 1
_Option2$6 = -148					; size = 1
_Option3$7 = -144					; size = 1
tv1866 = -140						; size = 4
_serial$1$ = -136					; size = 4
_type$1$ = -132						; size = 4
_aIndex$GSCopy$1$ = -128				; size = 4
_map$1$ = -124						; size = 4
_ServerCmd$8 = -124					; size = 7
_ServerCmd$9 = -124					; size = 7
_Level$1$ = -116					; size = 4
_dur$1$ = -116						; size = 4
tv489 = -116						; size = 4
_level$1$ = -112					; size = 4
_JOHOption$1$ = -106					; size = 1
_JOHOptionLevel$1$ = -105				; size = 1
_serial2$1$ = -104					; size = 4
tv1116 = -104						; size = 4
tv481 = -104						; size = 4
tv471 = -104						; size = 4
tv455 = -104						; size = 4
tv447 = -104						; size = 4
tv423 = -104						; size = 4
tv407 = -104						; size = 4
tv399 = -104						; size = 4
tv367 = -104						; size = 4
tv353 = -104						; size = 4
tv319 = -104						; size = 4
tv308 = -104						; size = 4
tv277 = -104						; size = 4
tv269 = -104						; size = 4
tv242 = -104						; size = 4
_pResult$ = -100					; size = 5
_pChange$10 = -92					; size = 17
_szItemName$11 = -72					; size = 50
_SocketOptions$12 = -20					; size = 5
_NewOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_drop_type$ = 16					; size = 4
?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z PROC	; CGItemDropRequest, COMDAT

; 4042 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 4043 : 	BOOL CopyItem = FALSE;
; 4044 : 	BYTE NewOption[MAX_EXOPTION_SIZE];
; 4045 : 
; 4046 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001c	56		 push	 esi
  0001d	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  00023	57		 push	 edi
  00024	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  00027	89 bd 58 ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], edi
  0002d	89 5d 80	 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], ebx
  00030	03 c6		 add	 eax, esi
  00032	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _CopyItem$1$[ebp], 0
  0003c	50		 push	 eax
  0003d	89 b5 74 ff ff
	ff		 mov	 DWORD PTR tv1866[ebp], esi
  00043	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00048	83 c4 04	 add	 esp, 4
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 d0 00 00
	00		 je	 $LN133@CGItemDrop

; 4047 : 		return FALSE;
; 4048 : 
; 4049 : 	PMSG_ITEMTHROW_RESULT pResult;
; 4050 : 
; 4051 : 	PHeadSetB((LPBYTE)&pResult, 0x23, sizeof(pResult));

  00053	6a 05		 push	 5
  00055	8d 45 9c	 lea	 eax, DWORD PTR _pResult$[ebp]
  00058	6a 23		 push	 35			; 00000023H
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 4052 : 	pResult.Result = true;
; 4053 : 	pResult.Ipos = lpMsg->Ipos;
; 4054 : 
; 4055 : 	if ( gObj[aIndex].m_IfState.use != 0 )

  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00066	b2 01		 mov	 dl, 1
  00068	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	88 55 9f	 mov	 BYTE PTR _pResult$[ebp+3], dl
  00071	88 45 a0	 mov	 BYTE PTR _pResult$[ebp+4], al
  00074	8b 84 0e b8 11
	00 00		 mov	 eax, DWORD PTR [esi+ecx+4536]
  0007b	a8 03		 test	 al, 3
  0007d	74 10		 je	 SHORT $LN6@CGItemDrop

; 4056 : 	{
; 4057 : 		if ( gObj[aIndex].m_IfState.type != 3 )

  0007f	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00084	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00089	0f 85 94 00 00
	00		 jne	 $LN133@CGItemDrop
$LN6@CGItemDrop:

; 4058 : 		{
; 4059 : 			pResult.Result = false;
; 4060 : 			return FALSE;
; 4061 : 		}
; 4062 : 	}
; 4063 : 
; 4064 : 	if ( gObj[aIndex].CloseType != -1 )

  0008f	0f b6 c2	 movzx	 eax, dl
  00092	33 d2		 xor	 edx, edx
  00094	80 7c 0e 0d ff	 cmp	 BYTE PTR [esi+ecx+13], -1
  00099	0f 45 c2	 cmovne	 eax, edx
  0009c	88 45 9f	 mov	 BYTE PTR _pResult$[ebp+3], al

; 4065 : 		pResult.Result = false;
; 4066 : 
; 4067 : 	if ( gObj[aIndex].m_bMapSvrMoveQuit == true )

  0009f	80 bc 0e 3c 20
	00 00 01	 cmp	 BYTE PTR [esi+ecx+8252], 1
  000a7	75 1e		 jne	 SHORT $LN8@CGItemDrop

; 4068 : 	{
; 4069 : 		LogAddTD("[ANTI-HACK][Item Duplication] - Item Drop during MapServer Move [%s][%s]",

  000a9	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000ac	03 c6		 add	 eax, esi
  000ae	50		 push	 eax
  000af	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000b2	03 c6		 add	 eax, esi
  000b4	50		 push	 eax
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@FINNND@?$FLANTI?9HACK?$FN?$FLItem?5Duplication?$FN?5?9?5@
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4070 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);
; 4071 : 		pResult.Result = false;

  000c3	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN8@CGItemDrop:

; 4072 : 	}
; 4073 : 
; 4074 : 
; 4075 : 	if ( !::gObjFixInventoryPointer(aIndex))

  000c7	53		 push	 ebx
  000c8	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  000cd	83 c4 04	 add	 esp, 4
  000d0	84 c0		 test	 al, al
  000d2	75 18		 jne	 SHORT $LN9@CGItemDrop

; 4076 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  000d4	68 ec 0f 00 00	 push	 4076			; 00000fecH
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@CGItemDrop:

; 4077 : 
; 4078 : 	if ( gObj[aIndex].pTransaction == 1 )

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f1	80 bc 06 cc 11
	00 00 01	 cmp	 BYTE PTR [esi+eax+4556], 1
  000f9	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  000fc	75 38		 jne	 SHORT $LN10@CGItemDrop

; 4079 : 	{
; 4080 : 		LogAddTD("[%s][%s] CGItemDropRequest() Failed : Transaction == 1, IF_TYPE : %d",

  000fe	8b 83 b8 11 00
	00		 mov	 eax, DWORD PTR [ebx+4536]
  00104	c1 e8 06	 shr	 eax, 6
  00107	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0010c	50		 push	 eax
  0010d	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00110	50		 push	 eax
  00111	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00114	50		 push	 eax
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@ILLBNEEI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemDropRequest?$CI?$CJ?5Fai@
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00120	83 c4 10	 add	 esp, 16			; 00000010H
$LN133@CGItemDrop:

; 4081 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);
; 4082 : 		pResult.Result = false;
; 4083 : 		
; 4084 : 		return false;

  00123	33 c0		 xor	 eax, eax

; 4605 : }

  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	5b		 pop	 ebx
  00128	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012b	33 cd		 xor	 ecx, ebp
  0012d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c3		 ret	 0
$LN10@CGItemDrop:

; 4085 : 	}
; 4086 : 
; 4087 : 	LPOBJ lpObj = &gObj[aIndex];
; 4088 : 
; 4089 : 	if ( lpMsg->Ipos == 0xFF )	// Null Position

  00136	80 7f 05 ff	 cmp	 BYTE PTR [edi+5], 255	; 000000ffH
  0013a	75 1c		 jne	 SHORT $LN125@CGItemDrop

; 4090 : 	{
; 4091 : 		LogAdd("error:%s %d", __FILE__, __LINE__);

  0013c	68 fb 0f 00 00	 push	 4091			; 00000ffbH
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HHKDDFJH@error?3?$CFs?5?$CFd?$AA@
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4092 : 		pResult.Result = false;

  00154	32 c0		 xor	 al, al
  00156	eb 03		 jmp	 SHORT $LN11@CGItemDrop
$LN125@CGItemDrop:
  00158	8a 45 9f	 mov	 al, BYTE PTR _pResult$[ebp+3]
$LN11@CGItemDrop:

; 4093 : 	}
; 4094 : 
; 4095 : 	if ( lpMsg->Ipos < 0 || lpMsg->Ipos > MAIN_INVENTORY_SIZE-1)	// Out of Bounds

  0015b	33 c9		 xor	 ecx, ecx
  0015d	0f b6 c0	 movzx	 eax, al
  00160	80 7f 05 cb	 cmp	 BYTE PTR [edi+5], 203	; 000000cbH

; 4096 : 		pResult.Result = false;
; 4097 : 
; 4098 : 	if (!::gObjCanItemTouch(lpObj, 0))

  00164	51		 push	 ecx
  00165	0f 47 c1	 cmova	 eax, ecx
  00168	53		 push	 ebx
  00169	88 45 9f	 mov	 BYTE PTR _pResult$[ebp+3], al
  0016c	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCanItemTouch

; 4099 : 		pResult.Result = false;
; 4100 : 
; 4101 : 	// Icarus Preventions about Dinorant
; 4102 : 	if ( gObj[aIndex].MapNumber == MAP_INDEX_ICARUS)

  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00177	83 c4 08	 add	 esp, 8
  0017a	8b d0		 mov	 edx, eax
  0017c	f7 da		 neg	 edx
  0017e	1a d2		 sbb	 dl, dl
  00180	22 55 9f	 and	 dl, BYTE PTR _pResult$[ebp+3]
  00183	88 55 9f	 mov	 BYTE PTR _pResult$[ebp+3], dl
  00186	80 bc 0e 23 01
	00 00 0a	 cmp	 BYTE PTR [esi+ecx+291], 10 ; 0000000aH
  0018e	75 56		 jne	 SHORT $LN21@CGItemDrop

; 4103 : 	{
; 4104 : 		if ( lpMsg->Ipos == 8 )

  00190	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  00193	3c 08		 cmp	 al, 8
  00195	75 2c		 jne	 SHORT $LN16@CGItemDrop

; 4105 : 		{
; 4106 : 			if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,3) ) // Dinorant

  00197	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  0019d	b8 03 1a 00 00	 mov	 eax, 6659		; 00001a03H
  001a2	66 39 81 a6 06
	00 00		 cmp	 WORD PTR [ecx+1702], ax
  001a9	75 3b		 jne	 SHORT $LN21@CGItemDrop

; 4107 : 			{
; 4108 : 				if( lpObj->pInventory[7].IsItem() == FALSE )

  001ab	81 c1 cc 05 00
	00		 add	 ecx, 1484		; 000005ccH
  001b1	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001b6	85 c0		 test	 eax, eax
  001b8	75 04		 jne	 SHORT $LN126@CGItemDrop

; 4109 : 				{
; 4110 : 					pResult.Result = false;

  001ba	32 d2		 xor	 dl, dl

; 4111 : 				}
; 4112 : 			}
; 4113 : 		}

  001bc	eb 25		 jmp	 SHORT $LN131@CGItemDrop
$LN126@CGItemDrop:

; 4115 : 		{
; 4116 : 			if ( lpObj->pInventory[8].m_Type != ITEMGET(13,3) ) // Dinorant 

  001be	8a 55 9f	 mov	 dl, BYTE PTR _pResult$[ebp+3]
  001c1	eb 23		 jmp	 SHORT $LN21@CGItemDrop
$LN16@CGItemDrop:

; 4114 : 		else if ( lpMsg->Ipos == 7 )

  001c3	3c 07		 cmp	 al, 7
  001c5	75 1f		 jne	 SHORT $LN21@CGItemDrop

; 4115 : 		{
; 4116 : 			if ( lpObj->pInventory[8].m_Type != ITEMGET(13,3) ) // Dinorant 

  001c7	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  001cd	be 03 1a 00 00	 mov	 esi, 6659		; 00001a03H
  001d2	0f b6 ca	 movzx	 ecx, dl
  001d5	33 d2		 xor	 edx, edx
  001d7	66 39 b0 a6 06
	00 00		 cmp	 WORD PTR [eax+1702], si
  001de	0f 45 ca	 cmovne	 ecx, edx
  001e1	8a d1		 mov	 dl, cl
$LN131@CGItemDrop:
  001e3	88 55 9f	 mov	 BYTE PTR _pResult$[ebp+3], dl
$LN21@CGItemDrop:

; 4117 : 			{
; 4118 : 				pResult.Result = false;
; 4119 : 			}
; 4120 : 		}
; 4121 : 	}
; 4122 : 
; 4123 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,30) ||
; 4124 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,31) ||
; 4125 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,36) ||

  001e6	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  001ea	b9 1e 18 00 00	 mov	 ecx, 6174		; 0000181eH
  001ef	69 f0 d4 00 00
	00		 imul	 esi, eax, 212
  001f5	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  001fb	0f b7 44 06 06	 movzx	 eax, WORD PTR [esi+eax+6]
  00200	66 3b c1	 cmp	 ax, cx
  00203	74 1e		 je	 SHORT $LN23@CGItemDrop
  00205	b9 1f 18 00 00	 mov	 ecx, 6175		; 0000181fH
  0020a	66 3b c1	 cmp	 ax, cx
  0020d	74 14		 je	 SHORT $LN23@CGItemDrop
  0020f	b9 24 1a 00 00	 mov	 ecx, 6692		; 00001a24H
  00214	66 3b c1	 cmp	 ax, cx
  00217	74 0a		 je	 SHORT $LN23@CGItemDrop
  00219	b9 25 1a 00 00	 mov	 ecx, 6693		; 00001a25H
  0021e	66 3b c1	 cmp	 ax, cx
  00221	75 05		 jne	 SHORT $LN22@CGItemDrop
$LN23@CGItemDrop:

; 4126 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,37) )
; 4127 : 	{
; 4128 : 		pResult.Result = false;

  00223	32 d2		 xor	 dl, dl
  00225	88 55 9f	 mov	 BYTE PTR _pResult$[ebp+3], dl
$LN22@CGItemDrop:

; 4129 : 	}
; 4130 : 
; 4131 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,42) )

  00228	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0022e	0f b6 ca	 movzx	 ecx, dl
  00231	ba 2a 1a 00 00	 mov	 edx, 6698		; 00001a2aH
  00236	66 39 54 06 06	 cmp	 WORD PTR [esi+eax+6], dx
  0023b	ba 00 00 00 00	 mov	 edx, 0
  00240	0f 44 ca	 cmove	 ecx, edx
  00243	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl

; 4132 : 	{
; 4133 : 		pResult.Result = false;
; 4134 : 	}
; 4135 : 
; 4136 : 	if ( IT_MAP_RANGE( lpObj->MapNumber ) )

  00246	8a 83 23 01 00
	00		 mov	 al, BYTE PTR [ebx+291]
  0024c	3c 2d		 cmp	 al, 45			; 0000002dH
  0024e	72 29		 jb	 SHORT $LN26@CGItemDrop
  00250	b2 32		 mov	 dl, 50			; 00000032H
  00252	3a d0		 cmp	 dl, al
  00254	1b c0		 sbb	 eax, eax
  00256	83 c0 01	 add	 eax, 1
  00259	74 1e		 je	 SHORT $LN26@CGItemDrop

; 4137 : 	{
; 4138 : 		if( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,51) )

  0025b	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00261	ba 33 1a 00 00	 mov	 edx, 6707		; 00001a33H
  00266	0f b6 c9	 movzx	 ecx, cl
  00269	66 39 54 06 06	 cmp	 WORD PTR [esi+eax+6], dx
  0026e	ba 00 00 00 00	 mov	 edx, 0
  00273	0f 44 ca	 cmove	 ecx, edx
  00276	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl
$LN26@CGItemDrop:

; 4139 : 		{
; 4140 : 			pResult.Result = false;
; 4141 : 		}
; 4142 : 	}
; 4143 : 
; 4144 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,64) )

  00279	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0027f	ba 40 1c 00 00	 mov	 edx, 7232		; 00001c40H
  00284	0f b6 c9	 movzx	 ecx, cl
  00287	66 39 54 06 06	 cmp	 WORD PTR [esi+eax+6], dx
  0028c	ba 00 00 00 00	 mov	 edx, 0
  00291	0f 44 ca	 cmove	 ecx, edx

; 4145 : 	{
; 4146 : 		pResult.Result = false;
; 4147 : 	}
; 4148 : 
; 4149 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,36) &&

  00294	ba 24 18 00 00	 mov	 edx, 6180		; 00001824H
  00299	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl
  0029c	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  002a2	0f b7 44 06 06	 movzx	 eax, WORD PTR [esi+eax+6]
  002a7	66 3b c2	 cmp	 ax, dx
  002aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gPkLimitFree@@3HA ; gPkLimitFree
  002b0	7c 1c		 jl	 SHORT $LN29@CGItemDrop
  002b2	c7 45 98 28 18
	00 00		 mov	 DWORD PTR tv242[ebp], 6184 ; 00001828H
  002b9	66 3b 45 98	 cmp	 ax, WORD PTR tv242[ebp]
  002bd	7f 0f		 jg	 SHORT $LN29@CGItemDrop

; 4150 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,40) )
; 4151 : 	{
; 4152 : 		if ( gPkLimitFree == FALSE )

  002bf	0f b6 c1	 movzx	 eax, cl
  002c2	33 c9		 xor	 ecx, ecx
  002c4	85 d2		 test	 edx, edx
  002c6	0f 44 c1	 cmove	 eax, ecx
  002c9	8a c8		 mov	 cl, al
  002cb	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl
$LN29@CGItemDrop:

; 4153 : 		{
; 4154 : 			pResult.Result = false;
; 4155 : 		}
; 4156 : 	}
; 4157 : 
; 4158 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,49) ||

  002ce	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  002d4	c7 45 98 31 18
	00 00		 mov	 DWORD PTR tv269[ebp], 6193 ; 00001831H
  002db	0f b7 44 06 06	 movzx	 eax, WORD PTR [esi+eax+6]
  002e0	66 3b 45 98	 cmp	 ax, WORD PTR tv269[ebp]
  002e4	74 0d		 je	 SHORT $LN31@CGItemDrop
  002e6	c7 45 98 32 18
	00 00		 mov	 DWORD PTR tv277[ebp], 6194 ; 00001832H
  002ed	66 3b 45 98	 cmp	 ax, WORD PTR tv277[ebp]
  002f1	75 0f		 jne	 SHORT $LN32@CGItemDrop
$LN31@CGItemDrop:

; 4159 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,50) )
; 4160 : 	{
; 4161 : 		if ( gPkLimitFree == FALSE )

  002f3	0f b6 c1	 movzx	 eax, cl
  002f6	33 c9		 xor	 ecx, ecx
  002f8	85 d2		 test	 edx, edx
  002fa	0f 44 c1	 cmove	 eax, ecx
  002fd	8a c8		 mov	 cl, al
  002ff	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl
$LN32@CGItemDrop:

; 4162 : 		{
; 4163 : 			pResult.Result = false;
; 4164 : 		}
; 4165 : 	}
; 4166 : 
; 4167 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,130) &&

  00302	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00308	c7 45 98 82 18
	00 00		 mov	 DWORD PTR tv308[ebp], 6274 ; 00001882H
  0030f	0f b7 44 06 06	 movzx	 eax, WORD PTR [esi+eax+6]
  00314	66 3b 45 98	 cmp	 ax, WORD PTR tv308[ebp]
  00318	7c 1c		 jl	 SHORT $LN34@CGItemDrop
  0031a	c7 45 98 87 18
	00 00		 mov	 DWORD PTR tv319[ebp], 6279 ; 00001887H
  00321	66 3b 45 98	 cmp	 ax, WORD PTR tv319[ebp]
  00325	7f 0f		 jg	 SHORT $LN34@CGItemDrop

; 4168 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,135) )
; 4169 : 	{
; 4170 : 		if ( gPkLimitFree == FALSE )

  00327	0f b6 c1	 movzx	 eax, cl
  0032a	33 c9		 xor	 ecx, ecx
  0032c	85 d2		 test	 edx, edx
  0032e	0f 44 c1	 cmove	 eax, ecx
  00331	8a c8		 mov	 cl, al
  00333	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl
$LN34@CGItemDrop:

; 4171 : 		{
; 4172 : 			pResult.Result = false;
; 4173 : 		}
; 4174 : 	}
; 4175 : 
; 4176 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,262) &&

  00336	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0033c	c7 45 98 06 19
	00 00		 mov	 DWORD PTR tv353[ebp], 6406 ; 00001906H
  00343	0f b7 44 06 06	 movzx	 eax, WORD PTR [esi+eax+6]
  00348	66 3b 45 98	 cmp	 ax, WORD PTR tv353[ebp]
  0034c	7c 1c		 jl	 SHORT $LN36@CGItemDrop
  0034e	c7 45 98 0b 19
	00 00		 mov	 DWORD PTR tv367[ebp], 6411 ; 0000190bH
  00355	66 3b 45 98	 cmp	 ax, WORD PTR tv367[ebp]
  00359	7f 0f		 jg	 SHORT $LN36@CGItemDrop

; 4177 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,267) )
; 4178 : 	{
; 4179 : 		if ( gPkLimitFree == FALSE )

  0035b	0f b6 c1	 movzx	 eax, cl
  0035e	33 c9		 xor	 ecx, ecx
  00360	85 d2		 test	 edx, edx
  00362	0f 44 c1	 cmove	 eax, ecx
  00365	8a c8		 mov	 cl, al
  00367	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl
$LN36@CGItemDrop:

; 4180 : 		{
; 4181 : 			pResult.Result = false;
; 4182 : 		}
; 4183 : 	}
; 4184 : 
; 4185 : 
; 4186 : #if (CUSTOM_WINGS == 1)
; 4187 : 
; 4188 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,440) &&
; 4189 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,445) )
; 4190 : 	{
; 4191 : 		if ( gPkLimitFree == FALSE )
; 4192 : 		{
; 4193 : 			pResult.Result = false;
; 4194 : 		}
; 4195 : 	}
; 4196 : 
; 4197 : #endif
; 4198 : 
; 4199 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,52) ||

  0036a	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00370	c7 45 98 34 1a
	00 00		 mov	 DWORD PTR tv399[ebp], 6708 ; 00001a34H
  00377	0f b7 44 06 06	 movzx	 eax, WORD PTR [esi+eax+6]
  0037c	66 3b 45 98	 cmp	 ax, WORD PTR tv399[ebp]
  00380	74 0d		 je	 SHORT $LN38@CGItemDrop
  00382	c7 45 98 35 1a
	00 00		 mov	 DWORD PTR tv407[ebp], 6709 ; 00001a35H
  00389	66 3b 45 98	 cmp	 ax, WORD PTR tv407[ebp]
  0038d	75 05		 jne	 SHORT $LN37@CGItemDrop
$LN38@CGItemDrop:

; 4200 : 		 lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,53) )
; 4201 : 	{
; 4202 : 		pResult.Result = false;

  0038f	32 c9		 xor	 cl, cl
  00391	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl
$LN37@CGItemDrop:

; 4203 : 	}
; 4204 : 
; 4205 : 	if (	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,13) 
; 4206 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,14) 
; 4207 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,16)
; 4208 : 		||	(lpObj->pInventory[lpMsg->Ipos].m_Type >= ITEMGET(12,0) && lpObj->pInventory[lpMsg->Ipos].m_Type <= ITEMGET(12,6)) 
; 4209 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,15) 
; 4210 : 		||	(lpObj->pInventory[lpMsg->Ipos].m_Level >= 7  && lpObj->pInventory[lpMsg->Ipos].m_Type < ITEMGET(12,0)) 
; 4211 : 		||	lpObj->pInventory[lpMsg->Ipos].IsSetItem() != FALSE 
; 4212 : 		||	lpObj->pInventory[lpMsg->Ipos].IsExtItem() != FALSE
; 4213 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,14)
; 4214 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,19)
; 4215 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,15) 
; 4216 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,34) 
; 4217 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,31)
; 4218 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,41)
; 4219 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,42)
; 4220 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,43) 
; 4221 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(14,44) 
; 4222 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,41)
; 4223 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,42)
; 4224 : 		||	lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(12,43) )

  00394	03 b3 c0 11 00
	00		 add	 esi, DWORD PTR [ebx+4544]
  0039a	c7 45 98 0d 1c
	00 00		 mov	 DWORD PTR tv423[ebp], 7181 ; 00001c0dH
  003a1	0f b7 46 06	 movzx	 eax, WORD PTR [esi+6]
  003a5	66 3b 45 98	 cmp	 ax, WORD PTR tv423[ebp]
  003a9	0f 84 24 01 00
	00		 je	 $LN40@CGItemDrop
  003af	c7 45 98 0e 1c
	00 00		 mov	 DWORD PTR tv447[ebp], 7182 ; 00001c0eH
  003b6	66 3b 45 98	 cmp	 ax, WORD PTR tv447[ebp]
  003ba	0f 84 13 01 00
	00		 je	 $LN40@CGItemDrop
  003c0	c7 45 98 10 1c
	00 00		 mov	 DWORD PTR tv455[ebp], 7184 ; 00001c10H
  003c7	66 3b 45 98	 cmp	 ax, WORD PTR tv455[ebp]
  003cb	0f 84 02 01 00
	00		 je	 $LN40@CGItemDrop
  003d1	c7 45 8c 00 18
	00 00		 mov	 DWORD PTR tv489[ebp], 6144 ; 00001800H
  003d8	66 3b 45 8c	 cmp	 ax, WORD PTR tv489[ebp]
  003dc	7c 11		 jl	 SHORT $LN41@CGItemDrop
  003de	c7 45 98 06 18
	00 00		 mov	 DWORD PTR tv471[ebp], 6150 ; 00001806H
  003e5	66 3b 45 98	 cmp	 ax, WORD PTR tv471[ebp]
  003e9	0f 8e e4 00 00
	00		 jle	 $LN40@CGItemDrop
$LN41@CGItemDrop:
  003ef	c7 45 98 0f 18
	00 00		 mov	 DWORD PTR tv481[ebp], 6159 ; 0000180fH
  003f6	66 3b 45 98	 cmp	 ax, WORD PTR tv481[ebp]
  003fa	0f 84 d3 00 00
	00		 je	 $LN40@CGItemDrop
  00400	66 83 7e 08 07	 cmp	 WORD PTR [esi+8], 7
  00405	7c 0a		 jl	 SHORT $LN42@CGItemDrop
  00407	66 3b 45 8c	 cmp	 ax, WORD PTR tv489[ebp]
  0040b	0f 8c c2 00 00
	00		 jl	 $LN40@CGItemDrop
$LN42@CGItemDrop:
  00411	8b ce		 mov	 ecx, esi
  00413	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00418	85 c0		 test	 eax, eax
  0041a	0f 85 aa 00 00
	00		 jne	 $LN127@CGItemDrop
  00420	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00424	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0042a	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  00430	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00435	85 c0		 test	 eax, eax
  00437	0f 85 8d 00 00
	00		 jne	 $LN127@CGItemDrop
  0043d	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00441	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00447	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0044d	0f b7 44 01 06	 movzx	 eax, WORD PTR [ecx+eax+6]
  00452	b9 0e 1a 00 00	 mov	 ecx, 6670		; 00001a0eH
  00457	66 3b c1	 cmp	 ax, cx
  0045a	74 6e		 je	 SHORT $LN127@CGItemDrop
  0045c	b9 13 1a 00 00	 mov	 ecx, 6675		; 00001a13H
  00461	66 3b c1	 cmp	 ax, cx
  00464	74 64		 je	 SHORT $LN127@CGItemDrop
  00466	b9 0f 1a 00 00	 mov	 ecx, 6671		; 00001a0fH
  0046b	66 3b c1	 cmp	 ax, cx
  0046e	74 5a		 je	 SHORT $LN127@CGItemDrop
  00470	b9 22 1a 00 00	 mov	 ecx, 6690		; 00001a22H
  00475	66 3b c1	 cmp	 ax, cx
  00478	74 50		 je	 SHORT $LN127@CGItemDrop
  0047a	b9 1f 1c 00 00	 mov	 ecx, 7199		; 00001c1fH
  0047f	66 3b c1	 cmp	 ax, cx
  00482	74 46		 je	 SHORT $LN127@CGItemDrop
  00484	b9 29 1c 00 00	 mov	 ecx, 7209		; 00001c29H
  00489	66 3b c1	 cmp	 ax, cx
  0048c	74 3c		 je	 SHORT $LN127@CGItemDrop
  0048e	b9 2a 1c 00 00	 mov	 ecx, 7210		; 00001c2aH
  00493	66 3b c1	 cmp	 ax, cx
  00496	74 32		 je	 SHORT $LN127@CGItemDrop
  00498	b9 2b 1c 00 00	 mov	 ecx, 7211		; 00001c2bH
  0049d	66 3b c1	 cmp	 ax, cx
  004a0	74 28		 je	 SHORT $LN127@CGItemDrop
  004a2	b9 2c 1c 00 00	 mov	 ecx, 7212		; 00001c2cH
  004a7	66 3b c1	 cmp	 ax, cx
  004aa	74 1e		 je	 SHORT $LN127@CGItemDrop
  004ac	b9 29 18 00 00	 mov	 ecx, 6185		; 00001829H
  004b1	66 3b c1	 cmp	 ax, cx
  004b4	74 14		 je	 SHORT $LN127@CGItemDrop
  004b6	b9 2a 18 00 00	 mov	 ecx, 6186		; 0000182aH
  004bb	66 3b c1	 cmp	 ax, cx
  004be	74 0a		 je	 SHORT $LN127@CGItemDrop
  004c0	b9 2b 18 00 00	 mov	 ecx, 6187		; 0000182bH
  004c5	66 3b c1	 cmp	 ax, cx
  004c8	75 16		 jne	 SHORT $LN43@CGItemDrop
$LN127@CGItemDrop:
  004ca	8a 4d 9f	 mov	 cl, BYTE PTR _pResult$[ebp+3]
  004cd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gPkLimitFree@@3HA ; gPkLimitFree
$LN40@CGItemDrop:

; 4225 : 	{
; 4226 : 		if ( gPkLimitFree == FALSE )

  004d3	0f b6 c1	 movzx	 eax, cl
  004d6	33 c9		 xor	 ecx, ecx
  004d8	85 d2		 test	 edx, edx
  004da	0f 44 c1	 cmove	 eax, ecx
  004dd	88 45 9f	 mov	 BYTE PTR _pResult$[ebp+3], al
$LN43@CGItemDrop:

; 4227 : 		{
; 4228 : 			pResult.Result = false;
; 4229 : 		}
; 4230 : 	}
; 4231 : 
; 4232 : 	if ( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony(&lpObj->pInventory[lpMsg->Ipos]) == TRUE )

  004e0	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  004e4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  004e9	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  004ef	03 83 c0 11 00
	00		 add	 eax, DWORD PTR [ebx+4544]
  004f5	50		 push	 eax
  004f6	e8 00 00 00 00	 call	 ?IsStrengthenByJewelOfHarmony@CJewelOfHarmonySystem@@QAEHPAVCItem@@@Z ; CJewelOfHarmonySystem::IsStrengthenByJewelOfHarmony
  004fb	83 f8 01	 cmp	 eax, 1
  004fe	75 1f		 jne	 SHORT $LN44@CGItemDrop

; 4233 : 	{
; 4234 : 		pResult.Result = false;
; 4235 : 		GCServerMsgStringSend(lMsg.Get(MSGGET(13, 43)), lpObj->m_Index, 1);

  00500	50		 push	 eax
  00501	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  00505	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0050a	ff 33		 push	 DWORD PTR [ebx]
  0050c	68 2b 0d 00 00	 push	 3371			; 00000d2bH
  00511	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00516	50		 push	 eax
  00517	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0051c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN44@CGItemDrop:

; 4236 : 	}
; 4237 : 
; 4238 : 	if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyOriginal(lpObj->pInventory[lpMsg->Ipos].m_Type) ||
; 4239 : 		 g_kJewelOfHarmonySystem.IsJewelOfHarmonyPurity(lpObj->pInventory[lpMsg->Ipos].m_Type)   ||

  0051f	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00523	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00529	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0052f	0f b7 44 01 06	 movzx	 eax, WORD PTR [ecx+eax+6]
  00534	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00539	50		 push	 eax
  0053a	e8 00 00 00 00	 call	 ?IsJewelOfHarmonyOriginal@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonyOriginal
  0053f	85 c0		 test	 eax, eax
  00541	75 4d		 jne	 SHORT $LN46@CGItemDrop
  00543	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00547	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  0054d	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00553	0f b7 44 01 06	 movzx	 eax, WORD PTR [ecx+eax+6]
  00558	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0055d	50		 push	 eax
  0055e	e8 00 00 00 00	 call	 ?IsJewelOfHarmonyPurity@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonyPurity
  00563	85 c0		 test	 eax, eax
  00565	75 29		 jne	 SHORT $LN46@CGItemDrop
  00567	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0056b	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00571	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00577	0f b7 44 01 06	 movzx	 eax, WORD PTR [ecx+eax+6]
  0057c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00581	50		 push	 eax
  00582	e8 00 00 00 00	 call	 ?IsJewelOfHarmonySmeltingItems@CJewelOfHarmonySystem@@QAEHF@Z ; CJewelOfHarmonySystem::IsJewelOfHarmonySmeltingItems
  00587	85 c0		 test	 eax, eax
  00589	75 05		 jne	 SHORT $LN46@CGItemDrop

; 4240 : 		 g_kJewelOfHarmonySystem.IsJewelOfHarmonySmeltingItems(lpObj->pInventory[lpMsg->Ipos].m_Type) )
; 4241 : 	{
; 4242 : 		pResult.Result = false;

  0058b	8a 4d 9f	 mov	 cl, BYTE PTR _pResult$[ebp+3]
  0058e	eb 05		 jmp	 SHORT $LN45@CGItemDrop
$LN46@CGItemDrop:
  00590	32 c9		 xor	 cl, cl
  00592	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl
$LN45@CGItemDrop:

; 4243 : 	}
; 4244 : 
; 4245 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_Type == ITEMGET(13,39) )

  00595	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00599	be 27 1a 00 00	 mov	 esi, 6695		; 00001a27H
  0059e	69 d0 d4 00 00
	00		 imul	 edx, eax, 212
  005a4	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  005aa	0f b6 c9	 movzx	 ecx, cl
  005ad	66 39 74 02 06	 cmp	 WORD PTR [edx+eax+6], si
  005b2	be 00 00 00 00	 mov	 esi, 0
  005b7	0f 44 ce	 cmove	 ecx, esi
  005ba	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl

; 4246 : 	{
; 4247 : 		pResult.Result = false;
; 4248 : 	}
; 4249 : 
; 4250 : 	if ( IsCashItem(lpObj->pInventory[lpMsg->Ipos].m_Type) == TRUE )

  005bd	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  005c3	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  005c8	50		 push	 eax
  005c9	e8 00 00 00 00	 call	 ?IsCashItem@@YAHH@Z	; IsCashItem
  005ce	48		 dec	 eax
  005cf	f7 d8		 neg	 eax
  005d1	1a c0		 sbb	 al, al
  005d3	20 45 9f	 and	 BYTE PTR _pResult$[ebp+3], al

; 4251 : 	{
; 4252 : 		pResult.Result = false;
; 4253 : 	}
; 4254 : 
; 4255 : 	if ( IsCashSpecialItem(lpObj->pInventory[lpMsg->Ipos].m_Type) == TRUE )

  005d6	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  005da	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  005e0	69 c0 d4 00 00
	00		 imul	 eax, eax, 212
  005e6	0f bf 44 08 06	 movsx	 eax, WORD PTR [eax+ecx+6]
  005eb	50		 push	 eax
  005ec	e8 00 00 00 00	 call	 ?IsCashSpecialItem@@YAHH@Z ; IsCashSpecialItem

; 4256 : 	{
; 4257 : 		pResult.Result = false;
; 4258 : 	}
; 4259 : 
; 4260 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_bLOCKED )

  005f1	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  005f5	48		 dec	 eax
  005f6	83 c4 08	 add	 esp, 8
  005f9	f7 d8		 neg	 eax
  005fb	1a c0		 sbb	 al, al
  005fd	69 d1 d4 00 00
	00		 imul	 edx, ecx, 212
  00603	22 45 9f	 and	 al, BYTE PTR _pResult$[ebp+3]
  00606	88 45 9f	 mov	 BYTE PTR _pResult$[ebp+3], al
  00609	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  0060f	0f b6 c0	 movzx	 eax, al
  00612	80 bc 0a d1 00
	00 00 00	 cmp	 BYTE PTR [edx+ecx+209], 0

; 4261 : 	{
; 4262 : 		pResult.Result = false;
; 4263 : 	}
; 4264 : 
; 4265 : 	if ( g_ElementalSystem.IsElementalItem(lpObj->pInventory[lpMsg->Ipos].m_Type) )

  0061a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  0061f	0f 45 c6	 cmovne	 eax, esi
  00622	88 45 9f	 mov	 BYTE PTR _pResult$[ebp+3], al
  00625	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  0062b	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00630	50		 push	 eax
  00631	e8 00 00 00 00	 call	 ?IsElementalItem@CElementalSystem@@QAEHH@Z ; CElementalSystem::IsElementalItem
  00636	0f b6 4d 9f	 movzx	 ecx, BYTE PTR _pResult$[ebp+3]
  0063a	33 d2		 xor	 edx, edx
  0063c	85 c0		 test	 eax, eax

; 4266 : 	{
; 4267 : 		pResult.Result = false;
; 4268 : 	}
; 4269 : 
; 4270 : 	if ( lpObj->pInventory[lpMsg->Ipos].m_QuestItem != FALSE )

  0063e	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00642	0f 45 ca	 cmovne	 ecx, edx
  00645	88 4d 9f	 mov	 BYTE PTR _pResult$[ebp+3], cl
  00648	8b b3 c0 11 00
	00		 mov	 esi, DWORD PTR [ebx+4544]
  0064e	89 4d 98	 mov	 DWORD PTR tv1116[ebp], ecx
  00651	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00657	03 f1		 add	 esi, ecx
  00659	38 96 a9 00 00
	00		 cmp	 BYTE PTR [esi+169], dl
  0065f	74 16		 je	 SHORT $LN52@CGItemDrop

; 4271 : 	{
; 4272 : 		return 0xFF;

  00661	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH

; 4605 : }

  00666	5f		 pop	 edi
  00667	5e		 pop	 esi
  00668	5b		 pop	 ebx
  00669	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0066c	33 cd		 xor	 ecx, ebp
  0066e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00673	8b e5		 mov	 esp, ebp
  00675	5d		 pop	 ebp
  00676	c3		 ret	 0
$LN52@CGItemDrop:

; 4273 : 	}
; 4274 : 
; 4275 : #if (ENABLETEST_NEWPVP == 1)
; 4276 : 	// portal?
; 4277 : 	if (drop_type == 0 && lpObj->pInventory[lpMsg->Ipos].m_Type == (512 * 14) + 28 && g_NewPVP.IsDuel(*lpObj)) {

  00677	39 55 10	 cmp	 DWORD PTR _drop_type$[ebp], edx
  0067a	75 1e		 jne	 SHORT $LN53@CGItemDrop
  0067c	b8 1c 1c 00 00	 mov	 eax, 7196		; 00001c1cH
  00681	66 39 46 06	 cmp	 WORD PTR [esi+6], ax
  00685	75 13		 jne	 SHORT $LN53@CGItemDrop
  00687	53		 push	 ebx
  00688	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0068d	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  00692	85 c0		 test	 eax, eax
  00694	0f 85 fe 01 00
	00		 jne	 $LN134@CGItemDrop
$LN53@CGItemDrop:

; 4278 : 		pResult.Result = 0x00;
; 4279 : 	}
; 4280 : #endif
; 4281 : 
; 4282 : 	if ( pResult.Result == 1 )

  0069a	80 7d 98 01	 cmp	 BYTE PTR tv1116[ebp], 1
  0069e	0f 85 f8 01 00
	00		 jne	 $LN129@CGItemDrop

; 4283 : 	{
; 4284 : 		::ItemIsBufExOption(NewOption, &lpObj->pInventory[lpMsg->Ipos]);

  006a4	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$[ebp]
  006a7	56		 push	 esi
  006a8	50		 push	 eax
  006a9	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 4285 : 
; 4286 : 		int map = lpObj->MapNumber;

  006ae	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  006b5	83 c4 08	 add	 esp, 8
  006b8	89 45 84	 mov	 DWORD PTR _map$1$[ebp], eax

; 4287 : 		int type = lpObj->pInventory[lpMsg->Ipos].m_Type;

  006bb	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  006bf	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  006c5	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  006cb	0f bf 41 06	 movsx	 eax, WORD PTR [ecx+6]

; 4288 : 		int level = lpObj->pInventory[lpMsg->Ipos].m_Level;
; 4289 : 		float dur = lpObj->pInventory[lpMsg->Ipos].m_Durability;

  006cf	f3 0f 10 41 24	 movss	 xmm0, DWORD PTR [ecx+36]
  006d4	89 85 7c ff ff
	ff		 mov	 DWORD PTR _type$1$[ebp], eax
  006da	0f bf 41 08	 movsx	 eax, WORD PTR [ecx+8]
  006de	89 45 90	 mov	 DWORD PTR _level$1$[ebp], eax
  006e1	f3 0f 11 45 8c	 movss	 DWORD PTR _dur$1$[ebp], xmm0

; 4290 : 		BOOL bIsItem = lpObj->pInventory[lpMsg->Ipos].IsItem();

  006e6	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem

; 4291 : 		BYTE Option1 = lpObj->pInventory[lpMsg->Ipos].m_Option1;

  006eb	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  006ef	69 d1 d4 00 00
	00		 imul	 edx, ecx, 212
  006f5	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  006fb	03 ca		 add	 ecx, edx
  006fd	89 85 54 ff ff
	ff		 mov	 DWORD PTR _bIsItem$1$[ebp], eax
  00703	8a 81 90 00 00
	00		 mov	 al, BYTE PTR [ecx+144]
  00709	88 85 68 ff ff
	ff		 mov	 BYTE PTR _Option1$5[ebp], al

; 4292 : 		BYTE Option2 = lpObj->pInventory[lpMsg->Ipos].m_Option2;

  0070f	8a 81 91 00 00
	00		 mov	 al, BYTE PTR [ecx+145]
  00715	88 85 6c ff ff
	ff		 mov	 BYTE PTR _Option2$6[ebp], al

; 4293 : 		BYTE Option3 = lpObj->pInventory[lpMsg->Ipos].m_Option3;

  0071b	8a 81 92 00 00
	00		 mov	 al, BYTE PTR [ecx+146]
  00721	88 85 70 ff ff
	ff		 mov	 BYTE PTR _Option3$7[ebp], al

; 4294 : 		BYTE NOption = lpObj->pInventory[lpMsg->Ipos].m_NewOption;

  00727	8a 81 93 00 00
	00		 mov	 al, BYTE PTR [ecx+147]
  0072d	88 85 44 ff ff
	ff		 mov	 BYTE PTR _NOption$1[ebp], al

; 4295 : 		DWORD serial = lpObj->pInventory[lpMsg->Ipos].m_Number;

  00733	8b 01		 mov	 eax, DWORD PTR [ecx]
  00735	89 85 78 ff ff
	ff		 mov	 DWORD PTR _serial$1$[ebp], eax

; 4296 : 		int PetLevel = lpObj->pInventory[lpMsg->Ipos].m_PetItem_Level;

  0073b	8b 81 b8 00 00
	00		 mov	 eax, DWORD PTR [ecx+184]
  00741	89 85 48 ff ff
	ff		 mov	 DWORD PTR _PetLevel$1$[ebp], eax

; 4297 : 		int PetExp = lpObj->pInventory[lpMsg->Ipos].m_PetItem_Exp;

  00747	8b 81 bc 00 00
	00		 mov	 eax, DWORD PTR [ecx+188]
  0074d	89 85 4c ff ff
	ff		 mov	 DWORD PTR _PetExp$1$[ebp], eax

; 4298 : 		BYTE SOption = lpObj->pInventory[lpMsg->Ipos].m_SetOption;

  00753	8a 81 aa 00 00
	00		 mov	 al, BYTE PTR [ecx+170]
  00759	88 85 60 ff ff
	ff		 mov	 BYTE PTR _SOption$3[ebp], al

; 4299 : 		BYTE btItemEffectEx = lpObj->pInventory[lpMsg->Ipos].m_ItemOptionEx;

  0075f	8a 81 c6 00 00
	00		 mov	 al, BYTE PTR [ecx+198]
  00765	88 85 64 ff ff
	ff		 mov	 BYTE PTR _btItemEffectEx$4[ebp], al

; 4300 : 
; 4301 : 
; 4302 : 		BYTE SocketOptions[MAX_SOCKET_COUNT];
; 4303 : 		BYTE SocketBonus;
; 4304 : 		
; 4305 : 
; 4306 : 		g_SocketItem.GetItemOptions(&lpObj->pInventory[lpMsg->Ipos],&SocketOptions[0],&SocketBonus);

  0076b	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _SocketBonus$2[ebp]
  00771	50		 push	 eax
  00772	8d 45 ec	 lea	 eax, DWORD PTR _SocketOptions$12[ebp]
  00775	50		 push	 eax
  00776	51		 push	 ecx
  00777	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SocketItem@@3VCSocketItems@@A ; g_SocketItem
  0077c	e8 00 00 00 00	 call	 ?GetItemOptions@CSocketItems@@QAEXPAVCItem@@PAE1@Z ; CSocketItems::GetItemOptions

; 4307 : 
; 4308 : 		int serial2 = lpObj->pInventory[lpMsg->Ipos].m_Number;

  00781	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00785	69 f0 d4 00 00
	00		 imul	 esi, eax, 212

; 4309 : 		char szItemName[50] = "Item";

  0078b	6a 2d		 push	 45			; 0000002dH
  0078d	6a 00		 push	 0
  0078f	03 b3 c0 11 00
	00		 add	 esi, DWORD PTR [ebx+4544]
  00795	8b 06		 mov	 eax, DWORD PTR [esi]
  00797	89 45 98	 mov	 DWORD PTR _serial2$1$[ebp], eax
  0079a	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04BGCMBJDA@Item?$AA@
  0079f	89 45 b8	 mov	 DWORD PTR _szItemName$11[ebp], eax
  007a2	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_04BGCMBJDA@Item?$AA@+4
  007a7	88 45 bc	 mov	 BYTE PTR _szItemName$11[ebp+4], al
  007aa	8d 45 bd	 lea	 eax, DWORD PTR _szItemName$11[ebp+5]
  007ad	50		 push	 eax
  007ae	e8 00 00 00 00	 call	 _memset
  007b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4310 : 		BYTE JOHOption = g_kJewelOfHarmonySystem.GetItemStrengthenOption(&lpObj->pInventory[lpMsg->Ipos]);

  007b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  007bb	56		 push	 esi
  007bc	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption

; 4311 : 		BYTE JOHOptionLevel = g_kJewelOfHarmonySystem.GetItemOptionLevel(&lpObj->pInventory[lpMsg->Ipos]);

  007c1	0f b6 57 05	 movzx	 edx, BYTE PTR [edi+5]
  007c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  007ca	69 d2 d4 00 00
	00		 imul	 edx, edx, 212
  007d0	88 45 96	 mov	 BYTE PTR _JOHOption$1$[ebp], al
  007d3	03 93 c0 11 00
	00		 add	 edx, DWORD PTR [ebx+4544]
  007d9	52		 push	 edx
  007da	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel

; 4312 : 
; 4313 : 		if ( gObjCheckSerial0ItemList(&lpObj->pInventory[lpMsg->Ipos]) != FALSE )

  007df	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  007e3	69 c9 d4 00 00
	00		 imul	 ecx, ecx, 212
  007e9	88 45 97	 mov	 BYTE PTR _JOHOptionLevel$1$[ebp], al
  007ec	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  007f2	51		 push	 ecx
  007f3	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  007f8	83 c4 04	 add	 esp, 4
  007fb	85 c0		 test	 eax, eax
  007fd	74 59		 je	 SHORT $LN130@CGItemDrop

; 4314 : 		{
; 4315 : 			MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(13, 26)));

  007ff	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  00804	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00809	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0080e	50		 push	 eax
  0080f	ff 33		 push	 DWORD PTR [ebx]
  00811	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 4316 : 			LogAddTD("[ANTI-HACK][Serial 0 Item] [ItemDrop] (%s)(%s) Item(%s) Pos(%d)",

  00816	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0081a	83 c4 08	 add	 esp, 8
  0081d	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00823	50		 push	 eax
  00824	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  0082a	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0082f	50		 push	 eax
  00830	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00833	50		 push	 eax
  00834	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00837	50		 push	 eax
  00838	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@MFJKFJAM@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLItem@
  0083d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00843	83 c4 14	 add	 esp, 20			; 00000014H

; 4317 : 				lpObj->AccountID, lpObj->Name, lpObj->pInventory[lpMsg->Ipos].GetName(),
; 4318 : 				lpMsg->Ipos);
; 4319 : 
; 4320 : 			CopyItem = TRUE;

  00846	c7 85 5c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _CopyItem$1$[ebp], 1

; 4321 : 			pResult.Result = false;

  00850	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 4322 : 			bIsItem = FALSE;

  00854	33 f6		 xor	 esi, esi
  00856	eb 06		 jmp	 SHORT $LN55@CGItemDrop
$LN130@CGItemDrop:
  00858	8b b5 54 ff ff
	ff		 mov	 esi, DWORD PTR _bIsItem$1$[ebp]
$LN55@CGItemDrop:

; 4323 : 		}
; 4324 : 
; 4325 : 		
; 4326 : 		if ( !::gObjInventorySearchSerialNumber(lpObj, serial2))	// ANTI DUPE SYSTEM

  0085e	ff 75 98	 push	 DWORD PTR _serial2$1$[ebp]
  00861	53		 push	 ebx
  00862	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAUOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00867	83 c4 08	 add	 esp, 8
  0086a	85 c0		 test	 eax, eax
  0086c	0f 85 25 01 00
	00		 jne	 $LN56@CGItemDrop

; 4327 : 		{
; 4328 : 			CopyItem = TRUE;

  00872	c7 85 5c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _CopyItem$1$[ebp], 1

; 4329 : 			pResult.Result = false;

  0087c	88 45 9f	 mov	 BYTE PTR _pResult$[ebp+3], al
$LN57@CGItemDrop:

; 4567 : 		{
; 4568 : 			LogAdd(lMsg.Get(MSGGET(1, 225)));

  0087f	68 e1 01 00 00	 push	 481			; 000001e1H
  00884	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00889	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0088e	50		 push	 eax
  0088f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00895	83 c4 04	 add	 esp, 4
$LN134@CGItemDrop:

; 4569 : 			pResult.Result = false;

  00898	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
$LN129@CGItemDrop:
  0089c	8b 75 80	 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
$LN58@CGItemDrop:

; 4570 : 		}
; 4571 : 	}
; 4572 : 
; 4573 : 	DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0089f	0f b6 45 9d	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  008a3	50		 push	 eax
  008a4	8d 45 9c	 lea	 eax, DWORD PTR _pResult$[ebp]
  008a7	50		 push	 eax
  008a8	56		 push	 esi
  008a9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  008ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4574 : 
; 4575 : 	if ( CopyItem != FALSE )

  008b1	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR _CopyItem$1$[ebp], 0
  008b8	74 09		 je	 SHORT $LN108@CGItemDrop

; 4576 : 		::GCItemListSend(aIndex);

  008ba	56		 push	 esi
  008bb	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  008c0	83 c4 04	 add	 esp, 4
$LN108@CGItemDrop:

; 4577 : 
; 4578 : 	if ( pResult.Result == 1 )

  008c3	8a 4d 9f	 mov	 cl, BYTE PTR _pResult$[ebp+3]
  008c6	80 f9 01	 cmp	 cl, 1
  008c9	0f 85 b4 00 00
	00		 jne	 $LN110@CGItemDrop

; 4579 : 	{
; 4580 : 		if ( lpMsg->Ipos < 12 )

  008cf	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  008d2	3c 0c		 cmp	 al, 12			; 0000000cH
  008d4	0f 83 a9 00 00
	00		 jae	 $LN110@CGItemDrop

; 4581 : 		{
; 4582 : 			if ( lpMsg->Ipos == 10 || lpMsg->Ipos == 11 )

  008da	3c 0a		 cmp	 al, 10			; 0000000aH
  008dc	74 04		 je	 SHORT $LN112@CGItemDrop
  008de	3c 0b		 cmp	 al, 11			; 0000000bH
  008e0	75 0b		 jne	 SHORT $LN111@CGItemDrop
$LN112@CGItemDrop:

; 4583 : 			{
; 4584 : 				gObjUseSkill.SkillChangeUse(aIndex);

  008e2	56		 push	 esi
  008e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  008e8	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN111@CGItemDrop:

; 4585 : 			}
; 4586 : 
; 4587 : 
; 4588 : 			::gObjMakePreviewCharSet(aIndex);

  008ed	56		 push	 esi
  008ee	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 4589 : 
; 4590 : 			PMSG_USEREQUIPMENTCHANGED pChange;
; 4591 : 
; 4592 : 			PHeadSetB((LPBYTE)&pChange, 0x25, sizeof(pChange));

  008f3	6a 11		 push	 17			; 00000011H
  008f5	8d 45 a4	 lea	 eax, DWORD PTR _pChange$10[ebp]
  008f8	6a 25		 push	 37			; 00000025H
  008fa	50		 push	 eax
  008fb	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 4593 : 			pChange.NumberH = SET_NUMBERH(aIndex);

  00900	8b 4d 80	 mov	 ecx, DWORD PTR _aIndex$GSCopy$1$[ebp]

; 4594 : 			pChange.NumberL = SET_NUMBERL(aIndex);
; 4595 : 			ItemByteConvert(pChange.ItemInfo, lpObj->pInventory[lpMsg->Ipos]);

  00903	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00909	8b c1		 mov	 eax, ecx
  0090b	88 4d a8	 mov	 BYTE PTR _pChange$10[ebp+4], cl
  0090e	c1 e8 08	 shr	 eax, 8
  00911	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00916	88 45 a7	 mov	 BYTE PTR _pChange$10[ebp+3], al
  00919	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  0091d	8b fc		 mov	 edi, esp
  0091f	69 f0 d4 00 00
	00		 imul	 esi, eax, 212
  00925	8d 45 a9	 lea	 eax, DWORD PTR _pChange$10[ebp+5]
  00928	50		 push	 eax
  00929	03 b3 c0 11 00
	00		 add	 esi, DWORD PTR [ebx+4544]
  0092f	f3 a5		 rep movsd
  00931	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 4596 : 			pChange.ItemInfo[I_OPTION] = lpMsg->Ipos <<  4;

  00936	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]

; 4597 : 			pChange.ItemInfo[I_OPTION] |= LevelSmallConvert(aIndex, lpMsg->Ipos) & 0x0F;

  0093c	8b 75 80	 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  0093f	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  00942	8a c1		 mov	 al, cl
  00944	c0 e0 04	 shl	 al, 4
  00947	88 45 aa	 mov	 BYTE PTR _pChange$10[ebp+6], al
  0094a	0f b6 c1	 movzx	 eax, cl
  0094d	50		 push	 eax
  0094e	56		 push	 esi
  0094f	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  00954	24 0f		 and	 al, 15			; 0000000fH
  00956	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  0095c	08 45 aa	 or	 BYTE PTR _pChange$10[ebp+6], al

; 4598 : 
; 4599 : 			DataSend(aIndex, (LPBYTE)&pChange, pChange.h.size);

  0095f	0f b6 45 a5	 movzx	 eax, BYTE PTR _pChange$10[ebp+1]
  00963	50		 push	 eax
  00964	8d 45 a4	 lea	 eax, DWORD PTR _pChange$10[ebp]
  00967	50		 push	 eax
  00968	56		 push	 esi
  00969	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4600 : 			MsgSendV2(lpObj, (LPBYTE)&pChange, pChange.h.size);

  0096e	0f b6 45 a5	 movzx	 eax, BYTE PTR _pChange$10[ebp+1]
  00972	50		 push	 eax
  00973	8d 45 a4	 lea	 eax, DWORD PTR _pChange$10[ebp]
  00976	50		 push	 eax
  00977	53		 push	 ebx
  00978	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0097d	8a 4d 9f	 mov	 cl, BYTE PTR _pResult$[ebp+3]
  00980	83 c4 18	 add	 esp, 24			; 00000018H
$LN110@CGItemDrop:

; 4601 : 		}
; 4602 : 	}
; 4603 : 
; 4604 : 	return pResult.Result;

  00983	0f b6 c1	 movzx	 eax, cl

; 4605 : }

  00986	5f		 pop	 edi
  00987	5e		 pop	 esi
  00988	5b		 pop	 ebx
  00989	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0098c	33 cd		 xor	 ecx, ebp
  0098e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00993	8b e5		 mov	 esp, ebp
  00995	5d		 pop	 ebp
  00996	c3		 ret	 0
$LN56@CGItemDrop:

; 4330 : 			bIsItem = FALSE;
; 4331 : 		}
; 4332 : 
; 4333 : 		if ( bIsItem == TRUE )

  00997	83 fe 01	 cmp	 esi, 1
  0099a	0f 85 df fe ff
	ff		 jne	 $LN57@CGItemDrop

; 4334 : 		{
; 4335 : 			strcpy(szItemName, lpObj->pInventory[lpMsg->Ipos].GetName());

  009a0	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  009a4	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  009aa	03 8b c0 11 00
	00		 add	 ecx, DWORD PTR [ebx+4544]
  009b0	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  009b5	8d 55 b8	 lea	 edx, DWORD PTR _szItemName$11[ebp]
  009b8	2b d0		 sub	 edx, eax
  009ba	66 0f 1f 44 00
	00		 npad	 6
$LL116@CGItemDrop:
  009c0	8a 08		 mov	 cl, BYTE PTR [eax]
  009c2	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  009c5	40		 inc	 eax
  009c6	84 c9		 test	 cl, cl
  009c8	75 f6		 jne	 SHORT $LL116@CGItemDrop

; 4336 : 			
; 4337 : 			BYTE EventItemBagState = g_EventItemBagManager.OpenBox(aIndex, type, level);

  009ca	ff 75 90	 push	 DWORD PTR _level$1$[ebp]
  009cd	8b 75 80	 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  009d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  009d5	ff b5 7c ff ff
	ff		 push	 DWORD PTR _type$1$[ebp]
  009db	56		 push	 esi
  009dc	e8 00 00 00 00	 call	 ?OpenBox@EventItemBagManager@@QAEEHHE@Z ; EventItemBagManager::OpenBox

; 4338 : 
; 4339 : 			if( EventItemBagState == 1 )

  009e1	3c 01		 cmp	 al, 1
  009e3	75 17		 jne	 SHORT $LN59@CGItemDrop

; 4340 : 			{
; 4341 : 				::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  009e5	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  009e9	50		 push	 eax
  009ea	56		 push	 esi
  009eb	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  009f0	83 c4 08	 add	 esp, 8

; 4342 : 				pResult.Result = true;

  009f3	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  009f7	e9 a3 fe ff ff	 jmp	 $LN58@CGItemDrop
$LN59@CGItemDrop:

; 4343 : 			}
; 4344 : 			else if( EventItemBagState == 0 )

  009fc	84 c0		 test	 al, al
  009fe	75 29		 jne	 SHORT $LN61@CGItemDrop
$LN77@CGItemDrop:

; 4345 : 			{
; 4346 : 				pResult.Result = false;
; 4347 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00a00	0f b6 45 9d	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00a04	50		 push	 eax
  00a05	8d 45 9c	 lea	 eax, DWORD PTR _pResult$[ebp]
  00a08	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  00a0c	50		 push	 eax
  00a0d	56		 push	 esi
  00a0e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4605 : }

  00a13	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a16	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a19	33 cd		 xor	 ecx, ebp
  00a1b	33 c0		 xor	 eax, eax
  00a1d	5f		 pop	 edi
  00a1e	5e		 pop	 esi
  00a1f	5b		 pop	 ebx
  00a20	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a25	8b e5		 mov	 esp, ebp
  00a27	5d		 pop	 ebp
  00a28	c3		 ret	 0
$LN61@CGItemDrop:

; 4348 : 				return FALSE;
; 4349 : 			}
; 4350 : 			else if( type == ITEMGET(14,51) || type == ITEMGET(14,63) || type == ITEMGET(14,99) )

  00a29	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _type$1$[ebp]
  00a2f	81 f9 33 1c 00
	00		 cmp	 ecx, 7219		; 00001c33H
  00a35	0f 84 1e 05 00
	00		 je	 $LN65@CGItemDrop
  00a3b	81 f9 3f 1c 00
	00		 cmp	 ecx, 7231		; 00001c3fH
  00a41	0f 84 12 05 00
	00		 je	 $LN65@CGItemDrop
  00a47	81 f9 63 1c 00
	00		 cmp	 ecx, 7267		; 00001c63H
  00a4d	0f 84 06 05 00
	00		 je	 $LN65@CGItemDrop

; 4361 : 					lpObj->AccountID, lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y,
; 4362 : 					serial, szItemName, type, level, Option1, Option2, Option3);
; 4363 : 			}
; 4364 : 			else if ( type == ITEMGET(12,26) )

  00a53	81 f9 1a 18 00
	00		 cmp	 ecx, 6170		; 0000181aH
  00a59	0f 85 ae 01 00
	00		 jne	 $LN66@CGItemDrop

; 4365 : 			{
; 4366 : 				switch ( level )

  00a5f	8b 45 90	 mov	 eax, DWORD PTR _level$1$[ebp]
  00a62	83 f8 05	 cmp	 eax, 5
  00a65	0f 87 34 fe ff
	ff		 ja	 $LN58@CGItemDrop
  00a6b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN136@CGItemDrop[eax*4]
$LN68@CGItemDrop:

; 4367 : 				{
; 4368 : 					case 0:
; 4369 : 						{
; 4370 : 							gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00a72	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00a76	50		 push	 eax
  00a77	56		 push	 esi
  00a78	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00a7d	83 c4 08	 add	 esp, 8

; 4371 : 							pResult.Result = true;

  00a80	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 4372 : 							int ltype = ITEMGET(12,26);
; 4373 : 							int randor = rand()%100;

  00a84	e8 00 00 00 00	 call	 _rand
  00a89	99		 cdq
  00a8a	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00a8f	f7 f9		 idiv	 ecx

; 4374 : 							int Level;
; 4375 : 
; 4376 : 							if ( randor < 10 )

  00a91	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00a94	7d 05		 jge	 SHORT $LN69@CGItemDrop

; 4377 : 							{
; 4378 : 								Level = 3;

  00a96	8d 41 9f	 lea	 eax, DWORD PTR [ecx-97]
  00a99	eb 09		 jmp	 SHORT $LN132@CGItemDrop
$LN69@CGItemDrop:

; 4379 : 							}
; 4380 : 							else if ( randor < 45 )

  00a9b	33 c0		 xor	 eax, eax
  00a9d	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  00aa0	0f 9d c0	 setge	 al
  00aa3	40		 inc	 eax
$LN132@CGItemDrop:

; 4381 : 							{
; 4382 : 								Level = 1;
; 4383 : 							}
; 4384 : 							else
; 4385 : 							{
; 4386 : 								Level = 2;
; 4387 : 							}
; 4388 : 
; 4389 : 							ItemSerialCreateSend(aIndex, lpObj->MapNumber, lpObj->X, lpObj->Y,

  00aa4	6a 00		 push	 0
  00aa6	6a 00		 push	 0
  00aa8	6a 00		 push	 0
  00aaa	6a 00		 push	 0
  00aac	ff 33		 push	 DWORD PTR [ebx]
  00aae	89 45 8c	 mov	 DWORD PTR _Level$1$[ebp], eax
  00ab1	6a 00		 push	 0
  00ab3	6a 00		 push	 0
  00ab5	6a 00		 push	 0
  00ab7	6a 01		 push	 1
  00ab9	50		 push	 eax
  00aba	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  00ac1	68 1a 18 00 00	 push	 6170			; 0000181aH
  00ac6	50		 push	 eax
  00ac7	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00ace	50		 push	 eax
  00acf	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  00ad6	50		 push	 eax
  00ad7	56		 push	 esi
  00ad8	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 4390 : 								ltype, Level, 1, 0, 0, 0, lpObj->m_Index, 0, 0);
; 4391 : 							
; 4392 : 							LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Mysterious Bead : Drop (%d) - serial:%d",

  00add	ff b5 78 ff ff
	ff		 push	 DWORD PTR _serial$1$[ebp]
  00ae3	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00ae6	ff 75 8c	 push	 DWORD PTR _Level$1$[ebp]
  00ae9	50		 push	 eax
  00aea	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00aed	50		 push	 eax
  00aee	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@GOMPGJDH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00af3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00af9	83 c4 50	 add	 esp, 80			; 00000050H

; 4393 : 								lpObj->AccountID, lpObj->Name, Level, serial);
; 4394 : 						}
; 4395 : 						break;

  00afc	e9 9e fd ff ff	 jmp	 $LN58@CGItemDrop
$LN73@CGItemDrop:

; 4396 : 					case 1: case 2: case 3:
; 4397 : 						{
; 4398 : 							gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00b01	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00b05	50		 push	 eax
  00b06	56		 push	 esi
  00b07	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 4399 : 							pResult.Result = true;
; 4400 : 
; 4401 : 							PMSG_SERVERCMD ServerCmd;
; 4402 : 
; 4403 : 							PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  00b0c	6a 07		 push	 7
  00b0e	6a 40		 push	 64			; 00000040H
  00b10	8d 45 84	 lea	 eax, DWORD PTR _ServerCmd$8[ebp]
  00b13	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00b17	68 f3 00 00 00	 push	 243			; 000000f3H
  00b1c	50		 push	 eax
  00b1d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 4404 : 							ServerCmd.CmdType = 0;
; 4405 : 							ServerCmd.X = lpObj->X;

  00b22	8a 83 20 01 00
	00		 mov	 al, BYTE PTR [ebx+288]
  00b28	88 45 89	 mov	 BYTE PTR _ServerCmd$8[ebp+5], al

; 4406 : 							ServerCmd.Y = lpObj->Y;

  00b2b	8a 83 21 01 00
	00		 mov	 al, BYTE PTR [ebx+289]
  00b31	88 45 8a	 mov	 BYTE PTR _ServerCmd$8[ebp+6], al

; 4407 : 
; 4408 : 							MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00b34	8d 45 84	 lea	 eax, DWORD PTR _ServerCmd$8[ebp]
  00b37	6a 07		 push	 7
  00b39	50		 push	 eax
  00b3a	53		 push	 ebx
  00b3b	c6 45 88 00	 mov	 BYTE PTR _ServerCmd$8[ebp+4], 0
  00b3f	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 4409 : 							DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00b44	6a 07		 push	 7
  00b46	8d 45 84	 lea	 eax, DWORD PTR _ServerCmd$8[ebp]
  00b49	50		 push	 eax
  00b4a	ff 33		 push	 DWORD PTR [ebx]
  00b4c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4410 : 													
; 4411 : 							LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Crystal (%d) - serial:%d",

  00b51	ff b5 78 ff ff
	ff		 push	 DWORD PTR _serial$1$[ebp]
  00b57	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00b5a	ff 75 90	 push	 DWORD PTR _level$1$[ebp]
  00b5d	50		 push	 eax
  00b5e	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00b61	50		 push	 eax
  00b62	68 00 00 00 00	 push	 OFFSET ??_C@_0ED@PDKMNGPH@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00b67	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b6d	83 c4 44	 add	 esp, 68			; 00000044H

; 4412 : 								lpObj->AccountID, lpObj->Name, level, serial);
; 4413 : 						}
; 4414 : 						break;

  00b70	e9 2a fd ff ff	 jmp	 $LN58@CGItemDrop
$LN74@CGItemDrop:

; 4415 : 					case 5:
; 4416 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Throw Surprise Treasure Box - serial:%d",

  00b75	ff b5 78 ff ff
	ff		 push	 DWORD PTR _serial$1$[ebp]
  00b7b	8d 73 5d	 lea	 esi, DWORD PTR [ebx+93]
  00b7e	56		 push	 esi
  00b7f	8d 7b 52	 lea	 edi, DWORD PTR [ebx+82]
  00b82	57		 push	 edi
  00b83	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@LPMBPPDG@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00b88	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4417 : 							lpObj->AccountID, lpObj->Name,  serial);
; 4418 : 						gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00b8e	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00b94	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  00b98	50		 push	 eax
  00b99	ff 75 80	 push	 DWORD PTR _aIndex$GSCopy$1$[ebp]
  00b9c	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00ba1	83 c4 18	 add	 esp, 24			; 00000018H

; 4419 : 						pResult.Result = true;

  00ba4	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1

; 4420 : 
; 4421 : 						int money = 1000000;
; 4422 : 						MapC[lpObj->MapNumber].MoneyItemDrop(money, lpObj->X, lpObj->Y);

  00ba8	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  00baf	50		 push	 eax
  00bb0	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00bb7	50		 push	 eax
  00bb8	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  00bbf	69 c8 28 38 05
	00		 imul	 ecx, eax, 342056
  00bc5	68 40 42 0f 00	 push	 1000000			; 000f4240H
  00bca	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00bd0	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop

; 4423 : 							
; 4424 : 						LogAddTD("[Hidden TreasureBox Event] [%s][%s] Event ZenDrop : %d : (%d)(%d/%d)",

  00bd5	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  00bdc	50		 push	 eax
  00bdd	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00be4	50		 push	 eax
  00be5	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  00bec	50		 push	 eax
  00bed	68 40 42 0f 00	 push	 1000000			; 000f4240H
  00bf2	56		 push	 esi
  00bf3	57		 push	 edi
  00bf4	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@GOCIBGLO@?$FLHidden?5TreasureBox?5Event?$FN?5?$FL?$CFs?$FN?$FL@
  00bf9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4425 : 							lpObj->AccountID, lpObj->Name, money, lpObj->MapNumber, lpObj->X, lpObj->Y);
; 4426 : 						break;
; 4427 : 				}
; 4428 : 			}
; 4429 : 			else if ( type == ITEMGET(14,28) ) // Lost Map

  00bff	8b bd 58 ff ff
	ff		 mov	 edi, DWORD PTR _lpMsg$GSCopy$1$[ebp]
  00c05	83 c4 1c	 add	 esp, 28			; 0000001cH
  00c08	e9 8f fc ff ff	 jmp	 $LN129@CGItemDrop
$LN66@CGItemDrop:
  00c0d	81 f9 1c 1c 00
	00		 cmp	 ecx, 7196		; 00001c1cH
  00c13	75 70		 jne	 SHORT $LN75@CGItemDrop

; 4430 : 			{
; 4431 : 				if ( g_KalimaGate.CreateKalimaGate(aIndex, level, lpMsg->px, lpMsg->py))

  00c15	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00c19	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  00c1e	50		 push	 eax
  00c1f	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00c23	50		 push	 eax
  00c24	ff 75 90	 push	 DWORD PTR _level$1$[ebp]
  00c27	56		 push	 esi
  00c28	e8 00 00 00 00	 call	 ?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z ; CKalimaGate::CreateKalimaGate
  00c2d	85 c0		 test	 eax, eax
  00c2f	0f 84 cb fd ff
	ff		 je	 $LN77@CGItemDrop

; 4432 : 				{
; 4433 : 					LogAddTD("[Kalima] [%s][%s] Success to Make Kalima Gate (Lost Kalima Map Serial:%d)",

  00c35	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00c39	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c3f	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00c45	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv1866[ebp]
  00c4b	8b 84 10 c0 11
	00 00		 mov	 eax, DWORD PTR [eax+edx+4544]
  00c52	ff 34 01	 push	 DWORD PTR [ecx+eax]
  00c55	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv1866[ebp]
  00c5b	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00c5e	03 c1		 add	 eax, ecx
  00c60	50		 push	 eax
  00c61	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  00c64	03 c1		 add	 eax, ecx
  00c66	50		 push	 eax
  00c67	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@IDAEHEED@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5to?5Mak@
  00c6c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4434 : 						gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pInventory[lpMsg->Ipos].m_Number);
; 4435 : 
; 4436 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00c72	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00c76	50		 push	 eax
  00c77	56		 push	 esi
  00c78	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00c7d	83 c4 18	 add	 esp, 24			; 00000018H

; 4437 : 				}
; 4438 : 				else
; 4439 : 				{
; 4440 : 					pResult.Result = false;
; 4441 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4442 : 
; 4443 : 					return FALSE;
; 4444 : 				}

  00c80	e9 1a fc ff ff	 jmp	 $LN58@CGItemDrop
$LN75@CGItemDrop:

; 4445 : 			}
; 4446 : 			else if ( type == ITEMGET(13,7) ) // Contract (Summon)

  00c85	81 f9 07 1a 00
	00		 cmp	 ecx, 6663		; 00001a07H
  00c8b	75 4c		 jne	 SHORT $LN79@CGItemDrop

; 4447 : 			{
; 4448 : 				int iMonsterID = 0;
; 4449 : 
; 4450 : 				if ( level == 0 )

  00c8d	8b 45 90	 mov	 eax, DWORD PTR _level$1$[ebp]
  00c90	33 c9		 xor	 ecx, ecx
  00c92	85 c0		 test	 eax, eax
  00c94	75 07		 jne	 SHORT $LN81@CGItemDrop

; 4451 : 					iMonsterID = 286;

  00c96	b9 1e 01 00 00	 mov	 ecx, 286		; 0000011eH
  00c9b	eb 0b		 jmp	 SHORT $LN83@CGItemDrop
$LN81@CGItemDrop:

; 4452 : 				else if ( level == 1 )

  00c9d	83 f8 01	 cmp	 eax, 1
  00ca0	ba 1f 01 00 00	 mov	 edx, 287		; 0000011fH
  00ca5	0f 44 ca	 cmove	 ecx, edx
$LN83@CGItemDrop:

; 4453 : 					iMonsterID = 287;
; 4454 : 
; 4455 : 
; 4456 : 				if ( g_CsNPC_Mercenary.CreateMercenary(aIndex, iMonsterID, lpMsg->px, lpMsg->py) )

  00ca8	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00cac	50		 push	 eax
  00cad	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00cb1	50		 push	 eax
  00cb2	51		 push	 ecx
  00cb3	56		 push	 esi
  00cb4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Mercenary@@3VCMercenary@@A ; g_CsNPC_Mercenary
  00cb9	e8 00 00 00 00	 call	 ?CreateMercenary@CMercenary@@QAEHHHEE@Z ; CMercenary::CreateMercenary
  00cbe	85 c0		 test	 eax, eax
  00cc0	0f 84 3a fd ff
	ff		 je	 $LN77@CGItemDrop

; 4457 : 				{
; 4458 : 					::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00cc6	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00cca	50		 push	 eax
  00ccb	56		 push	 esi
  00ccc	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00cd1	83 c4 08	 add	 esp, 8

; 4459 : 				}
; 4460 : 				else
; 4461 : 				{
; 4462 : 					pResult.Result = false;
; 4463 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4464 : 
; 4465 : 					return FALSE;
; 4466 : 				}

  00cd4	e9 c6 fb ff ff	 jmp	 $LN58@CGItemDrop
$LN79@CGItemDrop:

; 4467 : 			}
; 4468 : 			else if ( type == ITEMGET(13,11) ) // Guardian / LifeStone

  00cd9	81 f9 0b 1a 00
	00		 cmp	 ecx, 6667		; 00001a0bH
  00cdf	75 44		 jne	 SHORT $LN86@CGItemDrop

; 4469 : 			{
; 4470 : 				BOOL bResult = FALSE;
; 4471 : 
; 4472 : 				if ( level == 0 )

  00ce1	8b 45 90	 mov	 eax, DWORD PTR _level$1$[ebp]
  00ce4	85 c0		 test	 eax, eax
  00ce6	75 0d		 jne	 SHORT $LN88@CGItemDrop

; 4473 : 					bResult = g_CsNPC_Guardian.CreateGuardian(aIndex);

  00ce8	56		 push	 esi
  00ce9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Guardian@@3VCGuardian@@A ; g_CsNPC_Guardian
  00cee	e8 00 00 00 00	 call	 ?CreateGuardian@CGuardian@@QAEHH@Z ; CGuardian::CreateGuardian
  00cf3	eb 14		 jmp	 SHORT $LN90@CGItemDrop
$LN88@CGItemDrop:

; 4474 : #if (GS_CASTLE == 1)
; 4475 : 				else if(level == 1)

  00cf5	83 f8 01	 cmp	 eax, 1
  00cf8	0f 85 02 fd ff
	ff		 jne	 $LN77@CGItemDrop

; 4476 : 					bResult = g_CsNPC_LifeStone.CreateLifeStone(aIndex);

  00cfe	56		 push	 esi
  00cff	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_LifeStone@@3VCLifeStone@@A ; g_CsNPC_LifeStone
  00d04	e8 00 00 00 00	 call	 ?CreateLifeStone@CLifeStone@@QAEHH@Z ; CLifeStone::CreateLifeStone
$LN90@CGItemDrop:

; 4477 : #endif
; 4478 : 
; 4479 : 				if ( bResult == TRUE )

  00d09	83 f8 01	 cmp	 eax, 1
  00d0c	0f 85 ee fc ff
	ff		 jne	 $LN77@CGItemDrop

; 4480 : 					::gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00d12	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00d16	50		 push	 eax
  00d17	56		 push	 esi
  00d18	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00d1d	83 c4 08	 add	 esp, 8

; 4481 : 				else
; 4482 : 				{
; 4483 : 					pResult.Result = false;
; 4484 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4485 : 
; 4486 : 					return FALSE;
; 4487 : 				}
; 4488 : 			}
; 4489 : 			else if( g_SnakeBegins.IsScroll(type) )

  00d20	e9 7a fb ff ff	 jmp	 $LN58@CGItemDrop
$LN86@CGItemDrop:
; File c:\users\michel\desktop\source\gameserver\source\snakebegins.h

; 18   : 	bool	IsScroll(WORD ItemType) { return ItemType >= ITEMGET(14, 210) && ItemType <= ITEMGET(14, 213); };

  00d25	8d 81 2e e3 ff
	ff		 lea	 eax, DWORD PTR [ecx-7378]
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 4491 : 				if( g_SnakeBegins.DropScroll(lpObj, type) )

  00d2b	51		 push	 ecx
; File c:\users\michel\desktop\source\gameserver\source\snakebegins.h

; 18   : 	bool	IsScroll(WORD ItemType) { return ItemType >= ITEMGET(14, 210) && ItemType <= ITEMGET(14, 213); };

  00d2c	66 83 f8 03	 cmp	 ax, 3
  00d30	77 63		 ja	 SHORT $LN93@CGItemDrop
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 4491 : 				if( g_SnakeBegins.DropScroll(lpObj, type) )

  00d32	53		 push	 ebx
  00d33	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_SnakeBegins@@3VSnakeBegins@@A ; g_SnakeBegins
  00d38	e8 00 00 00 00	 call	 ?DropScroll@SnakeBegins@@QAE_NPAUOBJECTSTRUCT@@G@Z ; SnakeBegins::DropScroll
  00d3d	84 c0		 test	 al, al
  00d3f	0f 84 bb fc ff
	ff		 je	 $LN77@CGItemDrop

; 4492 : 				{
; 4493 : 					LogAddTD("[SnakeBegins] [%s][%s] Success to create Snake",

  00d45	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00d49	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d4f	69 c8 d4 00 00
	00		 imul	 ecx, eax, 212
  00d55	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv1866[ebp]
  00d5b	8b 84 10 c0 11
	00 00		 mov	 eax, DWORD PTR [eax+edx+4544]
  00d62	ff 34 01	 push	 DWORD PTR [ecx+eax]
  00d65	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv1866[ebp]
  00d6b	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00d6e	03 c1		 add	 eax, ecx
  00d70	50		 push	 eax
  00d71	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  00d74	03 c1		 add	 eax, ecx
  00d76	50		 push	 eax
  00d77	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@KAEBPCMA@?$FLSnakeBegins?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5t@
  00d7c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 4494 : 						gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pInventory[lpMsg->Ipos].m_Number);
; 4495 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00d82	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00d86	50		 push	 eax
  00d87	56		 push	 esi
  00d88	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00d8d	83 c4 18	 add	 esp, 24			; 00000018H

; 4496 : 				}
; 4497 : 				else
; 4498 : 				{
; 4499 : 					pResult.Result = false;
; 4500 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4501 : 					return false;
; 4502 : 				}

  00d90	e9 0a fb ff ff	 jmp	 $LN58@CGItemDrop
$LN93@CGItemDrop:

; 4503 : 			}
; 4504 : #if (ENABLE_CUSTOM_MONSTERSPAWNER == 1)
; 4505 : 			else if (MonsterSpawnerMng::getInstance()->isKeyItem(type)) {

  00d95	e8 00 00 00 00	 call	 ?getInstance@MonsterSpawnerMng@@SAPAV1@XZ ; MonsterSpawnerMng::getInstance
  00d9a	8b c8		 mov	 ecx, eax
  00d9c	e8 00 00 00 00	 call	 ?isKeyItem@MonsterSpawnerMng@@QAE_NH@Z ; MonsterSpawnerMng::isKeyItem
  00da1	84 c0		 test	 al, al
  00da3	74 2e		 je	 SHORT $LN97@CGItemDrop

; 4506 : 				if (MonsterSpawnerMng::getInstance()->procCreate(aIndex, type)) {

  00da5	ff b5 7c ff ff
	ff		 push	 DWORD PTR _type$1$[ebp]
  00dab	56		 push	 esi
  00dac	e8 00 00 00 00	 call	 ?getInstance@MonsterSpawnerMng@@SAPAV1@XZ ; MonsterSpawnerMng::getInstance
  00db1	8b c8		 mov	 ecx, eax
  00db3	e8 00 00 00 00	 call	 ?procCreate@MonsterSpawnerMng@@QAE_NFH@Z ; MonsterSpawnerMng::procCreate
  00db8	84 c0		 test	 al, al
  00dba	0f 84 40 fc ff
	ff		 je	 $LN77@CGItemDrop

; 4507 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00dc0	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00dc4	50		 push	 eax
  00dc5	56		 push	 esi
  00dc6	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00dcb	83 c4 08	 add	 esp, 8

; 4508 : 				} else {
; 4509 : 					pResult.Result = false;
; 4510 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4511 : 					return false;
; 4512 : 				}
; 4513 : 			}
; 4514 : #endif
; 4515 : #ifdef __NOVUS__
; 4516 : 			else if( g_SummonSpot.IsScroll(type) )
; 4517 : 			{
; 4518 : 				if( g_SummonSpot.DropScroll(lpObj, type) )
; 4519 : 				{
; 4520 : 					LogAddTD("[SummonSpot] [%s][%s] Success to create spot",
; 4521 : 						gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pInventory[lpMsg->Ipos].m_Number);
; 4522 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);
; 4523 : 				}
; 4524 : 				else
; 4525 : 				{
; 4526 : 					pResult.Result = false;
; 4527 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4528 : 					return false;
; 4529 : 				}
; 4530 : 			}
; 4531 : #endif
; 4532 : 			else

  00dce	e9 cc fa ff ff	 jmp	 $LN58@CGItemDrop
$LN97@CGItemDrop:

; 4533 : 			{
; 4534 : 				int OwnerIndex = aIndex;
; 4535 : 
; 4536 : 				if ( (type >= ITEMGET(14,0) && type <= ITEMGET(14,10)) || (type == ITEMGET(4,7) ) || type ==ITEMGET(4,15) )

  00dd3	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _type$1$[ebp]
  00dd9	8b c6		 mov	 eax, esi
  00ddb	81 f9 00 1c 00
	00		 cmp	 ecx, 7168		; 00001c00H
  00de1	7c 08		 jl	 SHORT $LN103@CGItemDrop
  00de3	81 f9 0a 1c 00
	00		 cmp	 ecx, 7178		; 00001c0aH
  00de9	7e 10		 jle	 SHORT $LN102@CGItemDrop
$LN103@CGItemDrop:
  00deb	81 f9 07 08 00
	00		 cmp	 ecx, 2055		; 00000807H
  00df1	74 08		 je	 SHORT $LN102@CGItemDrop
  00df3	81 f9 0f 08 00
	00		 cmp	 ecx, 2063		; 0000080fH
  00df9	75 03		 jne	 SHORT $LN101@CGItemDrop
$LN102@CGItemDrop:

; 4537 : 					OwnerIndex = -1;

  00dfb	83 c8 ff	 or	 eax, -1
$LN101@CGItemDrop:

; 4538 : 
; 4539 : 				if ( MapC[map].ItemDrop( type, level, dur, lpMsg->px, lpMsg->py, Option1, Option2, Option3,
; 4540 : 					NOption, SOption, serial2, OwnerIndex, PetLevel, PetExp, btItemEffectEx,&SocketOptions[0],SocketBonus) == TRUE )

  00dfe	ff b5 50 ff ff
	ff		 push	 DWORD PTR _SocketBonus$2[ebp]
  00e04	8d 55 ec	 lea	 edx, DWORD PTR _SocketOptions$12[ebp]
  00e07	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _dur$1$[ebp]
  00e0c	52		 push	 edx
  00e0d	ff b5 64 ff ff
	ff		 push	 DWORD PTR _btItemEffectEx$4[ebp]
  00e13	ff b5 4c ff ff
	ff		 push	 DWORD PTR _PetExp$1$[ebp]
  00e19	ff b5 48 ff ff
	ff		 push	 DWORD PTR _PetLevel$1$[ebp]
  00e1f	50		 push	 eax
  00e20	ff 75 98	 push	 DWORD PTR _serial2$1$[ebp]
  00e23	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00e27	ff b5 60 ff ff
	ff		 push	 DWORD PTR _SOption$3[ebp]
  00e2d	ff b5 44 ff ff
	ff		 push	 DWORD PTR _NOption$1[ebp]
  00e33	ff b5 70 ff ff
	ff		 push	 DWORD PTR _Option3$7[ebp]
  00e39	ff b5 6c ff ff
	ff		 push	 DWORD PTR _Option2$6[ebp]
  00e3f	ff b5 68 ff ff
	ff		 push	 DWORD PTR _Option1$5[ebp]
  00e45	50		 push	 eax
  00e46	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00e4a	50		 push	 eax
  00e4b	51		 push	 ecx
  00e4c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e51	ff 75 90	 push	 DWORD PTR _level$1$[ebp]
  00e54	51		 push	 ecx
  00e55	69 4d 84 28 38
	05 00		 imul	 ecx, DWORD PTR _map$1$[ebp], 342056
  00e5c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00e62	e8 00 00 00 00	 call	 ?ItemDrop@MapClass@@QAEHHHMHHEEEEEKHHHEPAEE@Z ; MapClass::ItemDrop
  00e67	83 f8 01	 cmp	 eax, 1
  00e6a	0f 85 e0 00 00
	00		 jne	 $LN104@CGItemDrop

; 4541 : 				{
; 4542 : 					gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00e70	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00e74	50		 push	 eax
  00e75	56		 push	 esi
  00e76	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 4543 : 					pResult.Result = true;
; 4544 : 
; 4545 : 					if ( drop_type == FALSE )
; 4546 : 					{
; 4547 : 						LogAddTD(lMsg.Get(MSGGET(1, 223)), lpObj->AccountID, lpObj->Name, lpObj->MapNumber,

  00e7b	0f b6 45 97	 movzx	 eax, BYTE PTR _JOHOptionLevel$1$[ebp]
  00e7f	83 c4 08	 add	 esp, 8
  00e82	c6 45 9f 01	 mov	 BYTE PTR _pResult$[ebp+3], 1
  00e86	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00e8b	50		 push	 eax
  00e8c	0f b6 45 96	 movzx	 eax, BYTE PTR _JOHOption$1$[ebp]
  00e90	50		 push	 eax
  00e91	0f b6 85 64 ff
	ff ff		 movzx	 eax, BYTE PTR _btItemEffectEx$4[ebp]
  00e98	c1 e8 07	 shr	 eax, 7
  00e9b	83 7d 10 00	 cmp	 DWORD PTR _drop_type$[ebp], 0
  00e9f	50		 push	 eax
  00ea0	0f b6 85 60 ff
	ff ff		 movzx	 eax, BYTE PTR _SOption$3[ebp]
  00ea7	50		 push	 eax
  00ea8	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$[ebp+6]
  00eac	50		 push	 eax
  00ead	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$[ebp+5]
  00eb1	50		 push	 eax
  00eb2	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$[ebp+4]
  00eb6	50		 push	 eax
  00eb7	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$[ebp+3]
  00ebb	50		 push	 eax
  00ebc	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$[ebp+2]
  00ec0	50		 push	 eax
  00ec1	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$[ebp+1]
  00ec5	50		 push	 eax
  00ec6	0f b6 45 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp]
  00eca	50		 push	 eax
  00ecb	f3 0f 2c 45 8c	 cvttss2si eax, DWORD PTR _dur$1$[ebp]
  00ed0	50		 push	 eax
  00ed1	0f b6 85 70 ff
	ff ff		 movzx	 eax, BYTE PTR _Option3$7[ebp]
  00ed8	50		 push	 eax
  00ed9	0f b6 85 6c ff
	ff ff		 movzx	 eax, BYTE PTR _Option2$6[ebp]
  00ee0	50		 push	 eax
  00ee1	0f b6 85 68 ff
	ff ff		 movzx	 eax, BYTE PTR _Option1$5[ebp]
  00ee8	50		 push	 eax
  00ee9	ff 75 90	 push	 DWORD PTR _level$1$[ebp]
  00eec	8d 45 b8	 lea	 eax, DWORD PTR _szItemName$11[ebp]
  00eef	ff b5 7c ff ff
	ff		 push	 DWORD PTR _type$1$[ebp]
  00ef5	50		 push	 eax
  00ef6	ff b5 78 ff ff
	ff		 push	 DWORD PTR _serial$1$[ebp]
  00efc	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  00f03	50		 push	 eax
  00f04	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00f0b	50		 push	 eax
  00f0c	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  00f13	50		 push	 eax
  00f14	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00f17	50		 push	 eax
  00f18	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00f1b	50		 push	 eax
  00f1c	75 19		 jne	 SHORT $LN106@CGItemDrop
  00f1e	68 df 01 00 00	 push	 479			; 000001dfH
  00f23	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00f28	50		 push	 eax
  00f29	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00f2f	83 c4 64	 add	 esp, 100		; 00000064H

; 4548 : 							lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2,
; 4549 : 							Option3, (int)dur, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4],
; 4550 : 							NewOption[5], NewOption[6], SOption, btItemEffectEx>>7, JOHOption, JOHOptionLevel);
; 4551 : 					}
; 4552 : 					else

  00f32	e9 68 f9 ff ff	 jmp	 $LN58@CGItemDrop
$LN106@CGItemDrop:

; 4553 : 					{
; 4554 : 						LogAddTD(lMsg.Get(MSGGET(1, 224)), lpObj->AccountID, lpObj->Name, lpObj->MapNumber,

  00f37	68 e0 01 00 00	 push	 480			; 000001e0H
  00f3c	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00f41	50		 push	 eax
  00f42	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00f48	83 c4 64	 add	 esp, 100		; 00000064H

; 4555 : 							lpObj->X, lpObj->Y, serial, szItemName, type, level, Option1, Option2,
; 4556 : 							Option3, (int)dur, NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4],
; 4557 : 							NewOption[5], NewOption[6], SOption, btItemEffectEx>>7, JOHOption, JOHOptionLevel );
; 4558 : 					}
; 4559 : 				}
; 4560 : 				else

  00f4b	e9 4f f9 ff ff	 jmp	 $LN58@CGItemDrop
$LN104@CGItemDrop:

; 4561 : 				{
; 4562 : 					pResult.Result = false;

  00f50	c6 45 9f 00	 mov	 BYTE PTR _pResult$[ebp+3], 0
  00f54	e9 46 f9 ff ff	 jmp	 $LN58@CGItemDrop
$LN65@CGItemDrop:

; 4351 : 			{
; 4352 : 				gObjInventoryDeleteItem(aIndex, lpMsg->Ipos);

  00f59	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  00f5d	50		 push	 eax
  00f5e	56		 push	 esi
  00f5f	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem

; 4353 : 				PMSG_SERVERCMD ServerCmd = { 0 };

  00f64	33 c0		 xor	 eax, eax
  00f66	c6 45 84 00	 mov	 BYTE PTR _ServerCmd$9[ebp], 0

; 4354 : 				PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));

  00f6a	6a 07		 push	 7
  00f6c	6a 40		 push	 64			; 00000040H
  00f6e	89 45 85	 mov	 DWORD PTR _ServerCmd$9[ebp+1], eax
  00f71	66 89 45 89	 mov	 WORD PTR _ServerCmd$9[ebp+5], ax
  00f75	8d 45 84	 lea	 eax, DWORD PTR _ServerCmd$9[ebp]
  00f78	68 f3 00 00 00	 push	 243			; 000000f3H
  00f7d	50		 push	 eax
  00f7e	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 4355 : 				ServerCmd.CmdType = 0;
; 4356 : 				ServerCmd.X = lpObj->X;

  00f83	8a 83 20 01 00
	00		 mov	 al, BYTE PTR [ebx+288]
  00f89	88 45 89	 mov	 BYTE PTR _ServerCmd$9[ebp+5], al

; 4357 : 				ServerCmd.Y = lpObj->Y;

  00f8c	8a 83 21 01 00
	00		 mov	 al, BYTE PTR [ebx+289]
  00f92	88 45 8a	 mov	 BYTE PTR _ServerCmd$9[ebp+6], al

; 4358 : 				MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00f95	8d 45 84	 lea	 eax, DWORD PTR _ServerCmd$9[ebp]
  00f98	6a 07		 push	 7
  00f9a	50		 push	 eax
  00f9b	53		 push	 ebx
  00f9c	c6 45 88 00	 mov	 BYTE PTR _ServerCmd$9[ebp+4], 0
  00fa0	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 4359 : 				DataSend(aIndex, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  00fa5	6a 07		 push	 7
  00fa7	8d 45 84	 lea	 eax, DWORD PTR _ServerCmd$9[ebp]
  00faa	50		 push	 eax
  00fab	56		 push	 esi
  00fac	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 4360 : 				LogAddTD("[%s][%s][%d]%d/%d Used Fireworks:%u (%s:%d/level:%d/skill:%d/op2:%d/op3:%d)",

  00fb1	0f b6 85 70 ff
	ff ff		 movzx	 eax, BYTE PTR _Option3$7[ebp]
  00fb8	50		 push	 eax
  00fb9	0f b6 85 6c ff
	ff ff		 movzx	 eax, BYTE PTR _Option2$6[ebp]
  00fc0	50		 push	 eax
  00fc1	0f b6 85 68 ff
	ff ff		 movzx	 eax, BYTE PTR _Option1$5[ebp]
  00fc8	50		 push	 eax
  00fc9	ff 75 90	 push	 DWORD PTR _level$1$[ebp]
  00fcc	8d 45 b8	 lea	 eax, DWORD PTR _szItemName$11[ebp]
  00fcf	ff b5 7c ff ff
	ff		 push	 DWORD PTR _type$1$[ebp]
  00fd5	50		 push	 eax
  00fd6	ff b5 78 ff ff
	ff		 push	 DWORD PTR _serial$1$[ebp]
  00fdc	0f b6 83 21 01
	00 00		 movzx	 eax, BYTE PTR [ebx+289]
  00fe3	50		 push	 eax
  00fe4	0f b6 83 20 01
	00 00		 movzx	 eax, BYTE PTR [ebx+288]
  00feb	50		 push	 eax
  00fec	0f b6 83 23 01
	00 00		 movzx	 eax, BYTE PTR [ebx+291]
  00ff3	50		 push	 eax
  00ff4	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00ff7	50		 push	 eax
  00ff8	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00ffb	50		 push	 eax
  00ffc	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@HPFBFIFH@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFd?$FN?$CFd?1?$CFd?5Used?5Fireworks@
  01001	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01007	83 c4 64	 add	 esp, 100		; 00000064H

; 4563 : 				}
; 4564 : 			}
; 4565 : 		}
; 4566 : 		else	// bIsItem

  0100a	e9 90 f8 ff ff	 jmp	 $LN58@CGItemDrop
  0100f	90		 npad	 1
$LN136@CGItemDrop:

; 4605 : }

  01010	00 00 00 00	 DD	 $LN68@CGItemDrop
  01014	00 00 00 00	 DD	 $LN73@CGItemDrop
  01018	00 00 00 00	 DD	 $LN73@CGItemDrop
  0101c	00 00 00 00	 DD	 $LN73@CGItemDrop
  01020	00 00 00 00	 DD	 $LN58@CGItemDrop
  01024	00 00 00 00	 DD	 $LN74@CGItemDrop
?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ENDP	; CGItemDropRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z
_TEXT	SEGMENT
_Bridge$1$ = -252					; size = 4
tv3283 = -252						; size = 4
_level$1$ = -248					; size = 4
tv3272 = -244						; size = 4
_type$1$ = -240						; size = 4
tv3270 = -240						; size = 4
_aIndex$GSCopy$1$ = -236				; size = 4
_Bridge$1$ = -236					; size = 4
_item_num$1$ = -232					; size = 4
_NewDur$1$ = -228					; size = 4
_pos$1$ = -228						; size = 4
_pos$1$ = -228						; size = 4
_n$1$ = -228						; size = 4
_n$1$ = -228						; size = 4
_map_num$1$ = -224					; size = 4
_i$1$ = -220						; size = 4
_NewDur$1$ = -220					; size = 4
_NewDur$1$ = -220					; size = 4
_pos$1$ = -220						; size = 4
tv3204 = -220						; size = 4
_pos$1$ = -216						; size = 4
_n$1$ = -216						; size = 4
_n$1$ = -216						; size = 4
_NewDur$1$ = -216					; size = 4
_n$1$ = -212						; size = 4
_pos$1$ = -212						; size = 4
_pos$1$ = -212						; size = 4
_pos$1$ = -212						; size = 4
_pos$1$ = -212						; size = 4
_pos$1$ = -212						; size = 4
_pos$1$ = -212						; size = 4
tv3212 = -212						; size = 4
tv3208 = -212						; size = 4
tv3206 = -212						; size = 4
_pos$1 = -212						; size = 1
_pResult$ = -208					; size = 16
_szTempMsg$2 = -192					; size = 128
_szItemName$ = -64					; size = 50
_NewOption$3 = -12					; size = 8
_NewOption$4 = -12					; size = 8
_NewOption$5 = -12					; size = 8
_NewOption$6 = -12					; size = 8
_NewOption$7 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z PROC	; CGItemGetRequest, COMDAT

; 3282 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]

; 3283 : 	int item_num, map_num;
; 3284 : 	PMSG_ITEMGETRESULT pResult;
; 3285 : 	int type;
; 3286 : 	int level;
; 3287 : 	int special;
; 3288 : 	int NOption;
; 3289 : 	char szItemName[50];
; 3290 : 	CMapItem * lpItem;
; 3291 : 
; 3292 : 	pResult.h.c = 0xC3;
; 3293 : 	pResult.h.headcode = 0x22;
; 3294 : 	pResult.h.size = sizeof(pResult);
; 3295 : 	pResult.result = -1;
; 3296 : 
; 3297 : 	if ( !gObjIsConnected(aIndex))

  0001b	56		 push	 esi
  0001c	89 b5 14 ff ff
	ff		 mov	 DWORD PTR _aIndex$GSCopy$1$[ebp], esi
  00022	c7 85 30 ff ff
	ff c3 10 22 ff	 mov	 DWORD PTR _pResult$[ebp], -14544701 ; ff2210c3H
  0002c	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00031	83 c4 04	 add	 esp, 4
  00034	85 c0		 test	 eax, eax
  00036	75 19		 jne	 SHORT $LN26@CGItemGetR

; 3298 : 	{
; 3299 : 		CloseClient(aIndex);

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0003e	83 c4 04	 add	 esp, 4
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi

; 4007 : 								map_num - (MAP_INDEX_ILLUSIONTEMPLE1 - 1),gObj[aIndex].AccountID,gObj[aIndex].Name,lpItem->m_Number);
; 4008 : 						}
; 4009 : #if (ENABLETEST_ARCA == 1)
; 4010 : 						if( g_ArcaBattle.IsArcaBattleServer() && lpItem->m_Type == AB_REW_KILL_TROPHY )
; 4011 : 						{
; 4012 : 							g_ArcaBattle.BootyItemGetCnt(gObj[aIndex]);
; 4013 : 						}
; 4014 : #endif
; 4015 : 					}
; 4016 : 				}
; 4017 : 				else
; 4018 : 				{
; 4019 : 					pResult.result = -1;
; 4020 : 					pResult.h.size -= sizeof(pResult.Data);
; 4021 : 
; 4022 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4023 : 				}
; 4024 : 			}
; 4025 : 			else
; 4026 : 			{
; 4027 : 				pResult.result = -1;
; 4028 : 				pResult.h.size -= sizeof(pResult.Data);
; 4029 : 
; 4030 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4031 : 			}
; 4032 : 		}
; 4033 : 	}
; 4034 : 	else
; 4035 : 	{
; 4036 : 		pResult.h.size -= sizeof(pResult.Data);
; 4037 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 4038 : 	}
; 4039 : }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	33 cd		 xor	 ecx, ebp
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
$LN26@CGItemGetR:

; 3300 : 		return;
; 3301 : 	}
; 3302 : 
; 3303 : 	if ( gObj[aIndex].CloseType != -1 )

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	53		 push	 ebx
  00057	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  0005d	89 9d 04 ff ff
	ff		 mov	 DWORD PTR tv3283[ebp], ebx
  00063	80 7c 03 0d ff	 cmp	 BYTE PTR [ebx+eax+13], -1
  00068	0f 85 ca 17 00
	00		 jne	 $LN246@CGItemGetR

; 3304 : 		return;
; 3305 : 
; 3306 : 	if ( gObj[aIndex].DieRegen != 0 )

  0006e	80 bc 03 8a 05
	00 00 00	 cmp	 BYTE PTR [ebx+eax+1418], 0
  00076	0f 85 7d 01 00
	00		 jne	 $LN108@CGItemGetR

; 3307 : 	{
; 3308 : 		pResult.result = -1;
; 3309 : 		pResult.h.size -= sizeof(pResult.Data);
; 3310 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 3311 : 
; 3312 : 		return;
; 3313 : 	}
; 3314 : 
; 3315 : 	if ( gObj[aIndex].m_IfState.use != 0 )

  0007c	8b 84 03 b8 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4536]
  00083	a8 03		 test	 al, 3
  00085	74 29		 je	 SHORT $LN30@CGItemGetR

; 3316 : 	{
; 3317 : 		if ( gObj[aIndex].m_IfState.type != 3 )

  00087	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0008c	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00091	74 1d		 je	 SHORT $LN30@CGItemGetR

; 3318 : 		{
; 3319 : 			::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 94)), aIndex, 1);

  00093	6a 01		 push	 1
  00095	56		 push	 esi
  00096	68 5e 04 00 00	 push	 1118			; 0000045eH
  0009b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000a0	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 3320 : 			pResult.result = -1;
; 3321 : 			pResult.h.size -= sizeof(pResult.Data);
; 3322 : 			DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 3323 : 
; 3324 : 			return;

  000ab	e9 5f 17 00 00	 jmp	 $LN247@CGItemGetR
$LN30@CGItemGetR:

; 3325 : 		}
; 3326 : 	}
; 3327 : 
; 3328 : 	if ( !::gObjFixInventoryPointer(aIndex))

  000b0	56		 push	 esi
  000b1	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  000b6	83 c4 04	 add	 esp, 4
  000b9	84 c0		 test	 al, al
  000bb	75 18		 jne	 SHORT $LN31@CGItemGetR

; 3329 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  000bd	68 01 0d 00 00	 push	 3329			; 00000d01H
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5?$CF@
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@CGItemGetR:

; 3330 : 
; 3331 : 	if ( gObj[aIndex].pTransaction == TRUE )

  000d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000db	80 bc 13 cc 11
	00 00 01	 cmp	 BYTE PTR [ebx+edx+4556], 1
  000e3	75 3b		 jne	 SHORT $LN32@CGItemGetR

; 3332 : 	{
; 3333 : 		LogAddTD("[%s][%s] CGItemGetRequest() Failed : Transaction == 1, IF_TYPE : %d",

  000e5	8b 84 13 b8 11
	00 00		 mov	 eax, DWORD PTR [ebx+edx+4536]
  000ec	c1 e8 06	 shr	 eax, 6
  000ef	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  000f4	50		 push	 eax
  000f5	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  000f8	03 c3		 add	 eax, ebx
  000fa	50		 push	 eax
  000fb	8d 42 52	 lea	 eax, DWORD PTR [edx+82]
  000fe	03 c3		 add	 eax, ebx
  00100	50		 push	 eax
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@JLFGKDAP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CGItemGetRequest?$CI?$CJ?5Fail@
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0010c	83 c4 10	 add	 esp, 16			; 00000010H
  0010f	5b		 pop	 ebx
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi

; 4007 : 								map_num - (MAP_INDEX_ILLUSIONTEMPLE1 - 1),gObj[aIndex].AccountID,gObj[aIndex].Name,lpItem->m_Number);
; 4008 : 						}
; 4009 : #if (ENABLETEST_ARCA == 1)
; 4010 : 						if( g_ArcaBattle.IsArcaBattleServer() && lpItem->m_Type == AB_REW_KILL_TROPHY )
; 4011 : 						{
; 4012 : 							g_ArcaBattle.BootyItemGetCnt(gObj[aIndex]);
; 4013 : 						}
; 4014 : #endif
; 4015 : 					}
; 4016 : 				}
; 4017 : 				else
; 4018 : 				{
; 4019 : 					pResult.result = -1;
; 4020 : 					pResult.h.size -= sizeof(pResult.Data);
; 4021 : 
; 4022 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4023 : 				}
; 4024 : 			}
; 4025 : 			else
; 4026 : 			{
; 4027 : 				pResult.result = -1;
; 4028 : 				pResult.h.size -= sizeof(pResult.Data);
; 4029 : 
; 4030 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4031 : 			}
; 4032 : 		}
; 4033 : 	}
; 4034 : 	else
; 4035 : 	{
; 4036 : 		pResult.h.size -= sizeof(pResult.Data);
; 4037 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 4038 : 	}
; 4039 : }

  00112	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	33 cd		 xor	 ecx, ebp
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN32@CGItemGetR:

; 3334 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].m_IfState.type);
; 3335 : 		return;
; 3336 : 
; 3337 : 	}
; 3338 : 
; 3339 : 	item_num = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);

  00120	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00124	66 c1 e0 08	 shl	 ax, 8
  00128	0f b7 c8	 movzx	 ecx, ax
  0012b	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0012f	0b c8		 or	 ecx, eax
  00131	89 8d 18 ff ff
	ff		 mov	 DWORD PTR _item_num$1$[ebp], ecx

; 3340 : 
; 3341 : 	if ( MAX_ITEM_TYPE_RANGE(item_num) == FALSE )

  00137	0f 8c bd 16 00
	00		 jl	 $LN226@CGItemGetR
  0013d	33 c0		 xor	 eax, eax
  0013f	81 f9 2b 01 00
	00		 cmp	 ecx, 299		; 0000012bH
  00145	0f 9e c0	 setle	 al
  00148	85 c0		 test	 eax, eax
  0014a	0f 84 aa 16 00
	00		 je	 $LN226@CGItemGetR

; 3347 : 
; 3348 : 		return;
; 3349 : 	}
; 3350 : 
; 3351 : 	map_num = gObj[aIndex].MapNumber;

  00150	0f b6 94 13 23
	01 00 00	 movzx	 edx, BYTE PTR [ebx+edx+291]
  00158	89 95 20 ff ff
	ff		 mov	 DWORD PTR _map_num$1$[ebp], edx

; 3352 : 
; 3353 : 	if ( MAX_MAP_RANGE(map_num) == FALSE )

  0015e	85 d2		 test	 edx, edx
  00160	0f 88 8d 16 00
	00		 js	 $LN227@CGItemGetR
  00166	33 c0		 xor	 eax, eax
  00168	83 fa 63	 cmp	 edx, 99			; 00000063H
  0016b	0f 9e c0	 setle	 al
  0016e	85 c0		 test	 eax, eax
  00170	0f 84 7d 16 00
	00		 je	 $LN227@CGItemGetR

; 3361 : 	}
; 3362 : 
; 3363 : 	lpItem = &MapC[map_num].m_cItem[item_num];

  00176	69 d2 28 38 05
	00		 imul	 edx, edx, 342056
  0017c	69 c1 74 04 00
	00		 imul	 eax, ecx, 1140
  00182	89 95 0c ff ff
	ff		 mov	 DWORD PTR tv3272[ebp], edx
  00188	8d ba 20 00 00
	00		 lea	 edi, DWORD PTR ?MapC@@3PAVMapClass@@A[edx+32]
  0018e	03 f8		 add	 edi, eax

; 3364 : 
; 3365 : 	if ( lpItem->IsItem() == TRUE && lpItem->Give == false && lpItem->live == true)

  00190	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00193	8b c8		 mov	 ecx, eax
  00195	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv3270[ebp], eax
  0019b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001a0	83 f8 01	 cmp	 eax, 1
  001a3	75 5b		 jne	 SHORT $LN35@CGItemGetR
  001a5	80 bf db 00 00
	00 00		 cmp	 BYTE PTR [edi+219], 0
  001ac	75 52		 jne	 SHORT $LN35@CGItemGetR
  001ae	38 87 da 00 00
	00		 cmp	 BYTE PTR [edi+218], al
  001b4	75 4a		 jne	 SHORT $LN35@CGItemGetR

; 3366 : 	{
; 3367 : 		if ( lpItem->m_QuestItem != false )

  001b6	80 bf ad 00 00
	00 00		 cmp	 BYTE PTR [edi+173], 0
  001bd	74 19		 je	 SHORT $LN38@CGItemGetR

; 3368 : 		{
; 3369 : 			int bResult = g_QuestInfo.CheckItemCount(aIndex,lpItem->m_Type,lpItem->m_Level);

  001bf	0f b7 47 0c	 movzx	 eax, WORD PTR [edi+12]
  001c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  001c8	50		 push	 eax
  001c9	0f b7 47 0a	 movzx	 eax, WORD PTR [edi+10]
  001cd	50		 push	 eax
  001ce	56		 push	 esi
  001cf	e8 00 00 00 00	 call	 ?CheckItemCount@CQuestInfo@@QAEHHFF@Z ; CQuestInfo::CheckItemCount

; 3370 : 
; 3371 : 			if ( bResult == FALSE )

  001d4	85 c0		 test	 eax, eax
  001d6	74 21		 je	 SHORT $LN108@CGItemGetR
$LN38@CGItemGetR:

; 3372 : 			{
; 3373 : 				pResult.result = -1;
; 3374 : 				pResult.h.size -= sizeof(pResult.Data);
; 3375 : 
; 3376 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3377 : 				return;
; 3378 : 			}
; 3379 : 		}
; 3380 : 
; 3381 : 		if ( lpItem->m_Type == ITEMGET(13,20) )	// Wizard Ring

  001d8	b8 14 1a 00 00	 mov	 eax, 6676		; 00001a14H
  001dd	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  001e1	0f 85 c5 00 00
	00		 jne	 $LN41@CGItemGetR

; 3382 : 		{
; 3383 : 			switch ( lpItem->m_Level )

  001e7	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  001eb	83 e8 00	 sub	 eax, 0
  001ee	74 43		 je	 SHORT $LN40@CGItemGetR
  001f0	83 e8 01	 sub	 eax, 1
  001f3	0f 85 b3 00 00
	00		 jne	 $LN41@CGItemGetR
$LN108@CGItemGetR:

; 3401 : 					}
; 3402 : 					break;
; 3403 : 				}
; 3404 : 				case 1:
; 3405 : 
; 3406 : 					pResult.result = -1;

  001f9	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
$LN35@CGItemGetR:

; 3407 : 					pResult.h.size -= sizeof(pResult.Data);

  00200	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00206	04 f4		 add	 al, 244			; 000000f4H
$LN255@CGItemGetR:
  00208	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
$LN50@CGItemGetR:

; 3408 : 
; 3409 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  0020e	0f b6 c0	 movzx	 eax, al
$LN252@CGItemGetR:
  00211	50		 push	 eax
  00212	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00218	50		 push	 eax
  00219	56		 push	 esi
  0021a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00222	5b		 pop	 ebx
  00223	5f		 pop	 edi
  00224	5e		 pop	 esi

; 4007 : 								map_num - (MAP_INDEX_ILLUSIONTEMPLE1 - 1),gObj[aIndex].AccountID,gObj[aIndex].Name,lpItem->m_Number);
; 4008 : 						}
; 4009 : #if (ENABLETEST_ARCA == 1)
; 4010 : 						if( g_ArcaBattle.IsArcaBattleServer() && lpItem->m_Type == AB_REW_KILL_TROPHY )
; 4011 : 						{
; 4012 : 							g_ArcaBattle.BootyItemGetCnt(gObj[aIndex]);
; 4013 : 						}
; 4014 : #endif
; 4015 : 					}
; 4016 : 				}
; 4017 : 				else
; 4018 : 				{
; 4019 : 					pResult.result = -1;
; 4020 : 					pResult.h.size -= sizeof(pResult.Data);
; 4021 : 
; 4022 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4023 : 				}
; 4024 : 			}
; 4025 : 			else
; 4026 : 			{
; 4027 : 				pResult.result = -1;
; 4028 : 				pResult.h.size -= sizeof(pResult.Data);
; 4029 : 
; 4030 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4031 : 			}
; 4032 : 		}
; 4033 : 	}
; 4034 : 	else
; 4035 : 	{
; 4036 : 		pResult.h.size -= sizeof(pResult.Data);
; 4037 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 4038 : 	}
; 4039 : }

  00225	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00228	33 cd		 xor	 ecx, ebp
  0022a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c3		 ret	 0
$LN40@CGItemGetR:

; 3384 : 			{
; 3385 : 				case 0:
; 3386 : 				{
; 3387 : 					int iWRCount = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_SUBTYPE_ITEMS, lpItem->m_Type%MAX_SUBTYPE_ITEMS, lpItem->m_Level);

  00233	6a 00		 push	 0
  00235	6a 14		 push	 20			; 00000014H
  00237	6a 0d		 push	 13			; 0000000dH
  00239	56		 push	 esi
  0023a	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  0023f	83 c4 10	 add	 esp, 16			; 00000010H

; 3388 : 
; 3389 : 					if ( iWRCount > 0 )

  00242	85 c0		 test	 eax, eax
  00244	7e 66		 jle	 SHORT $LN41@CGItemGetR

; 3390 : 					{
; 3391 : 						LogAdd("[Ring Event] Too many have Magician's Ring [%s][%s] (Name:%s, Count:%d)",

  00246	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv3270[ebp]
  0024c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00258	50		 push	 eax
  00259	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0025c	03 c3		 add	 eax, ebx
  0025e	50		 push	 eax
  0025f	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00262	03 c3		 add	 eax, ebx
  00264	50		 push	 eax
  00265	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@IFAFBJMM@?$FLRing?5Event?$FN?5Too?5many?5have?5Magic@
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 3392 : 							gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), iWRCount);
; 3393 : 
; 3394 : 						pResult.result = -1;
; 3395 : 						pResult.h.size -= sizeof(pResult.Data);

  00270	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]

; 3396 : 
; 3397 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00276	8b b5 14 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  0027c	04 f4		 add	 al, 244			; 000000f4H
  0027e	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  00284	0f b6 c0	 movzx	 eax, al
  00287	50		 push	 eax
  00288	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  0028e	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00295	50		 push	 eax
  00296	56		 push	 esi
  00297	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0029c	83 c4 20	 add	 esp, 32			; 00000020H

; 3398 : 						::GCServerMsgStringSend(lMsg.Get(MSGGET(4, 186)), aIndex, 1);

  0029f	6a 01		 push	 1
  002a1	56		 push	 esi
  002a2	68 ba 04 00 00	 push	 1210			; 000004baH

; 3399 : 
; 3400 : 						return;

  002a7	e9 29 01 00 00	 jmp	 $LN254@CGItemGetR
$LN41@CGItemGetR:

; 3410 : 					return;
; 3411 : 				
; 3412 : 			}
; 3413 : 		}
; 3414 : 
; 3415 : 		if ( lpItem->m_Type == ITEMGET(13,20) && lpItem->m_Level == 2 )	// Wizard Ring

  002ac	0f b7 47 0a	 movzx	 eax, WORD PTR [edi+10]
  002b0	b9 14 1a 00 00	 mov	 ecx, 6676		; 00001a14H
  002b5	66 3b c1	 cmp	 ax, cx
  002b8	75 0b		 jne	 SHORT $LN43@CGItemGetR
  002ba	66 83 7f 0c 02	 cmp	 WORD PTR [edi+12], 2
  002bf	0f 84 34 ff ff
	ff		 je	 $LN108@CGItemGetR
$LN43@CGItemGetR:

; 3416 : 		{
; 3417 : 			pResult.result = -1;
; 3418 : 			pResult.h.size -= sizeof(pResult.Data);
; 3419 : 
; 3420 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			
; 3421 : 
; 3422 : 			return;
; 3423 : 		}
; 3424 : 
; 3425 : 		if ( lpItem->m_Type == ITEMGET(13,38) )	// MoonStonePendant

  002c5	b9 26 1a 00 00	 mov	 ecx, 6694		; 00001a26H
  002ca	66 3b c1	 cmp	 ax, cx
  002cd	75 7c		 jne	 SHORT $LN45@CGItemGetR

; 3426 : 		{
; 3427 : 			int count = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_SUBTYPE_ITEMS,

  002cf	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  002d3	50		 push	 eax
  002d4	6a 26		 push	 38			; 00000026H
  002d6	6a 0d		 push	 13			; 0000000dH
  002d8	56		 push	 esi
  002d9	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  002de	83 c4 10	 add	 esp, 16			; 00000010H

; 3428 : 				lpItem->m_Type % MAX_SUBTYPE_ITEMS, lpItem->m_Level);
; 3429 : 
; 3430 : 			if ( count > 0 )

  002e1	85 c0		 test	 eax, eax
  002e3	7e 66		 jle	 SHORT $LN45@CGItemGetR

; 3431 : 			{
; 3432 : 				LogAdd("[ MoonStonePendant ] Too many have MoonStonePendant [%s][%s] ( Name:%s, Count:%d )",

  002e5	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv3270[ebp]
  002eb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002f1	50		 push	 eax
  002f2	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  002f7	50		 push	 eax
  002f8	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  002fb	03 c3		 add	 eax, ebx
  002fd	50		 push	 eax
  002fe	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00301	03 c3		 add	 eax, ebx
  00303	50		 push	 eax
  00304	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@GAPCMOG@?$FL?5MoonStonePendant?5?$FN?5Too?5many?5ha@
  00309	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 3433 : 					gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), count);
; 3434 : 
; 3435 : 				pResult.result = -1;
; 3436 : 				pResult.h.size -= sizeof(pResult.Data);

  0030f	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]

; 3437 : 
; 3438 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);	

  00315	8b b5 14 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  0031b	04 f4		 add	 al, 244			; 000000f4H
  0031d	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  00323	0f b6 c0	 movzx	 eax, al
  00326	50		 push	 eax
  00327	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  0032d	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  00334	50		 push	 eax
  00335	56		 push	 esi
  00336	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0033b	83 c4 20	 add	 esp, 32			; 00000020H

; 3439 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(13, 56)), aIndex, 1);

  0033e	6a 01		 push	 1
  00340	56		 push	 esi
  00341	68 38 0d 00 00	 push	 3384			; 00000d38H

; 3440 : 
; 3441 : 				return;

  00346	e9 8a 00 00 00	 jmp	 $LN254@CGItemGetR
$LN45@CGItemGetR:

; 3442 : 			}
; 3443 : 		}
; 3444 : 
; 3445 : 		if ( lpItem->m_Type == ITEMGET(13,39) )	// ChangeRing

  0034b	b8 27 1a 00 00	 mov	 eax, 6695		; 00001a27H
  00350	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  00354	0f 85 9f 00 00
	00		 jne	 $LN47@CGItemGetR

; 3446 : 		{
; 3447 : 			int count = gObjGetItemCountInIventory(aIndex, lpItem->m_Type/MAX_SUBTYPE_ITEMS,

  0035a	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  0035e	50		 push	 eax
  0035f	6a 27		 push	 39			; 00000027H
  00361	6a 0d		 push	 13			; 0000000dH
  00363	56		 push	 esi
  00364	e8 00 00 00 00	 call	 ?gObjGetItemCountInIventory@@YAHHHHH@Z ; gObjGetItemCountInIventory
  00369	83 c4 10	 add	 esp, 16			; 00000010H

; 3448 : 				lpItem->m_Type % MAX_SUBTYPE_ITEMS, lpItem->m_Level);
; 3449 : 
; 3450 : 			if ( count > 0 )

  0036c	85 c0		 test	 eax, eax
  0036e	0f 8e 85 00 00
	00		 jle	 $LN47@CGItemGetR

; 3451 : 			{
; 3452 : 				LogAdd("[ ChangeRing ] Too many have ChangeRing [%s][%s] ( Name:%s, Count:%d )",

  00374	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv3270[ebp]
  0037a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00386	50		 push	 eax
  00387	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0038a	03 c3		 add	 eax, ebx
  0038c	50		 push	 eax
  0038d	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00390	03 c3		 add	 eax, ebx
  00392	50		 push	 eax
  00393	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@LLDKIPIA@?$FL?5ChangeRing?5?$FN?5Too?5many?5have?5Cha@
  00398	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 3453 : 					gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->GetName(), count);
; 3454 : 
; 3455 : 				pResult.result = -1;
; 3456 : 				pResult.h.size -= sizeof(pResult.Data);

  0039e	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]

; 3457 : 
; 3458 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);	

  003a4	8b b5 14 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  003aa	04 f4		 add	 al, 244			; 000000f4H
  003ac	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al
  003b2	0f b6 c0	 movzx	 eax, al
  003b5	50		 push	 eax
  003b6	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  003bc	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  003c3	50		 push	 eax
  003c4	56		 push	 esi
  003c5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  003ca	83 c4 20	 add	 esp, 32			; 00000020H

; 3459 : 				GCServerMsgStringSend(lMsg.Get(MSGGET(13, 63)), aIndex, 1);

  003cd	6a 01		 push	 1
  003cf	56		 push	 esi
  003d0	68 3f 0d 00 00	 push	 3391			; 00000d3fH
$LN254@CGItemGetR:
  003d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003da	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003df	50		 push	 eax
  003e0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e8	5b		 pop	 ebx
  003e9	5f		 pop	 edi
  003ea	5e		 pop	 esi

; 4007 : 								map_num - (MAP_INDEX_ILLUSIONTEMPLE1 - 1),gObj[aIndex].AccountID,gObj[aIndex].Name,lpItem->m_Number);
; 4008 : 						}
; 4009 : #if (ENABLETEST_ARCA == 1)
; 4010 : 						if( g_ArcaBattle.IsArcaBattleServer() && lpItem->m_Type == AB_REW_KILL_TROPHY )
; 4011 : 						{
; 4012 : 							g_ArcaBattle.BootyItemGetCnt(gObj[aIndex]);
; 4013 : 						}
; 4014 : #endif
; 4015 : 					}
; 4016 : 				}
; 4017 : 				else
; 4018 : 				{
; 4019 : 					pResult.result = -1;
; 4020 : 					pResult.h.size -= sizeof(pResult.Data);
; 4021 : 
; 4022 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4023 : 				}
; 4024 : 			}
; 4025 : 			else
; 4026 : 			{
; 4027 : 				pResult.result = -1;
; 4028 : 				pResult.h.size -= sizeof(pResult.Data);
; 4029 : 
; 4030 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4031 : 			}
; 4032 : 		}
; 4033 : 	}
; 4034 : 	else
; 4035 : 	{
; 4036 : 		pResult.h.size -= sizeof(pResult.Data);
; 4037 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 4038 : 	}
; 4039 : }

  003eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ee	33 cd		 xor	 ecx, ebp
  003f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f5	8b e5		 mov	 esp, ebp
  003f7	5d		 pop	 ebp
  003f8	c3		 ret	 0
$LN47@CGItemGetR:

; 3460 : 
; 3461 : 				return;
; 3462 : 			}
; 3463 : 		}
; 3464 : 
; 3465 : 		type = lpItem->m_Type;

  003f9	0f bf 47 0a	 movsx	 eax, WORD PTR [edi+10]

; 3466 : 		level = lpItem->m_Level;
; 3467 : 		special = lpItem->m_Special[0];
; 3468 : 		NOption = lpItem->m_NewOption;
; 3469 : 		strcpy(szItemName, lpItem->GetName());

  003fd	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00400	89 85 10 ff ff
	ff		 mov	 DWORD PTR _type$1$[ebp], eax
  00406	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  0040a	89 85 08 ff ff
	ff		 mov	 DWORD PTR _level$1$[ebp], eax
  00410	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00415	8d 55 c0	 lea	 edx, DWORD PTR _szItemName$[ebp]
  00418	2b d0		 sub	 edx, eax
  0041a	66 0f 1f 44 00
	00		 npad	 6
$LL127@CGItemGetR:
  00420	8a 08		 mov	 cl, BYTE PTR [eax]
  00422	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00425	88 4c 02 ff	 mov	 BYTE PTR [edx+eax-1], cl
  00429	84 c9		 test	 cl, cl
  0042b	75 f3		 jne	 SHORT $LL127@CGItemGetR

; 3470 : 
; 3471 : 		if ( lpItem->m_Type == ITEMGET(14,15) ) // Zen

  0042d	0f b7 47 0a	 movzx	 eax, WORD PTR [edi+10]
  00431	b9 0f 1c 00 00	 mov	 ecx, 7183		; 00001c0fH
  00436	66 3b c1	 cmp	 ax, cx
  00439	0f 85 04 01 00
	00		 jne	 $LN48@CGItemGetR

; 3472 : 		{
; 3473 : 			if ( MapC[map_num].ItemGive(aIndex, item_num, false) == TRUE )

  0043f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv3272[ebp]
  00445	6a 00		 push	 0
  00447	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  0044d	56		 push	 esi
  0044e	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  00454	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00459	83 f8 01	 cmp	 eax, 1
  0045c	0f 85 d6 00 00
	00		 jne	 $LN239@CGItemGetR

; 3474 : 			{
; 3475 : 				if ( !gObjCheckMaxZen(aIndex, lpItem->m_BuyMoney))

  00462	ff 77 7c	 push	 DWORD PTR [edi+124]
  00465	56		 push	 esi
  00466	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  0046b	83 c4 08	 add	 esp, 8
  0046e	85 c0		 test	 eax, eax
  00470	75 6b		 jne	 SHORT $LN51@CGItemGetR

; 3476 : 				{
; 3477 : 					if ( gObj[aIndex].Money < MAX_ZEN )

  00472	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00477	81 bc 03 cc 00
	00 00 00 94 35
	77		 cmp	 DWORD PTR [ebx+eax+204], 2000000000 ; 77359400H
  00482	0f 8d 71 fd ff
	ff		 jge	 $LN108@CGItemGetR

; 3478 : 					{
; 3479 : 						gObj[aIndex].Money = MAX_ZEN;

  00488	c7 84 03 cc 00
	00 00 00 94 35
	77		 mov	 DWORD PTR [ebx+eax+204], 2000000000 ; 77359400H

; 3480 : 						pResult.result = -2;
; 3481 : 						WORD hiWord = SET_NUMBERHW(gObj[aIndex].Money);

  00493	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00498	c6 85 33 ff ff
	ff fe		 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH
  0049f	0f b7 8c 03 ce
	00 00 00	 movzx	 ecx, WORD PTR [ebx+eax+206]

; 3482 : 						WORD loWord = SET_NUMBERLW(gObj[aIndex].Money);

  004a7	0f b7 94 03 cc
	00 00 00	 movzx	 edx, WORD PTR [ebx+eax+204]

; 3483 : 						pResult.Data[0] = SET_NUMBERH(hiWord);

  004af	8b c1		 mov	 eax, ecx
  004b1	c1 e8 08	 shr	 eax, 8
  004b4	88 85 34 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+4], al

; 3484 : 						pResult.Data[1] = SET_NUMBERL(hiWord);
; 3485 : 						pResult.Data[2] = SET_NUMBERH(loWord);

  004ba	8b c2		 mov	 eax, edx
  004bc	c1 e8 08	 shr	 eax, 8
  004bf	88 85 36 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+6], al

; 3486 : 						pResult.Data[3] = SET_NUMBERL(loWord);
; 3487 : 
; 3488 : 						DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  004c5	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  004cc	88 8d 35 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+5], cl
  004d2	88 95 37 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+7], dl

; 3489 : 
; 3490 : 						return;

  004d8	e9 34 fd ff ff	 jmp	 $LN252@CGItemGetR
$LN51@CGItemGetR:

; 3491 : 					}
; 3492 : 
; 3493 : 					pResult.result = -1;
; 3494 : 					pResult.h.size -= sizeof(pResult.Data);
; 3495 : 
; 3496 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			
; 3497 : 
; 3498 : 					return;
; 3499 : 				}
; 3500 : 
; 3501 : 				gObj[aIndex].Money += lpItem->m_BuyMoney;

  004dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004e3	8b 47 7c	 mov	 eax, DWORD PTR [edi+124]
  004e6	01 84 0b cc 00
	00 00		 add	 DWORD PTR [ebx+ecx+204], eax

; 3502 : 				pResult.result = -2;
; 3503 : 
; 3504 : 				WORD hiWord = SET_NUMBERHW(gObj[aIndex].Money);

  004ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004f2	c6 85 33 ff ff
	ff fe		 mov	 BYTE PTR _pResult$[ebp+3], 254 ; 000000feH
  004f9	0f b7 8c 03 ce
	00 00 00	 movzx	 ecx, WORD PTR [ebx+eax+206]

; 3505 : 				WORD loWord = SET_NUMBERLW(gObj[aIndex].Money);

  00501	0f b7 94 03 cc
	00 00 00	 movzx	 edx, WORD PTR [ebx+eax+204]

; 3506 : 				pResult.Data[0] = SET_NUMBERH(hiWord);

  00509	8b c1		 mov	 eax, ecx
  0050b	c1 e8 08	 shr	 eax, 8
  0050e	88 85 34 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+4], al

; 3507 : 				pResult.Data[1] = SET_NUMBERL(hiWord);
; 3508 : 				pResult.Data[2] = SET_NUMBERH(loWord);

  00514	8b c2		 mov	 eax, edx
  00516	c1 e8 08	 shr	 eax, 8
  00519	88 85 36 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+6], al

; 3509 : 				pResult.Data[3] = SET_NUMBERL(loWord);
; 3510 : 				pResult.h.size -= 3;

  0051f	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  00525	88 8d 35 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+5], cl
  0052b	04 fd		 add	 al, 253			; 000000fdH
  0052d	88 95 37 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+7], dl
  00533	e9 d0 fc ff ff	 jmp	 $LN255@CGItemGetR
$LN239@CGItemGetR:
  00538	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]

; 3511 : 			}
; 3512 : 
; 3513 : 			DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3514 : 
; 3515 : 		}
; 3516 : 		else

  0053e	e9 cb fc ff ff	 jmp	 $LN50@CGItemGetR
$LN48@CGItemGetR:

; 3517 : 		{
; 3518 : 			if ( lpItem->m_Type == ITEMGET(13,32) )

  00543	b9 20 1a 00 00	 mov	 ecx, 6688		; 00001a20H
  00548	66 3b c1	 cmp	 ax, cx
  0054b	75 3a		 jne	 SHORT $LN54@CGItemGetR

; 3519 : 			{
; 3520 : 
; 3521 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 20, ITEMGET(13,32), 0);

  0054d	6a 00		 push	 0
  0054f	51		 push	 ecx
  00550	6a 14		 push	 20			; 00000014H
  00552	56		 push	 esi
  00553	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  00559	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0055c	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map_num$1$[ebp]
  00562	50		 push	 eax
  00563	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  00568	83 c4 1c	 add	 esp, 28			; 0000001cH
  0056b	89 85 2c ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], eax

; 3522 : 
; 3523 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  00571	85 c0		 test	 eax, eax
  00573	78 12		 js	 SHORT $LN54@CGItemGetR
  00575	33 c9		 xor	 ecx, ecx
  00577	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  0057c	0f 9e c1	 setle	 cl
  0057f	85 c9		 test	 ecx, ecx
  00581	0f 85 e6 04 00
	00		 jne	 $LN205@CGItemGetR
$LN54@CGItemGetR:

; 3524 : 				{
; 3525 : 					pResult.result = -3;
; 3526 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3527 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;
; 3528 : 					GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);
; 3529 : 
; 3530 : 					return;
; 3531 : 				}
; 3532 : 			}
; 3533 : 
; 3534 : 			if ( lpItem->m_Type == ITEMGET(13,33) )

  00587	b8 21 1a 00 00	 mov	 eax, 6689		; 00001a21H
  0058c	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  00590	75 3a		 jne	 SHORT $LN56@CGItemGetR

; 3535 : 			{
; 3536 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 20, ITEMGET(13,33), 0);

  00592	6a 00		 push	 0
  00594	50		 push	 eax
  00595	6a 14		 push	 20			; 00000014H
  00597	56		 push	 esi
  00598	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  0059e	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  005a1	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map_num$1$[ebp]
  005a7	50		 push	 eax
  005a8	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  005ad	83 c4 1c	 add	 esp, 28			; 0000001cH
  005b0	89 85 2c ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], eax

; 3537 : 
; 3538 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  005b6	85 c0		 test	 eax, eax
  005b8	78 12		 js	 SHORT $LN56@CGItemGetR
  005ba	33 c9		 xor	 ecx, ecx
  005bc	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  005c1	0f 9e c1	 setle	 cl
  005c4	85 c9		 test	 ecx, ecx
  005c6	0f 85 a1 04 00
	00		 jne	 $LN205@CGItemGetR
$LN56@CGItemGetR:

; 3539 : 				{
; 3540 : 					pResult.result = -3;
; 3541 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3542 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;
; 3543 : 					GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);
; 3544 : 
; 3545 : 					return;
; 3546 : 				}
; 3547 : 			}
; 3548 : 
; 3549 : 			if ( lpItem->m_Type == ITEMGET(13,34) )

  005cc	b8 22 1a 00 00	 mov	 eax, 6690		; 00001a22H
  005d1	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  005d5	75 3a		 jne	 SHORT $LN58@CGItemGetR

; 3550 : 			{
; 3551 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 10, ITEMGET(13,34), 0);

  005d7	6a 00		 push	 0
  005d9	50		 push	 eax
  005da	6a 0a		 push	 10			; 0000000aH
  005dc	56		 push	 esi
  005dd	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  005e3	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  005e6	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map_num$1$[ebp]
  005ec	50		 push	 eax
  005ed	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  005f2	83 c4 1c	 add	 esp, 28			; 0000001cH
  005f5	89 85 2c ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], eax

; 3552 : 
; 3553 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  005fb	85 c0		 test	 eax, eax
  005fd	78 12		 js	 SHORT $LN58@CGItemGetR
  005ff	33 c9		 xor	 ecx, ecx
  00601	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  00606	0f 9e c1	 setle	 cl
  00609	85 c9		 test	 ecx, ecx
  0060b	0f 85 5c 04 00
	00		 jne	 $LN205@CGItemGetR
$LN58@CGItemGetR:

; 3554 : 				{
; 3555 : 					pResult.result = -3;
; 3556 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3557 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;
; 3558 : 					GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);
; 3559 : 
; 3560 : 					return;
; 3561 : 				}
; 3562 : 			}
; 3563 : 
; 3564 : 			if ( lpItem->m_Type == ITEMGET(14,70) ||
; 3565 : 				 lpItem->m_Type == ITEMGET(14,71) ||

  00611	0f b7 47 0a	 movzx	 eax, WORD PTR [edi+10]
  00615	b9 46 1c 00 00	 mov	 ecx, 7238		; 00001c46H
  0061a	66 3b c1	 cmp	 ax, cx
  0061d	74 14		 je	 SHORT $LN60@CGItemGetR
  0061f	b9 47 1c 00 00	 mov	 ecx, 7239		; 00001c47H
  00624	66 3b c1	 cmp	 ax, cx
  00627	74 0a		 je	 SHORT $LN60@CGItemGetR
  00629	b9 5e 1c 00 00	 mov	 ecx, 7262		; 00001c5eH
  0062e	66 3b c1	 cmp	 ax, cx
  00631	75 3b		 jne	 SHORT $LN61@CGItemGetR
$LN60@CGItemGetR:

; 3566 : 				 lpItem->m_Type == ITEMGET(14,94) )
; 3567 : 			{
; 3568 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, 50, lpItem->m_Type, 0);

  00633	6a 00		 push	 0
  00635	98		 cwde
  00636	50		 push	 eax
  00637	6a 32		 push	 50			; 00000032H
  00639	56		 push	 esi
  0063a	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  00640	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00643	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map_num$1$[ebp]
  00649	50		 push	 eax
  0064a	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  0064f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00652	89 85 2c ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], eax

; 3569 : 
; 3570 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  00658	85 c0		 test	 eax, eax
  0065a	78 12		 js	 SHORT $LN61@CGItemGetR
  0065c	33 c9		 xor	 ecx, ecx
  0065e	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  00663	0f 9e c1	 setle	 cl
  00666	85 c9		 test	 ecx, ecx
  00668	0f 85 ff 03 00
	00		 jne	 $LN205@CGItemGetR
$LN61@CGItemGetR:

; 3571 : 				{
; 3572 : 					pResult.result = -3;
; 3573 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3574 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;
; 3575 : 					GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);
; 3576 : 
; 3577 : 					return;
; 3578 : 				}
; 3579 : 			}
; 3580 : 
; 3581 : 			if ( lpItem->m_Type == ITEMGET(14,88) ||
; 3582 : 				 lpItem->m_Type == ITEMGET(14,89) ||
; 3583 : 				 lpItem->m_Type == ITEMGET(14,90) ||
; 3584 : 				 lpItem->m_Type == ITEMGET(14,85) ||
; 3585 : 				 lpItem->m_Type == ITEMGET(14,86) ||

  0066e	0f b7 47 0a	 movzx	 eax, WORD PTR [edi+10]
  00672	b9 58 1c 00 00	 mov	 ecx, 7256		; 00001c58H
  00677	66 3b c1	 cmp	 ax, cx
  0067a	74 32		 je	 SHORT $LN63@CGItemGetR
  0067c	b9 59 1c 00 00	 mov	 ecx, 7257		; 00001c59H
  00681	66 3b c1	 cmp	 ax, cx
  00684	74 28		 je	 SHORT $LN63@CGItemGetR
  00686	b9 5a 1c 00 00	 mov	 ecx, 7258		; 00001c5aH
  0068b	66 3b c1	 cmp	 ax, cx
  0068e	74 1e		 je	 SHORT $LN63@CGItemGetR
  00690	b9 55 1c 00 00	 mov	 ecx, 7253		; 00001c55H
  00695	66 3b c1	 cmp	 ax, cx
  00698	74 14		 je	 SHORT $LN63@CGItemGetR
  0069a	b9 56 1c 00 00	 mov	 ecx, 7254		; 00001c56H
  0069f	66 3b c1	 cmp	 ax, cx
  006a2	74 0a		 je	 SHORT $LN63@CGItemGetR
  006a4	b9 57 1c 00 00	 mov	 ecx, 7255		; 00001c57H
  006a9	66 3b c1	 cmp	 ax, cx
  006ac	75 6d		 jne	 SHORT $LN70@CGItemGetR
$LN63@CGItemGetR:

; 3586 : 				 lpItem->m_Type == ITEMGET(14,87) )
; 3587 : 			{
; 3588 : 				int Dur = 1;
; 3589 : 
; 3590 : 				switch( lpItem->m_Type )

  006ae	0f bf d0	 movsx	 edx, ax
  006b1	b9 01 00 00 00	 mov	 ecx, 1
  006b6	8d 82 ab e3 ff
	ff		 lea	 eax, DWORD PTR [edx-7253]
  006bc	83 f8 05	 cmp	 eax, 5
  006bf	77 21		 ja	 SHORT $LN4@CGItemGetR
  006c1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN257@CGItemGetR[eax*4]
$LN64@CGItemGetR:

; 3591 : 				{
; 3592 : 				case ITEMGET(14,88):
; 3593 : 					Dur = 10;

  006c8	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH

; 3594 : 					break;

  006cd	eb 13		 jmp	 SHORT $LN4@CGItemGetR
$LN65@CGItemGetR:

; 3595 : 				case ITEMGET(14,89):
; 3596 : 					Dur = 30;

  006cf	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH

; 3597 : 					break;

  006d4	eb 0c		 jmp	 SHORT $LN4@CGItemGetR
$LN66@CGItemGetR:

; 3598 : 				case ITEMGET(14,90):
; 3599 : 					Dur = 255;

  006d6	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH

; 3600 : 					break;
; 3601 : 				case ITEMGET(14,85):
; 3602 : 					Dur = 3;
; 3603 : 					break;

  006db	eb 05		 jmp	 SHORT $LN4@CGItemGetR
$LN69@CGItemGetR:

; 3604 : 				case ITEMGET(14,86):
; 3605 : 					Dur = 3;
; 3606 : 					break;
; 3607 : 				case ITEMGET(14,87):
; 3608 : 					Dur = 3;

  006dd	b9 03 00 00 00	 mov	 ecx, 3
$LN4@CGItemGetR:

; 3609 : 					break;
; 3610 : 				}
; 3611 : 
; 3612 : 				int pos = gObjOverlapItemUsingDur((lpItem)?((CItem *)&lpItem->m_Number):NULL, map_num, item_num, aIndex, Dur, lpItem->m_Type, 0);

  006e2	6a 00		 push	 0
  006e4	52		 push	 edx
  006e5	51		 push	 ecx
  006e6	56		 push	 esi
  006e7	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  006ed	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  006f0	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map_num$1$[ebp]
  006f6	50		 push	 eax
  006f7	e8 00 00 00 00	 call	 ?gObjOverlapItemUsingDur@@YAHPAVCItem@@HHHHHH@Z ; gObjOverlapItemUsingDur
  006fc	83 c4 1c	 add	 esp, 28			; 0000001cH
  006ff	89 85 2c ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], eax

; 3613 : 
; 3614 : 				if ( MAIN_INVENTORY_RANGE(pos) != FALSE )

  00705	85 c0		 test	 eax, eax
  00707	78 12		 js	 SHORT $LN70@CGItemGetR
  00709	33 c9		 xor	 ecx, ecx
  0070b	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  00710	0f 9e c1	 setle	 cl
  00713	85 c9		 test	 ecx, ecx
  00715	0f 85 52 03 00
	00		 jne	 $LN205@CGItemGetR
$LN70@CGItemGetR:

; 3615 : 				{
; 3616 : 					pResult.result = -3;
; 3617 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 3618 : 					gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;
; 3619 : 					GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);
; 3620 : 
; 3621 : 					return;
; 3622 : 				}
; 3623 : 			}
; 3624 : 			
; 3625 : 			if ( lpItem->m_Type == ITEMGET(14,29) ) // Symbol of Kundun

  0071b	b8 1d 1c 00 00	 mov	 eax, 7197		; 00001c1dH
  00720	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  00724	0f 85 9f 02 00
	00		 jne	 $LN72@CGItemGetR

; 3626 : 			{
; 3627 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  0072a	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
$LL8@CGItemGetR:

; 3628 : 				{
; 3629 : 					int pos = ::g_KalimaGate.CheckOverlapKundunMark(aIndex, lpItem->m_Level);

  00734	0f b6 47 0c	 movzx	 eax, BYTE PTR [edi+12]
  00738	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  0073d	50		 push	 eax
  0073e	56		 push	 esi
  0073f	e8 00 00 00 00	 call	 ?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z ; CKalimaGate::CheckOverlapKundunMark
  00744	89 85 24 ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], eax

; 3630 : 
; 3631 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  0074a	85 c0		 test	 eax, eax
  0074c	0f 88 77 02 00
	00		 js	 $LN72@CGItemGetR
  00752	33 c9		 xor	 ecx, ecx
  00754	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  00759	0f 9e c1	 setle	 cl
  0075c	85 c9		 test	 ecx, ecx
  0075e	0f 84 65 02 00
	00		 je	 $LN72@CGItemGetR

; 3632 : 					{
; 3633 : 						if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  00764	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv3272[ebp]
  0076a	6a 01		 push	 1
  0076c	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  00772	56		 push	 esi
  00773	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  00779	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  0077e	83 f8 01	 cmp	 eax, 1
  00781	0f 85 2a 02 00
	00		 jne	 $LN6@CGItemGetR

; 3634 : 						{
; 3635 : 							BYTE NewOption[MAX_EXOPTION_SIZE];
; 3636 : 
; 3637 : 							::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  00787	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0078a	50		 push	 eax
  0078b	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$7[ebp]
  0078e	50		 push	 eax
  0078f	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  00794	83 c4 08	 add	 esp, 8

; 3638 : 
; 3639 : 							LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num,

  00797	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0079a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0079f	50		 push	 eax
  007a0	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  007a5	0f b6 c0	 movzx	 eax, al
  007a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  007ad	50		 push	 eax
  007ae	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  007b1	50		 push	 eax
  007b2	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  007b7	0f b6 c0	 movzx	 eax, al
  007ba	50		 push	 eax
  007bb	0f b6 87 ca 00
	00 00		 movzx	 eax, BYTE PTR [edi+202]
  007c2	c1 e8 07	 shr	 eax, 7
  007c5	50		 push	 eax
  007c6	0f b6 87 ae 00
	00 00		 movzx	 eax, BYTE PTR [edi+174]
  007cd	50		 push	 eax
  007ce	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$7[ebp+6]
  007d2	50		 push	 eax
  007d3	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$7[ebp+5]
  007d7	50		 push	 eax
  007d8	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$7[ebp+4]
  007dc	50		 push	 eax
  007dd	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$7[ebp+3]
  007e1	50		 push	 eax
  007e2	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$7[ebp+2]
  007e6	50		 push	 eax
  007e7	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$7[ebp+1]
  007eb	50		 push	 eax
  007ec	0f b6 45 f4	 movzx	 eax, BYTE PTR _NewOption$7[ebp]
  007f0	50		 push	 eax
  007f1	f3 0f 2c 47 28	 cvttss2si eax, DWORD PTR [edi+40]
  007f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  007fc	50		 push	 eax
  007fd	0f b6 87 96 00
	00 00		 movzx	 eax, BYTE PTR [edi+150]
  00804	50		 push	 eax
  00805	0f b6 87 95 00
	00 00		 movzx	 eax, BYTE PTR [edi+149]
  0080c	50		 push	 eax
  0080d	0f b6 87 94 00
	00 00		 movzx	 eax, BYTE PTR [edi+148]
  00814	50		 push	 eax
  00815	ff b5 08 ff ff
	ff		 push	 DWORD PTR _level$1$[ebp]
  0081b	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$[ebp]
  0081e	ff b5 10 ff ff
	ff		 push	 DWORD PTR _type$1$[ebp]
  00824	50		 push	 eax
  00825	ff 77 04	 push	 DWORD PTR [edi+4]
  00828	0f b6 84 0b 21
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+289]
  00830	50		 push	 eax
  00831	0f b6 84 0b 20
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+288]
  00839	50		 push	 eax
  0083a	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map_num$1$[ebp]
  00840	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00843	03 c3		 add	 eax, ebx
  00845	50		 push	 eax
  00846	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00849	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0084e	03 c3		 add	 eax, ebx
  00850	50		 push	 eax
  00851	68 dd 01 00 00	 push	 477			; 000001ddH
  00856	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0085b	50		 push	 eax
  0085c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3640 : 								gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type,
; 3641 : 								level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (int)lpItem->m_Durability,
; 3642 : 								NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5],
; 3643 : 								NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7,
; 3644 : 								g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));
; 3645 : 
; 3646 : 							pResult.result = -3;
; 3647 : 
; 3648 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  00862	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00869	50		 push	 eax
  0086a	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00870	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  00877	50		 push	 eax
  00878	56		 push	 esi
  00879	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3649 : 
; 3650 : 							gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  0087e	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _pos$1$[ebp]
  00884	83 c4 70	 add	 esp, 112		; 00000070H
  00887	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0088c	f3 0f 10 47 28	 movss	 xmm0, DWORD PTR [edi+40]
  00891	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  00897	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  0089e	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv3212[ebp], ecx
  008a4	f3 0f 58 44 08
	24		 addss	 xmm0, DWORD PTR [eax+ecx+36]

; 3651 : 
; 3652 : 							if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  008aa	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40a00000
  008b2	f3 0f 11 44 08
	24		 movss	 DWORD PTR [eax+ecx+36], xmm0
  008b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008bd	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  008c4	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  008ca	0f 2f c1	 comiss	 xmm0, xmm1
  008cd	0f 82 36 0c 00
	00		 jb	 $LN105@CGItemGetR

; 3653 : 							{
; 3654 : 								int NewDur = (int)(gObj[aIndex].pInventory[pos].m_Durability - 5.0f);

  008d3	f3 0f 5c c1	 subss	 xmm0, xmm1

; 3655 : 								::gObjInventoryItemSet(aIndex, pos, -1);

  008d7	68 ff 00 00 00	 push	 255			; 000000ffH
  008dc	52		 push	 edx
  008dd	56		 push	 esi
  008de	f3 0f 2c c0	 cvttss2si eax, xmm0
  008e2	89 85 28 ff ff
	ff		 mov	 DWORD PTR _NewDur$1$[ebp], eax
  008e8	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 3656 : 								gObj[aIndex].pInventory[pos].Clear();

  008ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008f2	83 c4 0c	 add	 esp, 12			; 0000000cH
  008f5	8b 8c 03 c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4544]
  008fc	03 8d 2c ff ff
	ff		 add	 ecx, DWORD PTR tv3212[ebp]
  00902	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 3657 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);

  00907	6a 01		 push	 1
  00909	ff b5 24 ff ff
	ff		 push	 DWORD PTR _pos$1$[ebp]
  0090f	56		 push	 esi
  00910	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend

; 3658 : 								::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, ItemGetNumberMake(14, 28),

  00915	0f b6 47 0c	 movzx	 eax, BYTE PTR [edi+12]
  00919	83 c4 0c	 add	 esp, 12			; 0000000cH
  0091c	6a 00		 push	 0
  0091e	6a 00		 push	 0
  00920	6a 00		 push	 0
  00922	6a 00		 push	 0
  00924	56		 push	 esi
  00925	6a 00		 push	 0
  00927	6a 00		 push	 0
  00929	6a 00		 push	 0
  0092b	6a 00		 push	 0
  0092d	50		 push	 eax
  0092e	6a 1c		 push	 28			; 0000001cH
  00930	6a 0e		 push	 14			; 0000000eH
  00932	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00937	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0093d	83 c4 08	 add	 esp, 8
  00940	50		 push	 eax
  00941	0f b6 84 0b 21
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+289]
  00949	50		 push	 eax
  0094a	0f b6 84 0b 20
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+288]
  00952	50		 push	 eax
  00953	68 eb 00 00 00	 push	 235			; 000000ebH
  00958	56		 push	 esi
  00959	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 3659 : 									lpItem->m_Level, 0, 0, 0, 0, aIndex, 0, 0);
; 3660 : 
; 3661 : 								LogAddTD("[Kalima] [%s][%s] Make Lost Kalima Map (Left Kundun Mark:%d)",

  0095e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00964	ff b5 28 ff ff
	ff		 push	 DWORD PTR _NewDur$1$[ebp]
  0096a	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0096d	03 c3		 add	 eax, ebx
  0096f	50		 push	 eax
  00970	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00973	03 c3		 add	 eax, ebx
  00975	50		 push	 eax
  00976	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@NBANJING@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Lost?5Kali@
  0097b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3662 : 									gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);
; 3663 : 
; 3664 : 								if ( NewDur > 0 )

  00981	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _NewDur$1$[ebp]
  00987	83 c4 4c	 add	 esp, 76			; 0000004cH
  0098a	85 c0		 test	 eax, eax
  0098c	0f 8e a6 0e 00
	00		 jle	 $LN246@CGItemGetR

; 3665 : 								{
; 3666 : 									lpItem->m_State = 2;
; 3667 : 									lpItem->Give = false;
; 3668 : 									lpItem->live = true;
; 3669 : 									lpItem->m_Durability = (float)NewDur;

  00992	66 0f 6e c0	 movd	 xmm0, eax
  00996	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00999	c7 87 dc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+220], 2
  009a3	66 c7 87 da 00
	00 00 01 00	 mov	 WORD PTR [edi+218], 1
  009ac	f3 0f 11 47 28	 movss	 DWORD PTR [edi+40], xmm0
$LN6@CGItemGetR:

; 3626 : 			{
; 3627 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  009b1	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _n$1$[ebp]
  009b7	40		 inc	 eax
  009b8	89 85 1c ff ff
	ff		 mov	 DWORD PTR _n$1$[ebp], eax
  009be	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  009c3	0f 8c 6b fd ff
	ff		 jl	 $LL8@CGItemGetR
$LN72@CGItemGetR:

; 3670 : 									continue;
; 3671 : 
; 3672 : 								}
; 3673 : 							}
; 3674 : 							else
; 3675 : 							{
; 3676 : 								GCItemDurSend(aIndex,pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);
; 3677 : 								
; 3678 : 							}
; 3679 : 							return;
; 3680 : 						}
; 3681 : 					}
; 3682 : 					else
; 3683 : 					{
; 3684 : 						break;
; 3685 : 					}
; 3686 : 				}
; 3687 : 			}
; 3688 : 
; 3689 : 			if ( lpItem->m_Type == ITEMGET(14,21) && lpItem->m_Level == 3) // Sign of Lord

  009c9	b8 15 1c 00 00	 mov	 eax, 7189		; 00001c15H
  009ce	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  009d2	0f 85 6c 01 00
	00		 jne	 $LN79@CGItemGetR
  009d8	66 83 7f 0c 03	 cmp	 WORD PTR [edi+12], 3
  009dd	0f 85 61 01 00
	00		 jne	 $LN79@CGItemGetR

; 3690 : 			{	
; 3691 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  009e3	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  009ed	0f 1f 00	 npad	 3
$LL11@CGItemGetR:

; 3692 : 				{
; 3693 : 					int pos = ::g_CastleSiegeSync.CheckOverlapCsMarks(aIndex);

  009f0	56		 push	 esi
  009f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  009f6	e8 00 00 00 00	 call	 ?CheckOverlapCsMarks@CCastleSiegeSync@@QAEHH@Z ; CCastleSiegeSync::CheckOverlapCsMarks
  009fb	8b d0		 mov	 edx, eax
  009fd	89 95 2c ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], edx

; 3694 : 
; 3695 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  00a03	85 d2		 test	 edx, edx
  00a05	0f 88 39 01 00
	00		 js	 $LN79@CGItemGetR
  00a0b	33 c9		 xor	 ecx, ecx
  00a0d	81 fa cb 00 00
	00		 cmp	 edx, 203		; 000000cbH
  00a13	0f 9e c1	 setle	 cl
  00a16	85 c9		 test	 ecx, ecx
  00a18	0f 84 26 01 00
	00		 je	 $LN79@CGItemGetR

; 3696 : 					{
; 3697 : 						int Dur = (int)(gObj[aIndex].pInventory[pos].m_Durability + lpItem->m_Durability);

  00a1e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a23	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  00a29	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00a30	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00a36	f3 0f 58 47 28	 addss	 xmm0, DWORD PTR [edi+40]
  00a3b	f3 0f 2c c0	 cvttss2si eax, xmm0

; 3698 : 
; 3699 : 						if ( Dur <= 255 )

  00a3f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00a44	0f 8f 9b 00 00
	00		 jg	 $LN81@CGItemGetR

; 3700 : 						{
; 3701 : 							if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  00a4a	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv3272[ebp]
  00a50	6a 01		 push	 1
  00a52	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  00a58	56		 push	 esi
  00a59	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  00a5f	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00a64	83 f8 01	 cmp	 eax, 1
  00a67	0f 85 bf 00 00
	00		 jne	 $LN9@CGItemGetR
$LN205@CGItemGetR:

; 3702 : 							{
; 3703 : 								pResult.result = -3;
; 3704 : 								DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00a6d	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00a74	50		 push	 eax
  00a75	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00a7b	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  00a82	50		 push	 eax
  00a83	56		 push	 esi
  00a84	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3705 : 								gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  00a89	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _pos$1$[ebp]
  00a8f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00a94	f3 0f 10 47 28	 movss	 xmm0, DWORD PTR [edi+40]
  00a99	69 ca d4 00 00
	00		 imul	 ecx, edx, 212

; 3706 : 								GCItemDurSend( aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability,0);

  00a9f	6a 00		 push	 0
  00aa1	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00aa8	f3 0f 58 44 08
	24		 addss	 xmm0, DWORD PTR [eax+ecx+36]
  00aae	f3 0f 11 44 08
	24		 movss	 DWORD PTR [eax+ecx+36], xmm0
  00ab4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ab9	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00ac0	f3 0f 2c 44 08
	24		 cvttss2si eax, DWORD PTR [eax+ecx+36]
  00ac6	0f b6 c0	 movzx	 eax, al
  00ac9	50		 push	 eax
  00aca	52		 push	 edx
  00acb	56		 push	 esi
  00acc	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00ad1	83 c4 1c	 add	 esp, 28			; 0000001cH
  00ad4	5b		 pop	 ebx
  00ad5	5f		 pop	 edi
  00ad6	5e		 pop	 esi

; 4007 : 								map_num - (MAP_INDEX_ILLUSIONTEMPLE1 - 1),gObj[aIndex].AccountID,gObj[aIndex].Name,lpItem->m_Number);
; 4008 : 						}
; 4009 : #if (ENABLETEST_ARCA == 1)
; 4010 : 						if( g_ArcaBattle.IsArcaBattleServer() && lpItem->m_Type == AB_REW_KILL_TROPHY )
; 4011 : 						{
; 4012 : 							g_ArcaBattle.BootyItemGetCnt(gObj[aIndex]);
; 4013 : 						}
; 4014 : #endif
; 4015 : 					}
; 4016 : 				}
; 4017 : 				else
; 4018 : 				{
; 4019 : 					pResult.result = -1;
; 4020 : 					pResult.h.size -= sizeof(pResult.Data);
; 4021 : 
; 4022 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4023 : 				}
; 4024 : 			}
; 4025 : 			else
; 4026 : 			{
; 4027 : 				pResult.result = -1;
; 4028 : 				pResult.h.size -= sizeof(pResult.Data);
; 4029 : 
; 4030 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4031 : 			}
; 4032 : 		}
; 4033 : 	}
; 4034 : 	else
; 4035 : 	{
; 4036 : 		pResult.h.size -= sizeof(pResult.Data);
; 4037 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 4038 : 	}
; 4039 : }

  00ad7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ada	33 cd		 xor	 ecx, ebp
  00adc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ae1	8b e5		 mov	 esp, ebp
  00ae3	5d		 pop	 ebp
  00ae4	c3		 ret	 0
$LN81@CGItemGetR:

; 3707 : 								return;
; 3708 : 							}
; 3709 : 						}
; 3710 : 						else
; 3711 : 						{
; 3712 : 							lpItem->m_Durability = (float)(Dur - 255);

  00ae5	05 01 ff ff ff	 add	 eax, -255		; ffffff01H

; 3713 : 							gObj[aIndex].pInventory[pos].m_Durability = 255.0f;
; 3714 : 							GCItemDurSend(aIndex, pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  00aea	6a 00		 push	 0
  00aec	66 0f 6e c0	 movd	 xmm0, eax
  00af0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00af5	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00af8	f3 0f 11 47 28	 movss	 DWORD PTR [edi+40], xmm0
  00afd	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00b04	c7 44 08 24 00
	00 7f 43	 mov	 DWORD PTR [eax+ecx+36], 1132396544 ; 437f0000H
  00b0c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00b11	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00b18	f3 0f 2c 44 08
	24		 cvttss2si eax, DWORD PTR [eax+ecx+36]
  00b1e	0f b6 c0	 movzx	 eax, al
  00b21	50		 push	 eax
  00b22	52		 push	 edx
  00b23	56		 push	 esi
  00b24	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00b29	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@CGItemGetR:

; 3690 : 			{	
; 3691 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00b2c	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _n$1$[ebp]
  00b32	40		 inc	 eax
  00b33	89 85 1c ff ff
	ff		 mov	 DWORD PTR _n$1$[ebp], eax
  00b39	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  00b3e	0f 8c ac fe ff
	ff		 jl	 $LL11@CGItemGetR
$LN79@CGItemGetR:

; 3715 : 						}
; 3716 : 
; 3717 : 					}
; 3718 : 					else
; 3719 : 					{
; 3720 : 						break;
; 3721 : 					}
; 3722 : 				}
; 3723 : 			}
; 3724 : 
; 3725 : 
; 3726 : 			if ( lpItem->m_Type == ITEMGET(14,110) ) // Dimension Mark

  00b44	b8 6e 1c 00 00	 mov	 eax, 7278		; 00001c6eH
  00b49	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  00b4d	0f 85 b3 02 00
	00		 jne	 $LN86@CGItemGetR

; 3727 : 			{
; 3728 : 				if( lpItem->m_Durability > 5 )

  00b53	f3 0f 10 47 28	 movss	 xmm0, DWORD PTR [edi+40]
  00b58	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@40a00000
  00b5f	76 07		 jbe	 SHORT $LN85@CGItemGetR

; 3729 : 					lpItem->m_Durability = 1;

  00b61	c7 47 28 00 00
	80 3f		 mov	 DWORD PTR [edi+40], 1065353216 ; 3f800000H
$LN85@CGItemGetR:

; 3730 : 
; 3731 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00b68	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
$LL14@CGItemGetR:

; 3732 : 				{
; 3733 : 					int pos = ::gObjCheckOverlapItemUsingDur(aIndex,5,lpItem->m_Type,0);

  00b72	0f bf 47 0a	 movsx	 eax, WORD PTR [edi+10]
  00b76	6a 00		 push	 0
  00b78	50		 push	 eax
  00b79	6a 05		 push	 5
  00b7b	56		 push	 esi
  00b7c	e8 00 00 00 00	 call	 ?gObjCheckOverlapItemUsingDur@@YAHHHHH@Z ; gObjCheckOverlapItemUsingDur
  00b81	83 c4 10	 add	 esp, 16			; 00000010H
  00b84	89 85 1c ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], eax

; 3734 : 
; 3735 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  00b8a	85 c0		 test	 eax, eax
  00b8c	0f 88 74 02 00
	00		 js	 $LN86@CGItemGetR
  00b92	33 c9		 xor	 ecx, ecx
  00b94	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  00b99	0f 9e c1	 setle	 cl
  00b9c	85 c9		 test	 ecx, ecx
  00b9e	0f 84 62 02 00
	00		 je	 $LN86@CGItemGetR

; 3736 : 					{
; 3737 : 						if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  00ba4	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv3272[ebp]
  00baa	6a 01		 push	 1
  00bac	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  00bb2	56		 push	 esi
  00bb3	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  00bb9	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00bbe	83 f8 01	 cmp	 eax, 1
  00bc1	0f 85 27 02 00
	00		 jne	 $LN12@CGItemGetR

; 3738 : 						{
; 3739 : 							BYTE NewOption[MAX_EXOPTION_SIZE];
; 3740 : 
; 3741 : 							::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  00bc7	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00bca	50		 push	 eax
  00bcb	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$6[ebp]
  00bce	50		 push	 eax
  00bcf	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  00bd4	83 c4 08	 add	 esp, 8

; 3742 : 
; 3743 : 							LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num,

  00bd7	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00bda	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00bdf	50		 push	 eax
  00be0	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  00be5	0f b6 c0	 movzx	 eax, al
  00be8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00bed	50		 push	 eax
  00bee	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00bf1	50		 push	 eax
  00bf2	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  00bf7	0f b6 c0	 movzx	 eax, al
  00bfa	50		 push	 eax
  00bfb	0f b6 87 ca 00
	00 00		 movzx	 eax, BYTE PTR [edi+202]
  00c02	c1 e8 07	 shr	 eax, 7
  00c05	50		 push	 eax
  00c06	0f b6 87 ae 00
	00 00		 movzx	 eax, BYTE PTR [edi+174]
  00c0d	50		 push	 eax
  00c0e	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$6[ebp+6]
  00c12	50		 push	 eax
  00c13	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$6[ebp+5]
  00c17	50		 push	 eax
  00c18	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$6[ebp+4]
  00c1c	50		 push	 eax
  00c1d	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$6[ebp+3]
  00c21	50		 push	 eax
  00c22	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$6[ebp+2]
  00c26	50		 push	 eax
  00c27	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$6[ebp+1]
  00c2b	50		 push	 eax
  00c2c	0f b6 45 f4	 movzx	 eax, BYTE PTR _NewOption$6[ebp]
  00c30	50		 push	 eax
  00c31	f3 0f 2c 47 28	 cvttss2si eax, DWORD PTR [edi+40]
  00c36	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00c3c	50		 push	 eax
  00c3d	0f b6 87 96 00
	00 00		 movzx	 eax, BYTE PTR [edi+150]
  00c44	50		 push	 eax
  00c45	0f b6 87 95 00
	00 00		 movzx	 eax, BYTE PTR [edi+149]
  00c4c	50		 push	 eax
  00c4d	0f b6 87 94 00
	00 00		 movzx	 eax, BYTE PTR [edi+148]
  00c54	50		 push	 eax
  00c55	ff b5 08 ff ff
	ff		 push	 DWORD PTR _level$1$[ebp]
  00c5b	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$[ebp]
  00c5e	ff b5 10 ff ff
	ff		 push	 DWORD PTR _type$1$[ebp]
  00c64	50		 push	 eax
  00c65	ff 77 04	 push	 DWORD PTR [edi+4]
  00c68	0f b6 84 0b 21
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+289]
  00c70	50		 push	 eax
  00c71	0f b6 84 0b 20
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+288]
  00c79	50		 push	 eax
  00c7a	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map_num$1$[ebp]
  00c80	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00c83	03 c3		 add	 eax, ebx
  00c85	50		 push	 eax
  00c86	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00c89	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00c8e	03 c3		 add	 eax, ebx
  00c90	50		 push	 eax
  00c91	68 dd 01 00 00	 push	 477			; 000001ddH
  00c96	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00c9b	50		 push	 eax
  00c9c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3744 : 								gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type,
; 3745 : 								level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (int)lpItem->m_Durability,
; 3746 : 								NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5],
; 3747 : 								NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7,
; 3748 : 								g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));
; 3749 : 
; 3750 : 							pResult.result = -3;
; 3751 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  00ca2	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00ca9	50		 push	 eax
  00caa	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00cb0	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  00cb7	50		 push	 eax
  00cb8	56		 push	 esi
  00cb9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3752 : 
; 3753 : 							gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  00cbe	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _pos$1$[ebp]
  00cc4	83 c4 70	 add	 esp, 112		; 00000070H
  00cc7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ccc	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  00cd2	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00cd9	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv3208[ebp], ecx
  00cdf	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00ce5	f3 0f 58 47 28	 addss	 xmm0, DWORD PTR [edi+40]

; 3754 : 
; 3755 : 							if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  00cea	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40a00000
  00cf2	f3 0f 11 44 08
	24		 movss	 DWORD PTR [eax+ecx+36], xmm0
  00cf8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00cfd	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00d04	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00d0a	0f 2f c1	 comiss	 xmm0, xmm1
  00d0d	0f 82 f6 07 00
	00		 jb	 $LN105@CGItemGetR

; 3756 : 							{
; 3757 : 								int NewDur = (int)(gObj[aIndex].pInventory[pos].m_Durability - 5.0f);

  00d13	f3 0f 5c c1	 subss	 xmm0, xmm1

; 3758 : 								::gObjInventoryItemSet(aIndex, pos, -1);

  00d17	68 ff 00 00 00	 push	 255			; 000000ffH
  00d1c	52		 push	 edx
  00d1d	56		 push	 esi
  00d1e	f3 0f 2c c0	 cvttss2si eax, xmm0
  00d22	89 85 24 ff ff
	ff		 mov	 DWORD PTR _NewDur$1$[ebp], eax
  00d28	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 3759 : 								gObj[aIndex].pInventory[pos].Clear();

  00d2d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d32	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d35	8b 8c 03 c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4544]
  00d3c	03 8d 2c ff ff
	ff		 add	 ecx, DWORD PTR tv3208[ebp]
  00d42	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 3760 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);

  00d47	6a 01		 push	 1
  00d49	ff b5 1c ff ff
	ff		 push	 DWORD PTR _pos$1$[ebp]
  00d4f	56		 push	 esi
  00d50	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00d55	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3761 : 								::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, ItemGetNumberMake(14, 111),

  00d58	6a 00		 push	 0
  00d5a	6a 00		 push	 0
  00d5c	6a 00		 push	 0
  00d5e	6a 00		 push	 0
  00d60	56		 push	 esi
  00d61	6a 00		 push	 0
  00d63	6a 00		 push	 0
  00d65	6a 00		 push	 0
  00d67	6a 00		 push	 0
  00d69	6a 00		 push	 0
  00d6b	6a 6f		 push	 111			; 0000006fH
  00d6d	6a 0e		 push	 14			; 0000000eH
  00d6f	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00d74	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00d7a	83 c4 08	 add	 esp, 8
  00d7d	50		 push	 eax
  00d7e	0f b6 84 0b 21
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+289]
  00d86	50		 push	 eax
  00d87	0f b6 84 0b 20
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+288]
  00d8f	50		 push	 eax
  00d90	68 eb 00 00 00	 push	 235			; 000000ebH
  00d95	56		 push	 esi
  00d96	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 3762 : 									0, 0, 0, 0, 0, aIndex, 0, 0);
; 3763 : 
; 3764 : 								LogAddTD("[Doppelganger] [%s][%s] Make Dimension Mirror (Left Dimension Mark:%d)",

  00d9b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00da1	ff b5 24 ff ff
	ff		 push	 DWORD PTR _NewDur$1$[ebp]
  00da7	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00daa	03 c3		 add	 eax, ebx
  00dac	50		 push	 eax
  00dad	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00db0	03 c3		 add	 eax, ebx
  00db2	50		 push	 eax
  00db3	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@MPCKANHC@?$FLDoppelganger?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Dim@
  00db8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3765 : 									gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);
; 3766 : 
; 3767 : 								if ( NewDur > 0 )

  00dbe	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _NewDur$1$[ebp]
  00dc4	83 c4 4c	 add	 esp, 76			; 0000004cH
  00dc7	85 c0		 test	 eax, eax
  00dc9	0f 8e 69 0a 00
	00		 jle	 $LN246@CGItemGetR

; 3768 : 								{
; 3769 : 									lpItem->m_State = 2;
; 3770 : 									lpItem->Give = false;
; 3771 : 									lpItem->live = true;
; 3772 : 									lpItem->m_Durability = (float)NewDur;

  00dcf	66 0f 6e c0	 movd	 xmm0, eax
  00dd3	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00dd6	c7 87 dc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+220], 2
  00de0	66 c7 87 da 00
	00 00 01 00	 mov	 WORD PTR [edi+218], 1
  00de9	f3 0f 11 47 28	 movss	 DWORD PTR [edi+40], xmm0
$LN12@CGItemGetR:

; 3730 : 
; 3731 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00dee	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _n$1$[ebp]
  00df4	40		 inc	 eax
  00df5	89 85 28 ff ff
	ff		 mov	 DWORD PTR _n$1$[ebp], eax
  00dfb	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  00e00	0f 8c 6c fd ff
	ff		 jl	 $LL14@CGItemGetR
$LN86@CGItemGetR:

; 3773 : 									continue;
; 3774 : 
; 3775 : 								}
; 3776 : 							}
; 3777 : 							else
; 3778 : 							{
; 3779 : 								GCItemDurSend(aIndex,pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);
; 3780 : 								
; 3781 : 							}
; 3782 : 							return;
; 3783 : 						}
; 3784 : 					}
; 3785 : 					else
; 3786 : 					{
; 3787 : 						break;
; 3788 : 					}
; 3789 : 				}
; 3790 : 			}
; 3791 : 
; 3792 : 			if ( lpItem->m_Type == ITEMGET(14,101) ) // Old Paper

  00e06	b8 65 1c 00 00	 mov	 eax, 7269		; 00001c65H
  00e0b	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  00e0f	0f 85 9d 02 00
	00		 jne	 $LN93@CGItemGetR

; 3793 : 			{
; 3794 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  00e15	c7 85 28 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  00e1f	90		 npad	 1
$LL17@CGItemGetR:

; 3795 : 				{
; 3796 : 					int pos = ::g_ImperialGuardian.CheckOverlapMysteriousPaper(aIndex, lpItem->m_Level);

  00e20	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  00e24	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  00e29	50		 push	 eax
  00e2a	56		 push	 esi
  00e2b	e8 00 00 00 00	 call	 ?CheckOverlapMysteriousPaper@CImperialGuardian@@QAEHHH@Z ; CImperialGuardian::CheckOverlapMysteriousPaper
  00e30	89 85 1c ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], eax

; 3797 : 
; 3798 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  00e36	85 c0		 test	 eax, eax
  00e38	0f 88 74 02 00
	00		 js	 $LN93@CGItemGetR
  00e3e	33 c9		 xor	 ecx, ecx
  00e40	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  00e45	0f 9e c1	 setle	 cl
  00e48	85 c9		 test	 ecx, ecx
  00e4a	0f 84 62 02 00
	00		 je	 $LN93@CGItemGetR

; 3799 : 					{
; 3800 : 						if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  00e50	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv3272[ebp]
  00e56	6a 01		 push	 1
  00e58	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  00e5e	56		 push	 esi
  00e5f	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  00e65	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  00e6a	83 f8 01	 cmp	 eax, 1
  00e6d	0f 85 27 02 00
	00		 jne	 $LN15@CGItemGetR

; 3801 : 						{
; 3802 : 							BYTE NewOption[MAX_EXOPTION_SIZE];
; 3803 : 
; 3804 : 							::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  00e73	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00e76	50		 push	 eax
  00e77	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$5[ebp]
  00e7a	50		 push	 eax
  00e7b	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  00e80	83 c4 08	 add	 esp, 8

; 3805 : 
; 3806 : 							LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num,

  00e83	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00e86	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00e8b	50		 push	 eax
  00e8c	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  00e91	0f b6 c0	 movzx	 eax, al
  00e94	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  00e99	50		 push	 eax
  00e9a	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00e9d	50		 push	 eax
  00e9e	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  00ea3	0f b6 c0	 movzx	 eax, al
  00ea6	50		 push	 eax
  00ea7	0f b6 87 ca 00
	00 00		 movzx	 eax, BYTE PTR [edi+202]
  00eae	c1 e8 07	 shr	 eax, 7
  00eb1	50		 push	 eax
  00eb2	0f b6 87 ae 00
	00 00		 movzx	 eax, BYTE PTR [edi+174]
  00eb9	50		 push	 eax
  00eba	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$5[ebp+6]
  00ebe	50		 push	 eax
  00ebf	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$5[ebp+5]
  00ec3	50		 push	 eax
  00ec4	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$5[ebp+4]
  00ec8	50		 push	 eax
  00ec9	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$5[ebp+3]
  00ecd	50		 push	 eax
  00ece	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$5[ebp+2]
  00ed2	50		 push	 eax
  00ed3	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$5[ebp+1]
  00ed7	50		 push	 eax
  00ed8	0f b6 45 f4	 movzx	 eax, BYTE PTR _NewOption$5[ebp]
  00edc	50		 push	 eax
  00edd	f3 0f 2c 47 28	 cvttss2si eax, DWORD PTR [edi+40]
  00ee2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00ee8	50		 push	 eax
  00ee9	0f b6 87 96 00
	00 00		 movzx	 eax, BYTE PTR [edi+150]
  00ef0	50		 push	 eax
  00ef1	0f b6 87 95 00
	00 00		 movzx	 eax, BYTE PTR [edi+149]
  00ef8	50		 push	 eax
  00ef9	0f b6 87 94 00
	00 00		 movzx	 eax, BYTE PTR [edi+148]
  00f00	50		 push	 eax
  00f01	ff b5 08 ff ff
	ff		 push	 DWORD PTR _level$1$[ebp]
  00f07	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$[ebp]
  00f0a	ff b5 10 ff ff
	ff		 push	 DWORD PTR _type$1$[ebp]
  00f10	50		 push	 eax
  00f11	ff 77 04	 push	 DWORD PTR [edi+4]
  00f14	0f b6 84 0b 21
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+289]
  00f1c	50		 push	 eax
  00f1d	0f b6 84 0b 20
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+288]
  00f25	50		 push	 eax
  00f26	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map_num$1$[ebp]
  00f2c	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00f2f	03 c3		 add	 eax, ebx
  00f31	50		 push	 eax
  00f32	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00f35	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00f3a	03 c3		 add	 eax, ebx
  00f3c	50		 push	 eax
  00f3d	68 dd 01 00 00	 push	 477			; 000001ddH
  00f42	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00f47	50		 push	 eax
  00f48	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3807 : 								gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type,
; 3808 : 								level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (int)lpItem->m_Durability,
; 3809 : 								NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5],
; 3810 : 								NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7,
; 3811 : 								g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));
; 3812 : 
; 3813 : 							pResult.result = -3;
; 3814 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  00f4e	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00f55	50		 push	 eax
  00f56	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  00f5c	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  00f63	50		 push	 eax
  00f64	56		 push	 esi
  00f65	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3815 : 
; 3816 : 							gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  00f6a	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR _pos$1$[ebp]
  00f70	83 c4 70	 add	 esp, 112		; 00000070H
  00f73	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f78	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  00f7e	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00f85	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv3206[ebp], ecx
  00f8b	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00f91	f3 0f 58 47 28	 addss	 xmm0, DWORD PTR [edi+40]

; 3817 : 
; 3818 : 							if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  00f96	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40a00000
  00f9e	f3 0f 11 44 08
	24		 movss	 DWORD PTR [eax+ecx+36], xmm0
  00fa4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fa9	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  00fb0	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00fb6	0f 2f c1	 comiss	 xmm0, xmm1
  00fb9	0f 82 4a 05 00
	00		 jb	 $LN105@CGItemGetR

; 3819 : 							{
; 3820 : 								int NewDur = (int)(gObj[aIndex].pInventory[pos].m_Durability - 5.0f);

  00fbf	f3 0f 5c c1	 subss	 xmm0, xmm1

; 3821 : 								::gObjInventoryItemSet(aIndex, pos, -1);

  00fc3	68 ff 00 00 00	 push	 255			; 000000ffH
  00fc8	52		 push	 edx
  00fc9	56		 push	 esi
  00fca	f3 0f 2c c0	 cvttss2si eax, xmm0
  00fce	89 85 24 ff ff
	ff		 mov	 DWORD PTR _NewDur$1$[ebp], eax
  00fd4	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 3822 : 								gObj[aIndex].pInventory[pos].Clear();

  00fd9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fde	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fe1	8b 8c 03 c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4544]
  00fe8	03 8d 2c ff ff
	ff		 add	 ecx, DWORD PTR tv3206[ebp]
  00fee	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 3823 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);

  00ff3	6a 01		 push	 1
  00ff5	ff b5 1c ff ff
	ff		 push	 DWORD PTR _pos$1$[ebp]
  00ffb	56		 push	 esi
  00ffc	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  01001	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3824 : 								::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, ItemGetNumberMake(14, 102),

  01004	6a 00		 push	 0
  01006	6a 00		 push	 0
  01008	6a 00		 push	 0
  0100a	6a 00		 push	 0
  0100c	56		 push	 esi
  0100d	6a 00		 push	 0
  0100f	6a 00		 push	 0
  01011	6a 00		 push	 0
  01013	6a 00		 push	 0
  01015	6a 00		 push	 0
  01017	6a 66		 push	 102			; 00000066H
  01019	6a 0e		 push	 14			; 0000000eH
  0101b	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  01020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01026	83 c4 08	 add	 esp, 8
  01029	50		 push	 eax
  0102a	0f b6 84 0b 21
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+289]
  01032	50		 push	 eax
  01033	0f b6 84 0b 20
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+288]
  0103b	50		 push	 eax
  0103c	68 eb 00 00 00	 push	 235			; 000000ebH
  01041	56		 push	 esi
  01042	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 3825 : 									0, 0, 0, 0, 0, aIndex, 0, 0);
; 3826 : 
; 3827 : 								LogAddTD("[ImperialGuardianFort] [%s][%s] Make Imperial Letter (Left Old Paper:%d)",

  01047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0104d	ff b5 24 ff ff
	ff		 push	 DWORD PTR _NewDur$1$[ebp]
  01053	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  01056	03 c3		 add	 eax, ebx
  01058	50		 push	 eax
  01059	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0105c	03 c3		 add	 eax, ebx
  0105e	50		 push	 eax
  0105f	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@KBMFDFFG@?$FLImperialGuardianFort?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  01064	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3828 : 									gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);
; 3829 : 
; 3830 : 								if ( NewDur > 0 )

  0106a	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _NewDur$1$[ebp]
  01070	83 c4 4c	 add	 esp, 76			; 0000004cH
  01073	85 c0		 test	 eax, eax
  01075	0f 8e bd 07 00
	00		 jle	 $LN246@CGItemGetR

; 3831 : 								{
; 3832 : 									lpItem->m_State = 2;
; 3833 : 									lpItem->Give = false;
; 3834 : 									lpItem->live = true;
; 3835 : 									lpItem->m_Durability = (float)NewDur;

  0107b	66 0f 6e c0	 movd	 xmm0, eax
  0107f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  01082	c7 87 dc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+220], 2
  0108c	66 c7 87 da 00
	00 00 01 00	 mov	 WORD PTR [edi+218], 1
  01095	f3 0f 11 47 28	 movss	 DWORD PTR [edi+40], xmm0
$LN15@CGItemGetR:

; 3793 : 			{
; 3794 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  0109a	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _n$1$[ebp]
  010a0	40		 inc	 eax
  010a1	89 85 28 ff ff
	ff		 mov	 DWORD PTR _n$1$[ebp], eax
  010a7	3d cc 00 00 00	 cmp	 eax, 204		; 000000ccH
  010ac	0f 8c 6e fd ff
	ff		 jl	 $LL17@CGItemGetR
$LN93@CGItemGetR:

; 3836 : 									continue;
; 3837 : 
; 3838 : 								}
; 3839 : 							}
; 3840 : 							else
; 3841 : 							{
; 3842 : 								GCItemDurSend(aIndex,pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);
; 3843 : 								
; 3844 : 							}
; 3845 : 							return;
; 3846 : 						}
; 3847 : 					}
; 3848 : 					else
; 3849 : 					{
; 3850 : 						break;
; 3851 : 					}
; 3852 : 				}
; 3853 : 			}
; 3854 : 
; 3855 : 			if ( lpItem->m_Type == ITEMGET(13, 145) ) // Old Paper

  010b2	b8 91 1a 00 00	 mov	 eax, 6801		; 00001a91H
  010b7	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  010bb	0f 85 3e 03 00
	00		 jne	 $LN240@CGItemGetR

; 3856 : 			{
; 3857 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  010c1	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  010cb	0f 1f 44 00 00	 npad	 5
$LL20@CGItemGetR:

; 3858 : 				{
; 3859 : 					int pos = -1;

  010d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  010d6	83 c8 ff	 or	 eax, -1
  010d9	89 85 28 ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], eax
  010df	be f0 09 00 00	 mov	 esi, 2544		; 000009f0H

; 3860 : 					for(int i = INVETORY_WEAR_SIZE; i < 204; i++)

  010e4	c7 85 24 ff ff
	ff 0c 00 00 00	 mov	 DWORD PTR _i$1$[ebp], 12 ; 0000000cH
  010ee	66 90		 npad	 2
$LL23@CGItemGetR:

; 3861 : 					{
; 3862 : 						if( gObj[aIndex].pInventory[i].IsItem() == TRUE &&
; 3863 : 							gObj[aIndex].pInventory[i].m_Type == ITEMGET(13, 145) &&

  010f0	8b 8c 13 c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+edx+4544]
  010f7	03 ce		 add	 ecx, esi
  010f9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  010fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01104	83 f8 01	 cmp	 eax, 1
  01107	75 49		 jne	 SHORT $LN244@CGItemGetR
  01109	8b 8c 13 c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+edx+4544]
  01110	b8 91 1a 00 00	 mov	 eax, 6801		; 00001a91H
  01115	66 39 44 31 06	 cmp	 WORD PTR [ecx+esi+6], ax
  0111a	75 36		 jne	 SHORT $LN244@CGItemGetR
  0111c	66 8b 44 31 08	 mov	 ax, WORD PTR [ecx+esi+8]
  01121	66 3b 47 0c	 cmp	 ax, WORD PTR [edi+12]
  01125	75 2b		 jne	 SHORT $LN244@CGItemGetR

; 3864 : 							gObj[aIndex].pInventory[i].m_Level == lpItem->m_Level )
; 3865 : 						{
; 3866 : 							int nItemDur = (int)gObj[aIndex].pInventory[i].m_Durability;

  01127	f3 0f 2c 4c 31
	24		 cvttss2si ecx, DWORD PTR [ecx+esi+36]

; 3867 : 
; 3868 : 							if( ((nItemDur < 0) ? FALSE : (nItemDur <= 4)) != 0 )

  0112d	85 c9		 test	 ecx, ecx
  0112f	78 21		 js	 SHORT $LN244@CGItemGetR
  01131	33 c0		 xor	 eax, eax
  01133	83 f9 04	 cmp	 ecx, 4
  01136	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$1$[ebp]
  0113c	0f 9e c0	 setle	 al
  0113f	85 c0		 test	 eax, eax
  01141	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  01147	0f 45 c8	 cmovne	 ecx, eax
  0114a	89 8d 28 ff ff
	ff		 mov	 DWORD PTR _pos$1$[ebp], ecx
  01150	eb 0c		 jmp	 SHORT $LN21@CGItemGetR
$LN244@CGItemGetR:
  01152	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  01158	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$1$[ebp]
$LN21@CGItemGetR:

; 3860 : 					for(int i = INVETORY_WEAR_SIZE; i < 204; i++)

  0115e	40		 inc	 eax
  0115f	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  01165	89 85 24 ff ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  0116b	81 fe f0 a8 00
	00		 cmp	 esi, 43248		; 0000a8f0H
  01171	0f 8c 79 ff ff
	ff		 jl	 $LL23@CGItemGetR

; 3869 : 								pos = i;
; 3870 : 						}
; 3871 : 					}
; 3872 : 
; 3873 : 					if ( MAIN_INVENTORY_RANGE(pos) )

  01177	8b b5 14 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  0117d	85 c9		 test	 ecx, ecx
  0117f	0f 88 80 02 00
	00		 js	 $LN102@CGItemGetR
  01185	33 c0		 xor	 eax, eax
  01187	81 f9 cb 00 00
	00		 cmp	 ecx, 203		; 000000cbH
  0118d	0f 9e c0	 setle	 al
  01190	85 c0		 test	 eax, eax
  01192	0f 84 6d 02 00
	00		 je	 $LN102@CGItemGetR

; 3874 : 					{
; 3875 : 						if ( MapC[map_num].ItemGive(aIndex, item_num, true) == TRUE )

  01198	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv3272[ebp]
  0119e	6a 01		 push	 1
  011a0	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  011a6	56		 push	 esi
  011a7	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  011ad	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  011b2	83 f8 01	 cmp	 eax, 1
  011b5	0f 85 2b 02 00
	00		 jne	 $LN18@CGItemGetR

; 3876 : 						{
; 3877 : 							BYTE NewOption[MAX_EXOPTION_SIZE];
; 3878 : 
; 3879 : 							::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  011bb	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  011be	50		 push	 eax
  011bf	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$4[ebp]
  011c2	50		 push	 eax
  011c3	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  011c8	83 c4 08	 add	 esp, 8

; 3880 : 
; 3881 : 							LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num,

  011cb	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  011ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  011d3	50		 push	 eax
  011d4	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  011d9	0f b6 c0	 movzx	 eax, al
  011dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  011e1	50		 push	 eax
  011e2	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  011e5	50		 push	 eax
  011e6	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  011eb	0f b6 c0	 movzx	 eax, al
  011ee	50		 push	 eax
  011ef	0f b6 87 ca 00
	00 00		 movzx	 eax, BYTE PTR [edi+202]
  011f6	c1 e8 07	 shr	 eax, 7
  011f9	50		 push	 eax
  011fa	0f b6 87 ae 00
	00 00		 movzx	 eax, BYTE PTR [edi+174]
  01201	50		 push	 eax
  01202	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$4[ebp+6]
  01206	50		 push	 eax
  01207	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$4[ebp+5]
  0120b	50		 push	 eax
  0120c	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$4[ebp+4]
  01210	50		 push	 eax
  01211	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$4[ebp+3]
  01215	50		 push	 eax
  01216	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$4[ebp+2]
  0121a	50		 push	 eax
  0121b	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$4[ebp+1]
  0121f	50		 push	 eax
  01220	0f b6 45 f4	 movzx	 eax, BYTE PTR _NewOption$4[ebp]
  01224	50		 push	 eax
  01225	f3 0f 2c 47 28	 cvttss2si eax, DWORD PTR [edi+40]
  0122a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01230	50		 push	 eax
  01231	0f b6 87 96 00
	00 00		 movzx	 eax, BYTE PTR [edi+150]
  01238	50		 push	 eax
  01239	0f b6 87 95 00
	00 00		 movzx	 eax, BYTE PTR [edi+149]
  01240	50		 push	 eax
  01241	0f b6 87 94 00
	00 00		 movzx	 eax, BYTE PTR [edi+148]
  01248	50		 push	 eax
  01249	ff b5 08 ff ff
	ff		 push	 DWORD PTR _level$1$[ebp]
  0124f	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$[ebp]
  01252	ff b5 10 ff ff
	ff		 push	 DWORD PTR _type$1$[ebp]
  01258	50		 push	 eax
  01259	ff 77 04	 push	 DWORD PTR [edi+4]
  0125c	0f b6 84 0b 21
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+289]
  01264	50		 push	 eax
  01265	0f b6 84 0b 20
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+288]
  0126d	50		 push	 eax
  0126e	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map_num$1$[ebp]
  01274	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  01277	03 c3		 add	 eax, ebx
  01279	50		 push	 eax
  0127a	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0127d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  01282	03 c3		 add	 eax, ebx
  01284	50		 push	 eax
  01285	68 dd 01 00 00	 push	 477			; 000001ddH
  0128a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0128f	50		 push	 eax
  01290	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3882 : 								gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type,
; 3883 : 								level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (int)lpItem->m_Durability,
; 3884 : 								NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5],
; 3885 : 								NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7,
; 3886 : 								g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));
; 3887 : 
; 3888 : 							pResult.result = -3;
; 3889 : 							DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);			

  01296	0f b6 85 31 ff
	ff ff		 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0129d	50		 push	 eax
  0129e	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  012a4	c6 85 33 ff ff
	ff fd		 mov	 BYTE PTR _pResult$[ebp+3], 253 ; 000000fdH
  012ab	50		 push	 eax
  012ac	56		 push	 esi
  012ad	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3890 : 
; 3891 : 							gObj[aIndex].pInventory[pos].m_Durability += lpItem->m_Durability;

  012b2	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR _pos$1$[ebp]
  012b8	83 c4 70	 add	 esp, 112		; 00000070H
  012bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  012c0	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  012c6	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  012cd	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv3204[ebp], ecx
  012d3	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  012d9	f3 0f 58 47 28	 addss	 xmm0, DWORD PTR [edi+40]

; 3892 : 
; 3893 : 							if ( gObj[aIndex].pInventory[pos].m_Durability >= 5.0f )

  012de	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40a00000
  012e6	f3 0f 11 44 08
	24		 movss	 DWORD PTR [eax+ecx+36], xmm0
  012ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  012f1	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  012f8	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  012fe	0f 2f c1	 comiss	 xmm0, xmm1
  01301	0f 82 02 02 00
	00		 jb	 $LN105@CGItemGetR

; 3894 : 							{
; 3895 : 								int NewDur = (int)(gObj[aIndex].pInventory[pos].m_Durability - 5.0f);

  01307	f3 0f 5c c1	 subss	 xmm0, xmm1

; 3896 : 								::gObjInventoryItemSet(aIndex, pos, -1);

  0130b	68 ff 00 00 00	 push	 255			; 000000ffH
  01310	52		 push	 edx
  01311	56		 push	 esi
  01312	f3 0f 2c c0	 cvttss2si eax, xmm0
  01316	89 85 1c ff ff
	ff		 mov	 DWORD PTR _NewDur$1$[ebp], eax
  0131c	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 3897 : 								gObj[aIndex].pInventory[pos].Clear();

  01321	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01326	83 c4 0c	 add	 esp, 12			; 0000000cH
  01329	8b 8c 03 c0 11
	00 00		 mov	 ecx, DWORD PTR [ebx+eax+4544]
  01330	03 8d 24 ff ff
	ff		 add	 ecx, DWORD PTR tv3204[ebp]
  01336	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 3898 : 								::GCInventoryItemDeleteSend(aIndex, pos, 1);

  0133b	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _pos$1$[ebp]
  01341	6a 01		 push	 1
  01343	50		 push	 eax
  01344	56		 push	 esi
  01345	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0134a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3899 : 								::ItemSerialCreateSend(aIndex, 235, gObj[aIndex].X, gObj[aIndex].Y, ItemGetNumberMake(13, 146),

  0134d	6a 00		 push	 0
  0134f	6a 00		 push	 0
  01351	6a 00		 push	 0
  01353	6a 00		 push	 0
  01355	56		 push	 esi
  01356	6a 00		 push	 0
  01358	6a 00		 push	 0
  0135a	6a 00		 push	 0
  0135c	6a 00		 push	 0
  0135e	6a 00		 push	 0
  01360	68 92 00 00 00	 push	 146			; 00000092H
  01365	6a 0d		 push	 13			; 0000000dH
  01367	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0136c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01372	83 c4 08	 add	 esp, 8
  01375	50		 push	 eax
  01376	0f b6 84 0b 21
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+289]
  0137e	50		 push	 eax
  0137f	0f b6 84 0b 20
	01 00 00	 movzx	 eax, BYTE PTR [ebx+ecx+288]
  01387	50		 push	 eax
  01388	68 eb 00 00 00	 push	 235			; 000000ebH
  0138d	56		 push	 esi
  0138e	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEEPAE@Z ; ItemSerialCreateSend

; 3900 : 									0, 0, 0, 0, 0, aIndex, 0, 0);
; 3901 : 
; 3902 : 								LogAddTD("[Acheron] [%s][%s] Make Spirit Map (Left Old Map:%d)",

  01393	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01399	ff b5 1c ff ff
	ff		 push	 DWORD PTR _NewDur$1$[ebp]
  0139f	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  013a2	03 c3		 add	 eax, ebx
  013a4	50		 push	 eax
  013a5	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  013a8	03 c3		 add	 eax, ebx
  013aa	50		 push	 eax
  013ab	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@EMLONCAM@?$FLAcheron?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Make?5Spirit?5M@
  013b0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3903 : 									gObj[aIndex].AccountID, gObj[aIndex].Name, NewDur);
; 3904 : 
; 3905 : 								if ( NewDur > 0 )

  013b6	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR _NewDur$1$[ebp]
  013bc	83 c4 4c	 add	 esp, 76			; 0000004cH
  013bf	85 c0		 test	 eax, eax
  013c1	0f 8e 71 04 00
	00		 jle	 $LN246@CGItemGetR

; 3906 : 								{
; 3907 : 									lpItem->m_State = 2;
; 3908 : 									lpItem->Give = false;
; 3909 : 									lpItem->live = true;
; 3910 : 									lpItem->m_Durability = (float)NewDur;

  013c7	66 0f 6e c0	 movd	 xmm0, eax
  013cb	0f 5b c0	 cvtdq2ps xmm0, xmm0
  013ce	c7 87 dc 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edi+220], 2
  013d8	66 c7 87 da 00
	00 00 01 00	 mov	 WORD PTR [edi+218], 1
  013e1	f3 0f 11 47 28	 movss	 DWORD PTR [edi+40], xmm0
$LN18@CGItemGetR:

; 3856 : 			{
; 3857 : 				for ( int n=0;n<MAIN_INVENTORY_SIZE;n++)

  013e6	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _n$1$[ebp]
  013ec	41		 inc	 ecx
  013ed	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _n$1$[ebp], ecx
  013f3	81 f9 cc 00 00
	00		 cmp	 ecx, 204		; 000000ccH
  013f9	0f 8c d1 fc ff
	ff		 jl	 $LL20@CGItemGetR
$LN240@CGItemGetR:

; 3918 : 								
; 3919 : 							}
; 3920 : 							return;

  013ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN102@CGItemGetR:

; 3921 : 						}
; 3922 : 					}
; 3923 : 					else
; 3924 : 					{
; 3925 : 						break;
; 3926 : 					}
; 3927 : 				}
; 3928 : 			}
; 3929 : 
; 3930 : 			pResult.result = ::gObjInventoryInsertItemTemp(&gObj[aIndex], lpItem);

  01405	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  01408	57		 push	 edi
  01409	50		 push	 eax
  0140a	e8 00 00 00 00	 call	 ?gObjInventoryInsertItemTemp@@YAEPAUOBJECTSTRUCT@@PAVCMapItem@@@Z ; gObjInventoryInsertItemTemp
  0140f	83 c4 08	 add	 esp, 8
  01412	88 85 33 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], al

; 3931 : 
; 3932 : 			if ( pResult.result != 0xFF )

  01418	3c ff		 cmp	 al, 255			; 000000ffH
  0141a	0f 84 d9 ed ff
	ff		 je	 $LN108@CGItemGetR

; 3933 : 			{
; 3934 : 				ItemByteConvert((LPBYTE)&pResult.Data[0], lpItem->m_Type, lpItem->m_Option1, lpItem->m_Option2,

  01420	0f b6 87 cb 00
	00 00		 movzx	 eax, BYTE PTR [edi+203]
  01427	50		 push	 eax
  01428	8d 87 cc 00 00
	00		 lea	 eax, DWORD PTR [edi+204]
  0142e	50		 push	 eax
  0142f	0f b6 87 ca 00
	00 00		 movzx	 eax, BYTE PTR [edi+202]
  01436	50		 push	 eax
  01437	0f b6 87 c4 00
	00 00		 movzx	 eax, BYTE PTR [edi+196]
  0143e	50		 push	 eax
  0143f	0f b6 87 ae 00
	00 00		 movzx	 eax, BYTE PTR [edi+174]
  01446	50		 push	 eax
  01447	0f b6 87 97 00
	00 00		 movzx	 eax, BYTE PTR [edi+151]
  0144e	50		 push	 eax
  0144f	f3 0f 2c 47 28	 cvttss2si eax, DWORD PTR [edi+40]
  01454	0f b6 c0	 movzx	 eax, al
  01457	50		 push	 eax
  01458	0f b6 47 0c	 movzx	 eax, BYTE PTR [edi+12]
  0145c	50		 push	 eax
  0145d	0f b6 87 96 00
	00 00		 movzx	 eax, BYTE PTR [edi+150]
  01464	50		 push	 eax
  01465	0f b6 87 95 00
	00 00		 movzx	 eax, BYTE PTR [edi+149]
  0146c	50		 push	 eax
  0146d	0f b6 87 94 00
	00 00		 movzx	 eax, BYTE PTR [edi+148]
  01474	50		 push	 eax
  01475	0f bf 47 0a	 movsx	 eax, WORD PTR [edi+10]
  01479	50		 push	 eax
  0147a	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp+4]
  01480	50		 push	 eax
  01481	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEHEEEEEEEEE0E@Z ; ItemByteConvert

; 3935 : 					lpItem->m_Option3, lpItem->m_Level, (BYTE)lpItem->m_Durability, lpItem->m_NewOption,
; 3936 : 					lpItem->m_SetOption, lpItem->m_JewelOfHarmonyOption, lpItem->m_ItemOptionEx,
; 3937 : 					lpItem->m_SocketOption,lpItem->m_SocketBonus);
; 3938 : 
; 3939 : 				if ( MapC[map_num].ItemGive(aIndex, item_num, false) == TRUE )

  01486	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv3272[ebp]
  0148c	83 c4 34	 add	 esp, 52			; 00000034H
  0148f	6a 00		 push	 0
  01491	ff b5 18 ff ff
	ff		 push	 DWORD PTR _item_num$1$[ebp]
  01497	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  0149d	56		 push	 esi
  0149e	e8 00 00 00 00	 call	 ?ItemGive@MapClass@@QAEHHH_N@Z ; MapClass::ItemGive
  014a3	83 f8 01	 cmp	 eax, 1
  014a6	0f 85 4d ed ff
	ff		 jne	 $LN108@CGItemGetR

; 3940 : 				{
; 3941 : 					BYTE pos = ::gObjInventoryInsertItem(aIndex, lpItem);

  014ac	57		 push	 edi
  014ad	56		 push	 esi
  014ae	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z ; gObjInventoryInsertItem

; 3942 : 
; 3943 : 					if ( pos == 0xFF )

  014b3	0f b6 8d 33 ff
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+3]
  014ba	8a d8		 mov	 bl, al
  014bc	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  014c1	88 9d 2c ff ff
	ff		 mov	 BYTE PTR _pos$1[ebp], bl
  014c7	3a d8		 cmp	 bl, al
  014c9	0f 44 c8	 cmove	 ecx, eax

; 3944 : 						pResult.result = -1;
; 3945 : 
; 3946 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  014cc	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  014d2	88 8d 33 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+3], cl
  014d8	0f b6 8d 31 ff
	ff ff		 movzx	 ecx, BYTE PTR _pResult$[ebp+1]
  014df	51		 push	 ecx
  014e0	50		 push	 eax
  014e1	56		 push	 esi
  014e2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  014e7	83 c4 14	 add	 esp, 20			; 00000014H

; 3947 : 
; 3948 : 					if ( pos == 0xFF )

  014ea	80 fb ff	 cmp	 bl, 255			; 000000ffH
  014ed	75 53		 jne	 SHORT $LN113@CGItemGetR

; 3949 : 					{
; 3950 : 						::GCItemListSend(aIndex);

  014ef	56		 push	 esi
  014f0	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  014f5	83 c4 04	 add	 esp, 4
  014f8	5b		 pop	 ebx
  014f9	5f		 pop	 edi
  014fa	5e		 pop	 esi

; 4007 : 								map_num - (MAP_INDEX_ILLUSIONTEMPLE1 - 1),gObj[aIndex].AccountID,gObj[aIndex].Name,lpItem->m_Number);
; 4008 : 						}
; 4009 : #if (ENABLETEST_ARCA == 1)
; 4010 : 						if( g_ArcaBattle.IsArcaBattleServer() && lpItem->m_Type == AB_REW_KILL_TROPHY )
; 4011 : 						{
; 4012 : 							g_ArcaBattle.BootyItemGetCnt(gObj[aIndex]);
; 4013 : 						}
; 4014 : #endif
; 4015 : 					}
; 4016 : 				}
; 4017 : 				else
; 4018 : 				{
; 4019 : 					pResult.result = -1;
; 4020 : 					pResult.h.size -= sizeof(pResult.Data);
; 4021 : 
; 4022 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4023 : 				}
; 4024 : 			}
; 4025 : 			else
; 4026 : 			{
; 4027 : 				pResult.result = -1;
; 4028 : 				pResult.h.size -= sizeof(pResult.Data);
; 4029 : 
; 4030 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4031 : 			}
; 4032 : 		}
; 4033 : 	}
; 4034 : 	else
; 4035 : 	{
; 4036 : 		pResult.h.size -= sizeof(pResult.Data);
; 4037 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 4038 : 	}
; 4039 : }

  014fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  014fe	33 cd		 xor	 ecx, ebp
  01500	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01505	8b e5		 mov	 esp, ebp
  01507	5d		 pop	 ebp
  01508	c3		 ret	 0
$LN105@CGItemGetR:

; 3911 : 									continue;
; 3912 : 
; 3913 : 								}
; 3914 : 							}
; 3915 : 							else
; 3916 : 							{
; 3917 : 								GCItemDurSend(aIndex,pos, (BYTE)gObj[aIndex].pInventory[pos].m_Durability, 0);

  01509	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0150e	69 ca d4 00 00
	00		 imul	 ecx, edx, 212
  01514	6a 00		 push	 0
  01516	8b 84 03 c0 11
	00 00		 mov	 eax, DWORD PTR [ebx+eax+4544]
  0151d	f3 0f 2c 44 08
	24		 cvttss2si eax, DWORD PTR [eax+ecx+36]
  01523	0f b6 c0	 movzx	 eax, al
  01526	50		 push	 eax
  01527	52		 push	 edx
  01528	56		 push	 esi
  01529	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0152e	83 c4 10	 add	 esp, 16			; 00000010H
  01531	5b		 pop	 ebx
  01532	5f		 pop	 edi
  01533	5e		 pop	 esi

; 4007 : 								map_num - (MAP_INDEX_ILLUSIONTEMPLE1 - 1),gObj[aIndex].AccountID,gObj[aIndex].Name,lpItem->m_Number);
; 4008 : 						}
; 4009 : #if (ENABLETEST_ARCA == 1)
; 4010 : 						if( g_ArcaBattle.IsArcaBattleServer() && lpItem->m_Type == AB_REW_KILL_TROPHY )
; 4011 : 						{
; 4012 : 							g_ArcaBattle.BootyItemGetCnt(gObj[aIndex]);
; 4013 : 						}
; 4014 : #endif
; 4015 : 					}
; 4016 : 				}
; 4017 : 				else
; 4018 : 				{
; 4019 : 					pResult.result = -1;
; 4020 : 					pResult.h.size -= sizeof(pResult.Data);
; 4021 : 
; 4022 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4023 : 				}
; 4024 : 			}
; 4025 : 			else
; 4026 : 			{
; 4027 : 				pResult.result = -1;
; 4028 : 				pResult.h.size -= sizeof(pResult.Data);
; 4029 : 
; 4030 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4031 : 			}
; 4032 : 		}
; 4033 : 	}
; 4034 : 	else
; 4035 : 	{
; 4036 : 		pResult.h.size -= sizeof(pResult.Data);
; 4037 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 4038 : 	}
; 4039 : }

  01534	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01537	33 cd		 xor	 ecx, ebp
  01539	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0153e	8b e5		 mov	 esp, ebp
  01540	5d		 pop	 ebp
  01541	c3		 ret	 0
$LN113@CGItemGetR:

; 3951 : 					}
; 3952 : 					else
; 3953 : 					{
; 3954 : 						BYTE NewOption[MAX_EXOPTION_SIZE];
; 3955 : 
; 3956 : 						::ItemIsBufExOption(NewOption, (lpItem != NULL)?(CItem*)&lpItem->m_Number:NULL);

  01542	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]
  01545	8d 45 f4	 lea	 eax, DWORD PTR _NewOption$3[ebp]
  01548	53		 push	 ebx
  01549	50		 push	 eax
  0154a	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 3957 : 
; 3958 : 						LogAddTD(lMsg.Get(MSGGET(1, 221)), gObj[aIndex].AccountID, gObj[aIndex].Name, map_num,

  0154f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01555	83 c4 08	 add	 esp, 8
  01558	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0155d	53		 push	 ebx
  0155e	e8 00 00 00 00	 call	 ?GetItemOptionLevel@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemOptionLevel
  01563	0f b6 c0	 movzx	 eax, al
  01566	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kJewelOfHarmonySystem@@3VCJewelOfHarmonySystem@@A ; g_kJewelOfHarmonySystem
  0156b	50		 push	 eax
  0156c	53		 push	 ebx
  0156d	e8 00 00 00 00	 call	 ?GetItemStrengthenOption@CJewelOfHarmonySystem@@QAEEPAVCItem@@@Z ; CJewelOfHarmonySystem::GetItemStrengthenOption
  01572	0f b6 c0	 movzx	 eax, al
  01575	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0157a	50		 push	 eax
  0157b	0f b6 87 ca 00
	00 00		 movzx	 eax, BYTE PTR [edi+202]
  01582	c1 e8 07	 shr	 eax, 7
  01585	50		 push	 eax
  01586	0f b6 87 ae 00
	00 00		 movzx	 eax, BYTE PTR [edi+174]
  0158d	50		 push	 eax
  0158e	0f b6 45 fa	 movzx	 eax, BYTE PTR _NewOption$3[ebp+6]
  01592	50		 push	 eax
  01593	0f b6 45 f9	 movzx	 eax, BYTE PTR _NewOption$3[ebp+5]
  01597	50		 push	 eax
  01598	0f b6 45 f8	 movzx	 eax, BYTE PTR _NewOption$3[ebp+4]
  0159c	50		 push	 eax
  0159d	0f b6 45 f7	 movzx	 eax, BYTE PTR _NewOption$3[ebp+3]
  015a1	50		 push	 eax
  015a2	0f b6 45 f6	 movzx	 eax, BYTE PTR _NewOption$3[ebp+2]
  015a6	50		 push	 eax
  015a7	0f b6 45 f5	 movzx	 eax, BYTE PTR _NewOption$3[ebp+1]
  015ab	50		 push	 eax
  015ac	0f b6 45 f4	 movzx	 eax, BYTE PTR _NewOption$3[ebp]
  015b0	50		 push	 eax
  015b1	f3 0f 2c 47 28	 cvttss2si eax, DWORD PTR [edi+40]
  015b6	50		 push	 eax
  015b7	0f b6 87 96 00
	00 00		 movzx	 eax, BYTE PTR [edi+150]
  015be	50		 push	 eax
  015bf	0f b6 87 95 00
	00 00		 movzx	 eax, BYTE PTR [edi+149]
  015c6	50		 push	 eax
  015c7	0f b6 87 94 00
	00 00		 movzx	 eax, BYTE PTR [edi+148]
  015ce	50		 push	 eax
  015cf	ff b5 08 ff ff
	ff		 push	 DWORD PTR _level$1$[ebp]
  015d5	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$[ebp]
  015d8	ff b5 10 ff ff
	ff		 push	 DWORD PTR _type$1$[ebp]
  015de	50		 push	 eax
  015df	ff 33		 push	 DWORD PTR [ebx]
  015e1	8b 9d 04 ff ff
	ff		 mov	 ebx, DWORD PTR tv3283[ebp]
  015e7	0f b6 84 33 21
	01 00 00	 movzx	 eax, BYTE PTR [ebx+esi+289]
  015ef	50		 push	 eax
  015f0	0f b6 84 33 20
	01 00 00	 movzx	 eax, BYTE PTR [ebx+esi+288]
  015f8	50		 push	 eax
  015f9	ff b5 20 ff ff
	ff		 push	 DWORD PTR _map_num$1$[ebp]
  015ff	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  01602	03 c3		 add	 eax, ebx
  01604	50		 push	 eax
  01605	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  01608	03 c3		 add	 eax, ebx
  0160a	50		 push	 eax
  0160b	68 dd 01 00 00	 push	 477			; 000001ddH
  01610	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01615	50		 push	 eax
  01616	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 3959 : 							gObj[aIndex].X, gObj[aIndex].Y, lpItem->m_Number, szItemName, type,
; 3960 : 							level, lpItem->m_Option1, lpItem->m_Option2, lpItem->m_Option3, (INT)lpItem->m_Durability,
; 3961 : 							NewOption[0], NewOption[1], NewOption[2], NewOption[3], NewOption[4], NewOption[5],
; 3962 : 							NewOption[6], lpItem->m_SetOption, lpItem->m_ItemOptionEx>>7,
; 3963 : 							g_kJewelOfHarmonySystem.GetItemStrengthenOption((lpItem)?((CItem *)&lpItem->m_Number):NULL), g_kJewelOfHarmonySystem.GetItemOptionLevel((lpItem)?((CItem *)&lpItem->m_Number):NULL));
; 3964 : 						::GCSendGetItemInfoForParty(aIndex, lpItem);

  0161c	8b b5 14 ff ff
	ff		 mov	 esi, DWORD PTR _aIndex$GSCopy$1$[ebp]
  01622	57		 push	 edi
  01623	56		 push	 esi
  01624	e8 00 00 00 00	 call	 ?GCSendGetItemInfoForParty@@YAXHPAVCMapItem@@@Z ; GCSendGetItemInfoForParty

; 3965 : 
; 3966 : 						if ( BC_MAP_RANGE(map_num) )

  01629	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _map_num$1$[ebp]
  0162f	83 c4 6c	 add	 esp, 108		; 0000006cH
  01632	83 f9 34	 cmp	 ecx, 52			; 00000034H
  01635	74 19		 je	 SHORT $LN228@CGItemGetR
  01637	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0163a	0f 8c 1c 01 00
	00		 jl	 $LN116@CGItemGetR
  01640	33 c0		 xor	 eax, eax
  01642	83 f9 11	 cmp	 ecx, 17			; 00000011H
  01645	0f 9e c0	 setle	 al
  01648	85 c0		 test	 eax, eax
  0164a	0f 84 0c 01 00
	00		 je	 $LN116@CGItemGetR
$LN228@CGItemGetR:

; 3967 : 						{
; 3968 : 							int Bridge = g_BloodCastle.GetBridgeLevel(map_num);

  01650	51		 push	 ecx
  01651	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01656	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel

; 3969 : 							if ( g_BloodCastle.CheckQuestItemSerial(Bridge, lpItem) )

  0165b	57		 push	 edi
  0165c	50		 push	 eax
  0165d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01662	89 85 04 ff ff
	ff		 mov	 DWORD PTR _Bridge$1$[ebp], eax
  01668	e8 00 00 00 00	 call	 ?CheckQuestItemSerial@CBloodCastle@@QAE_NHPAVCMapItem@@@Z ; CBloodCastle::CheckQuestItemSerial
  0166d	84 c0		 test	 al, al
  0166f	0f 84 e1 00 00
	00		 je	 $LN245@CGItemGetR

; 3970 : 							{
; 3971 : 								g_BloodCastle.m_BridgeData[Bridge].m_iBC_QUEST_ITEM_USER_INDEX = gObj[aIndex].m_Index;

  01675	69 8d 04 ff ff
	ff 0c 02 00 00	 imul	 ecx, DWORD PTR _Bridge$1$[ebp], 524
  0167f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01685	8b 04 13	 mov	 eax, DWORD PTR [ebx+edx]
  01688	89 81 94 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+404], eax

; 3972 : 								int Bridge = g_BloodCastle.GetBridgeLevel(gObj[aIndex].MapNumber);

  0168e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  01693	0f b6 84 13 23
	01 00 00	 movzx	 eax, BYTE PTR [ebx+edx+291]
  0169b	50		 push	 eax
  0169c	e8 00 00 00 00	 call	 ?GetBridgeLevel@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetBridgeLevel

; 3973 : 
; 3974 : 								char szTempMsg[128];
; 3975 : 
; 3976 : 								switch ( lpItem->m_Level )

  016a1	0f bf 4f 0c	 movsx	 ecx, WORD PTR [edi+12]
  016a5	89 85 14 ff ff
	ff		 mov	 DWORD PTR _Bridge$1$[ebp], eax
  016ab	83 e9 00	 sub	 ecx, 0
  016ae	74 37		 je	 SHORT $LN117@CGItemGetR
  016b0	83 e9 01	 sub	 ecx, 1
  016b3	74 20		 je	 SHORT $LN118@CGItemGetR
  016b5	83 e9 01	 sub	 ecx, 1
  016b8	74 09		 je	 SHORT $LN119@CGItemGetR

; 3992 : 
; 3993 : 									default:
; 3994 : 										szTempMsg[0] = 0;

  016ba	c6 85 40 ff ff
	ff 00		 mov	 BYTE PTR _szTempMsg$2[ebp], 0
  016c1	eb 66		 jmp	 SHORT $LN24@CGItemGetR
$LN119@CGItemGetR:

; 3987 : 
; 3988 : 									case 2:	// Crossbow of Archangel
; 3989 : 										wsprintf(szTempMsg, lMsg.Get(MSGGET(4, 152)), gObj[aIndex].Name);

  016c3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016c8	83 c0 5d	 add	 eax, 93			; 0000005dH
  016cb	03 c3		 add	 eax, ebx
  016cd	50		 push	 eax
  016ce	68 98 04 00 00	 push	 1176			; 00000498H

; 3990 : 										g_BloodCastle.SendNoticeMessage(Bridge, szTempMsg);
; 3991 : 										break;

  016d3	eb 22		 jmp	 SHORT $LN250@CGItemGetR
$LN118@CGItemGetR:

; 3981 : 										break;
; 3982 : 
; 3983 : 									case 1:	// Sword of Archangel
; 3984 : 										wsprintf(szTempMsg, lMsg.Get(MSGGET(4, 151)), gObj[aIndex].Name);

  016d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016da	83 c0 5d	 add	 eax, 93			; 0000005dH
  016dd	03 c3		 add	 eax, ebx
  016df	50		 push	 eax
  016e0	68 97 04 00 00	 push	 1175			; 00000497H

; 3985 : 										g_BloodCastle.SendNoticeMessage(Bridge, szTempMsg);
; 3986 : 										break;

  016e5	eb 10		 jmp	 SHORT $LN250@CGItemGetR
$LN117@CGItemGetR:

; 3977 : 								{
; 3978 : 									case 0:	// Staff of Archangel
; 3979 : 										wsprintf(szTempMsg, lMsg.Get(MSGGET(4, 150)), gObj[aIndex].Name);

  016e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  016ec	83 c0 5d	 add	 eax, 93			; 0000005dH
  016ef	03 c3		 add	 eax, ebx
  016f1	50		 push	 eax
  016f2	68 96 04 00 00	 push	 1174			; 00000496H
$LN250@CGItemGetR:
  016f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  016fc	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  01701	50		 push	 eax
  01702	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _szTempMsg$2[ebp]
  01708	50		 push	 eax
  01709	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0170f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3980 : 										g_BloodCastle.SendNoticeMessage(Bridge, szTempMsg);

  01712	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _szTempMsg$2[ebp]
  01718	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0171d	50		 push	 eax
  0171e	ff b5 14 ff ff
	ff		 push	 DWORD PTR _Bridge$1$[ebp]
  01724	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage
$LN24@CGItemGetR:

; 3995 : 								}
; 3996 : 
; 3997 : 								LogAddTD("[Blood Castle] (%d) (Account:%s, Name:%s) picked up Angel King's Weapon (%d)",

  01729	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0172f	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  01733	50		 push	 eax
  01734	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  01737	03 c3		 add	 eax, ebx
  01739	50		 push	 eax
  0173a	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0173d	03 c3		 add	 eax, ebx
  0173f	50		 push	 eax
  01740	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _Bridge$1$[ebp]
  01746	40		 inc	 eax
  01747	50		 push	 eax
  01748	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@INJOAAFP@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3?$CFs?0@
  0174d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01753	83 c4 14	 add	 esp, 20			; 00000014H
$LN245@CGItemGetR:
  01756	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _map_num$1$[ebp]
$LN116@CGItemGetR:

; 3998 : 									Bridge+1, gObj[aIndex].AccountID, gObj[aIndex].Name, lpItem->m_Level);
; 3999 : 							}
; 4000 : 						}
; 4001 : 						
; 4002 : 						if ( IT_MAP_RANGE(map_num) && lpItem->m_Type == ITEMGET(14,64) )

  0175c	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  0175f	0f 8c d3 00 00
	00		 jl	 $LN246@CGItemGetR
  01765	33 c0		 xor	 eax, eax
  01767	83 f9 32	 cmp	 ecx, 50			; 00000032H
  0176a	0f 9e c0	 setle	 al
  0176d	85 c0		 test	 eax, eax
  0176f	0f 84 c3 00 00
	00		 je	 $LN246@CGItemGetR
  01775	b8 40 1c 00 00	 mov	 eax, 7232		; 00001c40H
  0177a	66 39 47 0a	 cmp	 WORD PTR [edi+10], ax
  0177e	0f 85 b4 00 00
	00		 jne	 $LN246@CGItemGetR

; 4003 : 						{
; 4004 : 							g_IllusionTemple.PickupRelic(gObj[aIndex].MapNumber,aIndex,pos);

  01784	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  01789	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  0178e	ff b5 2c ff ff
	ff		 push	 DWORD PTR _pos$1[ebp]
  01794	56		 push	 esi
  01795	0f b6 84 03 23
	01 00 00	 movzx	 eax, BYTE PTR [ebx+eax+291]
  0179d	50		 push	 eax
  0179e	e8 00 00 00 00	 call	 ?PickupRelic@CIllusionTempleEvent@@QAEXEHE@Z ; CIllusionTempleEvent::PickupRelic

; 4005 : 							g_IllusionTemple.PickupRelicSend(&gObj[aIndex]);

  017a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  017ad	03 c3		 add	 eax, ebx
  017af	50		 push	 eax
  017b0	e8 00 00 00 00	 call	 ?PickupRelicSend@CIllusionTempleEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CIllusionTempleEvent::PickupRelicSend

; 4006 : 							LogAddTD("[Illusion Temple] (%d) (Account:%s, Name:%s) picked up Relics Item(serial:%u)",

  017b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  017bb	ff 77 04	 push	 DWORD PTR [edi+4]
  017be	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  017c1	03 c3		 add	 eax, ebx
  017c3	50		 push	 eax
  017c4	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  017c7	03 c3		 add	 eax, ebx
  017c9	50		 push	 eax
  017ca	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _map_num$1$[ebp]
  017d0	83 c0 d4	 add	 eax, -44		; ffffffd4H
  017d3	50		 push	 eax
  017d4	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@IHPJKMLA@?$FLIllusion?5Temple?$FN?5?$CI?$CFd?$CJ?5?$CIAccount?3@
  017d9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  017df	83 c4 14	 add	 esp, 20			; 00000014H
  017e2	5b		 pop	 ebx
  017e3	5f		 pop	 edi
  017e4	5e		 pop	 esi

; 4007 : 								map_num - (MAP_INDEX_ILLUSIONTEMPLE1 - 1),gObj[aIndex].AccountID,gObj[aIndex].Name,lpItem->m_Number);
; 4008 : 						}
; 4009 : #if (ENABLETEST_ARCA == 1)
; 4010 : 						if( g_ArcaBattle.IsArcaBattleServer() && lpItem->m_Type == AB_REW_KILL_TROPHY )
; 4011 : 						{
; 4012 : 							g_ArcaBattle.BootyItemGetCnt(gObj[aIndex]);
; 4013 : 						}
; 4014 : #endif
; 4015 : 					}
; 4016 : 				}
; 4017 : 				else
; 4018 : 				{
; 4019 : 					pResult.result = -1;
; 4020 : 					pResult.h.size -= sizeof(pResult.Data);
; 4021 : 
; 4022 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4023 : 				}
; 4024 : 			}
; 4025 : 			else
; 4026 : 			{
; 4027 : 				pResult.result = -1;
; 4028 : 				pResult.h.size -= sizeof(pResult.Data);
; 4029 : 
; 4030 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4031 : 			}
; 4032 : 		}
; 4033 : 	}
; 4034 : 	else
; 4035 : 	{
; 4036 : 		pResult.h.size -= sizeof(pResult.Data);
; 4037 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 4038 : 	}
; 4039 : }

  017e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017e8	33 cd		 xor	 ecx, ebp
  017ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017ef	8b e5		 mov	 esp, ebp
  017f1	5d		 pop	 ebp
  017f2	c3		 ret	 0
$LN227@CGItemGetR:

; 3354 : 	{
; 3355 : 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  017f3	68 1b 0d 00 00	 push	 3355			; 00000d1bH

; 3356 : 		pResult.result = -1;
; 3357 : 		pResult.h.size -= sizeof(pResult.Data);
; 3358 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 3359 : 
; 3360 : 		return;

  017f8	eb 05		 jmp	 SHORT $LN251@CGItemGetR
$LN226@CGItemGetR:

; 3342 : 	{
; 3343 : 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  017fa	68 0f 0d 00 00	 push	 3343			; 00000d0fH
$LN251@CGItemGetR:
  017ff	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  01804	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd?$AA@
  01809	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
$LN247@CGItemGetR:

; 3344 : 		pResult.result = -1;
; 3345 : 		pResult.h.size -= sizeof(pResult.Data);

  0180f	8a 85 31 ff ff
	ff		 mov	 al, BYTE PTR _pResult$[ebp+1]
  01815	04 f4		 add	 al, 244			; 000000f4H
  01817	c6 85 33 ff ff
	ff ff		 mov	 BYTE PTR _pResult$[ebp+3], 255 ; 000000ffH
  0181e	88 85 31 ff ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 3346 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  01824	0f b6 c0	 movzx	 eax, al
  01827	50		 push	 eax
  01828	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  0182e	50		 push	 eax
  0182f	56		 push	 esi
  01830	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01835	83 c4 18	 add	 esp, 24			; 00000018H
$LN246@CGItemGetR:

; 4007 : 								map_num - (MAP_INDEX_ILLUSIONTEMPLE1 - 1),gObj[aIndex].AccountID,gObj[aIndex].Name,lpItem->m_Number);
; 4008 : 						}
; 4009 : #if (ENABLETEST_ARCA == 1)
; 4010 : 						if( g_ArcaBattle.IsArcaBattleServer() && lpItem->m_Type == AB_REW_KILL_TROPHY )
; 4011 : 						{
; 4012 : 							g_ArcaBattle.BootyItemGetCnt(gObj[aIndex]);
; 4013 : 						}
; 4014 : #endif
; 4015 : 					}
; 4016 : 				}
; 4017 : 				else
; 4018 : 				{
; 4019 : 					pResult.result = -1;
; 4020 : 					pResult.h.size -= sizeof(pResult.Data);
; 4021 : 
; 4022 : 					DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4023 : 				}
; 4024 : 			}
; 4025 : 			else
; 4026 : 			{
; 4027 : 				pResult.result = -1;
; 4028 : 				pResult.h.size -= sizeof(pResult.Data);
; 4029 : 
; 4030 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 4031 : 			}
; 4032 : 		}
; 4033 : 	}
; 4034 : 	else
; 4035 : 	{
; 4036 : 		pResult.h.size -= sizeof(pResult.Data);
; 4037 : 		DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);
; 4038 : 	}
; 4039 : }

  01838	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0183b	5b		 pop	 ebx
  0183c	5f		 pop	 edi
  0183d	33 cd		 xor	 ecx, ebp
  0183f	5e		 pop	 esi
  01840	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01845	8b e5		 mov	 esp, ebp
  01847	5d		 pop	 ebp
  01848	c3		 ret	 0
  01849	0f 1f 00	 npad	 3
$LN257@CGItemGetR:
  0184c	00 00 00 00	 DD	 $LN69@CGItemGetR
  01850	00 00 00 00	 DD	 $LN69@CGItemGetR
  01854	00 00 00 00	 DD	 $LN69@CGItemGetR
  01858	00 00 00 00	 DD	 $LN64@CGItemGetR
  0185c	00 00 00 00	 DD	 $LN65@CGItemGetR
  01860	00 00 00 00	 DD	 $LN66@CGItemGetR
?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ENDP	; CGItemGetRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCItemInventoryPutSend@@YAXHEEE@Z
_TEXT	SEGMENT
_pResult$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
_iteminfo1$ = 16					; size = 1
_iteminfo2$ = 20					; size = 1
?GCItemInventoryPutSend@@YAXHEEE@Z PROC			; GCItemInventoryPutSend, COMDAT

; 3263 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3264 : 	PMSG_ITEMGETRESULT pResult;
; 3265 : 
; 3266 : 	pResult.h.c = 0xC3;
; 3267 : 	pResult.h.headcode = 0x22;
; 3268 : 	pResult.h.size = sizeof(pResult);
; 3269 : 	pResult.result = result;

  00010	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00013	88 45 ef	 mov	 BYTE PTR _pResult$[ebp+3], al

; 3270 : 	pResult.Data[0] = iteminfo1;

  00016	8a 45 10	 mov	 al, BYTE PTR _iteminfo1$[ebp]
  00019	88 45 f0	 mov	 BYTE PTR _pResult$[ebp+4], al

; 3271 : 	pResult.Data[1] = iteminfo2;

  0001c	8a 45 14	 mov	 al, BYTE PTR _iteminfo2$[ebp]
  0001f	88 45 f1	 mov	 BYTE PTR _pResult$[ebp+5], al

; 3272 : 	pResult.h.size -= 2;
; 3273 : 
; 3274 : 	DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  00022	8d 45 ec	 lea	 eax, DWORD PTR _pResult$[ebp]
  00025	6a 0e		 push	 14			; 0000000eH
  00027	50		 push	 eax
  00028	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0002b	66 c7 45 ec c3
	0e		 mov	 WORD PTR _pResult$[ebp], 3779 ; 00000ec3H
  00031	c6 45 ee 22	 mov	 BYTE PTR _pResult$[ebp+2], 34 ; 00000022H
  00035	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3275 : }

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	33 cd		 xor	 ecx, ebp
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?GCItemInventoryPutSend@@YAXHEEE@Z ENDP			; GCItemInventoryPutSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCMoneySend@@YAXHK@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_money$ = 12						; size = 4
?GCMoneySend@@YAXHK@Z PROC				; GCMoneySend, COMDAT

; 3242 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3243 : 	PMSG_ITEMGETRESULT pMsg;
; 3244 : 
; 3245 : 	pMsg.h.c = 0xC3;
; 3246 : 	pMsg.h.headcode = 0x22;
; 3247 : 	pMsg.h.size = sizeof(pMsg);
; 3248 : 	pMsg.result = 0xFE;
; 3249 : 
; 3250 : 	WORD hiWord = SET_NUMBERHW(money);

  00010	8b 55 0c	 mov	 edx, DWORD PTR _money$[ebp]
  00013	8b ca		 mov	 ecx, edx
  00015	c1 e9 10	 shr	 ecx, 16			; 00000010H

; 3251 : 	WORD loWord = SET_NUMBERLW(money);
; 3252 : 	pMsg.Data[0] = SET_NUMBERH(hiWord);

  00018	8b c1		 mov	 eax, ecx
  0001a	c7 45 ec c3 10
	22 fe		 mov	 DWORD PTR _pMsg$[ebp], -31321917 ; fe2210c3H
  00021	c1 e8 08	 shr	 eax, 8
  00024	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 3253 : 	pMsg.Data[1] = SET_NUMBERL(hiWord);
; 3254 : 	pMsg.Data[2] = SET_NUMBERH(loWord);

  00027	8b c2		 mov	 eax, edx
  00029	c1 e8 08	 shr	 eax, 8
  0002c	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 3255 : 	pMsg.Data[3] = SET_NUMBERL(loWord);
; 3256 : 
; 3257 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0002f	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00032	6a 10		 push	 16			; 00000010H
  00034	50		 push	 eax
  00035	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00038	88 4d f1	 mov	 BYTE PTR _pMsg$[ebp+5], cl
  0003b	88 55 f3	 mov	 BYTE PTR _pMsg$[ebp+7], dl
  0003e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3258 : }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	33 cd		 xor	 ecx, ebp
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?GCMoneySend@@YAXHK@Z ENDP				; GCMoneySend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSkillKeySend@@YAXHPAEEEEEEEK@Z
_TEXT	SEGMENT
_pMsg$ = -40						; size = 34
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_keybuffer$ = 12					; size = 4
_GO$ = 16						; size = 1
_Qk$ = 20						; size = 1
_Wk$ = 24						; size = 1
_Ek$ = 28						; size = 1
_ChatWnd$ = 32						; size = 1
_Rk$ = 36						; size = 1
_QWERLevel$ = 40					; size = 4
?GCSkillKeySend@@YAXHPAEEEEEEEK@Z PROC			; GCSkillKeySend, COMDAT

; 3214 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR _keybuffer$[ebp]

; 3215 : 	PMSG_SKILLKEY pMsg;
; 3216 : 
; 3217 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x30, sizeof(pMsg));

  00015	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00018	6a 22		 push	 34			; 00000022H
  0001a	6a 30		 push	 48			; 00000030H
  0001c	68 f3 00 00 00	 push	 243			; 000000f3H
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3218 : 	memcpy(pMsg.SKillKey, keybuffer, sizeof(pMsg.SKillKey));

  00027	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002a	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]

; 3219 : 	pMsg.GameOption = GO;
; 3220 : 	pMsg.QkeyDefine = Qk;
; 3221 : 	pMsg.WkeyDefine = Wk;
; 3222 : 	pMsg.EkeyDefine = Ek;

  0002d	8a 7d 1c	 mov	 bh, BYTE PTR _Ek$[ebp]

; 3223 : 	pMsg.ChatWindow = ChatWnd;
; 3224 : 	pMsg.RkeyDefine = Rk;

  00030	8a 5d 24	 mov	 bl, BYTE PTR _Rk$[ebp]

; 3225 : 	pMsg.QWERLevel = QWERLevel;

  00033	8b 75 28	 mov	 esi, DWORD PTR _QWERLevel$[ebp]
  00036	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+20], eax
  00039	8a 45 10	 mov	 al, BYTE PTR _GO$[ebp]
  0003c	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+24], al
  0003f	8a 45 14	 mov	 al, BYTE PTR _Qk$[ebp]
  00042	88 45 f1	 mov	 BYTE PTR _pMsg$[ebp+25], al
  00045	8a 45 18	 mov	 al, BYTE PTR _Wk$[ebp]
  00048	88 45 f2	 mov	 BYTE PTR _pMsg$[ebp+26], al
  0004b	8a 45 20	 mov	 al, BYTE PTR _ChatWnd$[ebp]
  0004e	88 45 f4	 mov	 BYTE PTR _pMsg$[ebp+28], al

; 3226 : 
; 3227 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00051	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00055	50		 push	 eax
  00056	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00059	88 7d f3	 mov	 BYTE PTR _pMsg$[ebp+27], bh
  0005c	50		 push	 eax
  0005d	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00060	0f 11 45 dc	 movups	 XMMWORD PTR _pMsg$[ebp+4], xmm0
  00064	88 5d f5	 mov	 BYTE PTR _pMsg$[ebp+29], bl
  00067	89 75 f6	 mov	 DWORD PTR _pMsg$[ebp+30], esi
  0006a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3228 : 	LogAddL("Option Send %d %d %d %d %d %d", GO, Qk, Wk, Ek, Rk, QWERLevel);

  0006f	56		 push	 esi
  00070	0f b6 c3	 movzx	 eax, bl
  00073	50		 push	 eax
  00074	0f b6 c7	 movzx	 eax, bh
  00077	50		 push	 eax
  00078	0f b6 45 18	 movzx	 eax, BYTE PTR _Wk$[ebp]
  0007c	50		 push	 eax
  0007d	0f b6 45 14	 movzx	 eax, BYTE PTR _Qk$[ebp]
  00081	50		 push	 eax
  00082	0f b6 45 10	 movzx	 eax, BYTE PTR _GO$[ebp]
  00086	50		 push	 eax
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KLPIKBAN@Option?5Send?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL

; 3229 : }

  00092	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00095	83 c4 38	 add	 esp, 56			; 00000038H
  00098	33 cd		 xor	 ecx, ebp
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?GCSkillKeySend@@YAXHPAEEEEEEEK@Z ENDP			; GCSkillKeySend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z
_TEXT	SEGMENT
_RkeyDefine$ = -4					; size = 1
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z PROC		; GCSkillKeyRecv, COMDAT

; 3183 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3184 : 	if ( !gObjIsGamePlaing(&gObj[aIndex]))

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	57		 push	 edi
  0000a	69 7d 0c 40 27
	00 00		 imul	 edi, DWORD PTR _aIndex$[ebp], 10048
  00011	03 c7		 add	 eax, edi
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?gObjIsGamePlaing@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsGamePlaing
  00019	83 c4 04	 add	 esp, 4
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 98 00 00
	00		 je	 $LN1@GCSkillKey

; 3185 : 		return;
; 3186 : 
; 3187 : 	if ( gObj[aIndex].iOptionRecv == TRUE )

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00029	80 bc 07 7c 24
	00 00 01	 cmp	 BYTE PTR [edi+eax+9340], 1
  00031	0f 84 85 00 00
	00		 je	 $LN1@GCSkillKey

; 3188 : 		return;
; 3189 : 
; 3190 : 	gObj[aIndex].iOptionRecv = TRUE;
; 3191 : 
; 3192 : 	BYTE RkeyDefine = 0;
; 3193 : 	RkeyDefine = lpMsg->RkeyDefine;

  00037	53		 push	 ebx
  00038	56		 push	 esi
  00039	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  0003c	c6 84 07 7c 24
	00 00 01	 mov	 BYTE PTR [edi+eax+9340], 1
  00044	8a 5e 1d	 mov	 bl, BYTE PTR [esi+29]

; 3194 : 
; 3195 : 	DWORD QWERLevel = 0;
; 3196 : 	QWERLevel = ntohl(lpMsg->QWERLevel);

  00047	ff 76 1e	 push	 DWORD PTR [esi+30]
  0004a	88 5d fc	 mov	 BYTE PTR _RkeyDefine$[ebp], bl
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ntohl@4

; 3197 : 
; 3198 : 	DGOptionDataSend(aIndex, gObj[aIndex].Name,

  00053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00059	0f b6 8c 3a 12
	27 00 00	 movzx	 ecx, BYTE PTR [edx+edi+10002]
  00061	51		 push	 ecx
  00062	50		 push	 eax
  00063	ff 75 fc	 push	 DWORD PTR _RkeyDefine$[ebp]
  00066	0f b6 46 1c	 movzx	 eax, BYTE PTR [esi+28]
  0006a	50		 push	 eax
  0006b	0f b6 46 1b	 movzx	 eax, BYTE PTR [esi+27]
  0006f	50		 push	 eax
  00070	0f b6 46 1a	 movzx	 eax, BYTE PTR [esi+26]
  00074	50		 push	 eax
  00075	0f b6 46 19	 movzx	 eax, BYTE PTR [esi+25]
  00079	50		 push	 eax
  0007a	0f b6 46 18	 movzx	 eax, BYTE PTR [esi+24]
  0007e	50		 push	 eax
  0007f	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00082	50		 push	 eax
  00083	8d 42 5d	 lea	 eax, DWORD PTR [edx+93]
  00086	03 c7		 add	 eax, edi
  00088	50		 push	 eax
  00089	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  0008c	e8 00 00 00 00	 call	 ?DGOptionDataSend@@YAXHPADPAEEEEEEEKD@Z ; DGOptionDataSend

; 3199 : 		lpMsg->SKillKey, lpMsg->GameOption,
; 3200 : 		lpMsg->QkeyDefine,  lpMsg->WkeyDefine, lpMsg->EkeyDefine,lpMsg->ChatWindow,RkeyDefine,QWERLevel, gObj[aIndex].m_EnableUseChangeSkin);
; 3201 : 
; 3202 : 	LogAddL("Option Recv %d %d %d %d %d %d", lpMsg->GameOption,

  00091	ff 76 1e	 push	 DWORD PTR [esi+30]
  00094	0f b6 c3	 movzx	 eax, bl
  00097	50		 push	 eax
  00098	0f b6 46 1b	 movzx	 eax, BYTE PTR [esi+27]
  0009c	50		 push	 eax
  0009d	0f b6 46 1a	 movzx	 eax, BYTE PTR [esi+26]
  000a1	50		 push	 eax
  000a2	0f b6 46 19	 movzx	 eax, BYTE PTR [esi+25]
  000a6	50		 push	 eax
  000a7	0f b6 46 18	 movzx	 eax, BYTE PTR [esi+24]
  000ab	50		 push	 eax
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LCFCBICD@Option?5Recv?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?5?$CFd?$AA@
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  000b7	83 c4 48	 add	 esp, 72			; 00000048H
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
$LN1@GCSkillKey:
  000bc	5f		 pop	 edi

; 3203 : 		lpMsg->QkeyDefine,  lpMsg->WkeyDefine, lpMsg->EkeyDefine, RkeyDefine, lpMsg->QWERLevel);
; 3204 : }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z ENDP		; GCSkillKeyRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCGoalSend@@YAXHPADE0E@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 22
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Name1$ = 12						; size = 4
_score1$ = 16						; size = 1
_Name2$ = 20						; size = 4
_score2$ = 24						; size = 1
?GCGoalSend@@YAXHPADE0E@Z PROC				; GCGoalSend, COMDAT

; 3167 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _Name1$[ebp]

; 3168 : 	PMSG_GOALSEND pMsg;
; 3169 : 
; 3170 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x23, sizeof(pMsg));

  00014	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 14	 mov	 edi, DWORD PTR _Name2$[ebp]
  0001b	6a 16		 push	 22			; 00000016H
  0001d	6a 23		 push	 35			; 00000023H
  0001f	68 f3 00 00 00	 push	 243			; 000000f3H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3171 : 	memcpy(pMsg.RedTeamName, Name1, sizeof(pMsg.RedTeamName));

  0002a	8b 06		 mov	 eax, DWORD PTR [esi]
  0002c	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+4], eax
  0002f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00032	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 3172 : 	pMsg.RedTeamScore = score1;

  00035	8a 45 10	 mov	 al, BYTE PTR _score1$[ebp]
  00038	88 45 f0	 mov	 BYTE PTR _pMsg$[ebp+12], al

; 3173 : 	memcpy(pMsg.BlueTeamName, Name2, sizeof(pMsg.BlueTeamName));

  0003b	8b 07		 mov	 eax, DWORD PTR [edi]
  0003d	89 45 f1	 mov	 DWORD PTR _pMsg$[ebp+13], eax
  00040	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00043	89 45 f5	 mov	 DWORD PTR _pMsg$[ebp+17], eax

; 3174 : 	pMsg.BlueTeamScore = score2;

  00046	8a 45 18	 mov	 al, BYTE PTR _score2$[ebp]
  00049	88 45 f9	 mov	 BYTE PTR _pMsg$[ebp+21], al

; 3175 : 
; 3176 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0004c	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00050	50		 push	 eax
  00051	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00054	50		 push	 eax
  00055	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00058	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3177 : }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	83 c4 1c	 add	 esp, 28			; 0000001cH
  00063	33 cd		 xor	 ecx, ebp
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?GCGoalSend@@YAXHPADE0E@Z ENDP				; GCGoalSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCTimeViewSend@@YAXHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
_second$ = 12						; size = 4
?GCTimeViewSend@@YAXHH@Z PROC				; GCTimeViewSend, COMDAT

; 3143 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3144 : 	PMSG_TIMEVIEW pMsg;
; 3145 : 
; 3146 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x22, sizeof(pMsg));

  00006	6a 06		 push	 6
  00008	6a 22		 push	 34			; 00000022H
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 f3 00 00 00	 push	 243			; 000000f3H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3147 : 	pMsg.Second = second;

  00018	66 8b 45 0c	 mov	 ax, WORD PTR _second$[ebp]
  0001c	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 3148 : 
; 3149 : 	DataSend(aIndex, (UCHAR *)&pMsg, pMsg.h.size);

  00020	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00024	50		 push	 eax
  00025	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00028	50		 push	 eax
  00029	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3150 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?GCTimeViewSend@@YAXHH@Z ENDP				; GCTimeViewSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCRecallMonLife@@YAXHHH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_maxlife$ = 12						; size = 4
_life$ = 16						; size = 4
?GCRecallMonLife@@YAXHHH@Z PROC				; GCRecallMonLife, COMDAT

; 3118 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3119 : 	if ( maxlife <= 0 )

  00006	83 7d 0c 00	 cmp	 DWORD PTR _maxlife$[ebp], 0
  0000a	7e 31		 jle	 SHORT $LN1@GCRecallMo

; 3120 : 		return;
; 3121 : 	
; 3122 : 	PMSG_RECALLMONLIFE pMsg;
; 3123 : 	BYTE per = life * 100 / maxlife;
; 3124 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x20, sizeof(pMsg));

  0000c	6a 05		 push	 5
  0000e	6a 20		 push	 32			; 00000020H
  00010	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00013	68 f3 00 00 00	 push	 243			; 000000f3H
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0001e	6b 45 10 64	 imul	 eax, DWORD PTR _life$[ebp], 100
  00022	99		 cdq
  00023	f7 7d 0c	 idiv	 DWORD PTR _maxlife$[ebp]

; 3125 : 	pMsg.Life = per;

  00026	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 3126 : 
; 3127 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00029	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0002d	50		 push	 eax
  0002e	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00031	50		 push	 eax
  00032	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00035	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003a	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@GCRecallMo:

; 3128 : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?GCRecallMonLife@@YAXHHH@Z ENDP				; GCRecallMonLife
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCEquipmentSend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCEquipmentSend@@YAXH@Z PROC				; GCEquipmentSend, COMDAT

; 3094 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 3095 : 	PMSG_EQUIPMENTLIST pMsg;
; 3096 : 
; 3097 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x13, sizeof(pMsg));

  00014	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 18		 push	 24			; 00000018H
  00019	6a 13		 push	 19			; 00000013H
  0001b	68 f3 00 00 00	 push	 243			; 000000f3H
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3098 : 	pMsg.NumberH = SET_NUMBERH(aIndex);

  00026	8b c3		 mov	 eax, ebx

; 3099 : 	pMsg.NumberL = SET_NUMBERL(aIndex);

  00028	88 5d e9	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  0002b	c1 e8 08	 shr	 eax, 8

; 3100 : 	gObjMakePreviewCharSet(aIndex);

  0002e	53		 push	 ebx
  0002f	88 45 e8	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00032	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet

; 3101 : 	LPOBJ lpObj = &gObj[aIndex];

  00037	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  0003d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 3102 : 
; 3103 : 	memcpy(pMsg.Equipment, lpObj->CharSet, sizeof(lpObj->CharSet));

  00043	0f 10 81 84 08
	00 00		 movups	 xmm0, XMMWORD PTR [ecx+2180]
  0004a	0f 11 45 ea	 movups	 XMMWORD PTR _pMsg$[ebp+6], xmm0
  0004e	66 8b 81 94 08
	00 00		 mov	 ax, WORD PTR [ecx+2196]
  00055	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+22], ax

; 3104 : 	MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  00059	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0005d	50		 push	 eax
  0005e	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00061	50		 push	 eax
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 3105 : }

  00068	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006b	83 c4 20	 add	 esp, 32			; 00000020H
  0006e	33 cd		 xor	 ecx, ebp
  00070	5b		 pop	 ebx
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?GCEquipmentSend@@YAXH@Z ENDP				; GCEquipmentSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_pCount$ = -1024					; size = 6
_pList$ = -1016						; size = 4
_Count$1$ = -1012					; size = 4
_lOfs$1$ = -1008					; size = 4
_sendbuf$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_btListType$ = 12					; size = 1
?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z PROC	; GCMagicListMultiSend, COMDAT

; 3036 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 04 00
	00		 sub	 esp, 1024		; 00000400H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3037 : 	PMSG_MAGICLISTCOUNT pCount;
; 3038 : 	PMSG_MAGICLIST pList;
; 3039 : 	BYTE sendbuf[1000];
; 3040 : 	int lOfs = sizeof(pCount);
; 3041 : 	int Count = 0;
; 3042 : 	pCount.btListType = btListType;

  00013	8a 45 0c	 mov	 al, BYTE PTR _btListType$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 3043 : 
; 3044 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  0001c	6a 00		 push	 0
  0001e	6a 11		 push	 17			; 00000011H
  00020	88 85 05 fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], al
  00026	8d 85 00 fc ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0002c	68 f3 00 00 00	 push	 243			; 000000f3H
  00031	50		 push	 eax
  00032	c7 85 10 fc ff
	ff 06 00 00 00	 mov	 DWORD PTR _lOfs$1$[ebp], 6
  0003c	c7 85 0c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _Count$1$[ebp], 0
  00046	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0004b	83 c4 10	 add	 esp, 16			; 00000010H

; 3045 : 
; 3046 : 	for ( int n=0;n<MAX_MAGIC;n++)

  0004e	33 db		 xor	 ebx, ebx
  00050	33 f6		 xor	 esi, esi
$LL4@GCMagicLis:

; 3047 : 	{
; 3048 : 		if ( lpObj->Magic[n].IsMagic() == TRUE )

  00052	8b 8f a8 06 00
	00		 mov	 ecx, DWORD PTR [edi+1704]
  00058	03 ce		 add	 ecx, esi
  0005a	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0005f	83 f8 01	 cmp	 eax, 1
  00062	0f 85 b8 00 00
	00		 jne	 $LN19@GCMagicLis

; 3049 : 		{
; 3050 : 			if( !g_MasterSkillSystem.CheckUsableWeaponSkill(lpObj,n) )

  00068	53		 push	 ebx
  00069	57		 push	 edi
  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  0006f	e8 00 00 00 00	 call	 ?CheckUsableWeaponSkill@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMasterLevelSkillTreeSystem::CheckUsableWeaponSkill
  00074	85 c0		 test	 eax, eax
  00076	0f 84 a4 00 00
	00		 je	 $LN19@GCMagicLis

; 3051 : 				continue;
; 3052 : 
; 3053 : 			if( g_MasterSkillSystem.CheckMasterLevelSkill(lpObj->Magic[n].m_Skill) &&

  0007c	8b 87 a8 06 00
	00		 mov	 eax, DWORD PTR [edi+1704]
  00082	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  00087	ff 74 06 08	 push	 DWORD PTR [esi+eax+8]
  0008b	e8 00 00 00 00	 call	 ?CheckMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEHH@Z ; CMasterLevelSkillTreeSystem::CheckMasterLevelSkill
  00090	85 c0		 test	 eax, eax
  00092	74 19		 je	 SHORT $LN7@GCMagicLis
  00094	8b 87 a8 06 00
	00		 mov	 eax, DWORD PTR [edi+1704]
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0009f	ff 74 06 08	 push	 DWORD PTR [esi+eax+8]
  000a3	e8 00 00 00 00	 call	 ?GetSkillUseType@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetSkillUseType
  000a8	83 f8 03	 cmp	 eax, 3
  000ab	74 73		 je	 SHORT $LN19@GCMagicLis
$LN7@GCMagicLis:

; 3054 : 				MagicDamageC.GetSkillUseType(lpObj->Magic[n].m_Skill) == 3 )
; 3055 : 				continue;
; 3056 : 
; 3057 : 			if( g_MasterSkillSystem.IsExistMLSBasedSkill(lpObj,lpObj->Magic[n].m_Skill) )

  000ad	8b 87 a8 06 00
	00		 mov	 eax, DWORD PTR [edi+1704]
  000b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  000b8	ff 74 06 08	 push	 DWORD PTR [esi+eax+8]
  000bc	57		 push	 edi
  000bd	e8 00 00 00 00	 call	 ?IsExistMLSBasedSkill@CMasterLevelSkillTreeSystem@@QAEHPAUOBJECTSTRUCT@@H@Z ; CMasterLevelSkillTreeSystem::IsExistMLSBasedSkill
  000c2	85 c0		 test	 eax, eax
  000c4	75 5a		 jne	 SHORT $LN19@GCMagicLis

; 3058 : 				continue;
; 3059 : 
; 3060 : 			if( lpObj->Magic[n].m_bBrand )

  000c6	8b 97 a8 06 00
	00		 mov	 edx, DWORD PTR [edi+1704]
  000cc	38 44 32 14	 cmp	 BYTE PTR [edx+esi+20], al
  000d0	75 4e		 jne	 SHORT $LN19@GCMagicLis

; 3061 : 				continue;
; 3062 : 
; 3063 : 			pList.Pos = n;
; 3064 : 			pList.m_Skill = lpObj->Magic[n].m_Skill;

  000d2	66 8b 44 32 08	 mov	 ax, WORD PTR [edx+esi+8]

; 3065 : 			pList.m_Level = lpObj->Magic[n].m_Level << 3;

  000d7	8a 4c 32 04	 mov	 cl, BYTE PTR [edx+esi+4]
  000db	66 89 85 09 fc
	ff ff		 mov	 WORD PTR _pList$[ebp+1], ax

; 3066 : 			pList.m_Level |= lpObj->Magic[n].m_Skill & 7;

  000e2	24 07		 and	 al, 7
  000e4	c0 e1 03	 shl	 cl, 3
  000e7	0a c8		 or	 cl, al
  000e9	88 9d 08 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp], bl
  000ef	88 8d 0b fc ff
	ff		 mov	 BYTE PTR _pList$[ebp+3], cl

; 3067 : 			memcpy(&sendbuf[lOfs], &pList, sizeof(pList));

  000f5	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
  000fb	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp]
  00101	89 84 0d 14 fc
	ff ff		 mov	 DWORD PTR _sendbuf$[ebp+ecx], eax

; 3068 : 			lOfs+= sizeof(pList);

  00108	83 c1 04	 add	 ecx, 4

; 3069 : 			Count++;

  0010b	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _Count$1$[ebp]
  00111	40		 inc	 eax
  00112	89 8d 10 fc ff
	ff		 mov	 DWORD PTR _lOfs$1$[ebp], ecx
  00118	89 85 0c fc ff
	ff		 mov	 DWORD PTR _Count$1$[ebp], eax
  0011e	eb 0c		 jmp	 SHORT $LN2@GCMagicLis
$LN19@GCMagicLis:
  00120	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _lOfs$1$[ebp]
  00126	8b 85 0c fc ff
	ff		 mov	 eax, DWORD PTR _Count$1$[ebp]
$LN2@GCMagicLis:

; 3045 : 
; 3046 : 	for ( int n=0;n<MAX_MAGIC;n++)

  0012c	83 c6 18	 add	 esi, 24			; 00000018H
  0012f	43		 inc	 ebx
  00130	81 fe 10 0e 00
	00		 cmp	 esi, 3600		; 00000e10H
  00136	0f 8c 16 ff ff
	ff		 jl	 $LL4@GCMagicLis

; 3070 : 		}
; 3071 : 	}
; 3072 : 
; 3073 : 	pCount.Count = Count;

  0013c	88 85 04 fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], al

; 3074 : 	pCount.h.size = lOfs;

  00142	88 8d 01 fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], cl

; 3075 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  00148	8b 85 00 fc ff
	ff		 mov	 eax, DWORD PTR _pCount$[ebp]
  0014e	89 85 14 fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], eax
  00154	66 8b 85 04 fc
	ff ff		 mov	 ax, WORD PTR _pCount$[ebp+4]
  0015b	66 89 85 18 fc
	ff ff		 mov	 WORD PTR _sendbuf$[ebp+4], ax

; 3076 : 
; 3077 : 	DataSend(lpObj->m_Index, sendbuf, lOfs);

  00162	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  00168	51		 push	 ecx
  00169	50		 push	 eax
  0016a	ff 37		 push	 DWORD PTR [edi]
  0016c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3078 : }

  00171	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH
  00177	33 cd		 xor	 ecx, ebp
  00179	5f		 pop	 edi
  0017a	5e		 pop	 esi
  0017b	5b		 pop	 ebx
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c3		 ret	 0
?GCMagicListMultiSend@@YAXPAUOBJECTSTRUCT@@E@Z ENDP	; GCMagicListMultiSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCMagicListOneDelSend@@YAXHDGEEE@Z
_TEXT	SEGMENT
_pCount$ = -1016					; size = 6
_pList$ = -1008						; size = 4
_sendbuf$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Pos$ = 12						; size = 1
_type$ = 16						; size = 2
_level$ = 20						; size = 1
_skill$ = 24						; size = 1
_btListType$ = 28					; size = 1
?GCMagicListOneDelSend@@YAXHDGEEE@Z PROC		; GCMagicListOneDelSend, COMDAT

; 3007 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 03 00
	00		 sub	 esp, 1016		; 000003f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3008 : 	PMSG_MAGICLISTCOUNT pCount;
; 3009 : 	PMSG_MAGICLIST pList;
; 3010 : 
; 3011 : 	BYTE sendbuf[1000];
; 3012 : 	int lOfs = sizeof(pCount);
; 3013 : 
; 3014 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  00013	6a 00		 push	 0
  00015	6a 11		 push	 17			; 00000011H
  00017	8d 85 08 fc ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0001d	68 f3 00 00 00	 push	 243			; 000000f3H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 3015 : 	pCount.h.size = 0;
; 3016 : 	pCount.Count = 0xFF;
; 3017 : 	pCount.btListType = btListType;

  00028	8a 45 1c	 mov	 al, BYTE PTR _btListType$[ebp]

; 3018 : 	pList.Pos = Pos;
; 3019 : 
; 3020 : 	pList.m_Skill = type;
; 3021 : 
; 3022 : 	pList.m_Level = level<<3;

  0002b	8a 4d 14	 mov	 cl, BYTE PTR _level$[ebp]
  0002e	88 85 0d fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], al
  00034	8a 45 0c	 mov	 al, BYTE PTR _Pos$[ebp]
  00037	88 85 10 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp], al
  0003d	66 8b 45 10	 mov	 ax, WORD PTR _type$[ebp]
  00041	66 89 85 11 fc
	ff ff		 mov	 WORD PTR _pList$[ebp+1], ax

; 3023 : 	pList.m_Level |= skill & 0x07;

  00048	8a 45 18	 mov	 al, BYTE PTR _skill$[ebp]
  0004b	24 07		 and	 al, 7
  0004d	c0 e1 03	 shl	 cl, 3
  00050	0a c8		 or	 cl, al

; 3024 : 
; 3025 : 	memcpy(&sendbuf[lOfs], &pList, sizeof(pList));
; 3026 : 	lOfs+= sizeof(pList);
; 3027 : 	pCount.h.size = lOfs;

  00052	c6 85 09 fc ff
	ff 0a		 mov	 BYTE PTR _pCount$[ebp+1], 10 ; 0000000aH
  00059	88 8d 13 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp+3], cl
  0005f	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp]
  00065	89 85 1a fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+6], eax

; 3028 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  0006b	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _pCount$[ebp]
  00071	89 85 14 fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], eax
  00077	c6 85 0c fc ff
	ff ff		 mov	 BYTE PTR _pCount$[ebp+4], 255 ; 000000ffH
  0007e	0f b7 85 0c fc
	ff ff		 movzx	 eax, WORD PTR _pCount$[ebp+4]
  00085	66 89 85 18 fc
	ff ff		 mov	 WORD PTR _sendbuf$[ebp+4], ax

; 3029 : 
; 3030 : 	DataSend(aIndex, sendbuf, lOfs);

  0008c	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  00092	6a 0a		 push	 10			; 0000000aH
  00094	50		 push	 eax
  00095	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00098	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3031 : }

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	83 c4 1c	 add	 esp, 28			; 0000001cH
  000a3	33 cd		 xor	 ecx, ebp
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?GCMagicListOneDelSend@@YAXHDGEEE@Z ENDP		; GCMagicListOneDelSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCMagicListOneSend@@YAXHDGEEE@Z
_TEXT	SEGMENT
_pCount$ = -1016					; size = 6
_pList$ = -1008						; size = 4
_sendbuf$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_Pos$ = 12						; size = 1
_type$ = 16						; size = 2
_level$ = 20						; size = 1
_skill$ = 24						; size = 1
_btListType$ = 28					; size = 1
?GCMagicListOneSend@@YAXHDGEEE@Z PROC			; GCMagicListOneSend, COMDAT

; 2981 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 03 00
	00		 sub	 esp, 1016		; 000003f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2982 : 	PMSG_MAGICLISTCOUNT pCount;
; 2983 : 	PMSG_MAGICLIST pList;
; 2984 : 	BYTE sendbuf[1000];
; 2985 : 	int lOfs = sizeof(pCount);
; 2986 : 
; 2987 : 	PHeadSubSetB((LPBYTE)&pCount, 0xF3, 0x11, 0);

  00013	6a 00		 push	 0
  00015	6a 11		 push	 17			; 00000011H
  00017	8d 85 08 fc ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  0001d	68 f3 00 00 00	 push	 243			; 000000f3H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2988 : 	pCount.Count = 0xFE;
; 2989 : 	pCount.btListType = btListType;

  00028	8a 45 1c	 mov	 al, BYTE PTR _btListType$[ebp]

; 2990 : 	pList.Pos = Pos;
; 2991 : 	pList.m_Skill = type;
; 2992 : 
; 2993 : 	pList.m_Level = level<<3;

  0002b	8a 4d 14	 mov	 cl, BYTE PTR _level$[ebp]
  0002e	88 85 0d fc ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], al
  00034	8a 45 0c	 mov	 al, BYTE PTR _Pos$[ebp]
  00037	88 85 10 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp], al
  0003d	66 8b 45 10	 mov	 ax, WORD PTR _type$[ebp]
  00041	66 89 85 11 fc
	ff ff		 mov	 WORD PTR _pList$[ebp+1], ax

; 2994 : 	pList.m_Level |= skill & 0x07;

  00048	8a 45 18	 mov	 al, BYTE PTR _skill$[ebp]
  0004b	24 07		 and	 al, 7
  0004d	c0 e1 03	 shl	 cl, 3
  00050	0a c8		 or	 cl, al

; 2995 : 
; 2996 : 	memcpy(&sendbuf[lOfs], &pList, sizeof(pList));
; 2997 : 	lOfs+= sizeof(pList);
; 2998 : 	pCount.h.size = lOfs;

  00052	c6 85 09 fc ff
	ff 0a		 mov	 BYTE PTR _pCount$[ebp+1], 10 ; 0000000aH
  00059	88 8d 13 fc ff
	ff		 mov	 BYTE PTR _pList$[ebp+3], cl
  0005f	8b 85 10 fc ff
	ff		 mov	 eax, DWORD PTR _pList$[ebp]
  00065	89 85 1a fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp+6], eax

; 2999 : 	memcpy(sendbuf, &pCount, sizeof(pCount));

  0006b	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _pCount$[ebp]
  00071	89 85 14 fc ff
	ff		 mov	 DWORD PTR _sendbuf$[ebp], eax
  00077	c6 85 0c fc ff
	ff fe		 mov	 BYTE PTR _pCount$[ebp+4], 254 ; 000000feH
  0007e	0f b7 85 0c fc
	ff ff		 movzx	 eax, WORD PTR _pCount$[ebp+4]
  00085	66 89 85 18 fc
	ff ff		 mov	 WORD PTR _sendbuf$[ebp+4], ax

; 3000 : 
; 3001 : 	DataSend(aIndex, sendbuf, lOfs);

  0008c	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _sendbuf$[ebp]
  00092	6a 0a		 push	 10			; 0000000aH
  00094	50		 push	 eax
  00095	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00098	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 3002 : }

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	83 c4 1c	 add	 esp, 28			; 0000001cH
  000a3	33 cd		 xor	 ecx, ebp
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?GCMagicListOneSend@@YAXHDGEEE@Z ENDP			; GCMagicListOneSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCPkLevelSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 7
_aIndex$ = 8						; size = 4
_pklevel$ = 12						; size = 1
?GCPkLevelSend@@YAXHE@Z PROC				; GCPkLevelSend, COMDAT

; 2947 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 2948 : 	PMSG_PKLEVEL pMsg;
; 2949 : 
; 2950 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x08, sizeof(pMsg));

  00007	6a 07		 push	 7
  00009	6a 08		 push	 8
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	68 f3 00 00 00	 push	 243			; 000000f3H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2951 : 	pMsg.NumberH = SET_NUMBERH(aIndex);

  00019	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001c	8b c3		 mov	 eax, ebx
  0001e	c1 e8 08	 shr	 eax, 8
  00021	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 2952 : 	pMsg.NumberL = SET_NUMBERL(aIndex);
; 2953 : 	pMsg.PkLevel = pklevel;

  00024	8a 45 0c	 mov	 al, BYTE PTR _pklevel$[ebp]
  00027	88 45 fe	 mov	 BYTE PTR _pMsg$[ebp+6], al

; 2954 : 
; 2955 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0002a	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0002e	50		 push	 eax
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00032	88 5d fd	 mov	 BYTE PTR _pMsg$[ebp+5], bl
  00035	50		 push	 eax
  00036	53		 push	 ebx
  00037	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2956 : 	MsgSendV2(&gObj[aIndex], (UCHAR*)&pMsg, pMsg.h.size);

  0003c	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00040	50		 push	 eax
  00041	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00044	50		 push	 eax
  00045	69 c3 40 27 00
	00		 imul	 eax, ebx, 10048
  0004b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00057	83 c4 28	 add	 esp, 40			; 00000028H
  0005a	5b		 pop	 ebx

; 2957 : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?GCPkLevelSend@@YAXHE@Z ENDP				; GCPkLevelSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCInventoryItemOneSend@@YAXHH@Z
_TEXT	SEGMENT
_pos$GSCopy$1$ = -28					; size = 4
_pMsg$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?GCInventoryItemOneSend@@YAXHH@Z PROC			; GCInventoryItemOneSend, COMDAT

; 2921 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00017	56		 push	 esi

; 2922 : 	if ( !gObj[aIndex].pInventory[pos].IsItem())

  00018	69 f3 40 27 00
	00		 imul	 esi, ebx, 10048
  0001e	57		 push	 edi
  0001f	69 f8 d4 00 00
	00		 imul	 edi, eax, 212
  00025	89 45 e4	 mov	 DWORD PTR _pos$GSCopy$1$[ebp], eax
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002d	8b 8c 06 c0 11
	00 00		 mov	 ecx, DWORD PTR [esi+eax+4544]
  00034	03 cf		 add	 ecx, edi
  00036	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003b	85 c0		 test	 eax, eax
  0003d	74 53		 je	 SHORT $LN1@GCInventor

; 2923 : 		return;
; 2924 : 
; 2925 : 	PMSG_INVENTORYITEMMODIFY pMsg;
; 2926 : 
; 2927 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x14, sizeof(pMsg));

  0003f	6a 11		 push	 17			; 00000011H
  00041	6a 14		 push	 20			; 00000014H
  00043	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00046	68 f3 00 00 00	 push	 243			; 000000f3H
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2928 : 	pMsg.Pos = pos;

  00051	8b 45 e4	 mov	 eax, DWORD PTR _pos$GSCopy$1$[ebp]

; 2929 : 	ItemByteConvert(pMsg.ItemInfo, gObj[aIndex].pInventory[pos]);

  00054	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  0005a	88 45 ec	 mov	 BYTE PTR _pMsg$[ebp+4], al
  0005d	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00067	8b b4 06 c0 11
	00 00		 mov	 esi, DWORD PTR [esi+eax+4544]
  0006e	8d 45 ed	 lea	 eax, DWORD PTR _pMsg$[ebp+5]
  00071	03 f7		 add	 esi, edi
  00073	8b fc		 mov	 edi, esp
  00075	f3 a5		 rep movsd
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert

; 2930 : 
; 2931 : 	DataSend(aIndex, (UCHAR *)&pMsg, pMsg.h.size);

  0007d	0f b6 45 e9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00081	50		 push	 eax
  00082	8d 45 e8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00085	50		 push	 eax
  00086	53		 push	 ebx
  00087	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0008c	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
$LN1@GCInventor:

; 2932 : }

  00092	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	33 cd		 xor	 ecx, ebp
  00099	5b		 pop	 ebx
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
?GCInventoryItemOneSend@@YAXHH@Z ENDP			; GCInventoryItemOneSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z PROC	; CGLevelUpPointAdd, COMDAT

; 2862 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 2863 : 	if ( !gObjIsConnected(aIndex))

  00018	57		 push	 edi
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	75 19		 jne	 SHORT $LN4@CGLevelUpP

; 2864 : 	{
; 2865 : 		CloseClient(aIndex);

  00025	57		 push	 edi
  00026	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0002b	83 c4 04	 add	 esp, 4
  0002e	5f		 pop	 edi
  0002f	5b		 pop	 ebx

; 2905 : 
; 2906 : }

  00030	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00033	33 cd		 xor	 ecx, ebp
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN4@CGLevelUpP:
  0003e	56		 push	 esi

; 2866 : 		return;
; 2867 : 	}
; 2868 : 
; 2869 : 	PMSG_LVPOINTADDRESULT pMsg;
; 2870 : 
; 2871 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x06, sizeof(pMsg));

  0003f	6a 18		 push	 24			; 00000018H
  00041	6a 06		 push	 6
  00043	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00046	68 f3 00 00 00	 push	 243			; 000000f3H
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2872 : 	pMsg.ResultType = 0;
; 2873 : 	
; 2874 : 	if (::gObjLevelUpPointAdd(lpMsg->Type, &gObj[aIndex]) == TRUE )

  00051	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00056	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  0005c	c6 45 e8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  00060	03 c6		 add	 eax, esi
  00062	50		 push	 eax
  00063	0f b6 43 04	 movzx	 eax, BYTE PTR [ebx+4]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?gObjLevelUpPointAdd@@YAHEPAUOBJECTSTRUCT@@@Z ; gObjLevelUpPointAdd
  0006d	83 c4 18	 add	 esp, 24			; 00000018H
  00070	83 f8 01	 cmp	 eax, 1
  00073	0f 85 d1 00 00
	00		 jne	 $LN5@CGLevelUpP

; 2875 : 	{
; 2876 : 		pMsg.ResultType = 0x10;
; 2877 : 		pMsg.ResultType += lpMsg->Type;

  00079	8a 4b 04	 mov	 cl, BYTE PTR [ebx+4]
  0007c	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
  0007f	88 45 e8	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 2878 : 
; 2879 : 		switch ( lpMsg->Type )

  00082	0f b6 c1	 movzx	 eax, cl
  00085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0008b	83 e8 02	 sub	 eax, 2
  0008e	74 39		 je	 SHORT $LN6@CGLevelUpP
  00090	83 e8 01	 sub	 eax, 1
  00093	75 6d		 jne	 SHORT $LN2@CGLevelUpP

; 2885 : #endif
; 2886 : 				break;
; 2887 : 
; 2888 : 			case 3:	// Energy
; 2889 : 				pMsg.MaxLifeAndMana = (WORD)(gObj[aIndex].MaxMana + gObj[aIndex].AddMana);

  00095	66 0f 6e 84 0e
	28 01 00 00	 movd	 xmm0, DWORD PTR [esi+ecx+296]
  0009e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000a1	f3 0f 58 84 0e
	f0 00 00 00	 addss	 xmm0, DWORD PTR [esi+ecx+240]
  000aa	f3 0f 2c c0	 cvttss2si eax, xmm0
  000ae	66 89 45 ea	 mov	 WORD PTR _pMsg$[ebp+6], ax
  000b2	66 0f 6e 84 0e
	28 01 00 00	 movd	 xmm0, DWORD PTR [esi+ecx+296]

; 2890 : #if (FIX_HP==1)
; 2891 : 				pMsg.MAXHPANDMANA = (int)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana);

  000bb	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000be	f3 0f 58 84 0e
	f0 00 00 00	 addss	 xmm0, DWORD PTR [esi+ecx+240]
  000c7	eb 32		 jmp	 SHORT $LN9@CGLevelUpP
$LN6@CGLevelUpP:
  000c9	66 0f 6e 84 0e
	24 01 00 00	 movd	 xmm0, DWORD PTR [esi+ecx+292]

; 2880 : 		{
; 2881 : 			case 2:	// Vit
; 2882 : 				pMsg.MaxLifeAndMana = (WORD)(gObj[aIndex].MaxLife + gObj[aIndex].AddLife);

  000d2	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000d5	f3 0f 58 84 0e
	dc 00 00 00	 addss	 xmm0, DWORD PTR [esi+ecx+220]
  000de	f3 0f 2c c0	 cvttss2si eax, xmm0
  000e2	66 89 45 ea	 mov	 WORD PTR _pMsg$[ebp+6], ax
  000e6	66 0f 6e 84 0e
	24 01 00 00	 movd	 xmm0, DWORD PTR [esi+ecx+292]

; 2883 : #if (FIX_HP==1)
; 2884 : 				pMsg.MAXHPANDMANA = (int)(gObj[aIndex].MaxLife+gObj[aIndex].AddLife);

  000ef	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000f2	f3 0f 58 84 0e
	dc 00 00 00	 addss	 xmm0, DWORD PTR [esi+ecx+220]
$LN9@CGLevelUpP:
  000fb	f3 0f 2c c0	 cvttss2si eax, xmm0
  000ff	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+16], eax
$LN2@CGLevelUpP:

; 2892 : #endif
; 2893 : 				break;
; 2894 : 		}
; 2895 : 		pMsg.wMaxShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  00102	0f b7 84 0e 34
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+308]
  0010a	66 03 84 0e 30
	01 00 00	 add	 ax, WORD PTR [esi+ecx+304]

; 2896 : 		gObjSetBP(aIndex);

  00112	57		 push	 edi
  00113	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+8], ax
  00117	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP

; 2897 : 		pMsg.MaxBP = gObj[aIndex].MaxBP + gObj[aIndex].AddBP;

  0011c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00122	83 c4 04	 add	 esp, 4
  00125	0f b7 84 0e 0c
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+268]
  0012d	66 03 84 0e 08
	01 00 00	 add	 ax, WORD PTR [esi+ecx+264]
  00135	66 89 45 ee	 mov	 WORD PTR _pMsg$[ebp+10], ax

; 2898 : 
; 2899 : #if (FIX_HP==1)
; 2900 : 		pMsg.MAXSD = gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield;

  00139	8b 84 0e 34 01
	00 00		 mov	 eax, DWORD PTR [esi+ecx+308]
  00140	03 84 0e 30 01
	00 00		 add	 eax, DWORD PTR [esi+ecx+304]
  00147	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+20], eax
$LN5@CGLevelUpP:

; 2901 : #endif
; 2902 : 	}
; 2903 : 
; 2904 : 	DataSend(aIndex, (UCHAR *)&pMsg, pMsg.h.size);

  0014a	0f b6 45 e5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0014e	50		 push	 eax
  0014f	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00152	50		 push	 eax
  00153	57		 push	 edi
  00154	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2905 : 
; 2906 : }

  00159	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015f	33 cd		 xor	 ecx, ebp
  00161	5e		 pop	 esi
  00162	5f		 pop	 edi
  00163	5b		 pop	 ebx
  00164	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z ENDP	; CGLevelUpPointAdd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCLevelUpMsgSend@@YAXHH@Z
_TEXT	SEGMENT
_MaxMinusPoint$ = -56					; size = 2
_MinusPoint$ = -52					; size = 2
_MaxAddPoint$ = -48					; size = 2
_AddPoint$ = -44					; size = 2
_pMsg$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_iSendEffect$ = 12					; size = 4
?GCLevelUpMsgSend@@YAXHH@Z PROC				; GCLevelUpMsgSend, COMDAT

; 2823 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]

; 2824 : 	if ( !OBJMAX_RANGE(aIndex))

  00014	85 ff		 test	 edi, edi
  00016	0f 88 72 01 00
	00		 js	 $LN3@GCLevelUpM
  0001c	33 c0		 xor	 eax, eax
  0001e	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00024	0f 9e c0	 setle	 al
  00027	85 c0		 test	 eax, eax
  00029	0f 84 5f 01 00
	00		 je	 $LN3@GCLevelUpM

; 2825 : 		return;
; 2826 : 
; 2827 : 	short AddPoint=0;
; 2828 : 	short MaxAddPoint=0;
; 2829 : 	short MinusPoint=0;
; 2830 : 	short MaxMinusPoint=0;
; 2831 : 
; 2832 : 	gObjGetStatPointState(gObj[aIndex].m_Index, AddPoint, MaxAddPoint, MinusPoint, MaxMinusPoint);

  0002f	56		 push	 esi
  00030	8d 45 c8	 lea	 eax, DWORD PTR _MaxMinusPoint$[ebp]
  00033	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00039	50		 push	 eax
  0003a	8d 45 cc	 lea	 eax, DWORD PTR _MinusPoint$[ebp]
  0003d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _AddPoint$[ebp], 0
  00044	50		 push	 eax
  00045	8d 45 d0	 lea	 eax, DWORD PTR _MaxAddPoint$[ebp]
  00048	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _MaxAddPoint$[ebp], 0
  0004f	50		 push	 eax
  00050	8d 45 d4	 lea	 eax, DWORD PTR _AddPoint$[ebp]
  00053	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _MinusPoint$[ebp], 0
  0005a	50		 push	 eax
  0005b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _MaxMinusPoint$[ebp], 0
  00067	ff 34 06	 push	 DWORD PTR [esi+eax]
  0006a	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF000@Z ; gObjGetStatPointState

; 2833 : 	
; 2834 : 	PMSG_LEVELUP pMsg;
; 2835 : 
; 2836 : 	PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x05, sizeof(pMsg));

  0006f	6a 24		 push	 36			; 00000024H
  00071	6a 05		 push	 5
  00073	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00076	68 f3 00 00 00	 push	 243			; 000000f3H
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2837 : 	pMsg.Level = gObj[aIndex].Level;

  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00087	0f b7 84 0e 96
	00 00 00	 movzx	 eax, WORD PTR [esi+ecx+150]
  0008f	66 89 45 dc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 2838 : 	pMsg.LevelUpPoint = gObj[aIndex].LevelUpPoint;

  00093	0f b7 84 0e 98
	00 00 00	 movzx	 eax, WORD PTR [esi+ecx+152]
  0009b	66 89 45 de	 mov	 WORD PTR _pMsg$[ebp+6], ax
  0009f	66 0f 6e 84 0e
	24 01 00 00	 movd	 xmm0, DWORD PTR [esi+ecx+292]

; 2839 : 	pMsg.MaxLife = (WORD)(gObj[aIndex].MaxLife+gObj[aIndex].AddLife);

  000a8	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000ab	f3 0f 58 84 0e
	dc 00 00 00	 addss	 xmm0, DWORD PTR [esi+ecx+220]
  000b4	f3 0f 2c c0	 cvttss2si eax, xmm0
  000b8	66 89 45 e0	 mov	 WORD PTR _pMsg$[ebp+8], ax
  000bc	66 0f 6e 84 0e
	28 01 00 00	 movd	 xmm0, DWORD PTR [esi+ecx+296]

; 2840 : 	pMsg.MaxMana = (WORD)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana);

  000c5	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000c8	f3 0f 58 84 0e
	f0 00 00 00	 addss	 xmm0, DWORD PTR [esi+ecx+240]
  000d1	f3 0f 2c c0	 cvttss2si eax, xmm0
  000d5	66 89 45 e2	 mov	 WORD PTR _pMsg$[ebp+10], ax

; 2841 : 	pMsg.MaxBP = gObj[aIndex].MaxBP + gObj[aIndex].AddBP;

  000d9	0f b7 84 0e 0c
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+268]
  000e1	66 03 84 0e 08
	01 00 00	 add	 ax, WORD PTR [esi+ecx+264]
  000e9	66 89 45 e6	 mov	 WORD PTR _pMsg$[ebp+14], ax

; 2842 : 	pMsg.wMaxShield = gObj[aIndex].iMaxShield + gObj[aIndex].iAddShield;

  000ed	0f b7 84 0e 30
	01 00 00	 movzx	 eax, WORD PTR [esi+ecx+304]
  000f5	66 03 84 0e 34
	01 00 00	 add	 ax, WORD PTR [esi+ecx+308]
  000fd	66 89 45 e4	 mov	 WORD PTR _pMsg$[ebp+12], ax

; 2843 : 	pMsg.AddPoint = AddPoint;

  00101	0f b7 45 d4	 movzx	 eax, WORD PTR _AddPoint$[ebp]
  00105	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+16], ax

; 2844 : 	pMsg.MaxAddPoint = MaxAddPoint;

  00109	0f b7 45 d0	 movzx	 eax, WORD PTR _MaxAddPoint$[ebp]
  0010d	66 89 45 ea	 mov	 WORD PTR _pMsg$[ebp+18], ax

; 2845 : 	pMsg.MinusPoint = MinusPoint;

  00111	0f b7 45 cc	 movzx	 eax, WORD PTR _MinusPoint$[ebp]
  00115	66 89 45 ec	 mov	 WORD PTR _pMsg$[ebp+20], ax

; 2846 : 	pMsg.MaxMinusPoint = MaxMinusPoint;

  00119	0f b7 45 c8	 movzx	 eax, WORD PTR _MaxMinusPoint$[ebp]
  0011d	66 89 45 ee	 mov	 WORD PTR _pMsg$[ebp+22], ax
  00121	66 0f 6e 84 0e
	24 01 00 00	 movd	 xmm0, DWORD PTR [esi+ecx+292]

; 2847 : 
; 2848 : #if (FIX_HP==1)
; 2849 : 	pMsg.MAXHP = (int)(gObj[aIndex].AddLife + gObj[aIndex].MaxLife);

  0012a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0012d	f3 0f 58 84 0e
	dc 00 00 00	 addss	 xmm0, DWORD PTR [esi+ecx+220]
  00136	f3 0f 2c c0	 cvttss2si eax, xmm0
  0013a	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  0013d	66 0f 6e 84 0e
	28 01 00 00	 movd	 xmm0, DWORD PTR [esi+ecx+296]

; 2850 : 	pMsg.MAXMP = (int)(gObj[aIndex].AddMana + gObj[aIndex].MaxMana);

  00146	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00149	f3 0f 58 84 0e
	f0 00 00 00	 addss	 xmm0, DWORD PTR [esi+ecx+240]
  00152	f3 0f 2c c0	 cvttss2si eax, xmm0
  00156	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+28], eax

; 2851 : 	pMsg.MAXSD = gObj[aIndex].iAddShield+gObj[aIndex].iMaxShield;

  00159	8b 84 0e 30 01
	00 00		 mov	 eax, DWORD PTR [esi+ecx+304]
  00160	03 84 0e 34 01
	00 00		 add	 eax, DWORD PTR [esi+ecx+308]
  00167	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+32], eax

; 2852 : #endif
; 2853 : 
; 2854 : 	DataSend(aIndex, (LPBYTE)&pMsg, pMsg.h.size);

  0016a	0f b6 45 d9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0016e	50		 push	 eax
  0016f	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00172	50		 push	 eax
  00173	57		 push	 edi
  00174	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00179	83 c4 30	 add	 esp, 48			; 00000030H

; 2855 : 
; 2856 : 	if ( iSendEffect == 1 )

  0017c	83 7d 0c 01	 cmp	 DWORD PTR _iSendEffect$[ebp], 1
  00180	5e		 pop	 esi
  00181	75 0b		 jne	 SHORT $LN3@GCLevelUpM

; 2857 : 		GCSendEffectInfo(aIndex, 0x10);

  00183	6a 10		 push	 16			; 00000010H
  00185	57		 push	 edi
  00186	e8 00 00 00 00	 call	 ?GCSendEffectInfo@@YAXHE@Z ; GCSendEffectInfo
  0018b	83 c4 08	 add	 esp, 8
$LN3@GCLevelUpM:

; 2858 : }

  0018e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00191	33 cd		 xor	 ecx, ebp
  00193	5f		 pop	 edi
  00194	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
?GCLevelUpMsgSend@@YAXHH@Z ENDP				; GCLevelUpMsgSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z
_TEXT	SEGMENT
_lpInfo$ = -72						; size = 26
_pCRequest$ = -44					; size = 28
__name$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z PROC ; CGPCharacterMapJoinRequest, COMDAT

; 2755 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2756 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00019	56		 push	 esi
  0001a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001d	57		 push	 edi
  0001e	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00024	03 c7		 add	 eax, edi
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 07 01 00
	00		 je	 $LN1@CGPCharact

; 2757 : 	{
; 2758 : 		//JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2759 : 		return;
; 2760 : 	}
; 2761 : 
; 2762 : 	if ( !gObjIsAccontConnect(aIndex, gObj[aIndex].AccountID))

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003c	83 c0 52	 add	 eax, 82			; 00000052H
  0003f	03 c7		 add	 eax, edi
  00041	50		 push	 eax
  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00048	83 c4 08	 add	 esp, 8
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 eb 00 00
	00		 je	 $LN1@CGPCharact

; 2763 : 		return;
; 2764 : 
; 2765 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00058	83 7c 07 04 03	 cmp	 DWORD PTR [edi+eax+4], 3
  0005d	0f 84 db 00 00
	00		 je	 $LN1@CGPCharact

; 2766 : 		return;
; 2767 : 
; 2768 : 	gObj[aIndex].bEnableDelCharacter = FALSE;
; 2769 : 
; 2770 : 	char _name[MAX_ACCOUNT_LEN+1];
; 2771 : 	SDHP_DBCHARINFOREQUEST pCRequest;
; 2772 : 
; 2773 : 	PHeadSetB((LPBYTE)&pCRequest, 0x06, sizeof(pCRequest));

  00063	6a 1c		 push	 28			; 0000001cH
  00065	c7 44 07 10 00
	00 00 00	 mov	 DWORD PTR [edi+eax+16], 0
  0006d	8d 45 d4	 lea	 eax, DWORD PTR _pCRequest$[ebp]
  00070	6a 06		 push	 6
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2774 : 	memset(_name, 0, MAX_ACCOUNT_LEN);
; 2775 : 	memcpy(_name, lpMsg->Name, MAX_ACCOUNT_LEN);

  00078	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  0007c	0f 57 c0	 xorps	 xmm0, xmm0
  0007f	66 c7 45 f8 00
	00		 mov	 WORD PTR __name$[ebp+8], 0
  00085	66 0f d6 45 f0	 movq	 QWORD PTR __name$[ebp], xmm0
  0008a	f3 0f 7e 43 04	 movq	 xmm0, QWORD PTR [ebx+4]
  0008f	66 89 45 f8	 mov	 WORD PTR __name$[ebp+8], ax

; 2776 : #if( ENABLE_ZMULTISERVER_UPDATE_3 == 0 )
; 2777 : 	BuxConvert(_name, MAX_ACCOUNT_LEN);

  00093	8d 45 f0	 lea	 eax, DWORD PTR __name$[ebp]
  00096	6a 0a		 push	 10			; 0000000aH
  00098	50		 push	 eax
  00099	66 0f d6 45 f0	 movq	 QWORD PTR __name$[ebp], xmm0
  0009e	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 2778 : #endif
; 2779 : 	memcpy(pCRequest.Name, _name, MAX_ACCOUNT_LEN);
; 2780 : 	strcpy(pCRequest.AccountID, gObj[aIndex].AccountID);

  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a9	8d 55 d7	 lea	 edx, DWORD PTR _pCRequest$[ebp+3]
  000ac	f3 0f 7e 45 f0	 movq	 xmm0, QWORD PTR __name$[ebp]
  000b1	83 c1 52	 add	 ecx, 82			; 00000052H
  000b4	0f b7 45 f8	 movzx	 eax, WORD PTR __name$[ebp+8]
  000b8	03 cf		 add	 ecx, edi
  000ba	83 c4 14	 add	 esp, 20			; 00000014H
  000bd	66 0f d6 45 e2	 movq	 QWORD PTR _pCRequest$[ebp+14], xmm0
  000c2	66 89 45 ea	 mov	 WORD PTR _pCRequest$[ebp+22], ax
  000c6	2b d1		 sub	 edx, ecx
  000c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL9@CGPCharact:
  000d0	8a 01		 mov	 al, BYTE PTR [ecx]
  000d2	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000d5	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  000d9	84 c0		 test	 al, al
  000db	75 f3		 jne	 SHORT $LL9@CGPCharact

; 2781 : 	pCRequest.Number = aIndex;
; 2782 : 	cDBSMng.Send((char*)&pCRequest, pCRequest.h.size);

  000dd	0f b6 45 d5	 movzx	 eax, BYTE PTR _pCRequest$[ebp+1]
  000e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000e6	50		 push	 eax
  000e7	8d 45 d4	 lea	 eax, DWORD PTR _pCRequest$[ebp]
  000ea	66 89 75 ee	 mov	 WORD PTR _pCRequest$[ebp+26], si
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2783 : 	
; 2784 : 	USER_GET_BATTLEINFO lpInfo;
; 2785 : 	PHeadSubSetB((LPBYTE)&lpInfo, 0xFD, 0x01, sizeof(USER_GET_BATTLEINFO));

  000f4	6a 1a		 push	 26			; 0000001aH
  000f6	6a 01		 push	 1
  000f8	8d 45 b8	 lea	 eax, DWORD PTR _lpInfo$[ebp]
  000fb	68 fd 00 00 00	 push	 253			; 000000fdH
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00106	83 c4 10	 add	 esp, 16			; 00000010H

; 2786 : 	// ----
; 2787 : 	for(int i = 0; i < 11; i++ )

  00109	33 c0		 xor	 eax, eax
  0010b	0f 1f 44 00 00	 npad	 5
$LL4@CGPCharact:

; 2788 : 	{
; 2789 : 		lpInfo.BattleMapList[i] = gGensSystem.m_MapList[i];

  00110	0f b6 88 4b 00
	00 00		 movzx	 ecx, BYTE PTR ?gGensSystem@@3VCGensSystem@@A[eax+75]
  00117	88 4c 05 bc	 mov	 BYTE PTR _lpInfo$[ebp+eax+4], cl

; 2790 : 		lpInfo.BattleZoneList[i] = gGensSystem.m_ZoneList[i];

  0011b	0f b6 88 56 00
	00 00		 movzx	 ecx, BYTE PTR ?gGensSystem@@3VCGensSystem@@A[eax+86]
  00122	88 4c 05 c7	 mov	 BYTE PTR _lpInfo$[ebp+eax+15], cl
  00126	40		 inc	 eax
  00127	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0012a	7c e4		 jl	 SHORT $LL4@CGPCharact

; 2791 : 	}
; 2792 : 	// ----
; 2793 : 	DataSend(aIndex, (LPBYTE)&lpInfo, lpInfo.h.size);

  0012c	0f b6 45 b9	 movzx	 eax, BYTE PTR _lpInfo$[ebp+1]
  00130	50		 push	 eax
  00131	8d 45 b8	 lea	 eax, DWORD PTR _lpInfo$[ebp]
  00134	50		 push	 eax
  00135	56		 push	 esi
  00136	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CGPCharact:

; 2794 : }

  0013e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00141	5f		 pop	 edi
  00142	5e		 pop	 esi
  00143	33 cd		 xor	 ecx, ebp
  00145	5b		 pop	 ebx
  00146	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ENDP ; CGPCharacterMapJoinRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z
_TEXT	SEGMENT
_pResult$ = -112					; size = 5
_pCDel$ = -104						; size = 36
_szTemp2$ = -68						; size = 20
_szTemp$ = -48						; size = 20
_szJoomin$ = -28					; size = 21
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z PROC		; CGPCharDel, COMDAT

; 2654 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2655 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00019	56		 push	 esi
  0001a	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001d	57		 push	 edi
  0001e	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00024	03 c7		 add	 eax, edi
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0002c	83 c4 04	 add	 esp, 4
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 3d 02 00
	00		 je	 $LN1@CGPCharDel

; 2656 : 		return;
; 2657 : 
; 2658 : 	if ( gObj[aIndex].Connected < PLAYER_LOGGED )

  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003d	03 cf		 add	 ecx, edi
  0003f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00042	83 f8 02	 cmp	 eax, 2
  00045	7d 1a		 jge	 SHORT $LN3@CGPCharDel

; 2659 : 	{
; 2660 : 		CloseClient(aIndex);

  00047	56		 push	 esi
  00048	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0004d	83 c4 04	 add	 esp, 4
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx

; 2748 : }

  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	33 cd		 xor	 ecx, ebp
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN3@CGPCharDel:

; 2661 : 		return;
; 2662 : 	}
; 2663 : 
; 2664 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  00061	83 f8 03	 cmp	 eax, 3
  00064	75 2d		 jne	 SHORT $LN4@CGPCharDel

; 2665 : 	{
; 2666 : 		LogAddTD("[Anti-HACK][CGPCharDel] Attempted Character Delete during GamePlay. [%s][%s]",

  00066	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00069	50		 push	 eax
  0006a	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0006d	50		 push	 eax
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@HJCICDL@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2667 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);
; 2668 : 		CloseClient(aIndex);

  00079	56		 push	 esi
  0007a	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0007f	83 c4 10	 add	 esp, 16			; 00000010H
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx

; 2748 : }

  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN4@CGPCharDel:

; 2669 : 		return;
; 2670 : 	}
; 2671 : 
; 2672 : 	if ( gObj[aIndex].bEnableDelCharacter == FALSE )

  00093	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00097	75 2d		 jne	 SHORT $LN5@CGPCharDel

; 2673 : 	{
; 2674 : 		LogAddTD("[Anti-HACK][CGPCharDel] Attempted Character Delete during Prevented Time. [%s][%s]",

  00099	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0009c	50		 push	 eax
  0009d	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000a0	50		 push	 eax
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@NNHNDILD@?$FLAnti?9HACK?$FN?$FLCGPCharDel?$FN?5Attempte@
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2675 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);
; 2676 : 		CloseClient(aIndex);

  000ac	56		 push	 esi
  000ad	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000b2	83 c4 10	 add	 esp, 16			; 00000010H
  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx

; 2748 : }

  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bb	33 cd		 xor	 ecx, ebp
  000bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
$LN5@CGPCharDel:

; 2677 : 		return;
; 2678 : 	}
; 2679 : 
; 2680 : 	SDHP_CHARDELETE pCDel;
; 2681 : 	PMSG_RESULT pResult;
; 2682 : 
; 2683 : 	PHeadSubSetB((LPBYTE)&pResult, 0xF3, 0x02, sizeof(pResult));

  000c6	6a 05		 push	 5
  000c8	6a 02		 push	 2
  000ca	8d 45 90	 lea	 eax, DWORD PTR _pResult$[ebp]
  000cd	68 f3 00 00 00	 push	 243			; 000000f3H
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2684 : 	pResult.result = 0;
; 2685 : 
; 2686 : 	if ( gObj[aIndex].m_cAccountItemBlock )

  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000dd	83 c4 10	 add	 esp, 16			; 00000010H
  000e0	c6 45 94 00	 mov	 BYTE PTR _pResult$[ebp+4], 0
  000e4	80 bc 07 c4 01
	00 00 00	 cmp	 BYTE PTR [edi+eax+452], 0
  000ec	74 27		 je	 SHORT $LN6@CGPCharDel

; 2687 : 	{
; 2688 : 		pResult.result = 3;

  000ee	c6 45 94 03	 mov	 BYTE PTR _pResult$[ebp+4], 3
$LN21@CGPCharDel:

; 2689 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  000f2	0f b6 45 91	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000f6	50		 push	 eax
  000f7	8d 45 90	 lea	 eax, DWORD PTR _pResult$[ebp]
  000fa	50		 push	 eax
  000fb	56		 push	 esi
  000fc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00101	83 c4 0c	 add	 esp, 12			; 0000000cH
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx

; 2748 : }

  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	33 cd		 xor	 ecx, ebp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
$LN6@CGPCharDel:

; 2690 : 		return;
; 2691 : 	}
; 2692 : 
; 2693 : 	if ( !gGuildDestroy )

  00115	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gGuildDestroy@@3HA, 0 ; gGuildDestroy
  0011c	75 06		 jne	 SHORT $LN7@CGPCharDel

; 2694 : 	{
; 2695 : 		pResult.result = 0;

  0011e	c6 45 94 00	 mov	 BYTE PTR _pResult$[ebp+4], 0

; 2696 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 2697 : 		return;

  00122	eb ce		 jmp	 SHORT $LN21@CGPCharDel
$LN7@CGPCharDel:

; 2698 : 	}
; 2699 : 
; 2700 : 	char szJoomin[21];
; 2701 : 	char szTemp[20];
; 2702 : 	char szTemp2[20];
; 2703 : 
; 2704 : 	memset(szJoomin, 0, sizeof(szJoomin));
; 2705 : 	memcpy(szJoomin, lpMsg->LastJoominNumber, 20);
; 2706 : 
; 2707 : #if (__CUSTOM__ == 1)
; 2708 : 	if (gc_bPersonalID == TRUE && gObjJoominCheck(aIndex, szJoomin) == FALSE )

  00124	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gc_bPersonalID@@3HA, 1 ; gc_bPersonalID
  0012b	0f 57 c0	 xorps	 xmm0, xmm0
  0012e	8b 43 1e	 mov	 eax, DWORD PTR [ebx+30]
  00131	0f 11 45 e4	 movups	 XMMWORD PTR _szJoomin$[ebp], xmm0
  00135	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _szJoomin$[ebp+16], 0
  0013c	0f 10 43 0e	 movups	 xmm0, XMMWORD PTR [ebx+14]
  00140	c6 45 f8 00	 mov	 BYTE PTR _szJoomin$[ebp+20], 0
  00144	89 45 f4	 mov	 DWORD PTR _szJoomin$[ebp+16], eax
  00147	0f 11 45 e4	 movups	 XMMWORD PTR _szJoomin$[ebp], xmm0
  0014b	75 17		 jne	 SHORT $LN8@CGPCharDel
  0014d	8d 45 e4	 lea	 eax, DWORD PTR _szJoomin$[ebp]
  00150	50		 push	 eax
  00151	56		 push	 esi
  00152	e8 00 00 00 00	 call	 ?gObjJoominCheck@@YAHHPAD@Z ; gObjJoominCheck
  00157	83 c4 08	 add	 esp, 8
  0015a	85 c0		 test	 eax, eax
  0015c	75 06		 jne	 SHORT $LN8@CGPCharDel

; 2709 : #else
; 2710 : 	if (gObjJoominCheck(aIndex, szJoomin) == FALSE )
; 2711 : #endif
; 2712 : 	{
; 2713 : 		pResult.result = 2;

  0015e	c6 45 94 02	 mov	 BYTE PTR _pResult$[ebp+4], 2

; 2714 : 		DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);
; 2715 : 		return;

  00162	eb 8e		 jmp	 SHORT $LN21@CGPCharDel
$LN8@CGPCharDel:

; 2716 : 	}
; 2717 : 
; 2718 : 	PHeadSetB((LPBYTE)&pCDel, 0x05, sizeof(pCDel));

  00164	6a 24		 push	 36			; 00000024H
  00166	8d 45 98	 lea	 eax, DWORD PTR _pCDel$[ebp]
  00169	6a 05		 push	 5
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2719 : 	pCDel.Number = aIndex;

  00171	66 89 75 9c	 mov	 WORD PTR _pCDel$[ebp+4], si

; 2720 : 	memcpy(pCDel.AccountID, gObj[aIndex].AccountID, sizeof(pCDel.AccountID));
; 2721 : 	memcpy(pCDel.Name, lpMsg->Name, sizeof(pCDel.Name));

  00175	83 c3 04	 add	 ebx, 4
  00178	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0017e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00181	03 f7		 add	 esi, edi
  00183	f3 0f 7e 46 52	 movq	 xmm0, QWORD PTR [esi+82]
  00188	66 0f d6 45 9e	 movq	 QWORD PTR _pCDel$[ebp+6], xmm0
  0018d	0f b7 46 5a	 movzx	 eax, WORD PTR [esi+90]
  00191	f3 0f 7e 03	 movq	 xmm0, QWORD PTR [ebx]
  00195	66 89 45 a6	 mov	 WORD PTR _pCDel$[ebp+14], ax
  00199	0f b7 43 08	 movzx	 eax, WORD PTR [ebx+8]
  0019d	66 0f d6 45 a8	 movq	 QWORD PTR _pCDel$[ebp+16], xmm0
  001a2	66 89 45 b0	 mov	 WORD PTR _pCDel$[ebp+24], ax

; 2722 : 	pCDel.Guild = 0;

  001a6	c6 45 b2 00	 mov	 BYTE PTR _pCDel$[ebp+26], 0

; 2723 : 
; 2724 : 	if ( gObj[aIndex].GuildNumber > 0 && gObj[aIndex].lpGuild != NULL)

  001aa	83 be 14 06 00
	00 00		 cmp	 DWORD PTR [esi+1556], 0
  001b1	7e 51		 jle	 SHORT $LN9@CGPCharDel
  001b3	8b 8e 18 06 00
	00		 mov	 ecx, DWORD PTR [esi+1560]
  001b9	85 c9		 test	 ecx, ecx
  001bb	74 47		 je	 SHORT $LN9@CGPCharDel

; 2725 : 	{
; 2726 : 		if ( !strcmp(gObj[aIndex].Name, gObj[aIndex].lpGuild->Names[0] ))

  001bd	83 c1 2f	 add	 ecx, 47			; 0000002fH
  001c0	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
$LL17@CGPCharDel:
  001c3	8a 10		 mov	 dl, BYTE PTR [eax]
  001c5	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001c7	75 1a		 jne	 SHORT $LN18@CGPCharDel
  001c9	84 d2		 test	 dl, dl
  001cb	74 12		 je	 SHORT $LN19@CGPCharDel
  001cd	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001d0	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001d3	75 0e		 jne	 SHORT $LN18@CGPCharDel
  001d5	83 c0 02	 add	 eax, 2
  001d8	83 c1 02	 add	 ecx, 2
  001db	84 d2		 test	 dl, dl
  001dd	75 e4		 jne	 SHORT $LL17@CGPCharDel
$LN19@CGPCharDel:
  001df	33 c0		 xor	 eax, eax
  001e1	eb 05		 jmp	 SHORT $LN20@CGPCharDel
$LN18@CGPCharDel:
  001e3	1b c0		 sbb	 eax, eax
  001e5	83 c8 01	 or	 eax, 1
$LN20@CGPCharDel:
  001e8	85 c0		 test	 eax, eax
  001ea	0f 95 c0	 setne	 al
  001ed	fe c0		 inc	 al
  001ef	88 45 b2	 mov	 BYTE PTR _pCDel$[ebp+26], al

; 2727 : 		{
; 2728 : 			pCDel.Guild = 1;	// Master
; 2729 : 		}
; 2730 : 		else
; 2731 : 		{
; 2732 : 			pCDel.Guild = 2;	// Member
; 2733 : 		}
; 2734 : 
; 2735 : 		memcpy(pCDel.GuildName, gObj[aIndex].lpGuild->Name, MAX_GUILD_LEN);

  001f2	8b 8e 18 06 00
	00		 mov	 ecx, DWORD PTR [esi+1560]
  001f8	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001fb	89 45 b3	 mov	 DWORD PTR _pCDel$[ebp+27], eax
  001fe	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00201	89 45 b7	 mov	 DWORD PTR _pCDel$[ebp+31], eax
$LN9@CGPCharDel:

; 2736 : 	}
; 2737 : 
; 2738 : 	g_CashItemPeriodSystem.GDReqPeriodItemDelete(&gObj[aIndex], lpMsg->Name);

  00204	53		 push	 ebx
  00205	56		 push	 esi
  00206	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  0020b	e8 00 00 00 00	 call	 ?GDReqPeriodItemDelete@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CCashItemPeriodSystem::GDReqPeriodItemDelete

; 2739 : 	szTemp[10]=0;
; 2740 : 	szTemp2[10]=0;
; 2741 : 	memcpy(szTemp, pCDel.Name, MAX_ACCOUNT_LEN);

  00210	0f b7 45 b0	 movzx	 eax, WORD PTR _pCDel$[ebp+24]
  00214	f3 0f 7e 45 a8	 movq	 xmm0, QWORD PTR _pCDel$[ebp+16]
  00219	66 89 45 d8	 mov	 WORD PTR _szTemp$[ebp+8], ax

; 2742 : 	memcpy(szTemp2, pCDel.AccountID, MAX_ACCOUNT_LEN);

  0021d	0f b7 45 a6	 movzx	 eax, WORD PTR _pCDel$[ebp+14]
  00221	66 89 45 c4	 mov	 WORD PTR _szTemp2$[ebp+8], ax

; 2743 : 
; 2744 : 	LogAddTD("Character delete : %s,%s", szTemp2, szTemp);

  00225	8d 45 d0	 lea	 eax, DWORD PTR _szTemp$[ebp]
  00228	50		 push	 eax
  00229	8d 45 bc	 lea	 eax, DWORD PTR _szTemp2$[ebp]
  0022c	66 0f d6 45 d0	 movq	 QWORD PTR _szTemp$[ebp], xmm0
  00231	f3 0f 7e 45 9e	 movq	 xmm0, QWORD PTR _pCDel$[ebp+6]
  00236	50		 push	 eax
  00237	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HPDAEMEM@Character?5delete?5?3?5?$CFs?0?$CFs?$AA@
  0023c	c6 45 da 00	 mov	 BYTE PTR _szTemp$[ebp+10], 0
  00240	c6 45 c6 00	 mov	 BYTE PTR _szTemp2$[ebp+10], 0
  00244	66 0f d6 45 bc	 movq	 QWORD PTR _szTemp2$[ebp], xmm0
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2745 : 
; 2746 : 	cDBSMng.Send((PCHAR)&pCDel, pCDel.h.size);

  0024f	0f b6 45 99	 movzx	 eax, BYTE PTR _pCDel$[ebp+1]
  00253	83 c4 0c	 add	 esp, 12			; 0000000cH
  00256	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  0025b	50		 push	 eax
  0025c	8d 45 98	 lea	 eax, DWORD PTR _pCDel$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send

; 2747 : 	gObj[aIndex].Level = 0;

  00265	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0026a	33 c9		 xor	 ecx, ecx
  0026c	66 89 8c 07 96
	00 00 00	 mov	 WORD PTR [edi+eax+150], cx
$LN1@CGPCharDel:

; 2748 : }

  00274	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00277	5f		 pop	 edi
  00278	5e		 pop	 esi
  00279	33 cd		 xor	 ecx, ebp
  0027b	5b		 pop	 ebx
  0027c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00281	8b e5		 mov	 esp, ebp
  00283	5d		 pop	 ebp
  00284	c3		 ret	 0
?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z ENDP		; CGPCharDel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z
_TEXT	SEGMENT
tv461 = -132						; size = 4
tv451 = -128						; size = 4
tv448 = -128						; size = 4
tv297 = -128						; size = 4
_pResult$1 = -124					; size = 44
_sCreate$ = -80						; size = 36
_szTemp2$ = -44						; size = 20
_szTemp$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z PROC	; CGPCharacterCreate, COMDAT

; 2489 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2490 : 	if ( !PacketCheckTime(&gObj[aIndex]))

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	53		 push	 ebx
  00019	8b 5d 08	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  0001c	56		 push	 esi
  0001d	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00020	57		 push	 edi
  00021	69 fe 40 27 00
	00		 imul	 edi, esi, 10048
  00027	03 c7		 add	 eax, edi
  00029	89 bd 7c ff ff
	ff		 mov	 DWORD PTR tv461[ebp], edi
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00035	83 c4 04	 add	 esp, 4
  00038	85 c0		 test	 eax, eax
  0003a	75 1e		 jne	 SHORT $LN5@CGPCharact
$LN38@CGPCharact:

; 2491 : 	{
; 2492 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  0003c	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0003f	50		 push	 eax
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  00046	83 c4 08	 add	 esp, 8
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 2633 : }

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004f	33 cd		 xor	 ecx, ebp
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
$LN5@CGPCharact:

; 2493 : 		return;
; 2494 : 	}
; 2495 : 
; 2496 : 	if ( gObj[aIndex].Connected < PLAYER_LOGGED )

  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00060	03 cf		 add	 ecx, edi
  00062	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00065	83 f8 02	 cmp	 eax, 2
  00068	7d 35		 jge	 SHORT $LN6@CGPCharact

; 2497 : 	{
; 2498 : 		LogAdd(lMsg.Get(MSGGET(1, 220)), aIndex, gObj[aIndex].Ip_addr);

  0006a	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  0006d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00072	50		 push	 eax
  00073	56		 push	 esi
  00074	68 dc 01 00 00	 push	 476			; 000001dcH
  00079	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0007e	50		 push	 eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2499 : 		CloseClient(aIndex);

  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0008b	83 c4 10	 add	 esp, 16			; 00000010H
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx

; 2633 : }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
$LN6@CGPCharact:

; 2500 : 
; 2501 : 		return;
; 2502 : 	}
; 2503 : 
; 2504 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  0009f	83 f8 03	 cmp	 eax, 3
  000a2	75 2d		 jne	 SHORT $LN7@CGPCharact

; 2505 : 	{
; 2506 : 		LogAddTD("[Anti-HACK][CGPCharacterCreate] Attempted Character Create during GamePlay. [%s][%s]",

  000a4	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000a7	50		 push	 eax
  000a8	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000ab	50		 push	 eax
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@BEFIFKBL@?$FLAnti?9HACK?$FN?$FLCGPCharacterCreate?$FN?5@
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2507 : 			gObj[aIndex].AccountID, gObj[aIndex].Name);
; 2508 : 		CloseClient(aIndex);

  000b7	56		 push	 esi
  000b8	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000bd	83 c4 10	 add	 esp, 16			; 00000010H
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx

; 2633 : }

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c6	33 cd		 xor	 ecx, ebp
  000c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
$LN7@CGPCharact:

; 2509 : 
; 2510 : 		return;
; 2511 : 	}
; 2512 : 
; 2513 : 	if ( !gCreateCharacter )

  000d1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gCreateCharacter@@3HA, 0 ; gCreateCharacter
  000d8	75 2b		 jne	 SHORT $LN8@CGPCharact

; 2514 : 	{
; 2515 : 		GCServerMsgStringSend("Character creation is disabled!", aIndex, 1);

  000da	6a 01		 push	 1
  000dc	56		 push	 esi
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LCMJGFID@Character?5creation?5is?5disabled?$CB?$AA@
  000e2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 2516 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  000e7	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  000ea	50		 push	 eax
  000eb	56		 push	 esi
  000ec	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  000f1	83 c4 14	 add	 esp, 20			; 00000014H
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 2633 : }

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fa	33 cd		 xor	 ecx, ebp
  000fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
$LN8@CGPCharact:

; 2517 : 		return;
; 2518 : 	}
; 2519 : 
; 2520 : 
; 2521 : 	if ( lpMsg->ClassSkin == 0x00 ||
; 2522 : 		 lpMsg->ClassSkin == 0x10 ||
; 2523 : 		 lpMsg->ClassSkin == 0x20 ||
; 2524 : 		 lpMsg->ClassSkin == 0x30 ||
; 2525 : 		 lpMsg->ClassSkin == 0x40 ||
; 2526 : 		 lpMsg->ClassSkin == 0x50 ||

  00105	8a 43 0e	 mov	 al, BYTE PTR [ebx+14]
  00108	84 c0		 test	 al, al
  0010a	74 1c		 je	 SHORT $LN11@CGPCharact
  0010c	3c 10		 cmp	 al, 16			; 00000010H
  0010e	74 18		 je	 SHORT $LN11@CGPCharact
  00110	3c 20		 cmp	 al, 32			; 00000020H
  00112	74 14		 je	 SHORT $LN11@CGPCharact
  00114	3c 30		 cmp	 al, 48			; 00000030H
  00116	74 14		 je	 SHORT $LN37@CGPCharact
  00118	3c 40		 cmp	 al, 64			; 00000040H
  0011a	74 0c		 je	 SHORT $LN11@CGPCharact
  0011c	3c 50		 cmp	 al, 80			; 00000050H
  0011e	74 08		 je	 SHORT $LN11@CGPCharact
  00120	3c 60		 cmp	 al, 96			; 00000060H
  00122	0f 85 14 ff ff
	ff		 jne	 $LN38@CGPCharact
$LN11@CGPCharact:

; 2527 : 		 lpMsg->ClassSkin == 0x60 )
; 2528 : 	{
; 2529 : 
; 2530 : 	}
; 2531 : 	else
; 2532 : 	{
; 2533 : 		JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2534 : 		return;
; 2535 : 	}
; 2536 : 
; 2537 : 	
; 2538 : 
; 2539 : 	if( lpMsg->ClassSkin == 0x30 ) // MG

  00128	3c 30		 cmp	 al, 48			; 00000030H
  0012a	75 7c		 jne	 SHORT $LN14@CGPCharact
$LN37@CGPCharact:

; 2540 : 	{
; 2541 : 		if( gObj[aIndex].m_AccountMaxLevel < g_CreateCharLevelMG )

  0012c	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  00130	66 8b 3d 00 00
	00 00		 mov	 di, WORD PTR ?g_CreateCharLevelMG@@3FA ; g_CreateCharLevelMG
  00137	66 3b d7	 cmp	 dx, di
  0013a	7d 37		 jge	 SHORT $LN13@CGPCharact
$LN39@CGPCharact:

; 2542 : 		{
; 2543 : 			LogAddC(2, "[%s] Create character error (ReqLevel: %d, AccountLevel: %d)", 

  0013c	0f bf c2	 movsx	 eax, dx
  0013f	50		 push	 eax
  00140	0f bf c7	 movsx	 eax, di
$LN40@CGPCharact:
  00143	50		 push	 eax
  00144	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00147	50		 push	 eax
  00148	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@NJBNDAEI@?$FL?$CFs?$FN?5Create?5character?5error?5?$CIReq@
  0014d	6a 02		 push	 2
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 2544 : 				gObj[aIndex].AccountID, g_CreateCharLevelMG, gObj[aIndex].m_AccountMaxLevel);
; 2545 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  00155	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00158	50		 push	 eax
  00159	56		 push	 esi
  0015a	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  0015f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx

; 2633 : }

  00165	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00168	33 cd		 xor	 ecx, ebp
  0016a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
$LN13@CGPCharact:

; 2546 : 			return;
; 2547 : 		}
; 2548 : 
; 2549 : 		if ( gObj[aIndex].Magumsa == 0 )

  00173	80 79 34 00	 cmp	 BYTE PTR [ecx+52], 0
  00177	75 2f		 jne	 SHORT $LN14@CGPCharact

; 2550 : 		{
; 2551 : 			LogAddC(2, "error-L1: Magumsa Character create error [%s]", gObj[aIndex].AccountID);

  00179	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0017c	50		 push	 eax
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@FCKNKLJK@error?9L1?3?5Magumsa?5Character?5crea@
$LN41@CGPCharact:
  00182	6a 02		 push	 2
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 2552 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);

  0018a	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0018d	50		 push	 eax
  0018e	56		 push	 esi
  0018f	e8 00 00 00 00	 call	 ?JGCharacterCreateFailSend@@YAXHPAD@Z ; JGCharacterCreateFailSend
  00194	83 c4 14	 add	 esp, 20			; 00000014H
  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	5b		 pop	 ebx

; 2633 : }

  0019a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019d	33 cd		 xor	 ecx, ebp
  0019f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
$LN14@CGPCharact:

; 2553 : 			return;
; 2554 : 		}
; 2555 : 	}
; 2556 : 
; 2557 : 	if ( lpMsg->ClassSkin == 0x40 ) // DL

  001a8	3c 40		 cmp	 al, 64			; 00000040H
  001aa	75 21		 jne	 SHORT $LN17@CGPCharact

; 2558 : 	{
; 2559 : 		if( gObj[aIndex].m_AccountMaxLevel < g_CreateCharLevelDL )

  001ac	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  001b0	66 8b 3d 00 00
	00 00		 mov	 di, WORD PTR ?g_CreateCharLevelDL@@3FA ; g_CreateCharLevelDL
  001b7	66 3b d7	 cmp	 dx, di
  001ba	7c 80		 jl	 SHORT $LN39@CGPCharact

; 2560 : 		{
; 2561 : 			LogAddC(2, "[%s] Create character error (ReqLevel: %d, AccountLevel: %d)", 
; 2562 : 				gObj[aIndex].AccountID, g_CreateCharLevelDL, gObj[aIndex].m_AccountMaxLevel);
; 2563 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2564 : 			return;
; 2565 : 		}
; 2566 : 
; 2567 : 		if ( gObj[aIndex].Magumsa != 2 )

  001bc	80 79 34 02	 cmp	 BYTE PTR [ecx+52], 2
  001c0	74 0b		 je	 SHORT $LN17@CGPCharact

; 2568 : 		{
; 2569 : 			LogAddC(2, "error-L1: Darklord Character create error [%s]", gObj[aIndex].AccountID);

  001c2	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  001c5	50		 push	 eax
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FFBFNNND@error?9L1?3?5Darklord?5Character?5cre@

; 2570 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2571 : 			return;

  001cb	eb b5		 jmp	 SHORT $LN41@CGPCharact
$LN17@CGPCharact:

; 2572 : 		}
; 2573 : 	}
; 2574 : 	
; 2575 : 	if ( lpMsg->ClassSkin == 0x50 ) // SUM

  001cd	3c 50		 cmp	 al, 80			; 00000050H
  001cf	75 14		 jne	 SHORT $LN19@CGPCharact

; 2576 : 	{
; 2577 : 		if( gObj[aIndex].m_AccountMaxLevel < g_CreateCharLevelSUM )

  001d1	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  001d5	66 8b 3d 00 00
	00 00		 mov	 di, WORD PTR ?g_CreateCharLevelSUM@@3FA ; g_CreateCharLevelSUM
  001dc	66 3b d7	 cmp	 dx, di
  001df	0f 8c 57 ff ff
	ff		 jl	 $LN39@CGPCharact
$LN19@CGPCharact:

; 2578 : 		{
; 2579 : 			LogAddC(2, "[%s] Create character error (ReqLevel: %d, AccountLevel: %d)", 
; 2580 : 				gObj[aIndex].AccountID, g_CreateCharLevelSUM, gObj[aIndex].m_AccountMaxLevel);
; 2581 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2582 : 			return;
; 2583 : 		}
; 2584 : 	}
; 2585 : 
; 2586 : 	if ( lpMsg->ClassSkin == 0x60 ) // RF

  001e5	3c 60		 cmp	 al, 96			; 00000060H
  001e7	75 1a		 jne	 SHORT $LN21@CGPCharact

; 2587 : 	{
; 2588 : 		if( gObj[aIndex].m_AccountMaxLevel < g_CreateCharLevelRF )

  001e9	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  001ed	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?g_CreateCharLevelRF@@3FA ; g_CreateCharLevelRF
  001f4	66 3b c2	 cmp	 ax, dx
  001f7	7d 0a		 jge	 SHORT $LN21@CGPCharact

; 2589 : 		{
; 2590 : 			LogAddC(2, "[%s] Create character error (ReqLevel: %d, AccountLevel: %d)", 

  001f9	98		 cwde
  001fa	50		 push	 eax
  001fb	0f bf c2	 movsx	 eax, dx

; 2591 : 				gObj[aIndex].AccountID, g_CreateCharLevelRF, gObj[aIndex].m_AccountMaxLevel);
; 2592 : 			JGCharacterCreateFailSend(aIndex, lpMsg->Name);
; 2593 : 			return;

  001fe	e9 40 ff ff ff	 jmp	 $LN40@CGPCharact
$LN21@CGPCharact:

; 2594 : 		}
; 2595 : 	}
; 2596 : 
; 2597 : 	if( g_MultilangCharacterName == 0 )

  00203	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?g_MultilangCharacterName@@3EA, 0 ; g_MultilangCharacterName
  0020a	75 53		 jne	 SHORT $LN3@CGPCharact

; 2598 : 	{
; 2599 : 		for(int i = 0; i < strlen(lpMsg->Name); i++)

  0020c	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  0020f	33 ff		 xor	 edi, edi
  00211	8b ca		 mov	 ecx, edx
  00213	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00216	89 45 80	 mov	 DWORD PTR tv448[ebp], eax
  00219	0f 1f 80 00 00
	00 00		 npad	 7
$LL34@CGPCharact:
  00220	8a 01		 mov	 al, BYTE PTR [ecx]
  00222	41		 inc	 ecx
  00223	84 c0		 test	 al, al
  00225	75 f9		 jne	 SHORT $LL34@CGPCharact
  00227	2b 4d 80	 sub	 ecx, DWORD PTR tv448[ebp]
  0022a	74 33		 je	 SHORT $LN3@CGPCharact
  0022c	0f 1f 40 00	 npad	 4
$LL4@CGPCharact:

; 2600 : 		{
; 2601 : 			if( !isalnum(lpMsg->Name[i]) )	

  00230	0f be 04 3a	 movsx	 eax, BYTE PTR [edx+edi]
  00234	50		 push	 eax
  00235	e8 00 00 00 00	 call	 _isalnum
  0023a	83 c4 04	 add	 esp, 4
  0023d	85 c0		 test	 eax, eax
  0023f	0f 84 d0 00 00
	00		 je	 $LN30@CGPCharact

; 2598 : 	{
; 2599 : 		for(int i = 0; i < strlen(lpMsg->Name); i++)

  00245	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
  00248	47		 inc	 edi
  00249	8b c2		 mov	 eax, edx
  0024b	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0024e	89 4d 80	 mov	 DWORD PTR tv451[ebp], ecx
$LL35@CGPCharact:
  00251	8a 08		 mov	 cl, BYTE PTR [eax]
  00253	40		 inc	 eax
  00254	84 c9		 test	 cl, cl
  00256	75 f9		 jne	 SHORT $LL35@CGPCharact
  00258	2b 45 80	 sub	 eax, DWORD PTR tv451[ebp]
  0025b	3b f8		 cmp	 edi, eax
  0025d	72 d1		 jb	 SHORT $LL4@CGPCharact
$LN3@CGPCharact:

; 2610 : 				return;
; 2611 : 			}
; 2612 : 		}
; 2613 : 	}
; 2614 : 
; 2615 : 	SDHP_CREATECHAR sCreate;
; 2616 : 
; 2617 : 	memset(&sCreate, 0, sizeof(sCreate));
; 2618 : 	PHeadSetB((LPBYTE)&sCreate, 0x04, sizeof(sCreate));

  0025f	6a 24		 push	 36			; 00000024H
  00261	0f 57 c0	 xorps	 xmm0, xmm0
  00264	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _sCreate$[ebp+32], 0
  0026b	8d 45 b0	 lea	 eax, DWORD PTR _sCreate$[ebp]
  0026e	6a 04		 push	 4
  00270	50		 push	 eax
  00271	0f 11 45 b0	 movups	 XMMWORD PTR _sCreate$[ebp], xmm0
  00275	0f 11 45 c0	 movups	 XMMWORD PTR _sCreate$[ebp+16], xmm0
  00279	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2619 : 	sCreate.ClassSkin = lpMsg->ClassSkin;

  0027e	8a 43 0e	 mov	 al, BYTE PTR [ebx+14]

; 2620 : 	sCreate.Number = aIndex;
; 2621 : 	memcpy(sCreate.AccountId, gObj[aIndex].AccountID, MAX_ACCOUNT_LEN);

  00281	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv461[ebp]

; 2622 : 	memcpy(sCreate.Name, lpMsg->Name, MAX_ACCOUNT_LEN);

  00287	f3 0f 7e 43 04	 movq	 xmm0, QWORD PTR [ebx+4]
  0028c	88 45 d2	 mov	 BYTE PTR _sCreate$[ebp+34], al
  0028f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00294	66 89 75 bc	 mov	 WORD PTR _sCreate$[ebp+12], si
  00298	f3 0f 7e 4c 01
	52		 movq	 xmm1, QWORD PTR [ecx+eax+82]
  0029e	66 0f d6 4d be	 movq	 QWORD PTR _sCreate$[ebp+14], xmm1
  002a3	66 8b 4c 01 5a	 mov	 cx, WORD PTR [ecx+eax+90]
  002a8	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  002ac	66 89 45 d0	 mov	 WORD PTR _sCreate$[ebp+32], ax

; 2623 : 	char szTemp[20];
; 2624 : 	char szTemp2[20];
; 2625 : 	szTemp[10]=0;
; 2626 : 	szTemp2[10]=0;
; 2627 : 	memcpy(szTemp, sCreate.Name, MAX_ACCOUNT_LEN);

  002b0	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  002b4	66 89 45 f0	 mov	 WORD PTR _szTemp$[ebp+8], ax

; 2628 : 	memcpy(szTemp2, sCreate.AccountId, MAX_ACCOUNT_LEN);
; 2629 : 
; 2630 : 	LogAddTD("Character create : %s,%s", szTemp2, szTemp);

  002b8	8d 45 e8	 lea	 eax, DWORD PTR _szTemp$[ebp]
  002bb	50		 push	 eax
  002bc	8d 45 d4	 lea	 eax, DWORD PTR _szTemp2$[ebp]
  002bf	66 0f d6 45 c8	 movq	 QWORD PTR _sCreate$[ebp+24], xmm0
  002c4	50		 push	 eax
  002c5	66 0f 7f c0	 movq	 xmm0, xmm0
  002c9	66 89 4d c6	 mov	 WORD PTR _sCreate$[ebp+22], cx
  002cd	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GDNNOEGN@Character?5create?5?3?5?$CFs?0?$CFs?$AA@
  002d2	c6 45 f2 00	 mov	 BYTE PTR _szTemp$[ebp+10], 0
  002d6	c6 45 de 00	 mov	 BYTE PTR _szTemp2$[ebp+10], 0
  002da	66 0f d6 45 e8	 movq	 QWORD PTR _szTemp$[ebp], xmm0
  002df	66 0f d6 4d d4	 movq	 QWORD PTR _szTemp2$[ebp], xmm1
  002e4	66 89 4d dc	 mov	 WORD PTR _szTemp2$[ebp+8], cx
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2631 : 
; 2632 : 	cDBSMng.Send((char*)&sCreate, sCreate.h.size);

  002ee	0f b6 45 b1	 movzx	 eax, BYTE PTR _sCreate$[ebp+1]
  002f2	83 c4 18	 add	 esp, 24			; 00000018H
  002f5	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  002fa	50		 push	 eax
  002fb	8d 45 b0	 lea	 eax, DWORD PTR _sCreate$[ebp]
  002fe	50		 push	 eax
  002ff	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
  00304	5f		 pop	 edi
  00305	5e		 pop	 esi
  00306	5b		 pop	 ebx

; 2633 : }

  00307	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0030a	33 cd		 xor	 ecx, ebp
  0030c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00311	8b e5		 mov	 esp, ebp
  00313	5d		 pop	 ebp
  00314	c3		 ret	 0
$LN30@CGPCharact:

; 2602 : 			{
; 2603 : 				PMSG_CHARCREATERESULT pResult = { 0 };

  00315	6a 2b		 push	 43			; 0000002bH
  00317	8d 45 85	 lea	 eax, DWORD PTR _pResult$1[ebp+1]
  0031a	6a 00		 push	 0
  0031c	50		 push	 eax
  0031d	e8 00 00 00 00	 call	 _memset

; 2604 : 				pResult.h.c = 0xC1;
; 2605 : 				pResult.h.size = sizeof(PMSG_CHARCREATERESULT);
; 2606 : 				pResult.h.headcode = 0xF3;
; 2607 : 				pResult.subcode = 0x01;
; 2608 : 				pResult.Result = 2;
; 2609 : 				DataSend(aIndex, (LPBYTE)&pResult, pResult.h.size);

  00322	6a 2c		 push	 44			; 0000002cH
  00324	8d 45 84	 lea	 eax, DWORD PTR _pResult$1[ebp]
  00327	c7 45 84 c1 2c
	f3 01		 mov	 DWORD PTR _pResult$1[ebp], 32713921 ; 01f32cc1H
  0032e	50		 push	 eax
  0032f	56		 push	 esi
  00330	c6 45 88 02	 mov	 BYTE PTR _pResult$1[ebp+4], 2
  00334	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2633 : }

  00339	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033c	83 c4 18	 add	 esp, 24			; 00000018H
  0033f	33 cd		 xor	 ecx, ebp
  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00349	8b e5		 mov	 esp, ebp
  0034b	5d		 pop	 ebp
  0034c	c3		 ret	 0
?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z ENDP	; CGPCharacterCreate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z PROC		; CGClientMsg, COMDAT

; 2449 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2450 : 	if ( lpMsg->Flag )

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00006	53		 push	 ebx
  00007	8a 5a 04	 mov	 bl, BYTE PTR [edx+4]
  0000a	84 db		 test	 bl, bl
  0000c	74 31		 je	 SHORT $LN2@CGClientMs

; 2451 : 	{
; 2452 : 		LogAddC(2,"error-L1 : HackCheck [%s][%s] 0x%x 0x%x",

  0000e	69 4d 0c 40 27
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 10048
  00015	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  00019	50		 push	 eax
  0001a	0f b6 c3	 movzx	 eax, bl
  0001d	50		 push	 eax
  0001e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00024	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00027	50		 push	 eax
  00028	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@
  00031	6a 02		 push	 2
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00039	83 c4 18	 add	 esp, 24			; 00000018H
  0003c	5b		 pop	 ebx

; 2469 : 	}
; 2470 : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN2@CGClientMs:

; 2453 : 			gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2454 : 			lpMsg->Flag, lpMsg->subFlag);
; 2455 : 	}
; 2456 : 	else 
; 2457 : 	{
; 2458 : 		if ( gObj[aIndex].m_ClientHackLogCount < 100 )

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00044	56		 push	 esi
  00045	69 75 0c 40 27
	00 00		 imul	 esi, DWORD PTR _aIndex$[ebp], 10048
  0004c	80 bc 06 77 14
	00 00 64	 cmp	 BYTE PTR [esi+eax+5239], 100 ; 00000064H
  00054	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00057	73 24		 jae	 SHORT $LN4@CGClientMs

; 2459 : 		{
; 2460 : 			LogAddC(2, "error-L1 : HackCheck [%s][%s] 0x%x 0x%x",

  00059	0f b6 42 05	 movzx	 eax, BYTE PTR [edx+5]
  0005d	50		 push	 eax
  0005e	6a 00		 push	 0
  00060	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00063	50		 push	 eax
  00064	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KOHNJIIP@error?9L1?5?3?5HackCheck?5?$FL?$CFs?$FN?$FL?$CFs?$FN?50x@
  0006d	6a 02		 push	 2
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0007a	83 c4 18	 add	 esp, 24			; 00000018H
$LN4@CGClientMs:

; 2461 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2462 : 				lpMsg->Flag, lpMsg->subFlag);
; 2463 : 		}
; 2464 : 
; 2465 : 		gObj[aIndex].m_ClientHackLogCount++;

  0007d	fe 84 06 77 14
	00 00		 inc	 BYTE PTR [esi+eax+5239]

; 2466 : 
; 2467 : 		if ( gObj[aIndex].m_ClientHackLogCount >= 100 )

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00089	80 bc 06 77 14
	00 00 64	 cmp	 BYTE PTR [esi+eax+5239], 100 ; 00000064H
  00091	72 08		 jb	 SHORT $LN7@CGClientMs

; 2468 : 			gObj[aIndex].m_ClientHackLogCount = 100;

  00093	c6 84 06 77 14
	00 00 64	 mov	 BYTE PTR [esi+eax+5239], 100 ; 00000064H
$LN7@CGClientMs:
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx

; 2469 : 	}
; 2470 : }

  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z ENDP		; CGClientMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCCloseMsgSend@@YAXHE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?GCCloseMsgSend@@YAXHE@Z PROC				; GCCloseMsgSend, COMDAT

; 2435 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2436 : 	PMSG_RESULT pMsg;
; 2437 : 
; 2438 : 	PHeadSubSetBE((LPBYTE)&pMsg, 0xF1, 0x02, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 02		 push	 2
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetBE@@YAXPAEEEH@Z ; PHeadSubSetBE

; 2439 : 	pMsg.result = result;

  00018	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  0001b	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 2440 : 	
; 2441 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0001e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00022	50		 push	 eax
  00023	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00026	50		 push	 eax
  00027	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0002a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2442 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GCCloseMsgSend@@YAXHE@Z ENDP				; GCCloseMsgSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z PROC	; CGClientCloseMsg, COMDAT

; 2385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2386 : 	switch ( lpMsg->Flag )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00006	56		 push	 esi
  00007	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0000b	83 e8 00	 sub	 eax, 0
  0000e	0f 84 bc 00 00
	00		 je	 $LN4@CGClientCl
  00014	83 e8 01	 sub	 eax, 1
  00017	74 60		 je	 SHORT $LN10@CGClientCl
  00019	83 e8 01	 sub	 eax, 1
  0001c	0f 85 fe 00 00
	00		 jne	 $LN6@CGClientCl

; 2397 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2398 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 2399 : 			break;
; 2400 : 
; 2401 : 		case 2:	// ServerList
; 2402 : 			gObjCloseSet(aIndex, 2);

  00022	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00025	6a 02		 push	 2
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  0002d	83 c4 08	 add	 esp, 8

; 2403 : 
; 2404 : 			if ( aIndex < 0 || aIndex > OBJMAX-1)

  00030	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00036	0f 87 e4 00 00
	00		 ja	 $LN6@CGClientCl

; 2405 : 			{
; 2406 : 				return;
; 2407 : 			}
; 2408 : 
; 2409 : 			LogAddTD("[UserSelClose] Go ServerList [%s][%s] Map:[%d][%d/%d]",

  0003c	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00042	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00048	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  0004f	50		 push	 eax
  00050	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  00057	50		 push	 eax
  00058	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  0005f	50		 push	 eax
  00060	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00063	50		 push	 eax
  00064	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MAGKNHGP@?$FLUserSelClose?$FN?5Go?5ServerList?5?$FL?$CFs@
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00073	83 c4 18	 add	 esp, 24			; 00000018H
  00076	5e		 pop	 esi

; 2423 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2424 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 2425 : 			break;
; 2426 : 	}
; 2427 : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN10@CGClientCl:

; 2410 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2411 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 2412 : 			break;
; 2413 : 
; 2414 : 		case 1:	// Select Character
; 2415 : 			gObjCloseSet(aIndex, 1);

  00079	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0007c	6a 01		 push	 1
  0007e	56		 push	 esi
  0007f	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  00084	83 c4 08	 add	 esp, 8

; 2416 : 
; 2417 : 			if ( aIndex < 0 || aIndex > OBJMAX-1)

  00087	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  0008d	0f 87 8d 00 00
	00		 ja	 $LN6@CGClientCl

; 2418 : 			{
; 2419 : 				return;
; 2420 : 			}
; 2421 : 
; 2422 : 			LogAddTD("[UserSelClose] Go CharSelect [%s][%s] Map:[%d][%d/%d]",

  00093	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  00099	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009f	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  000a6	50		 push	 eax
  000a7	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  000ae	50		 push	 eax
  000af	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  000b6	50		 push	 eax
  000b7	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  000ba	50		 push	 eax
  000bb	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  000be	50		 push	 eax
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JEMIEEON@?$FLUserSelClose?$FN?5Go?5CharSelect?5?$FL?$CFs@
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ca	83 c4 18	 add	 esp, 24			; 00000018H
  000cd	5e		 pop	 esi

; 2423 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2424 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 2425 : 			break;
; 2426 : 	}
; 2427 : }

  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
$LN4@CGClientCl:

; 2387 : 	{
; 2388 : 		case 0:	// Close Game
; 2389 : 			gObjCloseSet(aIndex, 0);

  000d0	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  000d3	6a 00		 push	 0
  000d5	56		 push	 esi
  000d6	e8 00 00 00 00	 call	 ?gObjCloseSet@@YAXHH@Z	; gObjCloseSet
  000db	83 c4 08	 add	 esp, 8

; 2390 : 
; 2391 : 			if ( aIndex < 0 || aIndex > OBJMAX-1)

  000de	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  000e4	77 3a		 ja	 SHORT $LN6@CGClientCl

; 2392 : 			{
; 2393 : 				return;
; 2394 : 			}
; 2395 : 
; 2396 : 			LogAddTD("[UserSelClose] Go Exit [%s][%s] Map:[%d][%d/%d]",

  000e6	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  000ec	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f2	0f b6 81 21 01
	00 00		 movzx	 eax, BYTE PTR [ecx+289]
  000f9	50		 push	 eax
  000fa	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  00101	50		 push	 eax
  00102	0f b6 81 23 01
	00 00		 movzx	 eax, BYTE PTR [ecx+291]
  00109	50		 push	 eax
  0010a	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0010d	50		 push	 eax
  0010e	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  00111	50		 push	 eax
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@BEHJLACI@?$FLUserSelClose?$FN?5Go?5Exit?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5@
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0011d	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@CGClientCl:
  00120	5e		 pop	 esi

; 2423 : 				gObj[aIndex].AccountID, gObj[aIndex].Name,
; 2424 : 				gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y);
; 2425 : 			break;
; 2426 : 	}
; 2427 : }

  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z ENDP	; CGClientCloseMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCJoinSocketResult@@YAXEI@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 5
_result$ = 8						; size = 1
_Socket$ = 12						; size = 4
?GCJoinSocketResult@@YAXEI@Z PROC			; GCJoinSocketResult, COMDAT

; 2370 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2371 : 	PMSG_RESULT pResult;
; 2372 : 
; 2373 : 	PHeadSubSetB((LPBYTE)&pResult , 0xF1, 0x01, sizeof(pResult) );

  00006	6a 05		 push	 5
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2374 : 	pResult.result= result;

  00018	8a 45 08	 mov	 al, BYTE PTR _result$[ebp]
  0001b	83 c4 10	 add	 esp, 16			; 00000010H
  0001e	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al

; 2375 : 
; 2376 : 	wsGServer.DataSocketSend(Socket, (char*)&pResult, pResult.h.size);

  00021	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsGServer@@3VCwsGameServer@@A ; wsGServer
  00026	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0002a	50		 push	 eax
  0002b	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0002e	50		 push	 eax
  0002f	ff 75 0c	 push	 DWORD PTR _Socket$[ebp]
  00032	e8 00 00 00 00	 call	 ?DataSocketSend@CwsGameServer@@QAEHIPADH@Z ; CwsGameServer::DataSocketSend

; 2377 : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?GCJoinSocketResult@@YAXEI@Z ENDP			; GCJoinSocketResult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCJoinResult@@YAXEH@Z
_TEXT	SEGMENT
_pResult$ = -8						; size = 5
_result$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?GCJoinResult@@YAXEH@Z PROC				; GCJoinResult, COMDAT

; 2358 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2359 : 	PMSG_RESULT  pResult;
; 2360 : 
; 2361 : 	PHeadSubSetB((LPBYTE)&pResult, 0xF1, 0x01, sizeof(pResult));

  00006	6a 05		 push	 5
  00008	6a 01		 push	 1
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000d	68 f1 00 00 00	 push	 241			; 000000f1H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 2362 : 	pResult.result = result;

  00018	8a 45 08	 mov	 al, BYTE PTR _result$[ebp]
  0001b	88 45 fc	 mov	 BYTE PTR _pResult$[ebp+4], al

; 2363 : 	DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  0001e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00022	50		 push	 eax
  00023	8d 45 f8	 lea	 eax, DWORD PTR _pResult$[ebp]
  00026	50		 push	 eax
  00027	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  0002a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0002f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2364 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GCJoinResult@@YAXEH@Z ENDP				; GCJoinResult
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCJoinBillCheckSend@@YAXPADH@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_AccountId$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?GCJoinBillCheckSend@@YAXPADH@Z PROC			; GCJoinBillCheckSend, COMDAT

; 2342 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _AccountId$[ebp]

; 2343 : 	SDHP_BILLSEARCH pMsg;
; 2344 : 
; 2345 : 	PHeadSetB((LPBYTE)&pMsg, 0x06, sizeof(pMsg));

  00014	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	6a 10		 push	 16			; 00000010H
  00019	6a 06		 push	 6
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2346 : 	memcpy(pMsg.Id, AccountId, sizeof(pMsg.Id));

  00021	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]

; 2347 : 	pMsg.Number = aIndex;
; 2348 : 
; 2349 : 	wsJServerCli.DataSend((char*)&pMsg, pMsg.h.size);

  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00031	66 89 45 f7	 mov	 WORD PTR _pMsg$[ebp+11], ax
  00035	66 8b 45 0c	 mov	 ax, WORD PTR _aIndex$[ebp]
  00039	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+14], ax
  0003d	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00041	50		 push	 eax
  00042	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00045	66 0f d6 45 ef	 movq	 QWORD PTR _pMsg$[ebp+3], xmm0
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 2350 : }

  00050	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00053	33 cd		 xor	 ecx, ebp
  00055	5e		 pop	 esi
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?GCJoinBillCheckSend@@YAXPADH@Z ENDP			; GCJoinBillCheckSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z
_TEXT	SEGMENT
_spMsg$ = -84						; size = 54
_szPass$ = -28						; size = 11
_szId$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z PROC	; CSPJoinIdPassRequestTEST, COMDAT

; 2297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]

; 2298 : 	char szId[11];
; 2299 : 	char szPass[11];
; 2300 : 	LPOBJ lpObj = &gObj[aIndex];
; 2301 : 	SDHP_IDPASS spMsg;
; 2302 : 
; 2303 : 	PHeadSetB((LPBYTE)&spMsg, 0x11, sizeof(spMsg));

  00014	8d 45 ac	 lea	 eax, DWORD PTR _spMsg$[ebp]
  00017	6a 36		 push	 54			; 00000036H
  00019	6a 11		 push	 17			; 00000011H
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2304 : 	spMsg.Number = aIndex;
; 2305 : 	wsprintf(szId, "%d", logincounttest);

  00021	ff 35 00 00 00
	00		 push	 DWORD PTR ?logincounttest@@3HA ; logincounttest
  00027	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0002a	66 89 75 ce	 mov	 WORD PTR _spMsg$[ebp+34], si
  0002e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__wsprintfA
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_08NPLAPO@?$LN?$LI?$LF?$LJ?$MA?L?$CFd?$AA@
  00039	50		 push	 eax
  0003a	ff d6		 call	 esi

; 2306 : 	wsprintf(szPass, "m321", rand()%9);

  0003c	e8 00 00 00 00	 call	 _rand
  00041	99		 cdq
  00042	b9 09 00 00 00	 mov	 ecx, 9
  00047	f7 f9		 idiv	 ecx
  00049	8d 45 e4	 lea	 eax, DWORD PTR _szPass$[ebp]
  0004c	52		 push	 edx
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_04FLFDNKBN@m321?$AA@
  00052	50		 push	 eax
  00053	ff d6		 call	 esi

; 2307 : 	LogAdd("login send : %s %s", szId, szPass);

  00055	8d 45 e4	 lea	 eax, DWORD PTR _szPass$[ebp]
  00058	50		 push	 eax
  00059	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0005c	50		 push	 eax
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CNPHLENH@login?5send?5?3?5?$CFs?5?$CFs?$AA@
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2308 : 	
; 2309 : 	BuxConvert(szId, MAX_ACCOUNT_LEN);

  00068	8d 45 f0	 lea	 eax, DWORD PTR _szId$[ebp]
  0006b	6a 0a		 push	 10			; 0000000aH
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 2310 : 	BuxConvert(szPass, MAX_ACCOUNT_LEN);

  00073	8d 45 e4	 lea	 eax, DWORD PTR _szPass$[ebp]
  00076	6a 0a		 push	 10			; 0000000aH
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert

; 2311 : 	memcpy(spMsg.Id, szId, MAX_ACCOUNT_LEN);

  0007e	f3 0f 7e 45 f0	 movq	 xmm0, QWORD PTR _szId$[ebp]
  00083	83 c4 40	 add	 esp, 64			; 00000040H
  00086	0f b7 45 f8	 movzx	 eax, WORD PTR _szId$[ebp+8]

; 2312 : 	memcpy(spMsg.Pass, szPass, MAX_ACCOUNT_LEN);
; 2313 : 	logincounttest++;

  0008a	ff 05 00 00 00
	00		 inc	 DWORD PTR ?logincounttest@@3HA ; logincounttest

; 2314 : 	
; 2315 : 	if ( (GetTickCount()-ltesttime) > 1000 )

  00090	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount@0
  00096	66 0f d6 45 af	 movq	 QWORD PTR _spMsg$[ebp+3], xmm0
  0009b	f3 0f 7e 45 e4	 movq	 xmm0, QWORD PTR _szPass$[ebp]
  000a0	66 89 45 b7	 mov	 WORD PTR _spMsg$[ebp+11], ax
  000a4	0f b7 45 ec	 movzx	 eax, WORD PTR _szPass$[ebp+8]
  000a8	66 0f d6 45 b9	 movq	 QWORD PTR _spMsg$[ebp+13], xmm0
  000ad	66 89 45 c1	 mov	 WORD PTR _spMsg$[ebp+21], ax
  000b1	ff d6		 call	 esi
  000b3	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ltesttime@@3HA ; ltesttime
  000b9	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  000be	76 11		 jbe	 SHORT $LN2@CSPJoinIdP

; 2316 : 	{
; 2317 : 		ltesttime = GetTickCount();

  000c0	ff d6		 call	 esi
  000c2	a3 00 00 00 00	 mov	 DWORD PTR ?ltesttime@@3HA, eax ; ltesttime

; 2318 : 		logincounttest=0;

  000c7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?logincounttest@@3HA, 0 ; logincounttest
$LN2@CSPJoinIdP:

; 2319 : 	}
; 2320 : 
; 2321 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  000d1	0f b6 45 ad	 movzx	 eax, BYTE PTR _spMsg$[ebp+1]
  000d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  000da	50		 push	 eax
  000db	8d 45 ac	 lea	 eax, DWORD PTR _spMsg$[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 2322 : 	spMsg.h.headcode = 0x01;
; 2323 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  000e4	0f b6 45 ad	 movzx	 eax, BYTE PTR _spMsg$[ebp+1]
  000e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  000ed	50		 push	 eax
  000ee	8d 45 ac	 lea	 eax, DWORD PTR _spMsg$[ebp]
  000f1	c6 45 ae 01	 mov	 BYTE PTR _spMsg$[ebp+2], 1
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 2324 : }

  000fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	33 cd		 xor	 ecx, ebp
  00100	5e		 pop	 esi
  00101	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c3		 ret	 0
?CSPJoinIdPassRequestTEST@@YAXPAUPMSG_IDPASS@@H@Z ENDP	; CSPJoinIdPassRequestTEST
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z
_TEXT	SEGMENT
_lpObj$1$ = -96						; size = 4
_spMsg$ = -92						; size = 54
_serial$ = -36						; size = 17
_id$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z PROC	; CSPJoinIdPassRequest, COMDAT

; 2195 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2196 : 	char serial[17];
; 2197 : 	char id[11];
; 2198 : 
; 2199 : 	if ( lpMsg->CliVersion[0] != szClientVersion[0] ||
; 2200 : 		 lpMsg->CliVersion[1] != szClientVersion[1] ||
; 2201 : 		 lpMsg->CliVersion[2] != szClientVersion[2] ||
; 2202 : 		 lpMsg->CliVersion[3] != szClientVersion[3] ||

  00010	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001f	0f b6 4f 26	 movzx	 ecx, BYTE PTR [edi+38]
  00023	3b c8		 cmp	 ecx, eax
  00025	0f 85 e8 02 00
	00		 jne	 $LN3@CSPJoinIdP
  0002b	0f b6 4f 27	 movzx	 ecx, BYTE PTR [edi+39]
  0002f	0f be 05 01 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+1
  00036	3b c8		 cmp	 ecx, eax
  00038	0f 85 d5 02 00
	00		 jne	 $LN3@CSPJoinIdP
  0003e	0f b6 4f 28	 movzx	 ecx, BYTE PTR [edi+40]
  00042	0f be 05 02 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+2
  00049	3b c8		 cmp	 ecx, eax
  0004b	0f 85 c2 02 00
	00		 jne	 $LN3@CSPJoinIdP
  00051	0f b6 4f 29	 movzx	 ecx, BYTE PTR [edi+41]
  00055	0f be 05 03 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+3
  0005c	3b c8		 cmp	 ecx, eax
  0005e	0f 85 af 02 00
	00		 jne	 $LN3@CSPJoinIdP
  00064	0f b6 4f 2a	 movzx	 ecx, BYTE PTR [edi+42]
  00068	0f be 05 04 00
	00 00		 movsx	 eax, BYTE PTR ?szClientVersion@@3PADA+4
  0006f	3b c8		 cmp	 ecx, eax
  00071	0f 85 9c 02 00
	00		 jne	 $LN3@CSPJoinIdP

; 2207 : 		return;
; 2208 : 	}
; 2209 : 
; 2210 : 	serial[16] = 0;
; 2211 : 	memcpy(serial, lpMsg->CliSerial, sizeof(lpMsg->CliSerial));

  00077	0f 10 47 2b	 movups	 xmm0, XMMWORD PTR [edi+43]

; 2212 : 	id[10]=0;
; 2213 : 	memcpy(id, lpMsg->Id, sizeof(lpMsg->Id));

  0007b	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]
  0007f	66 89 45 f8	 mov	 WORD PTR _id$[ebp+8], ax

; 2214 : 	BuxConvert(id, MAX_ACCOUNT_LEN);

  00083	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  00086	0f 11 45 dc	 movups	 XMMWORD PTR _serial$[ebp], xmm0
  0008a	6a 0a		 push	 10			; 0000000aH
  0008c	f3 0f 7e 47 04	 movq	 xmm0, QWORD PTR [edi+4]
  00091	50		 push	 eax
  00092	c6 45 ec 00	 mov	 BYTE PTR _serial$[ebp+16], 0
  00096	c6 45 fa 00	 mov	 BYTE PTR _id$[ebp+10], 0
  0009a	66 0f d6 45 f0	 movq	 QWORD PTR _id$[ebp], xmm0
  0009f	e8 00 00 00 00	 call	 ?BuxConvert@@YAXPADH@Z	; BuxConvert
  000a4	83 c4 08	 add	 esp, 8

; 2215 : 
; 2216 : 	if ( strcmp(serial, szGameServerExeSerial) != 0 )

  000a7	8d 45 dc	 lea	 eax, DWORD PTR _serial$[ebp]
  000aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?szGameServerExeSerial@@3PADA ; szGameServerExeSerial
  000af	90		 npad	 1
$LL21@CSPJoinIdP:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN22@CSPJoinIdP
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN23@CSPJoinIdP
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN22@CSPJoinIdP
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL21@CSPJoinIdP
$LN23@CSPJoinIdP:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN24@CSPJoinIdP
$LN22@CSPJoinIdP:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 c8 01	 or	 eax, 1
$LN24@CSPJoinIdP:
  000d5	85 c0		 test	 eax, eax
  000d7	74 36		 je	 SHORT $LN4@CSPJoinIdP

; 2217 : 	{
; 2218 : 		LogAddC(2, "error-L1: Serial error [%s] [%s]", id, serial);

  000d9	8d 45 dc	 lea	 eax, DWORD PTR _serial$[ebp]
  000dc	50		 push	 eax
  000dd	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  000e0	50		 push	 eax
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@GGKFEOLP@error?9L1?3?5Serial?5error?5?$FL?$CFs?$FN?5?$FL?$CFs?$FN@
  000e6	6a 02		 push	 2
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 2219 : 		GCJoinResult(JS_BAD_CLIENT_VERSION, aIndex);

  000ee	56		 push	 esi
  000ef	6a 06		 push	 6
  000f1	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult

; 2220 : 		CloseClient(aIndex);

  000f6	56		 push	 esi
  000f7	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000fc	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi

; 2285 : 	lpObj->m_btDestY = 0;
; 2286 : }

  00101	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00104	33 cd		 xor	 ecx, ebp
  00106	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
$LN4@CSPJoinIdP:

; 2221 : 		return;
; 2222 : 	}
; 2223 : 	
; 2224 : 	if ( g_ConnectMemberLoad == TRUE )

  0010f	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?g_ConnectMemberLoad@@3_NA, 1 ; g_ConnectMemberLoad
  00116	75 2d		 jne	 SHORT $LN6@CSPJoinIdP

; 2225 : 	{
; 2226 : 		if ( ConMember.IsMember(id) == FALSE )

  00118	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  0011b	b9 00 00 00 00	 mov	 ecx, OFFSET ?ConMember@@3VCConMember@@A ; ConMember
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ?IsMember@CConMember@@QAEHPAD@Z ; CConMember::IsMember
  00126	85 c0		 test	 eax, eax
  00128	75 1b		 jne	 SHORT $LN6@CSPJoinIdP

; 2227 : 		{
; 2228 : 			GCJoinResult(JS_ONLY_VIP_MEMBERS, aIndex);

  0012a	56		 push	 esi
  0012b	6a 02		 push	 2
  0012d	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult
  00132	83 c4 08	 add	 esp, 8
  00135	5f		 pop	 edi
  00136	5e		 pop	 esi

; 2285 : 	lpObj->m_btDestY = 0;
; 2286 : }

  00137	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013a	33 cd		 xor	 ecx, ebp
  0013c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c3		 ret	 0
$LN6@CSPJoinIdP:

; 2229 : 			return;
; 2230 : 		}
; 2231 : 	}
; 2232 : 
; 2233 : 	LPOBJ lpObj = &gObj[aIndex];

  00145	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014a	53		 push	 ebx
  0014b	69 de 40 27 00
	00		 imul	 ebx, esi, 10048
  00151	03 c3		 add	 eax, ebx

; 2234 : 
; 2235 : 	if (PacketCheckTime(lpObj) == FALSE )

  00153	50		 push	 eax
  00154	89 45 a0	 mov	 DWORD PTR _lpObj$1$[ebp], eax
  00157	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0015c	83 c4 04	 add	 esp, 4
  0015f	85 c0		 test	 eax, eax
  00161	75 0c		 jne	 SHORT $LN7@CSPJoinIdP

; 2236 : 	{
; 2237 : 		LogAdd(lMsg.Get(MSGGET(1, 217)), aIndex, id);

  00163	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  00166	50		 push	 eax
  00167	56		 push	 esi
  00168	68 d9 01 00 00	 push	 473			; 000001d9H

; 2238 : 		CloseClient(aIndex);
; 2239 : 		return;

  0016d	eb 19		 jmp	 SHORT $LN26@CSPJoinIdP
$LN7@CSPJoinIdP:

; 2240 : 	}
; 2241 : 
; 2242 : 	if ( gObj[aIndex].Connected != PLAYER_CONNECTED )

  0016f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00174	83 7c 03 04 01	 cmp	 DWORD PTR [ebx+eax+4], 1
  00179	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  0017c	74 35		 je	 SHORT $LN8@CSPJoinIdP

; 2243 : 	{
; 2244 : 		LogAdd(lMsg.Get(MSGGET(1, 218)), aIndex, id);

  0017e	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  00181	50		 push	 eax
  00182	56		 push	 esi
  00183	68 da 01 00 00	 push	 474			; 000001daH
$LN26@CSPJoinIdP:
  00188	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0018d	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00192	50		 push	 eax
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 2245 : 		CloseClient(aIndex);

  00199	56		 push	 esi
  0019a	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 2252 : 		{
; 2253 : 			LogAdd(lMsg.Get(MSGGET(1, 219)), aIndex, id, gObj[aIndex].Ip_addr );

  0019f	83 c4 10	 add	 esp, 16			; 00000010H
  001a2	5b		 pop	 ebx
  001a3	5f		 pop	 edi
  001a4	5e		 pop	 esi

; 2285 : 	lpObj->m_btDestY = 0;
; 2286 : }

  001a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a8	33 cd		 xor	 ecx, ebp
  001aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
$LN8@CSPJoinIdP:

; 2246 : 		return;
; 2247 : 	}
; 2248 : 
; 2249 : 	if ( gObj[aIndex].LoginMsgSnd != FALSE )

  001b3	8a 41 0a	 mov	 al, BYTE PTR [ecx+10]
  001b6	84 c0		 test	 al, al
  001b8	74 4c		 je	 SHORT $LN9@CSPJoinIdP

; 2250 : 	{
; 2251 : 		if ( gObj[aIndex].LoginMsgSnd == TRUE )

  001ba	3c 01		 cmp	 al, 1
  001bc	75 33		 jne	 SHORT $LN10@CSPJoinIdP

; 2252 : 		{
; 2253 : 			LogAdd(lMsg.Get(MSGGET(1, 219)), aIndex, id, gObj[aIndex].Ip_addr );

  001be	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  001c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001c6	50		 push	 eax
  001c7	8d 45 f0	 lea	 eax, DWORD PTR _id$[ebp]
  001ca	50		 push	 eax
  001cb	56		 push	 esi
  001cc	68 db 01 00 00	 push	 475			; 000001dbH
  001d1	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001d6	50		 push	 eax
$LN27@CSPJoinIdP:
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001dd	83 c4 10	 add	 esp, 16			; 00000010H
  001e0	5b		 pop	 ebx
  001e1	5f		 pop	 edi
  001e2	5e		 pop	 esi

; 2285 : 	lpObj->m_btDestY = 0;
; 2286 : }

  001e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e6	33 cd		 xor	 ecx, ebp
  001e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c3		 ret	 0
$LN10@CSPJoinIdP:

; 2254 : 		}
; 2255 : 		else
; 2256 : 		{
; 2257 : 			LogAdd("error : %d %s %d", gObj[aIndex].LoginMsgSnd, __FILE__, __LINE__);

  001f1	68 d1 08 00 00	 push	 2257			; 000008d1H
  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  001fb	0f be c0	 movsx	 eax, al
  001fe	50		 push	 eax
  001ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PPEDKKBK@error?5?3?5?$CFd?5?$CFs?5?$CFd?$AA@

; 2258 : 		}
; 2259 : 
; 2260 : 		return;

  00204	eb d1		 jmp	 SHORT $LN27@CSPJoinIdP
$LN9@CSPJoinIdP:

; 2261 : 	}
; 2262 : 
; 2263 : 	SDHP_IDPASS spMsg;
; 2264 : 
; 2265 : 	PHeadSetB((LPBYTE)&spMsg, 0x01, sizeof(spMsg));

  00206	6a 36		 push	 54			; 00000036H
  00208	8d 45 a4	 lea	 eax, DWORD PTR _spMsg$[ebp]
  0020b	6a 01		 push	 1
  0020d	50		 push	 eax
  0020e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2266 : 	spMsg.Number = aIndex;
; 2267 : 	memcpy(spMsg.Id, lpMsg->Id, sizeof(spMsg.Id));

  00213	f3 0f 7e 47 04	 movq	 xmm0, QWORD PTR [edi+4]

; 2268 : 	memcpy(spMsg.Pass, lpMsg->Pass, sizeof(spMsg.Pass));
; 2269 : 	strcpy(spMsg.IpAddress, gObj[aIndex].Ip_addr);

  00218	8d 55 c8	 lea	 edx, DWORD PTR _spMsg$[ebp+36]
  0021b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00221	83 c4 0c	 add	 esp, 12			; 0000000cH
  00224	66 8b 47 0c	 mov	 ax, WORD PTR [edi+12]
  00228	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0022b	66 0f d6 45 a7	 movq	 QWORD PTR _spMsg$[ebp+3], xmm0
  00230	03 cb		 add	 ecx, ebx
  00232	0f 10 47 0e	 movups	 xmm0, XMMWORD PTR [edi+14]
  00236	66 89 45 af	 mov	 WORD PTR _spMsg$[ebp+11], ax
  0023a	2b d1		 sub	 edx, ecx
  0023c	8b 47 1e	 mov	 eax, DWORD PTR [edi+30]
  0023f	66 89 75 c6	 mov	 WORD PTR _spMsg$[ebp+34], si
  00243	0f 11 45 b1	 movups	 XMMWORD PTR _spMsg$[ebp+13], xmm0
  00247	89 45 c1	 mov	 DWORD PTR _spMsg$[ebp+29], eax
  0024a	66 0f 1f 44 00
	00		 npad	 6
$LL17@CSPJoinIdP:
  00250	8a 01		 mov	 al, BYTE PTR [ecx]
  00252	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00255	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00259	84 c0		 test	 al, al
  0025b	75 f3		 jne	 SHORT $LL17@CSPJoinIdP

; 2270 : 
; 2271 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();

  0025d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00263	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00269	89 44 0b 3c	 mov	 DWORD PTR [ebx+ecx+60], eax

; 2272 : 
; 2273 : 	gObj[aIndex].LoginMsgSnd = 1;

  0026d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00272	c6 44 03 0a 01	 mov	 BYTE PTR [ebx+eax+10], 1

; 2274 : 	gObj[aIndex].LoginMsgCount++;

  00277	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0027c	fe 44 03 0b	 inc	 BYTE PTR [ebx+eax+11]

; 2275 : 	gObj[aIndex].AccountID[MAX_ACCOUNT_LEN] = 0;

  00280	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00285	c6 44 03 5c 00	 mov	 BYTE PTR [ebx+eax+92], 0

; 2276 : 	memcpy(gObj[aIndex].AccountID, id, MAX_ACCOUNT_LEN);

  0028a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00290	f3 0f 7e 45 f0	 movq	 xmm0, QWORD PTR _id$[ebp]
  00295	66 0f d6 44 19
	52		 movq	 QWORD PTR [ecx+ebx+82], xmm0
  0029b	66 8b 45 f8	 mov	 ax, WORD PTR _id$[ebp+8]
  0029f	66 89 44 19 5a	 mov	 WORD PTR [ecx+ebx+90], ax

; 2277 : 	gObj[aIndex].m_cAccountItemBlock = 0;
; 2278 : 
; 2279 : 	wsJServerCli.DataSend((char*)&spMsg, spMsg.h.size);

  002a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  002a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002ae	c6 84 03 c4 01
	00 00 00	 mov	 BYTE PTR [ebx+eax+452], 0
  002b6	0f b6 45 a5	 movzx	 eax, BYTE PTR _spMsg$[ebp+1]
  002ba	50		 push	 eax
  002bb	8d 45 a4	 lea	 eax, DWORD PTR _spMsg$[ebp]
  002be	50		 push	 eax
  002bf	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 2280 : 	LogAddTD("join send : (%d)%s", aIndex, gObj[aIndex].AccountID);

  002c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  002c9	83 c0 52	 add	 eax, 82			; 00000052H
  002cc	03 c3		 add	 eax, ebx
  002ce	50		 push	 eax
  002cf	56		 push	 esi
  002d0	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CICILPEN@join?5send?5?3?5?$CI?$CFd?$CJ?$CFs?$AA@
  002d5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 2281 : 	lpObj->m_bMapSvrMoveReq = false;

  002db	8b 45 a0	 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  002de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2282 : 	lpObj->m_sPrevMapSvrCode = -1; 

  002e1	83 c9 ff	 or	 ecx, -1
  002e4	5b		 pop	 ebx
  002e5	5f		 pop	 edi
  002e6	c6 80 3d 20 00
	00 00		 mov	 BYTE PTR [eax+8253], 0
  002ed	66 89 88 44 20
	00 00		 mov	 WORD PTR [eax+8260], cx

; 2283 : 	lpObj->m_sDestMapNumber = -1;

  002f4	66 89 88 46 20
	00 00		 mov	 WORD PTR [eax+8262], cx

; 2284 : 	lpObj->m_btDestX = 0;

  002fb	66 c7 80 48 20
	00 00 00 00	 mov	 WORD PTR [eax+8264], 0
  00304	5e		 pop	 esi

; 2285 : 	lpObj->m_btDestY = 0;
; 2286 : }

  00305	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00308	33 cd		 xor	 ecx, ebp
  0030a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030f	8b e5		 mov	 esp, ebp
  00311	5d		 pop	 ebp
  00312	c3		 ret	 0
$LN3@CSPJoinIdP:

; 2203 : 		 lpMsg->CliVersion[4] != szClientVersion[4] )
; 2204 : 	{
; 2205 : 		GCJoinResult(JS_BAD_CLIENT_VERSION, aIndex);

  00313	56		 push	 esi
  00314	6a 06		 push	 6
  00316	e8 00 00 00 00	 call	 ?GCJoinResult@@YAXEH@Z	; GCJoinResult

; 2206 : 		CloseClient(aIndex);

  0031b	56		 push	 esi
  0031c	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient

; 2285 : 	lpObj->m_btDestY = 0;
; 2286 : }

  00321	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00324	83 c4 0c	 add	 esp, 12			; 0000000cH
  00327	33 cd		 xor	 ecx, ebp
  00329	5f		 pop	 edi
  0032a	5e		 pop	 esi
  0032b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00330	8b e5		 mov	 esp, ebp
  00332	5d		 pop	 ebp
  00333	c3		 ret	 0
?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z ENDP	; CSPJoinIdPassRequest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?SCPJoinResultSend@@YAXHE@Z
_TEXT	SEGMENT
_pResult$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_result$ = 12						; size = 1
?SCPJoinResultSend@@YAXHE@Z PROC			; SCPJoinResultSend, COMDAT

; 2161 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2162 : 	PMSG_JOINRESULT pResult;
; 2163 : 
; 2164 : 	memset(&pResult, 0, sizeof(pResult));
; 2165 : 
; 2166 : 	pResult.h.size = sizeof(pResult);
; 2167 : 	pResult.h.c = 0xC1;
; 2168 : 	pResult.h.headcode = 0xF1;
; 2169 : 	pResult.scode = 0x00;
; 2170 : 	pResult.result = result;

  00010	8a 45 0c	 mov	 al, BYTE PTR _result$[ebp]
  00013	0f 57 c0	 xorps	 xmm0, xmm0
  00016	66 0f d6 45 f0	 movq	 QWORD PTR _pResult$[ebp], xmm0
  0001b	88 45 f4	 mov	 BYTE PTR _pResult$[ebp+4], al
  0001e	53		 push	 ebx
  0001f	8b 5d 08	 mov	 ebx, DWORD PTR _aIndex$[ebp]

; 2171 : 	pResult.NumberH = SET_NUMBERH(aIndex);

  00022	8b c3		 mov	 eax, ebx
  00024	c1 e8 08	 shr	 eax, 8
  00027	88 45 f5	 mov	 BYTE PTR _pResult$[ebp+5], al

; 2172 : 	pResult.NumberL = SET_NUMBERL(aIndex);
; 2173 : 	pResult.CliVersion[0] = szClientVersion[0];

  0002a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?szClientVersion@@3PADA
  00031	88 45 f7	 mov	 BYTE PTR _pResult$[ebp+7], al

; 2174 : 	pResult.CliVersion[1] = szClientVersion[1];

  00034	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR ?szClientVersion@@3PADA+1
  0003b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pResult$[ebp+8], 0
  00042	88 45 f8	 mov	 BYTE PTR _pResult$[ebp+8], al

; 2175 : 	pResult.CliVersion[2] = szClientVersion[2];

  00045	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ?szClientVersion@@3PADA+2
  0004c	88 45 f9	 mov	 BYTE PTR _pResult$[ebp+9], al

; 2176 : 	pResult.CliVersion[3] = szClientVersion[3];

  0004f	0f b6 05 03 00
	00 00		 movzx	 eax, BYTE PTR ?szClientVersion@@3PADA+3
  00056	88 45 fa	 mov	 BYTE PTR _pResult$[ebp+10], al

; 2177 : 	pResult.CliVersion[4] = szClientVersion[4];

  00059	0f b6 05 04 00
	00 00		 movzx	 eax, BYTE PTR ?szClientVersion@@3PADA+4
  00060	88 45 fb	 mov	 BYTE PTR _pResult$[ebp+11], al

; 2178 : 
; 2179 : 	DataSend(aIndex, (unsigned char*)&pResult, pResult.h.size);

  00063	8d 45 f0	 lea	 eax, DWORD PTR _pResult$[ebp]
  00066	6a 0c		 push	 12			; 0000000cH
  00068	50		 push	 eax
  00069	53		 push	 ebx
  0006a	c7 45 f0 c1 0c
	f1 00		 mov	 DWORD PTR _pResult$[ebp], 15797441 ; 00f10cc1H
  00071	88 5d f6	 mov	 BYTE PTR _pResult$[ebp+6], bl
  00074	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2180 : 	gObj[aIndex].ConnectCheckTime = GetTickCount();

  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00088	69 d3 40 27 00
	00		 imul	 edx, ebx, 10048
  0008e	5b		 pop	 ebx
  0008f	89 44 0a 3c	 mov	 DWORD PTR [edx+ecx+60], eax

; 2181 : }

  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
?SCPJoinResultSend@@YAXHE@Z ENDP			; SCPJoinResultSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$1$ = -136					; size = 4
_index$1$ = -136					; size = 4
_pWhisper$ = -132					; size = 113
_tid$ = -16						; size = 11
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z PROC ; CGChatWhisperRecv, COMDAT

; 2098 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00016	53		 push	 ebx
  00017	56		 push	 esi

; 2099 : 	char tid[11];
; 2100 : 	PMSG_CHATDATA_WHISPER pWhisper;
; 2101 : 	int len;
; 2102 : 	LPOBJ lpObj = &gObj[aIndex];

  00018	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001e	57		 push	 edi
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00022	69 df 40 27 00
	00		 imul	 ebx, edi, 10048
  00028	89 85 78 ff ff
	ff		 mov	 DWORD PTR _lpMsg$GSCopy$1$[ebp], eax
  0002e	03 f3		 add	 esi, ebx

; 2103 : 	int index;
; 2104 : 
; 2105 : 	if ( PacketCheckTime(lpObj) == FALSE )

  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00036	83 c4 04	 add	 esp, 4
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 16 01 00
	00		 je	 $LN6@CGChatWhis

; 2106 : 	{
; 2107 : 		return;
; 2108 : 	}
; 2109 : 
; 2110 : 	if ( lpObj->ChatLimitTime > 0 )

  00041	0f b7 86 f8 00
	00 00		 movzx	 eax, WORD PTR [esi+248]
  00048	66 85 c0	 test	 ax, ax
  0004b	74 2c		 je	 SHORT $LN3@CGChatWhis

; 2111 : 	{
; 2112 : 		MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(4, 223)), lpObj->ChatLimitTime);

  0004d	50		 push	 eax
  0004e	68 df 04 00 00	 push	 1247			; 000004dfH
  00053	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00058	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0005d	50		 push	 eax
  0005e	ff 36		 push	 DWORD PTR [esi]
  00060	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput

; 2140 : 		DataSend(index, (UCHAR*)&pWhisper, pWhisper.h.size);

  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx

; 2141 : 	}
; 2142 : }

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006e	33 cd		 xor	 ecx, ebp
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN3@CGChatWhis:

; 2113 : 		return;
; 2114 : 	}
; 2115 : 
; 2116 : 	if ( (lpObj->Penalty & 2) == 2 )

  00079	f6 86 c0 01 00
	00 02		 test	 BYTE PTR [esi+448], 2
  00080	0f 85 d1 00 00
	00		 jne	 $LN6@CGChatWhis

; 2117 : 	{
; 2118 : 		return;
; 2119 : 	}
; 2120 : 
; 2121 : 	tid[10]=0;
; 2122 : 	memcpy(tid, lpMsg->id, sizeof(lpMsg->id));

  00086	8b b5 78 ff ff
	ff		 mov	 esi, DWORD PTR _lpMsg$GSCopy$1$[ebp]

; 2123 : 	index = WhisperCash.AddCash(tid);

  0008c	b9 00 00 00 00	 mov	 ecx, OFFSET ?WhisperCash@@3VCWhisperCash@@A ; WhisperCash
  00091	c6 45 fa 00	 mov	 BYTE PTR _tid$[ebp+10], 0
  00095	66 8b 46 0b	 mov	 ax, WORD PTR [esi+11]
  00099	f3 0f 7e 46 03	 movq	 xmm0, QWORD PTR [esi+3]
  0009e	66 89 45 f8	 mov	 WORD PTR _tid$[ebp+8], ax
  000a2	8d 45 f0	 lea	 eax, DWORD PTR _tid$[ebp]
  000a5	50		 push	 eax
  000a6	66 0f d6 45 f0	 movq	 QWORD PTR _tid$[ebp], xmm0
  000ab	e8 00 00 00 00	 call	 ?AddCash@CWhisperCash@@QAEHPAD@Z ; CWhisperCash::AddCash
  000b0	89 85 78 ff ff
	ff		 mov	 DWORD PTR _index$1$[ebp], eax

; 2124 : 
; 2125 : 	if ( index < 0 )

  000b6	85 c0		 test	 eax, eax
  000b8	79 1c		 jns	 SHORT $LN5@CGChatWhis

; 2126 : 	{
; 2127 : 		GCServerMsgSend(0, aIndex);

  000ba	57		 push	 edi
  000bb	6a 00		 push	 0
  000bd	e8 00 00 00 00	 call	 ?GCServerMsgSend@@YAXEH@Z ; GCServerMsgSend
  000c2	83 c4 08	 add	 esp, 8
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx

; 2141 : 	}
; 2142 : }

  000c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cb	33 cd		 xor	 ecx, ebp
  000cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
$LN5@CGChatWhis:

; 2128 : 		return;
; 2129 : 	}
; 2130 : 
; 2131 : 	PHeadSetB((LPBYTE)&pWhisper, 0x02, sizeof(pWhisper));

  000d6	6a 71		 push	 113			; 00000071H
  000d8	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _pWhisper$[ebp]
  000de	6a 02		 push	 2
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2132 : 	strcpy(pWhisper.id, gObj[aIndex].Name);

  000e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ec	8d 95 7f ff ff
	ff		 lea	 edx, DWORD PTR _pWhisper$[ebp+3]
  000f2	83 c1 5d	 add	 ecx, 93			; 0000005dH
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f8	03 cb		 add	 ecx, ebx
  000fa	2b d1		 sub	 edx, ecx
  000fc	0f 1f 40 00	 npad	 4
$LL10@CGChatWhis:
  00100	8a 01		 mov	 al, BYTE PTR [ecx]
  00102	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00105	88 44 0a ff	 mov	 BYTE PTR [edx+ecx-1], al
  00109	84 c0		 test	 al, al
  0010b	75 f3		 jne	 SHORT $LL10@CGChatWhis

; 2133 : 	memcpy(pWhisper.chatmsg, lpMsg->chatmsg, sizeof(lpMsg->chatmsg));

  0010d	83 c6 0d	 add	 esi, 13			; 0000000dH
  00110	8d 7d 89	 lea	 edi, DWORD PTR _pWhisper$[ebp+13]
  00113	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00118	f3 a5		 rep movsd

; 2134 : 	len = strlen(pWhisper.chatmsg);

  0011a	8d 4d 89	 lea	 ecx, DWORD PTR _pWhisper$[ebp+13]
  0011d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL14@CGChatWhis:
  00120	8a 01		 mov	 al, BYTE PTR [ecx]
  00122	41		 inc	 ecx
  00123	84 c0		 test	 al, al
  00125	75 f9		 jne	 SHORT $LL14@CGChatWhis
  00127	2b ca		 sub	 ecx, edx

; 2135 : 
; 2136 : 	if ( len > 0 )

  00129	85 c9		 test	 ecx, ecx
  0012b	7e 2a		 jle	 SHORT $LN6@CGChatWhis

; 2137 : 	{
; 2138 : 		pWhisper.h.size -= sizeof(pWhisper.chatmsg);
; 2139 : 		pWhisper.h.size += len + 1;

  0012d	8a 85 7d ff ff
	ff		 mov	 al, BYTE PTR _pWhisper$[ebp+1]
  00133	80 e9 63	 sub	 cl, 99			; 00000063H
  00136	02 c1		 add	 al, cl
  00138	88 85 7d ff ff
	ff		 mov	 BYTE PTR _pWhisper$[ebp+1], al

; 2140 : 		DataSend(index, (UCHAR*)&pWhisper, pWhisper.h.size);

  0013e	0f b6 c0	 movzx	 eax, al
  00141	50		 push	 eax
  00142	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _pWhisper$[ebp]
  00148	50		 push	 eax
  00149	ff b5 78 ff ff
	ff		 push	 DWORD PTR _index$1$[ebp]
  0014f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00154	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@CGChatWhis:

; 2141 : 	}
; 2142 : }

  00157	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	33 cd		 xor	 ecx, ebp
  0015e	5b		 pop	 ebx
  0015f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ENDP ; CGChatWhisperRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCMapEventStateSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_map$ = 8						; size = 4
_state$ = 12						; size = 1
_event$ = 16						; size = 1
?GCMapEventStateSend@@YAXHEE@Z PROC			; GCMapEventStateSend, COMDAT

; 2078 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2079 : 	PMSG_EVENT pMsg;
; 2080 : 
; 2081 : 	PHeadSetB((LPBYTE)&pMsg, 0x0B, sizeof(pMsg));

  00009	6a 05		 push	 5
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	6a 0b		 push	 11			; 0000000bH
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2082 : 	pMsg.Event = event;

  00016	8a 45 10	 mov	 al, BYTE PTR _event$[ebp]
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	8b 5d 08	 mov	 ebx, DWORD PTR _map$[ebp]

; 2083 : 	pMsg.State = state;
; 2084 : 
; 2085 : 	for ( int n=0; n<OBJMAX ; n++ )

  0001f	33 ff		 xor	 edi, edi
  00021	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00024	33 f6		 xor	 esi, esi
  00026	8a 45 0c	 mov	 al, BYTE PTR _state$[ebp]
  00029	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al
  0002c	0f 1f 40 00	 npad	 4
$LL4@GCMapEvent:

; 2086 : 	{
; 2087 : 		if ( gObj[n].Connected == PLAYER_PLAYING && gObj[n].Type == OBJ_USER && map == gObj[n].MapNumber )

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00035	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0003a	75 25		 jne	 SHORT $LN2@GCMapEvent
  0003c	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00041	75 1e		 jne	 SHORT $LN2@GCMapEvent
  00043	0f b6 84 06 23
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+291]
  0004b	3b d8		 cmp	 ebx, eax
  0004d	75 12		 jne	 SHORT $LN2@GCMapEvent

; 2088 : 		{
; 2089 : 			DataSend(n, (UCHAR*)&pMsg, pMsg.h.size);

  0004f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00053	50		 push	 eax
  00054	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00057	50		 push	 eax
  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCMapEvent:

; 2083 : 	pMsg.State = state;
; 2084 : 
; 2085 : 	for ( int n=0; n<OBJMAX ; n++ )

  00061	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00067	47		 inc	 edi
  00068	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  0006e	7c c0		 jl	 SHORT $LL4@GCMapEvent
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx

; 2090 : 		}
; 2091 : 	}
; 2092 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?GCMapEventStateSend@@YAXHEE@Z ENDP			; GCMapEventStateSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCEventStateSend@@YAXHEE@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_aIndex$ = 8						; size = 4
_state$ = 12						; size = 1
_event$ = 16						; size = 1
?GCEventStateSend@@YAXHEE@Z PROC			; GCEventStateSend, COMDAT

; 2063 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2064 : 	PMSG_EVENT pMsg;
; 2065 : 
; 2066 : 	PHeadSetB((LPBYTE)&pMsg, 0x0B, sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000b	6a 0b		 push	 11			; 0000000bH
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2067 : 	pMsg.Event = event;

  00013	8a 45 10	 mov	 al, BYTE PTR _event$[ebp]
  00016	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 2068 : 	pMsg.State = state;

  00019	8a 45 0c	 mov	 al, BYTE PTR _state$[ebp]
  0001c	88 45 fb	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2069 : 
; 2070 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  0001f	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00023	50		 push	 eax
  00024	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00027	50		 push	 eax
  00028	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 18	 add	 esp, 24			; 00000018H

; 2071 : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?GCEventStateSend@@YAXHEE@Z ENDP			; GCEventStateSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z
_TEXT	SEGMENT
_lpNode$ = 8						; size = 4
_szMsg$ = 12						; size = 4
_type$ = 16						; size = 1
?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z PROC ; GCServerMsgStringSendGuild, COMDAT

; 2036 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2037 : 	if ( lpNode == NULL )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpNode$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 40		 je	 SHORT $LN3@GCServerMs

; 2038 : 	{
; 2039 : 		return;
; 2040 : 	}
; 2041 : 
; 2042 : 	for ( int n = 0; n<MAX_USER_GUILD ; n++)

  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	33 f6		 xor	 esi, esi
  0000f	8d b8 a0 03 00
	00		 lea	 edi, DWORD PTR [eax+928]
  00015	8d 98 40 04 00
	00		 lea	 ebx, DWORD PTR [eax+1088]
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@GCServerMs:

; 2043 : 	{
; 2044 : 		if (lpNode->Use[n] > 0 && lpNode->Index[n] >= 0 )

  00020	80 3c 33 00	 cmp	 BYTE PTR [ebx+esi], 0
  00024	76 18		 jbe	 SHORT $LN2@GCServerMs
  00026	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00029	66 85 c0	 test	 ax, ax
  0002c	78 10		 js	 SHORT $LN2@GCServerMs

; 2045 : 		{
; 2046 : 			GCServerMsgStringSend((char*)szMsg, lpNode->Index[n], type);

  0002e	ff 75 10	 push	 DWORD PTR _type$[ebp]
  00031	98		 cwde
  00032	50		 push	 eax
  00033	ff 75 0c	 push	 DWORD PTR _szMsg$[ebp]
  00036	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@GCServerMs:

; 2038 : 	{
; 2039 : 		return;
; 2040 : 	}
; 2041 : 
; 2042 : 	for ( int n = 0; n<MAX_USER_GUILD ; n++)

  0003e	46		 inc	 esi
  0003f	83 c7 02	 add	 edi, 2
  00042	83 fe 50	 cmp	 esi, 80			; 00000050H
  00045	7c d9		 jl	 SHORT $LL4@GCServerMs
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
$LN3@GCServerMs:

; 2047 : 		}
; 2048 : 	}
; 2049 : }

  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?GCServerMsgStringSendGuild@@YAXPAU_GUILD_INFO_STRUCT@@PADE@Z ENDP ; GCServerMsgStringSendGuild
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCServerMsgStringSend@@YAXPADHE@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_szMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
_type$ = 16						; size = 1
?GCServerMsgStringSend@@YAXPADHE@Z PROC			; GCServerMsgStringSend, COMDAT

; 2024 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _szMsg$[ebp]

; 2025 : 	PMSG_NOTICE pNotice;
; 2026 : 	
; 2027 : 	TNotice::MakeNoticeMsg((TNotice*)&pNotice, type, szMsg);

  00016	50		 push	 eax
  00017	ff 75 10	 push	 DWORD PTR _type$[ebp]
  0001a	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg

; 2028 : 	DataSend(aIndex, (UCHAR*)&pNotice, pNotice.h.size);

  00026	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  0002d	50		 push	 eax
  0002e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00034	50		 push	 eax
  00035	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  00038	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 2029 : }

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	83 c4 18	 add	 esp, 24			; 00000018H
  00043	33 cd		 xor	 ecx, ebp
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GCServerMsgStringSend@@YAXPADHE@Z ENDP			; GCServerMsgStringSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCServerMsgSend@@YAXEH@Z
_TEXT	SEGMENT
_pMsg$ = -4						; size = 4
_msg$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?GCServerMsgSend@@YAXEH@Z PROC				; GCServerMsgSend, COMDAT

; 2010 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2011 : 	PMSG_SERVERMSG pMsg;
; 2012 : 
; 2013 : 	PHeadSetB((LPBYTE)&pMsg, 0x0C, sizeof(pMsg));

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00009	6a 0c		 push	 12			; 0000000cH
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 2014 : 	pMsg.MsgNumber = msg;

  00011	8a 45 08	 mov	 al, BYTE PTR _msg$[ebp]
  00014	88 45 ff	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 2015 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00017	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0001b	50		 push	 eax
  0001c	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR _aIndex$[ebp]
  00023	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00028	83 c4 18	 add	 esp, 24			; 00000018H

; 2016 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GCServerMsgSend@@YAXEH@Z ENDP				; GCServerMsgSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z PROC	; CGChatRecv, COMDAT

; 1986 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1987 : 	LPOBJ lpObj = &gObj[aIndex];

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00007	57		 push	 edi
  00008	69 fb 40 27 00
	00		 imul	 edi, ebx, 10048
  0000e	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1988 : 
; 1989 : 	if ( PacketCheckTime(lpObj) == FALSE )

  00014	57		 push	 edi
  00015	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 20		 je	 SHORT $LN1@CGChatRecv

; 1990 : 	{
; 1991 : 		return;
; 1992 : 	}
; 1993 : 
; 1994 : 	DataSend(aIndex, (LPBYTE)lpMsg, lpMsg->h.size);

  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _lpMsg$[ebp]
  00025	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00029	50		 push	 eax
  0002a	56		 push	 esi
  0002b	53		 push	 ebx
  0002c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1995 : 	MsgSendV2(lpObj, (LPBYTE)lpMsg, lpMsg->h.size);

  00031	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00035	50		 push	 eax
  00036	56		 push	 esi
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0003d	83 c4 18	 add	 esp, 24			; 00000018H
  00040	5e		 pop	 esi
$LN1@CGChatRecv:
  00041	5f		 pop	 edi
  00042	5b		 pop	 ebx

; 1996 : }

  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z ENDP	; CGChatRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z
_TEXT	SEGMENT
tv1071 = -424						; size = 4
_i$1$ = -424						; size = 4
tv1051 = -420						; size = 4
tv1042 = -416						; size = 4
tv1041 = -416						; size = 4
tv1072 = -412						; size = 4
_n$3$ = -412						; size = 4
_iGuildCount$1 = -412					; size = 4
_lpObj$1$ = -408					; size = 4
_iGuildList$2 = -404					; size = 400
_tmpCommandText$3 = -204				; size = 200
_lpRequest$4 = -112					; size = 106
__$ArrayPad$ = -4					; size = 4
_lpChat$ = 8						; size = 4
_aIndex$ = 12						; size = 2
?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z PROC		; PChatProc, COMDAT

; 1697 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	0f b7 45 0c	 movzx	 eax, WORD PTR _aIndex$[ebp]
  00017	53		 push	 ebx

; 1698 : 
; 1699 : 	int n;
; 1700 : 	LPOBJ lpObj = &gObj[aIndex];

  00018	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0001e	98		 cwde
  0001f	56		 push	 esi
  00020	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  00026	57		 push	 edi
  00027	8b 7d 08	 mov	 edi, DWORD PTR _lpChat$[ebp]
  0002a	89 85 64 fe ff
	ff		 mov	 DWORD PTR tv1072[ebp], eax
  00030	03 d9		 add	 ebx, ecx
  00032	89 8d 58 fe ff
	ff		 mov	 DWORD PTR tv1071[ebp], ecx

; 1701 : 	int number;
; 1702 : 	int slen = strlen(lpChat->chatmsg);

  00038	8d 4f 0d	 lea	 ecx, DWORD PTR [edi+13]
  0003b	89 9d 68 fe ff
	ff		 mov	 DWORD PTR _lpObj$1$[ebp], ebx
  00041	8b f1		 mov	 esi, ecx
  00043	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
$LL108@PChatProc:
  00046	8a 06		 mov	 al, BYTE PTR [esi]
  00048	46		 inc	 esi
  00049	84 c0		 test	 al, al
  0004b	75 f9		 jne	 SHORT $LL108@PChatProc
  0004d	2b f2		 sub	 esi, edx

; 1703 : 
; 1704 : 	if ( slen < 1 )

  0004f	83 fe 01	 cmp	 esi, 1
  00052	0f 8c ed 06 00
	00		 jl	 $LN5@PChatProc

; 1705 : 		return;
; 1706 : 
; 1707 : 	if ( slen > MAX_CHAT_LEN-1 )

  00058	83 fe 59	 cmp	 esi, 89			; 00000059H
  0005b	7e 28		 jle	 SHORT $LN23@PChatProc

; 1708 : 	{
; 1709 : 		LogAddTD("[Anti-HACK][PChatProc][%s][%s] Chat Message Len : %d", lpObj->AccountID, lpObj->Name, slen);

  0005d	56		 push	 esi
  0005e	8d 43 5d	 lea	 eax, DWORD PTR [ebx+93]
  00061	50		 push	 eax
  00062	8d 43 52	 lea	 eax, DWORD PTR [ebx+82]
  00065	50		 push	 eax
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@BCJCJNCO@?$FLAnti?9HACK?$FN?$FLPChatProc?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5C@
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00071	83 c4 10	 add	 esp, 16			; 00000010H
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  00077	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007a	33 cd		 xor	 ecx, ebp
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN23@PChatProc:

; 1710 : 		return;
; 1711 : 	}
; 1712 : 
; 1713 : 	char szId[MAX_ACCOUNT_LEN+1];
; 1714 : 	szId[MAX_ACCOUNT_LEN] = 0;
; 1715 : 
; 1716 : 	memcpy(szId, gObj[aIndex].Name, MAX_ACCOUNT_LEN);

  00085	f3 0f 7e 43 5d	 movq	 xmm0, QWORD PTR [ebx+93]
  0008a	83 c3 5d	 add	 ebx, 93			; 0000005dH

; 1717 : 	memcpy(lpChat->chatid, szId, MAX_ACCOUNT_LEN);
; 1718 : 	int szTargetNameCount = 0;
; 1719 : 
; 1720 : 	if (!ZTHelper::isValidChatSyntax(lpChat->chatmsg)) {

  0008d	51		 push	 ecx
  0008e	66 8b 43 08	 mov	 ax, WORD PTR [ebx+8]
  00092	66 0f d6 47 03	 movq	 QWORD PTR [edi+3], xmm0
  00097	66 89 47 0b	 mov	 WORD PTR [edi+11], ax
  0009b	e8 00 00 00 00	 call	 ?isValidChatSyntax@ZTHelper@@SA_NPBD@Z ; ZTHelper::isValidChatSyntax
  000a0	83 c4 04	 add	 esp, 4
  000a3	84 c0		 test	 al, al
  000a5	75 24		 jne	 SHORT $LN24@PChatProc

; 1721 : 		MsgOutput(aIndex, "Incorrect syntax");

  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FKJLBJJB@Incorrect?5syntax?$AA@
  000ac	ff b5 64 fe ff
	ff		 push	 DWORD PTR tv1072[ebp]
  000b2	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  000b7	83 c4 08	 add	 esp, 8
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c0	33 cd		 xor	 ecx, ebp
  000c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
$LN24@PChatProc:

; 1722 : 		return;
; 1723 : 	}
; 1724 : 	
; 1725 : 	switch ( lpChat->chatmsg[0] )

  000cb	8a 47 0d	 mov	 al, BYTE PTR [edi+13]
  000ce	8d 57 0d	 lea	 edx, DWORD PTR [edi+13]
  000d1	8a c8		 mov	 cl, al
  000d3	80 f9 21	 cmp	 cl, 33			; 00000021H
  000d6	74 34		 je	 SHORT $LN25@PChatProc
  000d8	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  000db	0f 85 2c 01 00
	00		 jne	 $LN28@PChatProc

; 1750 : 					return;
; 1751 : 				}
; 1752 : 			}
; 1753 : 			break;
; 1754 : 		case '/':	// Command
; 1755 : 			if ( slen > 2 )

  000e1	83 fe 02	 cmp	 esi, 2
  000e4	0f 8e 23 01 00
	00		 jle	 $LN28@PChatProc

; 1756 : 			{
; 1757 : 				g_CommandManager.Run(lpObj, lpChat->chatmsg);

  000ea	52		 push	 edx
  000eb	ff b5 68 fe ff
	ff		 push	 DWORD PTR _lpObj$1$[ebp]
  000f1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CommandManager@@3VCommandManager@@A ; g_CommandManager
  000f6	e8 00 00 00 00	 call	 ?Run@CommandManager@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CommandManager::Run
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  000fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00101	33 cd		 xor	 ecx, ebp
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
$LN25@PChatProc:

; 1726 : 	{
; 1727 : 		case '!':	// Global Announcement
; 1728 : 			if ( slen > 2 )

  0010c	83 fe 02	 cmp	 esi, 2
  0010f	0f 8e f8 00 00
	00		 jle	 $LN28@PChatProc

; 1729 : 			{
; 1730 : 				if (CheckAuthority(34,lpObj) == 1) {

  00115	8b 9d 68 fe ff
	ff		 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
  0011b	53		 push	 ebx
  0011c	6a 22		 push	 34			; 00000022H
  0011e	e8 00 00 00 00	 call	 ?CheckAuthority@@YAEHPAUOBJECTSTRUCT@@@Z ; CheckAuthority
  00123	83 c4 08	 add	 esp, 8
  00126	3c 01		 cmp	 al, 1
  00128	0f 85 8c 00 00
	00		 jne	 $LN27@PChatProc

; 1731 : 					/*MSG_SYS_BROADCAST	res = { 0 };
; 1732 : 					res.h.set((LPBYTE)&res, 0xCD, sizeof(res));
; 1733 : 					res.btSize = lpChat->h.size;
; 1734 : 					CopyMemory(res.szMessage, lpChat->chatmsg, lpChat->h.size);
; 1735 : 					cDBSMng.Send((char*)&res, sizeof(MSG_SYS_BROADCAST));
; 1736 : 					AllSendServerMsg(&lpChat->chatmsg[1]);*/
; 1737 : 					
; 1738 : 					BroadCastMessageInfo lpRequest = { 0 };

  0012e	6a 69		 push	 105			; 00000069H
  00130	8d 45 91	 lea	 eax, DWORD PTR _lpRequest$4[ebp+1]
  00133	6a 00		 push	 0
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _memset

; 1741 : 					CopyMemory(lpRequest.Text, lpChat->chatmsg, lpChat->h.size);

  0013b	0f b6 77 01	 movzx	 esi, BYTE PTR [edi+1]
  0013f	8d 47 0d	 lea	 eax, DWORD PTR [edi+13]
  00142	56		 push	 esi
  00143	50		 push	 eax
  00144	8d 45 a0	 lea	 eax, DWORD PTR _lpRequest$4[ebp+16]
; File c:\users\michel\desktop\source\gameserver\include\prodef.h

; 111  : 		lpBuf[0] = 0xC2;

  00147	c7 45 90 c2 00
	6a cd		 mov	 DWORD PTR _lpRequest$4[ebp], -848691006 ; cd6a00c2H
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 1741 : 					CopyMemory(lpRequest.Text, lpChat->chatmsg, lpChat->h.size);

  0014e	50		 push	 eax
  0014f	c6 45 94 00	 mov	 BYTE PTR _lpRequest$4[ebp+4], 0
  00153	e8 00 00 00 00	 call	 _memcpy

; 1742 : 					DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);

  00158	56		 push	 esi
  00159	57		 push	 edi
  0015a	ff b5 64 fe ff
	ff		 push	 DWORD PTR tv1072[ebp]
  00160	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00165	83 c4 24	 add	 esp, 36			; 00000024H

; 1743 : 					wsJServerCli.DataSend((PCHAR)&lpRequest, sizeof(BroadCastMessageInfo));

  00168	8d 45 90	 lea	 eax, DWORD PTR _lpRequest$4[ebp]
  0016b	b9 00 00 00 00	 mov	 ecx, OFFSET ?wsJServerCli@@3VwsJoinServerCli@@A ; wsJServerCli
  00170	6a 6a		 push	 106			; 0000006aH
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 ?DataSend@wsJoinServerCli@@QAEHPADH@Z ; wsJoinServerCli::DataSend

; 1744 : 					LogAddTD(lMsg.Get(MSGGET(1, 215)), gObj[aIndex].AccountID, gObj[aIndex].Name, &lpChat->chatmsg[1]);

  00178	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv1071[ebp]
  0017e	8d 47 0e	 lea	 eax, DWORD PTR [edi+14]
  00181	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00187	50		 push	 eax
  00188	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  0018b	50		 push	 eax
  0018c	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  0018f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00194	50		 push	 eax
  00195	68 d7 01 00 00	 push	 471			; 000001d7H
  0019a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0019f	50		 push	 eax
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001a6	83 c4 10	 add	 esp, 16			; 00000010H
  001a9	5f		 pop	 edi
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  001ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001af	33 cd		 xor	 ecx, ebp
  001b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c3		 ret	 0
$LN27@PChatProc:
  001ba	68 c8 00 00 00	 push	 200			; 000000c8H
  001bf	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _tmpCommandText$3[ebp]
  001c5	6a 00		 push	 0
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 _memset

; 1745 : 					return;
; 1746 : 				} else { // post
; 1747 : 					char tmpCommandText[200] = { 0 };
; 1748 : 					sprintf_s(tmpCommandText, sizeof(tmpCommandText), "/post %s", &lpChat->chatmsg[1]);

  001cd	8d 47 0e	 lea	 eax, DWORD PTR [edi+14]
  001d0	50		 push	 eax
  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFCDDNP@?1post?5?$CFs?$AA@
  001d6	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _tmpCommandText$3[ebp]
  001dc	68 c8 00 00 00	 push	 200			; 000000c8H
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 _sprintf_s
  001e7	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1749 : 					g_CommandManager.Run(lpObj, tmpCommandText);

  001ea	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR _tmpCommandText$3[ebp]
  001f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CommandManager@@3VCommandManager@@A ; g_CommandManager
  001f5	50		 push	 eax
  001f6	53		 push	 ebx
  001f7	e8 00 00 00 00	 call	 ?Run@CommandManager@@QAEXPAUOBJECTSTRUCT@@PAD@Z ; CommandManager::Run
  001fc	5f		 pop	 edi
  001fd	5e		 pop	 esi
  001fe	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  001ff	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00202	33 cd		 xor	 ecx, ebp
  00204	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00209	8b e5		 mov	 esp, ebp
  0020b	5d		 pop	 ebp
  0020c	c3		 ret	 0
$LN28@PChatProc:

; 1758 : 				return;
; 1759 : 			}
; 1760 : 			break;
; 1761 : 	}
; 1762 : 
; 1763 : 	// Other Commands
; 1764 : 	if ( lpObj->ChatLimitTime > 0 )

  0020d	8b b5 68 fe ff
	ff		 mov	 esi, DWORD PTR _lpObj$1$[ebp]
  00213	0f b7 8e f8 00
	00 00		 movzx	 ecx, WORD PTR [esi+248]
  0021a	66 85 c9	 test	 cx, cx
  0021d	74 2c		 je	 SHORT $LN31@PChatProc

; 1765 : 	{
; 1766 : 		MsgOutput(lpObj->m_Index, lMsg.Get(MSGGET(4, 223)), lpObj->ChatLimitTime);

  0021f	51		 push	 ecx
  00220	68 df 04 00 00	 push	 1247			; 000004dfH
  00225	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0022a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0022f	50		 push	 eax
  00230	ff 36		 push	 DWORD PTR [esi]
  00232	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00237	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023a	5f		 pop	 edi
  0023b	5e		 pop	 esi
  0023c	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN31@PChatProc:

; 1767 : 		return;
; 1768 : 	}
; 1769 : 
; 1770 : 	if ( (lpObj->Penalty&2)==2)

  0024b	f6 86 c0 01 00
	00 02		 test	 BYTE PTR [esi+448], 2
  00252	0f 85 ed 04 00
	00		 jne	 $LN5@PChatProc

; 1771 : 		return;
; 1772 : 
; 1773 : 	// Party Message
; 1774 : 	if ( lpChat->chatmsg[0] == '~' || lpChat->chatmsg[0] == ']' )

  00258	3c 7e		 cmp	 al, 126			; 0000007eH
  0025a	0f 84 90 04 00
	00		 je	 $LN35@PChatProc
  00260	3c 5d		 cmp	 al, 93			; 0000005dH
  00262	0f 84 88 04 00
	00		 je	 $LN35@PChatProc

; 1789 : 					}
; 1790 : 				}
; 1791 : 			}
; 1792 : 		}
; 1793 : 	}
; 1794 : 	// Guild
; 1795 : 	else if ( lpChat->chatmsg[0] == '@' )

  00268	3c 40		 cmp	 al, 64			; 00000040H
  0026a	0f 85 22 03 00
	00		 jne	 $LN39@PChatProc

; 1796 : 	{
; 1797 : 		if ( lpObj->GuildNumber > 0 )

  00270	83 be 14 06 00
	00 00		 cmp	 DWORD PTR [esi+1556], 0
  00277	0f 8e c8 04 00
	00		 jle	 $LN5@PChatProc

; 1798 : 		{
; 1799 : 			// Notice
; 1800 : 			if ( lpChat->chatmsg[1] == '>' )

  0027d	8a 47 0e	 mov	 al, BYTE PTR [edi+14]
  00280	3c 3e		 cmp	 al, 62			; 0000003eH
  00282	0f 85 8d 00 00
	00		 jne	 $LN42@PChatProc

; 1801 : 			{
; 1802 : 				if ( lpObj->Name[0] == lpObj->lpGuild->Names[0][0] )

  00288	8b 96 18 06 00
	00		 mov	 edx, DWORD PTR [esi+1560]
  0028e	8a 03		 mov	 al, BYTE PTR [ebx]
  00290	8d 4a 2f	 lea	 ecx, DWORD PTR [edx+47]
  00293	3a 01		 cmp	 al, BYTE PTR [ecx]
  00295	0f 85 aa 04 00
	00		 jne	 $LN5@PChatProc
  0029b	0f 1f 44 00 00	 npad	 5
$LL109@PChatProc:

; 1803 : 				{
; 1804 : 					if ( !strcmp(lpObj->Name, lpObj->lpGuild->Names[0] ) )

  002a0	8a 03		 mov	 al, BYTE PTR [ebx]
  002a2	3a 01		 cmp	 al, BYTE PTR [ecx]
  002a4	75 1a		 jne	 SHORT $LN110@PChatProc
  002a6	84 c0		 test	 al, al
  002a8	74 12		 je	 SHORT $LN111@PChatProc
  002aa	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  002ad	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  002b0	75 0e		 jne	 SHORT $LN110@PChatProc
  002b2	83 c3 02	 add	 ebx, 2
  002b5	83 c1 02	 add	 ecx, 2
  002b8	84 c0		 test	 al, al
  002ba	75 e4		 jne	 SHORT $LL109@PChatProc
$LN111@PChatProc:
  002bc	33 c0		 xor	 eax, eax
  002be	eb 05		 jmp	 SHORT $LN112@PChatProc
$LN110@PChatProc:
  002c0	1b c0		 sbb	 eax, eax
  002c2	83 c8 01	 or	 eax, 1
$LN112@PChatProc:
  002c5	85 c0		 test	 eax, eax
  002c7	0f 85 78 04 00
	00		 jne	 $LN5@PChatProc

; 1805 : 					{
; 1806 : 						GDGuildNoticeSave(lpObj->lpGuild->Name, &lpChat->chatmsg[2]);

  002cd	8d 47 0f	 lea	 eax, DWORD PTR [edi+15]
  002d0	50		 push	 eax
  002d1	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  002d4	50		 push	 eax
  002d5	e8 00 00 00 00	 call	 ?GDGuildNoticeSave@@YAXPAD0@Z ; GDGuildNoticeSave
  002da	83 c4 08	 add	 esp, 8

; 1807 : 						LogAdd(lMsg.Get(MSGGET(1, 216)), lpObj->lpGuild->Name, lpChat->chatmsg);

  002dd	8d 47 0d	 lea	 eax, DWORD PTR [edi+13]
  002e0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  002e5	50		 push	 eax
  002e6	8b 86 18 06 00
	00		 mov	 eax, DWORD PTR [esi+1560]
  002ec	83 c0 04	 add	 eax, 4
  002ef	50		 push	 eax
  002f0	68 d8 01 00 00	 push	 472			; 000001d8H
  002f5	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  002fa	50		 push	 eax
  002fb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00301	83 c4 0c	 add	 esp, 12			; 0000000cH
  00304	5f		 pop	 edi
  00305	5e		 pop	 esi
  00306	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  00307	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0030a	33 cd		 xor	 ecx, ebp
  0030c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00311	8b e5		 mov	 esp, ebp
  00313	5d		 pop	 ebp
  00314	c3		 ret	 0
$LN42@PChatProc:

; 1808 : 					}
; 1809 : 				}
; 1810 : 			}
; 1811 : 			// Aliances
; 1812 : 			else if ( lpChat->chatmsg[1] == '@' && lpObj->lpGuild->iGuildUnion )

  00315	3c 40		 cmp	 al, 64			; 00000040H
  00317	0f 85 88 01 00
	00		 jne	 $LN46@PChatProc
  0031d	8b 86 18 06 00
	00		 mov	 eax, DWORD PTR [esi+1560]
  00323	8b b0 44 07 00
	00		 mov	 esi, DWORD PTR [eax+1860]
  00329	85 f6		 test	 esi, esi
  0032b	0f 84 74 01 00
	00		 je	 $LN46@PChatProc

; 1813 : 			{
; 1814 : 				int iGuildCount = 0;

  00331	68 90 01 00 00	 push	 400			; 00000190H
  00336	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _iGuildList$2[ebp]
  0033c	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iGuildCount$1[ebp], 0
  00346	6a 00		 push	 0
  00348	50		 push	 eax
  00349	e8 00 00 00 00	 call	 _memset
  0034e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1815 : 				int iGuildList[MAX_UNION_GUILD] ={0};
; 1816 : 
; 1817 : 				if ( UnionManager.GetGuildUnionMemberList(lpObj->lpGuild->iGuildUnion, iGuildCount, iGuildList) == TRUE )

  00351	8d 85 6c fe ff
	ff		 lea	 eax, DWORD PTR _iGuildList$2[ebp]
  00357	b9 00 00 00 00	 mov	 ecx, OFFSET ?UnionManager@@3VTUnion@@A ; UnionManager
  0035c	50		 push	 eax
  0035d	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _iGuildCount$1[ebp]
  00363	50		 push	 eax
  00364	56		 push	 esi
  00365	e8 00 00 00 00	 call	 ?GetGuildUnionMemberList@TUnion@@QAEHHAAHPAH@Z ; TUnion::GetGuildUnionMemberList
  0036a	83 f8 01	 cmp	 eax, 1
  0036d	0f 85 f9 00 00
	00		 jne	 $LN8@PChatProc

; 1818 : 				{
; 1819 : 					for ( int i=0;i<iGuildCount;i++)

  00373	33 c0		 xor	 eax, eax
  00375	89 85 58 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  0037b	39 85 64 fe ff
	ff		 cmp	 DWORD PTR _iGuildCount$1[ebp], eax
  00381	0f 8e e5 00 00
	00		 jle	 $LN8@PChatProc
  00387	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL9@PChatProc:

; 1820 : 					{
; 1821 : 						_GUILD_INFO_STRUCT *lpGuildInfo = Guild.SearchGuild_Number(iGuildList[i]);

  00390	ff b4 85 6c fe
	ff ff		 push	 DWORD PTR _iGuildList$2[ebp+eax*4]
  00397	b9 00 00 00 00	 mov	 ecx, OFFSET ?Guild@@3VCGuildClass@@A ; Guild
  0039c	e8 00 00 00 00	 call	 ?SearchGuild_Number@CGuildClass@@QAEPAU_GUILD_INFO_STRUCT@@H@Z ; CGuildClass::SearchGuild_Number

; 1822 : 
; 1823 : 						if ( !lpGuildInfo )

  003a1	85 c0		 test	 eax, eax
  003a3	0f 84 aa 00 00
	00		 je	 $LN7@PChatProc

; 1824 : 							continue;
; 1825 : 
; 1826 : 						for (n=0;n<MAX_USER_GUILD;n++)

  003a9	8d 90 a0 03 00
	00		 lea	 edx, DWORD PTR [eax+928]
  003af	33 f6		 xor	 esi, esi
  003b1	8d 58 2f	 lea	 ebx, DWORD PTR [eax+47]
  003b4	89 95 60 fe ff
	ff		 mov	 DWORD PTR tv1042[ebp], edx
  003ba	05 40 04 00 00	 add	 eax, 1088		; 00000440H
  003bf	89 85 5c fe ff
	ff		 mov	 DWORD PTR tv1051[ebp], eax
$LL12@PChatProc:

; 1827 : 						{
; 1828 : 							if ( lpGuildInfo->Use[n] )

  003c5	80 3c 30 00	 cmp	 BYTE PTR [eax+esi], 0
  003c9	74 72		 je	 SHORT $LN10@PChatProc

; 1829 : 							{
; 1830 : 								number = lpGuildInfo->Index[n];

  003cb	0f bf 02	 movsx	 eax, WORD PTR [edx]

; 1831 : 
; 1832 : 								if ( number >= 0 )

  003ce	85 c0		 test	 eax, eax
  003d0	78 65		 js	 SHORT $LN126@PChatProc

; 1833 : 								{
; 1834 : 									if ( lpGuildInfo->Names[n][0] == gObj[number].Name[0] )

  003d2	69 c8 40 27 00
	00		 imul	 ecx, eax, 10048
  003d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  003dd	83 c0 5d	 add	 eax, 93			; 0000005dH
  003e0	03 c1		 add	 eax, ecx
  003e2	8a 0b		 mov	 cl, BYTE PTR [ebx]
  003e4	3a 08		 cmp	 cl, BYTE PTR [eax]
  003e6	75 4f		 jne	 SHORT $LN126@PChatProc

; 1835 : 									{
; 1836 : 										if ( !strcmp(lpGuildInfo->Names[n], gObj[number].Name ))

  003e8	8b cb		 mov	 ecx, ebx
  003ea	66 0f 1f 44 00
	00		 npad	 6
$LL113@PChatProc:
  003f0	8a 11		 mov	 dl, BYTE PTR [ecx]
  003f2	3a 10		 cmp	 dl, BYTE PTR [eax]
  003f4	75 1a		 jne	 SHORT $LN114@PChatProc
  003f6	84 d2		 test	 dl, dl
  003f8	74 12		 je	 SHORT $LN115@PChatProc
  003fa	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  003fd	3a 50 01	 cmp	 dl, BYTE PTR [eax+1]
  00400	75 0e		 jne	 SHORT $LN114@PChatProc
  00402	83 c1 02	 add	 ecx, 2
  00405	83 c0 02	 add	 eax, 2
  00408	84 d2		 test	 dl, dl
  0040a	75 e4		 jne	 SHORT $LL113@PChatProc
$LN115@PChatProc:
  0040c	33 c0		 xor	 eax, eax
  0040e	eb 05		 jmp	 SHORT $LN116@PChatProc
$LN114@PChatProc:
  00410	1b c0		 sbb	 eax, eax
  00412	83 c8 01	 or	 eax, 1
$LN116@PChatProc:
  00415	85 c0		 test	 eax, eax
  00417	75 18		 jne	 SHORT $LN121@PChatProc

; 1837 : 										{
; 1838 : 											DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  00419	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0041d	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR tv1042[ebp]
  00423	50		 push	 eax
  00424	57		 push	 edi
  00425	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  00428	50		 push	 eax
  00429	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0042e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN121@PChatProc:
  00431	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR tv1042[ebp]
$LN126@PChatProc:
  00437	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR tv1051[ebp]
$LN10@PChatProc:

; 1824 : 							continue;
; 1825 : 
; 1826 : 						for (n=0;n<MAX_USER_GUILD;n++)

  0043d	46		 inc	 esi
  0043e	83 c2 02	 add	 edx, 2
  00441	83 c3 0b	 add	 ebx, 11			; 0000000bH
  00444	89 95 60 fe ff
	ff		 mov	 DWORD PTR tv1042[ebp], edx
  0044a	83 fe 50	 cmp	 esi, 80			; 00000050H
  0044d	0f 8c 72 ff ff
	ff		 jl	 $LL12@PChatProc
$LN7@PChatProc:

; 1818 : 				{
; 1819 : 					for ( int i=0;i<iGuildCount;i++)

  00453	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  00459	40		 inc	 eax
  0045a	89 85 58 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  00460	3b 85 64 fe ff
	ff		 cmp	 eax, DWORD PTR _iGuildCount$1[ebp]
  00466	0f 8c 24 ff ff
	ff		 jl	 $LL9@PChatProc
$LN8@PChatProc:

; 1839 : 										}
; 1840 : 									}
; 1841 : 								}
; 1842 : 							}
; 1843 : 						}
; 1844 : 					}
; 1845 : 				}
; 1846 : 
; 1847 : 				if ( g_iServerGroupUnionChatting == TRUE )

  0046c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_iServerGroupUnionChatting@@3HA, 1 ; g_iServerGroupUnionChatting
  00473	0f 85 cc 02 00
	00		 jne	 $LN5@PChatProc

; 1848 : 					GDUnionServerGroupChattingSend(lpObj->lpGuild->iGuildUnion, lpChat);

  00479	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  0047f	57		 push	 edi
  00480	8b 80 18 06 00
	00		 mov	 eax, DWORD PTR [eax+1560]
  00486	ff b0 44 07 00
	00		 push	 DWORD PTR [eax+1860]
  0048c	e8 00 00 00 00	 call	 ?GDUnionServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z ; GDUnionServerGroupChattingSend
  00491	83 c4 08	 add	 esp, 8
  00494	5f		 pop	 edi
  00495	5e		 pop	 esi
  00496	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  00497	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0049a	33 cd		 xor	 ecx, ebp
  0049c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a1	8b e5		 mov	 esp, ebp
  004a3	5d		 pop	 ebp
  004a4	c3		 ret	 0
$LN46@PChatProc:
  004a5	8b 9d 68 fe ff
	ff		 mov	 ebx, DWORD PTR _lpObj$1$[ebp]

; 1849 : 			}
; 1850 : 			// Just Guild
; 1851 : 			else
; 1852 : 			{
; 1853 : 				int count = lpObj->lpGuild->Count;
; 1854 : 
; 1855 : 				if ( count >= 0 )
; 1856 : 				{
; 1857 : 					for ( n=0;n<MAX_USER_GUILD;n++)

  004ab	33 c9		 xor	 ecx, ecx
  004ad	33 d2		 xor	 edx, edx
  004af	89 8d 64 fe ff
	ff		 mov	 DWORD PTR _n$3$[ebp], ecx
  004b5	89 95 60 fe ff
	ff		 mov	 DWORD PTR tv1041[ebp], edx
  004bb	be a0 03 00 00	 mov	 esi, 928		; 000003a0H
$LL15@PChatProc:

; 1858 : 					{
; 1859 : 						if ( lpObj->lpGuild->Use[n] )

  004c0	8b 83 18 06 00
	00		 mov	 eax, DWORD PTR [ebx+1560]
  004c6	80 bc 08 40 04
	00 00 00	 cmp	 BYTE PTR [eax+ecx+1088], 0
  004ce	74 61		 je	 SHORT $LN13@PChatProc

; 1860 : 							{
; 1861 : 								number = lpObj->lpGuild->Index[n];

  004d0	0f bf 1c 30	 movsx	 ebx, WORD PTR [eax+esi]

; 1862 : 
; 1863 : 								if ( number >= 0 )

  004d4	85 db		 test	 ebx, ebx
  004d6	78 53		 js	 SHORT $LN124@PChatProc

; 1864 : 								{
; 1865 : 									if ( lpObj->lpGuild->Names[n][0] == gObj[number].Name[0] )

  004d8	69 cb 40 27 00
	00		 imul	 ecx, ebx, 10048
  004de	83 c0 2f	 add	 eax, 47			; 0000002fH
  004e1	03 d0		 add	 edx, eax
  004e3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  004e8	83 c1 5d	 add	 ecx, 93			; 0000005dH
  004eb	03 c8		 add	 ecx, eax
  004ed	8a 02		 mov	 al, BYTE PTR [edx]
  004ef	3a 01		 cmp	 al, BYTE PTR [ecx]
  004f1	75 38		 jne	 SHORT $LN124@PChatProc
$LL117@PChatProc:

; 1866 : 									{
; 1867 : 										if ( !strcmp(lpObj->lpGuild->Names[n], gObj[number].Name ) )

  004f3	8a 02		 mov	 al, BYTE PTR [edx]
  004f5	3a 01		 cmp	 al, BYTE PTR [ecx]
  004f7	75 1a		 jne	 SHORT $LN118@PChatProc
  004f9	84 c0		 test	 al, al
  004fb	74 12		 je	 SHORT $LN119@PChatProc
  004fd	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00500	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  00503	75 0e		 jne	 SHORT $LN118@PChatProc
  00505	83 c2 02	 add	 edx, 2
  00508	83 c1 02	 add	 ecx, 2
  0050b	84 c0		 test	 al, al
  0050d	75 e4		 jne	 SHORT $LL117@PChatProc
$LN119@PChatProc:
  0050f	33 c0		 xor	 eax, eax
  00511	eb 05		 jmp	 SHORT $LN120@PChatProc
$LN118@PChatProc:
  00513	1b c0		 sbb	 eax, eax
  00515	83 c8 01	 or	 eax, 1
$LN120@PChatProc:
  00518	85 c0		 test	 eax, eax
  0051a	75 0f		 jne	 SHORT $LN124@PChatProc

; 1868 : 										{
; 1869 : 											DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  0051c	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00520	50		 push	 eax
  00521	57		 push	 edi
  00522	53		 push	 ebx
  00523	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00528	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN124@PChatProc:
  0052b	8b 9d 68 fe ff
	ff		 mov	 ebx, DWORD PTR _lpObj$1$[ebp]
$LN13@PChatProc:

; 1849 : 			}
; 1850 : 			// Just Guild
; 1851 : 			else
; 1852 : 			{
; 1853 : 				int count = lpObj->lpGuild->Count;
; 1854 : 
; 1855 : 				if ( count >= 0 )
; 1856 : 				{
; 1857 : 					for ( n=0;n<MAX_USER_GUILD;n++)

  00531	ff 85 64 fe ff
	ff		 inc	 DWORD PTR _n$3$[ebp]
  00537	83 c6 02	 add	 esi, 2
  0053a	83 85 60 fe ff
	ff 0b		 add	 DWORD PTR tv1041[ebp], 11 ; 0000000bH
  00541	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _n$3$[ebp]
  00547	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR tv1041[ebp]
  0054d	81 fe 40 04 00
	00		 cmp	 esi, 1088		; 00000440H
  00553	0f 8c 67 ff ff
	ff		 jl	 $LL15@PChatProc

; 1870 : 										}
; 1871 : 									}
; 1872 : 								}
; 1873 : 							}
; 1874 : 						}
; 1875 : 				}
; 1876 : 
; 1877 : 				if ( g_iServerGroupGuildChatting == TRUE )

  00559	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_iServerGroupGuildChatting@@3HA, 1 ; g_iServerGroupGuildChatting
  00560	0f 85 df 01 00
	00		 jne	 $LN5@PChatProc

; 1878 : 				{
; 1879 : 					if ( lpObj->lpGuild->Count > 1 )

  00566	8b 83 18 06 00
	00		 mov	 eax, DWORD PTR [ebx+1560]
  0056c	80 78 2d 01	 cmp	 BYTE PTR [eax+45], 1
  00570	0f 86 cf 01 00
	00		 jbe	 $LN5@PChatProc

; 1880 : 					{
; 1881 : 						GDGuildServerGroupChattingSend(lpObj->lpGuild->Number, lpChat);

  00576	57		 push	 edi
  00577	ff 30		 push	 DWORD PTR [eax]
  00579	e8 00 00 00 00	 call	 ?GDGuildServerGroupChattingSend@@YAXHPAUPMSG_CHATDATA@@@Z ; GDGuildServerGroupChattingSend
  0057e	83 c4 08	 add	 esp, 8
  00581	5f		 pop	 edi
  00582	5e		 pop	 esi
  00583	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  00584	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00587	33 cd		 xor	 ecx, ebp
  00589	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0058e	8b e5		 mov	 esp, ebp
  00590	5d		 pop	 ebp
  00591	c3		 ret	 0
$LN39@PChatProc:

; 1882 : 					}
; 1883 : 				}
; 1884 : 			}
; 1885 : 		}
; 1886 : 	}
; 1887 : #if (CUSTOM_OLYMP==1)
; 1888 : 	else if( lpChat->chatmsg[0] == '$' )
; 1889 : 	{
; 1890 : 		if( gObjCheckUsedBuffEffect(lpObj,BUFF_GLADIATOR_HONOR) )
; 1891 : 		{
; 1892 : 			for(int  n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)
; 1893 : 			{
; 1894 : 				if( gObj[n].Connected < 3 )
; 1895 : 					continue;
; 1896 : 
; 1897 : 				DataSend(n, (LPBYTE)lpChat, lpChat->h.size);
; 1898 : 			}
; 1899 : 
; 1900 : 			if ( gWriteChatLog )
; 1901 : 			{
; 1902 : 				memcpy(pChatMsg.szChatMsg, &lpChat->chatmsg[1], MAX_CHAT_LEN-1);
; 1903 : 				pChatMsg.szChatMsg[MAX_CHAT_LEN] = 0;
; 1904 : 				pChatMsg.btType = 0x06;
; 1905 : 			}
; 1906 : 		}
; 1907 : 		else
; 1908 : 		{
; 1909 : 			MsgOutput(lpObj->m_Index,"Only heroes can use this !");
; 1910 : 		}
; 1911 : 	}
; 1912 : #endif
; 1913 : #if(__GENS_SYSTEM__ == 1)
; 1914 : 	else if( lpChat->chatmsg[0] == '$' )

  00592	3c 24		 cmp	 al, 36			; 00000024H
  00594	0f 85 a6 00 00
	00		 jne	 $LN62@PChatProc

; 1915 : 	{
; 1916 : 		if( lpObj->Money < gGensSystem.GetChatPrice() )

  0059a	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  005a0	8b 0d 34 00 00
	00		 mov	 ecx, DWORD PTR ?gGensSystem@@3VCGensSystem@@A+52
  005a6	3b c1		 cmp	 eax, ecx
  005a8	7d 20		 jge	 SHORT $LN64@PChatProc

; 1917 : 		{
; 1918 : 			MsgOutput(lpObj->m_Index, "Need more zen for gens chat");

  005aa	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KJGOCGNH@Need?5more?5zen?5for?5gens?5chat?$AA@
  005af	ff 36		 push	 DWORD PTR [esi]
  005b1	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  005b6	83 c4 08	 add	 esp, 8
  005b9	5f		 pop	 edi
  005ba	5e		 pop	 esi
  005bb	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  005bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005bf	33 cd		 xor	 ecx, ebp
  005c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005c6	8b e5		 mov	 esp, ebp
  005c8	5d		 pop	 ebp
  005c9	c3		 ret	 0
$LN64@PChatProc:

; 1919 : 			return;
; 1920 : 		}
; 1921 : 
; 1922 : 		lpObj->Money -= gGensSystem.GetChatPrice();

  005ca	2b c1		 sub	 eax, ecx

; 1923 : 		GCMoneySend(lpObj->m_Index, lpObj->Money);

  005cc	50		 push	 eax
  005cd	ff 36		 push	 DWORD PTR [esi]
  005cf	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  005d5	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  005da	83 c4 08	 add	 esp, 8

; 1924 : 
; 1925 : 		for(int  n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)

  005dd	bb 04 29 00 00	 mov	 ebx, 10500		; 00002904H
  005e2	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
  005e7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@PChatProc:

; 1926 : 		{
; 1927 : 			if( gObj[n].Connected < 3 )

  005f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  005f5	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  005fa	7c 24		 jl	 SHORT $LN16@PChatProc

; 1928 : 				continue;
; 1929 : 
; 1930 : 			if( gObj[n].m_GensInfo.btFamily == lpObj->m_GensInfo.btFamily )

  005fc	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$1$[ebp]
  00602	8a 84 06 ac 26
	00 00		 mov	 al, BYTE PTR [esi+eax+9900]
  00609	3a 81 ac 26 00
	00		 cmp	 al, BYTE PTR [ecx+9900]
  0060f	75 0f		 jne	 SHORT $LN16@PChatProc

; 1931 : 			{
; 1932 : 				DataSend(n, (LPBYTE)lpChat, lpChat->h.size);

  00611	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00615	50		 push	 eax
  00616	57		 push	 edi
  00617	53		 push	 ebx
  00618	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0061d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@PChatProc:

; 1924 : 
; 1925 : 		for(int  n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)

  00620	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00626	43		 inc	 ebx
  00627	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  0062d	7c c1		 jl	 SHORT $LL18@PChatProc
  0062f	5f		 pop	 edi
  00630	5e		 pop	 esi
  00631	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  00632	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00635	33 cd		 xor	 ecx, ebp
  00637	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0063c	8b e5		 mov	 esp, ebp
  0063e	5d		 pop	 ebp
  0063f	c3		 ret	 0
$LN62@PChatProc:

; 1933 : 			}
; 1934 : 		}
; 1935 : 	}
; 1936 : #else
; 1937 : #if (CUSTOM_OLYMP==0)
; 1938 : 	else if( lpChat->chatmsg[0] == '$' )
; 1939 : 	{
; 1940 : 		MsgOutput(lpObj->m_Index,"Gens system is disabled!");
; 1941 : 	}
; 1942 : #endif
; 1943 : #endif
; 1944 : 	else
; 1945 : 	{
; 1946 : #if (__CUSTOM__ == 1)
; 1947 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);

  00640	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00644	50		 push	 eax
  00645	57		 push	 edi
  00646	ff b5 64 fe ff
	ff		 push	 DWORD PTR tv1072[ebp]
  0064c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00651	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1948 : 
; 1949 : 		if( lpObj->MapNumber == MAP_INDEX_PKFIELD && lpObj->m_iDuelUser == -1 )

  00654	80 be 23 01 00
	00 40		 cmp	 BYTE PTR [esi+291], 64	; 00000040H
  0065b	75 73		 jne	 SHORT $LN67@PChatProc
  0065d	83 be 50 12 00
	00 ff		 cmp	 DWORD PTR [esi+4688], -1
  00664	75 6a		 jne	 SHORT $LN67@PChatProc

; 1950 : 		{
; 1951 : 			for ( int n=0;n<MAX_VIEWPORT;n++)

  00666	81 c6 48 0c 00
	00		 add	 esi, 3144		; 00000c48H
  0066c	bb 4b 00 00 00	 mov	 ebx, 75			; 0000004bH
$LL21@PChatProc:

; 1952 : 			{
; 1953 : 				if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  00671	80 7e 04 01	 cmp	 BYTE PTR [esi+4], 1
  00675	75 40		 jne	 SHORT $LN19@PChatProc

; 1954 : 				{
; 1955 : 					if ( lpObj->VpPlayer2[n].state != 0 )

  00677	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0067a	74 3b		 je	 SHORT $LN19@PChatProc

; 1956 : 					{
; 1957 : 						int number = lpObj->VpPlayer2[n].number;

  0067c	0f bf 56 02	 movsx	 edx, WORD PTR [esi+2]

; 1958 : 	
; 1959 : 						if( OBJMAX_RANGE(number) )

  00680	85 d2		 test	 edx, edx
  00682	78 33		 js	 SHORT $LN19@PChatProc
  00684	33 c0		 xor	 eax, eax
  00686	81 fa eb 2c 00
	00		 cmp	 edx, 11499		; 00002cebH
  0068c	0f 9e c0	 setle	 al
  0068f	85 c0		 test	 eax, eax
  00691	74 24		 je	 SHORT $LN19@PChatProc

; 1960 : 						{
; 1961 : 							if( gObj[number].m_iDuelUser != -1 )

  00693	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00698	69 ca 40 27 00
	00		 imul	 ecx, edx, 10048
  0069e	83 bc 01 50 12
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+4688], -1
  006a6	75 0f		 jne	 SHORT $LN19@PChatProc

; 1962 : 							{
; 1963 : 								continue;
; 1964 : 							}
; 1965 : 	
; 1966 : 							DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  006a8	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  006ac	50		 push	 eax
  006ad	57		 push	 edi
  006ae	52		 push	 edx
  006af	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  006b4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@PChatProc:

; 1950 : 		{
; 1951 : 			for ( int n=0;n<MAX_VIEWPORT;n++)

  006b7	83 c6 0c	 add	 esi, 12			; 0000000cH
  006ba	83 eb 01	 sub	 ebx, 1
  006bd	75 b2		 jne	 SHORT $LL21@PChatProc
  006bf	5f		 pop	 edi
  006c0	5e		 pop	 esi
  006c1	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  006c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006c5	33 cd		 xor	 ecx, ebp
  006c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006cc	8b e5		 mov	 esp, ebp
  006ce	5d		 pop	 ebp
  006cf	c3		 ret	 0
$LN67@PChatProc:

; 1967 : 						}
; 1968 : 					}
; 1969 : 				}
; 1970 : 			}
; 1971 : 		}
; 1972 : 		else
; 1973 : 		{
; 1974 : 			MsgSendV2(lpObj,(LPBYTE)lpChat,lpChat->h.size);

  006d0	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  006d4	50		 push	 eax
  006d5	57		 push	 edi
  006d6	56		 push	 esi
  006d7	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  006dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  006df	5f		 pop	 edi
  006e0	5e		 pop	 esi
  006e1	5b		 pop	 ebx

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  006e2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006e5	33 cd		 xor	 ecx, ebp
  006e7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006ec	8b e5		 mov	 esp, ebp
  006ee	5d		 pop	 ebp
  006ef	c3		 ret	 0
$LN35@PChatProc:

; 1775 : 	{
; 1776 : 		if ( lpObj->PartyNumber >= 0 )

  006f0	8b 86 0c 06 00
	00		 mov	 eax, DWORD PTR [esi+1548]
  006f6	85 c0		 test	 eax, eax
  006f8	78 4b		 js	 SHORT $LN5@PChatProc

; 1777 : 		{
; 1778 : 			int partycount = gParty.GetPartyCount(lpObj->PartyNumber);

  006fa	50		 push	 eax
  006fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00700	e8 00 00 00 00	 call	 ?GetPartyCount@PartyClass@@QAEHH@Z ; PartyClass::GetPartyCount

; 1779 : 
; 1780 : 			if ( partycount >= 0 )

  00705	85 c0		 test	 eax, eax
  00707	78 3c		 js	 SHORT $LN5@PChatProc

; 1781 : 			{
; 1782 : 				for (n=0;n<MAX_USER_IN_PARTY;n++ )

  00709	33 f6		 xor	 esi, esi
  0070b	0f 1f 44 00 00	 npad	 5
$LL6@PChatProc:

; 1783 : 				{
; 1784 : 					number = gParty.m_PartyS[lpObj->PartyNumber].Number[n];

  00710	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$1$[ebp]
  00716	8b 80 0c 06 00
	00		 mov	 eax, DWORD PTR [eax+1548]
  0071c	8b c8		 mov	 ecx, eax
  0071e	c1 e1 04	 shl	 ecx, 4
  00721	2b c8		 sub	 ecx, eax
  00723	03 ce		 add	 ecx, esi
  00725	8b 0c 8d 0c 00
	00 00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[ecx*4+12]

; 1785 : 
; 1786 : 					if ( number >= 0 )

  0072c	85 c9		 test	 ecx, ecx
  0072e	78 0f		 js	 SHORT $LN4@PChatProc

; 1787 : 					{
; 1788 : 						DataSend(number, (LPBYTE)lpChat, lpChat->h.size);

  00730	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  00734	50		 push	 eax
  00735	57		 push	 edi
  00736	51		 push	 ecx
  00737	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0073c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@PChatProc:

; 1781 : 			{
; 1782 : 				for (n=0;n<MAX_USER_IN_PARTY;n++ )

  0073f	46		 inc	 esi
  00740	83 fe 05	 cmp	 esi, 5
  00743	7c cb		 jl	 SHORT $LL6@PChatProc
$LN5@PChatProc:

; 1975 : 		}
; 1976 : #else
; 1977 : 		DataSend(aIndex, (LPBYTE)lpChat, lpChat->h.size);
; 1978 : 		MsgSendV2(lpObj, (LPBYTE)lpChat, lpChat->h.size);
; 1979 : #endif
; 1980 : 	}
; 1981 : }							

  00745	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00748	5f		 pop	 edi
  00749	5e		 pop	 esi
  0074a	33 cd		 xor	 ecx, ebp
  0074c	5b		 pop	 ebx
  0074d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00752	8b e5		 mov	 esp, ebp
  00754	5d		 pop	 ebp
  00755	c3		 ret	 0
?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z ENDP		; PChatProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z
_TEXT	SEGMENT
_pMsg$ = -112						; size = 105
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
_senduser$ = 16						; size = 4
?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z PROC	; ChatTargetSend, COMDAT

; 1668 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00014	56		 push	 esi
  00015	8b 75 0c	 mov	 esi, DWORD PTR _szChat$[ebp]
  00018	57		 push	 edi

; 1669 : 	int len = strlen(szChat);

  00019	8b fe		 mov	 edi, esi
  0001b	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0001e	66 90		 npad	 2
$LL9@ChatTarget:
  00020	8a 07		 mov	 al, BYTE PTR [edi]
  00022	47		 inc	 edi
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL9@ChatTarget
  00027	2b f9		 sub	 edi, ecx

; 1670 : 
; 1671 : 	if ( len < 1 || len > MAX_CHAT_LEN-1)

  00029	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  0002c	83 f8 58	 cmp	 eax, 88			; 00000058H
  0002f	77 52		 ja	 SHORT $LN3@ChatTarget

; 1672 : 		return;
; 1673 : 
; 1674 : 	/*char szTempMsg[4096] = {0};
; 1675 : 	MultiByteToWideChar(1258, 0, szChat, len, (unsigned short*)szTempMsg, sizeof(szTempMsg));
; 1676 : 	memcpy(&pMsg.szChatMsg, szTempMsg, sizeof(pMsg.szChatMsg));
; 1677 : 	pMsg.szChatMsg[MAX_CHAT_LEN-2]=0;
; 1678 : 	pMsg.szChatMsg[MAX_CHAT_LEN-1]=0;
; 1679 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, wcslen((unsigned short*)pMsg.szChatMsg)*2 + (sizeof(GC_CHATSEND)-sizeof(pMsg.szChatMsg)));
; 1680 : 	pMsg.sIndex[0] = lpObj->m_Index >> 8;
; 1681 : 	pMsg.sIndex[1] = lpObj->m_Index & 0xFF;*/
; 1682 : 
; 1683 : 	PMSG_CHATDATA_NUMBER pMsg;
; 1684 : 
; 1685 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, len+6);

  00031	8d 47 06	 lea	 eax, DWORD PTR [edi+6]
  00034	50		 push	 eax
  00035	8d 45 90	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00038	6a 01		 push	 1
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1686 : 	strcpy(pMsg.chatmsg, szChat);

  00040	8d 4d 95	 lea	 ecx, DWORD PTR _pMsg$[ebp+5]
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	2b ce		 sub	 ecx, esi
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@ChatTarget:
  00050	8a 06		 mov	 al, BYTE PTR [esi]
  00052	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00055	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  00059	84 c0		 test	 al, al
  0005b	75 f3		 jne	 SHORT $LL5@ChatTarget

; 1687 : 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0005d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0005f	c1 e8 08	 shr	 eax, 8
  00062	88 45 93	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 1688 : 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);

  00065	8a 03		 mov	 al, BYTE PTR [ebx]
  00067	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 1689 : 	pMsg.chatmsg[len+1] = 0;

  0006a	c6 44 3d 96 00	 mov	 BYTE PTR _pMsg$[ebp+edi+6], 0

; 1690 : 
; 1691 : 	DataSend(senduser, (UCHAR*)&pMsg, pMsg.h.size);

  0006f	0f b6 45 91	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00073	50		 push	 eax
  00074	8d 45 90	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00077	50		 push	 eax
  00078	ff 75 10	 push	 DWORD PTR _senduser$[ebp]
  0007b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@ChatTarget:

; 1692 : }

  00083	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	33 cd		 xor	 ecx, ebp
  0008a	5b		 pop	 ebx
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?ChatTargetSend@@YAXPAUOBJECTSTRUCT@@PADH@Z ENDP	; ChatTargetSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?DataSendAll@@YAXPAEH@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_iMsgSize$ = 12						; size = 4
?DataSendAll@@YAXPAEH@Z PROC				; DataSendAll, COMDAT

; 1649 : {			

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1650 : 	for ( int n = OBJ_STARTUSERINDEX ; n < OBJMAX ; n++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _iMsgSize$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  0000e	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL4@DataSendAl:

; 1651 : 	{
; 1652 : 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00018	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0001d	75 14		 jne	 SHORT $LN2@DataSendAl

; 1653 : 		{
; 1654 : 			if ( gObj[n].Type == OBJ_USER )

  0001f	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00024	75 0d		 jne	 SHORT $LN2@DataSendAl

; 1655 : 			{
; 1656 : 				DataSend(n, (unsigned char*)lpMsg , iMsgSize );

  00026	53		 push	 ebx
  00027	ff 75 08	 push	 DWORD PTR _lpMsg$[ebp]
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@DataSendAl:

; 1650 : 	for ( int n = OBJ_STARTUSERINDEX ; n < OBJMAX ; n++)

  00033	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00039	47		 inc	 edi
  0003a	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00040	7c d1		 jl	 SHORT $LL4@DataSendAl
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 1657 : 			}
; 1658 : 		}
; 1659 : 	}
; 1660 : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?DataSendAll@@YAXPAEH@Z ENDP				; DataSendAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?AllSendServerMsg@@YAXPAD@Z
_TEXT	SEGMENT
_pNotice$ = -276					; size = 272
__$ArrayPad$ = -4					; size = 4
_chatmsg$ = 8						; size = 4
?AllSendServerMsg@@YAXPAD@Z PROC			; AllSendServerMsg, COMDAT

; 1627 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _chatmsg$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi

; 1628 : 	PMSG_NOTICE pNotice;
; 1629 : 	
; 1630 : 	TNotice::MakeNoticeMsg((TNotice*)&pNotice, 0x00,  chatmsg);

  00018	50		 push	 eax
  00019	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  0001f	6a 00		 push	 0
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?MakeNoticeMsg@TNotice@@SAXPAXEPAD@Z ; TNotice::MakeNoticeMsg
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1631 : 
; 1632 : 	for ( int n = OBJ_STARTUSERINDEX ; n < OBJMAX ; n++)

  0002a	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  0002f	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL4@AllSendSer:

; 1633 : 	{
; 1634 : 		if ( gObj[n].Connected == PLAYER_PLAYING )

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00039	83 7c 06 04 03	 cmp	 DWORD PTR [esi+eax+4], 3
  0003e	75 1f		 jne	 SHORT $LN2@AllSendSer

; 1635 : 		{
; 1636 : 			if ( gObj[n].Type == OBJ_USER )

  00040	80 7c 06 50 01	 cmp	 BYTE PTR [esi+eax+80], 1
  00045	75 18		 jne	 SHORT $LN2@AllSendSer

; 1637 : 			{
; 1638 : 				DataSend(n, (unsigned char*)&pNotice , pNotice.h.size );

  00047	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$[ebp+1]
  0004e	50		 push	 eax
  0004f	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$[ebp]
  00055	50		 push	 eax
  00056	57		 push	 edi
  00057	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@AllSendSer:

; 1631 : 
; 1632 : 	for ( int n = OBJ_STARTUSERINDEX ; n < OBJMAX ; n++)

  0005f	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00065	47		 inc	 edi
  00066	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  0006c	7c c6		 jl	 SHORT $LL4@AllSendSer

; 1639 : 			}
; 1640 : 		}
; 1641 : 	}
; 1642 : }

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	5f		 pop	 edi
  00072	33 cd		 xor	 ecx, ebp
  00074	5e		 pop	 esi
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?AllSendServerMsg@@YAXPAD@Z ENDP			; AllSendServerMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ
_TEXT	SEGMENT
_pMsg$ = -368						; size = 105
_szBuffer$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ PROC		; vChatSend, COMDAT

; 1585 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 70 01 00
	00		 sub	 esp, 368		; 00000170H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00017	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0001d	68 00 01 00 00	 push	 256			; 00000100H
  00022	6a 00		 push	 0
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _memset
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1386 :     int const _Result = __stdio_common_vsprintf(

  0002d	8d 45 10	 lea	 eax, DWORD PTR _szChat$[ebp+4]
  00030	50		 push	 eax
  00031	6a 00		 push	 0
  00033	ff 75 0c	 push	 DWORD PTR _szChat$[ebp]
  00036	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0003c	6a ff		 push	 -1
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	ff 70 04	 push	 DWORD PTR [eax+4]
  00049	83 c9 01	 or	 ecx, 1
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 1593 : 	int len = strlen(szBuffer);

  00052	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szBuffer$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00058	83 c4 1c	 add	 esp, 28			; 0000001cH
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp

; 1593 : 	int len = strlen(szBuffer);

  0005b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0005e	66 90		 npad	 2
$LL13@vChatSend:
  00060	8a 01		 mov	 al, BYTE PTR [ecx]
  00062	41		 inc	 ecx
  00063	84 c0		 test	 al, al
  00065	75 f9		 jne	 SHORT $LL13@vChatSend
  00067	2b ca		 sub	 ecx, edx

; 1594 : 
; 1595 : 	if ( len < 1 )

  00069	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0006c	83 f8 58	 cmp	 eax, 88			; 00000058H
  0006f	77 5f		 ja	 SHORT $LN1@vChatSend

; 1596 : 		return;
; 1597 : 
; 1598 : 	if ( len > MAX_CHAT_LEN-1 )
; 1599 : 		return;
; 1600 : 
; 1601 : /*	char szTempMsg[4096] = {0};
; 1602 : 	MultiByteToWideChar(1258, 0, szChat, len, (unsigned short*)szTempMsg, sizeof(szTempMsg));
; 1603 : 	memcpy(&pMsg.szChatMsg, szTempMsg, sizeof(pMsg.szChatMsg));
; 1604 : 	pMsg.szChatMsg[MAX_CHAT_LEN-2]=0;
; 1605 : 	pMsg.szChatMsg[MAX_CHAT_LEN-1]=0;
; 1606 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, wcslen((unsigned short*)pMsg.szChatMsg)*2 + (sizeof(GC_CHATSEND)-sizeof(pMsg.szChatMsg)));
; 1607 : 	pMsg.sIndex[0] = lpObj->m_Index >> 8;
; 1608 : 	pMsg.sIndex[1] = lpObj->m_Index & 0xFF;*/
; 1609 : 
; 1610 : 	PMSG_CHATDATA_NUMBER pMsg;
; 1611 : 
; 1612 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, len+6);

  00071	8d 41 06	 lea	 eax, DWORD PTR [ecx+6]
  00074	50		 push	 eax
  00075	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0007b	6a 01		 push	 1
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 : 	strcpy(pMsg.chatmsg, szBuffer);

  00086	33 c0		 xor	 eax, eax
  00088	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@vChatSend:
  00090	8a 8c 05 fc fe
	ff ff		 mov	 cl, BYTE PTR _szBuffer$[ebp+eax]
  00097	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  0009a	88 8c 05 94 fe
	ff ff		 mov	 BYTE PTR _pMsg$[ebp+eax+4], cl
  000a1	84 c9		 test	 cl, cl
  000a3	75 eb		 jne	 SHORT $LL5@vChatSend

; 1614 : 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	c1 e8 08	 shr	 eax, 8
  000aa	88 85 93 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+3], al

; 1615 : 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);

  000b0	8a 06		 mov	 al, BYTE PTR [esi]
  000b2	88 85 94 fe ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+4], al

; 1616 : 
; 1617 : 	MsgSendV2(lpObj, (UCHAR*)&pMsg, pMsg.h.size);

  000b8	0f b6 85 91 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000bf	50		 push	 eax
  000c0	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  000c6	50		 push	 eax
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@vChatSend:

; 1618 : }

  000d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d3	33 cd		 xor	 ecx, ebp
  000d5	5e		 pop	 esi
  000d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
?vChatSend@@YAXPAUOBJECTSTRUCT@@PADZZ ENDP		; vChatSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z
_TEXT	SEGMENT
_pMsg$ = -112						; size = 105
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_szChat$ = 12						; size = 4
?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z PROC		; ChatSend, COMDAT

; 1552 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 0c	 mov	 esi, DWORD PTR _szChat$[ebp]

; 1553 : 	int len = strlen(szChat);

  00014	8b ce		 mov	 ecx, esi
  00016	57		 push	 edi
  00017	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001a	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0001d	0f 1f 00	 npad	 3
$LL9@ChatSend:
  00020	8a 01		 mov	 al, BYTE PTR [ecx]
  00022	41		 inc	 ecx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL9@ChatSend
  00027	2b ca		 sub	 ecx, edx

; 1554 : 
; 1555 : 	if ( len < 1 )

  00029	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0002c	83 f8 58	 cmp	 eax, 88			; 00000058H
  0002f	77 4b		 ja	 SHORT $LN1@ChatSend

; 1556 : 		return;
; 1557 : 
; 1558 : 	if ( len > MAX_CHAT_LEN-1 )
; 1559 : 		return;
; 1560 : 
; 1561 : /*	char szTempMsg[4096] = {0};
; 1562 : 	MultiByteToWideChar(1258, 0, szChat, len, (unsigned short *)szTempMsg, sizeof(szTempMsg));
; 1563 : 	memcpy(&pMsg.szChatMsg, szTempMsg, sizeof(pMsg.szChatMsg));
; 1564 : 	pMsg.szChatMsg[MAX_CHAT_LEN-2]=0;
; 1565 : 	pMsg.szChatMsg[MAX_CHAT_LEN-1]=0;
; 1566 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, wcslen((unsigned short*)pMsg.szChatMsg)*2 + (sizeof(GC_CHATSEND)-sizeof(pMsg.szChatMsg)));
; 1567 : 	pMsg.sIndex[0] = lpObj->m_Index >> 8;
; 1568 : 	pMsg.sIndex[1] = lpObj->m_Index & 0xFF;*/
; 1569 : 
; 1570 : 	PMSG_CHATDATA_NUMBER pMsg;
; 1571 : 
; 1572 : 	PHeadSetB((LPBYTE)&pMsg, 0x01, len+6);

  00031	8d 41 06	 lea	 eax, DWORD PTR [ecx+6]
  00034	50		 push	 eax
  00035	8d 45 90	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00038	6a 01		 push	 1
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1573 : 	strcpy(pMsg.chatmsg, szChat);

  00040	8d 4d 95	 lea	 ecx, DWORD PTR _pMsg$[ebp+5]
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	2b ce		 sub	 ecx, esi
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@ChatSend:
  00050	8a 06		 mov	 al, BYTE PTR [esi]
  00052	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00055	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  00059	84 c0		 test	 al, al
  0005b	75 f3		 jne	 SHORT $LL5@ChatSend

; 1574 : 	pMsg.NumberH = SET_NUMBERH(lpObj->m_Index);

  0005d	8b 07		 mov	 eax, DWORD PTR [edi]
  0005f	c1 e8 08	 shr	 eax, 8
  00062	88 45 93	 mov	 BYTE PTR _pMsg$[ebp+3], al

; 1575 : 	pMsg.NumberL = SET_NUMBERL(lpObj->m_Index);

  00065	8a 07		 mov	 al, BYTE PTR [edi]
  00067	88 45 94	 mov	 BYTE PTR _pMsg$[ebp+4], al

; 1576 : 
; 1577 : 	MsgSendV2(lpObj, (UCHAR*)&pMsg, pMsg.h.size);

  0006a	0f b6 45 91	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0006e	50		 push	 eax
  0006f	8d 45 90	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00072	50		 push	 eax
  00073	57		 push	 edi
  00074	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ChatSend:

; 1578 : }

  0007c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007f	5f		 pop	 edi
  00080	33 cd		 xor	 ecx, ebp
  00082	5e		 pop	 esi
  00083	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z ENDP		; ChatSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCResultSend@@YAXHEE@Z
_TEXT	SEGMENT
_pResult$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_headcode$ = 12						; size = 1
_result$ = 16						; size = 1
?GCResultSend@@YAXHEE@Z PROC				; GCResultSend, COMDAT

; 1539 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1540 : 	PMSG_DEFRESULT pResult;
; 1541 : 
; 1542 : 	PHeadSetB((LPBYTE)&pResult, headcode, sizeof(pResult));

  00004	6a 04		 push	 4
  00006	ff 75 0c	 push	 DWORD PTR _headcode$[ebp]
  00009	8d 45 fc	 lea	 eax, DWORD PTR _pResult$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1543 : 	pResult.result = result;

  00012	8a 45 10	 mov	 al, BYTE PTR _result$[ebp]
  00015	88 45 ff	 mov	 BYTE PTR _pResult$[ebp+3], al

; 1544 : 	
; 1545 : 	DataSend(aIndex, (UCHAR*)&pResult, pResult.h.size);

  00018	0f b6 45 fd	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0001c	50		 push	 eax
  0001d	8d 45 fc	 lea	 eax, DWORD PTR _pResult$[ebp]
  00020	50		 push	 eax
  00021	ff 75 08	 push	 DWORD PTR _aIndex$[ebp]
  00024	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00029	83 c4 18	 add	 esp, 24			; 00000018H

; 1546 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GCResultSend@@YAXHEE@Z ENDP				; GCResultSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?PEchoProc@@YAXPAEHF@Z
_TEXT	SEGMENT
_aMsg$ = 8						; size = 4
_aLen$ = 12						; size = 4
_aIndex$ = 16						; size = 2
?PEchoProc@@YAXPAEHF@Z PROC				; PEchoProc, COMDAT

; 1519 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1520 : 	for ( int n = 0 ; n< OBJMAX ; n++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _aLen$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	33 f6		 xor	 esi, esi
  0000d	0f 1f 00	 npad	 3
$LL4@PEchoProc:

; 1521 : 	{
; 1522 : 		if ( gObj[n].Connected >= PLAYER_CONNECTED )

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00015	83 7c 06 04 01	 cmp	 DWORD PTR [esi+eax+4], 1
  0001a	7c 0d		 jl	 SHORT $LN2@PEchoProc

; 1523 : 		{
; 1524 : 			DataSend(n, aMsg, aLen);

  0001c	53		 push	 ebx
  0001d	ff 75 08	 push	 DWORD PTR _aMsg$[ebp]
  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@PEchoProc:

; 1520 : 	for ( int n = 0 ; n< OBJMAX ; n++)

  00029	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  0002f	47		 inc	 edi
  00030	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  00036	7c d8		 jl	 SHORT $LL4@PEchoProc
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx

; 1525 : 		}
; 1526 : 	}
; 1527 : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?PEchoProc@@YAXPAEHF@Z ENDP				; PEchoProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z PROC ; CGCheckMainRecv, COMDAT

; 1483 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1484 : 	/*if ( strcmp(gObj[aIndex].Ip_addr, "89.28.120.69") == 0 )	// #warning To Prevent HAckrs
; 1485 : 	{
; 1486 : 		gObj[aIndex].CheckSumTime = 0;
; 1487 : 		gObj[aIndex].m_InWebzen = true;
; 1488 : 		return;
; 1489 : 	}*/
; 1490 : 
; 1491 : 	gObj[aIndex].CheckSumTime = 0;

  00003	69 4d 0c 40 27
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 10048
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000f	c7 44 01 4c 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+76], 0

; 1492 : 	return;
; 1493 : 
; 1494 : 	if ( gObj[aIndex].CheckSumTableNum < 0 || gObj[aIndex].CheckSumTableNum > MAX_CHECKSUM_KEY-1 )
; 1495 : 	{
; 1496 : 		LogAdd("error-L1 : [%s][%s] CheckSum-Exe error ", gObj[aIndex].AccountID, gObj[aIndex].Name);
; 1497 : 		CloseClient(aIndex);
; 1498 : 		return;
; 1499 : 	}
; 1500 : 
; 1501 : 	if ( dwgCheckSum[gObj[aIndex].CheckSumTableNum] != lpMsg->m_dwKey)
; 1502 : 	{
; 1503 : 		LogAddTD("error-L1 : CheckSum-Exe error %d %d %d [%s]", dwgCheckSum[gObj[aIndex].CheckSumTableNum],
; 1504 : 			lpMsg->m_dwKey, gObj[aIndex].CheckSumTableNum, gObj[aIndex].AccountID);
; 1505 : 		CloseClient(aIndex);
; 1506 : 		return;
; 1507 : 	}
; 1508 : 
; 1509 : 	gObj[aIndex].CheckSumTime = 0;
; 1510 : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ENDP ; CGCheckMainRecv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?EncryptCheckSumKey@@YAGG@Z
_TEXT	SEGMENT
_wSource$ = 8						; size = 2
?EncryptCheckSumKey@@YAGG@Z PROC			; EncryptCheckSumKey, COMDAT

; 1471 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1472 : 	WORD wRandom = rand() % 64;

  00003	e8 00 00 00 00	 call	 _rand
  00008	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  0000d	79 05		 jns	 SHORT $LN3@EncryptChe
  0000f	48		 dec	 eax
  00010	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00013	40		 inc	 eax
$LN3@EncryptChe:

; 1473 : 	WORD wAcc = ((wSource & 0x3F0) * 64) | (wRandom *16) | (wSource & 0x0F);

  00014	8b 55 08	 mov	 edx, DWORD PTR _wSource$[ebp]
  00017	8b ca		 mov	 ecx, edx
  00019	81 e1 f0 03 00
	00		 and	 ecx, 1008		; 000003f0H
  0001f	c1 e0 04	 shl	 eax, 4
  00022	c1 e1 06	 shl	 ecx, 6
  00025	83 e2 0f	 and	 edx, 15			; 0000000fH
  00028	0b c1		 or	 eax, ecx
  0002a	0b c2		 or	 eax, edx

; 1474 : 	return wAcc ^ 0xB479;

  0002c	35 79 b4 00 00	 xor	 eax, 46201		; 0000b479H

; 1475 : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?EncryptCheckSumKey@@YAGG@Z ENDP			; EncryptCheckSumKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?GCCheckMainExeKeySend@@YAXH@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
_aIndex$ = 8						; size = 4
?GCCheckMainExeKeySend@@YAXH@Z PROC			; GCCheckMainExeKeySend, COMDAT

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1454 : 	PMSG_CHECK_MAINEXE pMsg;
; 1455 : 
; 1456 : 	gObj[aIndex].CheckSumTableNum = rand() % MAX_CHECKSUM_KEY;

  00008	8b 7d 08	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0000b	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00011	e8 00 00 00 00	 call	 _rand
  00016	25 ff 03 00 80	 and	 eax, -2147482625	; 800003ffH
  0001b	79 07		 jns	 SHORT $LN3@GCCheckMai
  0001d	48		 dec	 eax
  0001e	0d 00 fc ff ff	 or	 eax, -1024		; fffffc00H
  00023	40		 inc	 eax
$LN3@GCCheckMai:
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002a	66 89 44 0e 48	 mov	 WORD PTR [esi+ecx+72], ax

; 1457 : 	gObj[aIndex].CheckSumTime = GetTickCount();

  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1458 : 	PHeadSetB((LPBYTE)&pMsg, 0x03, sizeof(pMsg));

  0003b	6a 06		 push	 6
  0003d	6a 03		 push	 3
  0003f	89 44 0e 4c	 mov	 DWORD PTR [esi+ecx+76], eax
  00043	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1459 : 	pMsg.m_wKey = EncryptCheckSumKey(gObj[aIndex].CheckSumTableNum);

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00051	0f b7 44 06 48	 movzx	 eax, WORD PTR [esi+eax+72]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?EncryptCheckSumKey@@YAGG@Z ; EncryptCheckSumKey
  0005c	66 89 45 fc	 mov	 WORD PTR _pMsg$[ebp+4], ax

; 1460 : 
; 1461 : 	DataSend(aIndex, (UCHAR*)&pMsg, pMsg.h.size);

  00060	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00064	50		 push	 eax
  00065	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00068	50		 push	 eax
  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 1462 : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?GCCheckMainExeKeySend@@YAXH@Z ENDP			; GCCheckMainExeKeySend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z
_TEXT	SEGMENT
_lpClientTime$ = 8					; size = 4
_aIndex$ = 12						; size = 2
?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z PROC		; CGLiveClient, COMDAT

; 1416 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1417 : VM_START
; 1418 : 
; 1419 : 	if ( gObj[aIndex].Connected > PLAYER_CONNECTED )

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	0f bf 7d 0c	 movsx	 edi, WORD PTR _aIndex$[ebp]
  0000f	69 f7 40 27 00
	00		 imul	 esi, edi, 10048
  00015	83 7c 0e 04 01	 cmp	 DWORD PTR [esi+ecx+4], 1
  0001a	7e 16		 jle	 SHORT $LN2@CGLiveClie

; 1420 : 	{
; 1421 : 		gObj[aIndex].ConnectCheckTime = GetTickCount();

  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00028	89 44 0e 3c	 mov	 DWORD PTR [esi+ecx+60], eax
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN2@CGLiveClie:

; 1422 : 	}
; 1423 : 
; 1424 : 	if ( gObj[aIndex].Connected == PLAYER_PLAYING )

  00032	83 7c 0e 04 03	 cmp	 DWORD PTR [esi+ecx+4], 3
  00037	0f 85 86 00 00
	00		 jne	 $LN7@CGLiveClie

; 1425 : 	{
; 1426 : 		if ( gObj[aIndex].m_AttackSpeed < lpClientTime->AttackSpeed || gObj[aIndex].m_MagicSpeed < lpClientTime->MagicSpeed )

  0003d	8b 55 08	 mov	 edx, DWORD PTR _lpClientTime$[ebp]
  00040	53		 push	 ebx
  00041	0f b7 5a 08	 movzx	 ebx, WORD PTR [edx+8]
  00045	39 9c 0e 6c 06
	00 00		 cmp	 DWORD PTR [esi+ecx+1644], ebx
  0004c	7c 1a		 jl	 SHORT $LN6@CGLiveClie
  0004e	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  00052	39 84 0e 70 06
	00 00		 cmp	 DWORD PTR [esi+ecx+1648], eax
  00059	7c 0d		 jl	 SHORT $LN6@CGLiveClie

; 1434 : 			}
; 1435 : 		}
; 1436 : 		else
; 1437 : 		{
; 1438 : 			gObj[aIndex].m_AttackSpeedHackDetectedCount = 0;

  0005b	5b		 pop	 ebx
  0005c	5f		 pop	 edi
  0005d	c6 84 0e 78 05
	00 00 00	 mov	 BYTE PTR [esi+ecx+1400], 0
  00065	5e		 pop	 esi

; 1439 : 		}
; 1440 : 	}
; 1441 : VM_END
; 1442 : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
$LN6@CGLiveClie:

; 1427 : 		{
; 1428 : 			LogAddC(2, "[%s][%s][%s] ClientHack Detected : Editing AttackSpeed [%d][%d] [%d][%d]", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Ip_addr, gObj[aIndex].m_AttackSpeed, lpClientTime->AttackSpeed, gObj[aIndex].m_MagicSpeed, lpClientTime->MagicSpeed);

  00068	0f b7 42 0a	 movzx	 eax, WORD PTR [edx+10]
  0006c	50		 push	 eax
  0006d	ff b4 0e 70 06
	00 00		 push	 DWORD PTR [esi+ecx+1648]
  00074	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00077	53		 push	 ebx
  00078	ff b4 0e 6c 06
	00 00		 push	 DWORD PTR [esi+ecx+1644]
  0007f	03 c1		 add	 eax, ecx
  00081	50		 push	 eax
  00082	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00085	03 c1		 add	 eax, ecx
  00087	50		 push	 eax
  00088	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0008b	03 c1		 add	 eax, ecx
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@EJAGKNML@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FL?$CFs?$FN?5ClientHack?5Detected@
  00093	6a 02		 push	 2
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1429 : 			gObj[aIndex].m_AttackSpeedHackDetectedCount++;

  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000a0	83 c4 24	 add	 esp, 36			; 00000024H
  000a3	fe 84 06 78 05
	00 00		 inc	 BYTE PTR [esi+eax+1400]

; 1430 : 
; 1431 : 			if ( gObj[aIndex].m_AttackSpeedHackDetectedCount > 3 )

  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000af	80 bc 06 78 05
	00 00 03	 cmp	 BYTE PTR [esi+eax+1400], 3
  000b7	76 09		 jbe	 SHORT $LN9@CGLiveClie

; 1432 : 			{
; 1433 : 				CloseClient(aIndex);

  000b9	57		 push	 edi
  000ba	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000bf	83 c4 04	 add	 esp, 4
$LN9@CGLiveClie:
  000c2	5b		 pop	 ebx
$LN7@CGLiveClie:
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi

; 1439 : 		}
; 1440 : 	}
; 1441 : VM_END
; 1442 : }

  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ENDP		; CGLiveClient
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_Msg$ = 12						; size = 4
_size$ = 16						; size = 4
?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z PROC		; MsgSendV2, COMDAT

; 1400 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1401 : 	for ( int n=0;n<MAX_VIEWPORT;n++)

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000b	57		 push	 edi
  0000c	81 c6 48 0c 00
	00		 add	 esi, 3144		; 00000c48H
  00012	bf 4b 00 00 00	 mov	 edi, 75			; 0000004bH
$LL4@MsgSendV2:

; 1402 : 	{
; 1403 : 		if ( lpObj->VpPlayer2[n].type == OBJ_USER )

  00017	80 7e 04 01	 cmp	 BYTE PTR [esi+4], 1
  0001b	75 16		 jne	 SHORT $LN2@MsgSendV2

; 1404 : 		{
; 1405 : 			if ( lpObj->VpPlayer2[n].state != 0 )

  0001d	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00020	74 11		 je	 SHORT $LN2@MsgSendV2

; 1406 : 			{
; 1407 : 				DataSend(lpObj->VpPlayer2[n].number, Msg, size);

  00022	0f bf 46 02	 movsx	 eax, WORD PTR [esi+2]
  00026	53		 push	 ebx
  00027	ff 75 0c	 push	 DWORD PTR _Msg$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@MsgSendV2:

; 1401 : 	for ( int n=0;n<MAX_VIEWPORT;n++)

  00033	83 c6 0c	 add	 esi, 12			; 0000000cH
  00036	83 ef 01	 sub	 edi, 1
  00039	75 dc		 jne	 SHORT $LL4@MsgSendV2
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx

; 1408 : 			}
; 1409 : 		}
; 1410 : 	}
; 1411 : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ENDP		; MsgSendV2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?TestSend@@YAXXZ
_TEXT	SEGMENT
_pMsg$ = -2008						; size = 2004
__$ArrayPad$ = -4					; size = 4
?TestSend@@YAXXZ PROC					; TestSend, COMDAT

; 1380 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 07 00
	00		 sub	 esp, 2008		; 000007d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1381 : 	PMSG_TEST pMsg;
; 1382 : 	int size = sizeof(pMsg);
; 1383 : 	pMsg.h.c = 0xC2;
; 1384 : 	pMsg.h.headcode = 0xFF;	// Test Packet
; 1385 : 	pMsg.h.sizeH = SET_NUMBERH(size);
; 1386 : 	pMsg.h.sizeL = SET_NUMBERL(size);
; 1387 : 	DataSend( tempindex, (LPBYTE)&pMsg, size);

  00013	68 d4 07 00 00	 push	 2004			; 000007d4H
  00018	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0001e	c7 85 28 f8 ff
	ff c2 07 d4 ff	 mov	 DWORD PTR _pMsg$[ebp], -2881598 ; ffd407c2H
  00028	50		 push	 eax
  00029	ff 35 00 00 00
	00		 push	 DWORD PTR ?tempindex@@3HA ; tempindex
  0002f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1388 : 	DataSend( tempindex, (LPBYTE)&pMsg, size);

  00034	68 d4 07 00 00	 push	 2004			; 000007d4H
  00039	8d 85 28 f8 ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  0003f	50		 push	 eax
  00040	ff 35 00 00 00
	00		 push	 DWORD PTR ?tempindex@@3HA ; tempindex
  00046	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1389 : 	LogAdd("TEST Data Send");

  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KNPEEFN@TEST?5Data?5Send?$AA@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 1390 : }

  00056	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00059	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005c	33 cd		 xor	 ecx, ebp
  0005e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?TestSend@@YAXXZ ENDP					; TestSend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?ProtocolCore@@YAXEPAEHHHH@Z
_TEXT	SEGMENT
tv1598 = -44						; size = 4
tv1597 = -44						; size = 4
_res$1 = -44						; size = 5
_res$2 = -36						; size = 30
_pMsg$3 = -32						; size = 25
_res$4 = -24						; size = 17
_res$5 = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_protoNum$ = 8						; size = 1
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
_aIndex$ = 20						; size = 4
_Encrypt$ = 24						; size = 4
_serial$ = 28						; size = 4
?ProtocolCore@@YAXEPAEHHHH@Z PROC			; ProtocolCore, COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 145  : 	// Check if we wanna log the packets
; 146  : 	if ( gStalkProtocol )

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gStalkProtocol@@3HA, 0 ; gStalkProtocol
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	8b 75 14	 mov	 esi, DWORD PTR _aIndex$[ebp]
  0001c	57		 push	 edi
  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _aRecv$[ebp]
  00020	74 65		 je	 SHORT $LN348@ProtocolCo

; 147  : 	{
; 148  : 		if ( gStalkProtocolId[0] == gObj[aIndex].AccountID[0] )

  00022	a0 00 00 00 00	 mov	 al, BYTE PTR ?gStalkProtocolId@@3PADA
  00027	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048
  0002d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00033	3a 41 52	 cmp	 al, BYTE PTR [ecx+82]
  00036	8d 59 52	 lea	 ebx, DWORD PTR [ecx+82]
  00039	75 4c		 jne	 SHORT $LN348@ProtocolCo

; 149  : 		{
; 150  : 			if ( gStalkProtocolId[1] == gObj[aIndex].AccountID[1] )

  0003b	a0 01 00 00 00	 mov	 al, BYTE PTR ?gStalkProtocolId@@3PADA+1
  00040	3a 41 53	 cmp	 al, BYTE PTR [ecx+83]
  00043	75 42		 jne	 SHORT $LN348@ProtocolCo

; 151  : 			{
; 152  : 				if ( !strcmp(gStalkProtocolId, gObj[aIndex].AccountID ) )

  00045	8b cb		 mov	 ecx, ebx
  00047	b8 00 00 00 00	 mov	 eax, OFFSET ?gStalkProtocolId@@3PADA ; gStalkProtocolId
  0004c	0f 1f 40 00	 npad	 4
$LL337@ProtocolCo:
  00050	8a 10		 mov	 dl, BYTE PTR [eax]
  00052	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00054	75 1a		 jne	 SHORT $LN338@ProtocolCo
  00056	84 d2		 test	 dl, dl
  00058	74 12		 je	 SHORT $LN339@ProtocolCo
  0005a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0005d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00060	75 0e		 jne	 SHORT $LN338@ProtocolCo
  00062	83 c0 02	 add	 eax, 2
  00065	83 c1 02	 add	 ecx, 2
  00068	84 d2		 test	 dl, dl
  0006a	75 e4		 jne	 SHORT $LL337@ProtocolCo
$LN339@ProtocolCo:
  0006c	33 c0		 xor	 eax, eax
  0006e	eb 05		 jmp	 SHORT $LN340@ProtocolCo
$LN338@ProtocolCo:
  00070	1b c0		 sbb	 eax, eax
  00072	83 c8 01	 or	 eax, 1
$LN340@ProtocolCo:
  00075	85 c0		 test	 eax, eax
  00077	75 0e		 jne	 SHORT $LN348@ProtocolCo

; 153  : 				{
; 154  : 					LogAddHeadHex(gObj[aIndex].AccountID, (char*)aRecv, aLen);

  00079	ff 75 10	 push	 DWORD PTR _aLen$[ebp]
  0007c	57		 push	 edi
  0007d	53		 push	 ebx
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddHeadHex@@3P6AXPAD0H@ZA ; LogAddHeadHex
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN348@ProtocolCo:

; 155  : 				}
; 156  : 			}
; 157  : 		}
; 158  : 	}	// ig gStalkProtocol
; 159  : 
; 160  : 	// Serial Checking
; 161  : 	if ( serial >= 0 )

  00087	8b 4d 1c	 mov	 ecx, DWORD PTR _serial$[ebp]
  0008a	8b 5d 08	 mov	 ebx, DWORD PTR _protoNum$[ebp]
  0008d	85 c9		 test	 ecx, ecx
  0008f	78 5c		 js	 SHORT $LN349@ProtocolCo

; 162  : 	{
; 163  : 		if ( gObj[aIndex].Type == OBJ_USER )

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00096	69 d6 40 27 00
	00		 imul	 edx, esi, 10048
  0009c	89 55 d4	 mov	 DWORD PTR tv1598[ebp], edx
  0009f	80 7c 02 50 01	 cmp	 BYTE PTR [edx+eax+80], 1
  000a4	75 47		 jne	 SHORT $LN349@ProtocolCo

; 164  : 		{
; 165  : 			if ( gNSerialCheck[aIndex].InCheck(serial) == FALSE )

  000a6	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[esi*8]
  000ad	51		 push	 ecx
  000ae	8b c8		 mov	 ecx, eax
  000b0	e8 00 00 00 00	 call	 ?InCheck@NSerialCheck@@QAEHE@Z ; NSerialCheck::InCheck
  000b5	85 c0		 test	 eax, eax
  000b7	75 34		 jne	 SHORT $LN349@ProtocolCo

; 166  : 			{
; 167  : 				LogAdd("Error-L1 : Socket Serial %s %d o_serial:%d serial:%d ",

  000b9	ff 75 1c	 push	 DWORD PTR _serial$[ebp]
  000bc	8d 0c f5 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[esi*8]
  000c3	e8 00 00 00 00	 call	 ?GetSerial@NSerialCheck@@QAEHXZ ; NSerialCheck::GetSerial
  000c8	50		 push	 eax
  000c9	0f b6 c3	 movzx	 eax, bl
  000cc	50		 push	 eax
  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d2	83 c0 52	 add	 eax, 82			; 00000052H
  000d5	03 45 d4	 add	 eax, DWORD PTR tv1598[ebp]
  000d8	50		 push	 eax
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JHLFDPKE@Error?9L1?5?3?5Socket?5Serial?5?$CFs?5?$CFd?5o@
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd

; 168  : 					gObj[aIndex].AccountID, protoNum, gNSerialCheck[aIndex].GetSerial(), serial);
; 169  : 
; 170  : 				CloseClient(aIndex);

  000e4	56		 push	 esi
  000e5	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  000ea	83 c4 18	 add	 esp, 24			; 00000018H
$LN349@ProtocolCo:

; 171  : 			}
; 172  : 		}
; 173  : 	}	// if Serial Checking
; 174  : 
; 175  : 	if ( protoNum == 0xF1 || protoNum == 0xF3 )

  000ed	80 fb f1	 cmp	 bl, 241			; 000000f1H
  000f0	0f 84 88 18 00
	00		 je	 $LN65@ProtocolCo
  000f6	80 fb f3	 cmp	 bl, 243			; 000000f3H
  000f9	0f 84 7f 18 00
	00		 je	 $LN65@ProtocolCo

; 271  : 							break;
; 272  : 					}
; 273  : 				}
; 274  : 				break;
; 275  : 		}
; 276  : 	}
; 277  : 	else
; 278  : 	{
; 279  : 		LPOBJ lpObj = &gObj[aIndex];

  000ff	69 ce 40 27 00
	00		 imul	 ecx, esi, 10048

; 280  : 
; 281  : #if( DEBUG_PROTOCOL == 1 )
; 282  : 		LogAddHeadHexFunc(1, (LPSTR)aRecv, aLen);
; 283  : #endif
; 284  : 
; 285  : 		switch ( protoNum )

  00105	0f b6 d3	 movzx	 edx, bl
  00108	89 4d d4	 mov	 DWORD PTR tv1597[ebp], ecx
  0010b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00111	81 fa fe 00 00
	00		 cmp	 edx, 254		; 000000feH
  00117	0f 87 24 18 00
	00		 ja	 $LN326@ProtocolCo
  0011d	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN341@ProtocolCo[edx]
  00124	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN354@ProtocolCo[eax*4]
$LN87@ProtocolCo:

; 286  : 		{
; 287  : 			case 0x00:
; 288  : 				tempindex = aIndex;
; 289  : 				PChatProc((PMSG_CHATDATA *)aRecv, aIndex);

  0012b	56		 push	 esi
  0012c	57		 push	 edi
  0012d	89 35 00 00 00
	00		 mov	 DWORD PTR ?tempindex@@3HA, esi ; tempindex
  00133	e8 00 00 00 00	 call	 ?PChatProc@@YAXPAUPMSG_CHATDATA@@F@Z ; PChatProc
  00138	83 c4 08	 add	 esp, 8
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0013e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00141	33 cd		 xor	 ecx, ebp
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
$LN88@ProtocolCo:

; 290  : 				break;
; 291  : 			case 0x01:
; 292  : 				CGChatRecv((PMSG_CHATDATA_NUMBER *)aRecv, aIndex);

  0014c	56		 push	 esi
  0014d	57		 push	 edi
  0014e	e8 00 00 00 00	 call	 ?CGChatRecv@@YAXPAUPMSG_CHATDATA_NUMBER@@H@Z ; CGChatRecv
  00153	83 c4 08	 add	 esp, 8
  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00159	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015c	33 cd		 xor	 ecx, ebp
  0015e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
$LN89@ProtocolCo:

; 293  : 				break;
; 294  : 			case 0x02:
; 295  : 				CGChatWhisperRecv((PMSG_CHATDATA_WHISPER *)aRecv, aIndex);

  00167	56		 push	 esi
  00168	57		 push	 edi
  00169	e8 00 00 00 00	 call	 ?CGChatWhisperRecv@@YAXPAUPMSG_CHATDATA_WHISPER@@H@Z ; CGChatWhisperRecv
  0016e	83 c4 08	 add	 esp, 8
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00174	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00177	33 cd		 xor	 ecx, ebp
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c3		 ret	 0
$LN90@ProtocolCo:

; 296  : 				break;
; 297  : 			case 0x03:
; 298  : 				CGCheckMainRecv((PMSG_CHECK_MAINEXE_RESULT *)aRecv, aIndex);

  00182	56		 push	 esi
  00183	57		 push	 edi
  00184	e8 00 00 00 00	 call	 ?CGCheckMainRecv@@YAXPAUPMSG_CHECK_MAINEXE_RESULT@@H@Z ; CGCheckMainRecv
  00189	83 c4 08	 add	 esp, 8
  0018c	5f		 pop	 edi
  0018d	5e		 pop	 esi
  0018e	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0018f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00192	33 cd		 xor	 ecx, ebp
  00194	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
$LN92@ProtocolCo:

; 299  : 				break;
; 300  : 			case 0x04:
; 301  : 				break;
; 302  : 			case 0x0E:
; 303  : 				CGLiveClient((PMSG_CLIENTTIME *)aRecv, aIndex);

  0019d	56		 push	 esi
  0019e	57		 push	 edi
  0019f	e8 00 00 00 00	 call	 ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ; CGLiveClient
  001a4	83 c4 08	 add	 esp, 8
  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  001aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ad	33 cd		 xor	 ecx, ebp
  001af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b4	8b e5		 mov	 esp, ebp
  001b6	5d		 pop	 ebp
  001b7	c3		 ret	 0
$LN93@ProtocolCo:

; 304  : 				break;
; 305  : 				
; 306  : #if (__ENG__ == 1)
; 307  : 			case 0xD4:
; 308  : #else
; 309  : 			// KOR PROTOCOL !!!
; 310  : 			case 0xD7:
; 311  : #endif
; 312  : 				PMoveProc((PMSG_MOVE *)aRecv, aIndex);

  001b8	56		 push	 esi
  001b9	57		 push	 edi
  001ba	e8 00 00 00 00	 call	 ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ; PMoveProc
  001bf	83 c4 08	 add	 esp, 8
  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi
  001c4	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  001c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c8	33 cd		 xor	 ecx, ebp
  001ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c3		 ret	 0
$LN94@ProtocolCo:

; 313  : 				break;	
; 314  : #if (__ENG__ == 1)
; 315  : 			case 0x15:// ENG PROTOCOL !!!
; 316  : #else
; 317  : 			case 0x10:// KOR PROTOCOL !!!
; 318  : #endif
; 319  : 				RecvPositionSetProc((PMSG_POSISTION_SET *)aRecv, aIndex);

  001d3	56		 push	 esi
  001d4	57		 push	 edi
  001d5	e8 00 00 00 00	 call	 ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
  001da	83 c4 08	 add	 esp, 8
  001dd	5f		 pop	 edi
  001de	5e		 pop	 esi
  001df	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  001e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e3	33 cd		 xor	 ecx, ebp
  001e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c3		 ret	 0
$LN95@ProtocolCo:

; 320  : 				break;
; 321  : #if (__ENG__ == 1)
; 322  : 			case 0x11:	// ENG PROTOCOL !!!
; 323  : #else
; 324  : 			case 0xDF:	// KOR PROTOCOL !!!
; 325  : #endif
; 326  : 				CGAttack((PMSG_ATTACK *)aRecv, aIndex);

  001ee	56		 push	 esi
  001ef	57		 push	 edi
  001f0	e8 00 00 00 00	 call	 ?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z ; CGAttack
  001f5	83 c4 08	 add	 esp, 8
  001f8	5f		 pop	 edi
  001f9	5e		 pop	 esi
  001fa	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  001fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fe	33 cd		 xor	 ecx, ebp
  00200	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c3		 ret	 0
$LN96@ProtocolCo:

; 327  : 				break;
; 328  : 			case 0x18:
; 329  : 				CGActionRecv((PMSG_ACTION *)aRecv, aIndex);

  00209	56		 push	 esi
  0020a	57		 push	 edi
  0020b	e8 00 00 00 00	 call	 ?CGActionRecv@@YAXPAUPMSG_ACTION@@H@Z ; CGActionRecv
  00210	83 c4 08	 add	 esp, 8
  00213	5f		 pop	 edi
  00214	5e		 pop	 esi
  00215	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00216	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00219	33 cd		 xor	 ecx, ebp
  0021b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00220	8b e5		 mov	 esp, ebp
  00222	5d		 pop	 ebp
  00223	c3		 ret	 0
$LN97@ProtocolCo:

; 330  : 				break;
; 331  : 			case 0x19:
; 332  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00224	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  00227	53		 push	 ebx
  00228	56		 push	 esi
  00229	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0022e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00231	85 c0		 test	 eax, eax
  00233	0f 84 96 19 00
	00		 je	 $LN67@ProtocolCo

; 333  : 				{
; 334  : 					CGMagicAttack((PMSG_MAGICATTACK *)aRecv, aIndex);

  00239	56		 push	 esi
  0023a	57		 push	 edi
  0023b	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  00240	83 c4 08	 add	 esp, 8
  00243	5f		 pop	 edi
  00244	5e		 pop	 esi
  00245	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00246	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00249	33 cd		 xor	 ecx, ebp
  0024b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00250	8b e5		 mov	 esp, ebp
  00252	5d		 pop	 ebp
  00253	c3		 ret	 0
$LN99@ProtocolCo:

; 335  : 				}
; 336  : 				break;
; 337  : 			case 0x1B:
; 338  : 				CGMagicCancel((PMSG_MAGICCANCEL *)aRecv, aIndex);

  00254	56		 push	 esi
  00255	57		 push	 edi
  00256	e8 00 00 00 00	 call	 ?CGMagicCancel@@YAXPAUPMSG_MAGICCANCEL@@H@Z ; CGMagicCancel
  0025b	83 c4 08	 add	 esp, 8
  0025e	5f		 pop	 edi
  0025f	5e		 pop	 esi
  00260	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00261	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00264	33 cd		 xor	 ecx, ebp
  00266	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026b	8b e5		 mov	 esp, ebp
  0026d	5d		 pop	 ebp
  0026e	c3		 ret	 0
$LN100@ProtocolCo:

; 339  : 				break;
; 340  : 			case 0x1C:
; 341  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0026f	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  00272	53		 push	 ebx
  00273	56		 push	 esi
  00274	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00279	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027c	85 c0		 test	 eax, eax
  0027e	0f 84 4b 19 00
	00		 je	 $LN67@ProtocolCo

; 342  : 				{
; 343  : 					CGTeleportRecv((PMSG_TELEPORT *)aRecv, aIndex);

  00284	56		 push	 esi
  00285	57		 push	 edi
  00286	e8 00 00 00 00	 call	 ?CGTeleportRecv@@YAXPAUPMSG_TELEPORT@@H@Z ; CGTeleportRecv
  0028b	83 c4 08	 add	 esp, 8
  0028e	5f		 pop	 edi
  0028f	5e		 pop	 esi
  00290	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00291	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00294	33 cd		 xor	 ecx, ebp
  00296	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029b	8b e5		 mov	 esp, ebp
  0029d	5d		 pop	 ebp
  0029e	c3		 ret	 0
$LN102@ProtocolCo:

; 344  : 				}
; 345  : 				break;
; 346  : 			case 0xB0:
; 347  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0029f	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  002a2	53		 push	 ebx
  002a3	56		 push	 esi
  002a4	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  002a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ac	85 c0		 test	 eax, eax
  002ae	0f 84 1b 19 00
	00		 je	 $LN67@ProtocolCo

; 348  : 				{
; 349  : 					CGTargetTeleportRecv((PMSG_TARGET_TELEPORT *)aRecv, aIndex);

  002b4	56		 push	 esi
  002b5	57		 push	 edi
  002b6	e8 00 00 00 00	 call	 ?CGTargetTeleportRecv@@YAXPAUPMSG_TARGET_TELEPORT@@H@Z ; CGTargetTeleportRecv
  002bb	83 c4 08	 add	 esp, 8
  002be	5f		 pop	 edi
  002bf	5e		 pop	 esi
  002c0	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  002c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c4	33 cd		 xor	 ecx, ebp
  002c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002cb	8b e5		 mov	 esp, ebp
  002cd	5d		 pop	 ebp
  002ce	c3		 ret	 0
$LN104@ProtocolCo:

; 350  : 				}
; 351  : 				break;
; 352  : 				
; 353  : #if (__ENG__ == 1)
; 354  : 			case 0xDB:// ENG PROTOCOL
; 355  : #else
; 356  : 			case 0xD3: // KOR PROTOCOL
; 357  : #endif
; 358  : 				CGBeattackRecv(aRecv, aIndex, FALSE);

  002cf	6a 00		 push	 0
  002d1	56		 push	 esi
  002d2	57		 push	 edi
  002d3	e8 00 00 00 00	 call	 ?CGBeattackRecv@@YAXPAEHH@Z ; CGBeattackRecv
  002d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  002db	5f		 pop	 edi
  002dc	5e		 pop	 esi
  002dd	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  002de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e1	33 cd		 xor	 ecx, ebp
  002e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e8	8b e5		 mov	 esp, ebp
  002ea	5d		 pop	 ebp
  002eb	c3		 ret	 0
$LN105@ProtocolCo:

; 359  : 				break;
; 360  : 			case 0x1E:
; 361  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  002ec	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  002ef	53		 push	 ebx
  002f0	56		 push	 esi
  002f1	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  002f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f9	85 c0		 test	 eax, eax
  002fb	0f 84 ce 18 00
	00		 je	 $LN67@ProtocolCo

; 362  : 				{
; 363  : 					CGDurationMagicRecv((PMSG_DURATION_MAGIC_RECV *)aRecv, aIndex);

  00301	56		 push	 esi
  00302	57		 push	 edi
  00303	e8 00 00 00 00	 call	 ?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ; CGDurationMagicRecv
  00308	83 c4 08	 add	 esp, 8
  0030b	5f		 pop	 edi
  0030c	5e		 pop	 esi
  0030d	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0030e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00311	33 cd		 xor	 ecx, ebp
  00313	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00318	8b e5		 mov	 esp, ebp
  0031a	5d		 pop	 ebp
  0031b	c3		 ret	 0
$LN107@ProtocolCo:

; 364  : 				}
; 365  : 				break;
; 366  : 			case 0x22:
; 367  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0031c	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  0031f	53		 push	 ebx
  00320	56		 push	 esi
  00321	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00326	83 c4 0c	 add	 esp, 12			; 0000000cH
  00329	85 c0		 test	 eax, eax
  0032b	0f 84 9e 18 00
	00		 je	 $LN67@ProtocolCo

; 368  : 				{
; 369  : 					CGItemGetRequest((PMSG_ITEMGETREQUEST *)aRecv, aIndex);

  00331	56		 push	 esi
  00332	57		 push	 edi
  00333	e8 00 00 00 00	 call	 ?CGItemGetRequest@@YAXPAUPMSG_ITEMGETREQUEST@@H@Z ; CGItemGetRequest
  00338	83 c4 08	 add	 esp, 8
  0033b	5f		 pop	 edi
  0033c	5e		 pop	 esi
  0033d	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0033e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00341	33 cd		 xor	 ecx, ebp
  00343	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00348	8b e5		 mov	 esp, ebp
  0034a	5d		 pop	 ebp
  0034b	c3		 ret	 0
$LN109@ProtocolCo:

; 370  : 				}
; 371  : 				break;
; 372  : 			case 0x23:
; 373  : 				CGItemDropRequest((PMSG_ITEMTHROW *)aRecv, aIndex, 0);

  0034c	6a 00		 push	 0
  0034e	56		 push	 esi
  0034f	57		 push	 edi
  00350	e8 00 00 00 00	 call	 ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ; CGItemDropRequest
  00355	83 c4 0c	 add	 esp, 12			; 0000000cH
  00358	5f		 pop	 edi
  00359	5e		 pop	 esi
  0035a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0035b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0035e	33 cd		 xor	 ecx, ebp
  00360	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00365	8b e5		 mov	 esp, ebp
  00367	5d		 pop	 ebp
  00368	c3		 ret	 0
$LN110@ProtocolCo:

; 374  : 				break;
; 375  : 			case 0x24:
; 376  : 				CGInventoryItemMove((PMSG_INVENTORYITEMMOVE *)aRecv, aIndex);

  00369	56		 push	 esi
  0036a	57		 push	 edi
  0036b	e8 00 00 00 00	 call	 ?CGInventoryItemMove@@YAXPAUPMSG_INVENTORYITEMMOVE@@H@Z ; CGInventoryItemMove
  00370	83 c4 08	 add	 esp, 8
  00373	5f		 pop	 edi
  00374	5e		 pop	 esi
  00375	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00376	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00379	33 cd		 xor	 ecx, ebp
  0037b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00380	8b e5		 mov	 esp, ebp
  00382	5d		 pop	 ebp
  00383	c3		 ret	 0
$LN111@ProtocolCo:

; 377  : 				break;
; 378  : 			case 0x26:
; 379  : 				CGUseItemRecv((PMSG_USEITEM *)aRecv, aIndex);

  00384	56		 push	 esi
  00385	57		 push	 edi
  00386	e8 00 00 00 00	 call	 ?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z ; CGUseItemRecv
  0038b	83 c4 08	 add	 esp, 8
  0038e	5f		 pop	 edi
  0038f	5e		 pop	 esi
  00390	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00391	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00394	33 cd		 xor	 ecx, ebp
  00396	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0039b	8b e5		 mov	 esp, ebp
  0039d	5d		 pop	 ebp
  0039e	c3		 ret	 0
$LN112@ProtocolCo:

; 380  : 				break;
; 381  : 			case 0x30:
; 382  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  0039f	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  003a2	53		 push	 ebx
  003a3	56		 push	 esi
  003a4	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  003a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ac	85 c0		 test	 eax, eax
  003ae	0f 84 1b 18 00
	00		 je	 $LN67@ProtocolCo

; 383  : 				{
; 384  : 					CGTalkRequestRecv((PMSG_TALKREQUEST *)aRecv, aIndex);

  003b4	56		 push	 esi
  003b5	57		 push	 edi
  003b6	e8 00 00 00 00	 call	 ?CGTalkRequestRecv@@YAXPAUPMSG_TALKREQUEST@@H@Z ; CGTalkRequestRecv
  003bb	83 c4 08	 add	 esp, 8
  003be	5f		 pop	 edi
  003bf	5e		 pop	 esi
  003c0	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  003c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c4	33 cd		 xor	 ecx, ebp
  003c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cb	8b e5		 mov	 esp, ebp
  003cd	5d		 pop	 ebp
  003ce	c3		 ret	 0
$LN114@ProtocolCo:

; 385  : 				}
; 386  : 				break;
; 387  : 			case 0x31:
; 388  : 				CGCloseWindow(aIndex);

  003cf	56		 push	 esi
  003d0	e8 00 00 00 00	 call	 ?CGCloseWindow@@YAXH@Z	; CGCloseWindow
  003d5	83 c4 04	 add	 esp, 4
  003d8	5f		 pop	 edi
  003d9	5e		 pop	 esi
  003da	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  003db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003de	33 cd		 xor	 ecx, ebp
  003e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e5	8b e5		 mov	 esp, ebp
  003e7	5d		 pop	 ebp
  003e8	c3		 ret	 0
$LN115@ProtocolCo:

; 389  : 				break;
; 390  : 			case 0x32:
; 391  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  003e9	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  003ec	53		 push	 ebx
  003ed	56		 push	 esi
  003ee	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  003f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  003f6	85 c0		 test	 eax, eax
  003f8	0f 84 d1 17 00
	00		 je	 $LN67@ProtocolCo

; 392  : 				{
; 393  : 					CGBuyRequestRecv((PMSG_BUYREQUEST *)aRecv, aIndex);

  003fe	56		 push	 esi
  003ff	57		 push	 edi
  00400	e8 00 00 00 00	 call	 ?CGBuyRequestRecv@@YAXPAUPMSG_BUYREQUEST@@H@Z ; CGBuyRequestRecv
  00405	83 c4 08	 add	 esp, 8
  00408	5f		 pop	 edi
  00409	5e		 pop	 esi
  0040a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0040b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040e	33 cd		 xor	 ecx, ebp
  00410	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00415	8b e5		 mov	 esp, ebp
  00417	5d		 pop	 ebp
  00418	c3		 ret	 0
$LN117@ProtocolCo:

; 394  : 				}
; 395  : 				break;
; 396  : 			case 0x33:
; 397  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00419	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  0041c	53		 push	 ebx
  0041d	56		 push	 esi
  0041e	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00423	83 c4 0c	 add	 esp, 12			; 0000000cH
  00426	85 c0		 test	 eax, eax
  00428	0f 84 a1 17 00
	00		 je	 $LN67@ProtocolCo

; 398  : 				{
; 399  : 					CGSellRequestRecv((PMSG_SELLREQUEST *)aRecv, aIndex);

  0042e	56		 push	 esi
  0042f	57		 push	 edi
  00430	e8 00 00 00 00	 call	 ?CGSellRequestRecv@@YAXPAUPMSG_SELLREQUEST@@H@Z ; CGSellRequestRecv
  00435	83 c4 08	 add	 esp, 8
  00438	5f		 pop	 edi
  00439	5e		 pop	 esi
  0043a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0043b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0043e	33 cd		 xor	 ecx, ebp
  00440	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00445	8b e5		 mov	 esp, ebp
  00447	5d		 pop	 ebp
  00448	c3		 ret	 0
$LN119@ProtocolCo:

; 400  : 				}
; 401  : 				break;
; 402  : 			case 0x34:
; 403  : 				CGModifyRequestItem((PMSG_ITEMDURREPAIR *)aRecv, aIndex);

  00449	56		 push	 esi
  0044a	57		 push	 edi
  0044b	e8 00 00 00 00	 call	 ?CGModifyRequestItem@@YAXPAUPMSG_ITEMDURREPAIR@@H@Z ; CGModifyRequestItem
  00450	83 c4 08	 add	 esp, 8
  00453	5f		 pop	 edi
  00454	5e		 pop	 esi
  00455	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00456	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00459	33 cd		 xor	 ecx, ebp
  0045b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00460	8b e5		 mov	 esp, ebp
  00462	5d		 pop	 ebp
  00463	c3		 ret	 0
$LN120@ProtocolCo:

; 404  : 				break;
; 405  : 			case 0x36:
; 406  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00464	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  00467	53		 push	 ebx
  00468	56		 push	 esi
  00469	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0046e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00471	85 c0		 test	 eax, eax
  00473	0f 84 56 17 00
	00		 je	 $LN67@ProtocolCo

; 407  : 				{
; 408  : 					CGTradeRequestSend((PMSG_TRADE_REQUEST *)aRecv, aIndex);

  00479	56		 push	 esi
  0047a	57		 push	 edi
  0047b	e8 00 00 00 00	 call	 ?CGTradeRequestSend@@YAXPAUPMSG_TRADE_REQUEST@@H@Z ; CGTradeRequestSend
  00480	83 c4 08	 add	 esp, 8
  00483	5f		 pop	 edi
  00484	5e		 pop	 esi
  00485	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00486	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00489	33 cd		 xor	 ecx, ebp
  0048b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00490	8b e5		 mov	 esp, ebp
  00492	5d		 pop	 ebp
  00493	c3		 ret	 0
$LN122@ProtocolCo:

; 409  : 				}
; 410  : 				break;
; 411  : 			case 0x37:
; 412  : 				CGTradeResponseRecv((PMSG_TRADE_RESPONSE *)aRecv, aIndex);

  00494	56		 push	 esi
  00495	57		 push	 edi
  00496	e8 00 00 00 00	 call	 ?CGTradeResponseRecv@@YAXPAUPMSG_TRADE_RESPONSE@@H@Z ; CGTradeResponseRecv
  0049b	83 c4 08	 add	 esp, 8
  0049e	5f		 pop	 edi
  0049f	5e		 pop	 esi
  004a0	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  004a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a4	33 cd		 xor	 ecx, ebp
  004a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ab	8b e5		 mov	 esp, ebp
  004ad	5d		 pop	 ebp
  004ae	c3		 ret	 0
$LN123@ProtocolCo:

; 413  : 				break;
; 414  : 			case 0x3A:
; 415  : 				CGTradeMoneyRecv((PMSG_TRADE_GOLD *)aRecv, aIndex);

  004af	56		 push	 esi
  004b0	57		 push	 edi
  004b1	e8 00 00 00 00	 call	 ?CGTradeMoneyRecv@@YAXPAUPMSG_TRADE_GOLD@@H@Z ; CGTradeMoneyRecv
  004b6	83 c4 08	 add	 esp, 8
  004b9	5f		 pop	 edi
  004ba	5e		 pop	 esi
  004bb	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  004bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004bf	33 cd		 xor	 ecx, ebp
  004c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c6	8b e5		 mov	 esp, ebp
  004c8	5d		 pop	 ebp
  004c9	c3		 ret	 0
$LN124@ProtocolCo:

; 416  : 				break;
; 417  : 			case 0x3C:
; 418  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  004ca	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  004cd	53		 push	 ebx
  004ce	56		 push	 esi
  004cf	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  004d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d7	85 c0		 test	 eax, eax
  004d9	0f 84 f0 16 00
	00		 je	 $LN67@ProtocolCo

; 419  : 				{
; 420  : 					CGTradeOkButtonRecv((PMSG_TRADE_OKBUTTON *)aRecv, aIndex);

  004df	56		 push	 esi
  004e0	57		 push	 edi
  004e1	e8 00 00 00 00	 call	 ?CGTradeOkButtonRecv@@YAXPAUPMSG_TRADE_OKBUTTON@@H@Z ; CGTradeOkButtonRecv
  004e6	83 c4 08	 add	 esp, 8
  004e9	5f		 pop	 edi
  004ea	5e		 pop	 esi
  004eb	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  004ec	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ef	33 cd		 xor	 ecx, ebp
  004f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004f6	8b e5		 mov	 esp, ebp
  004f8	5d		 pop	 ebp
  004f9	c3		 ret	 0
$LN126@ProtocolCo:

; 421  : 				}
; 422  : 				break;
; 423  : 			case 0x3D:
; 424  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  004fa	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  004fd	53		 push	 ebx
  004fe	56		 push	 esi
  004ff	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  00504	83 c4 0c	 add	 esp, 12			; 0000000cH
  00507	85 c0		 test	 eax, eax
  00509	0f 84 c0 16 00
	00		 je	 $LN67@ProtocolCo

; 425  : 				{
; 426  : 					CGTradeCancelButtonRecv(aIndex);

  0050f	56		 push	 esi
  00510	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  00515	83 c4 04	 add	 esp, 4
  00518	5f		 pop	 edi
  00519	5e		 pop	 esi
  0051a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0051b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0051e	33 cd		 xor	 ecx, ebp
  00520	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00525	8b e5		 mov	 esp, ebp
  00527	5d		 pop	 ebp
  00528	c3		 ret	 0
$LN128@ProtocolCo:

; 427  : 				}
; 428  : 				break;
; 429  : 			case 0x3F:
; 430  : 				{
; 431  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 432  : 
; 433  : 					switch ( lpDef->subcode )

  00529	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0052d	48		 dec	 eax
  0052e	83 f8 05	 cmp	 eax, 5
  00531	0f 87 98 16 00
	00		 ja	 $LN67@ProtocolCo
  00537	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN355@ProtocolCo[eax*4]
$LN129@ProtocolCo:

; 434  : 					{
; 435  : 						case 0x01:
; 436  : 							CGPShopReqSetItemPrice((PMSG_REQ_PSHOP_SETITEMPRICE *)aRecv, aIndex);

  0053e	56		 push	 esi
  0053f	57		 push	 edi
  00540	e8 00 00 00 00	 call	 ?CGPShopReqSetItemPrice@@YAXPAUPMSG_REQ_PSHOP_SETITEMPRICE@@H@Z ; CGPShopReqSetItemPrice
  00545	83 c4 08	 add	 esp, 8
  00548	5f		 pop	 edi
  00549	5e		 pop	 esi
  0054a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0054b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0054e	33 cd		 xor	 ecx, ebp
  00550	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00555	8b e5		 mov	 esp, ebp
  00557	5d		 pop	 ebp
  00558	c3		 ret	 0
$LN130@ProtocolCo:

; 437  : 							break;
; 438  : 						case 0x02:
; 439  : 							CGPShopReqOpen((PMSG_REQ_PSHOP_OPEN *)aRecv, aIndex);

  00559	56		 push	 esi
  0055a	57		 push	 edi
  0055b	e8 00 00 00 00	 call	 ?CGPShopReqOpen@@YAXPAUPMSG_REQ_PSHOP_OPEN@@H@Z ; CGPShopReqOpen
  00560	83 c4 08	 add	 esp, 8
  00563	5f		 pop	 edi
  00564	5e		 pop	 esi
  00565	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00566	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00569	33 cd		 xor	 ecx, ebp
  0056b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00570	8b e5		 mov	 esp, ebp
  00572	5d		 pop	 ebp
  00573	c3		 ret	 0
$LN131@ProtocolCo:

; 440  : 							break;
; 441  : 						case 0x03:
; 442  : 							CGPShopReqClose(aIndex);

  00574	56		 push	 esi
  00575	e8 00 00 00 00	 call	 ?CGPShopReqClose@@YAXH@Z ; CGPShopReqClose
  0057a	83 c4 04	 add	 esp, 4
  0057d	5f		 pop	 edi
  0057e	5e		 pop	 esi
  0057f	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00580	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00583	33 cd		 xor	 ecx, ebp
  00585	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0058a	8b e5		 mov	 esp, ebp
  0058c	5d		 pop	 ebp
  0058d	c3		 ret	 0
$LN132@ProtocolCo:

; 443  : 							break;
; 444  : 						case 0x05:
; 445  : 							CGPShopReqBuyList((PMSG_REQ_BUYLIST_FROM_PSHOP *)aRecv, aIndex);

  0058e	56		 push	 esi
  0058f	57		 push	 edi
  00590	e8 00 00 00 00	 call	 ?CGPShopReqBuyList@@YAXPAUPMSG_REQ_BUYLIST_FROM_PSHOP@@H@Z ; CGPShopReqBuyList
  00595	83 c4 08	 add	 esp, 8
  00598	5f		 pop	 edi
  00599	5e		 pop	 esi
  0059a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0059b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0059e	33 cd		 xor	 ecx, ebp
  005a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005a5	8b e5		 mov	 esp, ebp
  005a7	5d		 pop	 ebp
  005a8	c3		 ret	 0
$LN133@ProtocolCo:

; 446  : 							break;
; 447  : 						case 0x06:
; 448  : 							CGPShopReqBuyItem((PMSG_REQ_BUYITEM_FROM_PSHOP *)aRecv, aIndex);

  005a9	56		 push	 esi
  005aa	57		 push	 edi
  005ab	e8 00 00 00 00	 call	 ?CGPShopReqBuyItem@@YAXPAUPMSG_REQ_BUYITEM_FROM_PSHOP@@H@Z ; CGPShopReqBuyItem
  005b0	83 c4 08	 add	 esp, 8
  005b3	5f		 pop	 edi
  005b4	5e		 pop	 esi
  005b5	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  005b6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005b9	33 cd		 xor	 ecx, ebp
  005bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005c0	8b e5		 mov	 esp, ebp
  005c2	5d		 pop	 ebp
  005c3	c3		 ret	 0
$LN134@ProtocolCo:

; 449  : 							break;
; 450  : 					}
; 451  : 				}
; 452  : 				break;
; 453  : 			case 0x40:
; 454  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  005c4	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  005c7	53		 push	 ebx
  005c8	56		 push	 esi
  005c9	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  005ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  005d1	85 c0		 test	 eax, eax
  005d3	0f 84 f6 15 00
	00		 je	 $LN67@ProtocolCo

; 455  : 				{
; 456  : 					CGPartyRequestRecv((PMSG_PARTYREQUEST *)aRecv, aIndex);

  005d9	56		 push	 esi
  005da	57		 push	 edi
  005db	e8 00 00 00 00	 call	 ?CGPartyRequestRecv@@YAXPAUPMSG_PARTYREQUEST@@H@Z ; CGPartyRequestRecv
  005e0	83 c4 08	 add	 esp, 8
  005e3	5f		 pop	 edi
  005e4	5e		 pop	 esi
  005e5	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  005e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e9	33 cd		 xor	 ecx, ebp
  005eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f0	8b e5		 mov	 esp, ebp
  005f2	5d		 pop	 ebp
  005f3	c3		 ret	 0
$LN136@ProtocolCo:

; 457  : 				}
; 458  : 				break;
; 459  : 			case 0x41:
; 460  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  005f4	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  005f7	53		 push	 ebx
  005f8	56		 push	 esi
  005f9	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  005fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00601	85 c0		 test	 eax, eax
  00603	0f 84 c6 15 00
	00		 je	 $LN67@ProtocolCo

; 461  : 				{
; 462  : 					CGPartyRequestResultRecv((PMSG_PARTYREQUESTRESULT *)aRecv, aIndex);

  00609	56		 push	 esi
  0060a	57		 push	 edi
  0060b	e8 00 00 00 00	 call	 ?CGPartyRequestResultRecv@@YAXPAUPMSG_PARTYREQUESTRESULT@@H@Z ; CGPartyRequestResultRecv
  00610	83 c4 08	 add	 esp, 8
  00613	5f		 pop	 edi
  00614	5e		 pop	 esi
  00615	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00616	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00619	33 cd		 xor	 ecx, ebp
  0061b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00620	8b e5		 mov	 esp, ebp
  00622	5d		 pop	 ebp
  00623	c3		 ret	 0
$LN138@ProtocolCo:

; 463  : 				}
; 464  : 				break;
; 465  : 			case 0x42:
; 466  : 				CGPartyList(aIndex);

  00624	56		 push	 esi
  00625	e8 00 00 00 00	 call	 ?CGPartyList@@YAXH@Z	; CGPartyList
  0062a	83 c4 04	 add	 esp, 4
  0062d	5f		 pop	 edi
  0062e	5e		 pop	 esi
  0062f	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00630	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00633	33 cd		 xor	 ecx, ebp
  00635	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0063a	8b e5		 mov	 esp, ebp
  0063c	5d		 pop	 ebp
  0063d	c3		 ret	 0
$LN139@ProtocolCo:

; 467  : 				break;
; 468  : 			case 0x43:
; 469  : 				if ( PacketCheckTime(&gObj[aIndex]) == TRUE )

  0063e	51		 push	 ecx
  0063f	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00644	83 c4 04	 add	 esp, 4
  00647	83 f8 01	 cmp	 eax, 1
  0064a	0f 85 7f 15 00
	00		 jne	 $LN67@ProtocolCo

; 470  : 				{
; 471  : 					if(!IT_MAP_RANGE(gObj[aIndex].MapNumber)
; 472  : 						&& !DG_MAP_RANGE(gObj[aIndex].MapNumber)
; 473  : 						&& !IF_MAP_RANGE(gObj[aIndex].MapNumber)

  00650	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00655	8b 4d d4	 mov	 ecx, DWORD PTR tv1597[ebp]
  00658	8a 8c 01 23 01
	00 00		 mov	 cl, BYTE PTR [ecx+eax+291]
  0065f	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  00662	72 0f		 jb	 SHORT $LN334@ProtocolCo
  00664	b0 32		 mov	 al, 50			; 00000032H
  00666	3a c1		 cmp	 al, cl
  00668	1b c0		 sbb	 eax, eax
  0066a	83 c0 01	 add	 eax, 1
  0066d	0f 85 5c 15 00
	00		 jne	 $LN67@ProtocolCo
$LN334@ProtocolCo:
  00673	80 f9 41	 cmp	 cl, 65			; 00000041H
  00676	72 0f		 jb	 SHORT $LN335@ProtocolCo
  00678	b0 44		 mov	 al, 68			; 00000044H
  0067a	3a c1		 cmp	 al, cl
  0067c	1b c0		 sbb	 eax, eax
  0067e	83 c0 01	 add	 eax, 1
  00681	0f 85 48 15 00
	00		 jne	 $LN67@ProtocolCo
$LN335@ProtocolCo:
  00687	80 f9 45	 cmp	 cl, 69			; 00000045H
  0068a	72 0f		 jb	 SHORT $LN336@ProtocolCo
  0068c	b0 48		 mov	 al, 72			; 00000048H
  0068e	3a c1		 cmp	 al, cl
  00690	1b c0		 sbb	 eax, eax
  00692	83 c0 01	 add	 eax, 1
  00695	0f 85 34 15 00
	00		 jne	 $LN67@ProtocolCo
$LN336@ProtocolCo:

; 474  : 						)
; 475  : 					{
; 476  : 						CGPartyDelUser((PMSG_PARTYDELUSER *)aRecv, aIndex);

  0069b	56		 push	 esi
  0069c	57		 push	 edi
  0069d	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  006a2	83 c4 08	 add	 esp, 8
  006a5	5f		 pop	 edi
  006a6	5e		 pop	 esi
  006a7	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  006a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006ab	33 cd		 xor	 ecx, ebp
  006ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006b2	8b e5		 mov	 esp, ebp
  006b4	5d		 pop	 ebp
  006b5	c3		 ret	 0
$LN142@ProtocolCo:

; 477  : 					}
; 478  : 				}
; 479  : 				break;
; 480  : 			case 0x4A:
; 481  : 				GCMonkMagicAttack((PMSG_MAGICATTACK*)aRecv,aIndex);

  006b6	56		 push	 esi
  006b7	57		 push	 edi
  006b8	e8 00 00 00 00	 call	 ?GCMonkMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; GCMonkMagicAttack
  006bd	83 c4 08	 add	 esp, 8
  006c0	5f		 pop	 edi
  006c1	5e		 pop	 esi
  006c2	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  006c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006c6	33 cd		 xor	 ecx, ebp
  006c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006cd	8b e5		 mov	 esp, ebp
  006cf	5d		 pop	 ebp
  006d0	c3		 ret	 0
$LN143@ProtocolCo:

; 482  : 				break;
; 483  : 			case 0x4B:
; 484  : 				GCMonkDarkSideTargetSelect((PMSG_MONK_DARKSIDE_RECV*)aRecv,aIndex);

  006d1	56		 push	 esi
  006d2	57		 push	 edi
  006d3	e8 00 00 00 00	 call	 ?GCMonkDarkSideTargetSelect@@YAXPAUPMSG_MONK_DARKSIDE_RECV@@H@Z ; GCMonkDarkSideTargetSelect
  006d8	83 c4 08	 add	 esp, 8
  006db	5f		 pop	 edi
  006dc	5e		 pop	 esi
  006dd	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  006de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006e1	33 cd		 xor	 ecx, ebp
  006e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006e8	8b e5		 mov	 esp, ebp
  006ea	5d		 pop	 ebp
  006eb	c3		 ret	 0
$LN144@ProtocolCo:

; 485  : 				break;
; 486  : 			case 0x4C:
; 487  : 				{
; 488  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 489  : 
; 490  : 					switch (lpDef->subcode)

  006ec	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  006f0	83 e8 00	 sub	 eax, 0
  006f3	74 44		 je	 SHORT $LN145@ProtocolCo
  006f5	83 e8 01	 sub	 eax, 1
  006f8	74 24		 je	 SHORT $LN146@ProtocolCo
  006fa	83 e8 02	 sub	 eax, 2
  006fd	0f 85 cc 14 00
	00		 jne	 $LN67@ProtocolCo

; 497  : 						break;
; 498  : 					case 3:
; 499  : 						CGMiningEnd((PMSG_MINING_END*)aRecv,aIndex);

  00703	56		 push	 esi
  00704	57		 push	 edi
  00705	e8 00 00 00 00	 call	 ?CGMiningEnd@@YAXPAUPMSG_MINING_END@@H@Z ; CGMiningEnd
  0070a	83 c4 08	 add	 esp, 8
  0070d	5f		 pop	 edi
  0070e	5e		 pop	 esi
  0070f	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00710	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00713	33 cd		 xor	 ecx, ebp
  00715	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0071a	8b e5		 mov	 esp, ebp
  0071c	5d		 pop	 ebp
  0071d	c3		 ret	 0
$LN146@ProtocolCo:

; 494  : 						break;
; 495  : 					case 1:
; 496  : 						CGRewardRequest((PMSG_MINING_REWARD_REQUEST*)aRecv,aIndex);

  0071e	56		 push	 esi
  0071f	57		 push	 edi
  00720	e8 00 00 00 00	 call	 ?CGRewardRequest@@YAXPAUPMSG_MINING_REWARD_REQUEST@@H@Z ; CGRewardRequest
  00725	83 c4 08	 add	 esp, 8
  00728	5f		 pop	 edi
  00729	5e		 pop	 esi
  0072a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0072b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0072e	33 cd		 xor	 ecx, ebp
  00730	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00735	8b e5		 mov	 esp, ebp
  00737	5d		 pop	 ebp
  00738	c3		 ret	 0
$LN145@ProtocolCo:

; 491  : 					{
; 492  : 					case 0:
; 493  : 						CGMiningRequest((PMSG_MINING_REQUEST*)aRecv,aIndex);

  00739	56		 push	 esi
  0073a	57		 push	 edi
  0073b	e8 00 00 00 00	 call	 ?CGMiningRequest@@YAXPAUPMSG_MINING_REQUEST@@H@Z ; CGMiningRequest
  00740	83 c4 08	 add	 esp, 8
  00743	5f		 pop	 edi
  00744	5e		 pop	 esi
  00745	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00746	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00749	33 cd		 xor	 ecx, ebp
  0074b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00750	8b e5		 mov	 esp, ebp
  00752	5d		 pop	 ebp
  00753	c3		 ret	 0
$LN148@ProtocolCo:

; 500  : 						break;
; 501  : 					}
; 502  : 				}
; 503  : 				break;
; 504  : #if (ENABLETEST_RUMMY == 1)
; 505  : 			case 0x4D:
; 506  : 				{
; 507  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 508  : 
; 509  : 					switch (lpDef->subcode)
; 510  : 					{
; 511  : 					case 0:
; 512  : 					  //if ( DataEncryptCheck(aIndex, protoNum, Encrypt) )
; 513  : 						//CGEventItemGetRequest((PMSG_EVENTITEM_GETREQUEST *)aRecv, aIndex);
; 514  : 					  break;
; 515  : 					case 1:
; 516  : 					  //CGEventItemDropRequest((PMSG_EVENTITEM_THROW*)aRecv, aIndex);
; 517  : 					  break;
; 518  : 					case 0xF:
; 519  : 					  g_CMuRummyMng.CGReqMuRummyEventOpen((_tagPMSG_REQ_MURUMMY_EVENT_OPEN*)aRecv, aIndex);
; 520  : 					  break;
; 521  : 					case 0x10:
; 522  : 					  g_CMuRummyMng.CGReqMuRummyStart((_tagPMSG_REQ_MURUMMY_INFO*)aRecv, aIndex);
; 523  : 					  break;
; 524  : 					case 0x11:
; 525  : 					  g_CMuRummyMng.CGReqCardReveal((_tagPMSG_REQ_REVEAL_CARD*)aRecv, aIndex);
; 526  : 					  break;
; 527  : 					case 0x12:
; 528  : 					  g_CMuRummyMng.CGReqCardMove((_tagPMSG_REQ_CARD_MOVE*)aRecv, aIndex);
; 529  : 					  break;
; 530  : 					case 0x13:
; 531  : 					  g_CMuRummyMng.CGReqCardReMove((_tagPMSG_REQ_CARD_REMOVE*)aRecv, aIndex);
; 532  : 					  break;
; 533  : 					case 0x14:
; 534  : 					  g_CMuRummyMng.CGReqCardMatch((_tagPMSG_REQ_CARD_MATCH*)aRecv, aIndex);
; 535  : 					  break;
; 536  : 					case 0x15:
; 537  : 					  g_CMuRummyMng.CGReqMuRummyEnd((_tagPMSG_REQ_MURUMMY_END*)aRecv, aIndex);
; 538  : 					  break;
; 539  : 					}
; 540  : 				}
; 541  : 				break;
; 542  : #endif
; 543  : #if (ENABLETEST_MUUN == 1)
; 544  : 			case 0x4E:
; 545  : 				{
; 546  : 					PMSG_DEFAULT2* lpDef = (PMSG_DEFAULT2*)aRecv;
; 547  : 					switch (lpDef->subcode) 
; 548  : 					{
; 549  : 					case 0:
; 550  : 						if (DataEncryptCheck(aIndex, protoNum, Encrypt)) {
; 551  : 							CGMuunItemGetRequest((PMSG_MUUNITEM_GETREQUEST*)aRecv, aIndex);
; 552  : 						}
; 553  : 						break;
; 554  : 					case 8:
; 555  : 						g_CMuunSystem.CGMuunInventoryUseItemRecv((PMSG_USEITEM_MUUN_INVEN*)aRecv, aIndex);
; 556  : 						break;
; 557  : 					case 9:
; 558  : 						if (DataEncryptCheck(aIndex, protoNum, Encrypt)) {
; 559  : 							CGMuunItemSellRequestRecv((PMSG_MUUN_ITEM_SELLREQUEST*)aRecv, aIndex);
; 560  : 						}
; 561  : 						break;
; 562  : 					}
; 563  : 					break;
; 564  : 				}
; 565  : 				break;
; 566  : #endif
; 567  : 			case 0x50:
; 568  : 				CGGuildRequestRecv((PMSG_GUILDJOINQ *)aRecv, aIndex);

  00754	56		 push	 esi
  00755	57		 push	 edi
  00756	e8 00 00 00 00	 call	 ?CGGuildRequestRecv@@YAXPAUPMSG_GUILDJOINQ@@H@Z ; CGGuildRequestRecv
  0075b	83 c4 08	 add	 esp, 8
  0075e	5f		 pop	 edi
  0075f	5e		 pop	 esi
  00760	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00761	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00764	33 cd		 xor	 ecx, ebp
  00766	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0076b	8b e5		 mov	 esp, ebp
  0076d	5d		 pop	 ebp
  0076e	c3		 ret	 0
$LN149@ProtocolCo:

; 569  : 				break;
; 570  : 			case 0x51:
; 571  : 				CGGuildRequestResultRecv((PMSG_GUILDQRESULT *)aRecv, aIndex);

  0076f	56		 push	 esi
  00770	57		 push	 edi
  00771	e8 00 00 00 00	 call	 ?CGGuildRequestResultRecv@@YAXPAUPMSG_GUILDQRESULT@@H@Z ; CGGuildRequestResultRecv
  00776	83 c4 08	 add	 esp, 8
  00779	5f		 pop	 edi
  0077a	5e		 pop	 esi
  0077b	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0077c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0077f	33 cd		 xor	 ecx, ebp
  00781	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00786	8b e5		 mov	 esp, ebp
  00788	5d		 pop	 ebp
  00789	c3		 ret	 0
$LN150@ProtocolCo:

; 572  : 				break;
; 573  : 			case 0x52:
; 574  : 				CGGuildListAll(aIndex);

  0078a	56		 push	 esi
  0078b	e8 00 00 00 00	 call	 ?CGGuildListAll@@YAXH@Z	; CGGuildListAll
  00790	83 c4 04	 add	 esp, 4
  00793	5f		 pop	 edi
  00794	5e		 pop	 esi
  00795	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00796	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00799	33 cd		 xor	 ecx, ebp
  0079b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007a0	8b e5		 mov	 esp, ebp
  007a2	5d		 pop	 ebp
  007a3	c3		 ret	 0
$LN151@ProtocolCo:

; 575  : 				break;
; 576  : 			case 0x53:
; 577  : 				CGGuildDelUser((PMSG_GUILDDELUSER *)aRecv, aIndex);

  007a4	56		 push	 esi
  007a5	57		 push	 edi
  007a6	e8 00 00 00 00	 call	 ?CGGuildDelUser@@YAXPAUPMSG_GUILDDELUSER@@H@Z ; CGGuildDelUser
  007ab	83 c4 08	 add	 esp, 8
  007ae	5f		 pop	 edi
  007af	5e		 pop	 esi
  007b0	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  007b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007b4	33 cd		 xor	 ecx, ebp
  007b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007bb	8b e5		 mov	 esp, ebp
  007bd	5d		 pop	 ebp
  007be	c3		 ret	 0
$LN152@ProtocolCo:

; 578  : 				break;
; 579  : 			case 0x54:
; 580  : 				CGGuildMasterAnswerRecv((PMSG_GUILDMASTERANSWER *)aRecv, aIndex);

  007bf	56		 push	 esi
  007c0	57		 push	 edi
  007c1	e8 00 00 00 00	 call	 ?CGGuildMasterAnswerRecv@@YAXPAUPMSG_GUILDMASTERANSWER@@H@Z ; CGGuildMasterAnswerRecv
  007c6	83 c4 08	 add	 esp, 8
  007c9	5f		 pop	 edi
  007ca	5e		 pop	 esi
  007cb	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  007cc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007cf	33 cd		 xor	 ecx, ebp
  007d1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007d6	8b e5		 mov	 esp, ebp
  007d8	5d		 pop	 ebp
  007d9	c3		 ret	 0
$LN153@ProtocolCo:

; 581  : 				break;
; 582  : 			case 0x55:
; 583  : 				CGGuildMasterInfoSave(aIndex, (PMSG_GUILDINFOSAVE *)aRecv);

  007da	57		 push	 edi
  007db	56		 push	 esi
  007dc	e8 00 00 00 00	 call	 ?CGGuildMasterInfoSave@@YAXHPAUPMSG_GUILDINFOSAVE@@@Z ; CGGuildMasterInfoSave
  007e1	83 c4 08	 add	 esp, 8
  007e4	5f		 pop	 edi
  007e5	5e		 pop	 esi
  007e6	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  007e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ea	33 cd		 xor	 ecx, ebp
  007ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007f1	8b e5		 mov	 esp, ebp
  007f3	5d		 pop	 ebp
  007f4	c3		 ret	 0
$LN154@ProtocolCo:

; 584  : 				break;
; 585  : 			case 0x57:
; 586  : 				CGGuildMasterCreateCancel(aIndex);

  007f5	56		 push	 esi
  007f6	e8 00 00 00 00	 call	 ?CGGuildMasterCreateCancel@@YAXH@Z ; CGGuildMasterCreateCancel
  007fb	83 c4 04	 add	 esp, 4
  007fe	5f		 pop	 edi
  007ff	5e		 pop	 esi
  00800	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00801	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00804	33 cd		 xor	 ecx, ebp
  00806	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0080b	8b e5		 mov	 esp, ebp
  0080d	5d		 pop	 ebp
  0080e	c3		 ret	 0
$LN155@ProtocolCo:

; 587  : 				break;
; 588  : 			case 0x61:
; 589  : 				GCGuildWarRequestSendRecv((PMSG_GUILDWARSEND_RESULT *)aRecv, aIndex);

  0080f	56		 push	 esi
  00810	57		 push	 edi
  00811	e8 00 00 00 00	 call	 ?GCGuildWarRequestSendRecv@@YAXPAUPMSG_GUILDWARSEND_RESULT@@H@Z ; GCGuildWarRequestSendRecv
  00816	83 c4 08	 add	 esp, 8
  00819	5f		 pop	 edi
  0081a	5e		 pop	 esi
  0081b	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0081c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081f	33 cd		 xor	 ecx, ebp
  00821	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00826	8b e5		 mov	 esp, ebp
  00828	5d		 pop	 ebp
  00829	c3		 ret	 0
$LN156@ProtocolCo:

; 590  : 				break;
; 591  : 			case 0x66:
; 592  : 				GCGuildViewportInfo((PMSG_REQ_GUILDVIEWPORT *)aRecv, aIndex);

  0082a	56		 push	 esi
  0082b	57		 push	 edi
  0082c	e8 00 00 00 00	 call	 ?GCGuildViewportInfo@@YAXPAUPMSG_REQ_GUILDVIEWPORT@@H@Z ; GCGuildViewportInfo
  00831	83 c4 08	 add	 esp, 8
  00834	5f		 pop	 edi
  00835	5e		 pop	 esi
  00836	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00837	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0083a	33 cd		 xor	 ecx, ebp
  0083c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00841	8b e5		 mov	 esp, ebp
  00843	5d		 pop	 ebp
  00844	c3		 ret	 0
$LN157@ProtocolCo:

; 593  : 				break;
; 594  : 			case 0xB1:
; 595  : 				{
; 596  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 597  : 					
; 598  : 					switch ( lpDef->subcode )

  00845	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00849	83 e8 01	 sub	 eax, 1
  0084c	0f 85 7d 13 00
	00		 jne	 $LN67@ProtocolCo

; 599  : 					{
; 600  : 						case 0x01:
; 601  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  00852	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  00855	53		 push	 ebx
  00856	56		 push	 esi
  00857	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0085c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0085f	85 c0		 test	 eax, eax
  00861	0f 84 68 13 00
	00		 je	 $LN67@ProtocolCo

; 602  : 							{
; 603  : 								CGReqMapSvrAuth((PMSG_REQ_MAPSERVERAUTH *)aRecv, aIndex);

  00867	56		 push	 esi
  00868	57		 push	 edi
  00869	e8 00 00 00 00	 call	 ?CGReqMapSvrAuth@@YAXPAUPMSG_REQ_MAPSERVERAUTH@@H@Z ; CGReqMapSvrAuth
  0086e	83 c4 08	 add	 esp, 8
  00871	5f		 pop	 edi
  00872	5e		 pop	 esi
  00873	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00874	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00877	33 cd		 xor	 ecx, ebp
  00879	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0087e	8b e5		 mov	 esp, ebp
  00880	5d		 pop	 ebp
  00881	c3		 ret	 0
$LN160@ProtocolCo:

; 604  : 							}
; 605  : 							break;
; 606  : 					}
; 607  : 				}
; 608  : 				break;
; 609  : 			case 0xB2:
; 610  : 				{
; 611  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 612  : 
; 613  : 					switch ( lpDef->subcode )

  00882	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00886	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00889	0f 87 40 13 00
	00		 ja	 $LN67@ProtocolCo
  0088f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN342@ProtocolCo[eax]
  00896	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN356@ProtocolCo[eax*4]
$LN161@ProtocolCo:

; 614  : 					{
; 615  : 						case 0x00:
; 616  : 							CGReqCastleSiegeState((PMSG_REQ_CASTLESIEGESTATE *)aRecv, aIndex);

  0089d	56		 push	 esi
  0089e	57		 push	 edi
  0089f	e8 00 00 00 00	 call	 ?CGReqCastleSiegeState@@YAXPAUPMSG_REQ_CASTLESIEGESTATE@@H@Z ; CGReqCastleSiegeState
  008a4	83 c4 08	 add	 esp, 8
  008a7	5f		 pop	 edi
  008a8	5e		 pop	 esi
  008a9	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  008aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008ad	33 cd		 xor	 ecx, ebp
  008af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008b4	8b e5		 mov	 esp, ebp
  008b6	5d		 pop	 ebp
  008b7	c3		 ret	 0
$LN162@ProtocolCo:

; 617  : 							break;
; 618  : 						case 0x01:
; 619  : 							CGReqRegCastleSiege((PMSG_REQ_REGCASTLESIEGE *)aRecv, aIndex);

  008b8	56		 push	 esi
  008b9	57		 push	 edi
  008ba	e8 00 00 00 00	 call	 ?CGReqRegCastleSiege@@YAXPAUPMSG_REQ_REGCASTLESIEGE@@H@Z ; CGReqRegCastleSiege
  008bf	83 c4 08	 add	 esp, 8
  008c2	5f		 pop	 edi
  008c3	5e		 pop	 esi
  008c4	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  008c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008c8	33 cd		 xor	 ecx, ebp
  008ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008cf	8b e5		 mov	 esp, ebp
  008d1	5d		 pop	 ebp
  008d2	c3		 ret	 0
$LN163@ProtocolCo:

; 620  : 							break;
; 621  : 						case 0x02:
; 622  : 							CGReqGiveUpCastleSiege((PMSG_REQ_GIVEUPCASTLESIEGE *)aRecv, aIndex);

  008d3	56		 push	 esi
  008d4	57		 push	 edi
  008d5	e8 00 00 00 00	 call	 ?CGReqGiveUpCastleSiege@@YAXPAUPMSG_REQ_GIVEUPCASTLESIEGE@@H@Z ; CGReqGiveUpCastleSiege
  008da	83 c4 08	 add	 esp, 8
  008dd	5f		 pop	 edi
  008de	5e		 pop	 esi
  008df	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  008e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008e3	33 cd		 xor	 ecx, ebp
  008e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008ea	8b e5		 mov	 esp, ebp
  008ec	5d		 pop	 ebp
  008ed	c3		 ret	 0
$LN164@ProtocolCo:

; 623  : 							break;
; 624  : 						case 0x03:
; 625  : 							CGReqGuildRegInfo((PMSG_REQ_GUILDREGINFO *)aRecv, aIndex);

  008ee	56		 push	 esi
  008ef	57		 push	 edi
  008f0	e8 00 00 00 00	 call	 ?CGReqGuildRegInfo@@YAXPAUPMSG_REQ_GUILDREGINFO@@H@Z ; CGReqGuildRegInfo
  008f5	83 c4 08	 add	 esp, 8
  008f8	5f		 pop	 edi
  008f9	5e		 pop	 esi
  008fa	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  008fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008fe	33 cd		 xor	 ecx, ebp
  00900	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00905	8b e5		 mov	 esp, ebp
  00907	5d		 pop	 ebp
  00908	c3		 ret	 0
$LN165@ProtocolCo:

; 626  : 							break;
; 627  : 						case 0x04:
; 628  : 							CGReqRegGuildMark((PMSG_REQ_REGGUILDMARK *)aRecv, aIndex);

  00909	56		 push	 esi
  0090a	57		 push	 edi
  0090b	e8 00 00 00 00	 call	 ?CGReqRegGuildMark@@YAXPAUPMSG_REQ_REGGUILDMARK@@H@Z ; CGReqRegGuildMark
  00910	83 c4 08	 add	 esp, 8
  00913	5f		 pop	 edi
  00914	5e		 pop	 esi
  00915	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00916	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00919	33 cd		 xor	 ecx, ebp
  0091b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00920	8b e5		 mov	 esp, ebp
  00922	5d		 pop	 ebp
  00923	c3		 ret	 0
$LN166@ProtocolCo:

; 629  : 							break;
; 630  : 						case 0x05:
; 631  : 							CGReqNpcBuy((PMSG_REQ_NPCBUY *)aRecv, aIndex);

  00924	56		 push	 esi
  00925	57		 push	 edi
  00926	e8 00 00 00 00	 call	 ?CGReqNpcBuy@@YAXPAUPMSG_REQ_NPCBUY@@H@Z ; CGReqNpcBuy
  0092b	83 c4 08	 add	 esp, 8
  0092e	5f		 pop	 edi
  0092f	5e		 pop	 esi
  00930	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00931	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00934	33 cd		 xor	 ecx, ebp
  00936	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0093b	8b e5		 mov	 esp, ebp
  0093d	5d		 pop	 ebp
  0093e	c3		 ret	 0
$LN167@ProtocolCo:

; 632  : 							break;
; 633  : 						case 0x06:
; 634  : 							CGReqNpcRepair((PMSG_REQ_NPCREPAIR *)aRecv, aIndex);

  0093f	56		 push	 esi
  00940	57		 push	 edi
  00941	e8 00 00 00 00	 call	 ?CGReqNpcRepair@@YAXPAUPMSG_REQ_NPCREPAIR@@H@Z ; CGReqNpcRepair
  00946	83 c4 08	 add	 esp, 8
  00949	5f		 pop	 edi
  0094a	5e		 pop	 esi
  0094b	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0094c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0094f	33 cd		 xor	 ecx, ebp
  00951	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00956	8b e5		 mov	 esp, ebp
  00958	5d		 pop	 ebp
  00959	c3		 ret	 0
$LN168@ProtocolCo:

; 635  : 							break;
; 636  : 						case 0x07:
; 637  : 							CGReqNpcUpgrade((PMSG_REQ_NPCUPGRADE *)aRecv, aIndex);

  0095a	56		 push	 esi
  0095b	57		 push	 edi
  0095c	e8 00 00 00 00	 call	 ?CGReqNpcUpgrade@@YAXPAUPMSG_REQ_NPCUPGRADE@@H@Z ; CGReqNpcUpgrade
  00961	83 c4 08	 add	 esp, 8
  00964	5f		 pop	 edi
  00965	5e		 pop	 esi
  00966	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00967	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0096a	33 cd		 xor	 ecx, ebp
  0096c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00971	8b e5		 mov	 esp, ebp
  00973	5d		 pop	 ebp
  00974	c3		 ret	 0
$LN169@ProtocolCo:

; 638  : 							break;
; 639  : 						case 0x08:
; 640  : 							CGReqTaxMoneyInfo((PMSG_REQ_TAXMONEYINFO *)aRecv, aIndex);

  00975	56		 push	 esi
  00976	57		 push	 edi
  00977	e8 00 00 00 00	 call	 ?CGReqTaxMoneyInfo@@YAXPAUPMSG_REQ_TAXMONEYINFO@@H@Z ; CGReqTaxMoneyInfo
  0097c	83 c4 08	 add	 esp, 8
  0097f	5f		 pop	 edi
  00980	5e		 pop	 esi
  00981	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00982	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00985	33 cd		 xor	 ecx, ebp
  00987	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0098c	8b e5		 mov	 esp, ebp
  0098e	5d		 pop	 ebp
  0098f	c3		 ret	 0
$LN170@ProtocolCo:

; 641  : 							break;
; 642  : 						case 0x09:
; 643  : 							CGReqTaxRateChange((PMSG_REQ_TAXRATECHANGE *)aRecv, aIndex);

  00990	56		 push	 esi
  00991	57		 push	 edi
  00992	e8 00 00 00 00	 call	 ?CGReqTaxRateChange@@YAXPAUPMSG_REQ_TAXRATECHANGE@@H@Z ; CGReqTaxRateChange
  00997	83 c4 08	 add	 esp, 8
  0099a	5f		 pop	 edi
  0099b	5e		 pop	 esi
  0099c	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0099d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009a0	33 cd		 xor	 ecx, ebp
  009a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009a7	8b e5		 mov	 esp, ebp
  009a9	5d		 pop	 ebp
  009aa	c3		 ret	 0
$LN171@ProtocolCo:

; 644  : 							break;
; 645  : 						case 0x10:
; 646  : 							CGReqMoneyDrawOut((PMSG_REQ_MONEYDRAWOUT *)aRecv, aIndex);

  009ab	56		 push	 esi
  009ac	57		 push	 edi
  009ad	e8 00 00 00 00	 call	 ?CGReqMoneyDrawOut@@YAXPAUPMSG_REQ_MONEYDRAWOUT@@H@Z ; CGReqMoneyDrawOut
  009b2	83 c4 08	 add	 esp, 8
  009b5	5f		 pop	 edi
  009b6	5e		 pop	 esi
  009b7	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  009b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009bb	33 cd		 xor	 ecx, ebp
  009bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009c2	8b e5		 mov	 esp, ebp
  009c4	5d		 pop	 ebp
  009c5	c3		 ret	 0
$LN172@ProtocolCo:

; 647  : 							break;
; 648  : 						case 0x12:
; 649  : 							CGReqCsGateOperate((PMSG_REQ_CSGATEOPERATE *)aRecv, aIndex);

  009c6	56		 push	 esi
  009c7	57		 push	 edi
  009c8	e8 00 00 00 00	 call	 ?CGReqCsGateOperate@@YAXPAUPMSG_REQ_CSGATEOPERATE@@H@Z ; CGReqCsGateOperate
  009cd	83 c4 08	 add	 esp, 8
  009d0	5f		 pop	 edi
  009d1	5e		 pop	 esi
  009d2	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  009d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009d6	33 cd		 xor	 ecx, ebp
  009d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009dd	8b e5		 mov	 esp, ebp
  009df	5d		 pop	 ebp
  009e0	c3		 ret	 0
$LN173@ProtocolCo:

; 650  : 							break;
; 651  : 						case 0x1B:
; 652  : 							CGReqCsMiniMapData((PMSG_REQ_MINIMAPDATA *)aRecv, aIndex);

  009e1	56		 push	 esi
  009e2	57		 push	 edi
  009e3	e8 00 00 00 00	 call	 ?CGReqCsMiniMapData@@YAXPAUPMSG_REQ_MINIMAPDATA@@H@Z ; CGReqCsMiniMapData
  009e8	83 c4 08	 add	 esp, 8
  009eb	5f		 pop	 edi
  009ec	5e		 pop	 esi
  009ed	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  009ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  009f1	33 cd		 xor	 ecx, ebp
  009f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009f8	8b e5		 mov	 esp, ebp
  009fa	5d		 pop	 ebp
  009fb	c3		 ret	 0
$LN174@ProtocolCo:

; 653  : 							break;
; 654  : 						case 0x1C:
; 655  : 							CGReqStopCsMiniMapData((PMSG_REQ_STOPMINIMAPDATA *)aRecv, aIndex);

  009fc	56		 push	 esi
  009fd	57		 push	 edi
  009fe	e8 00 00 00 00	 call	 ?CGReqStopCsMiniMapData@@YAXPAUPMSG_REQ_STOPMINIMAPDATA@@H@Z ; CGReqStopCsMiniMapData
  00a03	83 c4 08	 add	 esp, 8
  00a06	5f		 pop	 edi
  00a07	5e		 pop	 esi
  00a08	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00a09	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a0c	33 cd		 xor	 ecx, ebp
  00a0e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a13	8b e5		 mov	 esp, ebp
  00a15	5d		 pop	 ebp
  00a16	c3		 ret	 0
$LN175@ProtocolCo:

; 656  : 							break;
; 657  : 						case 0x1D:
; 658  : 							CGReqCsSendCommand((PMSG_REQ_CSCOMMAND *)aRecv, aIndex);

  00a17	56		 push	 esi
  00a18	57		 push	 edi
  00a19	e8 00 00 00 00	 call	 ?CGReqCsSendCommand@@YAXPAUPMSG_REQ_CSCOMMAND@@H@Z ; CGReqCsSendCommand
  00a1e	83 c4 08	 add	 esp, 8
  00a21	5f		 pop	 edi
  00a22	5e		 pop	 esi
  00a23	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00a24	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a27	33 cd		 xor	 ecx, ebp
  00a29	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a2e	8b e5		 mov	 esp, ebp
  00a30	5d		 pop	 ebp
  00a31	c3		 ret	 0
$LN176@ProtocolCo:

; 659  : 							break;
; 660  : 						case 0x1F:
; 661  : 							CGReqCsSetEnterHuntZone((PMSG_REQ_CSHUNTZONEENTER *)aRecv, aIndex);

  00a32	56		 push	 esi
  00a33	57		 push	 edi
  00a34	e8 00 00 00 00	 call	 ?CGReqCsSetEnterHuntZone@@YAXPAUPMSG_REQ_CSHUNTZONEENTER@@H@Z ; CGReqCsSetEnterHuntZone
  00a39	83 c4 08	 add	 esp, 8
  00a3c	5f		 pop	 edi
  00a3d	5e		 pop	 esi
  00a3e	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00a3f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a42	33 cd		 xor	 ecx, ebp
  00a44	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a49	8b e5		 mov	 esp, ebp
  00a4b	5d		 pop	 ebp
  00a4c	c3		 ret	 0
$LN177@ProtocolCo:

; 662  : 							break;
; 663  : 					}
; 664  : 				}
; 665  : 				break;
; 666  : 			case 0xB3:
; 667  : 				CGReqNpcDbList((PMSG_REQ_NPCDBLIST *)aRecv, aIndex);

  00a4d	56		 push	 esi
  00a4e	57		 push	 edi
  00a4f	e8 00 00 00 00	 call	 ?CGReqNpcDbList@@YAXPAUPMSG_REQ_NPCDBLIST@@H@Z ; CGReqNpcDbList
  00a54	83 c4 08	 add	 esp, 8
  00a57	5f		 pop	 edi
  00a58	5e		 pop	 esi
  00a59	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00a5a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a5d	33 cd		 xor	 ecx, ebp
  00a5f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a64	8b e5		 mov	 esp, ebp
  00a66	5d		 pop	 ebp
  00a67	c3		 ret	 0
$LN178@ProtocolCo:

; 668  : 				break;
; 669  : 			case 0xB4:
; 670  : 				CGReqCsRegGuildList((PMSG_REQ_CSREGGUILDLIST *)aRecv, aIndex);

  00a68	56		 push	 esi
  00a69	57		 push	 edi
  00a6a	e8 00 00 00 00	 call	 ?CGReqCsRegGuildList@@YAXPAUPMSG_REQ_CSREGGUILDLIST@@H@Z ; CGReqCsRegGuildList
  00a6f	83 c4 08	 add	 esp, 8
  00a72	5f		 pop	 edi
  00a73	5e		 pop	 esi
  00a74	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00a75	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a78	33 cd		 xor	 ecx, ebp
  00a7a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a7f	8b e5		 mov	 esp, ebp
  00a81	5d		 pop	 ebp
  00a82	c3		 ret	 0
$LN179@ProtocolCo:

; 671  : 				break;
; 672  : 			case 0xB5:
; 673  : 				CGReqCsAttkGuildList((PMSG_REQ_CSATTKGUILDLIST *)aRecv, aIndex);

  00a83	56		 push	 esi
  00a84	57		 push	 edi
  00a85	e8 00 00 00 00	 call	 ?CGReqCsAttkGuildList@@YAXPAUPMSG_REQ_CSATTKGUILDLIST@@H@Z ; CGReqCsAttkGuildList
  00a8a	83 c4 08	 add	 esp, 8
  00a8d	5f		 pop	 edi
  00a8e	5e		 pop	 esi
  00a8f	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00a90	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a93	33 cd		 xor	 ecx, ebp
  00a95	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a9a	8b e5		 mov	 esp, ebp
  00a9c	5d		 pop	 ebp
  00a9d	c3		 ret	 0
$LN180@ProtocolCo:

; 674  : 				break;
; 675  : 			case 0xB7:
; 676  : 				{
; 677  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 678  : 
; 679  : 					switch ( lpDef->subcode )

  00a9e	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00aa2	83 e8 01	 sub	 eax, 1
  00aa5	74 24		 je	 SHORT $LN181@ProtocolCo
  00aa7	83 e8 03	 sub	 eax, 3
  00aaa	0f 85 1f 11 00
	00		 jne	 $LN67@ProtocolCo

; 683  : 							break;
; 684  : 						case 0x04:
; 685  : 							CGReqWeaponDamageValue((PMSG_REQ_WEAPON_DAMAGE_VALUE *)aRecv, aIndex);

  00ab0	56		 push	 esi
  00ab1	57		 push	 edi
  00ab2	e8 00 00 00 00	 call	 ?CGReqWeaponDamageValue@@YAXPAUPMSG_REQ_WEAPON_DAMAGE_VALUE@@H@Z ; CGReqWeaponDamageValue
  00ab7	83 c4 08	 add	 esp, 8
  00aba	5f		 pop	 edi
  00abb	5e		 pop	 esi
  00abc	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00abd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ac0	33 cd		 xor	 ecx, ebp
  00ac2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ac7	8b e5		 mov	 esp, ebp
  00ac9	5d		 pop	 ebp
  00aca	c3		 ret	 0
$LN181@ProtocolCo:

; 680  : 					{
; 681  : 						case 0x01:
; 682  : 							CGReqWeaponUse((PMSG_REQ_USEWEAPON *)aRecv, aIndex);

  00acb	56		 push	 esi
  00acc	57		 push	 edi
  00acd	e8 00 00 00 00	 call	 ?CGReqWeaponUse@@YAXPAUPMSG_REQ_USEWEAPON@@H@Z ; CGReqWeaponUse
  00ad2	83 c4 08	 add	 esp, 8
  00ad5	5f		 pop	 edi
  00ad6	5e		 pop	 esi
  00ad7	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00ad8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00adb	33 cd		 xor	 ecx, ebp
  00add	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ae2	8b e5		 mov	 esp, ebp
  00ae4	5d		 pop	 ebp
  00ae5	c3		 ret	 0
$LN183@ProtocolCo:

; 686  : 							break;
; 687  : 					}
; 688  : 				}
; 689  : 				break;
; 690  : 			case 0xB9:
; 691  : 				{
; 692  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 693  : 
; 694  : 					switch ( lpDef->subcode )

  00ae6	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00aea	83 e8 02	 sub	 eax, 2
  00aed	74 24		 je	 SHORT $LN184@ProtocolCo
  00aef	83 e8 03	 sub	 eax, 3
  00af2	0f 85 d7 10 00
	00		 jne	 $LN67@ProtocolCo

; 698  : 							break;
; 699  : 						case 0x05:
; 700  : 							CGReqCastleHuntZoneEntrance((PMSG_REQ_MOVE_TO_CASTLE_HUNTZONE *)aRecv,aIndex);

  00af8	56		 push	 esi
  00af9	57		 push	 edi
  00afa	e8 00 00 00 00	 call	 ?CGReqCastleHuntZoneEntrance@@YAXPAUPMSG_REQ_MOVE_TO_CASTLE_HUNTZONE@@H@Z ; CGReqCastleHuntZoneEntrance
  00aff	83 c4 08	 add	 esp, 8
  00b02	5f		 pop	 edi
  00b03	5e		 pop	 esi
  00b04	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00b05	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b08	33 cd		 xor	 ecx, ebp
  00b0a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b0f	8b e5		 mov	 esp, ebp
  00b11	5d		 pop	 ebp
  00b12	c3		 ret	 0
$LN184@ProtocolCo:

; 695  : 					{
; 696  : 						case 0x02:
; 697  : 							CGReqGuildMarkOfCastleOwner((PMSG_REQ_GUILDMARK_OF_CASTLEOWNER *)aRecv, aIndex);

  00b13	56		 push	 esi
  00b14	57		 push	 edi
  00b15	e8 00 00 00 00	 call	 ?CGReqGuildMarkOfCastleOwner@@YAXPAUPMSG_REQ_GUILDMARK_OF_CASTLEOWNER@@H@Z ; CGReqGuildMarkOfCastleOwner
  00b1a	83 c4 08	 add	 esp, 8
  00b1d	5f		 pop	 edi
  00b1e	5e		 pop	 esi
  00b1f	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00b20	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b23	33 cd		 xor	 ecx, ebp
  00b25	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b2a	8b e5		 mov	 esp, ebp
  00b2c	5d		 pop	 ebp
  00b2d	c3		 ret	 0
$LN186@ProtocolCo:

; 701  : 							break;
; 702  : 					}
; 703  : 				}
; 704  : 				break;
; 705  : 			case 0xBC:
; 706  : 				{
; 707  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 708  : 
; 709  : 					switch ( lpDef->subcode )

  00b2e	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00b32	83 e8 00	 sub	 eax, 0
  00b35	74 24		 je	 SHORT $LN187@ProtocolCo
  00b37	83 e8 01	 sub	 eax, 1
  00b3a	0f 85 8f 10 00
	00		 jne	 $LN67@ProtocolCo

; 713  : 							break;
; 714  : 						case 0x01:
; 715  : 							CGReqJewelUnMix((PMSG_REQ_JEWEL_UNMIX *)aRecv, aIndex);

  00b40	56		 push	 esi
  00b41	57		 push	 edi
  00b42	e8 00 00 00 00	 call	 ?CGReqJewelUnMix@@YAXPAUPMSG_REQ_JEWEL_UNMIX@@H@Z ; CGReqJewelUnMix
  00b47	83 c4 08	 add	 esp, 8
  00b4a	5f		 pop	 edi
  00b4b	5e		 pop	 esi
  00b4c	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00b4d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b50	33 cd		 xor	 ecx, ebp
  00b52	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b57	8b e5		 mov	 esp, ebp
  00b59	5d		 pop	 ebp
  00b5a	c3		 ret	 0
$LN187@ProtocolCo:

; 710  : 					{
; 711  : 						case 0x00:
; 712  : 							CGReqJewelMix((PMSG_REQ_JEWEL_MIX *)aRecv, aIndex);

  00b5b	56		 push	 esi
  00b5c	57		 push	 edi
  00b5d	e8 00 00 00 00	 call	 ?CGReqJewelMix@@YAXPAUPMSG_REQ_JEWEL_MIX@@H@Z ; CGReqJewelMix
  00b62	83 c4 08	 add	 esp, 8
  00b65	5f		 pop	 edi
  00b66	5e		 pop	 esi
  00b67	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00b68	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b6b	33 cd		 xor	 ecx, ebp
  00b6d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b72	8b e5		 mov	 esp, ebp
  00b74	5d		 pop	 ebp
  00b75	c3		 ret	 0
$LN189@ProtocolCo:

; 716  : 							break;
; 717  : 					}
; 718  : 				}
; 719  : 				break;
; 720  : 			case 0xBD:
; 721  : 				{
; 722  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 723  : 
; 724  : 					switch ( lpDef->subcode )

  00b76	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00b79	84 c0		 test	 al, al
  00b7b	74 42		 je	 SHORT $LN190@ProtocolCo
  00b7d	3c 03		 cmp	 al, 3
  00b7f	74 23		 je	 SHORT $LN191@ProtocolCo
  00b81	3c 09		 cmp	 al, 9
  00b83	0f 85 46 10 00
	00		 jne	 $LN67@ProtocolCo

; 731  : 							break;
; 732  : 						case 0x09:
; 733  : 							CGReqPlusChaosRate((PMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE *)aRecv, aIndex);

  00b89	56		 push	 esi
  00b8a	57		 push	 edi
  00b8b	e8 00 00 00 00	 call	 ?CGReqPlusChaosRate@@YAXPAUPMSG_REQ_CRYWOLF_BENEFIT_PLUS_CHAOSRATE@@H@Z ; CGReqPlusChaosRate
  00b90	83 c4 08	 add	 esp, 8
  00b93	5f		 pop	 edi
  00b94	5e		 pop	 esi
  00b95	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00b96	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b99	33 cd		 xor	 ecx, ebp
  00b9b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ba0	8b e5		 mov	 esp, ebp
  00ba2	5d		 pop	 ebp
  00ba3	c3		 ret	 0
$LN191@ProtocolCo:

; 728  : 							break;
; 729  : 						case 0x03:
; 730  : 							CGReqAlatrContract((PMSG_REQ_CRYWOLF_ALTAR_CONTRACT *)aRecv, aIndex);

  00ba4	56		 push	 esi
  00ba5	57		 push	 edi
  00ba6	e8 00 00 00 00	 call	 ?CGReqAlatrContract@@YAXPAUPMSG_REQ_CRYWOLF_ALTAR_CONTRACT@@H@Z ; CGReqAlatrContract
  00bab	83 c4 08	 add	 esp, 8
  00bae	5f		 pop	 edi
  00baf	5e		 pop	 esi
  00bb0	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00bb1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bb4	33 cd		 xor	 ecx, ebp
  00bb6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bbb	8b e5		 mov	 esp, ebp
  00bbd	5d		 pop	 ebp
  00bbe	c3		 ret	 0
$LN190@ProtocolCo:

; 725  : 					{
; 726  : 						case 0x00:
; 727  : 							CGReqCrywolfInfo((PMSG_REQ_CRYWOLF_INFO *)aRecv, aIndex);

  00bbf	56		 push	 esi
  00bc0	57		 push	 edi
  00bc1	e8 00 00 00 00	 call	 ?CGReqCrywolfInfo@@YAXPAUPMSG_REQ_CRYWOLF_INFO@@H@Z ; CGReqCrywolfInfo
  00bc6	83 c4 08	 add	 esp, 8
  00bc9	5f		 pop	 edi
  00bca	5e		 pop	 esi
  00bcb	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00bcc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bcf	33 cd		 xor	 ecx, ebp
  00bd1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bd6	8b e5		 mov	 esp, ebp
  00bd8	5d		 pop	 ebp
  00bd9	c3		 ret	 0
$LN193@ProtocolCo:

; 734  : 							break;
; 735  : 					}
; 736  : 				}
; 737  : 				break;
; 738  : 			case 0xBF:
; 739  : 				{
; 740  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 741  : 
; 742  : 					switch ( lpDef->subcode )

  00bda	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00bde	83 f9 51	 cmp	 ecx, 81			; 00000051H
  00be1	0f 87 b8 00 00
	00		 ja	 $LN201@ProtocolCo
  00be7	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR $LN343@ProtocolCo[ecx]
  00bee	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN357@ProtocolCo[eax*4]
$LN194@ProtocolCo:

; 743  : 					{
; 744  : 						case 0x00:
; 745  : 							GCReqmoveIllusionTemple((PMSG_REQ_MOVEILLUSIONTEMPLE*)aRecv, aIndex);

  00bf5	56		 push	 esi
  00bf6	57		 push	 edi
  00bf7	e8 00 00 00 00	 call	 ?GCReqmoveIllusionTemple@@YAXPAUPMSG_REQ_MOVEILLUSIONTEMPLE@@H@Z ; GCReqmoveIllusionTemple
  00bfc	83 c4 08	 add	 esp, 8
  00bff	5f		 pop	 edi
  00c00	5e		 pop	 esi
  00c01	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00c02	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c05	33 cd		 xor	 ecx, ebp
  00c07	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c0c	8b e5		 mov	 esp, ebp
  00c0e	5d		 pop	 ebp
  00c0f	c3		 ret	 0
$LN195@ProtocolCo:

; 746  : 							break;
; 747  : 						case 0x02:
; 748  : 							GCIllusionSkillUseSend((PMSG_ILLUSION_REQ_SKILLUSE*)aRecv,aIndex);

  00c10	56		 push	 esi
  00c11	57		 push	 edi
  00c12	e8 00 00 00 00	 call	 ?GCIllusionSkillUseSend@@YAXPAUPMSG_ILLUSION_REQ_SKILLUSE@@H@Z ; GCIllusionSkillUseSend
  00c17	83 c4 08	 add	 esp, 8
  00c1a	5f		 pop	 edi
  00c1b	5e		 pop	 esi
  00c1c	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00c1d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c20	33 cd		 xor	 ecx, ebp
  00c22	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c27	8b e5		 mov	 esp, ebp
  00c29	5d		 pop	 ebp
  00c2a	c3		 ret	 0
$LN196@ProtocolCo:

; 749  : 							break;
; 750  : 						case 0x05:
; 751  : 							CGIllusionTempleReward(aIndex);

  00c2b	56		 push	 esi
  00c2c	e8 00 00 00 00	 call	 ?CGIllusionTempleReward@@YAXH@Z ; CGIllusionTempleReward
  00c31	83 c4 04	 add	 esp, 4
  00c34	5f		 pop	 edi
  00c35	5e		 pop	 esi
  00c36	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00c37	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c3a	33 cd		 xor	 ecx, ebp
  00c3c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c41	8b e5		 mov	 esp, ebp
  00c43	5d		 pop	 ebp
  00c44	c3		 ret	 0
$LN197@ProtocolCo:

; 752  : 							break;
; 753  : 						case 0x0E:
; 754  : 							CGReqmoveDoubleGoer(aRecv,aIndex);

  00c45	56		 push	 esi
  00c46	57		 push	 edi
  00c47	e8 00 00 00 00	 call	 ?CGReqmoveDoubleGoer@@YAXPAEH@Z ; CGReqmoveDoubleGoer
  00c4c	83 c4 08	 add	 esp, 8
  00c4f	5f		 pop	 edi
  00c50	5e		 pop	 esi
  00c51	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00c52	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c55	33 cd		 xor	 ecx, ebp
  00c57	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c5c	8b e5		 mov	 esp, ebp
  00c5e	5d		 pop	 ebp
  00c5f	c3		 ret	 0
$LN198@ProtocolCo:

; 755  : 							break;
; 756  : 						case 0x17:
; 757  : 							CGReqmoveLorenMarket(aIndex);

  00c60	56		 push	 esi
  00c61	e8 00 00 00 00	 call	 ?CGReqmoveLorenMarket@@YAXH@Z ; CGReqmoveLorenMarket
  00c66	83 c4 04	 add	 esp, 4
  00c69	5f		 pop	 edi
  00c6a	5e		 pop	 esi
  00c6b	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00c6c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c6f	33 cd		 xor	 ecx, ebp
  00c71	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c76	8b e5		 mov	 esp, ebp
  00c78	5d		 pop	 ebp
  00c79	c3		 ret	 0
$LN199@ProtocolCo:

; 758  : 							break;
; 759  : 						case 0x20:	//OK
; 760  : 							CGInventoryEquipment((_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM *)aRecv, aIndex);

  00c7a	56		 push	 esi
  00c7b	57		 push	 edi
  00c7c	e8 00 00 00 00	 call	 ?CGInventoryEquipment@@YAXPAU_tagPMSG_REQ_INVENTORY_EQUIPMENT_ITEM@@H@Z ; CGInventoryEquipment
  00c81	83 c4 08	 add	 esp, 8
$LN200@ProtocolCo:

; 761  : 						case 0x51:
; 762  : 							CGRequestStartMuBot((PMSG_MUBOT_REQ_START*)aRecv,aIndex);

  00c84	56		 push	 esi
  00c85	57		 push	 edi
  00c86	e8 00 00 00 00	 call	 ?CGRequestStartMuBot@@YAXPAUPMSG_MUBOT_REQ_START@@H@Z ; CGRequestStartMuBot
  00c8b	83 c4 08	 add	 esp, 8
  00c8e	5f		 pop	 edi
  00c8f	5e		 pop	 esi
  00c90	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00c91	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c94	33 cd		 xor	 ecx, ebp
  00c96	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c9b	8b e5		 mov	 esp, ebp
  00c9d	5d		 pop	 ebp
  00c9e	c3		 ret	 0
$LN201@ProtocolCo:

; 763  : 							break;
; 764  : 						default:
; 765  : 							LogAddTD("[0xBF] Unknown packet BF:%d",lpDef->subcode);

  00c9f	51		 push	 ecx
  00ca0	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BJHJAKKO@?$FL0xBF?$FN?5Unknown?5packet?5BF?3?$CFd?$AA@
  00ca5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00cab	83 c4 08	 add	 esp, 8
  00cae	5f		 pop	 edi
  00caf	5e		 pop	 esi
  00cb0	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00cb1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cb4	33 cd		 xor	 ecx, ebp
  00cb6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cbb	8b e5		 mov	 esp, ebp
  00cbd	5d		 pop	 ebp
  00cbe	c3		 ret	 0
$LN202@ProtocolCo:

; 766  : 							break;
; 767  : 					}
; 768  : 				}
; 769  : 				break;
; 770  : 			//case 0xBE:
; 771  : 			case 0xE1:
; 772  : 				CGGuildAssignStatus((PMSG_GUILD_ASSIGN_STATUS_REQ *)aRecv, aIndex);

  00cbf	56		 push	 esi
  00cc0	57		 push	 edi
  00cc1	e8 00 00 00 00	 call	 ?CGGuildAssignStatus@@YAXPAUPMSG_GUILD_ASSIGN_STATUS_REQ@@H@Z ; CGGuildAssignStatus
  00cc6	83 c4 08	 add	 esp, 8
  00cc9	5f		 pop	 edi
  00cca	5e		 pop	 esi
  00ccb	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00ccc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ccf	33 cd		 xor	 ecx, ebp
  00cd1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cd6	8b e5		 mov	 esp, ebp
  00cd8	5d		 pop	 ebp
  00cd9	c3		 ret	 0
$LN203@ProtocolCo:

; 773  : 				break;
; 774  : 			case 0xE2:
; 775  : 				CGGuildAssignType((PMSG_GUILD_ASSIGN_TYPE_REQ *)aRecv, aIndex);

  00cda	56		 push	 esi
  00cdb	57		 push	 edi
  00cdc	e8 00 00 00 00	 call	 ?CGGuildAssignType@@YAXPAUPMSG_GUILD_ASSIGN_TYPE_REQ@@H@Z ; CGGuildAssignType
  00ce1	83 c4 08	 add	 esp, 8
  00ce4	5f		 pop	 edi
  00ce5	5e		 pop	 esi
  00ce6	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00ce7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00cea	33 cd		 xor	 ecx, ebp
  00cec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00cf1	8b e5		 mov	 esp, ebp
  00cf3	5d		 pop	 ebp
  00cf4	c3		 ret	 0
$LN204@ProtocolCo:

; 776  : 				break;
; 777  : 			case 0xE5:
; 778  : 				CGRelationShipReqJoinBreakOff((PMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ *)aRecv, aIndex);

  00cf5	56		 push	 esi
  00cf6	57		 push	 edi
  00cf7	e8 00 00 00 00	 call	 ?CGRelationShipReqJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ@@H@Z ; CGRelationShipReqJoinBreakOff
  00cfc	83 c4 08	 add	 esp, 8
  00cff	5f		 pop	 edi
  00d00	5e		 pop	 esi
  00d01	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00d02	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d05	33 cd		 xor	 ecx, ebp
  00d07	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d0c	8b e5		 mov	 esp, ebp
  00d0e	5d		 pop	 ebp
  00d0f	c3		 ret	 0
$LN205@ProtocolCo:

; 779  : 				break;
; 780  : 			case 0xE6:
; 781  : 				CGRelationShipAnsJoinBreakOff((PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS *)aRecv, aIndex);

  00d10	56		 push	 esi
  00d11	57		 push	 edi
  00d12	e8 00 00 00 00	 call	 ?CGRelationShipAnsJoinBreakOff@@YAXPAUPMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS@@H@Z ; CGRelationShipAnsJoinBreakOff
  00d17	83 c4 08	 add	 esp, 8
  00d1a	5f		 pop	 edi
  00d1b	5e		 pop	 esi
  00d1c	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00d1d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d20	33 cd		 xor	 ecx, ebp
  00d22	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d27	8b e5		 mov	 esp, ebp
  00d29	5d		 pop	 ebp
  00d2a	c3		 ret	 0
$LN206@ProtocolCo:

; 782  : 				break;
; 783  : 			case 0xE7:
; 784  : 				{
; 785  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 786  : 
; 787  : 					switch ( lpDef->subcode )

  00d2b	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]

; 796  : 						break;
; 797  : 					default:
; 798  : //						LogAddTD("[0xE7] Unknown packet BF:%d",lpDef->subcode);
; 799  : 						g_Minimap.GCReqSendNpcPosInfo((_PMSG_REQ_NPC_POSITION*)aRecv, aIndex);

  00d2f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Minimap@@3VMinimap@@A ; g_Minimap
  00d34	56		 push	 esi
  00d35	83 e8 01	 sub	 eax, 1
  00d38	74 32		 je	 SHORT $LN207@ProtocolCo

; 782  : 				break;
; 783  : 			case 0xE7:
; 784  : 				{
; 785  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 786  : 
; 787  : 					switch ( lpDef->subcode )

  00d3a	83 e8 01	 sub	 eax, 1
  00d3d	74 17		 je	 SHORT $LN208@ProtocolCo

; 796  : 						break;
; 797  : 					default:
; 798  : //						LogAddTD("[0xE7] Unknown packet BF:%d",lpDef->subcode);
; 799  : 						g_Minimap.GCReqSendNpcPosInfo((_PMSG_REQ_NPC_POSITION*)aRecv, aIndex);

  00d3f	57		 push	 edi
  00d40	e8 00 00 00 00	 call	 ?GCReqSendNpcPosInfo@Minimap@@QAEXPAU_PMSG_REQ_NPC_POSITION@@H@Z ; Minimap::GCReqSendNpcPosInfo
  00d45	5f		 pop	 edi
  00d46	5e		 pop	 esi
  00d47	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00d48	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d4b	33 cd		 xor	 ecx, ebp
  00d4d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d52	8b e5		 mov	 esp, ebp
  00d54	5d		 pop	 ebp
  00d55	c3		 ret	 0
$LN208@ProtocolCo:

; 792  : 						break;
; 793  : 					case 2:
; 794  : //						g_MiniMap.SetCloseMinimap(aIndex);
; 795  : 						g_Minimap.CGReqSendMemberPosInfoStop(aIndex);

  00d56	e8 00 00 00 00	 call	 ?CGReqSendMemberPosInfoStop@Minimap@@QAEXH@Z ; Minimap::CGReqSendMemberPosInfoStop
  00d5b	5f		 pop	 edi
  00d5c	5e		 pop	 esi
  00d5d	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00d5e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d61	33 cd		 xor	 ecx, ebp
  00d63	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d68	8b e5		 mov	 esp, ebp
  00d6a	5d		 pop	 ebp
  00d6b	c3		 ret	 0
$LN207@ProtocolCo:

; 788  : 					{
; 789  : 					case 1:
; 790  : //						g_MiniMap.SetOpenMinimap(aIndex);
; 791  : 						g_Minimap.CGReqSendMemberPosInfoStart(aIndex);

  00d6c	e8 00 00 00 00	 call	 ?CGReqSendMemberPosInfoStart@Minimap@@QAEXH@Z ; Minimap::CGReqSendMemberPosInfoStart
  00d71	5f		 pop	 edi
  00d72	5e		 pop	 esi
  00d73	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00d74	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d77	33 cd		 xor	 ecx, ebp
  00d79	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d7e	8b e5		 mov	 esp, ebp
  00d80	5d		 pop	 ebp
  00d81	c3		 ret	 0
$LN210@ProtocolCo:

; 800  : 						break;
; 801  : 					}
; 802  : 				}
; 803  : 				break;
; 804  : 			case 0xE9:
; 805  : 				CGUnionList((PMSG_UNIONLIST_REQ *)aRecv, aIndex);

  00d82	56		 push	 esi
  00d83	57		 push	 edi
  00d84	e8 00 00 00 00	 call	 ?CGUnionList@@YAXPAUPMSG_UNIONLIST_REQ@@H@Z ; CGUnionList
  00d89	83 c4 08	 add	 esp, 8
  00d8c	5f		 pop	 edi
  00d8d	5e		 pop	 esi
  00d8e	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00d8f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d92	33 cd		 xor	 ecx, ebp
  00d94	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d99	8b e5		 mov	 esp, ebp
  00d9b	5d		 pop	 ebp
  00d9c	c3		 ret	 0
$LN211@ProtocolCo:

; 806  : 				break;
; 807  : 			case 0xEC:
; 808  : 				{
; 809  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 810  : 
; 811  : 					switch( lpDef->subcode )

  00d9d	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00da1	83 f8 31	 cmp	 eax, 49			; 00000031H
  00da4	0f 87 25 0e 00
	00		 ja	 $LN67@ProtocolCo
  00daa	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN344@ProtocolCo[eax]
  00db1	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN358@ProtocolCo[eax*4]
$LN212@ProtocolCo:

; 812  : 					{
; 813  : 					case 0x00:
; 814  : 						g_ElementalSystem.CGInsertErtel(aIndex,(PMSG_REQ_INSERTERTEL*)aRecv);

  00db8	57		 push	 edi
  00db9	56		 push	 esi
  00dba	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00dbf	e8 00 00 00 00	 call	 ?CGInsertErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_INSERTERTEL@@@Z ; CElementalSystem::CGInsertErtel
  00dc4	5f		 pop	 edi
  00dc5	5e		 pop	 esi
  00dc6	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00dc7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00dca	33 cd		 xor	 ecx, ebp
  00dcc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00dd1	8b e5		 mov	 esp, ebp
  00dd3	5d		 pop	 ebp
  00dd4	c3		 ret	 0
$LN213@ProtocolCo:

; 815  : 						break;
; 816  : 					case 0x01:
; 817  : 						g_ElementalSystem.CGRemoveErtel(aIndex,(PMSG_REQ_REMOVEERTEL*)aRecv);

  00dd5	57		 push	 edi
  00dd6	56		 push	 esi
  00dd7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00ddc	e8 00 00 00 00	 call	 ?CGRemoveErtel@CElementalSystem@@QAEXHPAUPMSG_REQ_REMOVEERTEL@@@Z ; CElementalSystem::CGRemoveErtel
  00de1	5f		 pop	 edi
  00de2	5e		 pop	 esi
  00de3	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00de4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00de7	33 cd		 xor	 ecx, ebp
  00de9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00dee	8b e5		 mov	 esp, ebp
  00df0	5d		 pop	 ebp
  00df1	c3		 ret	 0
$LN214@ProtocolCo:

; 818  : 						break;
; 819  : 					case 0x02:
; 820  : 						g_ElementalSystem.CGCombineButtonClick((PMSG_ERTEL_COMBINE*)aRecv,aIndex);

  00df2	56		 push	 esi
  00df3	57		 push	 edi
  00df4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00df9	e8 00 00 00 00	 call	 ?CGCombineButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_COMBINE@@H@Z ; CElementalSystem::CGCombineButtonClick
  00dfe	5f		 pop	 edi
  00dff	5e		 pop	 esi
  00e00	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00e01	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e04	33 cd		 xor	 ecx, ebp
  00e06	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e0b	8b e5		 mov	 esp, ebp
  00e0d	5d		 pop	 ebp
  00e0e	c3		 ret	 0
$LN215@ProtocolCo:

; 821  : 						break;
; 822  : 					case 0x03:
; 823  : 						g_ElementalSystem.CGUpgradeButtonClick((PMSG_ERTEL_LEVELUP*)aRecv,aIndex);

  00e0f	56		 push	 esi
  00e10	57		 push	 edi
  00e11	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ElementalSystem@@3VCElementalSystem@@A ; g_ElementalSystem
  00e16	e8 00 00 00 00	 call	 ?CGUpgradeButtonClick@CElementalSystem@@QAEXPAUPMSG_ERTEL_LEVELUP@@H@Z ; CElementalSystem::CGUpgradeButtonClick
  00e1b	5f		 pop	 edi
  00e1c	5e		 pop	 esi
  00e1d	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00e1e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e21	33 cd		 xor	 ecx, ebp
  00e23	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e28	8b e5		 mov	 esp, ebp
  00e2a	5d		 pop	 ebp
  00e2b	c3		 ret	 0
$LN216@ProtocolCo:

; 824  : 						break;
; 825  : 					case 0x31:
; 826  : 						g_ShopBoard.CGReqItemSearch(aIndex, (SHOPBOARD_CGREQ_ITEM*)aRecv);

  00e2c	57		 push	 edi
  00e2d	56		 push	 esi
  00e2e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopBoard@@3VShopBoard@@A ; g_ShopBoard
  00e33	e8 00 00 00 00	 call	 ?CGReqItemSearch@ShopBoard@@QAEXHPAUSHOPBOARD_CGREQ_ITEM@@@Z ; ShopBoard::CGReqItemSearch
  00e38	5f		 pop	 edi
  00e39	5e		 pop	 esi
  00e3a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00e3b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e3e	33 cd		 xor	 ecx, ebp
  00e40	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e45	8b e5		 mov	 esp, ebp
  00e47	5d		 pop	 ebp
  00e48	c3		 ret	 0
$LN217@ProtocolCo:

; 827  : 						break;
; 828  : 					}
; 829  : 				}
; 830  : 				break;
; 831  : 			case 0xED:
; 832  : 				{
; 833  : 					PMSG_DEFAULT2* lpDef = (PMSG_DEFAULT2*)aRecv;
; 834  : 					// ----
; 835  : 					switch(lpDef->subcode)

  00e49	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00e4d	83 f8 08	 cmp	 eax, 8
  00e50	0f 87 79 0d 00
	00		 ja	 $LN67@ProtocolCo
  00e56	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN359@ProtocolCo[eax*4]
$LN218@ProtocolCo:

; 836  : 					{
; 837  : 					case 0x00:
; 838  : 						g_GuildMatch.CGReqOfferList(aIndex, (GUILDMATCH_CGREQ_OFFERLIST*)aRecv);

  00e5d	57		 push	 edi
  00e5e	56		 push	 esi
  00e5f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00e64	e8 00 00 00 00	 call	 ?CGReqOfferList@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERLIST@@@Z ; GuildMatch::CGReqOfferList
  00e69	5f		 pop	 edi
  00e6a	5e		 pop	 esi
  00e6b	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00e6c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e6f	33 cd		 xor	 ecx, ebp
  00e71	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e76	8b e5		 mov	 esp, ebp
  00e78	5d		 pop	 ebp
  00e79	c3		 ret	 0
$LN219@ProtocolCo:

; 839  : 						break;
; 840  : 					case 0x01:
; 841  : 						g_GuildMatch.CGReqOfferListByFilter(aIndex, (GUILDMATCH_CGREQ_OFFERLISTFILTER*)aRecv);

  00e7a	57		 push	 edi
  00e7b	56		 push	 esi
  00e7c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00e81	e8 00 00 00 00	 call	 ?CGReqOfferListByFilter@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERLISTFILTER@@@Z ; GuildMatch::CGReqOfferListByFilter
  00e86	5f		 pop	 edi
  00e87	5e		 pop	 esi
  00e88	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00e89	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e8c	33 cd		 xor	 ecx, ebp
  00e8e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e93	8b e5		 mov	 esp, ebp
  00e95	5d		 pop	 ebp
  00e96	c3		 ret	 0
$LN220@ProtocolCo:

; 842  : 						break;
; 843  : 					case 0x02:
; 844  : 						g_GuildMatch.CGReqOfferCreate(aIndex, (GUILDMATCH_CGREQ_OFFERCREATE*)aRecv);

  00e97	57		 push	 edi
  00e98	56		 push	 esi
  00e99	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00e9e	e8 00 00 00 00	 call	 ?CGReqOfferCreate@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERCREATE@@@Z ; GuildMatch::CGReqOfferCreate
  00ea3	5f		 pop	 edi
  00ea4	5e		 pop	 esi
  00ea5	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00ea6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ea9	33 cd		 xor	 ecx, ebp
  00eab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00eb0	8b e5		 mov	 esp, ebp
  00eb2	5d		 pop	 ebp
  00eb3	c3		 ret	 0
$LN221@ProtocolCo:

; 845  : 						break;
; 846  : 					case 0x03:
; 847  : 						g_GuildMatch.CGReqOfferDelete(aIndex, (GUILDMATCH_CGREQ_OFFERDELETE*)aRecv);

  00eb4	57		 push	 edi
  00eb5	56		 push	 esi
  00eb6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00ebb	e8 00 00 00 00	 call	 ?CGReqOfferDelete@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_OFFERDELETE@@@Z ; GuildMatch::CGReqOfferDelete
  00ec0	5f		 pop	 edi
  00ec1	5e		 pop	 esi
  00ec2	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00ec3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ec6	33 cd		 xor	 ecx, ebp
  00ec8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ecd	8b e5		 mov	 esp, ebp
  00ecf	5d		 pop	 ebp
  00ed0	c3		 ret	 0
$LN222@ProtocolCo:

; 848  : 						break;
; 849  : 					case 0x04:
; 850  : 						g_GuildMatch.CGReqJoinReq(aIndex, (GUILDMATCH_CGREQ_JOINREQ*)aRecv);

  00ed1	57		 push	 edi
  00ed2	56		 push	 esi
  00ed3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00ed8	e8 00 00 00 00	 call	 ?CGReqJoinReq@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQ@@@Z ; GuildMatch::CGReqJoinReq
  00edd	5f		 pop	 edi
  00ede	5e		 pop	 esi
  00edf	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00ee0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ee3	33 cd		 xor	 ecx, ebp
  00ee5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00eea	8b e5		 mov	 esp, ebp
  00eec	5d		 pop	 ebp
  00eed	c3		 ret	 0
$LN223@ProtocolCo:

; 851  : 						break;
; 852  : 					case 0x05:
; 853  : 						g_GuildMatch.CGReqJoinReqDelete(aIndex, (GUILDMATCH_CGREQ_JOINREQDELETE*)aRecv);

  00eee	57		 push	 edi
  00eef	56		 push	 esi
  00ef0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00ef5	e8 00 00 00 00	 call	 ?CGReqJoinReqDelete@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQDELETE@@@Z ; GuildMatch::CGReqJoinReqDelete
  00efa	5f		 pop	 edi
  00efb	5e		 pop	 esi
  00efc	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00efd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f00	33 cd		 xor	 ecx, ebp
  00f02	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f07	8b e5		 mov	 esp, ebp
  00f09	5d		 pop	 ebp
  00f0a	c3		 ret	 0
$LN224@ProtocolCo:

; 854  : 						break;
; 855  : 					case 0x06:
; 856  : 						g_GuildMatch.CGReqJoinReqAnswer(aIndex, (GUILDMATCH_CGREQ_REQUESTANSWER*)aRecv);

  00f0b	57		 push	 edi
  00f0c	56		 push	 esi
  00f0d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00f12	e8 00 00 00 00	 call	 ?CGReqJoinReqAnswer@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_REQUESTANSWER@@@Z ; GuildMatch::CGReqJoinReqAnswer
  00f17	5f		 pop	 edi
  00f18	5e		 pop	 esi
  00f19	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00f1a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f1d	33 cd		 xor	 ecx, ebp
  00f1f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f24	8b e5		 mov	 esp, ebp
  00f26	5d		 pop	 ebp
  00f27	c3		 ret	 0
$LN225@ProtocolCo:

; 857  : 						break;
; 858  : 					case 0x07:
; 859  : 						g_GuildMatch.CGReqJoinReqList(aIndex, (GUILDMATCH_CGREQ_REQUESTLIST*)aRecv);

  00f28	57		 push	 edi
  00f29	56		 push	 esi
  00f2a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00f2f	e8 00 00 00 00	 call	 ?CGReqJoinReqList@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_REQUESTLIST@@@Z ; GuildMatch::CGReqJoinReqList
  00f34	5f		 pop	 edi
  00f35	5e		 pop	 esi
  00f36	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00f37	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f3a	33 cd		 xor	 ecx, ebp
  00f3c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f41	8b e5		 mov	 esp, ebp
  00f43	5d		 pop	 ebp
  00f44	c3		 ret	 0
$LN226@ProtocolCo:

; 860  : 						break;
; 861  : 					case 0x08:
; 862  : 						g_GuildMatch.CGReqJoinReqStatus(aIndex, (GUILDMATCH_CGREQ_JOINREQSTATUS*)aRecv);

  00f45	57		 push	 edi
  00f46	56		 push	 esi
  00f47	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_GuildMatch@@3VGuildMatch@@A ; g_GuildMatch
  00f4c	e8 00 00 00 00	 call	 ?CGReqJoinReqStatus@GuildMatch@@QAEXHPAUGUILDMATCH_CGREQ_JOINREQSTATUS@@@Z ; GuildMatch::CGReqJoinReqStatus
  00f51	5f		 pop	 edi
  00f52	5e		 pop	 esi
  00f53	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00f54	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f57	33 cd		 xor	 ecx, ebp
  00f59	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f5e	8b e5		 mov	 esp, ebp
  00f60	5d		 pop	 ebp
  00f61	c3		 ret	 0
$LN227@ProtocolCo:

; 863  : 						break;
; 864  : 
; 865  : 					}
; 866  : 				}
; 867  : 				break;
; 868  : 
; 869  : 			case 0xFE:
; 870  : 				{
; 871  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 872  : 
; 873  : 					switch( lpDef->subcode )

  00f62	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00f65	3c 05		 cmp	 al, 5
  00f67	74 5a		 je	 SHORT $LN228@ProtocolCo
  00f69	3c fe		 cmp	 al, 254			; 000000feH
  00f6b	0f 85 5e 0c 00
	00		 jne	 $LN67@ProtocolCo

; 891  : 						break;
; 892  : 
; 893  : 					case 0xFE:
; 894  : 						{
; 895  : 							if( gObj[aIndex].m_IfState.type == 21 )

  00f71	8b 91 b8 11 00
	00		 mov	 edx, DWORD PTR [ecx+4536]
  00f77	8b c2		 mov	 eax, edx
  00f79	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00f7e	3d 40 05 00 00	 cmp	 eax, 1344		; 00000540H
  00f83	0f 85 46 0c 00
	00		 jne	 $LN67@ProtocolCo

; 896  : 							{
; 897  : 								gObj[aIndex].m_IfState.use = 0;

  00f89	83 e2 fc	 and	 edx, -4			; fffffffcH
  00f8c	89 91 b8 11 00
	00		 mov	 DWORD PTR [ecx+4536], edx

; 898  : 								gObj[aIndex].m_IfState.type = 0;

  00f92	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00f97	8b 4d d4	 mov	 ecx, DWORD PTR tv1597[ebp]
  00f9a	5f		 pop	 edi
  00f9b	5e		 pop	 esi
  00f9c	5b		 pop	 ebx
  00f9d	81 a4 01 b8 11
	00 00 3f 00 ff
	ff		 and	 DWORD PTR [ecx+eax+4536], -65473 ; ffff003fH

; 899  : 								gObj[aIndex].m_IfState.state = 0;

  00fa8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00fad	83 a4 01 b8 11
	00 00 c3	 and	 DWORD PTR [ecx+eax+4536], -61 ; ffffffc3H

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00fb5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00fb8	33 cd		 xor	 ecx, ebp
  00fba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fbf	8b e5		 mov	 esp, ebp
  00fc1	5d		 pop	 ebp
  00fc2	c3		 ret	 0
$LN228@ProtocolCo:

; 874  : 					{
; 875  : #if (CUSTOM_OLYMP==1)
; 876  : 					case 0x01:
; 877  : 						g_CustomOlymp.CGRequestReg(aIndex);
; 878  : 						break;
; 879  : 					case 0x02:
; 880  : 						g_CustomOlymp.CGRequestReward(aIndex);
; 881  : 						break;
; 882  : #endif
; 883  : 
; 884  : #if(__NOVUS == 1)
; 885  : 					case 0x03:
; 886  : 						g_ExPoint.Update(aIndex);
; 887  : 						break;
; 888  : #endif
; 889  : 					case 0x05:
; 890  : 						g_ResetSystem.CG_RequestStart(aIndex, (PacketResetStart*)aRecv);

  00fc3	57		 push	 edi
  00fc4	56		 push	 esi
  00fc5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ResetSystem@@3VResetSystem@@A ; g_ResetSystem
  00fca	e8 00 00 00 00	 call	 ?CG_RequestStart@ResetSystem@@QAEXHPAUPacketResetStart@@@Z ; ResetSystem::CG_RequestStart
  00fcf	5f		 pop	 edi
  00fd0	5e		 pop	 esi
  00fd1	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  00fd2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00fd5	33 cd		 xor	 ecx, ebp
  00fd7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fdc	8b e5		 mov	 esp, ebp
  00fde	5d		 pop	 ebp
  00fdf	c3		 ret	 0
$LN231@ProtocolCo:

; 900  : 							}
; 901  : 						}
; 902  : 						break;
; 903  : 					}
; 904  : 
; 905  : 				}
; 906  : 				break;
; 907  : 			case 0xEF:
; 908  : 				{
; 909  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 910  : 					
; 911  : 					switch( lpDef->subcode )

  00fe0	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00fe4	83 f8 07	 cmp	 eax, 7
  00fe7	0f 87 e2 0b 00
	00		 ja	 $LN67@ProtocolCo
  00fed	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN360@ProtocolCo[eax*4]
$LN232@ProtocolCo:

; 912  : 					{
; 913  : 					case 0x00:
; 914  : 						CGReqPartyMatchReg((PMSG_PARTYMATCH_REG_REQ*)aRecv,aIndex);

  00ff4	56		 push	 esi
  00ff5	57		 push	 edi
  00ff6	e8 00 00 00 00	 call	 ?CGReqPartyMatchReg@@YAXPAUPMSG_PARTYMATCH_REG_REQ@@H@Z ; CGReqPartyMatchReg
  00ffb	83 c4 08	 add	 esp, 8
  00ffe	5f		 pop	 edi
  00fff	5e		 pop	 esi
  01000	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01001	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01004	33 cd		 xor	 ecx, ebp
  01006	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0100b	8b e5		 mov	 esp, ebp
  0100d	5d		 pop	 ebp
  0100e	c3		 ret	 0
$LN233@ProtocolCo:

; 915  : 						break;
; 916  : 					case 0x01:
; 917  : 						CGReqPartyMatchWindow((PMSG_PARTYMATCH_INFO_REQ*)aRecv,aIndex);

  0100f	56		 push	 esi
  01010	57		 push	 edi
  01011	e8 00 00 00 00	 call	 ?CGReqPartyMatchWindow@@YAXPAUPMSG_PARTYMATCH_INFO_REQ@@H@Z ; CGReqPartyMatchWindow
  01016	83 c4 08	 add	 esp, 8
  01019	5f		 pop	 edi
  0101a	5e		 pop	 esi
  0101b	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0101c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0101f	33 cd		 xor	 ecx, ebp
  01021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01026	8b e5		 mov	 esp, ebp
  01028	5d		 pop	 ebp
  01029	c3		 ret	 0
$LN234@ProtocolCo:

; 918  : 						break;
; 919  : 					case 0x02:
; 920  : 						CGReqPartyMatchJoin((PMSG_PARTYMATCH_JOIN_REQ*)aRecv,aIndex);

  0102a	56		 push	 esi
  0102b	57		 push	 edi
  0102c	e8 00 00 00 00	 call	 ?CGReqPartyMatchJoin@@YAXPAUPMSG_PARTYMATCH_JOIN_REQ@@H@Z ; CGReqPartyMatchJoin
  01031	83 c4 08	 add	 esp, 8
  01034	5f		 pop	 edi
  01035	5e		 pop	 esi
  01036	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01037	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0103a	33 cd		 xor	 ecx, ebp
  0103c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01041	8b e5		 mov	 esp, ebp
  01043	5d		 pop	 ebp
  01044	c3		 ret	 0
$LN235@ProtocolCo:

; 921  : 						break;
; 922  : 					case 0x03:
; 923  : 						CGReqPartyMatchWaitingList(aIndex);

  01045	56		 push	 esi
  01046	e8 00 00 00 00	 call	 ?CGReqPartyMatchWaitingList@@YAXH@Z ; CGReqPartyMatchWaitingList
  0104b	83 c4 04	 add	 esp, 4
  0104e	5f		 pop	 edi
  0104f	5e		 pop	 esi
  01050	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01054	33 cd		 xor	 ecx, ebp
  01056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0105b	8b e5		 mov	 esp, ebp
  0105d	5d		 pop	 ebp
  0105e	c3		 ret	 0
$LN236@ProtocolCo:

; 924  : 						break;
; 925  : 					case 0x04:
; 926  : 						CGReqPartyMatchAcceptList(aIndex);

  0105f	56		 push	 esi
  01060	e8 00 00 00 00	 call	 ?CGReqPartyMatchAcceptList@@YAXH@Z ; CGReqPartyMatchAcceptList
  01065	83 c4 04	 add	 esp, 4
  01068	5f		 pop	 edi
  01069	5e		 pop	 esi
  0106a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0106b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0106e	33 cd		 xor	 ecx, ebp
  01070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01075	8b e5		 mov	 esp, ebp
  01077	5d		 pop	 ebp
  01078	c3		 ret	 0
$LN237@ProtocolCo:

; 927  : 						break;
; 928  : 					case 0x05:
; 929  : 						CGReqPartyMatchRequestAnswer((PARTYMATCH_CGREQ_REQUESTANSWER*)aRecv, aIndex);

  01079	56		 push	 esi
  0107a	57		 push	 edi
  0107b	e8 00 00 00 00	 call	 ?CGReqPartyMatchRequestAnswer@@YAXPAUPARTYMATCH_CGREQ_REQUESTANSWER@@H@Z ; CGReqPartyMatchRequestAnswer
  01080	83 c4 08	 add	 esp, 8
  01083	5f		 pop	 edi
  01084	5e		 pop	 esi
  01085	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01089	33 cd		 xor	 ecx, ebp
  0108b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01090	8b e5		 mov	 esp, ebp
  01092	5d		 pop	 ebp
  01093	c3		 ret	 0
$LN238@ProtocolCo:

; 930  : 						break;
; 931  : 					case 0x06:
; 932  : 						CGReqPartyMatchCancel((PMSG_PARTYMATCH_CANCEL_REQ*)aRecv,aIndex);

  01094	56		 push	 esi
  01095	57		 push	 edi
  01096	e8 00 00 00 00	 call	 ?CGReqPartyMatchCancel@@YAXPAUPMSG_PARTYMATCH_CANCEL_REQ@@H@Z ; CGReqPartyMatchCancel
  0109b	83 c4 08	 add	 esp, 8
  0109e	5f		 pop	 edi
  0109f	5e		 pop	 esi
  010a0	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  010a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010a4	33 cd		 xor	 ecx, ebp
  010a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010ab	8b e5		 mov	 esp, ebp
  010ad	5d		 pop	 ebp
  010ae	c3		 ret	 0
$LN239@ProtocolCo:

; 933  : 						break;
; 934  : 					case 0x07:
; 935  : 						ClientTestSend(aIndex, (ClientTest*)aRecv);

  010af	57		 push	 edi
  010b0	56		 push	 esi
  010b1	e8 00 00 00 00	 call	 ?ClientTestSend@@YAXHPAUClientTest@@@Z ; ClientTestSend
  010b6	83 c4 08	 add	 esp, 8
  010b9	5f		 pop	 edi
  010ba	5e		 pop	 esi
  010bb	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  010bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010bf	33 cd		 xor	 ecx, ebp
  010c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010c6	8b e5		 mov	 esp, ebp
  010c8	5d		 pop	 ebp
  010c9	c3		 ret	 0
$LN240@ProtocolCo:

; 936  : 						break;
; 937  : 					}
; 938  : 				}
; 939  : 				//LogAddHeadHexFunc(1,(PCHAR)aRecv,aLen);
; 940  : 				break;
; 941  : 			case 0xEB:
; 942  : 				{
; 943  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 944  : 
; 945  : 					switch ( lpDef->subcode )

  010ca	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  010ce	83 e8 01	 sub	 eax, 1
  010d1	0f 85 f8 0a 00
	00		 jne	 $LN67@ProtocolCo

; 946  : 					{
; 947  : 						case 0x01:
; 948  : 							CGRelationShipReqKickOutUnionMember((PMSG_KICKOUT_UNIONMEMBER_REQ *)aRecv, aIndex);

  010d7	56		 push	 esi
  010d8	57		 push	 edi
  010d9	e8 00 00 00 00	 call	 ?CGRelationShipReqKickOutUnionMember@@YAXPAUPMSG_KICKOUT_UNIONMEMBER_REQ@@H@Z ; CGRelationShipReqKickOutUnionMember
  010de	83 c4 08	 add	 esp, 8
  010e1	5f		 pop	 edi
  010e2	5e		 pop	 esi
  010e3	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  010e4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  010e7	33 cd		 xor	 ecx, ebp
  010e9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  010ee	8b e5		 mov	 esp, ebp
  010f0	5d		 pop	 ebp
  010f1	c3		 ret	 0
$LN243@ProtocolCo:

; 949  : 							break;
; 950  : 					}
; 951  : 				}
; 952  : 				break;
; 953  : 			case 0x71:
; 954  : 				//GCPingSendRecv((PMSG_PING_RESULT *)aRecv, aIndex);
; 955  : 				break;
; 956  : 			case 0x72:
; 957  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  010f2	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  010f5	53		 push	 ebx
  010f6	56		 push	 esi
  010f7	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  010fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  010ff	85 c0		 test	 eax, eax
  01101	0f 84 c8 0a 00
	00		 je	 $LN67@ProtocolCo

; 958  : 				{
; 959  : 					GCPacketCheckSumRecv((PMSG_PACKETCHECKSUM *)aRecv, aIndex);

  01107	56		 push	 esi
  01108	57		 push	 edi
  01109	e8 00 00 00 00	 call	 ?GCPacketCheckSumRecv@@YAXPAUPMSG_PACKETCHECKSUM@@H@Z ; GCPacketCheckSumRecv
  0110e	83 c4 08	 add	 esp, 8
  01111	5f		 pop	 edi
  01112	5e		 pop	 esi
  01113	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01114	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01117	33 cd		 xor	 ecx, ebp
  01119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0111e	8b e5		 mov	 esp, ebp
  01120	5d		 pop	 ebp
  01121	c3		 ret	 0
$LN245@ProtocolCo:

; 960  : 				}
; 961  : 				break;
; 962  : 			case 0x73:
; 963  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  01122	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  01125	53		 push	 ebx
  01126	56		 push	 esi
  01127	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  0112c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0112f	5f		 pop	 edi
  01130	5e		 pop	 esi
  01131	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01135	33 cd		 xor	 ecx, ebp
  01137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0113c	8b e5		 mov	 esp, ebp
  0113e	5d		 pop	 ebp
  0113f	c3		 ret	 0
$LN247@ProtocolCo:

; 964  : 				{
; 965  : 					GCNPggCheckSumRecv((PMSG_NPROTECTGGCHECKSUM *)aRecv, aIndex);
; 966  : 				}
; 967  : 				break;
; 968  : 			case 0x81:
; 969  : 				CGWarehouseMoneyInOut(aIndex, (PMSG_WAREHOUSEMONEYINOUT *)aRecv);

  01140	57		 push	 edi
  01141	56		 push	 esi
  01142	e8 00 00 00 00	 call	 ?CGWarehouseMoneyInOut@@YAXHPAUPMSG_WAREHOUSEMONEYINOUT@@@Z ; CGWarehouseMoneyInOut
  01147	83 c4 08	 add	 esp, 8
  0114a	5f		 pop	 edi
  0114b	5e		 pop	 esi
  0114c	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0114d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01150	33 cd		 xor	 ecx, ebp
  01152	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01157	8b e5		 mov	 esp, ebp
  01159	5d		 pop	 ebp
  0115a	c3		 ret	 0
$LN248@ProtocolCo:

; 970  : 				break;
; 971  : 			case 0x82:
; 972  : 				CGWarehouseUseEnd(aIndex);

  0115b	56		 push	 esi
  0115c	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  01161	83 c4 04	 add	 esp, 4
  01164	5f		 pop	 edi
  01165	5e		 pop	 esi
  01166	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01167	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0116a	33 cd		 xor	 ecx, ebp
  0116c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01171	8b e5		 mov	 esp, ebp
  01173	5d		 pop	 ebp
  01174	c3		 ret	 0
$LN249@ProtocolCo:

; 973  : 				break;
; 974  : 			case 0x83:
; 975  : 				GCWarehouseRecivePassword(aIndex, (PMSG_WAREHOUSEPASSSEND *)aRecv);

  01175	57		 push	 edi
  01176	56		 push	 esi
  01177	e8 00 00 00 00	 call	 ?GCWarehouseRecivePassword@@YAXHPAUPMSG_WAREHOUSEPASSSEND@@@Z ; GCWarehouseRecivePassword
  0117c	83 c4 08	 add	 esp, 8
  0117f	5f		 pop	 edi
  01180	5e		 pop	 esi
  01181	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01182	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01185	33 cd		 xor	 ecx, ebp
  01187	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0118c	8b e5		 mov	 esp, ebp
  0118e	5d		 pop	 ebp
  0118f	c3		 ret	 0
$LN250@ProtocolCo:

; 976  : 				break;
; 977  : 			case 0x86:
; 978  : 				CGChaosBoxItemMixButtonClick((PMSG_CHAOSMIX *)aRecv, aIndex);

  01190	56		 push	 esi
  01191	57		 push	 edi
  01192	e8 00 00 00 00	 call	 ?CGChaosBoxItemMixButtonClick@@YAXPAUPMSG_CHAOSMIX@@H@Z ; CGChaosBoxItemMixButtonClick
  01197	83 c4 08	 add	 esp, 8
  0119a	5f		 pop	 edi
  0119b	5e		 pop	 esi
  0119c	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0119d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011a0	33 cd		 xor	 ecx, ebp
  011a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011a7	8b e5		 mov	 esp, ebp
  011a9	5d		 pop	 ebp
  011aa	c3		 ret	 0
$LN251@ProtocolCo:

; 979  : 				break;
; 980  : 			case 0x87:
; 981  : 				CGChaosBoxUseEnd(aIndex);

  011ab	56		 push	 esi
  011ac	e8 00 00 00 00	 call	 ?CGChaosBoxUseEnd@@YAXH@Z ; CGChaosBoxUseEnd
  011b1	83 c4 04	 add	 esp, 4
  011b4	5f		 pop	 edi
  011b5	5e		 pop	 esi
  011b6	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  011b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011ba	33 cd		 xor	 ecx, ebp
  011bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011c1	8b e5		 mov	 esp, ebp
  011c3	5d		 pop	 ebp
  011c4	c3		 ret	 0
$LN252@ProtocolCo:

; 982  : 				break;
; 983  : 			case 0x8E:
; 984  : 				CGWindowReqMove((PMSG_MOVE_REQUEST*)aRecv,aIndex);

  011c5	56		 push	 esi
  011c6	57		 push	 edi
  011c7	e8 00 00 00 00	 call	 ?CGWindowReqMove@@YAXPAUPMSG_MOVE_REQUEST@@H@Z ; CGWindowReqMove
  011cc	83 c4 08	 add	 esp, 8
  011cf	5f		 pop	 edi
  011d0	5e		 pop	 esi
  011d1	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  011d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011d5	33 cd		 xor	 ecx, ebp
  011d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011dc	8b e5		 mov	 esp, ebp
  011de	5d		 pop	 ebp
  011df	c3		 ret	 0
$LN253@ProtocolCo:

; 985  : 				break;
; 986  : 			case 0x90:
; 987  : 				GCReqmoveDevilSquare((PMSG_REQ_MOVEDEVILSQUARE *)aRecv, aIndex);

  011e0	56		 push	 esi
  011e1	57		 push	 edi
  011e2	e8 00 00 00 00	 call	 ?GCReqmoveDevilSquare@@YAXPAUPMSG_REQ_MOVEDEVILSQUARE@@H@Z ; GCReqmoveDevilSquare
  011e7	83 c4 08	 add	 esp, 8
  011ea	5f		 pop	 edi
  011eb	5e		 pop	 esi
  011ec	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  011ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  011f0	33 cd		 xor	 ecx, ebp
  011f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  011f7	8b e5		 mov	 esp, ebp
  011f9	5d		 pop	 ebp
  011fa	c3		 ret	 0
$LN254@ProtocolCo:

; 988  : 				break;
; 989  : 			case 0x91:
; 990  : 				GCReqDevilSquareRemainTime((PMSG_REQ_DEVILSQUARE_REMAINTIME *)aRecv, aIndex);

  011fb	56		 push	 esi
  011fc	57		 push	 edi
  011fd	e8 00 00 00 00	 call	 ?GCReqDevilSquareRemainTime@@YAXPAUPMSG_REQ_DEVILSQUARE_REMAINTIME@@H@Z ; GCReqDevilSquareRemainTime
  01202	83 c4 08	 add	 esp, 8
  01205	5f		 pop	 edi
  01206	5e		 pop	 esi
  01207	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01208	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0120b	33 cd		 xor	 ecx, ebp
  0120d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01212	8b e5		 mov	 esp, ebp
  01214	5d		 pop	 ebp
  01215	c3		 ret	 0
$LN255@ProtocolCo:

; 991  : 				break;
; 992  : 			case 0x95:
; 993  : 				GCRegEventChipRecv((PMSG_REGEVENTCHIP *)aRecv, aIndex);

  01216	56		 push	 esi
  01217	57		 push	 edi
  01218	e8 00 00 00 00	 call	 ?GCRegEventChipRecv@@YAXPAUPMSG_REGEVENTCHIP@@H@Z ; GCRegEventChipRecv
  0121d	83 c4 08	 add	 esp, 8
  01220	5f		 pop	 edi
  01221	5e		 pop	 esi
  01222	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01223	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01226	33 cd		 xor	 ecx, ebp
  01228	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0122d	8b e5		 mov	 esp, ebp
  0122f	5d		 pop	 ebp
  01230	c3		 ret	 0
$LN256@ProtocolCo:

; 994  : 				break;
; 995  : 			case 0x96:
; 996  : 				GCGetMutoNumRecv((PMSG_GETMUTONUMBER *)aRecv, aIndex);

  01231	56		 push	 esi
  01232	57		 push	 edi
  01233	e8 00 00 00 00	 call	 ?GCGetMutoNumRecv@@YAXPAUPMSG_GETMUTONUMBER@@H@Z ; GCGetMutoNumRecv
  01238	83 c4 08	 add	 esp, 8
  0123b	5f		 pop	 edi
  0123c	5e		 pop	 esi
  0123d	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0123e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01241	33 cd		 xor	 ecx, ebp
  01243	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01248	8b e5		 mov	 esp, ebp
  0124a	5d		 pop	 ebp
  0124b	c3		 ret	 0
$LN257@ProtocolCo:

; 997  : 				break;
; 998  : 			case 0x97:
; 999  : 				GCUseEndEventChipRescv(aIndex);

  0124c	56		 push	 esi
  0124d	e8 00 00 00 00	 call	 ?GCUseEndEventChipRescv@@YAXH@Z ; GCUseEndEventChipRescv
  01252	83 c4 04	 add	 esp, 4
  01255	5f		 pop	 edi
  01256	5e		 pop	 esi
  01257	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01258	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0125b	33 cd		 xor	 ecx, ebp
  0125d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01262	8b e5		 mov	 esp, ebp
  01264	5d		 pop	 ebp
  01265	c3		 ret	 0
$LN258@ProtocolCo:

; 1000 : 				break;
; 1001 : 			case 0x98:
; 1002 : 				GCUseRenaChangeZenRecv((PMSG_EXCHANGE_EVENTCHIP *)aRecv, aIndex);

  01266	56		 push	 esi
  01267	57		 push	 edi
  01268	e8 00 00 00 00	 call	 ?GCUseRenaChangeZenRecv@@YAXPAUPMSG_EXCHANGE_EVENTCHIP@@H@Z ; GCUseRenaChangeZenRecv
  0126d	83 c4 08	 add	 esp, 8
  01270	5f		 pop	 edi
  01271	5e		 pop	 esi
  01272	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01273	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01276	33 cd		 xor	 ecx, ebp
  01278	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0127d	8b e5		 mov	 esp, ebp
  0127f	5d		 pop	 ebp
  01280	c3		 ret	 0
$LN259@ProtocolCo:

; 1003 : 				break;
; 1004 : 			case 0x99:
; 1005 : 				CGReqMoveOtherServer((PMSG_REQ_MOVE_OTHERSERVER *)aRecv, aIndex);

  01281	56		 push	 esi
  01282	57		 push	 edi
  01283	e8 00 00 00 00	 call	 ?CGReqMoveOtherServer@@YAXPAUPMSG_REQ_MOVE_OTHERSERVER@@H@Z ; CGReqMoveOtherServer
  01288	83 c4 08	 add	 esp, 8
  0128b	5f		 pop	 edi
  0128c	5e		 pop	 esi
  0128d	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0128e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01291	33 cd		 xor	 ecx, ebp
  01293	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01298	8b e5		 mov	 esp, ebp
  0129a	5d		 pop	 ebp
  0129b	c3		 ret	 0
$LN260@ProtocolCo:

; 1006 : 				break;
; 1007 : 			case 0xA0:
; 1008 : 				CGRequestQuestInfo(aIndex);

  0129c	56		 push	 esi
  0129d	e8 00 00 00 00	 call	 ?CGRequestQuestInfo@@YAXH@Z ; CGRequestQuestInfo
  012a2	83 c4 04	 add	 esp, 4
  012a5	5f		 pop	 edi
  012a6	5e		 pop	 esi
  012a7	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  012a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012ab	33 cd		 xor	 ecx, ebp
  012ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012b2	8b e5		 mov	 esp, ebp
  012b4	5d		 pop	 ebp
  012b5	c3		 ret	 0
$LN261@ProtocolCo:

; 1009 : 				break;
; 1010 : 			case 0xA2:
; 1011 : 				CGSetQuestState((PMSG_SETQUEST *)aRecv, aIndex);

  012b6	56		 push	 esi
  012b7	57		 push	 edi
  012b8	e8 00 00 00 00	 call	 ?CGSetQuestState@@YAXPAUPMSG_SETQUEST@@H@Z ; CGSetQuestState
  012bd	83 c4 08	 add	 esp, 8
  012c0	5f		 pop	 edi
  012c1	5e		 pop	 esi
  012c2	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  012c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012c6	33 cd		 xor	 ecx, ebp
  012c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012cd	8b e5		 mov	 esp, ebp
  012cf	5d		 pop	 ebp
  012d0	c3		 ret	 0
$LN262@ProtocolCo:

; 1012 : 				break;
; 1013 : 			case 0xA7:
; 1014 : 				CGRequestPetItemCommand((PMSG_REQUEST_PET_ITEM_COMMAND *)aRecv, aIndex);

  012d1	56		 push	 esi
  012d2	57		 push	 edi
  012d3	e8 00 00 00 00	 call	 ?CGRequestPetItemCommand@@YAXPAUPMSG_REQUEST_PET_ITEM_COMMAND@@H@Z ; CGRequestPetItemCommand
  012d8	83 c4 08	 add	 esp, 8
  012db	5f		 pop	 edi
  012dc	5e		 pop	 esi
  012dd	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  012de	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012e1	33 cd		 xor	 ecx, ebp
  012e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012e8	8b e5		 mov	 esp, ebp
  012ea	5d		 pop	 ebp
  012eb	c3		 ret	 0
$LN263@ProtocolCo:

; 1015 : 				break;
; 1016 : 			case 0xA9:
; 1017 : 				CGRequestPetItemInfo((PMSG_REQUEST_PET_ITEMINFO *)aRecv, aIndex);

  012ec	56		 push	 esi
  012ed	57		 push	 edi
  012ee	e8 00 00 00 00	 call	 ?CGRequestPetItemInfo@@YAXPAUPMSG_REQUEST_PET_ITEMINFO@@H@Z ; CGRequestPetItemInfo
  012f3	83 c4 08	 add	 esp, 8
  012f6	5f		 pop	 edi
  012f7	5e		 pop	 esi
  012f8	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  012f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012fc	33 cd		 xor	 ecx, ebp
  012fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01303	8b e5		 mov	 esp, ebp
  01305	5d		 pop	 ebp
  01306	c3		 ret	 0
$LN264@ProtocolCo:

; 1018 : 				break;
; 1019 : #if (ENABLETEST_NEWPVP == 1)
; 1020 : 			case 0xAA://1.00.93
; 1021 : 				{
; 1022 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1023 : 					WORD wPacketType = MAKEWORD(lpDef->subcode,0xAA);
; 1024 : 					// ----
; 1025 : 					switch(wPacketType)

  01307	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0130b	0d 00 aa 00 00	 or	 eax, 43520		; 0000aa00H
  01310	05 ff 55 ff ff	 add	 eax, -43521		; ffff55ffH
  01315	83 f8 08	 cmp	 eax, 8
  01318	0f 87 b1 08 00
	00		 ja	 $LN67@ProtocolCo
  0131e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN361@ProtocolCo[eax*4]
$LN265@ProtocolCo:

; 1026 : 					{
; 1027 : 					case MSG_DUEL_INVITE :
; 1028 : 						{
; 1029 : 							LPPMSG_REQ_DUEL_INVITE lpReq = (LPPMSG_REQ_DUEL_INVITE)aRecv;
; 1030 : 							int nRet = OnCGInviteDuel(lpReq, aIndex);

  01325	56		 push	 esi
  01326	57		 push	 edi
  01327	e8 00 00 00 00	 call	 ?OnCGInviteDuel@@YAHPAU_tagPMSG_REQ_DUEL_INVITE@@H@Z ; OnCGInviteDuel
  0132c	83 c4 08	 add	 esp, 8

; 1031 : 							if( nRet != ENEWPVP::E_NO_ERROR )

  0132f	85 c0		 test	 eax, eax
  01331	0f 84 98 08 00
	00		 je	 $LN67@ProtocolCo

; 1032 : 							{
; 1033 : 								PMSG_ANS_DUEL_INVITE res = {0};

  01337	0f 57 c0	 xorps	 xmm0, xmm0
  0133a	0f 11 45 e9	 movups	 XMMWORD PTR _res$5[ebp+1], xmm0

; 1034 : 								res.h.c = PMHC_BYTE;

  0133e	c7 45 e8 c1 11
	aa 01		 mov	 DWORD PTR _res$5[ebp], 27922881 ; 01aa11c1H
$LN351@ProtocolCo:

; 1035 : 								res.h.size = sizeof(PMSG_ANS_DUEL_INVITE);
; 1036 : 								res.h.headcode = 0xAA;
; 1037 : 								res.h.subcode = 0x01;
; 1038 : 								res.nResult = nRet;

  01345	88 45 ec	 mov	 BYTE PTR _res$5[ebp+4], al

; 1039 : 								DataSend(aIndex, (LPBYTE)&res, res.h.size);

  01348	8d 45 e8	 lea	 eax, DWORD PTR _res$5[ebp]
  0134b	6a 11		 push	 17			; 00000011H
$LN352@ProtocolCo:
  0134d	50		 push	 eax
  0134e	56		 push	 esi
  0134f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01354	83 c4 0c	 add	 esp, 12			; 0000000cH
  01357	5f		 pop	 edi
  01358	5e		 pop	 esi
  01359	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0135a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0135d	33 cd		 xor	 ecx, ebp
  0135f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01364	8b e5		 mov	 esp, ebp
  01366	5d		 pop	 ebp
  01367	c3		 ret	 0
$LN267@ProtocolCo:

; 1040 : 							}
; 1041 : 						}
; 1042 : 						break;
; 1043 : 					case MSG_DUEL_ANSWER :
; 1044 : 						{
; 1045 : 							LPPMSG_ANS_DUEL_ANSWER lpReq = (LPPMSG_ANS_DUEL_ANSWER)aRecv;
; 1046 : 							int nRet = OnCGAnswerDuel(lpReq, aIndex);

  01368	56		 push	 esi
  01369	57		 push	 edi
  0136a	e8 00 00 00 00	 call	 ?OnCGAnswerDuel@@YAHPAU_tagPMSG_ANS_DUEL_ANSWER@@H@Z ; OnCGAnswerDuel
  0136f	83 c4 08	 add	 esp, 8
  01372	5f		 pop	 edi
  01373	5e		 pop	 esi
  01374	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01375	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01378	33 cd		 xor	 ecx, ebp
  0137a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0137f	8b e5		 mov	 esp, ebp
  01381	5d		 pop	 ebp
  01382	c3		 ret	 0
$LN268@ProtocolCo:

; 1047 : 							/*if( nRet != ENEWPVP::E_NO_ERROR )
; 1048 : 							{
; 1049 : 							}*/
; 1050 : 						}
; 1051 : 						break;
; 1052 : 					case MSG_DUEL_LEAVE :
; 1053 : 						{
; 1054 : 							LPPMSG_REQ_DUEL_EXIT lpReq = (LPPMSG_REQ_DUEL_EXIT)aRecv;
; 1055 : 							int nRet = OnCGLeaveDuel(lpReq, aIndex);

  01383	56		 push	 esi
  01384	57		 push	 edi
  01385	e8 00 00 00 00	 call	 ?OnCGLeaveDuel@@YAHPAU_tagPMSG_REQ_DUEL_EXIT@@H@Z ; OnCGLeaveDuel
  0138a	83 c4 08	 add	 esp, 8

; 1056 : 							if( nRet != ENEWPVP::E_NO_ERROR )

  0138d	85 c0		 test	 eax, eax
  0138f	0f 84 3a 08 00
	00		 je	 $LN67@ProtocolCo

; 1057 : 							{
; 1058 : 								PMSG_ANS_DUEL_EXIT res = {0};

  01395	0f 57 c0	 xorps	 xmm0, xmm0
  01398	0f 11 45 e9	 movups	 XMMWORD PTR _res$4[ebp+1], xmm0

; 1059 : 								res.h.c = PMHC_BYTE;

  0139c	c7 45 e8 c1 11
	aa 03		 mov	 DWORD PTR _res$4[ebp], 61477313 ; 03aa11c1H

; 1060 : 								res.h.size = sizeof(PMSG_ANS_DUEL_EXIT);
; 1061 : 								res.h.headcode = 0xAA;
; 1062 : 								res.h.subcode = 0x03;
; 1063 : 								res.nResult = nRet;
; 1064 : 								DataSend(aIndex, (LPBYTE)&res, res.h.size);
; 1065 : 							}
; 1066 : 						}
; 1067 : 						break;

  013a3	eb a0		 jmp	 SHORT $LN351@ProtocolCo
$LN270@ProtocolCo:

; 1068 : 					case MSG_DUEL_JOINCNANNEL :
; 1069 : 						{
; 1070 : 							int nRet = OnDuelChannelJoin((LPPMSG_REQ_DUEL_JOINCNANNEL)aRecv, aIndex);

  013a5	56		 push	 esi
  013a6	57		 push	 edi
  013a7	e8 00 00 00 00	 call	 ?OnDuelChannelJoin@@YAHPAU_tagPMSG_REQ_DUEL_JOINCNANNEL@@H@Z ; OnDuelChannelJoin
  013ac	83 c4 08	 add	 esp, 8

; 1071 : 							if( nRet != ENEWPVP::E_NO_ERROR )

  013af	85 c0		 test	 eax, eax
  013b1	0f 84 18 08 00
	00		 je	 $LN67@ProtocolCo

; 1072 : 							{
; 1073 : 								PMSG_ANS_DUEL_JOINCNANNEL res = {0};

  013b7	0f 57 c0	 xorps	 xmm0, xmm0
  013ba	c7 45 f5 00 00
	00 00		 mov	 DWORD PTR _res$2[ebp+25], 0
  013c1	0f 11 45 dd	 movups	 XMMWORD PTR _res$2[ebp+1], xmm0

; 1074 : 								res.h.c = PMHC_BYTE;
; 1075 : 								res.h.size = sizeof(PMSG_ANS_DUEL_JOINCNANNEL);
; 1076 : 								res.h.headcode = 0xAA;
; 1077 : 								res.h.subcode = 0x07;
; 1078 : 								res.nResult = nRet;

  013c5	88 45 e0	 mov	 BYTE PTR _res$2[ebp+4], al

; 1079 : 								DataSend(aIndex, (LPBYTE)&res, res.h.size);

  013c8	8d 45 dc	 lea	 eax, DWORD PTR _res$2[ebp]
  013cb	66 0f d6 45 ed	 movq	 QWORD PTR _res$2[ebp+17], xmm0
  013d0	c6 45 f9 00	 mov	 BYTE PTR _res$2[ebp+29], 0
  013d4	c7 45 dc c1 1e
	aa 07		 mov	 DWORD PTR _res$2[ebp], 128589505 ; 07aa1ec1H
  013db	6a 1e		 push	 30			; 0000001eH

; 1080 : 							}
; 1081 : 						}
; 1082 : 						break;

  013dd	e9 6b ff ff ff	 jmp	 $LN352@ProtocolCo
$LN272@ProtocolCo:

; 1083 : 					case MSG_DUEL_LEAVECNANNEL :
; 1084 : 						{
; 1085 : 							LPPMSG_REQ_DUEL_LEAVECNANNEL lpReq = (LPPMSG_REQ_DUEL_LEAVECNANNEL)aRecv;
; 1086 : 							int nRet = OnDuelChannelLeave(lpReq, aIndex);

  013e2	56		 push	 esi
  013e3	57		 push	 edi
  013e4	e8 00 00 00 00	 call	 ?OnDuelChannelLeave@@YAHPAU_tagPMSG_REQ_DUEL_LEAVECNANNEL@@H@Z ; OnDuelChannelLeave
  013e9	83 c4 08	 add	 esp, 8

; 1087 : 							if( nRet != ENEWPVP::E_NO_ERROR )

  013ec	85 c0		 test	 eax, eax
  013ee	0f 84 db 07 00
	00		 je	 $LN67@ProtocolCo

; 1088 : 							{
; 1089 : 								PMSG_ANS_DUEL_LEAVECNANNEL res = {0};

  013f4	c7 45 d5 00 00
	00 00		 mov	 DWORD PTR _res$1[ebp+1], 0

; 1090 : 								res.h.c = PMHC_BYTE;
; 1091 : 								res.h.size = sizeof(PMSG_ANS_DUEL_LEAVECNANNEL);
; 1092 : 								res.h.headcode = 0xAA;
; 1093 : 								res.h.subcode = 0x09;
; 1094 : 								res.nResult = nRet;

  013fb	88 45 d8	 mov	 BYTE PTR _res$1[ebp+4], al

; 1095 : 								DataSend(aIndex, (LPBYTE)&res, res.h.size);

  013fe	8d 45 d4	 lea	 eax, DWORD PTR _res$1[ebp]
  01401	6a 05		 push	 5
  01403	50		 push	 eax
  01404	56		 push	 esi
  01405	c7 45 d4 c1 05
	aa 09		 mov	 DWORD PTR _res$1[ebp], 162137537 ; 09aa05c1H
  0140c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01411	83 c4 0c	 add	 esp, 12			; 0000000cH
  01414	5f		 pop	 edi
  01415	5e		 pop	 esi
  01416	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01417	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0141a	33 cd		 xor	 ecx, ebp
  0141c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01421	8b e5		 mov	 esp, ebp
  01423	5d		 pop	 ebp
  01424	c3		 ret	 0
$LN274@ProtocolCo:

; 1096 : 							}
; 1097 : 						}
; 1098 : 						break;
; 1099 : 					}
; 1100 : 				}
; 1101 : 				break;
; 1102 : #else
; 1103 : 			case 0xAA:
; 1104 : 				{
; 1105 : 					//g_DuelManager.ProtocolCore(lpObj, aRecv);
; 1106 : 				}
; 1107 : 				break;
; 1108 : #endif
; 1109 : 			/*case 0xAA:
; 1110 : 				CGDuelStartRequestRecv((PMSG_REQ_START_DUEL *)aRecv, aIndex);
; 1111 : 				break;
; 1112 : 			case 0xAB:
; 1113 : 				CGDuelEndRequestRecv((PMSG_REQ_END_DUEL *)aRecv, aIndex);
; 1114 : 				break;
; 1115 : 			case 0xAC:
; 1116 : 				CGDuelOkRequestRecv((PMSG_ANS_DUEL_OK *)aRecv, aIndex);
; 1117 : 				break;*/
; 1118 : 			case 0xAE:
; 1119 : 				CGSaveMuBotSettings((PMSG_MUBOT_SETTINGS_RECV*)aRecv,aIndex);

  01425	56		 push	 esi
  01426	57		 push	 edi
  01427	e8 00 00 00 00	 call	 ?CGSaveMuBotSettings@@YAXPAUPMSG_MUBOT_SETTINGS_RECV@@H@Z ; CGSaveMuBotSettings
  0142c	83 c4 08	 add	 esp, 8
  0142f	5f		 pop	 edi
  01430	5e		 pop	 esi
  01431	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01432	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01435	33 cd		 xor	 ecx, ebp
  01437	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0143c	8b e5		 mov	 esp, ebp
  0143e	5d		 pop	 ebp
  0143f	c3		 ret	 0
$LN275@ProtocolCo:

; 1120 : 				break;
; 1121 : 			case 0x9A:
; 1122 : 				CGRequestEnterBloodCastle((PMSG_REQ_MOVEBLOODCASTLE*)aRecv, aIndex);

  01440	56		 push	 esi
  01441	57		 push	 edi
  01442	e8 00 00 00 00	 call	 ?CGRequestEnterBloodCastle@@YAXPAUPMSG_REQ_MOVEBLOODCASTLE@@H@Z ; CGRequestEnterBloodCastle
  01447	83 c4 08	 add	 esp, 8
  0144a	5f		 pop	 edi
  0144b	5e		 pop	 esi
  0144c	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0144d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01450	33 cd		 xor	 ecx, ebp
  01452	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01457	8b e5		 mov	 esp, ebp
  01459	5d		 pop	 ebp
  0145a	c3		 ret	 0
$LN277@ProtocolCo:

; 1123 : 				break;
; 1124 : 			case 0x9B:
; 1125 : 				//
; 1126 : 				break;
; 1127 : 			case 0x9F:
; 1128 : 				CGRequestEventEnterCount((PMSG_REQ_CL_ENTERCOUNT *)aRecv, aIndex);

  0145b	56		 push	 esi
  0145c	57		 push	 edi
  0145d	e8 00 00 00 00	 call	 ?CGRequestEventEnterCount@@YAXPAUPMSG_REQ_CL_ENTERCOUNT@@H@Z ; CGRequestEventEnterCount
  01462	83 c4 08	 add	 esp, 8
  01465	5f		 pop	 edi
  01466	5e		 pop	 esi
  01467	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01468	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0146b	33 cd		 xor	 ecx, ebp
  0146d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01472	8b e5		 mov	 esp, ebp
  01474	5d		 pop	 ebp
  01475	c3		 ret	 0
$LN278@ProtocolCo:

; 1129 : 				break;
; 1130 : 			case 0x9D:
; 1131 : 				CGRequestLottoRegister((PMSG_REQ_2ANV_LOTTO_EVENT *)aRecv, aIndex);

  01476	56		 push	 esi
  01477	57		 push	 edi
  01478	e8 00 00 00 00	 call	 ?CGRequestLottoRegister@@YAXPAUPMSG_REQ_2ANV_LOTTO_EVENT@@H@Z ; CGRequestLottoRegister
  0147d	83 c4 08	 add	 esp, 8
  01480	5f		 pop	 edi
  01481	5e		 pop	 esi
  01482	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01483	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01486	33 cd		 xor	 ecx, ebp
  01488	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0148d	8b e5		 mov	 esp, ebp
  0148f	5d		 pop	 ebp
  01490	c3		 ret	 0
$LN279@ProtocolCo:

; 1132 : 				break;
; 1133 : 			case 0xAF:
; 1134 : 				{
; 1135 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1136 : 
; 1137 : 					switch ( lpDef->subcode )

  01491	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  01495	83 e8 01	 sub	 eax, 1
  01498	74 24		 je	 SHORT $LN280@ProtocolCo
  0149a	83 e8 01	 sub	 eax, 1
  0149d	0f 85 2c 07 00
	00		 jne	 $LN67@ProtocolCo

; 1141 : 							break;
; 1142 : 						case 0x02:
; 1143 : 							CGRequestRepositionUserInChaosCastle((PMSG_REQ_REPOSUSER_IN_CC *)aRecv, aIndex);

  014a3	56		 push	 esi
  014a4	57		 push	 edi
  014a5	e8 00 00 00 00	 call	 ?CGRequestRepositionUserInChaosCastle@@YAXPAUPMSG_REQ_REPOSUSER_IN_CC@@H@Z ; CGRequestRepositionUserInChaosCastle
  014aa	83 c4 08	 add	 esp, 8
  014ad	5f		 pop	 edi
  014ae	5e		 pop	 esi
  014af	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  014b0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  014b3	33 cd		 xor	 ecx, ebp
  014b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  014ba	8b e5		 mov	 esp, ebp
  014bc	5d		 pop	 ebp
  014bd	c3		 ret	 0
$LN280@ProtocolCo:

; 1138 : 					{
; 1139 : 						case 0x01:
; 1140 : 							CGRequestEnterChaosCastle((PMSG_REQ_MOVECHAOSCASTLE *)aRecv, aIndex);

  014be	56		 push	 esi
  014bf	57		 push	 edi
  014c0	e8 00 00 00 00	 call	 ?CGRequestEnterChaosCastle@@YAXPAUPMSG_REQ_MOVECHAOSCASTLE@@H@Z ; CGRequestEnterChaosCastle
  014c5	83 c4 08	 add	 esp, 8
  014c8	5f		 pop	 edi
  014c9	5e		 pop	 esi
  014ca	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  014cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  014ce	33 cd		 xor	 ecx, ebp
  014d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  014d5	8b e5		 mov	 esp, ebp
  014d7	5d		 pop	 ebp
  014d8	c3		 ret	 0
$LN282@ProtocolCo:

; 1144 : 							break;
; 1145 : 					}
; 1146 : 				}
; 1147 : 				break;
; 1148 : 			case 0xC0:
; 1149 : 				FriendListRequest(aIndex);

  014d9	56		 push	 esi
  014da	e8 00 00 00 00	 call	 ?FriendListRequest@@YAXH@Z ; FriendListRequest
  014df	83 c4 04	 add	 esp, 4
  014e2	5f		 pop	 edi
  014e3	5e		 pop	 esi
  014e4	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  014e5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  014e8	33 cd		 xor	 ecx, ebp
  014ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  014ef	8b e5		 mov	 esp, ebp
  014f1	5d		 pop	 ebp
  014f2	c3		 ret	 0
$LN283@ProtocolCo:

; 1150 : 				break;
; 1151 : 			case 0xC1:
; 1152 : 				FriendAddRequest((PMSG_FRIEND_ADD_REQ *)aRecv, aIndex);

  014f3	56		 push	 esi
  014f4	57		 push	 edi
  014f5	e8 00 00 00 00	 call	 ?FriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_REQ@@H@Z ; FriendAddRequest
  014fa	83 c4 08	 add	 esp, 8
  014fd	5f		 pop	 edi
  014fe	5e		 pop	 esi
  014ff	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01500	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01503	33 cd		 xor	 ecx, ebp
  01505	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0150a	8b e5		 mov	 esp, ebp
  0150c	5d		 pop	 ebp
  0150d	c3		 ret	 0
$LN284@ProtocolCo:

; 1153 : 				break;
; 1154 : 			case 0xC2:
; 1155 : 				WaitFriendAddRequest((PMSG_FRIEND_ADD_SIN_RESULT *)aRecv, aIndex);

  0150e	56		 push	 esi
  0150f	57		 push	 edi
  01510	e8 00 00 00 00	 call	 ?WaitFriendAddRequest@@YAXPAUPMSG_FRIEND_ADD_SIN_RESULT@@H@Z ; WaitFriendAddRequest
  01515	83 c4 08	 add	 esp, 8
  01518	5f		 pop	 edi
  01519	5e		 pop	 esi
  0151a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0151b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0151e	33 cd		 xor	 ecx, ebp
  01520	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01525	8b e5		 mov	 esp, ebp
  01527	5d		 pop	 ebp
  01528	c3		 ret	 0
$LN285@ProtocolCo:

; 1156 : 				break;
; 1157 : 			case 0xC3:
; 1158 : 				FriendDelRequest((PMSG_FRIEND_DEL_REQ *)aRecv, aIndex);

  01529	56		 push	 esi
  0152a	57		 push	 edi
  0152b	e8 00 00 00 00	 call	 ?FriendDelRequest@@YAXPAUPMSG_FRIEND_DEL_REQ@@H@Z ; FriendDelRequest
  01530	83 c4 08	 add	 esp, 8
  01533	5f		 pop	 edi
  01534	5e		 pop	 esi
  01535	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01536	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01539	33 cd		 xor	 ecx, ebp
  0153b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01540	8b e5		 mov	 esp, ebp
  01542	5d		 pop	 ebp
  01543	c3		 ret	 0
$LN286@ProtocolCo:

; 1159 : 				break;
; 1160 : 			case 0xC4:
; 1161 : 				FriendStateClientRecv((PMSG_FRIEND_STATE_C *)aRecv, aIndex);

  01544	56		 push	 esi
  01545	57		 push	 edi
  01546	e8 00 00 00 00	 call	 ?FriendStateClientRecv@@YAXPAUPMSG_FRIEND_STATE_C@@H@Z ; FriendStateClientRecv
  0154b	83 c4 08	 add	 esp, 8
  0154e	5f		 pop	 edi
  0154f	5e		 pop	 esi
  01550	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01551	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01554	33 cd		 xor	 ecx, ebp
  01556	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0155b	8b e5		 mov	 esp, ebp
  0155d	5d		 pop	 ebp
  0155e	c3		 ret	 0
$LN287@ProtocolCo:

; 1162 : 				break;
; 1163 : 			case 0xC5:
; 1164 : 				FriendMemoSend((PMSG_FRIEND_MEMO *)aRecv, aIndex);

  0155f	56		 push	 esi
  01560	57		 push	 edi
  01561	e8 00 00 00 00	 call	 ?FriendMemoSend@@YAXPAUPMSG_FRIEND_MEMO@@H@Z ; FriendMemoSend
  01566	83 c4 08	 add	 esp, 8
  01569	5f		 pop	 edi
  0156a	5e		 pop	 esi
  0156b	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0156c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0156f	33 cd		 xor	 ecx, ebp
  01571	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01576	8b e5		 mov	 esp, ebp
  01578	5d		 pop	 ebp
  01579	c3		 ret	 0
$LN288@ProtocolCo:

; 1165 : 				break;
; 1166 : 			case 0xC7:
; 1167 : 				FriendMemoReadReq((PMSG_FRIEND_READ_MEMO_REQ *)aRecv, aIndex);

  0157a	56		 push	 esi
  0157b	57		 push	 edi
  0157c	e8 00 00 00 00	 call	 ?FriendMemoReadReq@@YAXPAUPMSG_FRIEND_READ_MEMO_REQ@@H@Z ; FriendMemoReadReq
  01581	83 c4 08	 add	 esp, 8
  01584	5f		 pop	 edi
  01585	5e		 pop	 esi
  01586	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01587	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0158a	33 cd		 xor	 ecx, ebp
  0158c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01591	8b e5		 mov	 esp, ebp
  01593	5d		 pop	 ebp
  01594	c3		 ret	 0
$LN289@ProtocolCo:

; 1168 : 				break;
; 1169 : 			case 0xC8:
; 1170 : 				FriendMemoDelReq((PMSG_FRIEND_MEMO_DEL_REQ *)aRecv, aIndex);

  01595	56		 push	 esi
  01596	57		 push	 edi
  01597	e8 00 00 00 00	 call	 ?FriendMemoDelReq@@YAXPAUPMSG_FRIEND_MEMO_DEL_REQ@@H@Z ; FriendMemoDelReq
  0159c	83 c4 08	 add	 esp, 8
  0159f	5f		 pop	 edi
  015a0	5e		 pop	 esi
  015a1	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  015a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015a5	33 cd		 xor	 ecx, ebp
  015a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015ac	8b e5		 mov	 esp, ebp
  015ae	5d		 pop	 ebp
  015af	c3		 ret	 0
$LN290@ProtocolCo:

; 1171 : 				break;
; 1172 : 			case 0xC9:
; 1173 : 				FriendMemoListReq(aIndex);

  015b0	56		 push	 esi
  015b1	e8 00 00 00 00	 call	 ?FriendMemoListReq@@YAXH@Z ; FriendMemoListReq
  015b6	83 c4 04	 add	 esp, 4
  015b9	5f		 pop	 edi
  015ba	5e		 pop	 esi
  015bb	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  015bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015bf	33 cd		 xor	 ecx, ebp
  015c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015c6	8b e5		 mov	 esp, ebp
  015c8	5d		 pop	 ebp
  015c9	c3		 ret	 0
$LN291@ProtocolCo:

; 1174 : 				break;
; 1175 : 			case 0xCA:
; 1176 : 				FriendChatRoomCreateReq((PMSG_FRIEND_ROOMCREATE_REQ *)aRecv, aIndex);

  015ca	56		 push	 esi
  015cb	57		 push	 edi
  015cc	e8 00 00 00 00	 call	 ?FriendChatRoomCreateReq@@YAXPAUPMSG_FRIEND_ROOMCREATE_REQ@@H@Z ; FriendChatRoomCreateReq
  015d1	83 c4 08	 add	 esp, 8
  015d4	5f		 pop	 edi
  015d5	5e		 pop	 esi
  015d6	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  015d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015da	33 cd		 xor	 ecx, ebp
  015dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015e1	8b e5		 mov	 esp, ebp
  015e3	5d		 pop	 ebp
  015e4	c3		 ret	 0
$LN292@ProtocolCo:

; 1177 : 				break;
; 1178 : 			case 0xCB:
; 1179 : 				FriendRoomInvitationReq((PMSG_ROOM_INVITATION *)aRecv, aIndex);

  015e5	56		 push	 esi
  015e6	57		 push	 edi
  015e7	e8 00 00 00 00	 call	 ?FriendRoomInvitationReq@@YAXPAUPMSG_ROOM_INVITATION@@H@Z ; FriendRoomInvitationReq
  015ec	83 c4 08	 add	 esp, 8
  015ef	5f		 pop	 edi
  015f0	5e		 pop	 esi
  015f1	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  015f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  015f5	33 cd		 xor	 ecx, ebp
  015f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  015fc	8b e5		 mov	 esp, ebp
  015fe	5d		 pop	 ebp
  015ff	c3		 ret	 0
$LN293@ProtocolCo:

; 1180 : 				break;
; 1181 : 			case 0xD0:
; 1182 : 				{
; 1183 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1184 : 
; 1185 : 					switch ( lpDef->subcode )

  01600	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  01604	83 e8 07	 sub	 eax, 7
  01607	74 23		 je	 SHORT $LN294@ProtocolCo
  01609	83 e8 01	 sub	 eax, 1
  0160c	0f 85 bd 05 00
	00		 jne	 $LN67@ProtocolCo

; 1189 : 							break;
; 1190 : 						case 0x08:
; 1191 : 							GCReqEnterBalgassLair(aIndex);

  01612	56		 push	 esi
  01613	e8 00 00 00 00	 call	 ?GCReqEnterBalgassLair@@YAXH@Z ; GCReqEnterBalgassLair
  01618	83 c4 04	 add	 esp, 4
  0161b	5f		 pop	 edi
  0161c	5e		 pop	 esi
  0161d	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0161e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01621	33 cd		 xor	 ecx, ebp
  01623	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01628	8b e5		 mov	 esp, ebp
  0162a	5d		 pop	 ebp
  0162b	c3		 ret	 0
$LN294@ProtocolCo:

; 1186 : 					{
; 1187 : 						case 0x07:
; 1188 : 							GCReqEnterBarracks(aIndex);

  0162c	56		 push	 esi
  0162d	e8 00 00 00 00	 call	 ?GCReqEnterBarracks@@YAXH@Z ; GCReqEnterBarracks
  01632	83 c4 04	 add	 esp, 4
  01635	5f		 pop	 edi
  01636	5e		 pop	 esi
  01637	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01638	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0163b	33 cd		 xor	 ecx, ebp
  0163d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01642	8b e5		 mov	 esp, ebp
  01644	5d		 pop	 ebp
  01645	c3		 ret	 0
$LN296@ProtocolCo:

; 1192 : 							break;
; 1193 : 					}
; 1194 : 				}
; 1195 : 				break;
; 1196 : 			case 0xD1:
; 1197 : 				{
; 1198 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1199 : 
; 1200 : 					switch ( lpDef->subcode )

  01646	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0164a	83 e8 00	 sub	 eax, 0
  0164d	74 24		 je	 SHORT $LN297@ProtocolCo
  0164f	83 e8 01	 sub	 eax, 1
  01652	0f 85 77 05 00
	00		 jne	 $LN67@ProtocolCo

; 1204 : 							break;
; 1205 : 						case 0x01:
; 1206 : 							GCReqEnterKanturuBossMap((PMSG_REQ_ENTER_KANTURU_BOSS_MAP *)aRecv, aIndex);

  01658	56		 push	 esi
  01659	57		 push	 edi
  0165a	e8 00 00 00 00	 call	 ?GCReqEnterKanturuBossMap@@YAXPAUPMSG_REQ_ENTER_KANTURU_BOSS_MAP@@H@Z ; GCReqEnterKanturuBossMap
  0165f	83 c4 08	 add	 esp, 8
  01662	5f		 pop	 edi
  01663	5e		 pop	 esi
  01664	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01665	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01668	33 cd		 xor	 ecx, ebp
  0166a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0166f	8b e5		 mov	 esp, ebp
  01671	5d		 pop	 ebp
  01672	c3		 ret	 0
$LN297@ProtocolCo:

; 1201 : 					{
; 1202 : 						case 0x00:
; 1203 : 							CGReqKanturuStateInfo((PMSG_REQ_KANTURU_STATE_INFO *)aRecv, aIndex);

  01673	56		 push	 esi
  01674	57		 push	 edi
  01675	e8 00 00 00 00	 call	 ?CGReqKanturuStateInfo@@YAXPAUPMSG_REQ_KANTURU_STATE_INFO@@H@Z ; CGReqKanturuStateInfo
  0167a	83 c4 08	 add	 esp, 8
  0167d	5f		 pop	 edi
  0167e	5e		 pop	 esi
  0167f	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01680	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01683	33 cd		 xor	 ecx, ebp
  01685	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0168a	8b e5		 mov	 esp, ebp
  0168c	5d		 pop	 ebp
  0168d	c3		 ret	 0
$LN299@ProtocolCo:

; 1207 : 							break;
; 1208 : 					}
; 1209 : 				}
; 1210 : 				break;
; 1211 : 			case 0xD2:
; 1212 : 				{
; 1213 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1214 : 
; 1215 : 					switch(lpDef->subcode)

  0168e	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  01692	48		 dec	 eax
  01693	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  01696	0f 87 33 05 00
	00		 ja	 $LN67@ProtocolCo
  0169c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN362@ProtocolCo[eax*4]
$LN300@ProtocolCo:

; 1216 : 					{
; 1217 : 					case 0x01:
; 1218 : 						g_CashShop.CGCashPoint(lpObj);

  016a3	51		 push	 ecx
  016a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  016a9	e8 00 00 00 00	 call	 ?CGCashPoint@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z ; CCashShop::CGCashPoint
  016ae	5f		 pop	 edi
  016af	5e		 pop	 esi
  016b0	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  016b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016b4	33 cd		 xor	 ecx, ebp
  016b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  016bb	8b e5		 mov	 esp, ebp
  016bd	5d		 pop	 ebp
  016be	c3		 ret	 0
$LN301@ProtocolCo:

; 1219 : 						break;
; 1220 : 					case 0x02:
; 1221 : 						g_CashShop.CGCashShopOpen(lpObj,(PMSG_REQ_CASHSHOPOPEN*)aRecv);

  016bf	57		 push	 edi
  016c0	51		 push	 ecx
  016c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  016c6	e8 00 00 00 00	 call	 ?CGCashShopOpen@CCashShop@@QAEHPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHSHOPOPEN@@@Z ; CCashShop::CGCashShopOpen
  016cb	5f		 pop	 edi
  016cc	5e		 pop	 esi
  016cd	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  016ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016d1	33 cd		 xor	 ecx, ebp
  016d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  016d8	8b e5		 mov	 esp, ebp
  016da	5d		 pop	 ebp
  016db	c3		 ret	 0
$LN302@ProtocolCo:

; 1222 : 						break;
; 1223 : 					case 0x03:
; 1224 : 						g_CashShop.CGCashItemBuy(lpObj,(PMSG_REQ_CASHITEM_BUY*)aRecv);

  016dc	57		 push	 edi
  016dd	51		 push	 ecx
  016de	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  016e3	e8 00 00 00 00	 call	 ?CGCashItemBuy@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z ; CCashShop::CGCashItemBuy
  016e8	5f		 pop	 edi
  016e9	5e		 pop	 esi
  016ea	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  016eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016ee	33 cd		 xor	 ecx, ebp
  016f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  016f5	8b e5		 mov	 esp, ebp
  016f7	5d		 pop	 ebp
  016f8	c3		 ret	 0
$LN303@ProtocolCo:

; 1225 : 						break;
; 1226 : 					case 0x04:
; 1227 : 						g_CashShop.CGCashGiftSend(lpObj,(PMSG_REQ_CASHITEM_GIFT*)aRecv);

  016f9	57		 push	 edi
  016fa	51		 push	 ecx
  016fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  01700	e8 00 00 00 00	 call	 ?CGCashGiftSend@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z ; CCashShop::CGCashGiftSend
  01705	5f		 pop	 edi
  01706	5e		 pop	 esi
  01707	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01708	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0170b	33 cd		 xor	 ecx, ebp
  0170d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01712	8b e5		 mov	 esp, ebp
  01714	5d		 pop	 ebp
  01715	c3		 ret	 0
$LN304@ProtocolCo:

; 1228 : 						break;
; 1229 : 					case 0x05:
; 1230 : 						g_CashShop.CGReqInfo(aRecv,lpObj->m_Index);

  01716	ff 31		 push	 DWORD PTR [ecx]
  01718	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  0171d	57		 push	 edi
  0171e	e8 00 00 00 00	 call	 ?CGReqInfo@CCashShop@@QAEHPAEH@Z ; CCashShop::CGReqInfo
  01723	5f		 pop	 edi
  01724	5e		 pop	 esi
  01725	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01726	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01729	33 cd		 xor	 ecx, ebp
  0172b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01730	8b e5		 mov	 esp, ebp
  01732	5d		 pop	 ebp
  01733	c3		 ret	 0
$LN305@ProtocolCo:

; 1231 : 						break;
; 1232 : 					case 0x0B:
; 1233 : 						g_CashShop.CGReqUseItem(lpObj,(PSMG_REQ_CASHITEM_USE*)aRecv);

  01734	57		 push	 edi
  01735	51		 push	 ecx
  01736	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  0173b	e8 00 00 00 00	 call	 ?CGReqUseItem@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPSMG_REQ_CASHITEM_USE@@@Z ; CCashShop::CGReqUseItem
  01740	5f		 pop	 edi
  01741	5e		 pop	 esi
  01742	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01743	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01746	33 cd		 xor	 ecx, ebp
  01748	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0174d	8b e5		 mov	 esp, ebp
  0174f	5d		 pop	 ebp
  01750	c3		 ret	 0
$LN306@ProtocolCo:

; 1234 : 						break;
; 1235 : 					}
; 1236 : 				}
; 1237 : 				break;
; 1238 : #if (__QUEST_SYSTEM__== 1)
; 1239 : 
; 1240 : 			case 0xF6:
; 1241 : 				{
; 1242 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1243 : 
; 1244 : 					switch ( lpDef->subcode )

  01751	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  01755	83 c0 f6	 add	 eax, -10		; fffffff6H
  01758	83 f8 27	 cmp	 eax, 39			; 00000027H
  0175b	0f 87 6e 04 00
	00		 ja	 $LN67@ProtocolCo
  01761	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN345@ProtocolCo[eax]
  01768	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN363@ProtocolCo[eax*4]
$LN307@ProtocolCo:

; 1245 : 					{
; 1246 : 					case 0x0A:
; 1247 : 						gQuestInfoEx.CGRequestInitQuest(aRecv,aIndex);

  0176f	56		 push	 esi
  01770	57		 push	 edi
  01771	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  01776	e8 00 00 00 00	 call	 ?CGRequestInitQuest@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGRequestInitQuest
  0177b	5f		 pop	 edi
  0177c	5e		 pop	 esi
  0177d	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0177e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01781	33 cd		 xor	 ecx, ebp
  01783	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01788	8b e5		 mov	 esp, ebp
  0178a	5d		 pop	 ebp
  0178b	c3		 ret	 0
$LN308@ProtocolCo:

; 1248 : 						break;
; 1249 : 					case 0x0B:
; 1250 : 						gQuestInfoEx.CGRequestQuestStep(aRecv,aIndex);

  0178c	56		 push	 esi
  0178d	57		 push	 edi
  0178e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  01793	e8 00 00 00 00	 call	 ?CGRequestQuestStep@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGRequestQuestStep
  01798	5f		 pop	 edi
  01799	5e		 pop	 esi
  0179a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0179b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0179e	33 cd		 xor	 ecx, ebp
  017a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017a5	8b e5		 mov	 esp, ebp
  017a7	5d		 pop	 ebp
  017a8	c3		 ret	 0
$LN309@ProtocolCo:

; 1251 : 						break;
; 1252 : 					case 0x0D:
; 1253 : 						gQuestInfoEx.CGQuestComplete(aRecv,aIndex);

  017a9	56		 push	 esi
  017aa	57		 push	 edi
  017ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  017b0	e8 00 00 00 00	 call	 ?CGQuestComplete@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGQuestComplete
  017b5	5f		 pop	 edi
  017b6	5e		 pop	 esi
  017b7	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  017b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017bb	33 cd		 xor	 ecx, ebp
  017bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017c2	8b e5		 mov	 esp, ebp
  017c4	5d		 pop	 ebp
  017c5	c3		 ret	 0
$LN310@ProtocolCo:

; 1254 : 						break;
; 1255 : 					case 0x0F:
; 1256 : 						gQuestInfoEx.CGQuitQuest(aRecv,aIndex);

  017c6	56		 push	 esi
  017c7	57		 push	 edi
  017c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  017cd	e8 00 00 00 00	 call	 ?CGQuitQuest@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGQuitQuest
  017d2	5f		 pop	 edi
  017d3	5e		 pop	 esi
  017d4	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  017d5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017d8	33 cd		 xor	 ecx, ebp
  017da	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017df	8b e5		 mov	 esp, ebp
  017e1	5d		 pop	 ebp
  017e2	c3		 ret	 0
$LN311@ProtocolCo:

; 1257 : 						break;
; 1258 : 					case 0x10:
; 1259 : 						gQuestInfoEx.CGClientAction(aRecv,aIndex);

  017e3	56		 push	 esi
  017e4	57		 push	 edi
  017e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  017ea	e8 00 00 00 00	 call	 ?CGClientAction@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGClientAction
  017ef	5f		 pop	 edi
  017f0	5e		 pop	 esi
  017f1	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  017f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  017f5	33 cd		 xor	 ecx, ebp
  017f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  017fc	8b e5		 mov	 esp, ebp
  017fe	5d		 pop	 ebp
  017ff	c3		 ret	 0
$LN312@ProtocolCo:

; 1260 : 						break;
; 1261 : 					case 0x1A:
; 1262 : 						gQuestInfoEx.CGRequestQuestState(aIndex);

  01800	56		 push	 esi
  01801	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  01806	e8 00 00 00 00	 call	 ?CGRequestQuestState@CQuestInfoEx@@QAEXH@Z ; CQuestInfoEx::CGRequestQuestState
  0180b	5f		 pop	 edi
  0180c	5e		 pop	 esi
  0180d	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0180e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01811	33 cd		 xor	 ecx, ebp
  01813	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01818	8b e5		 mov	 esp, ebp
  0181a	5d		 pop	 ebp
  0181b	c3		 ret	 0
$LN313@ProtocolCo:

; 1263 : 						break;
; 1264 : 					case 0x1B:
; 1265 : 						gQuestInfoEx.CGReqQuestInfo(aRecv,aIndex);

  0181c	56		 push	 esi
  0181d	57		 push	 edi
  0181e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  01823	e8 00 00 00 00	 call	 ?CGReqQuestInfo@CQuestInfoEx@@QAEXPAEH@Z ; CQuestInfoEx::CGReqQuestInfo
  01828	5f		 pop	 edi
  01829	5e		 pop	 esi
  0182a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0182b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0182e	33 cd		 xor	 ecx, ebp
  01830	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01835	8b e5		 mov	 esp, ebp
  01837	5d		 pop	 ebp
  01838	c3		 ret	 0
$LN315@ProtocolCo:

; 1266 : 						break;
; 1267 : 					case 0x21:
; 1268 : 						break;
; 1269 : 					case 0x30:
; 1270 : 						gQuestInfoEx.GCSendAvaibleQuest(aIndex);

  01839	56		 push	 esi
  0183a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  0183f	e8 00 00 00 00	 call	 ?GCSendAvaibleQuest@CQuestInfoEx@@QAEXH@Z ; CQuestInfoEx::GCSendAvaibleQuest
  01844	5f		 pop	 edi
  01845	5e		 pop	 esi
  01846	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01847	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0184a	33 cd		 xor	 ecx, ebp
  0184c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01851	8b e5		 mov	 esp, ebp
  01853	5d		 pop	 ebp
  01854	c3		 ret	 0
$LN316@ProtocolCo:

; 1271 : 						break;
; 1272 : 					case 0x31:
; 1273 : 						gQuestInfoEx.GCSendBuff(aIndex);

  01855	56		 push	 esi
  01856	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQuestInfoEx@@3VCQuestInfoEx@@A ; gQuestInfoEx
  0185b	e8 00 00 00 00	 call	 ?GCSendBuff@CQuestInfoEx@@QAEXH@Z ; CQuestInfoEx::GCSendBuff
  01860	5f		 pop	 edi
  01861	5e		 pop	 esi
  01862	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01863	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01866	33 cd		 xor	 ecx, ebp
  01868	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0186d	8b e5		 mov	 esp, ebp
  0186f	5d		 pop	 ebp
  01870	c3		 ret	 0
$LN317@ProtocolCo:

; 1274 : 						break;
; 1275 : 					}
; 1276 : 				}
; 1277 : 				break;
; 1278 : #endif
; 1279 : 			case 0xF7:
; 1280 : 				{
; 1281 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1282 : 
; 1283 : 					switch( lpDef->subcode )

  01871	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  01875	83 e8 01	 sub	 eax, 1
  01878	0f 85 51 03 00
	00		 jne	 $LN67@ProtocolCo

; 1284 : 					{
; 1285 : 					case 0x01:
; 1286 : 						CGReqEnterZone((PMSG_REQ_ENTERZONE*)aRecv,aIndex);

  0187e	56		 push	 esi
  0187f	57		 push	 edi
  01880	e8 00 00 00 00	 call	 ?CGReqEnterZone@@YAXPAUPMSG_REQ_ENTERZONE@@H@Z ; CGReqEnterZone
  01885	83 c4 08	 add	 esp, 8
  01888	5f		 pop	 edi
  01889	5e		 pop	 esi
  0188a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  0188b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0188e	33 cd		 xor	 ecx, ebp
  01890	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01895	8b e5		 mov	 esp, ebp
  01897	5d		 pop	 ebp
  01898	c3		 ret	 0
$LN319@ProtocolCo:

; 1287 : 						break;
; 1288 : 					}
; 1289 : 				}
; 1290 : 				break;
; 1291 : 			case 0xF8:
; 1292 : 				{
; 1293 : 
; 1294 : 					//LogAddHeadHexFunc(1,(char*)aRecv,aLen);
; 1295 : 
; 1296 : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 1297 : 
; 1298 : 					switch(lpDef->subcode)

  01899	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0189d	48		 dec	 eax
  0189e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  018a1	0f 87 28 03 00
	00		 ja	 $LN67@ProtocolCo
  018a7	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN346@ProtocolCo[eax]
  018ae	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN364@ProtocolCo[eax*4]
$LN320@ProtocolCo:

; 1299 : 					{
; 1300 : #if (__GENS_SYSTEM__ == 1)
; 1301 : 					case 0x01:
; 1302 : 						gGensSystem.CGJoinRequest(aRecv,aIndex);

  018b5	56		 push	 esi
  018b6	57		 push	 edi
  018b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  018bc	e8 00 00 00 00	 call	 ?CGJoinRequest@CGensSystem@@QAEXPAEH@Z ; CGensSystem::CGJoinRequest
  018c1	5f		 pop	 edi
  018c2	5e		 pop	 esi
  018c3	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  018c4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  018c7	33 cd		 xor	 ecx, ebp
  018c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018ce	8b e5		 mov	 esp, ebp
  018d0	5d		 pop	 ebp
  018d1	c3		 ret	 0
$LN321@ProtocolCo:

; 1303 : 						break;
; 1304 : 					case 0x03:
; 1305 : 						gGensSystem.CGLeaveRequest(aIndex);

  018d2	56		 push	 esi
  018d3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  018d8	e8 00 00 00 00	 call	 ?CGLeaveRequest@CGensSystem@@QAEXH@Z ; CGensSystem::CGLeaveRequest
  018dd	5f		 pop	 edi
  018de	5e		 pop	 esi
  018df	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  018e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  018e3	33 cd		 xor	 ecx, ebp
  018e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  018ea	8b e5		 mov	 esp, ebp
  018ec	5d		 pop	 ebp
  018ed	c3		 ret	 0
$LN322@ProtocolCo:

; 1306 : 						break;
; 1307 : 					case 0x09:
; 1308 : 						gGensSystem.CGRequestPrize(aRecv,aIndex);

  018ee	56		 push	 esi
  018ef	57		 push	 edi
  018f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  018f5	e8 00 00 00 00	 call	 ?CGRequestPrize@CGensSystem@@QAEXPAEH@Z ; CGensSystem::CGRequestPrize
  018fa	5f		 pop	 edi
  018fb	5e		 pop	 esi
  018fc	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  018fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01900	33 cd		 xor	 ecx, ebp
  01902	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01907	8b e5		 mov	 esp, ebp
  01909	5d		 pop	 ebp
  0190a	c3		 ret	 0
$LN323@ProtocolCo:

; 1309 : 						break;
; 1310 : 					case 0x0B:
; 1311 : 						gGensSystem.SendGensInfo(aIndex);

  0190b	56		 push	 esi
  0190c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  01911	e8 00 00 00 00	 call	 ?SendGensInfo@CGensSystem@@QAEXH@Z ; CGensSystem::SendGensInfo
  01916	5f		 pop	 edi
  01917	5e		 pop	 esi
  01918	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01919	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0191c	33 cd		 xor	 ecx, ebp
  0191e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01923	8b e5		 mov	 esp, ebp
  01925	5d		 pop	 ebp
  01926	c3		 ret	 0
$LN324@ProtocolCo:

; 1312 : 						break;
; 1313 : #endif
; 1314 : 					case 0x20:
; 1315 : 						CGReqMoveAcheron(aIndex);

  01927	56		 push	 esi
  01928	e8 00 00 00 00	 call	 ?CGReqMoveAcheron@@YAXH@Z ; CGReqMoveAcheron
  0192d	83 c4 04	 add	 esp, 4
  01930	5f		 pop	 edi
  01931	5e		 pop	 esi
  01932	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01933	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01936	33 cd		 xor	 ecx, ebp
  01938	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0193d	8b e5		 mov	 esp, ebp
  0193f	5d		 pop	 ebp
  01940	c3		 ret	 0
$LN326@ProtocolCo:

; 1316 : 						//CGReqAcheronEnter((_tagPMSG_REQ_ACHERON_ENTER *)aRecv, aIndex);
; 1317 : 						break;
; 1318 : #if (ENABLETEST_ARCA == 1)
; 1319 : 					case 0x30:
; 1320 : 						//CGReqArcaBattleGuildMasterJoin((_tagPMSG_REQ_ARCA_BATTLE_JOIN *)aRecv, aIndex);
; 1321 : 						break;
; 1322 : 					case 0x32:
; 1323 : 						//CGReqArcaBattleGuildMemberJoin((_tagPMSG_REQ_ARCA_BATTLE_JOIN *)aRecv, aIndex);
; 1324 : 						break;
; 1325 : 					case 0x34:
; 1326 : 						//CGReqArcaBattleEnter((_tagPMSG_REQ_ARCA_BATTLE_ENTER *)aRecv, aIndex);
; 1327 : 						break;
; 1328 : 					case 0x36:
; 1329 : 						//CGReqArcaBattleBootyExchange(aIndex);
; 1330 : 						break;
; 1331 : 					case 0x3C:
; 1332 : 						//CGReqSpritemapExchange(aIndex);
; 1333 : 						break;
; 1334 : 					case 0x41:
; 1335 : 						//CGReqRegisteredMemberCnt(aIndex);
; 1336 : 						break;
; 1337 : 					case 0x43:
; 1338 : 						//g_ArcaBattle.CGReqMarkReg(aIndex);
; 1339 : 						break;
; 1340 : 					case 0x45:
; 1341 : 						//g_ArcaBattle.CGReqMarkRank(aIndex);
; 1342 : 						break;
; 1343 : #endif
; 1344 : #if (ENABLETEST_ACHERON == 1)
; 1345 : 					case 0x4B:
; 1346 : 						g_AcheronGuardianEvent.CGReqAcheronEventEnter((_tagPMSG_REQ_ACHERON_EVENT_ENTER*)aRecv, aIndex);
; 1347 : 						break;
; 1348 : #endif
; 1349 : 					}
; 1350 : 				}
; 1351 : 				break;
; 1352 : #if (ENABLETEST_MUUN == 1)
; 1353 : 			case 0xF1:
; 1354 : 				g_CMuunSystem.DGLoadMuunInvenItem((_tagSDHP_ANS_DBMUUN_INVEN_LOAD *)aRecv);
; 1355 : 				break;
; 1356 : #endif
; 1357 : 			case 0xFC:
; 1358 : 				{
; 1359 : 					
; 1360 : 				}
; 1361 : 				break;
; 1362 : 
; 1363 : 
; 1364 : 			default:
; 1365 : 				LogAddC(2, "error-L2 : account:%s name:%s HEAD:%x (%s,%d) State:%d",

  01941	ff 71 04	 push	 DWORD PTR [ecx+4]
  01944	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  01947	68 56 05 00 00	 push	 1366			; 00000556H
  0194c	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ENFKFPKA@protocol?4cpp?$AA@
  01951	52		 push	 edx
  01952	50		 push	 eax
  01953	8d 41 52	 lea	 eax, DWORD PTR [ecx+82]
  01956	50		 push	 eax
  01957	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@ONNNLLKC@error?9L2?5?3?5account?3?$CFs?5name?3?$CFs?5HE@
  0195c	6a 02		 push	 2
  0195e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 1366 : 					gObj[aIndex].AccountID, gObj[aIndex].Name, protoNum, __FILE__, __LINE__, gObj[aIndex].Connected);
; 1367 : 				CloseClient(aIndex);

  01964	56		 push	 esi
  01965	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0196a	83 c4 24	 add	 esp, 36			; 00000024H
  0196d	5f		 pop	 edi
  0196e	5e		 pop	 esi
  0196f	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01970	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01973	33 cd		 xor	 ecx, ebp
  01975	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0197a	8b e5		 mov	 esp, ebp
  0197c	5d		 pop	 ebp
  0197d	c3		 ret	 0
$LN65@ProtocolCo:

; 176  : 	{
; 177  : #if( DEBUG_PROTOCOL == 1 )
; 178  : 		LogAddHeadHexFunc(1, (LPSTR)aRecv, aLen);
; 179  : #endif
; 180  : 		switch ( protoNum )

  0197e	0f b6 c3	 movzx	 eax, bl
  01981	83 e8 0e	 sub	 eax, 14			; 0000000eH
  01984	0f 84 24 02 00
	00		 je	 $LN66@ProtocolCo
  0198a	2d e3 00 00 00	 sub	 eax, 227		; 000000e3H
  0198f	0f 84 7a 01 00
	00		 je	 $LN68@ProtocolCo
  01995	83 e8 02	 sub	 eax, 2
  01998	0f 85 31 02 00
	00		 jne	 $LN67@ProtocolCo

; 211  : 							}
; 212  : 							break;
; 213  : 					}
; 214  : 				}
; 215  : 				break;
; 216  : 			case 0xF3:
; 217  : 				{
; 218  : 					PMSG_DEFAULT2 * lpDef = (PMSG_DEFAULT2 *)aRecv;
; 219  : 
; 220  : 					switch ( lpDef->subcode )

  0199e	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  019a2	83 f8 52	 cmp	 eax, 82			; 00000052H
  019a5	0f 87 24 02 00
	00		 ja	 $LN67@ProtocolCo
  019ab	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN347@ProtocolCo[eax]
  019b2	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN365@ProtocolCo[eax*4]
$LN76@ProtocolCo:

; 221  : 					{
; 222  : 						case 0x00:
; 223  : 							DataServerGetCharListRequest(aIndex);

  019b9	56		 push	 esi
  019ba	e8 00 00 00 00	 call	 ?DataServerGetCharListRequest@@YAXF@Z ; DataServerGetCharListRequest
  019bf	83 c4 04	 add	 esp, 4
  019c2	5f		 pop	 edi
  019c3	5e		 pop	 esi
  019c4	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  019c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  019c8	33 cd		 xor	 ecx, ebp
  019ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  019cf	8b e5		 mov	 esp, ebp
  019d1	5d		 pop	 ebp
  019d2	c3		 ret	 0
$LN77@ProtocolCo:

; 224  : 							break;
; 225  : 						case 0x01:
; 226  : 							CGPCharacterCreate((PMSG_CHARCREATE *)aRecv, aIndex);

  019d3	56		 push	 esi
  019d4	57		 push	 edi
  019d5	e8 00 00 00 00	 call	 ?CGPCharacterCreate@@YAXPAUPMSG_CHARCREATE@@H@Z ; CGPCharacterCreate
  019da	83 c4 08	 add	 esp, 8
  019dd	5f		 pop	 edi
  019de	5e		 pop	 esi
  019df	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  019e0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  019e3	33 cd		 xor	 ecx, ebp
  019e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  019ea	8b e5		 mov	 esp, ebp
  019ec	5d		 pop	 ebp
  019ed	c3		 ret	 0
$LN78@ProtocolCo:

; 227  : 							break;
; 228  : 						case 0x02:
; 229  : 							CGPCharDel((PMSG_CHARDELETE *)aRecv, aIndex);

  019ee	56		 push	 esi
  019ef	57		 push	 edi
  019f0	e8 00 00 00 00	 call	 ?CGPCharDel@@YAXPAUPMSG_CHARDELETE@@H@Z ; CGPCharDel
  019f5	83 c4 08	 add	 esp, 8
  019f8	5f		 pop	 edi
  019f9	5e		 pop	 esi
  019fa	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  019fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  019fe	33 cd		 xor	 ecx, ebp
  01a00	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a05	8b e5		 mov	 esp, ebp
  01a07	5d		 pop	 ebp
  01a08	c3		 ret	 0
$LN79@ProtocolCo:

; 230  : 							break;
; 231  : 						case 0x03:
; 232  : 							CGPCharacterMapJoinRequest((PMSG_CHARMAPJOIN *)aRecv, aIndex);

  01a09	56		 push	 esi
  01a0a	57		 push	 edi
  01a0b	e8 00 00 00 00	 call	 ?CGPCharacterMapJoinRequest@@YAXPAUPMSG_CHARMAPJOIN@@H@Z ; CGPCharacterMapJoinRequest
  01a10	83 c4 08	 add	 esp, 8
  01a13	5f		 pop	 edi
  01a14	5e		 pop	 esi
  01a15	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01a16	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a19	33 cd		 xor	 ecx, ebp
  01a1b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a20	8b e5		 mov	 esp, ebp
  01a22	5d		 pop	 ebp
  01a23	c3		 ret	 0
$LN80@ProtocolCo:

; 233  : 							break;
; 234  : 						case 0x06:
; 235  : 							CGLevelUpPointAdd((PMSG_LVPOINTADD *)aRecv, aIndex);

  01a24	56		 push	 esi
  01a25	57		 push	 edi
  01a26	e8 00 00 00 00	 call	 ?CGLevelUpPointAdd@@YAXPAUPMSG_LVPOINTADD@@H@Z ; CGLevelUpPointAdd
  01a2b	83 c4 08	 add	 esp, 8
  01a2e	5f		 pop	 edi
  01a2f	5e		 pop	 esi
  01a30	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01a31	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a34	33 cd		 xor	 ecx, ebp
  01a36	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a3b	8b e5		 mov	 esp, ebp
  01a3d	5d		 pop	 ebp
  01a3e	c3		 ret	 0
$LN81@ProtocolCo:

; 236  : 							break;
; 237  : 						case 0x12:
; 238  : 							gObjMoveDataLoadingOK(aIndex);

  01a3f	56		 push	 esi
  01a40	e8 00 00 00 00	 call	 ?gObjMoveDataLoadingOK@@YAXH@Z ; gObjMoveDataLoadingOK
  01a45	83 c4 04	 add	 esp, 4
  01a48	5f		 pop	 edi
  01a49	5e		 pop	 esi
  01a4a	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01a4b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01a4e	33 cd		 xor	 ecx, ebp
  01a50	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01a55	8b e5		 mov	 esp, ebp
  01a57	5d		 pop	 ebp
  01a58	c3		 ret	 0
$LN82@ProtocolCo:

; 239  : 							break;
; 240  : 						case 0x15:
; 241  : 							{
; 242  : 								PMSG_REQ_CHAR_PASSWORD* lpMsg = (PMSG_REQ_CHAR_PASSWORD*)aRecv;
; 243  : 								PMSG_ANS_CHECK_PASSWORD pMsg;
; 244  : 
; 245  : 								PHeadSubSetB((LPBYTE)&pMsg,0xF3,0x16,sizeof(pMsg));

  01a59	6a 19		 push	 25			; 00000019H
  01a5b	6a 16		 push	 22			; 00000016H
  01a5d	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$3[ebp]
  01a60	68 f3 00 00 00	 push	 243			; 000000f3H
  01a65	50		 push	 eax
  01a66	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 246  : 								memcpy(pMsg.Password,"1111111111",10);

  01a6b	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0L@HMJAEILC@1111111111?$AA@+8
  01a72	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@HMJAEILC@1111111111?$AA@
  01a7a	66 89 45 ec	 mov	 WORD PTR _pMsg$3[ebp+12], ax

; 247  : 								memcpy(pMsg.Name,lpMsg->Name,10);

  01a7e	0f b7 47 0c	 movzx	 eax, WORD PTR [edi+12]
  01a82	66 89 45 f6	 mov	 WORD PTR _pMsg$3[ebp+22], ax

; 248  : 
; 249  : 								pMsg.btResult = 0;
; 250  : 
; 251  : 								DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  01a86	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$3[ebp+1]
  01a8a	50		 push	 eax
  01a8b	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$3[ebp]
  01a8e	66 0f d6 45 e4	 movq	 QWORD PTR _pMsg$3[ebp+4], xmm0
  01a93	f3 0f 7e 47 04	 movq	 xmm0, QWORD PTR [edi+4]
  01a98	50		 push	 eax
  01a99	56		 push	 esi
  01a9a	66 0f d6 45 ee	 movq	 QWORD PTR _pMsg$3[ebp+14], xmm0
  01a9f	c6 45 f8 00	 mov	 BYTE PTR _pMsg$3[ebp+24], 0
  01aa3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01aa8	83 c4 1c	 add	 esp, 28			; 0000001cH
  01aab	5f		 pop	 edi
  01aac	5e		 pop	 esi
  01aad	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01aae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ab1	33 cd		 xor	 ecx, ebp
  01ab3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01ab8	8b e5		 mov	 esp, ebp
  01aba	5d		 pop	 ebp
  01abb	c3		 ret	 0
$LN83@ProtocolCo:

; 252  : 							}
; 253  : 							break;
; 254  : 						/*case 0x15:
; 255  : 						  CGReqCheckChangeName
; 256  : 						  break;
; 257  : 						case 0x16:
; 258  : 						  CGChangeName
; 259  : 						  break;*/
; 260  : 						case 0x21:
; 261  : 							CGEnableUsePolymorphSkinrRecv((PMSG_REQ_USE_POLYMORPH_SKIN*)aRecv, aIndex);

  01abc	56		 push	 esi
  01abd	57		 push	 edi
  01abe	e8 00 00 00 00	 call	 ?CGEnableUsePolymorphSkinrRecv@@YAXPAUPMSG_REQ_USE_POLYMORPH_SKIN@@H@Z ; CGEnableUsePolymorphSkinrRecv
  01ac3	83 c4 08	 add	 esp, 8
  01ac6	5f		 pop	 edi
  01ac7	5e		 pop	 esi
  01ac8	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01ac9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01acc	33 cd		 xor	 ecx, ebp
  01ace	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01ad3	8b e5		 mov	 esp, ebp
  01ad5	5d		 pop	 ebp
  01ad6	c3		 ret	 0
$LN84@ProtocolCo:

; 262  : 						  break;
; 263  : 						case 0x30:
; 264  : 							GCSkillKeyRecv((PMSG_SKILLKEY *)aRecv, aIndex);

  01ad7	56		 push	 esi
  01ad8	57		 push	 edi
  01ad9	e8 00 00 00 00	 call	 ?GCSkillKeyRecv@@YAXPAUPMSG_SKILLKEY@@H@Z ; GCSkillKeyRecv
  01ade	83 c4 08	 add	 esp, 8
  01ae1	5f		 pop	 edi
  01ae2	5e		 pop	 esi
  01ae3	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01ae4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ae7	33 cd		 xor	 ecx, ebp
  01ae9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01aee	8b e5		 mov	 esp, ebp
  01af0	5d		 pop	 ebp
  01af1	c3		 ret	 0
$LN86@ProtocolCo:

; 265  : 							break;
; 266  : 						case 0x31:
; 267  : 							//CGNotifyGuarditBreach
; 268  : 							break;
; 269  : 						case 0x52:
; 270  : 							g_MasterSkillSystem.CGReqGetMasterLevelSkill((PMSG_REQ_MASTERLEVEL_SKILL*)aRecv,aIndex);

  01af2	56		 push	 esi
  01af3	57		 push	 edi
  01af4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MasterSkillSystem@@3VCMasterLevelSkillTreeSystem@@A ; g_MasterSkillSystem
  01af9	e8 00 00 00 00	 call	 ?CGReqGetMasterLevelSkill@CMasterLevelSkillTreeSystem@@QAEXPAUPMSG_REQ_MASTERLEVEL_SKILL@@H@Z ; CMasterLevelSkillTreeSystem::CGReqGetMasterLevelSkill
  01afe	5f		 pop	 edi
  01aff	5e		 pop	 esi
  01b00	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01b01	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b04	33 cd		 xor	 ecx, ebp
  01b06	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b0b	8b e5		 mov	 esp, ebp
  01b0d	5d		 pop	 ebp
  01b0e	c3		 ret	 0
$LN68@ProtocolCo:

; 187  : 				}
; 188  : 				break;
; 189  : 			case 0xF1:
; 190  : 				{
; 191  : 					PMSG_DEFAULT2 * lpMsg2 = (PMSG_DEFAULT2 *)aRecv;
; 192  : 					
; 193  : 					switch ( lpMsg2->subcode )

  01b0f	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  01b13	83 e8 01	 sub	 eax, 1
  01b16	74 6a		 je	 SHORT $LN69@ProtocolCo
  01b18	83 e8 01	 sub	 eax, 1
  01b1b	74 39		 je	 SHORT $LN71@ProtocolCo
  01b1d	83 e8 01	 sub	 eax, 1
  01b20	0f 85 a9 00 00
	00		 jne	 $LN67@ProtocolCo

; 205  : 							}
; 206  : 							break;
; 207  : 						case 0x03:
; 208  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  01b26	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  01b29	53		 push	 ebx
  01b2a	56		 push	 esi
  01b2b	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01b30	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b33	85 c0		 test	 eax, eax
  01b35	0f 84 94 00 00
	00		 je	 $LN67@ProtocolCo

; 209  : 							{
; 210  : 								CGClientMsg((PMSG_CLIENTMSG *)aRecv, aIndex);

  01b3b	56		 push	 esi
  01b3c	57		 push	 edi
  01b3d	e8 00 00 00 00	 call	 ?CGClientMsg@@YAXPAUPMSG_CLIENTMSG@@H@Z ; CGClientMsg
  01b42	83 c4 08	 add	 esp, 8
  01b45	5f		 pop	 edi
  01b46	5e		 pop	 esi
  01b47	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01b48	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b4b	33 cd		 xor	 ecx, ebp
  01b4d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b52	8b e5		 mov	 esp, ebp
  01b54	5d		 pop	 ebp
  01b55	c3		 ret	 0
$LN71@ProtocolCo:

; 199  : 							}
; 200  : 							break;
; 201  : 						case 0x02:
; 202  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  01b56	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  01b59	53		 push	 ebx
  01b5a	56		 push	 esi
  01b5b	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01b60	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b63	85 c0		 test	 eax, eax
  01b65	74 68		 je	 SHORT $LN67@ProtocolCo

; 203  : 							{
; 204  : 								CGClientCloseMsg((PMSG_CLIENTCLOSE *)aRecv, aIndex);

  01b67	56		 push	 esi
  01b68	57		 push	 edi
  01b69	e8 00 00 00 00	 call	 ?CGClientCloseMsg@@YAXPAUPMSG_CLIENTCLOSE@@H@Z ; CGClientCloseMsg
  01b6e	83 c4 08	 add	 esp, 8
  01b71	5f		 pop	 edi
  01b72	5e		 pop	 esi
  01b73	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01b74	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01b77	33 cd		 xor	 ecx, ebp
  01b79	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01b7e	8b e5		 mov	 esp, ebp
  01b80	5d		 pop	 ebp
  01b81	c3		 ret	 0
$LN69@ProtocolCo:

; 194  : 					{
; 195  : 						case 0x01:
; 196  : 							if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  01b82	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  01b85	53		 push	 ebx
  01b86	56		 push	 esi
  01b87	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01b8c	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b8f	85 c0		 test	 eax, eax
  01b91	74 3c		 je	 SHORT $LN67@ProtocolCo

; 197  : 							{
; 198  : 								CSPJoinIdPassRequest((PMSG_IDPASS *)aRecv, aIndex);

  01b93	56		 push	 esi
  01b94	57		 push	 edi
  01b95	e8 00 00 00 00	 call	 ?CSPJoinIdPassRequest@@YAXPAUPMSG_IDPASS@@H@Z ; CSPJoinIdPassRequest
  01b9a	83 c4 08	 add	 esp, 8
  01b9d	5f		 pop	 edi
  01b9e	5e		 pop	 esi
  01b9f	5b		 pop	 ebx

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01ba0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01ba3	33 cd		 xor	 ecx, ebp
  01ba5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01baa	8b e5		 mov	 esp, ebp
  01bac	5d		 pop	 ebp
  01bad	c3		 ret	 0
$LN66@ProtocolCo:

; 181  : 		{
; 182  : 			case 0x0E:
; 183  : 				if ( DataEncryptCheck(aIndex, protoNum, Encrypt) != FALSE )

  01bae	ff 75 18	 push	 DWORD PTR _Encrypt$[ebp]
  01bb1	53		 push	 ebx
  01bb2	56		 push	 esi
  01bb3	e8 00 00 00 00	 call	 ?DataEncryptCheck@@YAHHEH@Z ; DataEncryptCheck
  01bb8	83 c4 0c	 add	 esp, 12			; 0000000cH
  01bbb	85 c0		 test	 eax, eax
  01bbd	74 10		 je	 SHORT $LN67@ProtocolCo

; 184  : 				{
; 185  : 					CGLiveClient((PMSG_CLIENTTIME *)aRecv, aIndex);

  01bbf	56		 push	 esi
  01bc0	57		 push	 edi
  01bc1	e8 00 00 00 00	 call	 ?CGLiveClient@@YAXPAUPMSG_CLIENTTIME@@F@Z ; CGLiveClient

; 186  : 					tempindex = aIndex;

  01bc6	89 35 00 00 00
	00		 mov	 DWORD PTR ?tempindex@@3HA, esi ; tempindex
  01bcc	83 c4 08	 add	 esp, 8
$LN67@ProtocolCo:

; 1368 : 
; 1369 : 
; 1370 : 		}	
; 1371 : 	}
; 1372 : }

  01bcf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01bd2	5f		 pop	 edi
  01bd3	5e		 pop	 esi
  01bd4	33 cd		 xor	 ecx, ebp
  01bd6	5b		 pop	 ebx
  01bd7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01bdc	8b e5		 mov	 esp, ebp
  01bde	5d		 pop	 ebp
  01bdf	c3		 ret	 0
$LN354@ProtocolCo:
  01be0	00 00 00 00	 DD	 $LN87@ProtocolCo
  01be4	00 00 00 00	 DD	 $LN88@ProtocolCo
  01be8	00 00 00 00	 DD	 $LN89@ProtocolCo
  01bec	00 00 00 00	 DD	 $LN90@ProtocolCo
  01bf0	00 00 00 00	 DD	 $LN67@ProtocolCo
  01bf4	00 00 00 00	 DD	 $LN92@ProtocolCo
  01bf8	00 00 00 00	 DD	 $LN95@ProtocolCo
  01bfc	00 00 00 00	 DD	 $LN94@ProtocolCo
  01c00	00 00 00 00	 DD	 $LN96@ProtocolCo
  01c04	00 00 00 00	 DD	 $LN97@ProtocolCo
  01c08	00 00 00 00	 DD	 $LN99@ProtocolCo
  01c0c	00 00 00 00	 DD	 $LN100@ProtocolCo
  01c10	00 00 00 00	 DD	 $LN105@ProtocolCo
  01c14	00 00 00 00	 DD	 $LN107@ProtocolCo
  01c18	00 00 00 00	 DD	 $LN109@ProtocolCo
  01c1c	00 00 00 00	 DD	 $LN110@ProtocolCo
  01c20	00 00 00 00	 DD	 $LN111@ProtocolCo
  01c24	00 00 00 00	 DD	 $LN112@ProtocolCo
  01c28	00 00 00 00	 DD	 $LN114@ProtocolCo
  01c2c	00 00 00 00	 DD	 $LN115@ProtocolCo
  01c30	00 00 00 00	 DD	 $LN117@ProtocolCo
  01c34	00 00 00 00	 DD	 $LN119@ProtocolCo
  01c38	00 00 00 00	 DD	 $LN120@ProtocolCo
  01c3c	00 00 00 00	 DD	 $LN122@ProtocolCo
  01c40	00 00 00 00	 DD	 $LN123@ProtocolCo
  01c44	00 00 00 00	 DD	 $LN124@ProtocolCo
  01c48	00 00 00 00	 DD	 $LN126@ProtocolCo
  01c4c	00 00 00 00	 DD	 $LN128@ProtocolCo
  01c50	00 00 00 00	 DD	 $LN134@ProtocolCo
  01c54	00 00 00 00	 DD	 $LN136@ProtocolCo
  01c58	00 00 00 00	 DD	 $LN138@ProtocolCo
  01c5c	00 00 00 00	 DD	 $LN139@ProtocolCo
  01c60	00 00 00 00	 DD	 $LN142@ProtocolCo
  01c64	00 00 00 00	 DD	 $LN143@ProtocolCo
  01c68	00 00 00 00	 DD	 $LN144@ProtocolCo
  01c6c	00 00 00 00	 DD	 $LN148@ProtocolCo
  01c70	00 00 00 00	 DD	 $LN149@ProtocolCo
  01c74	00 00 00 00	 DD	 $LN150@ProtocolCo
  01c78	00 00 00 00	 DD	 $LN151@ProtocolCo
  01c7c	00 00 00 00	 DD	 $LN152@ProtocolCo
  01c80	00 00 00 00	 DD	 $LN153@ProtocolCo
  01c84	00 00 00 00	 DD	 $LN154@ProtocolCo
  01c88	00 00 00 00	 DD	 $LN155@ProtocolCo
  01c8c	00 00 00 00	 DD	 $LN156@ProtocolCo
  01c90	00 00 00 00	 DD	 $LN243@ProtocolCo
  01c94	00 00 00 00	 DD	 $LN245@ProtocolCo
  01c98	00 00 00 00	 DD	 $LN247@ProtocolCo
  01c9c	00 00 00 00	 DD	 $LN248@ProtocolCo
  01ca0	00 00 00 00	 DD	 $LN249@ProtocolCo
  01ca4	00 00 00 00	 DD	 $LN250@ProtocolCo
  01ca8	00 00 00 00	 DD	 $LN251@ProtocolCo
  01cac	00 00 00 00	 DD	 $LN252@ProtocolCo
  01cb0	00 00 00 00	 DD	 $LN253@ProtocolCo
  01cb4	00 00 00 00	 DD	 $LN254@ProtocolCo
  01cb8	00 00 00 00	 DD	 $LN255@ProtocolCo
  01cbc	00 00 00 00	 DD	 $LN256@ProtocolCo
  01cc0	00 00 00 00	 DD	 $LN257@ProtocolCo
  01cc4	00 00 00 00	 DD	 $LN258@ProtocolCo
  01cc8	00 00 00 00	 DD	 $LN259@ProtocolCo
  01ccc	00 00 00 00	 DD	 $LN275@ProtocolCo
  01cd0	00 00 00 00	 DD	 $LN278@ProtocolCo
  01cd4	00 00 00 00	 DD	 $LN277@ProtocolCo
  01cd8	00 00 00 00	 DD	 $LN260@ProtocolCo
  01cdc	00 00 00 00	 DD	 $LN261@ProtocolCo
  01ce0	00 00 00 00	 DD	 $LN262@ProtocolCo
  01ce4	00 00 00 00	 DD	 $LN263@ProtocolCo
  01ce8	00 00 00 00	 DD	 $LN264@ProtocolCo
  01cec	00 00 00 00	 DD	 $LN274@ProtocolCo
  01cf0	00 00 00 00	 DD	 $LN279@ProtocolCo
  01cf4	00 00 00 00	 DD	 $LN102@ProtocolCo
  01cf8	00 00 00 00	 DD	 $LN157@ProtocolCo
  01cfc	00 00 00 00	 DD	 $LN160@ProtocolCo
  01d00	00 00 00 00	 DD	 $LN177@ProtocolCo
  01d04	00 00 00 00	 DD	 $LN178@ProtocolCo
  01d08	00 00 00 00	 DD	 $LN179@ProtocolCo
  01d0c	00 00 00 00	 DD	 $LN180@ProtocolCo
  01d10	00 00 00 00	 DD	 $LN183@ProtocolCo
  01d14	00 00 00 00	 DD	 $LN186@ProtocolCo
  01d18	00 00 00 00	 DD	 $LN189@ProtocolCo
  01d1c	00 00 00 00	 DD	 $LN193@ProtocolCo
  01d20	00 00 00 00	 DD	 $LN282@ProtocolCo
  01d24	00 00 00 00	 DD	 $LN283@ProtocolCo
  01d28	00 00 00 00	 DD	 $LN284@ProtocolCo
  01d2c	00 00 00 00	 DD	 $LN285@ProtocolCo
  01d30	00 00 00 00	 DD	 $LN286@ProtocolCo
  01d34	00 00 00 00	 DD	 $LN287@ProtocolCo
  01d38	00 00 00 00	 DD	 $LN288@ProtocolCo
  01d3c	00 00 00 00	 DD	 $LN289@ProtocolCo
  01d40	00 00 00 00	 DD	 $LN290@ProtocolCo
  01d44	00 00 00 00	 DD	 $LN291@ProtocolCo
  01d48	00 00 00 00	 DD	 $LN292@ProtocolCo
  01d4c	00 00 00 00	 DD	 $LN293@ProtocolCo
  01d50	00 00 00 00	 DD	 $LN296@ProtocolCo
  01d54	00 00 00 00	 DD	 $LN299@ProtocolCo
  01d58	00 00 00 00	 DD	 $LN93@ProtocolCo
  01d5c	00 00 00 00	 DD	 $LN104@ProtocolCo
  01d60	00 00 00 00	 DD	 $LN202@ProtocolCo
  01d64	00 00 00 00	 DD	 $LN203@ProtocolCo
  01d68	00 00 00 00	 DD	 $LN204@ProtocolCo
  01d6c	00 00 00 00	 DD	 $LN205@ProtocolCo
  01d70	00 00 00 00	 DD	 $LN206@ProtocolCo
  01d74	00 00 00 00	 DD	 $LN210@ProtocolCo
  01d78	00 00 00 00	 DD	 $LN240@ProtocolCo
  01d7c	00 00 00 00	 DD	 $LN211@ProtocolCo
  01d80	00 00 00 00	 DD	 $LN217@ProtocolCo
  01d84	00 00 00 00	 DD	 $LN231@ProtocolCo
  01d88	00 00 00 00	 DD	 $LN306@ProtocolCo
  01d8c	00 00 00 00	 DD	 $LN317@ProtocolCo
  01d90	00 00 00 00	 DD	 $LN319@ProtocolCo
  01d94	00 00 00 00	 DD	 $LN227@ProtocolCo
  01d98	00 00 00 00	 DD	 $LN326@ProtocolCo
$LN341@ProtocolCo:
  01d9c	00		 DB	 0
  01d9d	01		 DB	 1
  01d9e	02		 DB	 2
  01d9f	03		 DB	 3
  01da0	04		 DB	 4
  01da1	6e		 DB	 110			; 0000006eH
  01da2	6e		 DB	 110			; 0000006eH
  01da3	6e		 DB	 110			; 0000006eH
  01da4	6e		 DB	 110			; 0000006eH
  01da5	6e		 DB	 110			; 0000006eH
  01da6	6e		 DB	 110			; 0000006eH
  01da7	6e		 DB	 110			; 0000006eH
  01da8	6e		 DB	 110			; 0000006eH
  01da9	6e		 DB	 110			; 0000006eH
  01daa	05		 DB	 5
  01dab	6e		 DB	 110			; 0000006eH
  01dac	6e		 DB	 110			; 0000006eH
  01dad	06		 DB	 6
  01dae	6e		 DB	 110			; 0000006eH
  01daf	6e		 DB	 110			; 0000006eH
  01db0	6e		 DB	 110			; 0000006eH
  01db1	07		 DB	 7
  01db2	6e		 DB	 110			; 0000006eH
  01db3	6e		 DB	 110			; 0000006eH
  01db4	08		 DB	 8
  01db5	09		 DB	 9
  01db6	6e		 DB	 110			; 0000006eH
  01db7	0a		 DB	 10			; 0000000aH
  01db8	0b		 DB	 11			; 0000000bH
  01db9	6e		 DB	 110			; 0000006eH
  01dba	0c		 DB	 12			; 0000000cH
  01dbb	6e		 DB	 110			; 0000006eH
  01dbc	6e		 DB	 110			; 0000006eH
  01dbd	6e		 DB	 110			; 0000006eH
  01dbe	0d		 DB	 13			; 0000000dH
  01dbf	0e		 DB	 14			; 0000000eH
  01dc0	0f		 DB	 15			; 0000000fH
  01dc1	6e		 DB	 110			; 0000006eH
  01dc2	10		 DB	 16			; 00000010H
  01dc3	6e		 DB	 110			; 0000006eH
  01dc4	6e		 DB	 110			; 0000006eH
  01dc5	6e		 DB	 110			; 0000006eH
  01dc6	6e		 DB	 110			; 0000006eH
  01dc7	6e		 DB	 110			; 0000006eH
  01dc8	6e		 DB	 110			; 0000006eH
  01dc9	6e		 DB	 110			; 0000006eH
  01dca	6e		 DB	 110			; 0000006eH
  01dcb	6e		 DB	 110			; 0000006eH
  01dcc	11		 DB	 17			; 00000011H
  01dcd	12		 DB	 18			; 00000012H
  01dce	13		 DB	 19			; 00000013H
  01dcf	14		 DB	 20			; 00000014H
  01dd0	15		 DB	 21			; 00000015H
  01dd1	6e		 DB	 110			; 0000006eH
  01dd2	16		 DB	 22			; 00000016H
  01dd3	17		 DB	 23			; 00000017H
  01dd4	6e		 DB	 110			; 0000006eH
  01dd5	6e		 DB	 110			; 0000006eH
  01dd6	18		 DB	 24			; 00000018H
  01dd7	6e		 DB	 110			; 0000006eH
  01dd8	19		 DB	 25			; 00000019H
  01dd9	1a		 DB	 26			; 0000001aH
  01dda	6e		 DB	 110			; 0000006eH
  01ddb	1b		 DB	 27			; 0000001bH
  01ddc	1c		 DB	 28			; 0000001cH
  01ddd	1d		 DB	 29			; 0000001dH
  01dde	1e		 DB	 30			; 0000001eH
  01ddf	1f		 DB	 31			; 0000001fH
  01de0	6e		 DB	 110			; 0000006eH
  01de1	6e		 DB	 110			; 0000006eH
  01de2	6e		 DB	 110			; 0000006eH
  01de3	6e		 DB	 110			; 0000006eH
  01de4	6e		 DB	 110			; 0000006eH
  01de5	6e		 DB	 110			; 0000006eH
  01de6	20		 DB	 32			; 00000020H
  01de7	21		 DB	 33			; 00000021H
  01de8	22		 DB	 34			; 00000022H
  01de9	6e		 DB	 110			; 0000006eH
  01dea	6e		 DB	 110			; 0000006eH
  01deb	6e		 DB	 110			; 0000006eH
  01dec	23		 DB	 35			; 00000023H
  01ded	24		 DB	 36			; 00000024H
  01dee	25		 DB	 37			; 00000025H
  01def	26		 DB	 38			; 00000026H
  01df0	27		 DB	 39			; 00000027H
  01df1	28		 DB	 40			; 00000028H
  01df2	6e		 DB	 110			; 0000006eH
  01df3	29		 DB	 41			; 00000029H
  01df4	6e		 DB	 110			; 0000006eH
  01df5	6e		 DB	 110			; 0000006eH
  01df6	6e		 DB	 110			; 0000006eH
  01df7	6e		 DB	 110			; 0000006eH
  01df8	6e		 DB	 110			; 0000006eH
  01df9	6e		 DB	 110			; 0000006eH
  01dfa	6e		 DB	 110			; 0000006eH
  01dfb	6e		 DB	 110			; 0000006eH
  01dfc	6e		 DB	 110			; 0000006eH
  01dfd	2a		 DB	 42			; 0000002aH
  01dfe	6e		 DB	 110			; 0000006eH
  01dff	6e		 DB	 110			; 0000006eH
  01e00	6e		 DB	 110			; 0000006eH
  01e01	6e		 DB	 110			; 0000006eH
  01e02	2b		 DB	 43			; 0000002bH
  01e03	6e		 DB	 110			; 0000006eH
  01e04	6e		 DB	 110			; 0000006eH
  01e05	6e		 DB	 110			; 0000006eH
  01e06	6e		 DB	 110			; 0000006eH
  01e07	6e		 DB	 110			; 0000006eH
  01e08	6e		 DB	 110			; 0000006eH
  01e09	6e		 DB	 110			; 0000006eH
  01e0a	6e		 DB	 110			; 0000006eH
  01e0b	6e		 DB	 110			; 0000006eH
  01e0c	6e		 DB	 110			; 0000006eH
  01e0d	04		 DB	 4
  01e0e	2c		 DB	 44			; 0000002cH
  01e0f	2d		 DB	 45			; 0000002dH
  01e10	6e		 DB	 110			; 0000006eH
  01e11	6e		 DB	 110			; 0000006eH
  01e12	6e		 DB	 110			; 0000006eH
  01e13	6e		 DB	 110			; 0000006eH
  01e14	6e		 DB	 110			; 0000006eH
  01e15	6e		 DB	 110			; 0000006eH
  01e16	6e		 DB	 110			; 0000006eH
  01e17	6e		 DB	 110			; 0000006eH
  01e18	6e		 DB	 110			; 0000006eH
  01e19	6e		 DB	 110			; 0000006eH
  01e1a	6e		 DB	 110			; 0000006eH
  01e1b	6e		 DB	 110			; 0000006eH
  01e1c	6e		 DB	 110			; 0000006eH
  01e1d	2e		 DB	 46			; 0000002eH
  01e1e	2f		 DB	 47			; 0000002fH
  01e1f	30		 DB	 48			; 00000030H
  01e20	6e		 DB	 110			; 0000006eH
  01e21	6e		 DB	 110			; 0000006eH
  01e22	31		 DB	 49			; 00000031H
  01e23	32		 DB	 50			; 00000032H
  01e24	6e		 DB	 110			; 0000006eH
  01e25	6e		 DB	 110			; 0000006eH
  01e26	6e		 DB	 110			; 0000006eH
  01e27	6e		 DB	 110			; 0000006eH
  01e28	6e		 DB	 110			; 0000006eH
  01e29	6e		 DB	 110			; 0000006eH
  01e2a	33		 DB	 51			; 00000033H
  01e2b	6e		 DB	 110			; 0000006eH
  01e2c	34		 DB	 52			; 00000034H
  01e2d	35		 DB	 53			; 00000035H
  01e2e	6e		 DB	 110			; 0000006eH
  01e2f	6e		 DB	 110			; 0000006eH
  01e30	6e		 DB	 110			; 0000006eH
  01e31	36		 DB	 54			; 00000036H
  01e32	37		 DB	 55			; 00000037H
  01e33	38		 DB	 56			; 00000038H
  01e34	39		 DB	 57			; 00000039H
  01e35	3a		 DB	 58			; 0000003aH
  01e36	3b		 DB	 59			; 0000003bH
  01e37	04		 DB	 4
  01e38	6e		 DB	 110			; 0000006eH
  01e39	3c		 DB	 60			; 0000003cH
  01e3a	6e		 DB	 110			; 0000006eH
  01e3b	3d		 DB	 61			; 0000003dH
  01e3c	3e		 DB	 62			; 0000003eH
  01e3d	6e		 DB	 110			; 0000006eH
  01e3e	3f		 DB	 63			; 0000003fH
  01e3f	6e		 DB	 110			; 0000006eH
  01e40	6e		 DB	 110			; 0000006eH
  01e41	6e		 DB	 110			; 0000006eH
  01e42	6e		 DB	 110			; 0000006eH
  01e43	40		 DB	 64			; 00000040H
  01e44	6e		 DB	 110			; 0000006eH
  01e45	41		 DB	 65			; 00000041H
  01e46	42		 DB	 66			; 00000042H
  01e47	6e		 DB	 110			; 0000006eH
  01e48	6e		 DB	 110			; 0000006eH
  01e49	6e		 DB	 110			; 0000006eH
  01e4a	43		 DB	 67			; 00000043H
  01e4b	44		 DB	 68			; 00000044H
  01e4c	45		 DB	 69			; 00000045H
  01e4d	46		 DB	 70			; 00000046H
  01e4e	47		 DB	 71			; 00000047H
  01e4f	48		 DB	 72			; 00000048H
  01e50	49		 DB	 73			; 00000049H
  01e51	4a		 DB	 74			; 0000004aH
  01e52	6e		 DB	 110			; 0000006eH
  01e53	4b		 DB	 75			; 0000004bH
  01e54	6e		 DB	 110			; 0000006eH
  01e55	4c		 DB	 76			; 0000004cH
  01e56	6e		 DB	 110			; 0000006eH
  01e57	6e		 DB	 110			; 0000006eH
  01e58	4d		 DB	 77			; 0000004dH
  01e59	4e		 DB	 78			; 0000004eH
  01e5a	6e		 DB	 110			; 0000006eH
  01e5b	4f		 DB	 79			; 0000004fH
  01e5c	50		 DB	 80			; 00000050H
  01e5d	51		 DB	 81			; 00000051H
  01e5e	52		 DB	 82			; 00000052H
  01e5f	53		 DB	 83			; 00000053H
  01e60	54		 DB	 84			; 00000054H
  01e61	55		 DB	 85			; 00000055H
  01e62	6e		 DB	 110			; 0000006eH
  01e63	56		 DB	 86			; 00000056H
  01e64	57		 DB	 87			; 00000057H
  01e65	58		 DB	 88			; 00000058H
  01e66	59		 DB	 89			; 00000059H
  01e67	5a		 DB	 90			; 0000005aH
  01e68	6e		 DB	 110			; 0000006eH
  01e69	6e		 DB	 110			; 0000006eH
  01e6a	6e		 DB	 110			; 0000006eH
  01e6b	6e		 DB	 110			; 0000006eH
  01e6c	5b		 DB	 91			; 0000005bH
  01e6d	5c		 DB	 92			; 0000005cH
  01e6e	5d		 DB	 93			; 0000005dH
  01e6f	6e		 DB	 110			; 0000006eH
  01e70	5e		 DB	 94			; 0000005eH
  01e71	6e		 DB	 110			; 0000006eH
  01e72	6e		 DB	 110			; 0000006eH
  01e73	6e		 DB	 110			; 0000006eH
  01e74	6e		 DB	 110			; 0000006eH
  01e75	6e		 DB	 110			; 0000006eH
  01e76	6e		 DB	 110			; 0000006eH
  01e77	5f		 DB	 95			; 0000005fH
  01e78	6e		 DB	 110			; 0000006eH
  01e79	6e		 DB	 110			; 0000006eH
  01e7a	6e		 DB	 110			; 0000006eH
  01e7b	6e		 DB	 110			; 0000006eH
  01e7c	6e		 DB	 110			; 0000006eH
  01e7d	60		 DB	 96			; 00000060H
  01e7e	61		 DB	 97			; 00000061H
  01e7f	6e		 DB	 110			; 0000006eH
  01e80	6e		 DB	 110			; 0000006eH
  01e81	62		 DB	 98			; 00000062H
  01e82	63		 DB	 99			; 00000063H
  01e83	64		 DB	 100			; 00000064H
  01e84	6e		 DB	 110			; 0000006eH
  01e85	65		 DB	 101			; 00000065H
  01e86	6e		 DB	 110			; 0000006eH
  01e87	66		 DB	 102			; 00000066H
  01e88	67		 DB	 103			; 00000067H
  01e89	68		 DB	 104			; 00000068H
  01e8a	6e		 DB	 110			; 0000006eH
  01e8b	69		 DB	 105			; 00000069H
  01e8c	6e		 DB	 110			; 0000006eH
  01e8d	6e		 DB	 110			; 0000006eH
  01e8e	6e		 DB	 110			; 0000006eH
  01e8f	6e		 DB	 110			; 0000006eH
  01e90	6e		 DB	 110			; 0000006eH
  01e91	6e		 DB	 110			; 0000006eH
  01e92	6a		 DB	 106			; 0000006aH
  01e93	6b		 DB	 107			; 0000006bH
  01e94	6c		 DB	 108			; 0000006cH
  01e95	6e		 DB	 110			; 0000006eH
  01e96	6e		 DB	 110			; 0000006eH
  01e97	6e		 DB	 110			; 0000006eH
  01e98	04		 DB	 4
  01e99	6e		 DB	 110			; 0000006eH
  01e9a	6d		 DB	 109			; 0000006dH
  01e9b	90		 npad	 1
$LN355@ProtocolCo:
  01e9c	00 00 00 00	 DD	 $LN129@ProtocolCo
  01ea0	00 00 00 00	 DD	 $LN130@ProtocolCo
  01ea4	00 00 00 00	 DD	 $LN131@ProtocolCo
  01ea8	00 00 00 00	 DD	 $LN67@ProtocolCo
  01eac	00 00 00 00	 DD	 $LN132@ProtocolCo
  01eb0	00 00 00 00	 DD	 $LN133@ProtocolCo
$LN356@ProtocolCo:
  01eb4	00 00 00 00	 DD	 $LN161@ProtocolCo
  01eb8	00 00 00 00	 DD	 $LN162@ProtocolCo
  01ebc	00 00 00 00	 DD	 $LN163@ProtocolCo
  01ec0	00 00 00 00	 DD	 $LN164@ProtocolCo
  01ec4	00 00 00 00	 DD	 $LN165@ProtocolCo
  01ec8	00 00 00 00	 DD	 $LN166@ProtocolCo
  01ecc	00 00 00 00	 DD	 $LN167@ProtocolCo
  01ed0	00 00 00 00	 DD	 $LN168@ProtocolCo
  01ed4	00 00 00 00	 DD	 $LN169@ProtocolCo
  01ed8	00 00 00 00	 DD	 $LN170@ProtocolCo
  01edc	00 00 00 00	 DD	 $LN171@ProtocolCo
  01ee0	00 00 00 00	 DD	 $LN172@ProtocolCo
  01ee4	00 00 00 00	 DD	 $LN173@ProtocolCo
  01ee8	00 00 00 00	 DD	 $LN174@ProtocolCo
  01eec	00 00 00 00	 DD	 $LN175@ProtocolCo
  01ef0	00 00 00 00	 DD	 $LN176@ProtocolCo
  01ef4	00 00 00 00	 DD	 $LN67@ProtocolCo
$LN342@ProtocolCo:
  01ef8	00		 DB	 0
  01ef9	01		 DB	 1
  01efa	02		 DB	 2
  01efb	03		 DB	 3
  01efc	04		 DB	 4
  01efd	05		 DB	 5
  01efe	06		 DB	 6
  01eff	07		 DB	 7
  01f00	08		 DB	 8
  01f01	09		 DB	 9
  01f02	10		 DB	 16			; 00000010H
  01f03	10		 DB	 16			; 00000010H
  01f04	10		 DB	 16			; 00000010H
  01f05	10		 DB	 16			; 00000010H
  01f06	10		 DB	 16			; 00000010H
  01f07	10		 DB	 16			; 00000010H
  01f08	0a		 DB	 10			; 0000000aH
  01f09	10		 DB	 16			; 00000010H
  01f0a	0b		 DB	 11			; 0000000bH
  01f0b	10		 DB	 16			; 00000010H
  01f0c	10		 DB	 16			; 00000010H
  01f0d	10		 DB	 16			; 00000010H
  01f0e	10		 DB	 16			; 00000010H
  01f0f	10		 DB	 16			; 00000010H
  01f10	10		 DB	 16			; 00000010H
  01f11	10		 DB	 16			; 00000010H
  01f12	10		 DB	 16			; 00000010H
  01f13	0c		 DB	 12			; 0000000cH
  01f14	0d		 DB	 13			; 0000000dH
  01f15	0e		 DB	 14			; 0000000eH
  01f16	10		 DB	 16			; 00000010H
  01f17	0f		 DB	 15			; 0000000fH
$LN357@ProtocolCo:
  01f18	00 00 00 00	 DD	 $LN194@ProtocolCo
  01f1c	00 00 00 00	 DD	 $LN195@ProtocolCo
  01f20	00 00 00 00	 DD	 $LN196@ProtocolCo
  01f24	00 00 00 00	 DD	 $LN197@ProtocolCo
  01f28	00 00 00 00	 DD	 $LN198@ProtocolCo
  01f2c	00 00 00 00	 DD	 $LN199@ProtocolCo
  01f30	00 00 00 00	 DD	 $LN200@ProtocolCo
  01f34	00 00 00 00	 DD	 $LN201@ProtocolCo
$LN343@ProtocolCo:
  01f38	00		 DB	 0
  01f39	07		 DB	 7
  01f3a	01		 DB	 1
  01f3b	07		 DB	 7
  01f3c	07		 DB	 7
  01f3d	02		 DB	 2
  01f3e	07		 DB	 7
  01f3f	07		 DB	 7
  01f40	07		 DB	 7
  01f41	07		 DB	 7
  01f42	07		 DB	 7
  01f43	07		 DB	 7
  01f44	07		 DB	 7
  01f45	07		 DB	 7
  01f46	03		 DB	 3
  01f47	07		 DB	 7
  01f48	07		 DB	 7
  01f49	07		 DB	 7
  01f4a	07		 DB	 7
  01f4b	07		 DB	 7
  01f4c	07		 DB	 7
  01f4d	07		 DB	 7
  01f4e	07		 DB	 7
  01f4f	04		 DB	 4
  01f50	07		 DB	 7
  01f51	07		 DB	 7
  01f52	07		 DB	 7
  01f53	07		 DB	 7
  01f54	07		 DB	 7
  01f55	07		 DB	 7
  01f56	07		 DB	 7
  01f57	07		 DB	 7
  01f58	05		 DB	 5
  01f59	07		 DB	 7
  01f5a	07		 DB	 7
  01f5b	07		 DB	 7
  01f5c	07		 DB	 7
  01f5d	07		 DB	 7
  01f5e	07		 DB	 7
  01f5f	07		 DB	 7
  01f60	07		 DB	 7
  01f61	07		 DB	 7
  01f62	07		 DB	 7
  01f63	07		 DB	 7
  01f64	07		 DB	 7
  01f65	07		 DB	 7
  01f66	07		 DB	 7
  01f67	07		 DB	 7
  01f68	07		 DB	 7
  01f69	07		 DB	 7
  01f6a	07		 DB	 7
  01f6b	07		 DB	 7
  01f6c	07		 DB	 7
  01f6d	07		 DB	 7
  01f6e	07		 DB	 7
  01f6f	07		 DB	 7
  01f70	07		 DB	 7
  01f71	07		 DB	 7
  01f72	07		 DB	 7
  01f73	07		 DB	 7
  01f74	07		 DB	 7
  01f75	07		 DB	 7
  01f76	07		 DB	 7
  01f77	07		 DB	 7
  01f78	07		 DB	 7
  01f79	07		 DB	 7
  01f7a	07		 DB	 7
  01f7b	07		 DB	 7
  01f7c	07		 DB	 7
  01f7d	07		 DB	 7
  01f7e	07		 DB	 7
  01f7f	07		 DB	 7
  01f80	07		 DB	 7
  01f81	07		 DB	 7
  01f82	07		 DB	 7
  01f83	07		 DB	 7
  01f84	07		 DB	 7
  01f85	07		 DB	 7
  01f86	07		 DB	 7
  01f87	07		 DB	 7
  01f88	07		 DB	 7
  01f89	06		 DB	 6
  01f8a	66 90		 npad	 2
$LN358@ProtocolCo:
  01f8c	00 00 00 00	 DD	 $LN212@ProtocolCo
  01f90	00 00 00 00	 DD	 $LN213@ProtocolCo
  01f94	00 00 00 00	 DD	 $LN214@ProtocolCo
  01f98	00 00 00 00	 DD	 $LN215@ProtocolCo
  01f9c	00 00 00 00	 DD	 $LN216@ProtocolCo
  01fa0	00 00 00 00	 DD	 $LN67@ProtocolCo
$LN344@ProtocolCo:
  01fa4	00		 DB	 0
  01fa5	01		 DB	 1
  01fa6	02		 DB	 2
  01fa7	03		 DB	 3
  01fa8	05		 DB	 5
  01fa9	05		 DB	 5
  01faa	05		 DB	 5
  01fab	05		 DB	 5
  01fac	05		 DB	 5
  01fad	05		 DB	 5
  01fae	05		 DB	 5
  01faf	05		 DB	 5
  01fb0	05		 DB	 5
  01fb1	05		 DB	 5
  01fb2	05		 DB	 5
  01fb3	05		 DB	 5
  01fb4	05		 DB	 5
  01fb5	05		 DB	 5
  01fb6	05		 DB	 5
  01fb7	05		 DB	 5
  01fb8	05		 DB	 5
  01fb9	05		 DB	 5
  01fba	05		 DB	 5
  01fbb	05		 DB	 5
  01fbc	05		 DB	 5
  01fbd	05		 DB	 5
  01fbe	05		 DB	 5
  01fbf	05		 DB	 5
  01fc0	05		 DB	 5
  01fc1	05		 DB	 5
  01fc2	05		 DB	 5
  01fc3	05		 DB	 5
  01fc4	05		 DB	 5
  01fc5	05		 DB	 5
  01fc6	05		 DB	 5
  01fc7	05		 DB	 5
  01fc8	05		 DB	 5
  01fc9	05		 DB	 5
  01fca	05		 DB	 5
  01fcb	05		 DB	 5
  01fcc	05		 DB	 5
  01fcd	05		 DB	 5
  01fce	05		 DB	 5
  01fcf	05		 DB	 5
  01fd0	05		 DB	 5
  01fd1	05		 DB	 5
  01fd2	05		 DB	 5
  01fd3	05		 DB	 5
  01fd4	05		 DB	 5
  01fd5	04		 DB	 4
  01fd6	66 90		 npad	 2
$LN359@ProtocolCo:
  01fd8	00 00 00 00	 DD	 $LN218@ProtocolCo
  01fdc	00 00 00 00	 DD	 $LN219@ProtocolCo
  01fe0	00 00 00 00	 DD	 $LN220@ProtocolCo
  01fe4	00 00 00 00	 DD	 $LN221@ProtocolCo
  01fe8	00 00 00 00	 DD	 $LN222@ProtocolCo
  01fec	00 00 00 00	 DD	 $LN223@ProtocolCo
  01ff0	00 00 00 00	 DD	 $LN224@ProtocolCo
  01ff4	00 00 00 00	 DD	 $LN225@ProtocolCo
  01ff8	00 00 00 00	 DD	 $LN226@ProtocolCo
$LN360@ProtocolCo:
  01ffc	00 00 00 00	 DD	 $LN232@ProtocolCo
  02000	00 00 00 00	 DD	 $LN233@ProtocolCo
  02004	00 00 00 00	 DD	 $LN234@ProtocolCo
  02008	00 00 00 00	 DD	 $LN235@ProtocolCo
  0200c	00 00 00 00	 DD	 $LN236@ProtocolCo
  02010	00 00 00 00	 DD	 $LN237@ProtocolCo
  02014	00 00 00 00	 DD	 $LN238@ProtocolCo
  02018	00 00 00 00	 DD	 $LN239@ProtocolCo
$LN361@ProtocolCo:
  0201c	00 00 00 00	 DD	 $LN265@ProtocolCo
  02020	00 00 00 00	 DD	 $LN267@ProtocolCo
  02024	00 00 00 00	 DD	 $LN268@ProtocolCo
  02028	00 00 00 00	 DD	 $LN67@ProtocolCo
  0202c	00 00 00 00	 DD	 $LN67@ProtocolCo
  02030	00 00 00 00	 DD	 $LN67@ProtocolCo
  02034	00 00 00 00	 DD	 $LN270@ProtocolCo
  02038	00 00 00 00	 DD	 $LN67@ProtocolCo
  0203c	00 00 00 00	 DD	 $LN272@ProtocolCo
$LN362@ProtocolCo:
  02040	00 00 00 00	 DD	 $LN300@ProtocolCo
  02044	00 00 00 00	 DD	 $LN301@ProtocolCo
  02048	00 00 00 00	 DD	 $LN302@ProtocolCo
  0204c	00 00 00 00	 DD	 $LN303@ProtocolCo
  02050	00 00 00 00	 DD	 $LN304@ProtocolCo
  02054	00 00 00 00	 DD	 $LN67@ProtocolCo
  02058	00 00 00 00	 DD	 $LN67@ProtocolCo
  0205c	00 00 00 00	 DD	 $LN67@ProtocolCo
  02060	00 00 00 00	 DD	 $LN67@ProtocolCo
  02064	00 00 00 00	 DD	 $LN67@ProtocolCo
  02068	00 00 00 00	 DD	 $LN305@ProtocolCo
$LN363@ProtocolCo:
  0206c	00 00 00 00	 DD	 $LN307@ProtocolCo
  02070	00 00 00 00	 DD	 $LN308@ProtocolCo
  02074	00 00 00 00	 DD	 $LN309@ProtocolCo
  02078	00 00 00 00	 DD	 $LN310@ProtocolCo
  0207c	00 00 00 00	 DD	 $LN311@ProtocolCo
  02080	00 00 00 00	 DD	 $LN312@ProtocolCo
  02084	00 00 00 00	 DD	 $LN313@ProtocolCo
  02088	00 00 00 00	 DD	 $LN315@ProtocolCo
  0208c	00 00 00 00	 DD	 $LN316@ProtocolCo
  02090	00 00 00 00	 DD	 $LN67@ProtocolCo
$LN345@ProtocolCo:
  02094	00		 DB	 0
  02095	01		 DB	 1
  02096	09		 DB	 9
  02097	02		 DB	 2
  02098	09		 DB	 9
  02099	03		 DB	 3
  0209a	04		 DB	 4
  0209b	09		 DB	 9
  0209c	09		 DB	 9
  0209d	09		 DB	 9
  0209e	09		 DB	 9
  0209f	09		 DB	 9
  020a0	09		 DB	 9
  020a1	09		 DB	 9
  020a2	09		 DB	 9
  020a3	09		 DB	 9
  020a4	05		 DB	 5
  020a5	06		 DB	 6
  020a6	09		 DB	 9
  020a7	09		 DB	 9
  020a8	09		 DB	 9
  020a9	09		 DB	 9
  020aa	09		 DB	 9
  020ab	09		 DB	 9
  020ac	09		 DB	 9
  020ad	09		 DB	 9
  020ae	09		 DB	 9
  020af	09		 DB	 9
  020b0	09		 DB	 9
  020b1	09		 DB	 9
  020b2	09		 DB	 9
  020b3	09		 DB	 9
  020b4	09		 DB	 9
  020b5	09		 DB	 9
  020b6	09		 DB	 9
  020b7	09		 DB	 9
  020b8	09		 DB	 9
  020b9	09		 DB	 9
  020ba	07		 DB	 7
  020bb	08		 DB	 8
$LN364@ProtocolCo:
  020bc	00 00 00 00	 DD	 $LN320@ProtocolCo
  020c0	00 00 00 00	 DD	 $LN321@ProtocolCo
  020c4	00 00 00 00	 DD	 $LN322@ProtocolCo
  020c8	00 00 00 00	 DD	 $LN323@ProtocolCo
  020cc	00 00 00 00	 DD	 $LN324@ProtocolCo
  020d0	00 00 00 00	 DD	 $LN67@ProtocolCo
$LN346@ProtocolCo:
  020d4	00		 DB	 0
  020d5	05		 DB	 5
  020d6	01		 DB	 1
  020d7	05		 DB	 5
  020d8	05		 DB	 5
  020d9	05		 DB	 5
  020da	05		 DB	 5
  020db	05		 DB	 5
  020dc	02		 DB	 2
  020dd	05		 DB	 5
  020de	03		 DB	 3
  020df	05		 DB	 5
  020e0	05		 DB	 5
  020e1	05		 DB	 5
  020e2	05		 DB	 5
  020e3	05		 DB	 5
  020e4	05		 DB	 5
  020e5	05		 DB	 5
  020e6	05		 DB	 5
  020e7	05		 DB	 5
  020e8	05		 DB	 5
  020e9	05		 DB	 5
  020ea	05		 DB	 5
  020eb	05		 DB	 5
  020ec	05		 DB	 5
  020ed	05		 DB	 5
  020ee	05		 DB	 5
  020ef	05		 DB	 5
  020f0	05		 DB	 5
  020f1	05		 DB	 5
  020f2	05		 DB	 5
  020f3	04		 DB	 4
$LN365@ProtocolCo:
  020f4	00 00 00 00	 DD	 $LN76@ProtocolCo
  020f8	00 00 00 00	 DD	 $LN77@ProtocolCo
  020fc	00 00 00 00	 DD	 $LN78@ProtocolCo
  02100	00 00 00 00	 DD	 $LN79@ProtocolCo
  02104	00 00 00 00	 DD	 $LN80@ProtocolCo
  02108	00 00 00 00	 DD	 $LN81@ProtocolCo
  0210c	00 00 00 00	 DD	 $LN82@ProtocolCo
  02110	00 00 00 00	 DD	 $LN83@ProtocolCo
  02114	00 00 00 00	 DD	 $LN84@ProtocolCo
  02118	00 00 00 00	 DD	 $LN86@ProtocolCo
  0211c	00 00 00 00	 DD	 $LN67@ProtocolCo
$LN347@ProtocolCo:
  02120	00		 DB	 0
  02121	01		 DB	 1
  02122	02		 DB	 2
  02123	03		 DB	 3
  02124	0a		 DB	 10			; 0000000aH
  02125	0a		 DB	 10			; 0000000aH
  02126	04		 DB	 4
  02127	0a		 DB	 10			; 0000000aH
  02128	0a		 DB	 10			; 0000000aH
  02129	0a		 DB	 10			; 0000000aH
  0212a	0a		 DB	 10			; 0000000aH
  0212b	0a		 DB	 10			; 0000000aH
  0212c	0a		 DB	 10			; 0000000aH
  0212d	0a		 DB	 10			; 0000000aH
  0212e	0a		 DB	 10			; 0000000aH
  0212f	0a		 DB	 10			; 0000000aH
  02130	0a		 DB	 10			; 0000000aH
  02131	0a		 DB	 10			; 0000000aH
  02132	05		 DB	 5
  02133	0a		 DB	 10			; 0000000aH
  02134	0a		 DB	 10			; 0000000aH
  02135	06		 DB	 6
  02136	0a		 DB	 10			; 0000000aH
  02137	0a		 DB	 10			; 0000000aH
  02138	0a		 DB	 10			; 0000000aH
  02139	0a		 DB	 10			; 0000000aH
  0213a	0a		 DB	 10			; 0000000aH
  0213b	0a		 DB	 10			; 0000000aH
  0213c	0a		 DB	 10			; 0000000aH
  0213d	0a		 DB	 10			; 0000000aH
  0213e	0a		 DB	 10			; 0000000aH
  0213f	0a		 DB	 10			; 0000000aH
  02140	0a		 DB	 10			; 0000000aH
  02141	07		 DB	 7
  02142	0a		 DB	 10			; 0000000aH
  02143	0a		 DB	 10			; 0000000aH
  02144	0a		 DB	 10			; 0000000aH
  02145	0a		 DB	 10			; 0000000aH
  02146	0a		 DB	 10			; 0000000aH
  02147	0a		 DB	 10			; 0000000aH
  02148	0a		 DB	 10			; 0000000aH
  02149	0a		 DB	 10			; 0000000aH
  0214a	0a		 DB	 10			; 0000000aH
  0214b	0a		 DB	 10			; 0000000aH
  0214c	0a		 DB	 10			; 0000000aH
  0214d	0a		 DB	 10			; 0000000aH
  0214e	0a		 DB	 10			; 0000000aH
  0214f	0a		 DB	 10			; 0000000aH
  02150	08		 DB	 8
  02151	0a		 DB	 10			; 0000000aH
  02152	0a		 DB	 10			; 0000000aH
  02153	0a		 DB	 10			; 0000000aH
  02154	0a		 DB	 10			; 0000000aH
  02155	0a		 DB	 10			; 0000000aH
  02156	0a		 DB	 10			; 0000000aH
  02157	0a		 DB	 10			; 0000000aH
  02158	0a		 DB	 10			; 0000000aH
  02159	0a		 DB	 10			; 0000000aH
  0215a	0a		 DB	 10			; 0000000aH
  0215b	0a		 DB	 10			; 0000000aH
  0215c	0a		 DB	 10			; 0000000aH
  0215d	0a		 DB	 10			; 0000000aH
  0215e	0a		 DB	 10			; 0000000aH
  0215f	0a		 DB	 10			; 0000000aH
  02160	0a		 DB	 10			; 0000000aH
  02161	0a		 DB	 10			; 0000000aH
  02162	0a		 DB	 10			; 0000000aH
  02163	0a		 DB	 10			; 0000000aH
  02164	0a		 DB	 10			; 0000000aH
  02165	0a		 DB	 10			; 0000000aH
  02166	0a		 DB	 10			; 0000000aH
  02167	0a		 DB	 10			; 0000000aH
  02168	0a		 DB	 10			; 0000000aH
  02169	0a		 DB	 10			; 0000000aH
  0216a	0a		 DB	 10			; 0000000aH
  0216b	0a		 DB	 10			; 0000000aH
  0216c	0a		 DB	 10			; 0000000aH
  0216d	0a		 DB	 10			; 0000000aH
  0216e	0a		 DB	 10			; 0000000aH
  0216f	0a		 DB	 10			; 0000000aH
  02170	0a		 DB	 10			; 0000000aH
  02171	0a		 DB	 10			; 0000000aH
  02172	09		 DB	 9
?ProtocolCore@@YAXEPAEHHHH@Z ENDP			; ProtocolCore
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	8b 5d 08	 mov	 ebx, DWORD PTR ___flags$[ebp]
  0002a	f6 c3 02	 test	 bl, 2
  0002d	74 44		 je	 SHORT $LN2@vector
  0002f	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00034	ff 76 fc	 push	 DWORD PTR [esi-4]
  00037	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003a	68 40 27 00 00	 push	 10048			; 00002740H
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00045	f6 c3 01	 test	 bl, 1
  00048	74 13		 je	 SHORT $LN3@vector
  0004a	69 0f 40 27 00
	00		 imul	 ecx, DWORD PTR [edi], 10048
  00050	83 c1 04	 add	 ecx, 4
  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0005a	83 c4 08	 add	 esp, 8
$LN3@vector:
  0005d	8b c7		 mov	 eax, edi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN2@vector:
  00073	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00079	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0007e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00084	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00089	f6 c3 01	 test	 bl, 1
  0008c	74 0e		 je	 SHORT $LN4@vector
  0008e	68 40 27 00 00	 push	 10048			; 00002740H
  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00099	83 c4 08	 add	 esp, 8
$LN4@vector:
  0009c	8b c6		 mov	 eax, esi
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00009	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0000e	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00014	5e		 pop	 esi
  00015	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PAD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tdurmagickeychecker.h
;	COMDAT ?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::GetValidCount, COMDAT
; _this$ = ecx

; 67   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	8a 55 08	 mov	 dl, BYTE PTR _btMagicKey$[ebp]
  00006	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00009	3c 3b		 cmp	 al, 59			; 0000003bH
  0000b	77 0f		 ja	 SHORT $LN2@GetValidCo

; 69   : 		{		
; 70   : 			return this->m_btValidCount[btMagicKey];

  0000d	0f b6 c2	 movzx	 eax, dl
  00010	0f b6 84 08 f0
	00 00 00	 movzx	 eax, BYTE PTR [eax+ecx+240]

; 74   : 	};	// line : 80

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@GetValidCo:

; 71   : 		}
; 72   : 
; 73   : 		return -77;

  0001c	b8 b3 ff ff ff	 mov	 eax, -77		; ffffffb3H

; 74   : 	};	// line : 80

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?GetValidCount@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::GetValidCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tdurmagickeychecker.h
;	COMDAT ?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::GetValidDurationTime, COMDAT
; _this$ = ecx

; 57   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	8a 55 08	 mov	 dl, BYTE PTR _btMagicKey$[ebp]
  00006	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00009	3c 3b		 cmp	 al, 59			; 0000003bH
  0000b	77 0a		 ja	 SHORT $LN2@GetValidDu

; 59   : 		{
; 60   : 			return this->m_dwDurationTime[btMagicKey];

  0000d	0f b6 c2	 movzx	 eax, dl
  00010	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 64   : 	};	// line : 70

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
$LN2@GetValidDu:

; 61   : 		}
; 62   : 
; 63   : 		return -77;

  00017	b8 b3 ff ff ff	 mov	 eax, -77		; ffffffb3H

; 64   : 	};	// line : 70

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?GetValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::GetValidDurationTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tdurmagickeychecker.h
;	COMDAT ?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
_dwCurrentTickCount$ = 12				; size = 4
?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z PROC	; TDurMagicKeyChecker::SetDurationTime, COMDAT
; _this$ = ecx

; 46   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	8a 55 08	 mov	 dl, BYTE PTR _btMagicKey$[ebp]
  00006	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00009	3c 3b		 cmp	 al, 59			; 0000003bH
  0000b	77 11		 ja	 SHORT $LN2@SetDuratio

; 48   : 		{
; 49   : 			this->m_dwDurationTime[btMagicKey] = dwCurrentTickCount;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _dwCurrentTickCount$[ebp]
  00010	0f b6 d2	 movzx	 edx, dl
  00013	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 50   : 			this->m_btValidCount[btMagicKey] = 7;

  00016	c6 84 0a f0 00
	00 00 07	 mov	 BYTE PTR [edx+ecx+240], 7
$LN2@SetDuratio:

; 51   : 		}
; 52   : 	};	// line : 47

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?SetDurationTime@TDurMagicKeyChecker@@QAEXEK@Z ENDP	; TDurMagicKeyChecker::SetDurationTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tdurmagickeychecker.h
;	COMDAT ?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z PROC		; TDurMagicKeyChecker::IsValidCount, COMDAT
; _this$ = ecx

; 34   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00003	8a 45 08	 mov	 al, BYTE PTR _btMagicKey$[ebp]
  00006	b1 3b		 mov	 cl, 59			; 0000003bH
  00008	fe c8		 dec	 al
  0000a	3a c8		 cmp	 cl, al
  0000c	1b c0		 sbb	 eax, eax
  0000e	40		 inc	 eax

; 36   : 		{
; 37   : 			if ( this->m_btValidCount[btMagicKey] >= 0 )
; 38   : 			{
; 39   : 				return TRUE;
; 40   : 			}
; 41   : 		}
; 42   : 		return FALSE;
; 43   : 	};	// line : 38

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?IsValidCount@TDurMagicKeyChecker@@QAEHE@Z ENDP		; TDurMagicKeyChecker::IsValidCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\tdurmagickeychecker.h
;	COMDAT ?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z
_TEXT	SEGMENT
_btMagicKey$ = 8					; size = 1
?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z PROC	; TDurMagicKeyChecker::IsValidDurationTime, COMDAT
; _this$ = ecx

; 19   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 20   : 		if ( btMagicKey <= MAX_DUR_MAGIC_KEY && btMagicKey > 0)

  00004	8a 5d 08	 mov	 bl, BYTE PTR _btMagicKey$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  0000d	3c 3b		 cmp	 al, 59			; 0000003bH
  0000f	77 1e		 ja	 SHORT $LN3@IsValidDur

; 21   : 		{
; 22   : 			if ( (GetTickCount() - this->m_dwDurationTime[btMagicKey]) < 15000 )

  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00017	0f b6 cb	 movzx	 ecx, bl
  0001a	2b 04 8e	 sub	 eax, DWORD PTR [esi+ecx*4]
  0001d	3d 98 3a 00 00	 cmp	 eax, 15000		; 00003a98H
  00022	73 0b		 jae	 SHORT $LN3@IsValidDur

; 23   : 			{
; 24   : 				return TRUE;

  00024	5e		 pop	 esi
  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	5b		 pop	 ebx

; 29   : 
; 30   : 	};	// line : 25

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN3@IsValidDur:
  0002f	5e		 pop	 esi

; 25   : 			}
; 26   : 		}
; 27   : 
; 28   : 		return FALSE;

  00030	33 c0		 xor	 eax, eax
  00032	5b		 pop	 ebx

; 29   : 
; 30   : 	};	// line : 25

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?IsValidDurationTime@TDurMagicKeyChecker@@QAEHE@Z ENDP	; TDurMagicKeyChecker::IsValidDurationTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\guildclass.h
;	COMDAT ?GetChatPrice@CGensSystem@@QAEHXZ
_TEXT	SEGMENT
?GetChatPrice@CGensSystem@@QAEHXZ PROC			; CGensSystem::GetChatPrice, COMDAT
; _this$ = ecx

; 275  : 	int GetChatPrice(){ return this->m_ChatPrice; };

  00000	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00003	c3		 ret	 0
?GetChatPrice@CGensSystem@@QAEHXZ ENDP			; CGensSystem::GetChatPrice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD2@@QAEXPAEEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_sub$ = 16						; size = 1
_size$ = 20						; size = 1
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z PROC			; PBMSG_HEAD2::set, COMDAT
; _this$ = ecx

; 139  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 140  : 		lpBuf[0] = 0xC1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]

; 141  : 		lpBuf[1] = size;

  00006	8a 45 14	 mov	 al, BYTE PTR _size$[ebp]
  00009	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 142  : 		lpBuf[2] = head;

  0000c	8a 45 0c	 mov	 al, BYTE PTR _head$[ebp]
  0000f	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 143  : 		lpBuf[3] = sub;

  00012	8a 45 10	 mov	 al, BYTE PTR _sub$[ebp]
  00015	c6 01 c1	 mov	 BYTE PTR [ecx], 193	; 000000c1H
  00018	88 41 03	 mov	 BYTE PTR [ecx+3], al

; 144  : 	};

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?set@PBMSG_HEAD2@@QAEXPAEEEE@Z ENDP			; PBMSG_HEAD2::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
;	COMDAT ?set@PWMSG_HEAD@@QAEXPAEEH@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 4
?set@PWMSG_HEAD@@QAEXPAEEH@Z PROC			; PWMSG_HEAD::set, COMDAT
; _this$ = ecx

; 110  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 		lpBuf[0] = 0xC2;

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpBuf$[ebp]

; 112  : 		lpBuf[1] = SET_NUMBERH(size);

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 08	 shr	 eax, 8
  0000e	88 42 01	 mov	 BYTE PTR [edx+1], al

; 113  : 		lpBuf[2] = SET_NUMBERL(size);
; 114  : 		lpBuf[3] = head;

  00011	8a 45 0c	 mov	 al, BYTE PTR _head$[ebp]
  00014	c6 02 c2	 mov	 BYTE PTR [edx], 194	; 000000c2H
  00017	88 4a 02	 mov	 BYTE PTR [edx+2], cl
  0001a	88 42 03	 mov	 BYTE PTR [edx+3], al

; 115  : 	};

  0001d	5d		 pop	 ebp
  0001e	c2 0c 00	 ret	 12			; 0000000cH
?set@PWMSG_HEAD@@QAEXPAEEH@Z ENDP			; PWMSG_HEAD::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\include\prodef.h
;	COMDAT ?set@PBMSG_HEAD@@QAEXPAEEE@Z
_TEXT	SEGMENT
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 1
?set@PBMSG_HEAD@@QAEXPAEEE@Z PROC			; PBMSG_HEAD::set, COMDAT
; _this$ = ecx

; 85   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 		lpBuf[0] = 0xC1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]

; 87   : 		lpBuf[1] = size;

  00006	8a 45 10	 mov	 al, BYTE PTR _size$[ebp]
  00009	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 88   : 		lpBuf[2] = head;

  0000c	8a 45 0c	 mov	 al, BYTE PTR _head$[ebp]
  0000f	c6 01 c1	 mov	 BYTE PTR [ecx], 193	; 000000c1H
  00012	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 89   : 	};	// line : 22

  00015	5d		 pop	 ebp
  00016	c2 0c 00	 ret	 12			; 0000000cH
?set@PBMSG_HEAD@@QAEXPAEEE@Z ENDP			; PBMSG_HEAD::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 654  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@construct:

; 656  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 662  : 		_Ptr->~_Uty();
; 663  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 772  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN8@construct
  0000a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN8@construct:

; 773  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 774  : 		}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<char>, COMDAT

; 688  : 	{	// return address of object _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 689  : 	return (reinterpret_cast<_Ty *>(

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 690  : 		&const_cast<char&>(
; 691  : 		reinterpret_cast<const volatile char&>(_Val))));
; 692  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Addressof@D@std@@YAPADAADU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 780  : 		_Al.destroy(_Ptr);
; 781  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1233 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1234 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1235 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 916  : 		{	// construct _Ty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 07		 je	 SHORT $LN13@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@construct:

; 917  : 		_Mytraits::construct(*this, _Ptr,
; 918  : 			_STD forward<_Types>(_Args)...);
; 919  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 696  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 698  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 925  : 		_Mytraits::destroy(*this, _Ptr);
; 926  : 		}

  00000	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 488  : 		_Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00007	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 489  : 		_Myres = 0;

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 289  : 		}

  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\zthelper.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\michel\desktop\source\gameserver\source\zthelper.hpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\users\michel\desktop\source\gameserver\source\zthelper.hpp
;	COMDAT ?isValidChatSyntax@ZTHelper@@SA_NPBD@Z
_TEXT	SEGMENT
_strText$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_Text$ = 8						; size = 4
?isValidChatSyntax@ZTHelper@@SA_NPBD@Z PROC		; ZTHelper::isValidChatSyntax, COMDAT

; 10   : 	static bool isValidChatSyntax(const char* Text) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 08	 mov	 edx, DWORD PTR _Text$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00013	c7 45 f8 0f 00
	00 00		 mov	 DWORD PTR _strText$[ebp+20], 15 ; 0000000fH

; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0001a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _strText$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00021	c6 45 e4 00	 mov	 BYTE PTR _strText$[ebp], 0

; 523  : 		return (*_First == 0 ? 0

  00025	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00028	75 04		 jne	 SHORT $LN138@isValidCha
  0002a	33 c9		 xor	 ecx, ecx
  0002c	eb 10		 jmp	 SHORT $LN139@isValidCha
$LN138@isValidCha:
  0002e	8b ca		 mov	 ecx, edx
  00030	56		 push	 esi
  00031	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL263@isValidCha:
  00034	8a 01		 mov	 al, BYTE PTR [ecx]
  00036	41		 inc	 ecx
  00037	84 c0		 test	 al, al
  00039	75 f9		 jne	 SHORT $LL263@isValidCha
  0003b	2b ce		 sub	 ecx, esi
  0003d	5e		 pop	 esi
$LN139@isValidCha:
  0003e	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0003f	51		 push	 ecx
  00040	52		 push	 edx
  00041	8d 4d e4	 lea	 ecx, DWORD PTR _strText$[ebp]
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

  00049	6a 01		 push	 1
  0004b	6a 00		 push	 0
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_01MNNFJEPP@?$DM?$AA@
  00052	8d 4d e4	 lea	 ecx, DWORD PTR _strText$[ebp]
  00055	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _strText$[ebp+20]
; File c:\users\michel\desktop\source\gameserver\source\zthelper.hpp

; 12   : 		if (strText.find("<") != std::string::npos) {

  0005d	83 f8 ff	 cmp	 eax, -1
  00060	0f 94 c3	 sete	 bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00063	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00066	72 0d		 jb	 SHORT $LN264@isValidCha

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00068	41		 inc	 ecx
  00069	51		 push	 ecx
  0006a	ff 75 e4	 push	 DWORD PTR _strText$[ebp]
  0006d	8d 4d e4	 lea	 ecx, DWORD PTR _strText$[ebp]
  00070	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN264@isValidCha:
; File c:\users\michel\desktop\source\gameserver\source\zthelper.hpp

; 16   : 	}

  00075	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00078	8a c3		 mov	 al, bl
  0007a	33 cd		 xor	 ecx, ebp
  0007c	5b		 pop	 ebx
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?isValidChatSyntax@ZTHelper@@SA_NPBD@Z ENDP		; ZTHelper::isValidChatSyntax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2252 : 		_Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2247 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2229 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2230 : 		if (!_Built)

  00003	80 7d 08 00	 cmp	 BYTE PTR __Built$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	74 26		 je	 SHORT $LN4@Tidy

; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00010	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00014	72 20		 jb	 SHORT $LN4@Tidy

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;

  00016	53		 push	 ebx
  00017	8b 1e		 mov	 ebx, DWORD PTR [esi]

; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)

  00019	85 ff		 test	 edi, edi
  0001b	74 0b		 je	 SHORT $LN58@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  0001d	57		 push	 edi
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN58@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00028	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002b	8b ce		 mov	 ecx, esi
  0002d	40		 inc	 eax
  0002e	50		 push	 eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
  00035	5b		 pop	 ebx
$LN4@Tidy:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00036	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres
; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}
; 516  : 
; 517  : 	union _Bxty
; 518  : 		{	// storage for small buffer or pointer to larger one
; 519  : 		value_type _Buf[_BUF_SIZE];
; 520  : 		pointer _Ptr;
; 521  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 522  : 		} _Bx;
; 523  : 
; 524  : 	size_type _Mysize;	// current length of string
; 525  : 	size_type _Myres;	// current storage reserved for string
; 526  : 	};
; 527  : 
; 528  : 		// TEMPLATE CLASS _String_alloc
; 529  : template<class _Alloc_types>
; 530  : 	class _String_alloc
; 531  : 	{	// base class for basic_string to hold allocator
; 532  : public:
; 533  : 	typedef _String_alloc<_Alloc_types> _Myt;
; 534  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 535  : 	typedef typename _Alloc_types::_Alty _Alty;
; 536  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 537  : 
; 538  : 	typedef typename _Val_types::value_type value_type;
; 539  : 	typedef typename _Val_types::size_type size_type;
; 540  : 	typedef typename _Val_types::difference_type difference_type;
; 541  : 	typedef typename _Val_types::pointer pointer;
; 542  : 	typedef typename _Val_types::const_pointer const_pointer;
; 543  : 	typedef typename _Val_types::reference reference;
; 544  : 	typedef typename _Val_types::const_reference const_reference;
; 545  : 
; 546  : 	typedef _String_iterator<_String_val<_Val_types> > iterator;
; 547  : 	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;
; 548  : 
; 549  : 	enum
; 550  : 		{	// length of internal buffer, [1, 16]
; 551  : 		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
; 552  : 		};
; 553  : 
; 554  : 	enum
; 555  : 		{	// roundup mask for allocated buffers, [0, 15]
; 556  : 		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
; 557  : 		};
; 558  : 
; 559  : 	value_type *_Myptr()
; 560  : 		{	// determine current pointer to buffer for mutable string
; 561  : 		return (_Get_data()._Myptr());
; 562  : 		}
; 563  : 
; 564  : 	const value_type *_Myptr() const
; 565  : 		{	// determine current pointer to buffer for nonmutable string
; 566  : 		return (_Get_data()._Myptr());
; 567  : 		}
; 568  : 
; 569  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 570  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 571  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 572  : 		{	// construct allocator from _Al
; 573  : 		}
; 574  : 
; 575  : 	_String_alloc(_Alloc&& _Al)
; 576  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 577  : 		{	// construct allocator from _Al
; 578  : 		}
; 579  : 
; 580  : 	void _Copy_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Pocca(_Getal(), _Al);
; 583  : 		}
; 584  : 
; 585  : 	void _Move_alloc(_Alty& _Al)
; 586  : 		{	// replace old allocator
; 587  : 		_Pocma(_Getal(), _Al);
; 588  : 		}
; 589  : 
; 590  : 	void _Swap_alloc(_Myt& _Right)
; 591  : 		{	// swap allocators
; 592  : 		_Pocs(_Getal(), _Right._Getal());
; 593  : 		}
; 594  : 
; 595  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 596  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 597  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 598  : 		{	// construct allocator from _Al
; 599  : 		_Alloc_proxy();
; 600  : 		}
; 601  : 
; 602  : 	_String_alloc(_Alloc&& _Al)
; 603  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 604  : 		{	// construct allocator from _Al
; 605  : 		_Alloc_proxy();
; 606  : 		}
; 607  : 
; 608  : 	~_String_alloc() _NOEXCEPT
; 609  : 		{	// destroy the object
; 610  : 		_Free_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Copy_alloc(const _Alty& _Al)
; 614  : 		{	// replace old allocator
; 615  : 		_Free_proxy();
; 616  : 		_Pocca(_Getal(), _Al);
; 617  : 		_Alloc_proxy();
; 618  : 		}
; 619  : 
; 620  : 	void _Move_alloc(_Alty& _Al)
; 621  : 		{	// replace old allocator
; 622  : 		_Free_proxy();
; 623  : 		_Pocma(_Getal(), _Al);
; 624  : 		_Alloc_proxy();
; 625  : 		}
; 626  : 
; 627  : 	void _Swap_alloc(_Myt& _Right)
; 628  : 		{	// swap allocators
; 629  : 		_Pocs(_Getal(), _Right._Getal());
; 630  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 631  : 		}
; 632  : 
; 633  : 	void _Alloc_proxy()
; 634  : 		{	// construct proxy
; 635  : 		typename _Alty::template rebind<_Container_proxy>::other
; 636  : 			_Alproxy(_Getal());
; 637  : 		_Myproxy() = _Alproxy.allocate(1);
; 638  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 639  : 		_Myproxy()->_Mycont = &_Get_data();
; 640  : 		}
; 641  : 
; 642  : 	void _Free_proxy()
; 643  : 		{	// destroy proxy
; 644  : 		typename _Alty::template rebind<_Container_proxy>::other
; 645  : 			_Alproxy(_Getal());
; 646  : 		_Orphan_all();
; 647  : 		_Alproxy.destroy(_Myproxy());
; 648  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 649  : 		_Myproxy() = 0;
; 650  : 		}
; 651  : 
; 652  : 	_Iterator_base12 **_Getpfirst() const
; 653  : 		{	// get address of iterator chain
; 654  : 		return (_Get_data()._Getpfirst());
; 655  : 		}
; 656  : 
; 657  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 658  : 		{	// return reference to _Myproxy
; 659  : 		return (_Get_data()._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 663  : 		{	// return const reference to _Myproxy
; 664  : 		return (_Get_data()._Myproxy);
; 665  : 		}
; 666  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 667  : 
; 668  : 	void _Orphan_all()
; 669  : 		{	// orphan all iterators
; 670  : 		_Get_data()._Orphan_all();
; 671  : 		}
; 672  : 
; 673  : 	void _Swap_all(_Myt& _Right)
; 674  : 		{	// swap all iterators
; 675  : 		_Get_data()._Swap_all(_Right._Get_data());
; 676  : 		}
; 677  : 
; 678  : 	_Alty& _Getal() _NOEXCEPT
; 679  : 		{	// return reference to allocator
; 680  : 		return (_Mypair._Get_first());
; 681  : 		}
; 682  : 
; 683  : 	const _Alty& _Getal() const _NOEXCEPT
; 684  : 		{	// return const reference to allocator
; 685  : 		return (_Mypair._Get_first());
; 686  : 		}
; 687  : 
; 688  : 	_String_val<_Val_types>& _Get_data() _NOEXCEPT
; 689  : 		{	// return reference to _String_val
; 690  : 		return (_Mypair._Get_second());
; 691  : 		}
; 692  : 
; 693  : 	const _String_val<_Val_types>& _Get_data() const _NOEXCEPT
; 694  : 		{	// return const reference to _String_val
; 695  : 		return (_Mypair._Get_second());
; 696  : 		}
; 697  : 
; 698  : 	typedef typename _String_val<_Val_types>::_Bxty _Bxty;
; 699  : 
; 700  : 	_Bxty& _Bx() _NOEXCEPT
; 701  : 		{	// return reference to _Bx
; 702  : 		return (_Get_data()._Bx);
; 703  : 		}
; 704  : 
; 705  : 	const _Bxty& _Bx() const _NOEXCEPT
; 706  : 		{	// return const reference to _Bx
; 707  : 		return (_Get_data()._Bx);
; 708  : 		}
; 709  : 
; 710  : 	size_type& _Mysize() _NOEXCEPT
; 711  : 		{	// return reference to _Mysize
; 712  : 		return (_Get_data()._Mysize);
; 713  : 		}
; 714  : 
; 715  : 	const size_type& _Mysize() const _NOEXCEPT
; 716  : 		{	// return const reference to _Mysize
; 717  : 		return (_Get_data()._Mysize);
; 718  : 		}
; 719  : 
; 720  : 	size_type& _Myres() _NOEXCEPT
; 721  : 		{	// return reference to _Myres
; 722  : 		return (_Get_data()._Myres);
; 723  : 		}
; 724  : 
; 725  : 	const size_type& _Myres() const _NOEXCEPT
; 726  : 		{	// return const reference to _Myres
; 727  : 		return (_Get_data()._Myres);
; 728  : 		}
; 729  : 
; 730  : private:
; 731  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 732  : 	};
; 733  : 
; 734  : 		// TEMPLATE CLASS basic_string
; 735  : template<class _Elem,
; 736  : 	class _Traits,
; 737  : 	class _Alloc>
; 738  : 	class basic_string
; 739  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 740  : 	{	// null-terminated transparent array of elements
; 741  : public:
; 742  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 743  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 744  : 	typedef _Traits traits_type;
; 745  : 	typedef _Alloc allocator_type;
; 746  : 
; 747  : 	typedef typename _Mybase::_Alty _Alty;
; 748  : 
; 749  : 	typedef typename _Mybase::value_type value_type;
; 750  : 	typedef typename _Mybase::size_type size_type;
; 751  : 	typedef typename _Mybase::difference_type difference_type;
; 752  : 	typedef typename _Mybase::pointer pointer;
; 753  : 	typedef typename _Mybase::const_pointer const_pointer;
; 754  : 	typedef typename _Mybase::reference reference;
; 755  : 	typedef typename _Mybase::const_reference const_reference;
; 756  : 
; 757  : 	typedef typename _Mybase::iterator iterator;
; 758  : 	typedef typename _Mybase::const_iterator const_iterator;
; 759  : 
; 760  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 761  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 762  : 
; 763  : 	basic_string(const _Myt& _Right)
; 764  : 
; 765  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 766  : 
; 767  : 
; 768  : 		{	// construct by copying _Right
; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);
; 771  : 		}
; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0003d	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00040	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00044	72 0c		 jb	 SHORT $LN104@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00046	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00048	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2243 : 		}

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
$LN104@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00052	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2243 : 		}

  00058	5d		 pop	 ebp
  00059	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2219 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	56		 push	 esi
  00007	85 d2		 test	 edx, edx
  00009	74 2d		 je	 SHORT $LN4@Inside

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0000b	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00011	72 04		 jb	 SHORT $LN16@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00013	8b 31		 mov	 esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00015	eb 02		 jmp	 SHORT $LN17@Inside
$LN16@Inside:
  00017	8b f1		 mov	 esi, ecx
$LN17@Inside:

; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00019	3b d6		 cmp	 edx, esi
  0001b	72 1b		 jb	 SHORT $LN4@Inside

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0001d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00020	72 04		 jb	 SHORT $LN34@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00022	8b 31		 mov	 esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00024	eb 02		 jmp	 SHORT $LN35@Inside
$LN34@Inside:
  00026	8b f1		 mov	 esi, ecx
$LN35@Inside:

; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00028	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0002b	03 c6		 add	 eax, esi
  0002d	3b c2		 cmp	 eax, edx
  0002f	76 07		 jbe	 SHORT $LN4@Inside

; 2223 : 		else
; 2224 : 			return (true);

  00031	b0 01		 mov	 al, 1
  00033	5e		 pop	 esi

; 2225 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN4@Inside:

; 2222 : 			return (false);	// don't ask

  00038	32 c0		 xor	 al, al
  0003a	5e		 pop	 esi

; 2225 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2206 : 		if (max_size() < _Newsize)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00007	83 fe fe	 cmp	 esi, -2			; fffffffeH
  0000a	77 62		 ja	 SHORT $LN103@Grow

; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)

  0000c	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  0000f	73 16		 jae	 SHORT $LN3@Grow

; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00011	ff 71 10	 push	 DWORD PTR [ecx+16]
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  0001a	33 c0		 xor	 eax, eax
  0001c	3b c6		 cmp	 eax, esi
  0001e	5e		 pop	 esi
  0001f	1b c0		 sbb	 eax, eax
  00021	f7 d8		 neg	 eax

; 2216 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN3@Grow:

; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00027	80 7d 0c 00	 cmp	 BYTE PTR __Trim$[ebp], 0
  0002b	74 22		 je	 SHORT $LN5@Grow
  0002d	83 fe 10	 cmp	 esi, 16			; 00000010H
  00030	73 1d		 jae	 SHORT $LN5@Grow

; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  00032	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00035	3b f0		 cmp	 esi, eax
  00037	0f 42 c6	 cmovb	 eax, esi
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  00042	33 c0		 xor	 eax, eax
  00044	3b c6		 cmp	 eax, esi
  00046	5e		 pop	 esi
  00047	1b c0		 sbb	 eax, eax
  00049	f7 d8		 neg	 eax

; 2216 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
$LN5@Grow:

; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)

  0004f	85 f6		 test	 esi, esi
  00051	75 0e		 jne	 SHORT $LN100@Grow

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres
; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}
; 516  : 
; 517  : 	union _Bxty
; 518  : 		{	// storage for small buffer or pointer to larger one
; 519  : 		value_type _Buf[_BUF_SIZE];
; 520  : 		pointer _Ptr;
; 521  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 522  : 		} _Bx;
; 523  : 
; 524  : 	size_type _Mysize;	// current length of string
; 525  : 	size_type _Myres;	// current storage reserved for string
; 526  : 	};
; 527  : 
; 528  : 		// TEMPLATE CLASS _String_alloc
; 529  : template<class _Alloc_types>
; 530  : 	class _String_alloc
; 531  : 	{	// base class for basic_string to hold allocator
; 532  : public:
; 533  : 	typedef _String_alloc<_Alloc_types> _Myt;
; 534  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 535  : 	typedef typename _Alloc_types::_Alty _Alty;
; 536  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 537  : 
; 538  : 	typedef typename _Val_types::value_type value_type;
; 539  : 	typedef typename _Val_types::size_type size_type;
; 540  : 	typedef typename _Val_types::difference_type difference_type;
; 541  : 	typedef typename _Val_types::pointer pointer;
; 542  : 	typedef typename _Val_types::const_pointer const_pointer;
; 543  : 	typedef typename _Val_types::reference reference;
; 544  : 	typedef typename _Val_types::const_reference const_reference;
; 545  : 
; 546  : 	typedef _String_iterator<_String_val<_Val_types> > iterator;
; 547  : 	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;
; 548  : 
; 549  : 	enum
; 550  : 		{	// length of internal buffer, [1, 16]
; 551  : 		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
; 552  : 		};
; 553  : 
; 554  : 	enum
; 555  : 		{	// roundup mask for allocated buffers, [0, 15]
; 556  : 		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
; 557  : 		};
; 558  : 
; 559  : 	value_type *_Myptr()
; 560  : 		{	// determine current pointer to buffer for mutable string
; 561  : 		return (_Get_data()._Myptr());
; 562  : 		}
; 563  : 
; 564  : 	const value_type *_Myptr() const
; 565  : 		{	// determine current pointer to buffer for nonmutable string
; 566  : 		return (_Get_data()._Myptr());
; 567  : 		}
; 568  : 
; 569  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 570  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 571  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 572  : 		{	// construct allocator from _Al
; 573  : 		}
; 574  : 
; 575  : 	_String_alloc(_Alloc&& _Al)
; 576  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 577  : 		{	// construct allocator from _Al
; 578  : 		}
; 579  : 
; 580  : 	void _Copy_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Pocca(_Getal(), _Al);
; 583  : 		}
; 584  : 
; 585  : 	void _Move_alloc(_Alty& _Al)
; 586  : 		{	// replace old allocator
; 587  : 		_Pocma(_Getal(), _Al);
; 588  : 		}
; 589  : 
; 590  : 	void _Swap_alloc(_Myt& _Right)
; 591  : 		{	// swap allocators
; 592  : 		_Pocs(_Getal(), _Right._Getal());
; 593  : 		}
; 594  : 
; 595  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 596  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 597  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 598  : 		{	// construct allocator from _Al
; 599  : 		_Alloc_proxy();
; 600  : 		}
; 601  : 
; 602  : 	_String_alloc(_Alloc&& _Al)
; 603  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 604  : 		{	// construct allocator from _Al
; 605  : 		_Alloc_proxy();
; 606  : 		}
; 607  : 
; 608  : 	~_String_alloc() _NOEXCEPT
; 609  : 		{	// destroy the object
; 610  : 		_Free_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Copy_alloc(const _Alty& _Al)
; 614  : 		{	// replace old allocator
; 615  : 		_Free_proxy();
; 616  : 		_Pocca(_Getal(), _Al);
; 617  : 		_Alloc_proxy();
; 618  : 		}
; 619  : 
; 620  : 	void _Move_alloc(_Alty& _Al)
; 621  : 		{	// replace old allocator
; 622  : 		_Free_proxy();
; 623  : 		_Pocma(_Getal(), _Al);
; 624  : 		_Alloc_proxy();
; 625  : 		}
; 626  : 
; 627  : 	void _Swap_alloc(_Myt& _Right)
; 628  : 		{	// swap allocators
; 629  : 		_Pocs(_Getal(), _Right._Getal());
; 630  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 631  : 		}
; 632  : 
; 633  : 	void _Alloc_proxy()
; 634  : 		{	// construct proxy
; 635  : 		typename _Alty::template rebind<_Container_proxy>::other
; 636  : 			_Alproxy(_Getal());
; 637  : 		_Myproxy() = _Alproxy.allocate(1);
; 638  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 639  : 		_Myproxy()->_Mycont = &_Get_data();
; 640  : 		}
; 641  : 
; 642  : 	void _Free_proxy()
; 643  : 		{	// destroy proxy
; 644  : 		typename _Alty::template rebind<_Container_proxy>::other
; 645  : 			_Alproxy(_Getal());
; 646  : 		_Orphan_all();
; 647  : 		_Alproxy.destroy(_Myproxy());
; 648  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 649  : 		_Myproxy() = 0;
; 650  : 		}
; 651  : 
; 652  : 	_Iterator_base12 **_Getpfirst() const
; 653  : 		{	// get address of iterator chain
; 654  : 		return (_Get_data()._Getpfirst());
; 655  : 		}
; 656  : 
; 657  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 658  : 		{	// return reference to _Myproxy
; 659  : 		return (_Get_data()._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 663  : 		{	// return const reference to _Myproxy
; 664  : 		return (_Get_data()._Myproxy);
; 665  : 		}
; 666  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 667  : 
; 668  : 	void _Orphan_all()
; 669  : 		{	// orphan all iterators
; 670  : 		_Get_data()._Orphan_all();
; 671  : 		}
; 672  : 
; 673  : 	void _Swap_all(_Myt& _Right)
; 674  : 		{	// swap all iterators
; 675  : 		_Get_data()._Swap_all(_Right._Get_data());
; 676  : 		}
; 677  : 
; 678  : 	_Alty& _Getal() _NOEXCEPT
; 679  : 		{	// return reference to allocator
; 680  : 		return (_Mypair._Get_first());
; 681  : 		}
; 682  : 
; 683  : 	const _Alty& _Getal() const _NOEXCEPT
; 684  : 		{	// return const reference to allocator
; 685  : 		return (_Mypair._Get_first());
; 686  : 		}
; 687  : 
; 688  : 	_String_val<_Val_types>& _Get_data() _NOEXCEPT
; 689  : 		{	// return reference to _String_val
; 690  : 		return (_Mypair._Get_second());
; 691  : 		}
; 692  : 
; 693  : 	const _String_val<_Val_types>& _Get_data() const _NOEXCEPT
; 694  : 		{	// return const reference to _String_val
; 695  : 		return (_Mypair._Get_second());
; 696  : 		}
; 697  : 
; 698  : 	typedef typename _String_val<_Val_types>::_Bxty _Bxty;
; 699  : 
; 700  : 	_Bxty& _Bx() _NOEXCEPT
; 701  : 		{	// return reference to _Bx
; 702  : 		return (_Get_data()._Bx);
; 703  : 		}
; 704  : 
; 705  : 	const _Bxty& _Bx() const _NOEXCEPT
; 706  : 		{	// return const reference to _Bx
; 707  : 		return (_Get_data()._Bx);
; 708  : 		}
; 709  : 
; 710  : 	size_type& _Mysize() _NOEXCEPT
; 711  : 		{	// return reference to _Mysize
; 712  : 		return (_Get_data()._Mysize);
; 713  : 		}
; 714  : 
; 715  : 	const size_type& _Mysize() const _NOEXCEPT
; 716  : 		{	// return const reference to _Mysize
; 717  : 		return (_Get_data()._Mysize);
; 718  : 		}
; 719  : 
; 720  : 	size_type& _Myres() _NOEXCEPT
; 721  : 		{	// return reference to _Myres
; 722  : 		return (_Get_data()._Myres);
; 723  : 		}
; 724  : 
; 725  : 	const size_type& _Myres() const _NOEXCEPT
; 726  : 		{	// return const reference to _Myres
; 727  : 		return (_Get_data()._Myres);
; 728  : 		}
; 729  : 
; 730  : private:
; 731  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 732  : 	};
; 733  : 
; 734  : 		// TEMPLATE CLASS basic_string
; 735  : template<class _Elem,
; 736  : 	class _Traits,
; 737  : 	class _Alloc>
; 738  : 	class basic_string
; 739  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 740  : 	{	// null-terminated transparent array of elements
; 741  : public:
; 742  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 743  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 744  : 	typedef _Traits traits_type;
; 745  : 	typedef _Alloc allocator_type;
; 746  : 
; 747  : 	typedef typename _Mybase::_Alty _Alty;
; 748  : 
; 749  : 	typedef typename _Mybase::value_type value_type;
; 750  : 	typedef typename _Mybase::size_type size_type;
; 751  : 	typedef typename _Mybase::difference_type difference_type;
; 752  : 	typedef typename _Mybase::pointer pointer;
; 753  : 	typedef typename _Mybase::const_pointer const_pointer;
; 754  : 	typedef typename _Mybase::reference reference;
; 755  : 	typedef typename _Mybase::const_reference const_reference;
; 756  : 
; 757  : 	typedef typename _Mybase::iterator iterator;
; 758  : 	typedef typename _Mybase::const_iterator const_iterator;
; 759  : 
; 760  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 761  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 762  : 
; 763  : 	basic_string(const _Myt& _Right)
; 764  : 
; 765  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 766  : 
; 767  : 
; 768  : 		{	// construct by copying _Right
; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);
; 771  : 		}
; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00053	89 71 10	 mov	 DWORD PTR [ecx+16], esi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00056	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0005a	72 02		 jb	 SHORT $LN91@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0005c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN91@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0005e	c6 01 00	 mov	 BYTE PTR [ecx], 0
$LN100@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  00061	33 c0		 xor	 eax, eax
  00063	3b c6		 cmp	 eax, esi
  00065	5e		 pop	 esi
  00066	1b c0		 sbb	 eax, eax
  00068	f7 d8		 neg	 eax

; 2216 : 		}

  0006a	5d		 pop	 ebp
  0006b	c2 08 00	 ret	 8
$LN103@Grow:

; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;
; 2242 : 		_Eos(_Newsize);
; 2243 : 		}
; 2244 : 
; 2245 : 	[[noreturn]] void _Xlen() const
; 2246 : 		{	// report a length_error
; 2247 : 		_Xlength_error("string too long");

  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00073	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN105@Grow:
$LN102@Grow:
  00078	cc		 int	 3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2199 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00003	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00006	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00009	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0000d	72 0a		 jb	 SHORT $LN22@Eos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00011	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2201 : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN22@Eos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00019	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2201 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$1$ = -24						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00033	8b f8		 mov	 edi, eax
  00035	83 cf 0f	 or	 edi, 15			; 0000000fH

; 2166 : 		if (max_size() < _Newres)

  00038	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0003b	76 04		 jbe	 SHORT $LN2@Copy

; 2167 : 			_Newres = _Newsize;	// undo roundup if too big

  0003d	8b f8		 mov	 edi, eax

; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  0003f	eb 27		 jmp	 SHORT $LN108@Copy
$LN2@Copy:
  00041	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00044	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00049	f7 e7		 mul	 edi
  0004b	8b cb		 mov	 ecx, ebx
  0004d	d1 e9		 shr	 ecx, 1
  0004f	d1 ea		 shr	 edx, 1
  00051	3b ca		 cmp	 ecx, edx
  00053	76 13		 jbe	 SHORT $LN108@Copy

; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 2171 : 			_Newres = this->_Myres()

  0005a	8d 3c 19	 lea	 edi, DWORD PTR [ecx+ebx]
  0005d	2b c1		 sub	 eax, ecx
  0005f	3b d8		 cmp	 ebx, eax
  00061	76 05		 jbe	 SHORT $LN108@Copy

; 723  : 		}
; 724  : 
; 725  : 	const size_type& _Myres() const _NOEXCEPT
; 726  : 		{	// return const reference to _Myres
; 727  : 		return (_Get_data()._Myres);
; 728  : 		}
; 729  : 
; 730  : private:
; 731  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 732  : 	};
; 733  : 
; 734  : 		// TEMPLATE CLASS basic_string
; 735  : template<class _Elem,
; 736  : 	class _Traits,
; 737  : 	class _Alloc>
; 738  : 	class basic_string
; 739  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 740  : 	{	// null-terminated transparent array of elements
; 741  : public:
; 742  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 743  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 744  : 	typedef _Traits traits_type;
; 745  : 	typedef _Alloc allocator_type;
; 746  : 
; 747  : 	typedef typename _Mybase::_Alty _Alty;
; 748  : 
; 749  : 	typedef typename _Mybase::value_type value_type;
; 750  : 	typedef typename _Mybase::size_type size_type;
; 751  : 	typedef typename _Mybase::difference_type difference_type;
; 752  : 	typedef typename _Mybase::pointer pointer;
; 753  : 	typedef typename _Mybase::const_pointer const_pointer;
; 754  : 	typedef typename _Mybase::reference reference;
; 755  : 	typedef typename _Mybase::const_reference const_reference;
; 756  : 
; 757  : 	typedef typename _Mybase::iterator iterator;
; 758  : 	typedef typename _Mybase::const_iterator const_iterator;
; 759  : 
; 760  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 761  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 762  : 
; 763  : 	basic_string(const _Myt& _Right)
; 764  : 
; 765  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 766  : 
; 767  : 
; 768  : 		{	// construct by copying _Right
; 769  : 		_Tidy();
; 770  : 		assign(_Right, 0, npos);
; 771  : 		}
; 772  : 
; 773  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 774  : 		: _Mybase(_Al)
; 775  : 		{	// construct by copying with allocator
; 776  : 		_Tidy();
; 777  : 		assign(_Right, 0, npos);
; 778  : 		}
; 779  : 
; 780  : 	basic_string() _NOEXCEPT
; 781  : 		: _Mybase()
; 782  : 		{	// construct empty string
; 783  : 		_Tidy();
; 784  : 		}
; 785  : 
; 786  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 787  : 		: _Mybase(_Al)
; 788  : 		{	// construct empty string with allocator
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 793  : 		size_type _Count = npos)
; 794  : 		: _Mybase(_Right._Getal())
; 795  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 796  : 		_Tidy();
; 797  : 		assign(_Right, _Roff, _Count);
; 798  : 		}
; 799  : 
; 800  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 801  : 		const _Alloc& _Al)
; 802  : 		: _Mybase(_Al)
; 803  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 804  : 		_Tidy();
; 805  : 		assign(_Right, _Roff, _Count);
; 806  : 		}
; 807  : 
; 808  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 809  : 		: _Mybase()
; 810  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 811  : 		_Tidy();
; 812  : 		assign(_Ptr, _Count);
; 813  : 		}
; 814  : 
; 815  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 816  : 		: _Mybase(_Al)
; 817  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 818  : 		_Tidy();
; 819  : 		assign(_Ptr, _Count);
; 820  : 		}
; 821  : 
; 822  : 	basic_string(const _Elem *_Ptr)
; 823  : 		: _Mybase()
; 824  : 		{	// construct from [_Ptr, <null>)
; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}
; 828  : 
; 829  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 830  : 		: _Mybase(_Al)
; 831  : 		{	// construct from [_Ptr, <null>) with allocator
; 832  : 		_Tidy();
; 833  : 		assign(_Ptr);
; 834  : 		}
; 835  : 
; 836  : 	basic_string(size_type _Count, _Elem _Ch)
; 837  : 		: _Mybase()
; 838  : 		{	// construct from _Count * _Ch
; 839  : 		_Tidy();
; 840  : 		assign(_Count, _Ch);
; 841  : 		}
; 842  : 
; 843  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 844  : 		: _Mybase(_Al)
; 845  : 		{	// construct from _Count * _Ch with allocator
; 846  : 		_Tidy();
; 847  : 		assign(_Count, _Ch);
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter,
; 851  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 852  : 			void>::type>
; 853  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 854  : 		: _Mybase(_Al)
; 855  : 		{	// construct from [_First, _Last) with optional allocator
; 856  : 		_DEBUG_RANGE(_First, _Last);
; 857  : 		_Tidy();
; 858  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 859  : 		}
; 860  : 
; 861  : 	template<class _Iter>
; 862  : 		void _Construct(_Iter _First,
; 863  : 			_Iter _Last, input_iterator_tag)
; 864  : 		{	// initialize from [_First, _Last), input iterators
; 865  : 		_TRY_BEGIN
; 866  : 		for (; _First != _Last; ++_First)
; 867  : 			append((size_type)1, (_Elem)*_First);
; 868  : 		_CATCH_ALL
; 869  : 		_Tidy(true);
; 870  : 		_RERAISE;
; 871  : 		_CATCH_END
; 872  : 		}
; 873  : 
; 874  : 	template<class _Iter>
; 875  : 		void _Construct(_Iter _First,
; 876  : 			_Iter _Last, forward_iterator_tag)
; 877  : 		{	// initialize from [_First, _Last), forward iterators
; 878  : 		size_type _Count = 0;
; 879  : 		_Distance(_First, _Last, _Count);
; 880  : 		reserve(_Count);
; 881  : 		_Construct(_First, _Last, input_iterator_tag());
; 882  : 		}
; 883  : 
; 884  : 	void _Construct(_Elem *_First,
; 885  : 		_Elem *_Last, random_access_iterator_tag)
; 886  : 		{	// initialize from [_First, _Last), pointers
; 887  : 		if (_First != _Last)
; 888  : 			assign(_First, _Last - _First);
; 889  : 		}
; 890  : 
; 891  : 	void _Construct(const _Elem *_First,
; 892  : 		const _Elem *_Last, random_access_iterator_tag)
; 893  : 		{	// initialize from [_First, _Last), const pointers
; 894  : 		if (_First != _Last)
; 895  : 			assign(_First, _Last - _First);
; 896  : 		}
; 897  : 
; 898  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 899  : 		: _Mybase(_STD move(_Right._Getal()))
; 900  : 		{	// construct by moving _Right
; 901  : 		_Tidy();
; 902  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 903  : 		}
; 904  : 
; 905  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 906  : 		: _Mybase(_Al)
; 907  : 		{	// construct by moving _Right, allocator
; 908  : 		if (this->_Getal() != _Right._Getal())
; 909  : 			assign(_Right.begin(), _Right.end());
; 910  : 		else
; 911  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 912  : 		}
; 913  : 
; 914  : 	_Myt& operator=(_Myt&& _Right)
; 915  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 916  : 			|| _Alty::is_always_equal::value)
; 917  : 		{	// assign by moving _Right
; 918  : 		if (this != &_Right)
; 919  : 			{	// different, assign it
; 920  : 			_Tidy(true);
; 921  : 
; 922  : 			if (_Alty::propagate_on_container_move_assignment::value
; 923  : 				&& this->_Getal() != _Right._Getal())
; 924  : 				this->_Move_alloc(_Right._Getal());
; 925  : 
; 926  : 			if (this->_Getal() != _Right._Getal())
; 927  : 				assign(_Right.begin(), _Right.end());
; 928  : 			else
; 929  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 935  : 		{	// assign by moving _Right
; 936  : 		if (this == &_Right)
; 937  : 			;
; 938  : 		else if (get_allocator() != _Right.get_allocator()
; 939  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 940  : 			*this = _Right;
; 941  : 		else
; 942  : 			{	// not same, clear this and steal from _Right
; 943  : 			_Tidy(true);
; 944  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 945  : 			}
; 946  : 		return (*this);
; 947  : 		}
; 948  : 
; 949  : 	void _Assign_rv(_Myt&& _Right)
; 950  : 		{	// assign by moving _Right
; 951  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 952  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 953  : 				_Right._Mysize() + 1);
; 954  : 		else
; 955  : 			{	// copy pointer
; 956  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 957  : 			_Right._Bx()._Ptr = pointer();
; 958  : 			}
; 959  : 		this->_Mysize() = _Right._Mysize();
; 960  : 		this->_Myres() = _Right._Myres();
; 961  : 		_Right._Tidy();
; 962  : 		}
; 963  : 
; 964  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 965  : 		const _Alloc& _Al = allocator_type())
; 966  : 		: _Mybase(_Al)
; 967  : 		{	// construct from initializer_list
; 968  : 		_Tidy();
; 969  : 		assign(_Ilist.begin(), _Ilist.end());
; 970  : 		}
; 971  : 
; 972  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// assign initializer_list
; 974  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 978  : 		{	// append initializer_list
; 979  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 980  : 		}
; 981  : 
; 982  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 983  : 		{	// assign initializer_list
; 984  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 985  : 		}
; 986  : 
; 987  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 988  : 		{	// append initializer_list
; 989  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 990  : 		}
; 991  : 
; 992  : 	iterator insert(const_iterator _Where,
; 993  : 		_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// insert initializer_list
; 995  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// replace with initializer_list
; 1001 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	~basic_string() _NOEXCEPT
; 1005 : 		{	// destroy the string
; 1006 : 		_Tidy(true);
; 1007 : 		}
; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00063	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LN108@Copy:

; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  00068	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00072	50		 push	 eax
  00073	8b ce		 mov	 ecx, esi
  00075	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  0007a	8b c8		 mov	 ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
  0007c	eb 29		 jmp	 SHORT $LN469@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  0007e	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00081	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  00084	89 45 08	 mov	 DWORD PTR __Newres$[ebp], eax

; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00087	40		 inc	 eax
  00088	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  0008b	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2181 : 			_TRY_BEGIN

  0008c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 898  : 		return (_Mybase::allocate(_Count));

  00090	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00095	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END

  00098	b8 00 00 00 00	 mov	 eax, $LN466@Copy
  0009d	c3		 ret	 0
$LN466@Copy:
  0009e	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]
  000a1	8b 7d 08	 mov	 edi, DWORD PTR __Newres$[ebp]
  000a4	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN469@Copy:

; 2188 : 
; 2189 : 		if (0 < _Oldlen)

  000a7	8b 5d 0c	 mov	 ebx, DWORD PTR __Oldlen$[ebp]
  000aa	89 4d e8	 mov	 DWORD PTR __Ptr$1$[ebp], ecx
  000ad	85 db		 test	 ebx, ebx
  000af	74 1b		 je	 SHORT $LN276@Copy

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000b1	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000b5	72 04		 jb	 SHORT $LN265@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000b9	eb 02		 jmp	 SHORT $LN266@Copy
$LN265@Copy:
  000bb	8b c6		 mov	 eax, esi
$LN266@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  000bd	85 db		 test	 ebx, ebx
  000bf	74 0b		 je	 SHORT $LN276@Copy
  000c1	53		 push	 ebx
  000c2	50		 push	 eax
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _memcpy
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN276@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  000cc	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000cf	83 f8 10	 cmp	 eax, 16			; 00000010H
  000d2	72 0b		 jb	 SHORT $LN280@Copy

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  000d4	40		 inc	 eax
  000d5	8b ce		 mov	 ecx, esi
  000d7	50		 push	 eax
  000d8	ff 36		 push	 DWORD PTR [esi]
  000da	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN280@Copy:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  000df	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000e6	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000ed	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000f1	72 04		 jb	 SHORT $LN380@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  000f3	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000f5	eb 02		 jmp	 SHORT $LN381@Copy
$LN380@Copy:
  000f7	8b c6		 mov	 eax, esi
$LN381@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000f9	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 655  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$1$[ebp]
  000ff	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2194 : 		this->_Myres() = _Newres;

  00101	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00104	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00107	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0010b	72 02		 jb	 SHORT $LN456@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0010d	8b f0		 mov	 esi, eax
$LN456@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0010f	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2196 : 		}

  00113	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00116	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011d	59		 pop	 ecx
  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi
  00120	5b		 pop	 ebx
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 08 00	 ret	 8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres
; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}
; 516  : 
; 517  : 	union _Bxty
; 518  : 		{	// storage for small buffer or pointer to larger one
; 519  : 		value_type _Buf[_BUF_SIZE];
; 520  : 		pointer _Ptr;
; 521  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 522  : 		} _Bx;
; 523  : 
; 524  : 	size_type _Mysize;	// current length of string
; 525  : 	size_type _Myres;	// current storage reserved for string
; 526  : 	};
; 527  : 
; 528  : 		// TEMPLATE CLASS _String_alloc
; 529  : template<class _Alloc_types>
; 530  : 	class _String_alloc
; 531  : 	{	// base class for basic_string to hold allocator
; 532  : public:
; 533  : 	typedef _String_alloc<_Alloc_types> _Myt;
; 534  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 535  : 	typedef typename _Alloc_types::_Alty _Alty;
; 536  : 	typedef typename _Alloc_types::_Val_types _Val_types;
; 537  : 
; 538  : 	typedef typename _Val_types::value_type value_type;
; 539  : 	typedef typename _Val_types::size_type size_type;
; 540  : 	typedef typename _Val_types::difference_type difference_type;
; 541  : 	typedef typename _Val_types::pointer pointer;
; 542  : 	typedef typename _Val_types::const_pointer const_pointer;
; 543  : 	typedef typename _Val_types::reference reference;
; 544  : 	typedef typename _Val_types::const_reference const_reference;
; 545  : 
; 546  : 	typedef _String_iterator<_String_val<_Val_types> > iterator;
; 547  : 	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;
; 548  : 
; 549  : 	enum
; 550  : 		{	// length of internal buffer, [1, 16]
; 551  : 		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
; 552  : 		};
; 553  : 
; 554  : 	enum
; 555  : 		{	// roundup mask for allocated buffers, [0, 15]
; 556  : 		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
; 557  : 		};
; 558  : 
; 559  : 	value_type *_Myptr()
; 560  : 		{	// determine current pointer to buffer for mutable string
; 561  : 		return (_Get_data()._Myptr());
; 562  : 		}
; 563  : 
; 564  : 	const value_type *_Myptr() const
; 565  : 		{	// determine current pointer to buffer for nonmutable string
; 566  : 		return (_Get_data()._Myptr());
; 567  : 		}
; 568  : 
; 569  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 570  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 571  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 572  : 		{	// construct allocator from _Al
; 573  : 		}
; 574  : 
; 575  : 	_String_alloc(_Alloc&& _Al)
; 576  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 577  : 		{	// construct allocator from _Al
; 578  : 		}
; 579  : 
; 580  : 	void _Copy_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Pocca(_Getal(), _Al);
; 583  : 		}
; 584  : 
; 585  : 	void _Move_alloc(_Alty& _Al)
; 586  : 		{	// replace old allocator
; 587  : 		_Pocma(_Getal(), _Al);
; 588  : 		}
; 589  : 
; 590  : 	void _Swap_alloc(_Myt& _Right)
; 591  : 		{	// swap allocators
; 592  : 		_Pocs(_Getal(), _Right._Getal());
; 593  : 		}
; 594  : 
; 595  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 596  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 597  : 		: _Mypair(_One_then_variadic_args_t(), _Al)
; 598  : 		{	// construct allocator from _Al
; 599  : 		_Alloc_proxy();
; 600  : 		}
; 601  : 
; 602  : 	_String_alloc(_Alloc&& _Al)
; 603  : 		: _Mypair(_One_then_variadic_args_t(), _STD move(_Al))
; 604  : 		{	// construct allocator from _Al
; 605  : 		_Alloc_proxy();
; 606  : 		}
; 607  : 
; 608  : 	~_String_alloc() _NOEXCEPT
; 609  : 		{	// destroy the object
; 610  : 		_Free_proxy();
; 611  : 		}
; 612  : 
; 613  : 	void _Copy_alloc(const _Alty& _Al)
; 614  : 		{	// replace old allocator
; 615  : 		_Free_proxy();
; 616  : 		_Pocca(_Getal(), _Al);
; 617  : 		_Alloc_proxy();
; 618  : 		}
; 619  : 
; 620  : 	void _Move_alloc(_Alty& _Al)
; 621  : 		{	// replace old allocator
; 622  : 		_Free_proxy();
; 623  : 		_Pocma(_Getal(), _Al);
; 624  : 		_Alloc_proxy();
; 625  : 		}
; 626  : 
; 627  : 	void _Swap_alloc(_Myt& _Right)
; 628  : 		{	// swap allocators
; 629  : 		_Pocs(_Getal(), _Right._Getal());
; 630  : 		_Swap_adl(_Myproxy(), _Right._Myproxy());
; 631  : 		}
; 632  : 
; 633  : 	void _Alloc_proxy()
; 634  : 		{	// construct proxy
; 635  : 		typename _Alty::template rebind<_Container_proxy>::other
; 636  : 			_Alproxy(_Getal());
; 637  : 		_Myproxy() = _Alproxy.allocate(1);
; 638  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());
; 639  : 		_Myproxy()->_Mycont = &_Get_data();
; 640  : 		}
; 641  : 
; 642  : 	void _Free_proxy()
; 643  : 		{	// destroy proxy
; 644  : 		typename _Alty::template rebind<_Container_proxy>::other
; 645  : 			_Alproxy(_Getal());
; 646  : 		_Orphan_all();
; 647  : 		_Alproxy.destroy(_Myproxy());
; 648  : 		_Alproxy.deallocate(_Myproxy(), 1);
; 649  : 		_Myproxy() = 0;
; 650  : 		}
; 651  : 
; 652  : 	_Iterator_base12 **_Getpfirst() const
; 653  : 		{	// get address of iterator chain
; 654  : 		return (_Get_data()._Getpfirst());
; 655  : 		}
; 656  : 
; 657  : 	_Container_proxy * & _Myproxy() _NOEXCEPT
; 658  : 		{	// return reference to _Myproxy
; 659  : 		return (_Get_data()._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	_Container_proxy * const & _Myproxy() const _NOEXCEPT
; 663  : 		{	// return const reference to _Myproxy
; 664  : 		return (_Get_data()._Myproxy);
; 665  : 		}
; 666  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 667  : 
; 668  : 	void _Orphan_all()
; 669  : 		{	// orphan all iterators
; 670  : 		_Get_data()._Orphan_all();
; 671  : 		}
; 672  : 
; 673  : 	void _Swap_all(_Myt& _Right)
; 674  : 		{	// swap all iterators
; 675  : 		_Get_data()._Swap_all(_Right._Get_data());
; 676  : 		}
; 677  : 
; 678  : 	_Alty& _Getal() _NOEXCEPT
; 679  : 		{	// return reference to allocator
; 680  : 		return (_Mypair._Get_first());
; 681  : 		}
; 682  : 
; 683  : 	const _Alty& _Getal() const _NOEXCEPT
; 684  : 		{	// return const reference to allocator
; 685  : 		return (_Mypair._Get_first());
; 686  : 		}
; 687  : 
; 688  : 	_String_val<_Val_types>& _Get_data() _NOEXCEPT
; 689  : 		{	// return reference to _String_val
; 690  : 		return (_Mypair._Get_second());
; 691  : 		}
; 692  : 
; 693  : 	const _String_val<_Val_types>& _Get_data() const _NOEXCEPT
; 694  : 		{	// return const reference to _String_val
; 695  : 		return (_Mypair._Get_second());
; 696  : 		}
; 697  : 
; 698  : 	typedef typename _String_val<_Val_types>::_Bxty _Bxty;
; 699  : 
; 700  : 	_Bxty& _Bx() _NOEXCEPT
; 701  : 		{	// return reference to _Bx
; 702  : 		return (_Get_data()._Bx);
; 703  : 		}
; 704  : 
; 705  : 	const _Bxty& _Bx() const _NOEXCEPT
; 706  : 		{	// return const reference to _Bx
; 707  : 		return (_Get_data()._Bx);
; 708  : 		}
; 709  : 
; 710  : 	size_type& _Mysize() _NOEXCEPT
; 711  : 		{	// return reference to _Mysize
; 712  : 		return (_Get_data()._Mysize);
; 713  : 		}
; 714  : 
; 715  : 	const size_type& _Mysize() const _NOEXCEPT
; 716  : 		{	// return const reference to _Mysize
; 717  : 		return (_Get_data()._Mysize);
; 718  : 		}
; 719  : 
; 720  : 	size_type& _Myres() _NOEXCEPT
; 721  : 		{	// return reference to _Myres
; 722  : 		return (_Get_data()._Myres);

  00127	8b 75 ec	 mov	 esi, DWORD PTR _this$[ebp]

; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  0012a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0012d	83 f8 10	 cmp	 eax, 16			; 00000010H
  00130	72 0b		 jb	 SHORT $LN144@Copy

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00132	40		 inc	 eax
  00133	8b ce		 mov	 ecx, esi
  00135	50		 push	 eax
  00136	ff 36		 push	 DWORD PTR [esi]
  00138	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN144@Copy:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  0013d	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00144	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0014b	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0014f	72 02		 jb	 SHORT $LN245@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00151	8b 36		 mov	 esi, DWORD PTR [esi]
$LN245@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2185 : 			_RERAISE;

  00153	6a 00		 push	 0
  00155	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00157	c6 06 00	 mov	 BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2185 : 			_RERAISE;

  0015a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN470@Copy:
$LN468@Copy:
  0015f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 11		 jne	 SHORT $LN5@find
  0000c	33 d2		 xor	 edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

  0000e	52		 push	 edx
  0000f	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00018	5e		 pop	 esi

; 1907 : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
$LN5@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

  0001d	8b d6		 mov	 edx, esi
  0001f	57		 push	 edi
  00020	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@find:
  00023	8a 02		 mov	 al, BYTE PTR [edx]
  00025	42		 inc	 edx
  00026	84 c0		 test	 al, al
  00028	75 f9		 jne	 SHORT $LL7@find
  0002a	2b d7		 sub	 edx, edi
  0002c	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));

  0002d	52		 push	 edx
  0002e	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00037	5e		 pop	 esi

; 1907 : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00007	53		 push	 ebx
  00008	8b 5d 10	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000e	85 db		 test	 ebx, ebx
  00010	75 0e		 jne	 SHORT $LN5@find
  00012	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00015	77 09		 ja	 SHORT $LN5@find

; 1887 : 			return (_Off);	// null string always matches (if inside string)

  00017	8b c2		 mov	 eax, edx
  00019	5b		 pop	 ebx

; 1901 : 		}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
$LN5@find:
  00020	56		 push	 esi

; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))

  00021	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00024	57		 push	 edi
  00025	3b d6		 cmp	 edx, esi
  00027	73 6a		 jae	 SHORT $LN3@find
  00029	2b f2		 sub	 esi, edx
  0002b	3b de		 cmp	 ebx, esi
  0002d	77 64		 ja	 SHORT $LN3@find

; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	2b c3		 sub	 eax, ebx
  00036	03 f0		 add	 esi, eax

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00038	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0003c	72 02		 jb	 SHORT $LN46@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN46@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;

  00040	8d 1c 11	 lea	 ebx, DWORD PTR [ecx+edx]
$LL4@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  00043	85 f6		 test	 esi, esi
  00045	74 4c		 je	 SHORT $LN3@find
  00047	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004a	56		 push	 esi
  0004b	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0004e	50		 push	 eax
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 _memchr
  00055	8b f8		 mov	 edi, eax
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;

  0005a	85 ff		 test	 edi, edi
  0005c	74 35		 je	 SHORT $LN3@find

; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

  0005e	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00061	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 ?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	85 c0		 test	 eax, eax
  0006f	74 0a		 je	 SHORT $LN77@find

; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

  00071	2b df		 sub	 ebx, edi
  00073	4b		 dec	 ebx
  00074	03 f3		 add	 esi, ebx
  00076	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  00079	eb c8		 jmp	 SHORT $LL4@find
$LN77@find:

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  0007e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00082	72 02		 jb	 SHORT $LN68@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00084	8b 00		 mov	 eax, DWORD PTR [eax]
$LN68@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1897 : 					return (_Uptr - this->_Myptr());	// found a match

  00086	2b f8		 sub	 edi, eax
  00088	8b c7		 mov	 eax, edi
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 1901 : 		}

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 0c 00	 ret	 12			; 0000000cH
$LN3@find:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi

; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match

  00095	83 c8 ff	 or	 eax, -1
  00098	5b		 pop	 ebx

; 1901 : 		}

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1757 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1750 : 		return (this->_Mysize());

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 1751 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1345 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1346 : 		if (this->_Mysize() < _Off)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00009	57		 push	 edi
  0000a	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	72 7e		 jb	 SHORT $LN124@erase

; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00014	8b c7		 mov	 eax, edi
  00016	2b c1		 sub	 eax, ecx
  00018	3b c2		 cmp	 eax, edx
  0001a	77 23		 ja	 SHORT $LN3@erase

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0001c	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0001f	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00023	72 0e		 jb	 SHORT $LN49@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00028	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1357 : 		return (*this);

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 1358 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
$LN49@erase:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00037	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN3@erase:

; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)

  0003f	85 d2		 test	 edx, edx
  00041	74 44		 je	 SHORT $LN121@erase

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00043	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00047	72 04		 jb	 SHORT $LN70@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00049	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0004b	eb 02		 jmp	 SHORT $LN71@erase
$LN70@erase:
  0004d	8b c6		 mov	 eax, esi
$LN71@erase:

; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;

  0004f	2b fa		 sub	 edi, edx
  00051	53		 push	 ebx
  00052	8d 1c 08	 lea	 ebx, DWORD PTR [eax+ecx]

; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00055	8b c7		 mov	 eax, edi
  00057	2b c1		 sub	 eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

  00059	74 0e		 je	 SHORT $LN90@erase
  0005b	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  0005c	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

  0005f	50		 push	 eax
  00060	53		 push	 ebx
  00061	e8 00 00 00 00	 call	 _memmove
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN90@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00069	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0006c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00070	5b		 pop	 ebx
  00071	72 0e		 jb	 SHORT $LN112@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00073	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00075	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1357 : 		return (*this);

  00079	8b c6		 mov	 eax, esi
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 1358 : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
$LN112@erase:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00081	8b c6		 mov	 eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00083	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN121@erase:
  00087	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1357 : 		return (*this);

  00088	8b c6		 mov	 eax, esi
  0008a	5e		 pop	 esi

; 1358 : 		}

  0008b	5d		 pop	 ebp
  0008c	c2 08 00	 ret	 8
$LN124@erase:

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)
; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)
; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow
; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)
; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do
; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;
; 2242 : 		_Eos(_Newsize);
; 2243 : 		}
; 2244 : 
; 2245 : 	[[noreturn]] void _Xlen() const
; 2246 : 		{	// report a length_error
; 2247 : 		_Xlength_error("string too long");
; 2248 : 		}
; 2249 : 
; 2250 : 	[[noreturn]] void _Xran() const
; 2251 : 		{	// report an out_of_range error
; 2252 : 		_Xout_of_range("invalid string position");

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00094	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN126@erase:
$LN123@erase:
  00099	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1337 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1338 : 		if (this->_Mysize() < _Off)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00006	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00009	72 21		 jb	 SHORT $LN49@erase

; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0000b	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0000e	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00012	72 0c		 jb	 SHORT $LN37@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00016	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1341 : 		return (*this);

  0001a	8b c1		 mov	 eax, ecx

; 1342 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN37@erase:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00020	8b d1		 mov	 edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00022	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1341 : 		return (*this);

  00026	8b c1		 mov	 eax, ecx

; 1342 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN49@erase:

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)
; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)
; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow
; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)
; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do
; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;
; 2242 : 		_Eos(_Newsize);
; 2243 : 		}
; 2244 : 
; 2245 : 	[[noreturn]] void _Xlen() const
; 2246 : 		{	// report a length_error
; 2247 : 		_Xlength_error("string too long");
; 2248 : 		}
; 2249 : 
; 2250 : 	[[noreturn]] void _Xran() const
; 2251 : 		{	// report an out_of_range error
; 2252 : 		_Xout_of_range("invalid string position");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00031	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN51@erase:
$LN48@erase:
  00036	cc		 int	 3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1174 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000a	75 0e		 jne	 SHORT $LN5@assign
  0000c	33 d2		 xor	 edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0000e	52		 push	 edx
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00015	5e		 pop	 esi

; 1177 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

  0001a	8b d6		 mov	 edx, esi
  0001c	57		 push	 edi
  0001d	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL7@assign:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL7@assign
  00027	2b d7		 sub	 edx, edi
  00029	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0002a	52		 push	 edx
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00031	5e		 pop	 esi

; 1177 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]
  00007	56		 push	 esi

; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)

  00008	8b f1		 mov	 esi, ecx

; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  0000a	85 db		 test	 ebx, ebx
  0000c	74 57		 je	 SHORT $LN2@assign

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0000e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 04		 jb	 SHORT $LN20@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00018	eb 02		 jmp	 SHORT $LN21@assign
$LN20@assign:
  0001a	8b c6		 mov	 eax, esi
$LN21@assign:

; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  0001c	3b d8		 cmp	 ebx, eax
  0001e	72 45		 jb	 SHORT $LN2@assign

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00023	72 04		 jb	 SHORT $LN38@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00025	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00027	eb 02		 jmp	 SHORT $LN39@assign
$LN38@assign:
  00029	8b d6		 mov	 edx, esi
$LN39@assign:

; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

  0002b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002e	03 c2		 add	 eax, edx
  00030	3b c3		 cmp	 eax, ebx
  00032	76 31		 jbe	 SHORT $LN2@assign

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00034	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00037	72 16		 jb	 SHORT $LN65@assign

; 1162 : 			return (assign(*this,

  00039	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1162 : 			return (assign(*this,

  0003e	8b ce		 mov	 ecx, esi
  00040	2b d8		 sub	 ebx, eax
  00042	53		 push	 ebx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx

; 1171 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
$LN65@assign:

; 1162 : 			return (assign(*this,

  0004f	ff 75 0c	 push	 DWORD PTR __Count$[ebp]

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00052	8b c6		 mov	 eax, esi

; 1162 : 			return (assign(*this,

  00054	8b ce		 mov	 ecx, esi
  00056	2b d8		 sub	 ebx, eax
  00058	53		 push	 ebx
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 1171 : 		}

  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN2@assign:
  00065	57		 push	 edi

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)

  00066	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00069	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0006c	77 7d		 ja	 SHORT $LN233@assign

; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)

  0006e	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00071	73 19		 jae	 SHORT $LN75@assign

; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00073	ff 76 10	 push	 DWORD PTR [esi+16]
  00076	8b ce		 mov	 ecx, esi
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  0007e	85 ff		 test	 edi, edi

; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))

  00080	74 60		 je	 SHORT $LN227@assign
$LN232@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00082	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00086	72 2b		 jb	 SHORT $LN185@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00088	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0008a	eb 29		 jmp	 SHORT $LN186@assign
$LN75@assign:

; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)

  0008c	85 ff		 test	 edi, edi
  0008e	75 f2		 jne	 SHORT $LN232@assign

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00090	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00093	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00097	72 0e		 jb	 SHORT $LN163@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00099	8b 06		 mov	 eax, DWORD PTR [esi]
  0009b	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0009c	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1170 : 		return (*this);

  0009f	8b c6		 mov	 eax, esi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx

; 1171 : 		}

  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8
$LN163@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000a7	8b c6		 mov	 eax, esi
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000ac	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1171 : 		}

  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8
$LN185@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000b3	8b c6		 mov	 eax, esi
$LN186@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  000b5	85 ff		 test	 edi, edi
  000b7	74 0b		 je	 SHORT $LN196@assign
  000b9	57		 push	 edi
  000ba	53		 push	 ebx
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN196@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000c4	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000c7	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000cb	72 0f		 jb	 SHORT $LN218@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  000cd	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000cf	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1170 : 		return (*this);

  000d3	8b c6		 mov	 eax, esi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 1171 : 		}

  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8
$LN218@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000dc	8b c6		 mov	 eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000de	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN227@assign:
  000e2	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1170 : 		return (*this);

  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 1171 : 		}

  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN233@assign:

; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;
; 2242 : 		_Eos(_Newsize);
; 2243 : 		}
; 2244 : 
; 2245 : 	[[noreturn]] void _Xlen() const
; 2246 : 		{	// report a length_error
; 2247 : 		_Xlength_error("string too long");

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000f0	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN235@assign:
$LN230@assign:
  000f5	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1141 : 		if (_Right.size() < _Roff)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0000e	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00011	3b f9		 cmp	 edi, ecx
  00013	0f 82 e8 00 00
	00		 jb	 $LN258@assign

; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;

  00019	2b f9		 sub	 edi, ecx

; 1144 : 		if (_Count < _Num)

  0001b	39 7d 10	 cmp	 DWORD PTR __Count$[ebp], edi
  0001e	0f 42 7d 10	 cmovb	 edi, DWORD PTR __Count$[ebp]

; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)

  00022	3b f3		 cmp	 esi, ebx
  00024	75 47		 jne	 SHORT $LN4@assign

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00026	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]

; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)

  00029	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0002c	0f 82 d9 00 00
	00		 jb	 $LN260@assign

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00032	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00035	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00039	72 19		 jb	 SHORT $LN71@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  0003b	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0003d	51		 push	 ecx
  0003e	6a 00		 push	 0
  00040	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00042	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00046	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0004b	5f		 pop	 edi

; 1155 : 		return (*this);

  0004c	8b c6		 mov	 eax, esi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx

; 1156 : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN71@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00054	8b d6		 mov	 edx, esi

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00056	51		 push	 ecx
  00057	6a 00		 push	 0
  00059	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0005b	c6 04 02 00	 mov	 BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  0005f	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00064	5f		 pop	 edi

; 1155 : 		return (*this);

  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx

; 1156 : 		}

  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
$LN4@assign:

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)

  0006d	83 ff fe	 cmp	 edi, -2			; fffffffeH
  00070	0f 87 9f 00 00
	00		 ja	 $LN261@assign

; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)

  00076	39 7e 14	 cmp	 DWORD PTR [esi+20], edi
  00079	73 24		 jae	 SHORT $LN84@assign

; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  0007b	ff 76 10	 push	 DWORD PTR [esi+16]
  0007e	8b ce		 mov	 ecx, esi
  00080	57		 push	 edi
  00081	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00086	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]

; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do

  00089	85 ff		 test	 edi, edi

; 1149 : 		else if (_Grow(_Num))

  0008b	74 6b		 je	 SHORT $LN253@assign
$LN257@assign:

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}
; 509  : 
; 510  : 	const value_type *_Myptr() const
; 511  : 		{	// determine current pointer to buffer for nonmutable string
; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  0008d	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
  00091	72 02		 jb	 SHORT $LN193@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00093	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN193@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00095	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00099	72 2b		 jb	 SHORT $LN211@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 697  : 	return (_Addressof(_Val, is_function<_Ty>()));

  0009b	8b 16		 mov	 edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0009d	eb 29		 jmp	 SHORT $LN212@assign
$LN84@assign:

; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)

  0009f	85 ff		 test	 edi, edi
  000a1	75 ea		 jne	 SHORT $LN257@assign

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000a3	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000a6	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000aa	72 0e		 jb	 SHORT $LN172@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  000ac	8b 06		 mov	 eax, DWORD PTR [esi]
  000ae	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000af	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1155 : 		return (*this);

  000b2	8b c6		 mov	 eax, esi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx

; 1156 : 		}

  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
$LN172@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000ba	8b c6		 mov	 eax, esi
  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5b		 pop	 ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000bf	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1156 : 		}

  000c2	5d		 pop	 ebp
  000c3	c2 0c 00	 ret	 12			; 0000000cH
$LN211@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000c6	8b d6		 mov	 edx, esi
$LN212@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  000c8	85 ff		 test	 edi, edi
  000ca	74 0e		 je	 SHORT $LN222@assign
  000cc	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1151 : 			_Traits::copy(this->_Myptr(),

  000cd	8d 04 0b	 lea	 eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  000d0	50		 push	 eax
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 _memcpy
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN222@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000da	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000dd	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  000e1	72 0f		 jb	 SHORT $LN244@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  000e3	8b 06		 mov	 eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000e5	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1155 : 		return (*this);

  000e9	8b c6		 mov	 eax, esi
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx

; 1156 : 		}

  000ee	5d		 pop	 ebp
  000ef	c2 0c 00	 ret	 12			; 0000000cH
$LN244@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000f2	8b c6		 mov	 eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000f4	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
$LN253@assign:
  000f8	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1155 : 		return (*this);

  000f9	8b c6		 mov	 eax, esi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx

; 1156 : 		}

  000fd	5d		 pop	 ebp
  000fe	c2 0c 00	 ret	 12			; 0000000cH
$LN258@assign:

; 2248 : 		}
; 2249 : 
; 2250 : 	[[noreturn]] void _Xran() const
; 2251 : 		{	// report an out_of_range error
; 2252 : 		_Xout_of_range("invalid string position");

  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00106	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN262@assign:
$LN260@assign:
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00110	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN263@assign:
$LN261@assign:

; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())
; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;
; 2242 : 		_Eos(_Newsize);
; 2243 : 		}
; 2244 : 
; 2245 : 	[[noreturn]] void _Xlen() const
; 2246 : 		{	// report a length_error
; 2247 : 		_Xlength_error("string too long");

  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0011a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN264@assign:
$LN255@assign:
  0011f	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1005 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2201 : 		}
; 2202 : 
; 2203 : 	bool _Grow(size_type _Newsize,
; 2204 : 		bool _Trim = false)
; 2205 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2206 : 		if (max_size() < _Newsize)
; 2207 : 			_Xlen();	// result too long
; 2208 : 		if (this->_Myres() < _Newsize)
; 2209 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow
; 2210 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2211 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2212 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2213 : 		else if (_Newsize == 0)
; 2214 : 			_Eos(0);	// new size is zero, just null terminate
; 2215 : 		return (0 < _Newsize);	// return true only if more work to do
; 2216 : 		}
; 2217 : 
; 2218 : 	bool _Inside(const _Elem *_Ptr)
; 2219 : 		{	// test if _Ptr points inside string
; 2220 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2221 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)
; 2222 : 			return (false);	// don't ask
; 2223 : 		else
; 2224 : 			return (true);
; 2225 : 		}
; 2226 : 
; 2227 : 	void _Tidy(bool _Built = false,
; 2228 : 		size_type _Newsize = 0)
; 2229 : 		{	// initialize buffer, deallocating any storage
; 2230 : 		if (!_Built)
; 2231 : 			;
; 2232 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H
  00009	72 09		 jb	 SHORT $LN6@basic_stri

; 2233 : 			{	// copy any leftovers to small buffer and deallocate
; 2234 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2235 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2236 : 			if (0 < _Newsize)
; 2237 : 				_Traits::copy(this->_Bx()._Buf,
; 2238 : 					_STD addressof(*_Ptr), _Newsize);
; 2239 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:

; 2240 : 			}
; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00014	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1008 : 
; 1009 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1010 : 
; 1011 : 	_Myt& operator=(const _Myt& _Right)
; 1012 : 		{	// assign _Right
; 1013 : 		if (this != &_Right)
; 1014 : 			{	// different, assign it
; 1015 : 			if (this->_Getal() != _Right._Getal()
; 1016 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1017 : 				{	// change allocator before copying
; 1018 : 				_Tidy(true);
; 1019 : 				this->_Copy_alloc(_Right._Getal());
; 1020 : 				}
; 1021 : 
; 1022 : 			assign(_Right);
; 1023 : 			}
; 1024 : 		return (*this);
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator=(const _Elem *_Ptr)
; 1028 : 		{	// assign [_Ptr, <null>)
; 1029 : 		return (assign(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator=(_Elem _Ch)
; 1033 : 		{	// assign 1 * _Ch
; 1034 : 		return (assign(1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& operator+=(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1043 : 		{	// append [_Ptr, <null>)
; 1044 : 		return (append(_Ptr));
; 1045 : 		}
; 1046 : 
; 1047 : 	_Myt& operator+=(_Elem _Ch)
; 1048 : 		{	// append 1 * _Ch
; 1049 : 		return (append((size_type)1, _Ch));
; 1050 : 		}
; 1051 : 
; 1052 : 	_Myt& append(const _Myt& _Right)
; 1053 : 		{	// append _Right
; 1054 : 		return (append(_Right, 0, npos));
; 1055 : 		}
; 1056 : 
; 1057 : 	_Myt& append(const _Myt& _Right,
; 1058 : 		size_type _Roff, size_type _Count = npos)
; 1059 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1060 : 		if (_Right.size() < _Roff)
; 1061 : 			_Xran();	// _Roff off end
; 1062 : 		size_type _Num = _Right.size() - _Roff;
; 1063 : 		if (_Num < _Count)
; 1064 : 			_Count = _Num;	// trim _Count to size
; 1065 : 		if (npos - this->_Mysize() <= _Count)
; 1066 : 			_Xlen();	// result too long
; 1067 : 
; 1068 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1069 : 			{	// make room and append new stuff
; 1070 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1071 : 				_Right._Myptr() + _Roff, _Count);
; 1072 : 			_Eos(_Num);
; 1073 : 			}
; 1074 : 		return (*this);
; 1075 : 		}
; 1076 : 
; 1077 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1078 : 		{	// append [_Ptr, _Ptr + _Count)
; 1079 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1080 : 		if (_Inside(_Ptr))
; 1081 : 			return (append(*this,
; 1082 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1083 : 		if (npos - this->_Mysize() <= _Count)
; 1084 : 			_Xlen();	// result too long
; 1085 : 
; 1086 : 		size_type _Num;
; 1087 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1088 : 			{	// make room and append new stuff
; 1089 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1090 : 			_Eos(_Num);
; 1091 : 			}
; 1092 : 		return (*this);
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& append(const _Elem *_Ptr)
; 1096 : 		{	// append [_Ptr, <null>)
; 1097 : 		_DEBUG_POINTER(_Ptr);
; 1098 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1099 : 		}
; 1100 : 
; 1101 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1102 : 		{	// append _Count * _Ch
; 1103 : 		if (npos - this->_Mysize() <= _Count)
; 1104 : 			_Xlen();	// result too long
; 1105 : 
; 1106 : 		size_type _Num;
; 1107 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1108 : 			{	// make room and append new stuff using assign
; 1109 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1110 : 			_Eos(_Num);
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	template<class _Iter>
; 1116 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1117 : 			_Myt&>::type
; 1118 : 		append(_Iter _First, _Iter _Last)
; 1119 : 		{	// append [_First, _Last), input iterators
; 1120 : 		return (replace(end(), end(), _First, _Last));
; 1121 : 		}
; 1122 : 
; 1123 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1124 : 		{	// append [_First, _Last), const pointers
; 1125 : 		return (replace(end(), end(), _First, _Last));
; 1126 : 		}
; 1127 : 
; 1128 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1129 : 		{	// append [_First, _Last), const_iterators
; 1130 : 		return (replace(end(), end(), _First, _Last));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Myt& assign(const _Myt& _Right)
; 1134 : 		{	// assign _Right
; 1135 : 		return (assign(_Right, 0, npos));
; 1136 : 		}
; 1137 : 
; 1138 : 	_Myt& assign(const _Myt& _Right,
; 1139 : 		size_type _Roff, size_type _Count = npos)
; 1140 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1141 : 		if (_Right.size() < _Roff)
; 1142 : 			_Xran();	// _Roff off end
; 1143 : 		size_type _Num = _Right.size() - _Roff;
; 1144 : 		if (_Count < _Num)
; 1145 : 			_Num = _Count;	// trim _Num to size
; 1146 : 
; 1147 : 		if (this == &_Right)
; 1148 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1149 : 		else if (_Grow(_Num))
; 1150 : 			{	// make room and assign new stuff
; 1151 : 			_Traits::copy(this->_Myptr(),
; 1152 : 				_Right._Myptr() + _Roff, _Num);
; 1153 : 			_Eos(_Num);
; 1154 : 			}
; 1155 : 		return (*this);
; 1156 : 		}
; 1157 : 
; 1158 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1159 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1160 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1161 : 		if (_Inside(_Ptr))
; 1162 : 			return (assign(*this,
; 1163 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1164 : 
; 1165 : 		if (_Grow(_Count))
; 1166 : 			{	// make room and assign new stuff
; 1167 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1168 : 			_Eos(_Count);
; 1169 : 			}
; 1170 : 		return (*this);
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const _Elem *_Ptr)
; 1174 : 		{	// assign [_Ptr, <null>)
; 1175 : 		_DEBUG_POINTER(_Ptr);
; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00022	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00026	72 07		 jb	 SHORT $LN106@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 689  : 	return (reinterpret_cast<_Ty *>(

  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1007 : 		}

  0002e	c3		 ret	 0
$LN106@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0002f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00032	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1007 : 		}

  00033	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 824  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2241 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00009	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1177 : 		}
; 1178 : 
; 1179 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1180 : 		{	// assign _Count * _Ch
; 1181 : 		if (_Count == npos)
; 1182 : 			_Xlen();	// result too long
; 1183 : 
; 1184 : 		if (_Grow(_Count))
; 1185 : 			{	// make room and assign new stuff
; 1186 : 			_Chassign(0, _Count, _Ch);
; 1187 : 			_Eos(_Count);
; 1188 : 			}
; 1189 : 		return (*this);
; 1190 : 		}
; 1191 : 
; 1192 : 	template<class _Iter>
; 1193 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1194 : 			_Myt&>::type
; 1195 : 		assign(_Iter _First, _Iter _Last)
; 1196 : 		{	// assign [_First, _Last), input iterators
; 1197 : 		return (replace(begin(), end(), _First, _Last));
; 1198 : 		}
; 1199 : 
; 1200 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1201 : 		{	// assign [_First, _Last), const pointers
; 1202 : 		return (replace(begin(), end(), _First, _Last));
; 1203 : 		}
; 1204 : 
; 1205 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1206 : 		{	// assign [_First, _Last), const_iterators
; 1207 : 		return (replace(begin(), end(), _First, _Last));
; 1208 : 		}
; 1209 : 
; 1210 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1211 : 		{	// insert _Right at _Off
; 1212 : 		return (insert(_Off, _Right, 0, npos));
; 1213 : 		}
; 1214 : 
; 1215 : 	_Myt& insert(size_type _Off,
; 1216 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1217 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1218 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1219 : 			_Xran();	// _Off or _Roff off end
; 1220 : 		size_type _Num = _Right.size() - _Roff;
; 1221 : 		if (_Num < _Count)
; 1222 : 			_Count = _Num;	// trim _Count to size
; 1223 : 		if (npos - this->_Mysize() <= _Count)
; 1224 : 			_Xlen();	// result too long
; 1225 : 
; 1226 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		if (this->_Mysize() < _Off)
; 1251 : 			_Xran();	// _Off off end
; 1252 : 		if (npos - this->_Mysize() <= _Count)
; 1253 : 			_Xlen();	// result too long
; 1254 : 		size_type _Num;
; 1255 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1256 : 			{	// make room and insert new stuff
; 1257 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1258 : 				this->_Myptr() + _Off,
; 1259 : 				this->_Mysize() - _Off);	// empty out hole
; 1260 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1261 : 			_Eos(_Num);
; 1262 : 			}
; 1263 : 		return (*this);
; 1264 : 		}
; 1265 : 
; 1266 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1267 : 		{	// insert [_Ptr, <null>) at _Off
; 1268 : 		_DEBUG_POINTER(_Ptr);
; 1269 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1270 : 		}
; 1271 : 
; 1272 : 	_Myt& insert(size_type _Off,
; 1273 : 		size_type _Count, _Elem _Ch)
; 1274 : 		{	// insert _Count * _Ch at _Off
; 1275 : 		if (this->_Mysize() < _Off)
; 1276 : 			_Xran();	// _Off off end
; 1277 : 		if (npos - this->_Mysize() <= _Count)
; 1278 : 			_Xlen();	// result too long
; 1279 : 		size_type _Num;
; 1280 : 		if (0 < _Count && _Grow(_Num = this->_Mysize() + _Count))
; 1281 : 			{	// make room and insert new stuff
; 1282 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1283 : 				this->_Myptr() + _Off,
; 1284 : 				this->_Mysize() - _Off);	// empty out hole
; 1285 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1286 : 			_Eos(_Num);
; 1287 : 			}
; 1288 : 		return (*this);
; 1289 : 		}
; 1290 : 
; 1291 : 	iterator insert(const_iterator _Where)
; 1292 : 		{	// insert <null> at _Where
; 1293 : 		return (insert(_Where, _Elem()));
; 1294 : 		}
; 1295 : 
; 1296 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1297 : 		{	// insert _Ch at _Where
; 1298 : 		size_type _Off = _Where - begin();
; 1299 : 		insert(_Off, 1, _Ch);
; 1300 : 		return (begin() + _Off);
; 1301 : 		}
; 1302 : 
; 1303 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1304 : 		{	// insert _Count * _Elem at _Where
; 1305 : 		size_type _Off = _Where - begin();
; 1306 : 		insert(_Off, _Count, _Ch);
; 1307 : 		return (begin() + _Off);
; 1308 : 		}
; 1309 : 
; 1310 : 	template<class _Iter>
; 1311 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1312 : 			iterator>::type
; 1313 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1314 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1315 : 		size_type _Off = _Where - begin();
; 1316 : 		replace(_Where, _Where, _First, _Last);
; 1317 : 		return (begin() + _Off);
; 1318 : 		}
; 1319 : 
; 1320 : 	iterator insert(const_iterator _Where,
; 1321 : 		const_pointer _First, const_pointer _Last)
; 1322 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1323 : 		size_type _Off = _Where - begin();
; 1324 : 		replace(_Where, _Where, _First, _Last);
; 1325 : 		return (begin() + _Off);
; 1326 : 		}
; 1327 : 
; 1328 : 	iterator insert(const_iterator _Where,
; 1329 : 		const_iterator _First, const_iterator _Last)
; 1330 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1331 : 		size_type _Off = _Where - begin();
; 1332 : 		replace(_Where, _Where, _First, _Last);
; 1333 : 		return (begin() + _Off);
; 1334 : 		}
; 1335 : 
; 1336 : 	_Myt& erase(size_type _Off = 0)
; 1337 : 		{	// erase elements [_Off, ...)
; 1338 : 		if (this->_Mysize() < _Off)
; 1339 : 			_Xran();	// _Off off end
; 1340 : 		_Eos(_Off);
; 1341 : 		return (*this);
; 1342 : 		}
; 1343 : 
; 1344 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1345 : 		{	// erase elements [_Off, _Off + _Count)
; 1346 : 		if (this->_Mysize() < _Off)
; 1347 : 			_Xran();	// _Off off end
; 1348 : 		if (this->_Mysize() - _Off <= _Count)
; 1349 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1350 : 		else if (0 < _Count)
; 1351 : 			{	// move elements down
; 1352 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1353 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1354 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1355 : 			_Eos(_Newsize);
; 1356 : 			}
; 1357 : 		return (*this);
; 1358 : 		}
; 1359 : 
; 1360 : 	iterator erase(const_iterator _Where)
; 1361 : 		{	// erase element at _Where
; 1362 : 		size_type _Count = _Where - begin();
; 1363 : 		erase(_Count, 1);
; 1364 : 		return (begin() + _Count);
; 1365 : 		}
; 1366 : 
; 1367 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1368 : 		{	// erase substring [_First, _Last)
; 1369 : 		_DEBUG_RANGE(_First, _Last);
; 1370 : 		size_type _Count = _First - begin();
; 1371 : 		erase(_Count, _Last - _First);
; 1372 : 		return (begin() + _Count);
; 1373 : 		}
; 1374 : 
; 1375 : 	void clear() _NOEXCEPT
; 1376 : 		{	// erase all
; 1377 : 		_Eos(0);
; 1378 : 		}
; 1379 : 
; 1380 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1381 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1382 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1383 : 		}
; 1384 : 
; 1385 : 	_Myt& replace(size_type _Off,
; 1386 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1387 : 			size_type _Count = npos)
; 1388 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1389 : 		if (this->_Mysize() < _Off || _Right.size() < _Roff)
; 1390 : 			_Xran();	// _Off or _Roff off end
; 1391 : 		if (this->_Mysize() - _Off < _N0)
; 1392 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1393 : 		size_type _Num = _Right.size() - _Roff;
; 1394 : 		if (_Num < _Count)
; 1395 : 			_Count = _Num;	// trim _Count to size
; 1396 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1397 : 			_Xlen();	// result too long
; 1398 : 
; 1399 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1400 : 		size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1401 : 		if (this->_Mysize() < _Newsize)
; 1402 : 			_Grow(_Newsize);
; 1403 : 
; 1404 : 		if (this != &_Right)
; 1405 : 			{	// no overlap, just move down and copy in new stuff
; 1406 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1407 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1408 : 			_Traits::copy(this->_Myptr() + _Off,
; 1409 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1410 : 			}
; 1411 : 		else if (_Count <= _N0)
; 1412 : 			{	// hole doesn't get larger, just copy in substring
; 1413 : 			_Traits::move(this->_Myptr() + _Off,
; 1414 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1415 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1416 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1417 : 			}
; 1418 : 		else if (_Roff <= _Off)
; 1419 : 			{	// hole gets larger, substring begins before hole
; 1420 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1421 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1422 : 			_Traits::move(this->_Myptr() + _Off,
; 1423 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1424 : 			}
; 1425 : 		else if (_Off + _N0 <= _Roff)
; 1426 : 			{	// hole gets larger, substring begins after hole
; 1427 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1428 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1429 : 			_Traits::move(this->_Myptr() + _Off,
; 1430 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1431 : 				_Count);	// fill hole
; 1432 : 			}
; 1433 : 		else
; 1434 : 			{	// hole gets larger, substring begins in hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off,
; 1436 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1438 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1439 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1440 : 				this->_Myptr() + _Roff + _Count,
; 1441 : 				_Count - _N0);	// fill rest of new hole
; 1442 : 			}
; 1443 : 
; 1444 : 		_Eos(_Newsize);
; 1445 : 		return (*this);
; 1446 : 		}
; 1447 : 
; 1448 : 	_Myt& replace(size_type _Off,
; 1449 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1450 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1451 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize() < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize() - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize() < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize() - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize() + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr, size_type _Count)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		const _Elem *_Ptr)
; 1529 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1531 : 		}
; 1532 : 
; 1533 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1534 : 		size_type _Count, _Elem _Ch)
; 1535 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1536 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1537 : 		}
; 1538 : 
; 1539 : 	template<class _Iter>
; 1540 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1541 : 			_Myt&>::type
; 1542 : 		replace(const_iterator _First, const_iterator _Last,
; 1543 : 			_Iter _First2, _Iter _Last2)
; 1544 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1545 : 		_Myt _Right(_First2, _Last2);
; 1546 : 		replace(_First, _Last, _Right);
; 1547 : 		return (*this);
; 1548 : 		}
; 1549 : 
; 1550 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1551 : 		const_pointer _First2, const_pointer _Last2)
; 1552 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1553 : 		if (_First2 == _Last2)
; 1554 : 			erase(_First - begin(), _Last - _First);
; 1555 : 		else
; 1556 : 			replace(_First - begin(), _Last - _First,
; 1557 : 				&*_First2, _Last2 - _First2);
; 1558 : 		return (*this);
; 1559 : 		}
; 1560 : 
; 1561 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1562 : 		pointer _First2, pointer _Last2)
; 1563 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1564 : 		if (_First2 == _Last2)
; 1565 : 			erase(_First - begin(), _Last - _First);
; 1566 : 		else
; 1567 : 			replace(_First - begin(), _Last - _First,
; 1568 : 				&*_First2, _Last2 - _First2);
; 1569 : 		return (*this);
; 1570 : 		}
; 1571 : 
; 1572 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1573 : 		const_iterator _First2, const_iterator _Last2)
; 1574 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1575 : 		if (_First2 == _Last2)
; 1576 : 			erase(_First - begin(), _Last - _First);
; 1577 : 		else
; 1578 : 			replace(_First - begin(), _Last - _First,
; 1579 : 				&*_First2, _Last2 - _First2);
; 1580 : 		return (*this);
; 1581 : 		}
; 1582 : 
; 1583 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1584 : 		iterator _First2, iterator _Last2)
; 1585 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1586 : 		if (_First2 == _Last2)
; 1587 : 			erase(_First - begin(), _Last - _First);
; 1588 : 		else
; 1589 : 			replace(_First - begin(), _Last - _First,
; 1590 : 				&*_First2, _Last2 - _First2);
; 1591 : 		return (*this);
; 1592 : 		}
; 1593 : 
; 1594 : 	iterator begin() _NOEXCEPT
; 1595 : 		{	// return iterator for beginning of mutable sequence
; 1596 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1597 : 		}
; 1598 : 
; 1599 : 	const_iterator begin() const _NOEXCEPT
; 1600 : 		{	// return iterator for beginning of nonmutable sequence
; 1601 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1602 : 		}
; 1603 : 
; 1604 : 	iterator end() _NOEXCEPT
; 1605 : 		{	// return iterator for end of mutable sequence
; 1606 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1607 : 		}
; 1608 : 
; 1609 : 	const_iterator end() const _NOEXCEPT
; 1610 : 		{	// return iterator for end of nonmutable sequence
; 1611 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1612 : 		}
; 1613 : 
; 1614 : 	reverse_iterator rbegin() _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of reversed mutable sequence
; 1616 : 		return (reverse_iterator(end()));
; 1617 : 		}
; 1618 : 
; 1619 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1620 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1621 : 		return (const_reverse_iterator(end()));
; 1622 : 		}
; 1623 : 
; 1624 : 	reverse_iterator rend() _NOEXCEPT
; 1625 : 		{	// return iterator for end of reversed mutable sequence
; 1626 : 		return (reverse_iterator(begin()));
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (const_reverse_iterator(begin()));
; 1632 : 		}
; 1633 : 
; 1634 : 	const_iterator cbegin() const _NOEXCEPT
; 1635 : 		{	// return iterator for beginning of nonmutable sequence
; 1636 : 		return (begin());
; 1637 : 		}
; 1638 : 
; 1639 : 	const_iterator cend() const _NOEXCEPT
; 1640 : 		{	// return iterator for end of nonmutable sequence
; 1641 : 		return (end());
; 1642 : 		}
; 1643 : 
; 1644 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1645 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1646 : 		return (rbegin());
; 1647 : 		}
; 1648 : 
; 1649 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1650 : 		{	// return iterator for end of reversed nonmutable sequence
; 1651 : 		return (rend());
; 1652 : 		}
; 1653 : 
; 1654 : 	void shrink_to_fit()
; 1655 : 		{	// reduce capacity
; 1656 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1657 : 			{	// worth shrinking, do it
; 1658 : 			_Myt _Tmp(*this);
; 1659 : 			swap(_Tmp);
; 1660 : 			}
; 1661 : 		}
; 1662 : 
; 1663 : 	reference at(size_type _Off)
; 1664 : 		{	// subscript mutable sequence with checking
; 1665 : 		if (this->_Mysize() <= _Off)
; 1666 : 			_Xran();	// _Off off end
; 1667 : 		return (this->_Myptr()[_Off]);
; 1668 : 		}
; 1669 : 
; 1670 : 	const_reference at(size_type _Off) const
; 1671 : 		{	// subscript nonmutable sequence with checking
; 1672 : 		if (this->_Mysize() <= _Off)
; 1673 : 			_Xran();	// _Off off end
; 1674 : 		return (this->_Myptr()[_Off]);
; 1675 : 		}
; 1676 : 
; 1677 : 	reference operator[](size_type _Off)
; 1678 : 		{	// subscript mutable sequence
; 1679 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1680 : 		if (this->_Mysize() < _Off)	// sic
; 1681 : 			_DEBUG_ERROR("string subscript out of range");
; 1682 : 
; 1683 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1684 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1685 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1686 : 
; 1687 : 		return (this->_Myptr()[_Off]);
; 1688 : 		}
; 1689 : 
; 1690 : 	const_reference operator[](size_type _Off) const
; 1691 : 		{	// subscript nonmutable sequence
; 1692 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1693 : 		if (this->_Mysize() < _Off)	// sic
; 1694 : 			_DEBUG_ERROR("string subscript out of range");
; 1695 : 
; 1696 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1697 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1698 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1699 : 
; 1700 : 		return (this->_Myptr()[_Off]);
; 1701 : 		}
; 1702 : 
; 1703 : 	void push_back(_Elem _Ch)
; 1704 : 		{	// insert element at end
; 1705 : 		insert(end(), _Ch);
; 1706 : 		}
; 1707 : 
; 1708 : 	void pop_back()
; 1709 : 		{	// erase element at end
; 1710 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1711 : 		}
; 1712 : 
; 1713 : 	reference front()
; 1714 : 		{	// return first element of mutable sequence
; 1715 : 		return (*begin());
; 1716 : 		}
; 1717 : 
; 1718 : 	const_reference front() const
; 1719 : 		{	// return first element of nonmutable sequence
; 1720 : 		return (*begin());
; 1721 : 		}
; 1722 : 
; 1723 : 	reference back()
; 1724 : 		{	// return last element of mutable sequence
; 1725 : 		return (*(end() - 1));
; 1726 : 		}
; 1727 : 
; 1728 : 	const_reference back() const
; 1729 : 		{	// return last element of nonmutable sequence
; 1730 : 		return (*(end() - 1));
; 1731 : 		}
; 1732 : 
; 1733 : 	const _Elem *c_str() const _NOEXCEPT
; 1734 : 		{	// return pointer to null-terminated nonmutable array
; 1735 : 		return (this->_Myptr());
; 1736 : 		}
; 1737 : 
; 1738 : 	const _Elem *data() const _NOEXCEPT
; 1739 : 		{	// return pointer to nonmutable array
; 1740 : 		return (c_str());
; 1741 : 		}
; 1742 : 
; 1743 : 	size_type length() const _NOEXCEPT
; 1744 : 		{	// return length of sequence
; 1745 : 		return (this->_Mysize());
; 1746 : 		}
; 1747 : 
; 1748 : 	size_type size() const _NOEXCEPT
; 1749 : 		{	// return length of sequence
; 1750 : 		return (this->_Mysize());
; 1751 : 		}
; 1752 : 
; 1753 : 	size_type max_size() const _NOEXCEPT
; 1754 : 		{	// return maximum possible length of sequence
; 1755 : 		size_type _Num = this->_Getal().max_size();
; 1756 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1757 : 		}
; 1758 : 
; 1759 : 	void resize(size_type _Newsize)
; 1760 : 		{	// determine new length, padding with null elements as needed
; 1761 : 		resize(_Newsize, _Elem());
; 1762 : 		}
; 1763 : 
; 1764 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1765 : 		{	// determine new length, padding with _Ch elements as needed
; 1766 : 		if (_Newsize <= this->_Mysize())
; 1767 : 			_Eos(_Newsize);
; 1768 : 		else
; 1769 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1770 : 		}
; 1771 : 
; 1772 : 	size_type capacity() const _NOEXCEPT
; 1773 : 		{	// return current length of allocated storage
; 1774 : 		return (this->_Myres());
; 1775 : 		}
; 1776 : 
; 1777 : 	void reserve(size_type _Newcap = 0)
; 1778 : 		{	// determine new minimum length of allocated storage
; 1779 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1780 : 			{	// change reservation
; 1781 : 			size_type _Size = this->_Mysize();
; 1782 : 			if (_Grow(_Newcap, true))
; 1783 : 				_Eos(_Size);
; 1784 : 			}
; 1785 : 		}
; 1786 : 
; 1787 : 	bool empty() const _NOEXCEPT
; 1788 : 		{	// test if sequence is empty
; 1789 : 		return (this->_Mysize() == 0);
; 1790 : 		}
; 1791 : 
; 1792 : 	_SCL_INSECURE_DEPRECATE
; 1793 : 
; 1794 : 	size_type copy(_Elem *_Ptr,
; 1795 : 		size_type _Count, size_type _Off = 0) const
; 1796 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1797 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1798 : 		if (this->_Mysize() < _Off)
; 1799 : 			_Xran();	// _Off off end
; 1800 : 		if (this->_Mysize() - _Off < _Count)
; 1801 : 			_Count = this->_Mysize() - _Off;
; 1802 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1807 : 		size_type _Count, size_type _Off = 0) const
; 1808 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1809 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1810 : 		if (this->_Mysize() < _Off)
; 1811 : 			_Xran();	// _Off off end
; 1812 : 		if (this->_Mysize() - _Off < _Count)
; 1813 : 			_Count = this->_Mysize() - _Off;
; 1814 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1815 : 		return (_Count);
; 1816 : 		}
; 1817 : 
; 1818 : 	void _Swap_bx(_Myt& _Right)
; 1819 : 		{	// exchange _Bx() with _Right._Bx()
; 1820 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1821 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1822 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1823 : 			else
; 1824 : 				{	// swap large with small
; 1825 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1826 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1827 : 				_Traits::copy(this->_Bx()._Buf,
; 1828 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1829 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1830 : 				}
; 1831 : 		else
; 1832 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1833 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1834 : 			else
; 1835 : 				{	// swap small with large
; 1836 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1837 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1838 : 				_Traits::copy(_Right._Bx()._Buf,
; 1839 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1840 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1841 : 				}
; 1842 : 		}
; 1843 : 
; 1844 : 	void swap(_Myt& _Right)
; 1845 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1846 : 			|| _Alty::is_always_equal::value)
; 1847 : 		{	// exchange contents with _Right
; 1848 : 		if (this == &_Right)
; 1849 : 			;	// same object, do nothing
; 1850 : 		else if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, swap control information
; 1852 : 			this->_Swap_all(_Right);
; 1853 : 			_Swap_bx(_Right);
; 1854 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1855 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1856 : 			}
; 1857 : 
; 1858 : 		else if (_Alty::propagate_on_container_swap::value)
; 1859 : 			{	// swap allocators and control information
; 1860 : 				// assumes pointer is bitwise copyable
; 1861 : 			this->_Swap_alloc(_Right);
; 1862 : 			_Swap_bx(_Right);
; 1863 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1864 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1865 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1866 : 			}
; 1867 : 
; 1868 : 		else
; 1869 : 			{	// different allocator, do multiple assigns
; 1870 : 			_Myt _Tmp = *this;
; 1871 : 
; 1872 : 			*this = _Right;
; 1873 : 			_Right = _Tmp;
; 1874 : 			}
; 1875 : 		}
; 1876 : 
; 1877 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1878 : 		{	// look for _Right beginning at or after _Off
; 1879 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1880 : 		}
; 1881 : 
; 1882 : 	size_type find(const _Elem *_Ptr,
; 1883 : 		size_type _Off, size_type _Count) const
; 1884 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1885 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1886 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1887 : 			return (_Off);	// null string always matches (if inside string)
; 1888 : 
; 1889 : 		size_type _Nm;
; 1890 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1891 : 			{	// room for match, look for it
; 1892 : 			const _Elem *_Uptr, *_Vptr;
; 1893 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1894 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1895 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1896 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1897 : 					return (_Uptr - this->_Myptr());	// found a match
; 1898 : 			}
; 1899 : 
; 1900 : 		return (npos);	// no match
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1904 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1905 : 		_DEBUG_POINTER(_Ptr);
; 1906 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1907 : 		}
; 1908 : 
; 1909 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1910 : 		{	// look for _Ch at or after _Off
; 1911 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1912 : 		}
; 1913 : 
; 1914 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1915 : 		{	// look for _Right beginning before _Off
; 1916 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1917 : 		}
; 1918 : 
; 1919 : 	size_type rfind(const _Elem *_Ptr,
; 1920 : 		size_type _Off, size_type _Count) const
; 1921 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1922 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1923 : 		if (_Count == 0)
; 1924 : 			return (_Off < this->_Mysize() ? _Off
; 1925 : 				: this->_Mysize());	// null always matches
; 1926 : 		if (_Count <= this->_Mysize())
; 1927 : 			{	// room for match, look for it
; 1928 : 			const _Elem *_Uptr = this->_Myptr() +
; 1929 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1930 : 					: this->_Mysize() - _Count);
; 1931 : 			for (; ; --_Uptr)
; 1932 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1933 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1934 : 					return (_Uptr - this->_Myptr());	// found a match
; 1935 : 				else if (_Uptr == this->_Myptr())
; 1936 : 					break;	// at beginning, no more chance for match
; 1937 : 			}
; 1938 : 
; 1939 : 		return (npos);	// no match
; 1940 : 		}
; 1941 : 
; 1942 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1943 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1944 : 		_DEBUG_POINTER(_Ptr);
; 1945 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1946 : 		}
; 1947 : 
; 1948 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1949 : 		{	// look for _Ch before _Off
; 1950 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1951 : 		}
; 1952 : 
; 1953 : 	size_type find_first_of(const _Myt& _Right,
; 1954 : 		size_type _Off = 0) const _NOEXCEPT
; 1955 : 		{	// look for one of _Right at or after _Off
; 1956 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type find_first_of(const _Elem *_Ptr,
; 1960 : 		size_type _Off, size_type _Count) const
; 1961 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1962 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1963 : 		if (0 < _Count && _Off < this->_Mysize())
; 1964 : 			{	// room for match, look for it
; 1965 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1966 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1967 : 				_Uptr < _Vptr; ++_Uptr)
; 1968 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1969 : 					return (_Uptr - this->_Myptr());	// found a match
; 1970 : 			}
; 1971 : 
; 1972 : 		return (npos);	// no match
; 1973 : 		}
; 1974 : 
; 1975 : 	size_type find_first_of(const _Elem *_Ptr,
; 1976 : 		size_type _Off = 0) const
; 1977 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1978 : 		_DEBUG_POINTER(_Ptr);
; 1979 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_first_of(_Elem _Ch,
; 1983 : 		size_type _Off = 0) const
; 1984 : 		{	// look for _Ch at or after _Off
; 1985 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1986 : 		}
; 1987 : 
; 1988 : 	size_type find_last_of(const _Myt& _Right,
; 1989 : 		size_type _Off = npos) const _NOEXCEPT
; 1990 : 		{	// look for one of _Right before _Off
; 1991 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1992 : 		}
; 1993 : 
; 1994 : 	size_type find_last_of(const _Elem *_Ptr,
; 1995 : 		size_type _Off, size_type _Count) const
; 1996 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1997 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1998 : 		if (0 < _Count && 0 < this->_Mysize())
; 1999 : 			{	// worth searching, do it
; 2000 : 			const _Elem *_Uptr = this->_Myptr()
; 2001 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2002 : 			for (; ; --_Uptr)
; 2003 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2004 : 					return (_Uptr - this->_Myptr());	// found a match
; 2005 : 				else if (_Uptr == this->_Myptr())
; 2006 : 					break;	// at beginning, no more chance for match
; 2007 : 			}
; 2008 : 
; 2009 : 		return (npos);	// no match
; 2010 : 		}
; 2011 : 
; 2012 : 	size_type find_last_of(const _Elem *_Ptr,
; 2013 : 		size_type _Off = npos) const
; 2014 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2015 : 		_DEBUG_POINTER(_Ptr);
; 2016 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2017 : 		}
; 2018 : 
; 2019 : 	size_type find_last_of(_Elem _Ch,
; 2020 : 		size_type _Off = npos) const
; 2021 : 		{	// look for _Ch before _Off
; 2022 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_first_not_of(const _Myt& _Right,
; 2026 : 		size_type _Off = 0) const _NOEXCEPT
; 2027 : 		{	// look for none of _Right at or after _Off
; 2028 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2029 : 			_Right.size()));
; 2030 : 		}
; 2031 : 
; 2032 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2033 : 		size_type _Off, size_type _Count) const
; 2034 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2035 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2036 : 		if (_Off < this->_Mysize())
; 2037 : 			{	// room for match, look for it
; 2038 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2039 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2040 : 				_Uptr < _Vptr; ++_Uptr)
; 2041 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2042 : 					return (_Uptr - this->_Myptr());
; 2043 : 			}
; 2044 : 		return (npos);
; 2045 : 		}
; 2046 : 
; 2047 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2048 : 		size_type _Off = 0) const
; 2049 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2050 : 		_DEBUG_POINTER(_Ptr);
; 2051 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_first_not_of(_Elem _Ch,
; 2055 : 		size_type _Off = 0) const
; 2056 : 		{	// look for non _Ch at or after _Off
; 2057 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2058 : 		}
; 2059 : 
; 2060 : 	size_type find_last_not_of(const _Myt& _Right,
; 2061 : 		size_type _Off = npos) const _NOEXCEPT
; 2062 : 		{	// look for none of _Right before _Off
; 2063 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2064 : 		}
; 2065 : 
; 2066 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2067 : 		size_type _Off, size_type _Count) const
; 2068 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2069 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2070 : 		if (0 < this->_Mysize())
; 2071 : 			{	// worth searching, do it
; 2072 : 			const _Elem *_Uptr = this->_Myptr()
; 2073 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2074 : 			for (; ; --_Uptr)
; 2075 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2076 : 					return (_Uptr - this->_Myptr());
; 2077 : 				else if (_Uptr == this->_Myptr())
; 2078 : 					break;
; 2079 : 			}
; 2080 : 		return (npos);
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2084 : 		size_type _Off = npos) const
; 2085 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2086 : 		_DEBUG_POINTER(_Ptr);
; 2087 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2088 : 		}
; 2089 : 
; 2090 : 	size_type find_last_not_of(_Elem _Ch,
; 2091 : 		size_type _Off = npos) const
; 2092 : 		{	// look for non _Ch before _Off
; 2093 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2094 : 		}
; 2095 : 
; 2096 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2097 : 		{	// return [_Off, _Off + _Count) as new string
; 2098 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2099 : 		}
; 2100 : 
; 2101 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2102 : 		{	// compare [0, _Mysize()) with _Right
; 2103 : 		return (compare(0, this->_Mysize(), _Right._Myptr(), _Right.size()));
; 2104 : 		}
; 2105 : 
; 2106 : 	int compare(size_type _Off, size_type _N0,
; 2107 : 		const _Myt& _Right) const
; 2108 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2109 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2110 : 		}
; 2111 : 
; 2112 : 	int compare(size_type _Off,
; 2113 : 		size_type _N0, const _Myt& _Right,
; 2114 : 		size_type _Roff, size_type _Count = npos) const
; 2115 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2116 : 		if (_Right.size() < _Roff)
; 2117 : 			_Xran();	// _Off off end
; 2118 : 		if (_Right._Mysize() - _Roff < _Count)
; 2119 : 			_Count = _Right._Mysize() - _Roff;	// trim _Count to size
; 2120 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2121 : 		}
; 2122 : 
; 2123 : 	int compare(const _Elem *_Ptr) const
; 2124 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2125 : 		_DEBUG_POINTER(_Ptr);
; 2126 : 		return (compare(0, this->_Mysize(), _Ptr, _Traits::length(_Ptr)));
; 2127 : 		}
; 2128 : 
; 2129 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2130 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2131 : 		_DEBUG_POINTER(_Ptr);
; 2132 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2133 : 		}
; 2134 : 
; 2135 : 	int compare(size_type _Off,
; 2136 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2137 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2138 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2139 : 		if (this->_Mysize() < _Off)
; 2140 : 			_Xran();	// _Off off end
; 2141 : 		if (this->_Mysize() - _Off < _N0)
; 2142 : 			_N0 = this->_Mysize() - _Off;	// trim _N0 to size
; 2143 : 
; 2144 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2145 : 			_N0 < _Count ? _N0 : _Count);
; 2146 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2147 : 			: _N0 == _Count ? 0 : +1);
; 2148 : 		}
; 2149 : 
; 2150 : 	allocator_type get_allocator() const _NOEXCEPT
; 2151 : 		{	// return allocator object for values
; 2152 : 		return (this->_Getal());
; 2153 : 		}
; 2154 : 
; 2155 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2156 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2157 : 		if (_Count == 1)
; 2158 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2159 : 		else
; 2160 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2161 : 		}
; 2162 : 
; 2163 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2164 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2165 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2166 : 		if (max_size() < _Newres)
; 2167 : 			_Newres = _Newsize;	// undo roundup if too big
; 2168 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2169 : 			;
; 2170 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2171 : 			_Newres = this->_Myres()
; 2172 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2173 : 		else
; 2174 : 			_Newres = max_size();	// settle for max_size()
; 2175 : 
; 2176 : 		_Elem *_Ptr;
; 2177 : 		_TRY_BEGIN
; 2178 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2179 : 		_CATCH_ALL
; 2180 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2181 : 			_TRY_BEGIN
; 2182 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2183 : 			_CATCH_ALL
; 2184 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2185 : 			_RERAISE;
; 2186 : 			_CATCH_END
; 2187 : 		_CATCH_END
; 2188 : 
; 2189 : 		if (0 < _Oldlen)
; 2190 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2191 : 				_Oldlen);	// copy existing elements
; 2192 : 		_Tidy(true);
; 2193 : 		this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 2194 : 		this->_Myres() = _Newres;
; 2195 : 		_Eos(_Oldlen);
; 2196 : 		}
; 2197 : 
; 2198 : 	void _Eos(size_type _Newsize)
; 2199 : 		{	// set new length and null terminator
; 2200 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00010	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00017	c6 06 00	 mov	 BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

  0001a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0001d	75 12		 jne	 SHORT $LN133@basic_stri
  0001f	33 d2		 xor	 edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00021	52		 push	 edx
  00022	51		 push	 ecx
  00023	8b ce		 mov	 ecx, esi
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN133@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

  00031	8b d1		 mov	 edx, ecx
  00033	57		 push	 edi
  00034	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
$LL135@basic_stri:
  00037	8a 02		 mov	 al, BYTE PTR [edx]
  00039	42		 inc	 edx
  0003a	84 c0		 test	 al, al
  0003c	75 f9		 jne	 SHORT $LL135@basic_stri
  0003e	2b d7		 sub	 edx, edi
  00040	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 825  : 		_Tidy();
; 826  : 		assign(_Ptr);
; 827  : 		}

  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 320  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 315  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 300  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 295  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 722  : 		return (_Get_data()._Myres);

  00000	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]

; 723  : 		}

  00003	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 717  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 718  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 712  : 		return (_Get_data()._Mysize);

  00000	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]

; 713  : 		}

  00003	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 702  : 		return (_Get_data()._Bx);

  00000	8b c1		 mov	 eax, ecx

; 703  : 		}

  00002	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 695  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 696  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 690  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 691  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 685  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 686  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 680  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 681  : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 488  : 		_Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 573  : 		}

  00007	8b c1		 mov	 eax, ecx

; 489  : 		_Myres = 0;

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 573  : 		}

  00010	c2 04 00	 ret	 4
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr

; 566  : 		return (_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 567  : 		}

  00008	c3		 ret	 0
$LN11@Myptr:

; 566  : 		return (_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 567  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN11@Myptr

; 561  : 		return (_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 562  : 		}

  00008	c3		 ret	 0
$LN11@Myptr:

; 561  : 		return (_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 562  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 512  : 		return (this->_BUF_SIZE <= this->_Myres

  00009	8b c1		 mov	 eax, ecx

; 513  : 			? _STD addressof(*this->_Bx._Ptr)
; 514  : 			: this->_Bx._Buf);
; 515  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00004	72 03		 jb	 SHORT $LN3@Myptr
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}

  00008	c3		 ret	 0
$LN3@Myptr:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00009	8b c1		 mov	 eax, ecx

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 487  : 		{	// initialize values
; 488  : 		_Mysize = 0;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 489  : 		_Myres = 0;
; 490  : 		}

  00007	8b c1		 mov	 eax, ecx
  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 930  : 		return (_Mytraits::max_size(*this));

  00000	83 c8 ff	 or	 eax, -1

; 931  : 		}

  00003	c2 04 00	 ret	 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 908  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]

; 139  : 	}
; 140  : 
; 141  : 		// TEMPLATE FUNCTION _Construct
; 142  : template<class _Ty1,
; 143  : 	class _Ty2> inline
; 144  : 	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
; 145  : 	{	// construct object at _Ptr with value _Val
; 146  : 	void *_Vptr = _Ptr;
; 147  : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));
; 148  : 	}
; 149  : 
; 150  : template<class _Ty1> inline
; 151  : 	void _Construct(_Ty1 *_Ptr)
; 152  : 	{	// construct object at _Ptr with default value
; 153  : 	void *_Vptr = _Ptr;
; 154  : 
; 155  : 	::new (_Vptr) _Ty1();
; 156  : 	}
; 157  : 
; 158  : 		// TEMPLATE FUNCTION _Destroy
; 159  : template<class _Ty> inline
; 160  : 	void _Destroy(_Ty *_Ptr)
; 161  : 	{	// destroy object at _Ptr
; 162  : 	_Ptr->~_Ty();
; 163  : 	}
; 164  : 
; 165  : 		// TEMPLATE FUNCTION _Destroy_range
; 166  : template<class _Alloc> inline
; 167  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 168  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 169  : 		_Nonscalar_ptr_iterator_tag)
; 170  : 	{	// destroy [_First, _Last), arbitrary type
; 171  : 	for (; _First != _Last; ++_First)
; 172  : 		_Al.destroy(_STD addressof(*_First));
; 173  : 	}
; 174  : 
; 175  : template<class _Alloc> inline
; 176  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 177  : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 178  : 		_Scalar_ptr_iterator_tag)
; 179  : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 180  : 	}
; 181  : 
; 182  : template<class _Alloc> inline
; 183  : 	void _Destroy_range(typename _Alloc::pointer _First,
; 184  : 		typename _Alloc::pointer _Last, _Alloc& _Al)
; 185  : 	{	// destroy [_First, _Last)
; 186  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 187  : 	}
; 188  : 
; 189  : 		// TEMPLATE CLASS _Is_simple_alloc
; 190  : template<class _Alty>
; 191  : 	struct _Is_simple_alloc
; 192  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 193  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 194  : 		&& is_same<typename _Alty::pointer,
; 195  : 			typename _Alty::value_type *>::value
; 196  : 		&& is_same<typename _Alty::const_pointer,
; 197  : 			const typename _Alty::value_type *>::value
; 198  : 		&& is_same<typename _Alty::reference,
; 199  : 			typename _Alty::value_type&>::value
; 200  : 		&& is_same<typename _Alty::const_reference,
; 201  : 			const typename _Alty::value_type&>::value>
; 202  : 	{	// tests if allocator has simple addressing
; 203  : 	};
; 204  : 
; 205  : 		// TEMPLATE CLASS _Simple_types
; 206  : template<class _Value_type>
; 207  : 	struct _Simple_types
; 208  : 	{	// wraps types needed by iterators
; 209  : 	typedef _Value_type value_type;
; 210  : 	typedef size_t size_type;
; 211  : 	typedef ptrdiff_t difference_type;
; 212  : 	typedef value_type *pointer;
; 213  : 	typedef const value_type *const_pointer;
; 214  : 	typedef value_type& reference;
; 215  : 	typedef const value_type& const_reference;
; 216  : 	};
; 217  : 
; 218  : 		// TEMPLATE CLASS _Get_voidptr
; 219  : template<class _Alty,
; 220  : 	class _Pointer>
; 221  : 	struct _Get_voidptr
; 222  : 	{	// get void pointer for allocator
; 223  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 224  : 	typedef typename _Alvoid::pointer type;
; 225  : 	};
; 226  : 
; 227  : template<class _Alty,
; 228  : 	class _Ty>
; 229  : 	struct _Get_voidptr<_Alty, _Ty *>
; 230  : 	{	// get raw void pointer for allocator
; 231  : 	typedef void *type;
; 232  : 	};
; 233  : 
; 234  : 		// TEMPLATE STRUCT _Get_first_parameter
; 235  : template<class _Ty>
; 236  : 	struct _Get_first_parameter;
; 237  : 
; 238  : template<template<class, class...> class _Ty,
; 239  : 	class _First,
; 240  : 	class... _Rest>
; 241  : 	struct _Get_first_parameter<_Ty<_First, _Rest...> >
; 242  : 	{	// given _Ty<_First, _Rest...>, extract _First
; 243  : 	typedef _First type;
; 244  : 	};
; 245  : 
; 246  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 247  : template<class _Newfirst,
; 248  : 	class _Ty>
; 249  : 	struct _Replace_first_parameter;
; 250  : 
; 251  : template<class _Newfirst,
; 252  : 	template<class, class...> class _Ty,
; 253  : 	class _First,
; 254  : 	class... _Rest>
; 255  : 	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
; 256  : 	{	// given _Ty<_First, _Rest...>, replace _First
; 257  : 	typedef _Ty<_Newfirst, _Rest...> type;
; 258  : 	};
; 259  : 
; 260  : 		// TEMPLATE STRUCT _Get_element_type
; 261  : template<class _Ty>
; 262  : 	struct _Get_element_type
; 263  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 264  : 		typename _Get_first_parameter<_Uty>::type);
; 265  : 
; 266  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 267  : template<class _Ty>
; 268  : 	struct _Get_ptr_difference_type
; 269  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 270  : 		ptrdiff_t);
; 271  : 
; 272  : 		// TEMPLATE STRUCT _Get_rebind_type
; 273  : template<class _Ty,
; 274  : 	class _Other>
; 275  : 	struct _Get_rebind_type
; 276  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 277  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 278  : 
; 279  : 		// TEMPLATE CLASS pointer_traits
; 280  : template<class _Ty>
; 281  : 	struct pointer_traits
; 282  : 	{	// defines traits for arbitrary pointers
; 283  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 284  : 	typedef _Ty pointer;
; 285  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 286  : 
; 287  : 	template<class _Other>
; 288  : 		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;
; 289  : 
; 290  : 	typedef typename _If<is_void<element_type>::value,
; 291  : 		char&,
; 292  : 		typename add_lvalue_reference<element_type>::type>::type _Reftype;
; 293  : 
; 294  : 	static pointer pointer_to(_Reftype _Val)
; 295  : 		{	// convert raw reference to pointer
; 296  : 		return (_Ty::pointer_to(_Val));
; 297  : 		}
; 298  : 	};
; 299  : 
; 300  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 301  : template<class _Ty>
; 302  : 	struct pointer_traits<_Ty *>
; 303  : 	{	// defines traits for raw pointers
; 304  : 	typedef _Ty element_type;
; 305  : 	typedef _Ty *pointer;
; 306  : 	typedef ptrdiff_t difference_type;
; 307  : 
; 308  : 	template<class _Other>
; 309  : 		using rebind = _Other *;
; 310  : 
; 311  : 	typedef typename _If<is_void<_Ty>::value,
; 312  : 		char&,
; 313  : 		typename add_lvalue_reference<_Ty>::type>::type _Reftype;
; 314  : 
; 315  : 	static pointer pointer_to(_Reftype _Val)
; 316  : 		{	// convert raw reference to pointer
; 317  : 		return (_STD addressof(_Val));
; 318  : 		}
; 319  : 	};
; 320  : 
; 321  : 		// TEMPLATE STRUCT _Get_pointer_type
; 322  : template<class _Ty>
; 323  : 	struct _Get_pointer_type
; 324  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 325  : 		typename _Ty::value_type *);
; 326  : 
; 327  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 328  : template<class _Ty>
; 329  : 	struct _Get_const_pointer_type
; 330  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 331  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 332  : 			::template rebind<const typename _Ty::value_type>);
; 333  : 
; 334  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 335  : template<class _Ty>
; 336  : 	struct _Get_void_pointer_type
; 337  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 338  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 339  : 			::template rebind<void>);
; 340  : 
; 341  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 342  : template<class _Ty>
; 343  : 	struct _Get_const_void_pointer_type
; 344  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 345  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 346  : 			::template rebind<const void>);
; 347  : 
; 348  : 		// TEMPLATE STRUCT _Get_difference_type
; 349  : template<class _Ty>
; 350  : 	struct _Get_difference_type
; 351  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 352  : 		typename _Get_ptr_difference_type<
; 353  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 354  : 
; 355  : 		// TEMPLATE STRUCT _Get_size_type
; 356  : template<class _Ty>
; 357  : 	struct _Get_size_type
; 358  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 359  : 		typename make_unsigned<
; 360  : 			typename _Get_difference_type<_Ty>::type>::type);
; 361  : 
; 362  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 363  : template<class _Ty>
; 364  : 	struct _Get_propagate_on_container_copy
; 365  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 366  : 		false_type);
; 367  : 
; 368  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 369  : template<class _Ty>
; 370  : 	struct _Get_propagate_on_container_move
; 371  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 372  : 		false_type);
; 373  : 
; 374  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 375  : template<class _Ty>
; 376  : 	struct _Get_propagate_on_container_swap
; 377  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 378  : 		false_type);
; 379  : 
; 380  : 		// TEMPLATE STRUCT _Get_is_always_equal
; 381  : template<class _Ty>
; 382  : 	struct _Get_is_always_equal
; 383  : 	_GET_TYPE_OR_DEFAULT(is_always_equal,
; 384  : 		typename is_empty<_Ty>::type);
; 385  : 
; 386  : 		// STRUCT _Alloc_allocate
; 387  : struct _Alloc_allocate
; 388  : 	{	// determines allocator_traits<_Alloc>
; 389  : 		// ::allocate(size_type, const_void_pointer)
; 390  : 
; 391  : 	template<class _Alloc,
; 392  : 		class _Size_type,
; 393  : 		class _Const_void_pointer>
; 394  : 		static auto _Fn(int, _Alloc& _Al,
; 395  : 			_Size_type _Count,
; 396  : 			_Const_void_pointer _Hint)
; 397  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 398  : 		{	// call allocator supplied version
; 399  : 		return (_Al.allocate(_Count, _Hint));
; 400  : 		}
; 401  : 
; 402  : 	template<class _Alloc,
; 403  : 		class _Size_type,
; 404  : 		class _Const_void_pointer>
; 405  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 406  : 			_Size_type _Count,
; 407  : 			_Const_void_pointer)
; 408  : 			-> decltype(_Al.allocate(_Count))
; 409  : 		{	// call default version
; 410  : 		return (_Al.allocate(_Count));
; 411  : 		}
; 412  : 	};
; 413  : 
; 414  : 		// STRUCT _Alloc_construct
; 415  : struct _Alloc_construct
; 416  : 	{	// determines allocator_traits<_Ty>
; 417  : 		// ::construct(_Ty&, _Objty *, _Types&&...)
; 418  : 
; 419  : 	template<class _Ty,
; 420  : 		class _Objty,
; 421  : 		class... _Types>
; 422  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
; 423  : 			_Types&&... _Args)
; 424  : 			-> void_t<decltype(
; 425  : 				_Al.construct(_Ptr, _STD forward<_Types>(_Args)...))>
; 426  : 		{	// call allocator supplied version
; 427  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 428  : 		}
; 429  : 
; 430  : 	template<class _Ty,
; 431  : 		class _Objty,
; 432  : 		class... _Types>
; 433  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
; 434  : 			_Types&&... _Args)
; 435  : 		{	// call default version
; 436  : 		::new (static_cast<void *>(_Ptr))
; 437  : 			_Objty(_STD forward<_Types>(_Args)...);
; 438  : 		}
; 439  : 
; 440  : 	};
; 441  : 
; 442  : 		// STRUCT _Alloc_destroy
; 443  : struct _Alloc_destroy
; 444  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 445  : 	template<class _Ty,
; 446  : 		class _Objty>
; 447  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 448  : 			-> void_t<decltype(_Al.destroy(_Ptr))>
; 449  : 		{	// call allocator supplied version
; 450  : 		_Al.destroy(_Ptr);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty,
; 454  : 		class _Objty>
; 455  : 		static void _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 456  : 		{	// call default version
; 457  : 		_Ptr->~_Objty();
; 458  : 		}
; 459  : 	};
; 460  : 
; 461  : 		// STRUCT _Alloc_max_size
; 462  : struct _Alloc_max_size
; 463  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 464  : 	template<class _Ty>
; 465  : 		static auto _Fn(int, const _Ty& _Al) _NOEXCEPT
; 466  : 			-> decltype(_Al.max_size())
; 467  : 		{	// call allocator supplied version
; 468  : 		return (_Al.max_size());
; 469  : 		}
; 470  : 
; 471  : 	template<class _Ty>
; 472  : 		static auto _Fn(_Wrap_int, const _Ty&) _NOEXCEPT
; 473  : 			-> typename _Get_size_type<_Ty>::type
; 474  : 		{	// call default version
; 475  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 476  : 		}
; 477  : 	};
; 478  : 
; 479  : 		// STRUCT _Alloc_select
; 480  : struct _Alloc_select
; 481  : 	{	// determines allocator_traits<_Ty>
; 482  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 483  : 
; 484  : 	template<class _Ty>
; 485  : 		static auto _Fn(int, const _Ty& _Al)
; 486  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 487  : 		{	// call allocator supplied version
; 488  : 		return (_Al.select_on_container_copy_construction());
; 489  : 		}
; 490  : 
; 491  : 	template<class _Ty>
; 492  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 493  : 			-> _Ty
; 494  : 		{	// call default version
; 495  : 		return (_Al);
; 496  : 		}
; 497  : 	};
; 498  : 
; 499  : 		// TEMPLATE CLASS allocator_traits
; 500  : template<class _Alloc>
; 501  : 	struct allocator_traits
; 502  : 	{	// defines traits for allocators
; 503  : 	typedef _Alloc allocator_type;
; 504  : 	typedef typename _Alloc::value_type value_type;
; 505  : 
; 506  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 507  : 		pointer;
; 508  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 509  : 		const_pointer;
; 510  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 511  : 		void_pointer;
; 512  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 513  : 		const_void_pointer;
; 514  : 
; 515  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 516  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 517  : 
; 518  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 519  : 		propagate_on_container_copy_assignment;
; 520  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 521  : 		propagate_on_container_move_assignment;
; 522  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 523  : 		propagate_on_container_swap;
; 524  : 	typedef typename _Get_is_always_equal<_Alloc>::type
; 525  : 		is_always_equal;
; 526  : 
; 527  : 	template<class _Other>
; 528  : 		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;
; 529  : 
; 530  : 	template<class _Other>
; 531  : 		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;
; 532  : 
; 533  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count)
; 534  : 		{	// allocate array of _Count elements
; 535  : 		return (_Al.allocate(_Count));
; 536  : 		}
; 537  : 
; 538  : 	static _DECLSPEC_ALLOCATOR pointer allocate(_Alloc& _Al, size_type _Count,
; 539  : 		const_void_pointer _Hint)
; 540  : 		{	// allocate array of _Count elements, with hint
; 541  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 542  : 		}
; 543  : 
; 544  : 	static void deallocate(_Alloc& _Al,
; 545  : 		pointer _Ptr, size_type _Count)
; 546  : 		{	// deallocate _Count elements at _Ptr
; 547  : 		_Al.deallocate(_Ptr, _Count);
; 548  : 		}
; 549  : 
; 550  : 	template<class _Ty,
; 551  : 		class... _Types>
; 552  : 		static void construct(_Alloc& _Al, _Ty *_Ptr,
; 553  : 			_Types&&... _Args)
; 554  : 		{	// construct _Ty(_Types...) at _Ptr
; 555  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 556  : 			_STD forward<_Types>(_Args)...);
; 557  : 		}
; 558  : 
; 559  : 
; 560  : 	template<class _Ty>
; 561  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 562  : 		{	// destroy object at _Ptr
; 563  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 564  : 		}
; 565  : 
; 566  : 	static size_type max_size(const _Alloc& _Al) _NOEXCEPT
; 567  : 		{	// get maximum size
; 568  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 569  : 		}
; 570  : 
; 571  : 	static _Alloc select_on_container_copy_construction(
; 572  : 		const _Alloc& _Al)
; 573  : 		{	// get allocator to use
; 574  : 		return (_Alloc_select::_Fn(0, _Al));
; 575  : 		}
; 576  : 	};
; 577  : 
; 578  : 		// TEMPLATE CLASS allocator
; 579  : template<class _Ty>
; 580  : 	class allocator
; 581  : 	{	// generic allocator for objects of class _Ty
; 582  : public:
; 583  : 	static_assert(!is_const<_Ty>::value,
; 584  : 		"The C++ Standard forbids containers of const elements "
; 585  : 		"because allocator<const T> is ill-formed.");
; 586  : 
; 587  : 	typedef _Ty value_type;
; 588  : 
; 589  : 	typedef value_type *pointer;
; 590  : 	typedef const value_type *const_pointer;
; 591  : 
; 592  : 	typedef value_type& reference;
; 593  : 	typedef const value_type& const_reference;
; 594  : 
; 595  : 	typedef size_t size_type;
; 596  : 	typedef ptrdiff_t difference_type;
; 597  : 
; 598  : 	typedef true_type propagate_on_container_move_assignment;
; 599  : 	typedef true_type is_always_equal;
; 600  : 
; 601  : 	template<class _Other>
; 602  : 		struct rebind
; 603  : 		{	// convert this type to allocator<_Other>
; 604  : 		typedef allocator<_Other> other;
; 605  : 		};
; 606  : 
; 607  : 	pointer address(reference _Val) const _NOEXCEPT
; 608  : 		{	// return address of mutable _Val
; 609  : 		return (_STD addressof(_Val));
; 610  : 		}
; 611  : 
; 612  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 613  : 		{	// return address of nonmutable _Val
; 614  : 		return (_STD addressof(_Val));
; 615  : 		}
; 616  : 
; 617  : 	allocator() _THROW0()
; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}
; 620  : 
; 621  : 	allocator(const allocator<_Ty>&) _THROW0()
; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}
; 624  : 
; 625  : 	template<class _Other>
; 626  : 		allocator(const allocator<_Other>&) _THROW0()
; 627  : 		{	// construct from a related allocator (do nothing)
; 628  : 		}
; 629  : 
; 630  : 	template<class _Other>
; 631  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 632  : 		{	// assign from a related allocator (do nothing)
; 633  : 		return (*this);
; 634  : 		}
; 635  : 
; 636  : 	void deallocate(pointer _Ptr, size_type _Count)
; 637  : 		{	// deallocate object at _Ptr
; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	83 f9 ff	 cmp	 ecx, -1
  0000c	77 2e		 ja	 SHORT $LN16@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;
; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 19		 jb	 SHORT $LN7@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00016	a8 1f		 test	 al, 31			; 0000001fH
  00018	75 27		 jne	 SHORT $LN18@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001a	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0001d	3b c8		 cmp	 ecx, eax
  0001f	73 25		 jae	 SHORT $LN19@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00021	2b c1		 sub	 eax, ecx
  00023	83 f8 04	 cmp	 eax, 4
  00026	72 23		 jb	 SHORT $LN20@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00028	83 f8 23	 cmp	 eax, 35			; 00000023H
  0002b	77 23		 ja	 SHORT $LN21@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002d	8b c1		 mov	 eax, ecx
$LN7@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4

; 909  : 		_Mybase::deallocate(_Ptr, _Count);
; 910  : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN16@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  0003c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN19@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@deallocate:
$LN20@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN25@deallocate:
$LN21@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@deallocate:
$LN15@deallocate:
  00055	cc		 int	 3
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 897  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 899  : 		}

  00003	5d		 pop	 ebp

; 898  : 		return (_Mybase::allocate(_Count));

  00004	e9 00 00 00 00	 jmp	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 858  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 785  : 		return (_Al.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 786  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 667  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	83 c8 ff	 or	 eax, -1

; 668  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 642  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	if (_Count == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN4@allocate
$LN12@allocate:

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
$LN4@allocate:

; 58   : 		return (_Ptr);
; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 f8 ff	 cmp	 eax, -1
  00011	77 39		 ja	 SHORT $LN14@allocate

; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00013	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00018	72 23		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0001a	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 72   : 		if (_Block_size <= _User_size)

  0001d	3b c8		 cmp	 ecx, eax
  0001f	76 30		 jbe	 SHORT $LN16@allocate

; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00027	8b c8		 mov	 ecx, eax
  00029	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  0002c	85 c9		 test	 ecx, ecx
  0002e	74 26		 je	 SHORT $LN17@allocate

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00033	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00036	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 643  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 644  : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN6@allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00043	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00046	85 c0		 test	 eax, eax
  00048	75 c0		 jne	 SHORT $LN12@allocate
  0004a	eb 0f		 jmp	 SHORT $LN18@allocate
$LN14@allocate:

; 62   : 		_Xbad_alloc();	// report no memory

  0004c	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 73   : 			_Xbad_alloc();	// report no memory

  00051	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00056	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
  00060	cc		 int	 3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 637  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]

; 638  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00009	83 f9 ff	 cmp	 ecx, -1
  0000c	77 2e		 ja	 SHORT $LN13@deallocate

; 101  : 	const size_t _User_size = _Count * _Sz;
; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 19		 jb	 SHORT $LN5@deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00016	a8 1f		 test	 al, 31			; 0000001fH
  00018	75 27		 jne	 SHORT $LN15@deallocate

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0001a	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  0001d	3b c8		 cmp	 ecx, eax
  0001f	73 25		 jae	 SHORT $LN16@deallocate

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00021	2b c1		 sub	 eax, ecx
  00023	83 f8 04	 cmp	 eax, 4
  00026	72 23		 jb	 SHORT $LN17@deallocate

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00028	83 f8 23	 cmp	 eax, 35			; 00000023H
  0002b	77 23		 ja	 SHORT $LN18@deallocate

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002d	8b c1		 mov	 eax, ecx
$LN5@deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00035	83 c4 04	 add	 esp, 4

; 639  : 		}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN13@deallocate:

; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  0003c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN15@deallocate:

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN16@deallocate:

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN17@deallocate:

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN22@deallocate:
$LN18@deallocate:

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN23@deallocate:
$LN12@deallocate:
  00055	cc		 int	 3
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 622  : 		{	// construct by copying (do nothing)
; 623  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 618  : 		{	// construct default allocator (do nothing)
; 619  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 98   : 	{	// deallocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 99   :  #if defined(_M_IX86) || defined(_M_X64)
; 100  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  00003	83 c8 ff	 or	 eax, -1
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	f7 75 10	 div	 DWORD PTR __Sz$[ebp]
  0000e	3b c8		 cmp	 ecx, eax
  00010	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn

; 101  : 	const size_t _User_size = _Count * _Sz;

  00016	0f af 4d 10	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 102  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 2b		 jb	 SHORT $LN9@Deallocate

; 103  : 		{	// deallocate large block
; 104  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 105  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	a8 1f		 test	 al, 31			; 0000001fH
  00027	0f 85 00 00 00
	00		 jne	 __invalid_parameter_noinfo_noreturn

; 106  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 107  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 108  : 		const uintptr_t _Ptr_container =
; 109  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]

; 110  : 
; 111  :  #ifdef _DEBUG
; 112  : 		// If the following asserts, it likely means that we are performing
; 113  : 		// an aligned delete on memory coming from an unaligned allocation.
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 115  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 116  : 				_BIG_ALLOCATION_SENTINEL);
; 117  :  #endif /* _DEBUG */
; 118  : 
; 119  : 		// Extra paranoia on aligned allocation/deallocation
; 120  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00030	3b c8		 cmp	 ecx, eax
  00032	0f 83 00 00 00
	00		 jae	 __invalid_parameter_noinfo_noreturn

; 121  : 
; 122  :  #ifdef _DEBUG
; 123  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 124  : 			<= _Ptr_user - _Ptr_container);
; 125  : 
; 126  :  #else /* _DEBUG */
; 127  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

  00038	2b c1		 sub	 eax, ecx
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	0f 82 00 00 00
	00		 jb	 __invalid_parameter_noinfo_noreturn

; 128  : 			<= _Ptr_user - _Ptr_container);
; 129  :  #endif /* _DEBUG */
; 130  : 
; 131  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  00043	83 f8 23	 cmp	 eax, 35			; 00000023H
  00046	76 08		 jbe	 SHORT $LN3@Deallocate
  00048	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 132  : 			<= _NON_USER_SIZE);
; 133  : 
; 134  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 135  : 		}
; 136  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 137  : 
; 138  : 	::operator delete(_Ptr);

  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00056	83 c4 04	 add	 esp, 4

; 139  : 	}

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 54   : 	{	// allocate storage for _Count elements of size _Sz

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 55   : 	void *_Ptr = 0;
; 56   : 
; 57   : 	if (_Count == 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN2@Allocate

; 58   : 		return (_Ptr);

  0000a	33 c0		 xor	 eax, eax

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@Allocate:

; 59   : 
; 60   : 	// check overflow of multiply
; 61   : 	if ((size_t)(-1) / _Sz < _Count)

  0000e	83 c8 ff	 or	 eax, -1
  00011	33 d2		 xor	 edx, edx
  00013	f7 75 0c	 div	 DWORD PTR __Sz$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	0f 82 00 00 00
	00		 jb	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 62   : 		_Xbad_alloc();	// report no memory
; 63   : 	const size_t _User_size = _Count * _Sz;

  0001e	0f af 4d 0c	 imul	 ecx, DWORD PTR __Sz$[ebp]

; 64   : 
; 65   :  #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Try_aligned_allocation$[ebp], 0
  00026	74 31		 je	 SHORT $LN4@Allocate
  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 29		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00030	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 72   : 		if (_Block_size <= _User_size)

  00033	3b c1		 cmp	 eax, ecx
  00035	0f 86 00 00 00
	00		 jbe	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc

; 73   : 			_Xbad_alloc();	// report no memory
; 74   : 		const uintptr_t _Ptr_container =
; 75   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 04	 add	 esp, 4

; 76   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 77   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0004e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00051	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 78   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 79   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00054	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@Allocate:

; 80   : 
; 81   :  #ifdef _DEBUG
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 83   :  #endif /* _DEBUG */
; 84   : 		}
; 85   : 	else
; 86   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 87   : 
; 88   : 		{	// allocate normal block
; 89   : 		_Ptr = ::operator new(_User_size);

  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	83 c4 04	 add	 esp, 4

; 90   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  00062	85 c0		 test	 eax, eax
  00064	0f 84 00 00 00
	00		 je	 __invalid_parameter_noinfo_noreturn

; 91   : 		}
; 92   : 	return (_Ptr);
; 93   : 	}

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 565  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 566  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 553  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00012	5d		 pop	 ebp

; 553  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?find@?$char_traits@D@std@@SAPBDPBDIABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT

; 545  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 02		 jne	 SHORT $LN3@find

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
$LN3@find:

; 546  : 		return (_Count == 0 ? (const _Elem *)0

  0000c	50		 push	 eax
  0000d	8b 45 10	 mov	 eax, DWORD PTR __Ch$[ebp]
  00010	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00017	e8 00 00 00 00	 call	 _memchr
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 530  : 		return (_Count == 0 ? _First1

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

  0000f	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00012	5d		 pop	 ebp

; 530  : 		return (_Count == 0 ? _First1

  00013	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 523  : 		return (*_First == 0 ? 0

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 04		 jne	 SHORT $LN3@length
  0000b	33 c0		 xor	 eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

  0000f	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL5@length:
  00012	8a 08		 mov	 cl, BYTE PTR [eax]
  00014	40		 inc	 eax
  00015	84 c9		 test	 cl, cl
  00017	75 f9		 jne	 SHORT $LL5@length
  00019	2b c2		 sub	 eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 516  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 517  : 		return (_Count == 0 ? 0

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 04		 jne	 SHORT $LN3@compare
  0000a	33 c0		 xor	 eax, eax

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN3@compare:

; 517  : 		return (_Count == 0 ? 0

  0000e	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR __First2$[ebp]
  00015	83 e9 04	 sub	 ecx, 4
  00018	72 17		 jb	 SHORT $LN7@compare
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL8@compare:
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	3b 06		 cmp	 eax, DWORD PTR [esi]
  00024	75 10		 jne	 SHORT $LN6@compare
  00026	83 c2 04	 add	 edx, 4
  00029	83 c6 04	 add	 esi, 4
  0002c	83 e9 04	 sub	 ecx, 4
  0002f	73 ef		 jae	 SHORT $LL8@compare
$LN7@compare:
  00031	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00034	74 35		 je	 SHORT $LN5@compare
$LN6@compare:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	3a 06		 cmp	 al, BYTE PTR [esi]
  0003a	75 27		 jne	 SHORT $LN9@compare
  0003c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0003f	74 2a		 je	 SHORT $LN5@compare
  00041	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00044	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00047	75 1a		 jne	 SHORT $LN9@compare
  00049	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0004c	74 1d		 je	 SHORT $LN5@compare
  0004e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00051	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00054	75 0d		 jne	 SHORT $LN9@compare
  00056	83 f9 ff	 cmp	 ecx, -1
  00059	74 10		 je	 SHORT $LN5@compare
  0005b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0005e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00061	74 08		 je	 SHORT $LN5@compare
$LN9@compare:
  00063	1b c0		 sbb	 eax, eax
  00065	83 c8 01	 or	 eax, 1
  00068	5e		 pop	 esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN5@compare:

; 517  : 		return (_Count == 0 ? 0

  0006b	33 c0		 xor	 eax, eax
  0006d	5e		 pop	 esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1834 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);
; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1839 :         __crt_va_end(_ArgList);
; 1840 :         return _Result;
; 1841 :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsprintf_s PROC					; COMDAT

; 1515 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	ff 30		 push	 DWORD PTR [eax]
  0001b	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

  00020	83 c9 ff	 or	 ecx, -1
  00023	83 c4 1c	 add	 esp, 28			; 0000001cH
  00026	85 c0		 test	 eax, eax
  00028	0f 48 c1	 cmovs	 eax, ecx

; 1516 :         return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1517 :     }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_vsprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1493 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1499 : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1473 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 10	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000b	6a ff		 push	 -1
  0000d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00010	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	83 c9 01	 or	 ecx, 1
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1474 :     #pragma warning(push)
; 1475 :     #pragma warning(disable: 4996) // Deprecation
; 1476 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);
; 1477 :     #pragma warning(pop)
; 1478 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 90   :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 20584: #endif

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\michel\desktop\source\gameserver\source\protocol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 20584: #endif

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
